```diff
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 08521a58a..833266684 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -22,6 +22,7 @@
 
     <protected-broadcast android:name="android.intent.action.SHOW_MISSED_CALLS_NOTIFICATION"/>
     <protected-broadcast android:name="com.android.server.telecom.MESSAGE_SENT"/>
+    <protected-broadcast android:name="android.telecom.action.CALL_BACK"/>
 
     <uses-permission android:name="android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS"/>
 
@@ -68,6 +69,8 @@
     <uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT"/>
     <uses-permission android:name="android.permission.ACCESS_LAST_KNOWN_CELL_ID"/>
     <uses-permission android:name="android.permission.STATUS_BAR_SERVICE" />
+    <!-- Used for checking appops permissions with PermissionManager. -->
+    <uses-permission android:name="android.permission.UPDATE_APP_OPS_STATS" />
 
     <permission android:name="android.permission.BROADCAST_CALLLOG_INFO"
          android:label="Broadcast the call type/duration information"
diff --git a/flags/Android.bp b/flags/Android.bp
index 6f9caae6d..723a17853 100644
--- a/flags/Android.bp
+++ b/flags/Android.bp
@@ -34,7 +34,6 @@ aconfig_declarations {
         "telecom_calls_manager_flags.aconfig",
         "telecom_anomaly_report_flags.aconfig",
         "telecom_callaudiomodestatemachine_flags.aconfig",
-        "telecom_calllog_flags.aconfig",
         "telecom_resolve_hidden_dependencies.aconfig",
         "telecom_bluetoothroutemanager_flags.aconfig",
         "telecom_work_profile_flags.aconfig",
@@ -44,8 +43,7 @@ aconfig_declarations {
         "telecom_bluetoothdevicemanager_flags.aconfig",
         "telecom_non_critical_security_flags.aconfig",
         "telecom_headless_system_user_mode.aconfig",
-        "telecom_session_flags.aconfig",
         "telecom_metrics_flags.aconfig",
-        "telecom_voip_flags.aconfig",
+        "telecom_integrated_call_log.aconfig",
     ],
 }
diff --git a/flags/telecom_anomaly_report_flags.aconfig b/flags/telecom_anomaly_report_flags.aconfig
index bc248c80e..7d3c002a6 100644
--- a/flags/telecom_anomaly_report_flags.aconfig
+++ b/flags/telecom_anomaly_report_flags.aconfig
@@ -1,14 +1,6 @@
 package: "com.android.server.telecom.flags"
 container: "system"
 
-# OWNER=tjstuart TARGET=24Q3
-flag {
-  name: "gen_anom_report_on_focus_timeout"
-  namespace: "telecom"
-  description: "When getCurrentFocusCall times out, generate an anom. report"
-  bug: "309541253"
-}
-
 # OWNER=tjstuart TARGET=25Q2
 flag {
   name: "disconnect_self_managed_stuck_startup_calls"
diff --git a/flags/telecom_api_flags.aconfig b/flags/telecom_api_flags.aconfig
index 2dfd878a4..bc0c3d254 100644
--- a/flags/telecom_api_flags.aconfig
+++ b/flags/telecom_api_flags.aconfig
@@ -82,3 +82,27 @@ flag {
   description: "Allow system apps such as accessibility to accept and end VOIP calls."
   bug: "353579043"
 }
+
+# OWNER=grantmenke TARGET=25Q4
+flag {
+  name: "reuse_original_conn_remote_conf_api"
+  is_exported: true
+  namespace: "telecom"
+  description: "Allow reusing the telephony connection when creating a new conference call."
+  bug: "391889544"
+  metadata {
+      purpose: PURPOSE_FEATURE
+  }
+}
+
+# OWNER=tgunn TARGET=26Q2
+flag {
+  name: "call_connected_indicator_preference"
+  is_exported: true
+  namespace: "telecom"
+  description: "Add call connected indicator support for playing a tone or starting a vibration"
+  bug: "146090790"
+  metadata {
+      purpose: PURPOSE_FEATURE
+  }
+}
diff --git a/flags/telecom_bluetoothdevicemanager_flags.aconfig b/flags/telecom_bluetoothdevicemanager_flags.aconfig
index 1c8bd0c10..5dd5831dd 100644
--- a/flags/telecom_bluetoothdevicemanager_flags.aconfig
+++ b/flags/telecom_bluetoothdevicemanager_flags.aconfig
@@ -18,13 +18,3 @@ flag {
     purpose: PURPOSE_BUGFIX
   }
 }
-# OWNER=grantmenke TARGET=25Q2
-flag {
-  name: "skip_baseline_switch_when_route_not_bluetooth"
-  namespace: "telecom"
-  description: "Only switch back to baseline if the call audio is currently routed to bluetooth"
-  bug: "333417369"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
\ No newline at end of file
diff --git a/flags/telecom_broadcast_flags.aconfig b/flags/telecom_broadcast_flags.aconfig
index 831437633..df31a3409 100644
--- a/flags/telecom_broadcast_flags.aconfig
+++ b/flags/telecom_broadcast_flags.aconfig
@@ -1,10 +1,4 @@
 package: "com.android.server.telecom.flags"
 container: "system"
 
-# OWNER=tgunn TARGET=24Q3
-flag {
-  name: "is_new_outgoing_call_broadcast_unblocking"
-  namespace: "telecom"
-  description: "When set, the ACTION_NEW_OUTGOING_CALL broadcast is unblocking."
-  bug: "224550864"
-}
\ No newline at end of file
+# This file intentionally left blank to avoid compilation errors due to removed flag.
diff --git a/flags/telecom_call_filtering_flags.aconfig b/flags/telecom_call_filtering_flags.aconfig
index 693d727b0..d80cfa3b9 100644
--- a/flags/telecom_call_filtering_flags.aconfig
+++ b/flags/telecom_call_filtering_flags.aconfig
@@ -7,15 +7,4 @@ flag {
   namespace: "telecom"
   description: "Gates whether to still perform Dnd filter when phone account has skip_filter call extra."
   bug: "222333869"
-}
-
-# OWNER=tjstuart TARGET=25Q1
-flag {
-  name: "check_completed_filters_on_timeout"
-  namespace: "telecom"
-  description: "If the Filtering Graph times out, combine the finished results"
-  bug: "364946812"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
+}
\ No newline at end of file
diff --git a/flags/telecom_call_flags.aconfig b/flags/telecom_call_flags.aconfig
index 0000f3292..2a133c4e3 100644
--- a/flags/telecom_call_flags.aconfig
+++ b/flags/telecom_call_flags.aconfig
@@ -16,13 +16,6 @@ flag {
   bug: "309541257"
 }
 
-flag {
-  name: "cache_call_audio_callbacks"
-  namespace: "telecom"
-  description: "cache call audio callbacks if the service is not available and execute when set"
-  bug: "321369729"
-}
-
 # OWNER=breadley TARGET=24Q4
 flag {
   name: "cache_call_events"
@@ -45,43 +38,74 @@ flag {
     }
 }
 
-# OWNER=breadley TARGET=24Q4
+# OWNER=breadley TARGET=25Q2
+flag {
+  name: "enable_respond_via_sms_manager_async"
+  namespace: "telecom"
+  description: "Move RespondViaSmsManager to async thread"
+  bug: "328013578"
+  metadata {
+      purpose: PURPOSE_BUGFIX
+    }
+}
+
+# OWNER=pmadapurmath TARGET=25Q4
+flag {
+  name: "call_sequencing_call_resume_failed"
+  namespace: "telecom"
+  description: "Connection event received when a call resume fails"
+  bug: "390116261"
+}
+
+# OWNER=pmadapurmath TARGET=25Q4
 flag {
-  name: "use_stream_voice_call_tones"
+  name: "revert_disconnecting_during_merge"
   namespace: "telecom"
-  description: "Use STREAM_VOICE_CALL only for ToneGenerator"
-  bug: "363262590"
+  description: "When a user tries hanging up a call during a call merge, the hangup will be ignore but the call will be stuck in disconnecting. We prevent the call state from being placed into disconnecting."
+  bug: "409455144"
+}
+
+# OWNER=tjstuart TARGET=25Q3
+flag {
+  name: "cleanup_verify_call_state"
+  namespace: "telecom"
+  description: "When a call disconnects, finish the VerifyCallStateChangeTransaction if the target state is not reached"
+  bug: "404957140"
   metadata {
       purpose: PURPOSE_BUGFIX
     }
 }
 
-# OWNER=tjstuart TARGET=25Q1
+# OWNER=pmadapurmath TARGET=25Q4
 flag {
-  name: "remap_transactional_capabilities"
+  name: "bypass_hold_for_ecc_dial"
   namespace: "telecom"
-  description: "Transactional call capabilities need to be remapped to Connection capabilities"
-  bug: "366063695"
+  description: "When making room for an outgoing emergency call, don't send a hold request when the live call and emergency call phone accounts are the same. We will let this be handled in Telephony instead."
+  bug: "419729271"
   metadata {
       purpose: PURPOSE_BUGFIX
     }
 }
 
-# OWNER=breadley TARGET=25Q2
+# OWNER=tgunn TARGET=25Q3
 flag {
-  name: "enable_respond_via_sms_manager_async"
+  name: "voip_dnd_focus"
   namespace: "telecom"
-  description: "Move RespondViaSmsManager to async thread"
-  bug: "328013578"
+  description: "Ensure when call filtering is skipped that we do not use the DND filter results since they were not calculated"
+  bug: "415288638"
   metadata {
       purpose: PURPOSE_BUGFIX
     }
 }
 
-# OWNER=pmadapurmath TARGET=25Q4
+# OWNER=tjstuart TARGET=25Q4
 flag {
-  name: "call_sequencing_call_resume_failed"
+  name: "echo_abort_transactional_outgoing"
   namespace: "telecom"
-  description: "Connection event received when a call resume fails"
-  bug: "390116261"
+  description: "Fixes bug where clients are not informed of aborted outgoing calls"
+  bug: "354122175"
+  metadata {
+      purpose: PURPOSE_BUGFIX
+    }
 }
+
diff --git a/flags/telecom_callaudioroutestatemachine_flags.aconfig b/flags/telecom_callaudioroutestatemachine_flags.aconfig
index c0edf7f4b..cda223317 100644
--- a/flags/telecom_callaudioroutestatemachine_flags.aconfig
+++ b/flags/telecom_callaudioroutestatemachine_flags.aconfig
@@ -17,14 +17,6 @@ flag {
   bug: "306395598"
 }
 
-# OWNER=pmadapurmath TARGET=25Q1
-flag {
-  name: "resolve_active_bt_routing_and_bt_timing_issue"
-  namespace: "telecom"
-  description: "Resolve the active BT device routing and flaky timing issues noted in BT routing."
-  bug: "372029371"
-}
-
 # OWNER=tgunn TARGET=24Q3
 flag {
   name: "ensure_audio_mode_updates_on_foreground_call_change"
@@ -33,14 +25,6 @@ flag {
   bug: "289861657"
 }
 
-# OWNER=pmadapurmath TARGET=24Q1
-flag {
-  name: "ignore_auto_route_to_watch_device"
-  namespace: "telecom"
-  description: "Ignore auto routing to wearable devices."
-  bug: "294378768"
-}
-
 # OWNER=pmadapurmath TARGET=24Q3
 flag {
   name: "transit_route_before_audio_disconnect_bt"
@@ -49,14 +33,6 @@ flag {
   bug: "306113816"
 }
 
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "call_audio_communication_device_refactor"
-  namespace: "telecom"
-  description: "Refactor call audio set/clear communication device and include unsupported routes."
-  bug: "308968392"
-}
-
 # OWNER=pmadapurmath TARGET=24Q3
 flag {
   name: "communication_device_protected_by_lock"
@@ -81,77 +57,6 @@ flag {
   bug: "301695370"
 }
 
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "clear_communication_device_after_audio_ops_complete"
-  namespace: "telecom"
-  description: "Clear the requested communication device after the audio operations are completed."
-  bug: "315865533"
-}
-
-# OWNER=tgunn TARGET=24Q3
-flag {
-  name: "dont_use_communication_device_tracker"
-  namespace: "telecom"
-  description: "Do not use the communication device tracker with useRefactoredAudioRouteSwitching."
-  bug: "346472575"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "resolve_switching_bt_devices_computation"
-  namespace: "telecom"
-  description: "Update switching bt devices based on arbitrary device chosen if no device is specified."
-  bug: "333751408"
-}
-
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "early_update_internal_call_audio_state"
-  namespace: "telecom"
-  description: "Update internal call audio state before sending updated state to ICS"
-  bug: "335538831"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
-# OWNER=pmadapurmath TARGET=25Q1
-flag {
-  name: "new_audio_path_speaker_broadcast_and_unfocused_routing"
-  namespace: "telecom"
-  description: "Replace the speaker broadcasts with the communication device changed listener and resolve baseline routing issues when a call ends."
-  bug: "353419513"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
-# OWNER=pmadapurmath TARGET=25Q2
-flag {
-  name: "fix_user_request_baseline_route_video_call"
-  namespace: "telecom"
-  description: "Ensure that audio is routed out of speaker in a video call when we receive USER_SWITCH_BASELINE_ROUTE."
-  bug: "374037591"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
-# OWNER=tgunn TARGET=25Q2
-flag {
-  name: "only_clear_communication_device_on_inactive"
-  namespace: "telecom"
-  description: "Only clear the communication device when transitioning to an inactive route."
-  bug: "376781369"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
 # OWNER=tgunn TARGET=25Q2
 flag {
   name: "check_device_type_on_route_change"
@@ -173,36 +78,3 @@ flag {
     purpose: PURPOSE_BUGFIX
   }
 }
-
-# OWNER=pmadapurmath TARGET=25Q3
-flag {
-  name: "update_preferred_audio_device_logic"
-  namespace: "telecom"
-  description: "Change the use of preferred device for strategy to only use it at the start of the call and include relevant syncing with AudioManager#getCommunicationDevice"
-  bug: "377345692"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
-# OWNER=pmadapurmath TARGET=25Q3
-flag {
-  name: "call_audio_routing_performance_improvemenent"
-  namespace: "telecom"
-  description: "Change the handler to use the main looper to improve performance with processing messages from the message queue"
-  bug: "383466267"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
-# OWNER=pmadapurmath TARGET=25Q3
-flag {
-  name: "maybe_default_speaker_after_unhold"
-  namespace: "telecom"
-  description: "If the call audio route was on speaker and the call is held/unheld, ensure that we route back to speaker."
-  bug: "406898224"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
diff --git a/flags/telecom_calllog_flags.aconfig b/flags/telecom_calllog_flags.aconfig
deleted file mode 100644
index c0eebf16c..000000000
--- a/flags/telecom_calllog_flags.aconfig
+++ /dev/null
@@ -1,18 +0,0 @@
-package: "com.android.server.telecom.flags"
-container: "system"
-
-# OWNER=qingzhong TARGET=24Q2
-flag {
-  name: "telecom_log_external_wearable_calls"
-  namespace: "telecom"
-  description: "log external call if current device is a wearable one"
-  bug: "292600751"
-}
-
-# OWNER=ranamouawi TARGET=24Q2
-flag {
-  name: "telecom_skip_log_based_on_extra"
-  namespace: "telecom"
-  description: "skipping logging a call based on passed extra"
-  bug: "295530944"
-}
diff --git a/flags/telecom_calls_manager_flags.aconfig b/flags/telecom_calls_manager_flags.aconfig
index 6b8b772b7..ddcaa455a 100644
--- a/flags/telecom_calls_manager_flags.aconfig
+++ b/flags/telecom_calls_manager_flags.aconfig
@@ -1,22 +1,6 @@
 package: "com.android.server.telecom.flags"
 container: "system"
 
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "use_improved_listener_order"
-  namespace: "telecom"
-  description: "Make InCallController the first listener to trigger"
-  bug: "24244713"
-}
-
-# OWNER=tjstuart TARGET=24Q3
-flag {
-  name: "fix_audio_flicker_for_outgoing_calls"
-  namespace: "telecom"
-  description: "This fix ensures the MO calls won't switch from Active to Quite b/c setDialing was not called"
-  bug: "309540769"
-}
-
 # OWNER=breadley TARGET=24Q3
 flag {
   name: "enable_call_sequencing"
@@ -25,23 +9,34 @@ flag {
   bug: "327038818"
 }
 
-# OWNER=tjstuart TARGET=24Q4
+# OWNER=grantmenke TARGET=25Q3
+flag {
+  name: "prevent_self_managed_call_logging"
+  namespace: "telecom"
+  description: "Prevent self managed calls from logging to the call log"
+  bug: "405942024"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+}
+
+# OWNER=pmadapurmath TARGET=25Q3
 flag {
-  name: "transactional_hold_disconnects_unholdable"
+  name: "allow_call_on_same_connection_mgr"
   namespace: "telecom"
-  description: "Disconnect ongoing unholdable calls for CallControlCallbacks"
-  bug: "340621152"
+  description: "If two incoming calls are received at the same time from the same connection service, allow the CS to handle the second call."
+  bug: "414261900"
   metadata {
     purpose: PURPOSE_BUGFIX
   }
 }
 
-# OWNER=tgunn TARGET=25Q2
+# OWNER=breadley TARGET=25Q3
 flag {
-  name: "enable_call_audio_watchdog"
+  name: "select_phone_account_before_making_room"
   namespace: "telecom"
-  description: "Enables tracking of audio resources for voip calls to aid in diagnostics."
-  bug: "384570270"
+  description: "Select the PhoneAccount before making room for the call"
+  bug: "417370866"
   metadata {
     purpose: PURPOSE_BUGFIX
   }
diff --git a/flags/telecom_connection_service_wrapper_flags.aconfig b/flags/telecom_connection_service_wrapper_flags.aconfig
index 8e77af516..3a300c6cc 100644
--- a/flags/telecom_connection_service_wrapper_flags.aconfig
+++ b/flags/telecom_connection_service_wrapper_flags.aconfig
@@ -1,14 +1,6 @@
 package: "com.android.server.telecom.flags"
 container: "system"
 
-# OWNER=grantmenke TARGET=24Q2
-flag {
-  name: "updated_rcs_call_count_tracking"
-  namespace: "telecom"
-  description: "Ensure that the associatedCallCount of CS and RCS is accurately being tracked."
-  bug: "286154316"
-}
-
 # OWNER=tjstuart TARGET=24Q4
 flag {
   name: "csw_service_interface_is_null"
diff --git a/flags/telecom_default_phone_account_flags.aconfig b/flags/telecom_default_phone_account_flags.aconfig
index 161b67479..0004e5793 100644
--- a/flags/telecom_default_phone_account_flags.aconfig
+++ b/flags/telecom_default_phone_account_flags.aconfig
@@ -1,14 +1,6 @@
 package: "com.android.server.telecom.flags"
 container: "system"
 
-# OWNER=tjstuart TARGET=24Q3
-flag {
-  name: "only_update_telephony_on_valid_sub_ids"
-  namespace: "telecom"
-  description: "For testing purposes, only update Telephony when the default calling subId is non-zero"
-  bug: "234846282"
-}
-
 # OWNER=tjstuart TARGET=24Q3
 flag {
   name: "telephony_has_default_but_telecom_does_not"
diff --git a/flags/telecom_incallservice_flags.aconfig b/flags/telecom_incallservice_flags.aconfig
index c95816a0c..d3fb8c1e7 100644
--- a/flags/telecom_incallservice_flags.aconfig
+++ b/flags/telecom_incallservice_flags.aconfig
@@ -9,30 +9,6 @@ flag {
   bug: "282113261"
 }
 
-# OWNER=pmadapurmath TARGET=24Q2
-flag {
-  name: "ecc_keyguard"
-  namespace: "telecom"
-  description: "Ensure that users are able to return to call from keyguard UI for ECC"
-  bug: "306582821"
-}
-
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "separately_bind_to_bt_incall_service"
-  namespace: "telecom"
-  description: "Binding/Unbinding to BluetoothInCallServices in proper time to improve call audio"
-  bug: "306395598"
-}
-
-# OWNER=pmadapurmath TARGET=24Q4
-flag {
-  name: "on_call_endpoint_changed_ics_on_connected"
-  namespace: "telecom"
-  description: "Ensure onCallEndpointChanged is sent to ICS when it connects."
-  bug: "348297436"
-}
-
 # OWNER=tjstuart TARGET=24Q4
 flag {
   name: "do_not_send_call_to_null_ics"
diff --git a/flags/telecom_integrated_call_log.aconfig b/flags/telecom_integrated_call_log.aconfig
new file mode 100644
index 000000000..f75159a47
--- /dev/null
+++ b/flags/telecom_integrated_call_log.aconfig
@@ -0,0 +1,11 @@
+package: "com.android.server.telecom.flags"
+container: "system"
+
+# OWNER=huiwang TARGET=25Q4
+flag {
+  name: "integrated_call_logs"
+  namespace: "telecom"
+  description: "Support integrated call logs"
+  bug: "420711866"
+}
+
diff --git a/flags/telecom_metrics_flags.aconfig b/flags/telecom_metrics_flags.aconfig
index e582e9ecc..83b28a988 100644
--- a/flags/telecom_metrics_flags.aconfig
+++ b/flags/telecom_metrics_flags.aconfig
@@ -8,3 +8,14 @@ flag {
   description: "Support telecom metrics"
   bug: "362394177"
 }
+
+# OWNER=pmadapurmath TARGET=25Q3
+flag {
+  name: "call_sequencing_metrics"
+  namespace: "telecom"
+  description: "Support telecom call sequencing metrics"
+  bug: "384949208"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+}
diff --git a/flags/telecom_profile_user_flags.aconfig b/flags/telecom_profile_user_flags.aconfig
index feee07d67..b11b78ba0 100644
--- a/flags/telecom_profile_user_flags.aconfig
+++ b/flags/telecom_profile_user_flags.aconfig
@@ -1,13 +1,2 @@
 package: "com.android.server.telecom.flags"
 container: "system"
-
-# OWNER=huiwang TARGET=24Q3
-flag {
-  name: "profile_user_support"
-  namespace: "telecom"
-  description: "Fix issues related to the profile user like private profile"
-  bug: "326270861"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
diff --git a/flags/telecom_resolve_hidden_dependencies.aconfig b/flags/telecom_resolve_hidden_dependencies.aconfig
index e5bb1fb3e..db53d6de2 100644
--- a/flags/telecom_resolve_hidden_dependencies.aconfig
+++ b/flags/telecom_resolve_hidden_dependencies.aconfig
@@ -10,6 +10,17 @@ flag {
     bug: "323414215"
 }
 
+# OWNER=tgunn TARGET=26Q2
+flag {
+  name: "resolve_hidden_dependencies_two"
+  namespace: "telecom"
+  description: "Resolve hidden dependencies in Telecom related to mainline"
+  bug: "405460896"
+  metadata {
+    purpose: PURPOSE_FEATURE
+  }
+}
+
 flag {
     name: "telecom_mainline_blocked_numbers_manager"
     namespace: "telecom"
diff --git a/flags/telecom_ringer_flag_declarations.aconfig b/flags/telecom_ringer_flag_declarations.aconfig
index f954b09a2..f126bf349 100644
--- a/flags/telecom_ringer_flag_declarations.aconfig
+++ b/flags/telecom_ringer_flag_declarations.aconfig
@@ -7,24 +7,4 @@ flag {
   namespace: "telecom"
   description: "Gates whether to use a serialized, device-specific ring vibration."
   bug: "282113261"
-}
-
-# OWNER=grantmenke TARGET=24Q4
-flag {
-  name: "ensure_in_car_ringing"
-  namespace: "telecom"
-  description: "Gates whether to ensure that when a user is in their car, they are able to hear ringing for an incoming call."
-  bug: "348708398"
-}
-
-
-# OWNER=tjstuart TARGET=25Q1
-flag {
-  name: "get_ringer_mode_anom_report"
-  namespace: "telecom"
-  description: "getRingerMode & getRingerModeInternal should return the same val when dnd is off"
-  bug: "307389562"
-    metadata {
-      purpose: PURPOSE_BUGFIX
-    }
 }
\ No newline at end of file
diff --git a/flags/telecom_session_flags.aconfig b/flags/telecom_session_flags.aconfig
deleted file mode 100644
index 5b8075ce4..000000000
--- a/flags/telecom_session_flags.aconfig
+++ /dev/null
@@ -1,13 +0,0 @@
-package: "com.android.server.telecom.flags"
-container: "system"
-
-# OWNER=breadley TARGET=25Q1
-flag {
-  name: "end_session_improvements"
-  namespace: "telecom"
-  description: "Ensure that ending a session doesnt cause a stack overflow"
-  bug: "370349160"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
\ No newline at end of file
diff --git a/flags/telecom_voip_flags.aconfig b/flags/telecom_voip_flags.aconfig
deleted file mode 100644
index 67635e9f3..000000000
--- a/flags/telecom_voip_flags.aconfig
+++ /dev/null
@@ -1,13 +0,0 @@
-package: "com.android.server.telecom.flags"
-container: "system"
-
-# OWNER=tjstuart TARGET=25Q2
-flag {
-  name: "voip_call_monitor_refactor"
-  namespace: "telecom"
-  description: "VoipCallMonitor reworked to handle multi calling scenarios for the same app"
-  bug: "381129034"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
\ No newline at end of file
diff --git a/flags/telecom_work_profile_flags.aconfig b/flags/telecom_work_profile_flags.aconfig
index 1891423ce..df31a3409 100644
--- a/flags/telecom_work_profile_flags.aconfig
+++ b/flags/telecom_work_profile_flags.aconfig
@@ -1,10 +1,4 @@
 package: "com.android.server.telecom.flags"
 container: "system"
 
-# OWNER=pmadapurmath TARGET=24Q3
-flag {
-  name: "associated_user_refactor_for_work_profile"
-  namespace: "telecom"
-  description: "Redefines the associated user for calls in the context of work profile support (U+)"
-  bug: "315035693"
-}
\ No newline at end of file
+# This file intentionally left blank to avoid compilation errors due to removed flag.
diff --git a/proto/pulled_atoms.proto b/proto/pulled_atoms.proto
index a72e847d9..85d3c4ffb 100644
--- a/proto/pulled_atoms.proto
+++ b/proto/pulled_atoms.proto
@@ -16,6 +16,10 @@ message PulledAtoms {
   optional int64 telecom_error_stats_pull_timestamp_millis = 8;
   repeated TelecomEventStats telecom_event_stats = 9;
   optional int64 telecom_event_stats_pull_timestamp_millis = 10;
+  repeated CallSequencingStats call_sequencing_stats = 11;
+  optional int64 call_sequencing_stats_pull_timestamp_millis = 12;
+  repeated CallSequencingOperationStats call_sequencing_operation_stats = 13;
+  optional int64 call_sequencing_operations_stats_pull_timestamp_millis = 14;
 }
 
 /**
@@ -145,3 +149,92 @@ message TelecomEventStats {
     // The number of times this event occurs
     optional int32 count = 4;
 }
+
+/**
+ * Pulled atom to capture general stats of Telecom call sequencing information
+ */
+message CallSequencingStats {
+  // The value should be converted to android.telecom.CallTypeEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 primary_call_type = 1;
+
+  // The value should be converted to android.telecom.CallTypeEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 secondary_call_type = 2;
+
+  // True if the primary call is an emergency call
+  optional bool is_primary_call_emergency = 3;
+
+  // True if the secondary call is an emergency call
+  optional bool is_secondary_call_emergency = 4;
+
+  // True if this event is tracking a secondary call
+  optional bool has_secondary = 5;
+
+  // True if primary and secondary call phone accounts are the same
+  optional bool is_same_phone_account = 6;
+
+  // Average elapsed time between CALL_STATE_ACTIVE to CALL_STATE_DISCONNECTED.
+  optional int32 average_duration_ms = 7;
+
+  // The number of times this stat occurs
+  optional int32 count = 8;
+}
+
+/**
+ * Pulled atom to capture stats of Telecom call sequencing operations
+ */
+message CallSequencingOperationStats {
+  // The value should be converted to android.telecom.CallOperationTypeEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 call_operation = 1;
+
+  // The value should be converted to android.telecom.CallStateEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 focus_call_state = 2;
+
+  // The value should be converted to android.telecom.CallStateEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 source_call_state = 3;
+
+  // The value should be converted to android.telecom.CallTypeEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 focus_call_type = 4;
+
+  // The value should be converted to android.telecom.CallTypeEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 source_call_type = 5;
+
+  // Carrier name of focus call. This should always be -1/unknown for
+  // the private space calls
+  optional int32 focus_call_carrier_id = 6;
+
+  // Carrier name of the source call. This should always be -1/unknown for
+  // the private space calls or if source call isn’t defined
+  optional int32 source_call_carrier_id = 7;
+
+  // UID of the package to init the call. This should always be -1/unknown for
+  // the private space calls
+  optional int32 focus_call_id = 8;
+
+  // UID of the package to init the call. This should always be -1/unknown for
+  // the private space calls or if source call isn’t defined
+  optional int32 source_call_uid = 9;
+
+  // True if the focus call is an emergency call
+  optional bool is_focus_call_emergency = 10;
+
+  // True if the source call is an emergency call
+  optional bool is_source_call_emergency = 11;
+
+  // The value should be converted to android.telecom.CallOperationResultEnum
+  // From frameworks/proto_logging/stats/enums/telecomm/enums.proto
+  optional int32 operation_result = 12;
+
+  // True if source call (provided that this is present) and focus call
+  // are from same phone accounts
+  optional bool is_same_phone_account = 13;
+
+  // Duration (ms) taken for operation to complete
+  optional int32 operation_duration_ms = 14;
+}
\ No newline at end of file
diff --git a/res/layout/preference_multiline_title_edittext.xml b/res/layout/preference_multiline_title_edittext.xml
new file mode 100644
index 000000000..380cb91e0
--- /dev/null
+++ b/res/layout/preference_multiline_title_edittext.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:minHeight="?android:attr/listPreferredItemHeightSmall" android:gravity="center_vertical"
+    android:paddingStart="?android:attr/listPreferredItemPaddingStart"
+    android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
+    android:background="?android:attr/selectableItemBackground"
+    android:baselineAligned="false">
+
+    <RelativeLayout
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:paddingTop="16dp"
+        android:paddingBottom="16dp">
+
+        <TextView
+            android:id="@android:id/title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:singleLine="false"
+            android:textAppearance="?android:attr/textAppearanceListItem" />
+        <TextView
+            android:id="@android:id/summary"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_below="@android:id/title"
+            android:layout_alignStart="@android:id/title"
+            android:layout_marginTop="2dp"
+            android:textAppearance="?android:attr/textAppearanceListItemSecondary"
+            android:textColor="?android:attr/textColorSecondary"
+            android:maxLines="4" />
+    </RelativeLayout>
+
+    <LinearLayout
+        android:id="@android:id/widget_frame"
+        android:layout_width="wrap_content"
+        android:layout_height="match_parent"
+        android:gravity="center_vertical"
+        android:orientation="vertical" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/res/values-af/strings.xml b/res/values-af/strings.xml
index 0ab86e222..1ffa6a607 100644
--- a/res/values-af/strings.xml
+++ b/res/values-af/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Kan nie ’n oproep maak nie omdat daar reeds twee oproepe aan die gang is. Beëindig een van die oproepe of voeg dit saam in ’n konferensie voordat ’n nuwe oproep gemaak word."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Kan nie ’n oproep maak nie omdat daar reeds twee oproepe aan die gang is. Beëindig een van die oproepe voordat ’n nuwe oproep gemaak word."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Kan nie ’n oproep maak nie omdat daar ’n oproep is wat nie aangehou kan word nie. Beëindig die oproep voordat ’n nuwe oproep gemaak word."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Kan nie die aktiewe oproep ruil nie, want dit steun nie aanhou nie. Beëindig die oproep om die oproep wat aanhou aktief te maak."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Kan nie ’n oproep maak nie, aangesien daar ’n onbeantwoorde inkomende oproep is. Beantwoord of weier die inkomende oproep voordat jy ’n nuwe oproep plaas."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Hierdie MMI-kode is nie beskikbaar vir oproepe tussen verskeie rekeninge nie."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Oproep kan nie tydens ’n samevoeging beëindig word nie."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI-kodes kan nie tydens ’n noodoproep geskakel word nie."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Geen apps kan hierdie handeling uitvoer nie."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-stelsel"</string>
 </resources>
diff --git a/res/values-am/strings.xml b/res/values-am/strings.xml
index e42985986..ab9e42218 100644
--- a/res/values-am/strings.xml
+++ b/res/values-am/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ቀድሞውኑ ሁለት ጥሪዎች በሂደት ላይ ስለሆኑ ጥሪ ማድረግ አልተቻለም። አዲስ ጥሪ ከማድረግዎ በፊት ከጥሪዎቹ ላይ የአንዱን ግንኙነት ያቋርጡ ወይም ወደ ጉባዔ ያዋህዷቸው።"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ቀድሞውኑ ሁለት ጥሪዎች በሂደት ላይ ስለሆኑ ጥሪ ማድረግ አልተቻለም። አዲስ ጥሪ ከማድረግዎ በፊት ከጥሪዎቹ የአንዱን ግንኙነት ያቋርጡ።"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ይቆይ ሊደረግ የማይችል ጥሪ በመኖሩ ጥሪ ማድረግ አልተቻለም። አዲስ ጥሪ ከማድረግዎ በፊት የጥሪውን ግንኙነት ያቋርጡ።"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"ገቢር ጥሪውን ማገላበጥ አይቻልም ምክንያቱም ይቆይን አይደግፍም። ይቆይ ላይ ያለውን ጥሪ ገቢር ማድረግ የጥሪን ግንኙነት ያቋርጡ።"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ያልተመለሰ ገቢ ጥሪ ስላለ ጥሪ ማድረግ አይቻልም። አዲስ ጥሪ ከማድረግዎ በፊት ገቢ ጥሪን ይመልሱ ወይም ይዝጉ።"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ይህ MMI ኮድ በርካታ መለያዎች ላይ ላሉ ጥሪዎች አይገኝም።"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ጥሪ በማዋሃድ ወቅት ግንኙነቱ ሊቋረጥ አይችልም።"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI ኮዶች በአደጋ ጥሪ ወቅት መደወል አይችሉም።"</string>
+    <string name="noApplications" msgid="1703149220378476198">"ምንም መተግበሪያዎች ይህን ድርጊት ማከናወን አይችሉም።"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"የAndroid ሥርዓት"</string>
 </resources>
diff --git a/res/values-ar/strings.xml b/res/values-ar/strings.xml
index dcc5cd2b3..a6f0876bd 100644
--- a/res/values-ar/strings.xml
+++ b/res/values-ar/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"لا يمكن إجراء مكالمة لأنّ هناك مكالمتين جاريتين حاليًا. يمكنك إنهاء إحدى المكالمتين أو دمجهما في مكالمة جماعية قبل إجراء مكالمة جديدة."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"لا يمكن إجراء مكالمة لأنّ هناك مكالمتين جاريتين حاليًا. يُرجى إنهاء إحدى المكالمتين قبل إجراء مكالمة جديدة."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"أنت في مكالمة غير قابلة للتعليق، لذا لا يمكن إجراء مكالمة أخرى. يُرجى إنهاء المكالمة الحالية لإجراء مكالمة جديدة."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"لا يمكن تبديل المكالمة النشطة لأنها لا تتيح التعليق. يمكنك إنهاء المكالمة الحالية لتصبح المكالمة المعلَّقة نشطة."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"لا يمكن إجراء مكالمة لأن هناك مكالمة واردة لم يتم الرد عليها. يُرجى الرد على المكالمة الواردة أو رفضها قبل إجراء مكالمة جديدة."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"‏لا يتوفّر رمز MMI هذا للمكالمات على مستوى حسابات متعددة."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"لا يمكن إنهاء الاتصال أثناء مكالمة مدمجة."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"‏لا يمكن الاتصال برموز MMI أثناء إجراء مكالمة طوارئ."</string>
+    <string name="noApplications" msgid="1703149220378476198">"ليست هناك تطبيقات يمكنها تنفيذ هذا الإجراء."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"‏نظام Android"</string>
 </resources>
diff --git a/res/values-as/strings.xml b/res/values-as/strings.xml
index 9d20cd2c6..93f378652 100644
--- a/res/values-as/strings.xml
+++ b/res/values-as/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"কল কৰিব নোৱাৰি, কাৰণ ইতিমধ্যে দুটা কল চলি আছে। এটা নতুন কল কৰাৰ আগতে সেই দুটা কলৰ এটাৰ সংযোগ বিচ্ছিন্ন কৰক অথবা কল দুটা একত্ৰিত কৰি এটা কনফাৰেন্স কললৈ সলনি কৰক।"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"কল কৰিব নোৱাৰি কাৰণ ইতিমধ্যে দুটা কল চলি আছে। এটা নতুন কল কৰাৰ আগতে সেই দুটা কলৰ এটাৰ সংযোগ বিচ্ছিন্ন কৰক।"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"হ’ল্ডত ৰাখিব নোৱাৰা কল এটা চলি থকাৰ বাবে কল কৰিব নোৱাৰি। এটা নতুন কল কৰাৰ আগেয়ে কলটোৰ সংযোগ বিচ্ছিন্ন কৰক।"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"সক্ৰিয় কলটো সলনাসলনি কৰিব নোৱাৰি কাৰণ এইটোৱে হ’ল্ডত ৰখাৰ সুবিধাটো সমৰ্থন নকৰে। হ’ল্ডত ৰখা কলটো সক্ৰিয় কৰিবলৈ, কলটোৰ সংযোগ বিচ্ছিন্ন কৰক।"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"কল কৰিব নোৱাৰি, কাৰণ এটা অন্তৰ্গামী কল প্ৰগতিত আছে যাৰ উত্তৰ দিয়া হোৱা নাই। এটা নতুন কল কৰাৰ আগেয়ে অন্তৰ্গামী কলটোৰ উত্তৰ দিয়ক বা সেইটো প্ৰত্যাখ্যান কৰক।"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"একাধিক একাউণ্টৰ মাজত কল কৰাৰ বাবে এই MMI ক’ডটো উপলব্ধ নহয়।"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"একত্ৰিত কৰি থাকোঁতে কলৰ সংযোগ বিচ্ছিন্ন কৰিব নোৱাৰি।"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"জৰুৰীকালীন কলৰ সময়ত MMI ক’ড ডায়েল কৰিব নোৱাৰি।"</string>
+    <string name="noApplications" msgid="1703149220378476198">"কোনো এপে এই কাৰ্য কৰিব নোৱাৰে।"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android ছিষ্টেম"</string>
 </resources>
diff --git a/res/values-az/strings.xml b/res/values-az/strings.xml
index c679b0277..e280b6795 100644
--- a/res/values-az/strings.xml
+++ b/res/values-az/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Davam edən iki zəng olduğuna görə zəng etmək mümkün deyil. Yeni zəng etməzdən əvvəl zənglərin birini dayandırın və ya onları konfransa birləşdirin."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Davam edən iki zəng olduğuna görə zəng etmək mümkün deyil. Yeni zəng etməzdən əvvəl zənglərin birini dayandırın."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Canlı zəngi dayandırmaq mümkün olmadığına görə yeni zəng etmək olmur. Yeni zəng etməzdən əvvəl digər zəngi dayandırın."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktiv zəng gözlədilməni dəstəkləmədiyi üçün onu dəyişdirmək olmur. Gözlədilən zəngi aktivləşdirmək üçün zəngi dayandırın."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Cavabsız gələn zəng olduğuna görə zəng etmək mümkün deyil. Yeni zəngə başlamazdan əvvəl gələn zəngə cavab verin və ya rədd edin."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Bu MMI kodu birdən çox hesab üzrə zənglər üçün əlçatan deyil."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Birləşdirmə zamanı zəng dayandırıla bilməz."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Təcili zəng zamanı MMI kodlarını yığmaq olmur."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Heç bir tətbiq bu əməliyyatı icra edə bilmir."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android Sistemi"</string>
 </resources>
diff --git a/res/values-b+sr+Latn/strings.xml b/res/values-b+sr+Latn/strings.xml
index dd7ac7329..64b728247 100644
--- a/res/values-b+sr+Latn/strings.xml
+++ b/res/values-b+sr+Latn/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Ne možete da pozovete jer su dva poziva već u toku. Prekinite jedan od njih ili ih objedinite u konferenciju pre upućivanja novog poziva."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Ne možete da pozovete jer su dva poziva već u toku. Prekinite jedan od poziva pre upućivanja novog poziva."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Ne možete da uputite poziv jer je u toku poziv koji ne može da se stavi na čekanje. Prekinite taj poziv pre upućivanja novog poziva."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Ne možete da zamenite aktivni poziv jer ne podržava stavljanje na čekanje. Prekinite poziv u toku da biste aktivirali poziv na čekanju."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Ne možete da pozovete jer imate dolazni poziv na koji niste odgovorili. Primite ga ili odbijte pre upućivanja novog poziva."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ovaj MMI kôd nije dostupan za pozive na više naloga."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Poziv ne može da se prekine tokom objedinjavanja."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Biranje MMI kodova noje moguće tokom hitnog poziva."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Nijedna aplikacija ne može da obavlja ovu radnju."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android sistem"</string>
 </resources>
diff --git a/res/values-be/strings.xml b/res/values-be/strings.xml
index 118151450..d71bf039f 100644
--- a/res/values-be/strings.xml
+++ b/res/values-be/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Немагчыма зрабіць новы выклік, бо ўжо выконваюцца два іншыя. Каб зрабіць новы выклік, завяршыце адзін з бягучых ці аб’яднайце іх у канферэнц-выклік."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Немагчыма зрабіць новы выклік, бо ўжо выконваюцца два іншыя. Завяршыце адзін з выклікаў, перш чым зрабіць новы."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Немагчыма зрабіць выклік, бо ўжо выконваецца выклік, які нельга пераключыць у рэжым утрымання. Перш чым зрабіць новы выклік, завяршыце актыўны."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Не ўдаецца пераключыць актыўны выклік, бо ён не падтрымлівае функцыю ўтрымання. Каб зрабіць актыўным выклік, які ўтрымліваецца, завяршыце бягучы выклік."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Нельга зрабіць выклік, паколькі ёсць уваходны выклік без адказу. Адкажыце на ўваходны выклік або адхіліце яго, каб зрабіць новы."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Гэты код MMI недаступны для выклікаў паміж некалькімі ўліковымі запісамі."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Падчас аб’яднання выклік адключыць немагчыма."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Коды MMI нельга набраць падчас экстраннага выкліку."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Няма праграм, якія могуць выканаць гэта дзеянне."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Сістэма Android"</string>
 </resources>
diff --git a/res/values-bg/strings.xml b/res/values-bg/strings.xml
index 4f2ea3ffe..62ea34de7 100644
--- a/res/values-bg/strings.xml
+++ b/res/values-bg/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Не може да се извърши обаждане, тъй като вече се провеждат две обаждания. Прекъснете едно от тях или ги обединете в конферентен разговор, преди да започнете ново."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Не може да се извърши обаждане, тъй като вече се провеждат две обаждания. Прекъснете едно от тях, преди да започнете ново."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Не може да се извърши обаждане, тъй като има обаждане, което не може да бъде поставено на изчакване. Прекъснете обаждането, преди да извършите ново."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Активното обаждане не може да бъде превключено, защото не поддържа задържане. Прекъснете го, за да активирате задържаното обаждане."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Не може да се извърши обаждане, тъй като има неотговорено входящо обаждане. Отговорете му или го отхвърлете, преди да извършите ново обаждане."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Този MMI код не е налице, докато се провежда обаждане в друг профил."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Обаждането не може да бъде прекъснато по време на обединяване."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"По време на спешно обаждане не могат да се набират MMI кодове."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Това действие не може да се изпълни от нито едно приложение."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Система Android"</string>
 </resources>
diff --git a/res/values-bn/strings.xml b/res/values-bn/strings.xml
index a1fbd12bf..db3e39515 100644
--- a/res/values-bn/strings.xml
+++ b/res/values-bn/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"দুটি কল চলছে, তাই আরেকটি কল করা যাচ্ছে না। নতুন কল করার আগে যেকোনও একটি কল ডিসকানেক্ট করুন অথবা দুটিকে একসাথে একটি কনফারেন্সে মার্জ করুন।"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"দুটি কল চলছে, তাই আরেকটি কল করা যাচ্ছে না। নতুন কল করার আগে যেকোনও একটি কল ডিসকানেক্ট করুন।"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"হোল্ড করা যাবে না এমন কল রয়েছে তাই আরেকটি কল করা যাচ্ছে না। নতুন কল করার আগে কলটি ডিসকানেক্ট করুন।"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"যে কলটি চালু রয়েছে সেটি পাল্টানো যাবে না কারণ হোল্ড করার সুবিধা এতে কাজ করবে না। যে কলটি হোল্ডে আছে সেটি চালু করার জন্য এই কলটি ডিসকানেক্ট করুন।"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"উত্তর দেওয়া হয়নি এমন একটি ইনকামিং কল রয়েছে, তাই কল করা যাচ্ছে না। নতুন কল করার আগে ইনকামিং কলটির উত্তর দিন বা সেটি বাতিল করুন।"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"একাধিক অ্যাকাউন্ট জুড়ে কলের জন্য এই MMI কোড উপলভ্য নেই।"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"মার্জ করার সময় কল ডিসকানেক্ট করা যাবে না।"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"জরুরি কলের সময় MMI কোড ডায়াল করা যাবে না।"</string>
+    <string name="noApplications" msgid="1703149220378476198">"এই অ্যাকশনটি করার জন্য উপযুক্ত কোনও অ্যাপ ডিভাইসে নেই।"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android System"</string>
 </resources>
diff --git a/res/values-bs/strings.xml b/res/values-bs/strings.xml
index c3f643d4c..6a3239f43 100644
--- a/res/values-bs/strings.xml
+++ b/res/values-bs/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Nije moguće uputiti poziv jer su već dva poziva u toku. Prekinite jedan od tih poziva ili ih spojite u konferencijski poziv prije upućivanja novog poziva."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Nije moguće uputiti poziv jer su već dva poziva u toku. Prekinite jedan od tih poziva prije upućivanja novog."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nije moguće uputiti poziv zbog poziva koji se ne može staviti na čekanje. Prekinite taj poziv prije upućivanja novog poziva."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Nije moguće zamijeniti aktivni poziv jer ne podržava stavljanje na čekanje. Prekinite poziv da aktivirate poziv na čekanju."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nije moguće uputiti poziv zbog neodgovorenog dolaznog poziva. Odgovorite ili odbijte dolazni poziv prije upućivanja novog poziva."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"MMI kôd nije dostupan za pozive na više računa."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Poziv se ne može prekinuti tokom spajanja."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI kodovi se ne mogu birati tokom hitnog poziva."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Nijedna aplikacija ne može izvršiti tu radnju."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistem Android"</string>
 </resources>
diff --git a/res/values-ca/strings.xml b/res/values-ca/strings.xml
index 1bd052391..023c23104 100644
--- a/res/values-ca/strings.xml
+++ b/res/values-ca/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"No es pot fer la trucada perquè ja n\'hi ha dues en curs. Desconnecta\'n una o combina-les en una conferència abans de fer-ne més de noves."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"No es pot fer la trucada perquè ja n\'hi ha dues en curs. Desconnecta\'n una abans de fer-ne més de noves."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"No es pot fer la trucada perquè n\'hi ha una que no es pot posar en espera. Desconnecta-la abans de fer-ne més de noves."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"No es pot intercanviar la trucada activa perquè no admet la posada en espera. Desconnecta la trucada per activar la que està en espera."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"No es pot fer la trucada perquè hi ha una trucada entrant sense resposta. Respon-hi o rebutja-la abans de fer més trucades."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Aquest codi MMI no es pot utilitzar per fer trucades amb diversos comptes."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"La trucada no es pot desconnectar durant una combinació."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"No es poden marcar codis MMI durant una trucada d\'emergència."</string>
+    <string name="noApplications" msgid="1703149220378476198">"No hi ha cap aplicació que pugui fer aquesta acció."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-cs/strings.xml b/res/values-cs/strings.xml
index 27f38cc51..e2121fbb3 100644
--- a/res/values-cs/strings.xml
+++ b/res/values-cs/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Hovor nelze zahájit, protože už probíhají jiné dva hovory. Než zahájíte nový hovor, jeden ze stávajících zavěste nebo je slučte do konference."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Hovor nelze zahájit, protože už probíhají jiné dva hovory. Než zahájíte nový hovor, jeden ze stávajících zavěste."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nemůžete uskutečnit hovor, protože už probíhá hovor, který nelze podržet. Než zahájíte nový hovor, odpojte ten předchozí."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktivní hovor nejde přepnout, protože nepodporuje přidržení. Pokud chcete přejít do přidrženého hovoru, ten stávající zavěste."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nemůžete uskutečnit hovor, protože máte nepřijatý příchozí hovor. Nejdřív ho tedy přijměte nebo odmítněte."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Tento kód MMI není k dispozici pro hovory ve více účtech."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Během slučování hovorů se nelze odpojit."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Při tísňovém volání nelze vytáčet kódy MMI."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Žádná aplikace nemůže tuto akci provést."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Systém Android"</string>
 </resources>
diff --git a/res/values-da/strings.xml b/res/values-da/strings.xml
index 7aa6bf5a9..82aafc07e 100644
--- a/res/values-da/strings.xml
+++ b/res/values-da/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Der kan ikke foretages et opkald, fordi der allerede er to igangværende opkald. Afslut et af opkaldene, eller flet dem til et telefonmøde, før du foretager et nyt opkald."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Der kan ikke foretages et opkald, fordi der allerede er to igangværende opkald. Afslut et af opkaldene, før du foretager et nyt."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Opkaldet kan ikke foretages, fordi der er et opkald i gang, som ikke kan sættes på hold. Afslut opkaldet, før du foretager et nyt."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Det aktive opkald kan ikke udskiftes, da det ikke understøtter funktionen til at sætte opkald på hold. Afslut det nuværende opkald for at gøre opkaldet, der er på hold, aktivt."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Der kan ikke foretages et opkald, fordi et indgående opkald ringer. Besvar eller afvis det indgående opkald, før du foretager et nyt opkald."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Denne MMI-kode er ikke tilgængelig for opkald på tværs af flere konti."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Opkaldet kan ikke afbrydes under en fletning."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI-koder kan ikke ringe under et nødopkald."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Der er ingen apps, der kan foretage denne handling."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-system"</string>
 </resources>
diff --git a/res/values-de/strings.xml b/res/values-de/strings.xml
index 6af8a8a6d..bce8e1d2c 100644
--- a/res/values-de/strings.xml
+++ b/res/values-de/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Anruf nicht möglich, weil bereits zwei Anrufe aktiv sind. Beende einen der Anrufe oder führe beide Anrufe in einer Telefonkonferenz zusammen, bevor du einen neuen Anruf startest."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Anruf nicht möglich, weil bereits zwei Anrufe aktiv sind. Beende einen der Anrufe, bevor du einen neuen startest."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Anruf nicht möglich, da ein Anruf nicht gehalten werden kann. Beende den Anruf, bevor du einen neuen Anruf startest."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Der aktive Anruf kann nicht geändert werden, da das Halten des Anrufs nicht unterstützt wird. Du musst den Anruf trennen, damit der gehaltene Anruf zum aktiven Anruf wird."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Anruf nicht möglich, da ein nicht angenommener eingehender Anruf vorhanden ist. Nimm den eingehenden Anruf an oder lehne ihn ab, bevor du einen neuen Anruf startest."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Dieser MMI-Code ist nicht für Anrufe mit mehreren Konten verfügbar."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Während des Zusammenführens kann der Anruf nicht getrennt werden."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI-Codes können während eines Notrufs nicht gewählt werden."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Diese Aktion kann von keiner App ausgeführt werden."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-System"</string>
 </resources>
diff --git a/res/values-el/strings.xml b/res/values-el/strings.xml
index c21c8a6a5..7f47f85bb 100644
--- a/res/values-el/strings.xml
+++ b/res/values-el/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Δεν είναι δυνατή η πραγματοποίηση κλήσης, επειδή υπάρχουν ήδη δύο κλήσεις σε εξέλιξη. Τερματίστε μία από τις κλήσεις ή συγχωνεύστε τις σε μια διάσκεψη, προτού πραγματοποιήσετε νέα κλήση."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Δεν είναι δυνατή η πραγματοποίηση κλήσης, επειδή υπάρχουν ήδη δύο κλήσεις σε εξέλιξη. Αποσυνδέστε μία από τις κλήσεις πριν πραγματοποιήσετε νέα κλήση."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Δεν είναι δυνατή η πραγματοποίηση κλήσης, επειδή υπάρχει κλήση που δεν μπορεί να τεθεί σε αναμονή. Τερματίστε την κλήση πριν πραγματοποιήσετε νέα κλήση."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Δεν είναι δυνατή η εναλλαγή της ενεργής κλήσης, επειδή δεν υποστηρίζεται η αναμονή. Αποσυνδέστε την κλήση για να ενεργοποιήσετε την κλήση που έχει τεθεί σε αναμονή."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Δεν είναι δυνατή η πραγματοποίηση κλήσης, επειδή υπάρχει αναπάντητη εισερχόμενη κλήση. Απαντήστε ή απορρίψτε την εισερχόμενη κλήση, προτού πραγματοποιήσετε μια νέα κλήση."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Αυτός ο κωδικός MMI δεν είναι διαθέσιμος για κλήσεις σε πολλούς λογαριασμούς."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Δεν είναι δυνατή η αποσύνδεση της κλήσης κατά τη συγχώνευση."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Δεν είναι δυνατή η κλήση κωδικών MMI κατά τη διάρκεια μιας κλήσης έκτακτης ανάγκης."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Δεν υπάρχουν εφαρμογές, οι οποίες μπορούν να εκτελέσουν αυτή την ενέργεια."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Σύστημα Android"</string>
 </resources>
diff --git a/res/values-en-rAU/strings.xml b/res/values-en-rAU/strings.xml
index ad1c0e3ba..bb86a7816 100644
--- a/res/values-en-rAU/strings.xml
+++ b/res/values-en-rAU/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls or merge them into a conference prior to placing a new call."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls prior to placing a new call."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Cannot place a call as there is an unholdable call. Disconnect the call prior to placing a new call."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Cannot swap the active call because it does not support holding. Disconnect the call to make the held call active."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Cannot place a call as there is an unanswered incoming call. Answer or reject the incoming call prior to placing a new call."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"This MMI code is not available for calls across multiple accounts."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Call cannot be disconnected during a merge."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI codes cannot be dialled during an emergency call."</string>
+    <string name="noApplications" msgid="1703149220378476198">"No apps can perform this action."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android system"</string>
 </resources>
diff --git a/res/values-en-rCA/strings.xml b/res/values-en-rCA/strings.xml
index ceb8258d4..55299084a 100644
--- a/res/values-en-rCA/strings.xml
+++ b/res/values-en-rCA/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls or merge them into a conference prior to placing a new call."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls prior to placing a new call."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Cannot place a call as there is an unholdable call. Disconnect the call prior to placing a new call."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Cannot swap the active call because it does not support holding. Disconnect the call to make the held call active."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Cannot place a call as there is an unanswered incoming call. Answer or reject the incoming call prior to placing a new call."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"This MMI code is not available for calls across multiple accounts."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Call cannot be disconnected during a merge."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI codes cannot be dialed during an emergency call."</string>
+    <string name="noApplications" msgid="1703149220378476198">"No apps can perform this action."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android System"</string>
 </resources>
diff --git a/res/values-en-rGB/strings.xml b/res/values-en-rGB/strings.xml
index ad1c0e3ba..bb86a7816 100644
--- a/res/values-en-rGB/strings.xml
+++ b/res/values-en-rGB/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls or merge them into a conference prior to placing a new call."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls prior to placing a new call."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Cannot place a call as there is an unholdable call. Disconnect the call prior to placing a new call."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Cannot swap the active call because it does not support holding. Disconnect the call to make the held call active."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Cannot place a call as there is an unanswered incoming call. Answer or reject the incoming call prior to placing a new call."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"This MMI code is not available for calls across multiple accounts."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Call cannot be disconnected during a merge."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI codes cannot be dialled during an emergency call."</string>
+    <string name="noApplications" msgid="1703149220378476198">"No apps can perform this action."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android system"</string>
 </resources>
diff --git a/res/values-en-rIN/strings.xml b/res/values-en-rIN/strings.xml
index ad1c0e3ba..bb86a7816 100644
--- a/res/values-en-rIN/strings.xml
+++ b/res/values-en-rIN/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls or merge them into a conference prior to placing a new call."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Cannot place a call as there are already two calls in progress. Disconnect one of the calls prior to placing a new call."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Cannot place a call as there is an unholdable call. Disconnect the call prior to placing a new call."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Cannot swap the active call because it does not support holding. Disconnect the call to make the held call active."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Cannot place a call as there is an unanswered incoming call. Answer or reject the incoming call prior to placing a new call."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"This MMI code is not available for calls across multiple accounts."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Call cannot be disconnected during a merge."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI codes cannot be dialled during an emergency call."</string>
+    <string name="noApplications" msgid="1703149220378476198">"No apps can perform this action."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android system"</string>
 </resources>
diff --git a/res/values-es-rUS/strings.xml b/res/values-es-rUS/strings.xml
index 66db65b68..700ee5ccf 100644
--- a/res/values-es-rUS/strings.xml
+++ b/res/values-es-rUS/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"No puedes realizar la llamada porque hay otras dos en curso. Finaliza una de ellas o combínalas en una conferencia antes de iniciar una nueva."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"No puedes realizar la llamada porque hay otras dos en curso. Finaliza una de ellas antes de realizar una nueva."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"No puedes realizar la llamada porque hay otra que no se puede mantener en espera. Finalízala antes de iniciar una nueva."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"No se puede cambiar de llamada activa porque la llamada en curso no admite la puesta en espera. Desconecta la llamada en curso para activar la que está en espera."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"No puedes realizar la llamada porque hay una llamada entrante que aún no contestas. Contéstala o recházala antes de realizar una nueva."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Este código MMI no está disponible para llamadas en varias cuentas."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"No se puede desconectar la llamada durante una combinación."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"No se pueden marcar códigos MMI durante las llamadas de emergencia."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ninguna app puede realizar esta acción."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-es/strings.xml b/res/values-es/strings.xml
index 193491366..17bf825cc 100644
--- a/res/values-es/strings.xml
+++ b/res/values-es/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"No se puede llamar porque ya hay dos llamadas en curso. Interrumpe una de ellas o combínalas en una conferencia antes de hacer otra llamada."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"No se puede llamar porque ya hay dos llamadas en curso. Interrumpe una de las llamadas antes de hacer otra."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"No se puede hacer una llamada porque ya hay otra que no se puede poner en espera. Interrumpe la llamada antes de hacer otra."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"No se puede intercambiar la llamada activa porque no se puede poner en espera. Desconecta la llamada activa para activar la llamada en espera."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"No se puede llamar porque hay una llamada entrante sin responder. Contéstala o recházala antes de hacer otra llamada."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Este código MMI no está disponible para hacer llamadas con varias cuentas."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"El teléfono no puede colgarse mientras se combinan las llamadas."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"No se pueden marcar códigos MMI durante las llamadas de emergencia."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ninguna aplicación puede realizar esta acción."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-et/strings.xml b/res/values-et/strings.xml
index ba5be48c8..b852f3a64 100644
--- a/res/values-et/strings.xml
+++ b/res/values-et/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Kõnet ei saa teha, kuna kaks kõnet on juba pooleli. Enne uue kõne tegemist katkestage üks kõnedest või liitke need konverentskõneks."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Kõnet ei saa teha, kuna kaks kõnet on juba pooleli. Enne uue kõne tegemist katkestage üks kõnedest."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Uut kõnet ei saa teha, kuna pooleliolevat kõnet ei saa ootele panna. Enne uue kõne tegemist katkestage pooleliolev kõne."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktiivset kõnet ei saa ümber lülitada, kuna see ei toeta ootel hoidmist. Katkestage kõne, et muuta ootel olev kõne aktiivseks."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Kõnet ei saa teha, kuna teil on vastamata sissetulev kõne. Enne uue kõne tegemist vastake sissetulevale kõnele või keelduge sellest."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"See MMI-kood pole saadaval mitmel kontol toimuvate kõnede jaoks."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Ühendamise ajal ei saa kõnet katkestada."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI-koode ei saa hädaabikõne ajal valida."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ükski rakendus ei saa seda toimingut teha."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-süsteem"</string>
 </resources>
diff --git a/res/values-eu/strings.xml b/res/values-eu/strings.xml
index 6f362e86c..afa00437b 100644
--- a/res/values-eu/strings.xml
+++ b/res/values-eu/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Ezin da egin deia, dagoeneko 2 dei daudelako abian. Beste dei bat egin aurretik, eten deietako bat edo bateratu deiak konferentzia-dei bakarrean."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Ezin da egin deia, dagoeneko 2 dei daudelako abian. Beste dei bat egin aurretik, eten deietako bat."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Ezin da egin deia, zain utzi ezin den dei bat abian delako. Deskonektatu dei hori beste dei bat egin ahal izateko."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Ezin da aldatu dei aktiboa, zain uzteko aukera onartzen ez duelako. Zain dagoen deia aktibatzeko, deskonektatu deia."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Ezin da egin deia, oraindik erantzun ez diozun dei bat jasotzen ari zarelako. Beste dei bat egin aurretik, erantzun deiari edo bazter ezazu."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"MMI kode hau ezin da erabili kontu baten baino gehiagoren bidez deiak egiteko."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Ezin da deskonektatu deia bateratze-prozesua abian den bitartean."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI kodeak ezin dira markatu larrialdi-deietan."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ez dago ekintza hori egin dezakeen aplikaziorik."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android sistema"</string>
 </resources>
diff --git a/res/values-fa/strings.xml b/res/values-fa/strings.xml
index 3bb8889f9..9078161eb 100644
--- a/res/values-fa/strings.xml
+++ b/res/values-fa/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"نمی‌توانید تماسی برقرار کنید، زیرا هم‌اکنون دو تماس دیگر درحال انجام است. قبل‌از برقراری تماس جدید، یکی از تماس‌ها را قطع کنید یا آن‌ها را به‌صورت کنفرانسی ادغام کنید."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"نمی‌توانید تماسی برقرار کنید چون دو تماس دیگر ازقبل درحال انجام است. قبل‌از برقراری تماس جدید، یکی از تماس‌ها را قطع کنید."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"نمی‌توانید تماسی برقرار کنید زیرا هم‌اکنون تماسی بدون قابلیت انتظار درحال انجام است. قبل‌از برقراری تماس جدید، تماس را قطع کنید."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"تماس فعال تعویض نمی‌شود چون از درانتظار گذاشتن پشتیبانی نمی‌کند. برای فعال کردن تماس نگه‌داشته‌شده، تماس را قطع کنید."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"نمی‌توانید تماسی برقرار کنید، چون تماس ورودی بی‌پاسخی درحال انجام است. قبل‌از برقراری تماس جدید، به تماس ورودی پاسخ دهید یا آن را رد کنید."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"‏این کد MMI برای تماس در چندین حساب دردسترس نیست."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"تماس را نمی‌توان در طول ادغام کردن قطع کرد."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"‏امکان شماره‌گیری کدهای MMI حین تماس اضطراری وجود ندارد"</string>
+    <string name="noApplications" msgid="1703149220378476198">"‏هیچ برنامه‌ای نمی‎تواند این کنش را انجام دهد."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"‏سیستم Android"</string>
 </resources>
diff --git a/res/values-fi/strings.xml b/res/values-fi/strings.xml
index 9681dceb6..c7d1fc101 100644
--- a/res/values-fi/strings.xml
+++ b/res/values-fi/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Puhelua ei voi soittaa, koska kaksi puhelua on jo käynnissä. Katkaise toinen puheluista tai yhdistä ne puhelinneuvotteluksi ennen uuden puhelun soittamista."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Puhelua ei voi soittaa, koska kaksi puhelua on jo käynnissä. Katkaise toinen puheluista ennen uuden puhelun soittamista."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Puhelua ei voi soittaa, koska puhelua ei voi asettaa pitoon. Katkaise puhelu ennen uuden puhelun soittamista."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktiivista puhelua ei voi vaihtaa, koska se ei tue pitoa. Lopeta puhelu, jos haluat vastata pidossa olevaan puheluun."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Puhelua ei voi soittaa, koska saapuvaan puheluun ei ole vielä vastattu. Vastaa saapuvaan puheluun tai hylkää se, ennen kuin soitat uuden puhelun."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"MMI-koodi ei ole käytettävissä useilla tileillä käytävissä puheluissa."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Puhelua ei voi katkaista yhdistämisen aikana."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI-koodeja ei voi käyttää hätäpuhelun aikana."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Yksikään sovellus ei voi suorittaa tätä toimintoa."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-järjestelmä"</string>
 </resources>
diff --git a/res/values-fr-rCA/strings.xml b/res/values-fr-rCA/strings.xml
index ac82985dc..bcbbf0196 100644
--- a/res/values-fr-rCA/strings.xml
+++ b/res/values-fr-rCA/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Impossible de passer un appel parce que deux appels sont déjà en cours. Déconnectez-en un ou fusionnez-les en conférence téléphonique avant de passer un nouvel appel."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Impossible de passer un appel parce que deux appels sont déjà en cours. Déconnectez-en un avant de passer un nouvel appel."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Impossible de passer un appel parce qu\'un appel impossible à mettre en attente est en cours. Débranchez l\'appel avant de passer un nouvel appel."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Impossible d\'échanger l\'appel actif parce qu\'il ne prend pas en charge la mise en attente. Mettez fin à l\'appel pour rendre l\'appel en attente actif."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Impossible de passer un appel parce qu\'un appel entrant attend une réponse. Répondez à cet appel ou refusez-le avant de passer un nouvel appel."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ce code IHM n\'est pas disponible pour les appels utilisant plusieurs comptes."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Impossible de déconnecter l\'appel pendant une fusion."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Impossible de composer un code IHM pendant un appel d\'urgence."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Aucune appli ne peut effectuer cette action."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Système Android"</string>
 </resources>
diff --git a/res/values-fr/strings.xml b/res/values-fr/strings.xml
index 2db30ae75..b539d1dbb 100644
--- a/res/values-fr/strings.xml
+++ b/res/values-fr/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Impossible de passer un appel, car deux appels sont déjà en cours. Mettez fin à l\'un des appels ou fusionnez-les afin de créer une conférence avant de passer un nouvel appel."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Impossible de passer un appel, car deux appels sont déjà en cours. Mettez fin à l\'un des appels avant de passer un nouvel appel."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Impossible de passer un appel, car un appel est en cours et ne peut pas être mis en attente. Mettez fin à l\'appel avant de passer un nouvel appel."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Impossible de permuter l\'appel actif, car il n\'est pas compatible avec la mise en attente. Mettez fin à l\'appel pour rendre l\'appel mis en attente actif."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Impossible de passer un appel lorsqu\'un appel entrant attend une réponse. Répondez à cet appel ou refusez-le avant de passer un nouvel appel."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ce code IHM n\'est pas disponible pour les appels sur plusieurs comptes."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Impossible de raccrocher pendant une fusion."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Impossible de composer des codes IHM pendant un appel d\'urgence."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Aucune application ne peut effectuer cette action."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Système Android"</string>
 </resources>
diff --git a/res/values-gl/strings.xml b/res/values-gl/strings.xml
index cf144a868..b4329a9a3 100644
--- a/res/values-gl/strings.xml
+++ b/res/values-gl/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Non se pode facer ningunha chamada porque xa hai dúas en curso. Para poder facer unha nova, desconecta unha desas dúas ou combínaas nunha conferencia."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Non se pode facer ningunha chamada porque xa hai dúas en curso. Desconecta unha delas antes de facer outra."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Non se pode facer ningunha chamada porque hai unha que non é posible poñer en espera. Desconéctaa para poder facer unha nova."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Non se pode intercambiar a chamada activa porque non admite a función de pór en espera. Desconecta a chamada para activar a chamada en espera."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Non podes chamar porque te están chamando nestes momentos. Para poder facer unha chamada, primeiro tes que responder á outra ou rexeitala."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Este código MMI non está dispoñible para chamadas en varias contas."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Non se pode desconectar a chamada cando se está combinando."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Non se poden marcar códigos MMI durante as chamadas de emerxencia."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ningunha aplicación pode realizar esta acción."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-gu/strings.xml b/res/values-gu/strings.xml
index 3503a6a6c..2b103d671 100644
--- a/res/values-gu/strings.xml
+++ b/res/values-gu/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"કૉલ કરી શકાતો નથી, કારણ કે બે કૉલ પહેલેથી ચાલુ છે. કોઈ નવો કૉલ કરતા પહેલાં તેમાંના એક કૉલને ડિસ્કનેક્ટ કરો અથવા તેમને કોઈ કૉન્ફરન્સમાં મર્જ કરો."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"કૉલ કરી શકાતો નથી, કારણ કે બે કૉલ પહેલેથી ચાલુ છે. કોઈ નવો કૉલ કરતા પહેલાં તેમાંના એક કૉલને ડિસ્કનેક્ટ કરો."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"કૉલ કરી શકાતો નથી, કારણ કે હોલ્ડ ન કરી શકાય તેવો કોઈ કૉલ ચાલુ છે. કોઈ નવો કૉલ કરતા પહેલાં કૉલને ડિસ્કનેક્ટ કરો."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"સક્રિય કૉલ સ્વૉપ કરી શકતા નથી કારણ કે તે હોલ્ડ પર રાખવાને સપોર્ટ કરતો નથી. હોલ્ડ પર રાખેલા કૉલને સક્રિય કરવા માટે કૉલ ડિસ્કનેક્ટ કરો."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"કૉલ કરી શકાતો નથી કારણ કે ઇનકમિંગ કૉલનો જવાબ આપવામાં આવી રહ્યો નથી. નવો કૉલ કરતા પહેલાં ઇનકમિંગ કૉલનો જવાબ આપો અથવા તેને નકારો."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"આ MMI કોડનો ઉપયોગ એકથી વધુ એકાઉન્ટ પર ચાલી રહેલા કૉલ માટે ઉપલબ્ધ નથી."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"મર્જ કરવા દરમિયાન કૉલ ડિસ્કનેક્ટ કરી શકાતો નથી."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ઇમર્જન્સી કૉલ દરમિયાન MMI કોડ ડાયલ કરી શકાતા નથી."</string>
+    <string name="noApplications" msgid="1703149220378476198">"કોઈ ઍપ્લિકેશન આ ક્રિયા કરી શકતી નથી."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android સિસ્ટમ"</string>
 </resources>
diff --git a/res/values-hi/strings.xml b/res/values-hi/strings.xml
index 338519f0b..bb38cd1b7 100644
--- a/res/values-hi/strings.xml
+++ b/res/values-hi/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"कॉल नहीं किया जा सकता, क्योंकि पहले से ही दो कॉल जारी हैं. नया कॉल करने से पहले, उनमें से किसी एक कॉल को डिसकनेक्ट करें या उन्हें कॉन्फ़्रेंस कॉल में मर्ज करें."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"कॉल नहीं किया जा सकता, क्योंकि पहले से ही दो कॉल जारी हैं. नया कॉल करने से पहले, उनमें से किसी एक कॉल को डिसकनेक्ट करें."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"कॉल नहीं किया जा सकता, क्योंकि पहले से चल रहे कॉल को होल्ड नहीं किया जा सकता. नया कॉल करने से पहले, मौजूदा कॉल को डिसकनेक्ट करें."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"चालू कॉल को स्वैप नहीं किया जा सकता, क्योंकि इसमें होल्ड करने की सुविधा नहीं है. होल्ड पर रखी गई कॉल को चालू करने के लिए, चल रहे कॉल को डिसकनेक्ट करें."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"कॉल नहीं किया जा सकता, क्योंकि एक इनकमिंग कॉल का जवाब नहीं दिया जा रहा है. नया कॉल करने से पहले इनकमिंग कॉल का जवाब दें या उसे अस्वीकार करें."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"किसी दूसरे खाते पर चल रहे कॉल के दौरान, इस एमएमआई कोड का इस्तेमाल नहीं किया जा सकता."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"मर्ज करने की प्रोसेस के दौरान, कॉल को डिसकनेक्ट नहीं किया जा सकता."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"आपातकालीन कॉल के दौरान, MMI कोड डायल नहीं किए जा सकते."</string>
+    <string name="noApplications" msgid="1703149220378476198">"कोई भी ऐप्लिकेशन यह कार्रवाई नहीं कर सकता."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android सिस्टम"</string>
 </resources>
diff --git a/res/values-hr/strings.xml b/res/values-hr/strings.xml
index 383dc4662..36ae51080 100644
--- a/res/values-hr/strings.xml
+++ b/res/values-hr/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Poziv se ne može uputiti jer već su dva poziva u tijeku. Prije upućivanja novog poziva prekinite jedan od ta dva poziva ili ih spojite u konferencijski poziv."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Poziv se ne može uputiti jer već su dva poziva u tijeku. Prekinite jedan od tih poziva prije upućivanja novog."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Poziv se ne može uputiti jer je u tijeku poziv koji se ne može zadržati. Prekinite taj poziv prije upućivanja novog."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktivni poziv ne može se zamijeniti jer ne podržava stavljanje na čekanje. Prekinite poziv u tijeku da biste aktivirali poziv na čekanju."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Poziv se ne može uputiti jer je aktivan neodgovoreni dolazni poziv. Odgovorite ili odbijte dolazni poziv prije upućivanja novog poziva."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Taj MMI kôd nije dostupan za pozive na više računa."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Poziv se ne može prekinuti tijekom spajanja."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI kodovi ne mogu se birati tijekom hitnog poziva."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Tu radnju ne može izvesti nijedna aplikacija."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sustav Android"</string>
 </resources>
diff --git a/res/values-hu/strings.xml b/res/values-hu/strings.xml
index 828ae2bcc..5c9fc6a3d 100644
--- a/res/values-hu/strings.xml
+++ b/res/values-hu/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Nem kezdeményezhet hívást, mert már két hívás van folyamatban. Mielőtt új hívást indítana, tegye le az egyiket, vagy egyesítse őket egy konferenciahívásban."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Nem kezdeményezhet hívást, mert már két hívás van folyamatban. Mielőtt új hívást indítana, szakítsa meg az egyik hívást."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nem kezdeményezhet hívást, mert folyamatban van egy nem tartható hívás. Mielőtt új hívást indítana, szakítsa meg a hívást."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Nem lehet kicserélni az aktív hívást, mert az nem támogatja a hívástartást. A tartott hívás aktiválásához szakítsa meg a hívást."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nem kezdeményezhet hívást, mert folyamatban van egy megválaszolatlan bejövő hívás. Mielőtt új hívást indítana, vegye fel vagy utasítsa el a bejövő hívást."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ez az MMI-kód nem áll rendelkezésre hívásokhoz több fiók használata esetén."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"A hívás nem szakítható meg egyesítés közben."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Segélyhívás közben nem lehet MMI-kódot tárcsázni."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Egy alkalmazás sem tudja végrehajtani ezt a műveletet."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android rendszer"</string>
 </resources>
diff --git a/res/values-hy/strings.xml b/res/values-hy/strings.xml
index b336905ee..86f92fb78 100644
--- a/res/values-hy/strings.xml
+++ b/res/values-hy/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Հնարավոր չէ զանգել, քանի որ արդեն երկու ընթացիկ զանգ կա։ Նախքան նոր զանգ կատարելը ավարտեք զանգերից մեկը կամ միավորեք դրանք մեկ խմբային զանգում։"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Հնարավոր չէ զանգել, քանի որ արդեն երկու ընթացիկ զանգ կա։ Նախքան նոր զանգ կատարելը ավարտեք զանգերից մեկը։"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Հնարավոր չէ զանգել, քանի որ ընթացիկ զանգը չի կարելի սպասման մեջ դնել։ Նախքան նոր զանգ կատարելը պատասխանեք ավարտեք այս զանգը։"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Չհաջողվեց ակտիվացնել մյուս զանգը, քանի որ ընթացիկ զանգը չի աջակցում սպասման ռեժիմը։ Ավարտեք ընթացիկ զանգը, որպեսզի ակտիվացնեք սպասման մեջ գտնվող զանգը։"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Հնարավոր չէ զանգել, քանի որ անպատասխան մուտքային զանգ կա։ Նախքան նոր զանգ կատարելը պատասխանեք մուտքային զանգին կամ մերժեք այն։"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Այս MMI կոդը հասանելի չէ մի քանի հաշիվների օգտագործմամբ զանգերի համար։"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Միավորման ժամանակ զանգը հնարավոր չէ անջատել։"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Շտապ կանչի ընթացքում MMI կոդերի հավաքումը հնարավոր չէ։"</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ոչ մի հավելված չի կարող կատարել այս գործողությունը:"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android համակարգ"</string>
 </resources>
diff --git a/res/values-in/strings.xml b/res/values-in/strings.xml
index 331d2bec5..97146f5f4 100644
--- a/res/values-in/strings.xml
+++ b/res/values-in/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Tidak dapat melakukan panggilan karena ada dua panggilan yang sedang berlangsung. Putuskan salah satu panggilan atau gabungkan keduanya menjadi satu konferensi sebelum melakukan panggilan baru."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Tidak dapat melakukan panggilan karena ada dua panggilan yang sedang berlangsung. Putuskan salah satu panggilan sebelum melakukan panggilan baru."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Tidak dapat melakukan panggilan karena ada panggilan yang tidak dapat ditahan. Putuskan panggilan sebelum melakukan panggilan baru."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Tidak dapat mengalihkan panggilan aktif karena tidak dapat dijeda. Putuskan panggilan untuk tersambung ke panggilan yang ditahan."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Tidak dapat melakukan panggilan karena ada panggilan masuk yang belum terjawab. Jawab atau tolak panggilan masuk sebelum melakukan panggilan baru."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Kode MMI ini tidak tersedia untuk panggilan di beberapa akun."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Panggilan tidak dapat diputus selama penggabungan."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Kode MMI tidak dapat di-dial selama panggilan darurat."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Tidak ada apl yang dapat melakukan tindakan ini."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistem Android"</string>
 </resources>
diff --git a/res/values-is/strings.xml b/res/values-is/strings.xml
index c389052f4..3608e4c9d 100644
--- a/res/values-is/strings.xml
+++ b/res/values-is/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Ekki er hægt að hringja símtal vegna þess að þegar eru tvö símtöl í gangi. Slíttu öðru símtalinu eða sameinaðu þau í símafund áður en þú hringir nýtt símtal."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Ekki er hægt að hringja símtal þar sem það eru þegar tvö símtöl í gangi. Slíttu öðru símtalinu áður en þú hringir nýtt símtal."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Ekki er hægt að hringja símtal vegna símtals sem ekki er hægt að setja í bið. Slíttu símtalinu áður en þú hringir nýtt símtal."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Ekki er hægt að skipta út virka símtalinu því ekki er hægt að setja það í bið. Ljúktu símtalinu til að gera símtalið í bið virkt."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Ekki er hægt að hringja símtal, þar sem ósvarað símtal er að berast. Svaraðu eða hafnaðu símtalinu áður en þú hringir nýtt símtal."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Þessi MMI-kóði er ekki í boði ef hringt er í marga reikninga."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Ekki er hægt að slíta símtali á meðan á sameiningu stendur."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Ekki er hægt að hringja MMI-kóða í neyðarsímtali."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Engin forrit geta framkvæmt þessa aðgerð."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-kerfið"</string>
 </resources>
diff --git a/res/values-it/strings.xml b/res/values-it/strings.xml
index 85715742c..6f373ba7b 100644
--- a/res/values-it/strings.xml
+++ b/res/values-it/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Impossibile effettuare una chiamata perché due chiamate sono già in corso. Unisci le chiamate in una conferenza o scollegane una prima di effettuare una nuova chiamata."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Impossibile effettuare una chiamata perché due chiamate sono già in corso. Termina una delle chiamate prima di effettuarne una nuova."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Impossibile effettuare una chiamata perché è presente una chiamata non bloccabile. Termina la chiamata prima di effettuarne una nuova."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Impossibile passare dalla chiamata attiva a un\'altra perché non supporta la messa in attesa. Disconnetti la chiamata per attivare quella in attesa."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Impossibile effettuare una chiamata perché è presente una chiamata in arrivo senza risposta. Rispondi o rifiuta la chiamata in arrivo prima di effettuare una nuova chiamata."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Questo codice MMI non è disponibile per le chiamate su più account."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Impossibile disconnettere la chiamata durante l\'unione di più chiamate."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Impossibile comporre codici MMI durante una chiamata di emergenza."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Nessuna applicazione è in grado di eseguire questa azione."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-iw/strings.xml b/res/values-iw/strings.xml
index b31b68d2f..80f30d40d 100644
--- a/res/values-iw/strings.xml
+++ b/res/values-iw/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"אי אפשר להתקשר כי כבר יש שתי שיחות פעילות. כדי להתחיל שיחה חדשה, צריך לנתק את אחת מהשיחות או למזג אותן וליצור שיחת ועידה."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"אי אפשר להתקשר כי כבר יש שתי שיחות פעילות. כדי להתחיל שיחה חדשה, צריך לנתק את אחת מהשיחות."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"אי אפשר להתקשר כי כבר יש שיחה פעילה ואי אפשר להעביר אותה להמתנה. צריך לנתק את השיחה ורק אז לנסות להתקשר למספר אחר."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"אי אפשר להחליף בין השיחות כי השיחה החדשה לא תומכת במצב המתנה. כדי לחזור לשיחה הקודמת שבהמתנה, צריך לנתק את השיחה החדשה שהתחלת."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"אי אפשר להתקשר כי יש שיחה נכנסת אחרת. צריך לענות לשיחה או לדחות אותה ורק אז לנסות להתקשר למספר אחר."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"‏אי אפשר להשתמש בקוד ה-MMI הזה לשיחות במספר חשבונות."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"אי אפשר לנתק את השיחה במהלך מיזוג."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"‏אי אפשר להתקשר לקודי MMI בזמן שיחת חירום."</string>
+    <string name="noApplications" msgid="1703149220378476198">"אין אפליקציות שיכולות לבצע את הפעולה הזו."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"‏מערכת Android"</string>
 </resources>
diff --git a/res/values-ja/strings.xml b/res/values-ja/strings.xml
index c03db2b80..c6cc5b7e7 100644
--- a/res/values-ja/strings.xml
+++ b/res/values-ja/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"進行中の通話がすでに 2 件あるため、新しく通話を発信することはできません。進行中の通話のどちらかを終了するか、2 件の通話を統合してグループ通話にすると、新しく通話を発信できるようになります。"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"進行中の通話がすでに 2 件あるため、新しく通話を発信することはできません。進行中の通話のどちらかを終了すると、新しく通話を発信できるようになります。"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"保留できない通話があるため、新しく通話を発信できません。通話を終了すると、新しく通話を発信できるようになります。"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"アクティブな通話が保留に対応していないため、切り替えることができません。保留中の通話をアクティブにするには、現在の通話を終了してください。"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"通話を着信中のため、新しく通話を発信することはできません。着信中の通話に応答するか、通話を拒否すると、新しく通話を発信できるようになります。"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"この MMI コードは、複数のアカウントにまたがる通話には使用できません。"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"通話の統合中は通話を終了できません。"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"緊急通報中は MMI コードをダイヤルできません。"</string>
+    <string name="noApplications" msgid="1703149220378476198">"この操作を実行できるアプリがありません。"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android システム"</string>
 </resources>
diff --git a/res/values-ka/strings.xml b/res/values-ka/strings.xml
index ad841f3de..6d9695288 100644
--- a/res/values-ka/strings.xml
+++ b/res/values-ka/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ზარის განხორციელება შეუძლებელია, რადგან უკვე ორი ზარი მიმდინარეობს. ახალი ზარის განსახორციელებლად გათიშეთ ერთ-ერთი ზარი ან გააერთიანეთ ისინი კონფერენციად."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ზარის განხორციელება შეუძლებელია, რადგან უკვე ორი ზარი მიმდინარეობს. ახალი ზარის განსახორციელებლად გათიშეთ ერთ-ერთი ზარი."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ზარის განხორციელება ვერ ხერხდება, რადგან მიმდინარეობს ზარი, რომლის მოცდის რეჟიმში გადაყვანაც შეუძლებელია. ახალი ზარის განსახორციელებლად გათიშეთ აღნიშნული ზარი."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"აქტიური ზარის შენაცვლება შეუძლებელია, რადგან მას არ აქვს მოცდის მხარდაჭერა. გათიშეთ მიმდინარე ზარი შეყოვნებული ზარის გასააქტიურებლად."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ზარის განხორციელება შეუძლებელია, რადგან გაქვთ უპასუხო შემომავალი ზარი. უპასუხეთ ან უარყავით შემომავალი ზარი ახალი ზარის განხორციელებამდე."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ეს MMI კოდი ხელმისაწვდომი არ არის სხვადასხვა ანგარიშზე ზარების განხორცილებისას."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ზარის გათიშვა შეუძლებელია გაერთიანების დროს."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI კოდების აკრეფა შეუძლებელია გადაუდებელი ზარის განხორციელებისას."</string>
+    <string name="noApplications" msgid="1703149220378476198">"ვერცერთი აპი ვერ შეასრულებს ამ ქმედებას."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-ის სისტემა"</string>
 </resources>
diff --git a/res/values-kk/strings.xml b/res/values-kk/strings.xml
index af0026631..6f827c8dc 100644
--- a/res/values-kk/strings.xml
+++ b/res/values-kk/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Қоңырау шалу мүмкін емес, себебі онсыз да екі қоңырау жүріп жатыр. Жаңа қоңырау шалмас бұрын, қоңыраулардың бірін тоқтатыңыз немесе оларды бір конференцияға біріктіріңіз."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Қоңырау шалу мүмкін емес, себебі онсыз да екі қоңырау жүріп жатыр. Жаңа қоңырау шалмас бұрын, қоңыраулардың бірін тоқтатыңыз."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Қоңырау шалу мүмкін емес, себебі жүріп жатқан қоңырау кідіртілмейді. Жаңадан қоңырау шалу үшін жүріп жатқан қоңырауды тоқтатыңыз."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Ағымдағы қоңырауды ауыстыру мүмкін емес, себебі онда қоңырауды кідірту мүмкіндігі жоқ. Кідіртілген қоңырауды белсенді қылу үшін ағымдағы қоңырауды тоқтатыңыз."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Қоңырау шалу мүмкін емес, себебі жауап бермеген кіріс қоңырау бар. Жаңа қоңырау шалу үшін кіріс қоңырауға жауап беріңіз немесе оны қабылдамаңыз."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Бұл MMI кодын бірнеше аккаунттағы қоңыраулар үшін пайдалану мүмкін емес."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Біріктіру кезінде қоңырауды ажырату мүмкін емес."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Құтқару қызметіне қоңырау шалу кезінде MMI кодтары терілмейді."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Бұл әрекетті ешбір қолданба орындай алмайды."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android жүйесі"</string>
 </resources>
diff --git a/res/values-km/strings.xml b/res/values-km/strings.xml
index 578fff152..19a08a628 100644
--- a/res/values-km/strings.xml
+++ b/res/values-km/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"មិន​អាច​ធ្វើ​ការហៅ​ទូរសព្ទ​បាន​ទេ ដោយសារ​មាន​ការហៅ​ទូរសព្ទ​ពីរ​កំពុង​ដំណើរការ​រួច​ហើយ។ ផ្ដាច់​ការហៅ​ទូរសព្ទ​មួយ ឬ​ដាក់​ការហៅ​ទូរសព្ទ​ទាំងនេះ​ចូល​គ្នា​ជា​ការហៅជាក្រុម មុន​នឹង​ធ្វើ​ការហៅ​ទូរសព្ទ​ថ្មី។"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"មិនអាច​ធ្វើ​ការហៅ​ទូរសព្ទ​បានទេ ដោយសារ​មាន​ការហៅ​ទូរសព្ទ​ពីរ​កំពុង​ដំណើរការ​ស្រាប់​ហើយ។ សូមផ្ដាច់​ការហៅ​ទូរសព្ទ​មួយសិន មុនពេល​ធ្វើការហៅ​ទូរសព្ទថ្មី។"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"មិនអាច​ធ្វើការហៅ​ទូរសព្ទ​បានទេ ដោយសារ​មានការហៅ​ទូរសព្ទ​ដែលមិនអាច​ដាក់ឱ្យ​រង់ចាំបាន។ សូមផ្ដាច់​ការហៅ​ទូរសព្ទ​នោះសិន មុនពេល​ធ្វើការហៅ​ទូរសព្ទថ្មី។"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"មិនអាចប្ដូរ​ការហៅ​ទូរសព្ទ​ដែលកំពុង​ដំណើរការ​បានទេ ដោយសារ​វាមិនអាច​ដាក់ឱ្យ​រង់ចាំបាន។ សូមផ្ដាច់​ការហៅទូរសព្ទ​នោះ ដើម្បី​ដំណើរការ​ការហៅទូរសព្ទ​ដែលបាន​ដាក់ឱ្យ​រង់ចាំ។"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"មិន​អាច​ធ្វើ​ការហៅ​ទូរសព្ទ​បាន​ទេ ដោយសារ​មាន​ការហៅ​ចូល​មួយ​ដែល​មិន​បាន​ឆ្លើយតប។ ឆ្លើយតប ឬ​ច្រានចោល​ការហៅ​ចូល មុន​ពេល​ធ្វើ​ការហៅ​ទូរសព្ទ​ថ្មី។"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"មិនអាចប្រើលេខកូដ MMI នេះសម្រាប់ការហៅទូរសព្ទនៅលើ​គណនី​ច្រើនបានទេ។"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"មិនអាច​ផ្ដាច់​ការហៅទូរសព្ទ ក្នុង​អំឡុងពេល​ដាក់​ចូលគ្នា​បានទេ។"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"មិនអាច​ចុចលេខ​កូដ MMI ក្នុង​អំឡុងពេល​ហៅ​ទៅលេខ​សង្គ្រោះ​បន្ទាន់​បានទេ។"</string>
+    <string name="noApplications" msgid="1703149220378476198">"មិន​មាន​កម្មវិធី​ដែលអាចធ្វើ​សកម្មភាពនេះ​បាន​ទេ។"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"ប្រព័ន្ធ Android"</string>
 </resources>
diff --git a/res/values-kn/strings.xml b/res/values-kn/strings.xml
index 40319b3cc..c1a396166 100644
--- a/res/values-kn/strings.xml
+++ b/res/values-kn/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ಈಗಾಗಲೇ ಎರಡು ಕರೆಗಳು ಪ್ರಗತಿಯಲ್ಲಿರುವ ಕಾರಣ ಕರೆ ಮಾಡಲು ಸಾಧ್ಯವಿಲ್ಲ. ಒಂದು ಕರೆಯನ್ನು ಡಿಸ್‌ಕನೆಕ್ಟ್ ಮಾಡಿ ಅಥವಾ ಹೊಸ ಕರೆಯನ್ನು ಮಾಡುವ ಮೊದಲು ಎರಡು ಕರೆಗಳನ್ನು ಒಂದೇ ಕಾನ್ಫರೆನ್ಸ್‌ನಲ್ಲಿ ವಿಲೀನಗೊಳಿಸಿ."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ಈಗಾಗಲೇ ಎರಡು ಕರೆಗಳು ಪ್ರಗತಿಯಲ್ಲಿರುವ ಕಾರಣ ಕರೆ ಮಾಡಲು ಸಾಧ್ಯವಿಲ್ಲ. ಹೊಸ ಕರೆಯನ್ನು ಮಾಡುವ ಮೊದಲು ಒಂದು ಕರೆಯನ್ನು ಡಿಸ್‌ಕನೆಕ್ಟ್ ಮಾಡಿ."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ಈಗಾಗಲೇ ಪ್ರಗತಿಯಲ್ಲಿರುವ ಕರೆಯನ್ನು ಹೋಲ್ಡ್ ಮಾಡಲು ಸಾಧ್ಯವಿಲ್ಲದ ಕಾರಣ, ಕರೆ ಮಾಡಲು ಸಾಧ್ಯವಿಲ್ಲ. ಹೊಸ ಕರೆಯನ್ನು ಮಾಡುವ ಮೊದಲು ಕರೆಯನ್ನು ಡಿಸ್‌ಕನೆಕ್ಟ್ ಮಾಡಿ."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"ಸಕ್ರಿಯ ಕರೆಯನ್ನು ಬದಲಾಯಿಸಲು ಸಾಧ್ಯವಿಲ್ಲ ಏಕೆಂದರೆ ಇದು ಹೋಲ್ಡ್ ಮಾಡುವುದನ್ನು ಬೆಂಬಲಿಸುವುದಿಲ್ಲ. ಹೋಲ್ಡ್ ಮಾಡಿದ ಕರೆಯನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು ಕರೆಯನ್ನು ಡಿಸ್‌ಕನೆಕ್ಟ್ ಮಾಡಿ."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ಉತ್ತರಿಸದ ಒಳಬರುವ ಕರೆ ಬರುತ್ತಿರುವುದರಿಂದ ಕರೆ ಮಾಡಲು ಸಾಧ್ಯವಾಗುವುದಿಲ್ಲ. ಹೊಸ ಕರೆಯನ್ನು ಮಾಡುವ ಮೊದಲು ಕರೆಗೆ ಉತ್ತರ ನೀಡಿ ಅಥವಾ ತಿರಸ್ಕರಿಸಿ."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ಬಹು ಖಾತೆಗಳಾದ್ಯಂತ ಕರೆಗಳಿಗೆ ಈ MMI ಕೋಡ್ ಲಭ್ಯವಿರುವುದಿಲ್ಲ."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ವಿಲೀನಗೊಳಿಸುವ ಸಮಯದಲ್ಲಿ ಕರೆಯ ಸಂಪರ್ಕವನ್ನು ಕಡಿತಗೊಳಿಸಲಾಗುವುದಿಲ್ಲ."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ತುರ್ತು ಕರೆಯ ಸಮಯದಲ್ಲಿ MMI ಕೋಡ್‌ಗಳನ್ನು ಡಯಲ್ ಮಾಡಲು ಸಾಧ್ಯವಿಲ್ಲ."</string>
+    <string name="noApplications" msgid="1703149220378476198">"ಯಾವುದೇ ಆ್ಯಪ್‌ಗಳು ಈ ಕ್ರಿಯೆಗಾಗಿ ಬದ್ಧತೆ ತೋರಿಸುವುದಿಲ್ಲ."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android ಸಿಸ್ಟಂ"</string>
 </resources>
diff --git a/res/values-ko/strings.xml b/res/values-ko/strings.xml
index bd19dc271..ca604e6e8 100644
--- a/res/values-ko/strings.xml
+++ b/res/values-ko/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"이미 진행 중인 두 건의 통화가 있으므로 전화를 걸 수 없습니다. 통화 중 하나를 연결 해제하거나 두 통화를 다자간 통화로 병합한 후 새로운 전화를 걸 수 있습니다."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"이미 진행 중인 두 건의 통화가 있으므로 전화를 걸 수 없습니다. 통화 중 하나를 연결 해제한 후 새로운 전화를 걸 수 있습니다."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"대기할 수 없는 통화가 있으므로 전화를 걸 수 없습니다. 새로 전화를 걸기 전에 통화를 종료하세요."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"대기 중인 통화는 지원되지 않으므로 활성 통화를 전환할 수 없습니다. 대기 중인 통화를 활성화하려면 진행 중인 통화를 끊으세요."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"받지 않은 수신 전화가 있으므로 전화를 걸 수 없습니다. 새로 전화를 걸기 전에 수신 전화를 받거나 거절하세요."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"이 MMI 코드는 여러 계정 간에 통화에 사용할 수 없습니다."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"통화 병합 중에는 통화를 끊을 수 없습니다."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"긴급 전화 중에는 MMI 코드로 전화를 걸 수 없습니다."</string>
+    <string name="noApplications" msgid="1703149220378476198">"작업을 수행할 수 있는 앱이 없습니다."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android 시스템"</string>
 </resources>
diff --git a/res/values-ky/strings.xml b/res/values-ky/strings.xml
index c1bf92160..b10f5f3a8 100644
--- a/res/values-ky/strings.xml
+++ b/res/values-ky/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Чалуу аткарылбайт, анткени эки чалуу аткарылууда. Бир чалууну өчүрүңүз же аларды конференцияга бириктириңиз."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Эки чалуу аткарылууда, андыктан чалууга болбойт. Жаңы чалуу аткаруудан мурун учурдагы чалуулардын бирин бүтүрүңүз."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Чалуу мүмкүн эмес, анткени кармалбаган чалуу бар. Жаңы чалуудан мурда учурдагыны бүтүрүңүз."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Кармап турууну колдоого албагандыктан жигердүү чалууну которуштурууга болбойт. Кармалып турган чалууну жигердүү кылуу үчүн учурдагы чалууну ажыратыңыз."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Чалуу аткарылбайт, анткени кирүүчү чалууга жооп берилген жок. Жаңы чалуу аткаруудан мурун кирүүчү чалууга жооп бериңиз же четке кагыңыз."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Бул MMI коду бир нече аккаунт аркылуу чалуулар үчүн жеткиликсиз."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Бириктирип жатканда чалууну ажыратуу мүмкүн эмес."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Шашылыш чалуу учурунда MMI коддорун терүүгө болбойт."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Бул аракетти аткара турган колдонмо жок."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android системасы"</string>
 </resources>
diff --git a/res/values-lo/strings.xml b/res/values-lo/strings.xml
index 288614f6e..60b683108 100644
--- a/res/values-lo/strings.xml
+++ b/res/values-lo/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ບໍ່ສາມາດໂທໄດ້ເນື່ອງຈາກມີສອງສາຍກຳລັງໂທຢູ່. ກະລຸນາຕັດການເຊື່ອມຕໍ່ສາຍໃດໜຶ່ງອອກ ຫຼື ຮວມສາຍເປັນການປະຊຸມທາງໂທລະສັບກ່ອນໂທໃໝ່."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ບໍ່ສາມາດໂທອອກໄດ້ເນື່ອງຈາກມີສອງສາຍທີ່ພວມດຳເນີນຢູ່. ຕັດການເຊື່ອມຕໍ່ສາຍໃດໜຶ່ງກ່ອນທີ່ຈະໂທໃໝ່."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ບໍ່ສາມາດໂທໄດ້ເນື່ອງຈາກມີການໂທທີ່ບໍ່ສາມາດຖືສາຍຄ້າງໄວ້ໄດ້. ຕັດການເຊື່ອມຕໍ່ສາຍກ່ອນໂທໃໝ່."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"ບໍ່ສາມາດສະຫຼັບສາຍໂທທີ່ດຳເນີນຢູ່ເນື່ອງຈາກມັນບໍ່ຮອງຮັບການຖືສາຍ. ວາງສາຍເພື່ອລົມສາຍໂທທີ່ຖືໄວ້."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ບໍ່ສາມາດໂທອອກໄດ້ເນື່ອງຈາກມີສາຍໂທເຂົ້າທີ່ຍັງບໍ່ໄດ້ຮັບຢູ່. ກະລຸນາຮັບສາຍ ຫຼື ວາງສາຍທີ່ກຳລັງໂທເຂົ້າມາກ່ອນຈະໂທໃໝ່."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ລະຫັດ MMI ນີ້ແມ່ນໃຊ້ບໍ່ໄດ້ສໍາລັບການໂທດ້ວຍຫຼາຍບັນຊີ."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ບໍ່ສາມາດຕັດການເຊື່ອມຕໍ່ການໂທໃນລະຫວ່າງການຮວມໄດ້."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ບໍ່ສາມາດກົດລະຫັດ MMI ໄດ້ໃນລະຫວ່າງການໂທ​ສຸກ​ເສີນໄດ້."</string>
+    <string name="noApplications" msgid="1703149220378476198">"ບໍ່ມີແອັບໃດສາມາດເຮັດວຽກນີ້ໄດ້."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"ລະບົບ Android"</string>
 </resources>
diff --git a/res/values-lt/strings.xml b/res/values-lt/strings.xml
index da31d3647..03bebfe62 100644
--- a/res/values-lt/strings.xml
+++ b/res/values-lt/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Negalite skambinti, nes jau dalyvaujate dviejuose skambučiuose. Prieš pradėdami naują skambutį užbaikite vieną iš skambučių arba sujunkite juos į konferenciją."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Negalite skambinti, nes jau dalyvaujate dviejuose skambučiuose. Prieš pradėdami naują skambutį užbaikite vieną iš skambučių"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Negalite skambinti, nes yra skambutis, kurio negalima sulaikyti. Prieš pradėdami naują skambutį nutraukite esamą."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Negalima sukeisti aktyvaus skambučio, nes jame nepalaikomas sulaikymas. Nutraukite skambutį, kad sulaikytas skambutis taptų aktyvus."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Negalite skambinti, nes yra neatsakytas gaunamasis skambutis. Atsiliepkite arba atmeskite gaunamąjį skambutį prieš pradėdami naują."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Šis MMI kodas nepasiekiamas skambučiuose keliose paskyrose."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Sujungiant negalima atjungti skambučio."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI kodų negalima rinkti per skambutį pagalbos numeriu."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Jokios programos negali atlikti šio veiksmo."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"„Android“ sistema"</string>
 </resources>
diff --git a/res/values-lv/strings.xml b/res/values-lv/strings.xml
index 24ad8a08b..74bbf47b6 100644
--- a/res/values-lv/strings.xml
+++ b/res/values-lv/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Nevar veikt zvanu, jo pašlaik jau notiek divi zvani. Pirms jauna zvana veikšanas pārtrauciet vienu no pašreizējiem zvaniem vai apvienojiet tos konferences zvanā."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Nevar veikt zvanu, jo pašlaik jau notiek divi zvani. Pirms jauna zvana veikšanas pārtrauciet vienu no pašreizējiem zvaniem."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nevar veikt zvanu, jo pašlaik notiek zvans, ko nevar pārtraukt. Pirms jauna zvana veikšanas pārtrauciet pašreizējo zvanu."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Nevar pārslēgt aktīvo zvanu, jo tam netiek atbalstīta aizturēšana. Pārtrauciet pašreizējo zvanu, lai aizturētais zvans kļūtu aktīvs."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nevar veikt zvanu, jo ir neatbildēts ienākošais zvans. Pirms jauna zvana veikšanas atbildiet uz ienākošo zvanu vai noraidiet to."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Šis MMI kods nav pieejams zvaniem vairākos kontos."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Apvienošanas laikā nevar pārtraukt zvanu."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI kodus nevar ievadīt ārkārtas izsaukuma laikā."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Šo darbību nevar veikt neviena lietotne."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android sistēma"</string>
 </resources>
diff --git a/res/values-mcc214/config.xml b/res/values-mcc214/config.xml
new file mode 100644
index 000000000..941084865
--- /dev/null
+++ b/res/values-mcc214/config.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2018, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You my obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<!-- These resources are around just to allow their values to be customized
+     for different hardware and product builds. -->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <!-- String array containing numbers that shouldn't be logged
+       016 present here for Spain's gender violence number -->
+  <string-array translatable="false" name="unloggable_phone_numbers">
+    <item>016</item>
+  </string-array>
+</resources>
diff --git a/res/values-mk/strings.xml b/res/values-mk/strings.xml
index dca758bf7..2fcd4513a 100644
--- a/res/values-mk/strings.xml
+++ b/res/values-mk/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Не може да се воспостави повик бидејќи веќе се во тек два повика. Исклучете го едниот од повиците или спојте ги во конференциски повик пред да воспоставите нов повик."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Не може да се воспостави повик бидејќи веќе има два повика во тек. Прекинете еден од повиците пред да воспоставите нов повик."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Не може да се воспостави повик бидејќи има повик што не може да се стави на чекање. Исклучете го повикот пред да воспоставите нов повик."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Активниот повик не може да се замени бидејќи не поддржува ставање на чекање. Прекинете го повикот за да го активирате повикот на чекање."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Не може да се воспостави повик затоа што има неодговорен дојдовен повик. Одговорете или одбијте го дојдовниот повик пред воспоставувањето на новиот повик."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"MMI-кодов не е достапен за повици на повеќе сметки."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Повикот не може да се прекине додека се врши спојување."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"MMI-кодовите не може да се бираат за време на итен повик."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Нема апликации што може да го извршат дејствово."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Систем Android"</string>
 </resources>
diff --git a/res/values-ml/strings.xml b/res/values-ml/strings.xml
index fd6f31399..94190e11c 100644
--- a/res/values-ml/strings.xml
+++ b/res/values-ml/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"രണ്ട് കോളുകൾ നിലവിൽ പുരോഗമിക്കുന്നതിനാൽ, ഇനിയൊരു കോൾ കൂടി ചെയ്യാനാകില്ല. പുതിയൊരു കോൾ ചെയ്യുന്നതിന് മുമ്പ്, കോളുകളിലൊരെണ്ണം വിച്ഛേദിക്കുകയോ അവ കോൺഫറൻസ് കോളായി ലയിപ്പിക്കുകയോ ചെയ്യുക."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"രണ്ട് കോളുകൾ നിലവിൽ പുരോഗമിക്കുന്നതിനാൽ, ഇനിയൊരു കോൾ കൂടി ചെയ്യാനാകില്ല. പുതിയൊരു കോൾ ചെയ്യുന്നതിന് മുമ്പ് കോളുകളിലൊന്ന് വിച്ഛേദിക്കുക."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ഹോൾഡ് ചെയ്യാനാകാത്ത കോൾ പുരോഗമിക്കുന്നതിനാൽ ഇനിയൊരു കോൾ കൂടി ചെയ്യാനാകില്ല. പുതിയൊരു കോൾ ചെയ്യുന്നതിന് മുമ്പ് കോൾ വിച്ഛേദിക്കുക."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"ഹോൾഡ് ചെയ്യൽ പിന്തുണയ്ക്കാത്തതിനാൽ, സജീവമായ കോൾ സ്വാപ്പ് ചെയ്യാനാകില്ല. ഹോൾഡ് ചെയ്തിരിക്കുന്ന കോൾ സജീവമാക്കാൻ, ആദ്യത്തെ കോൾ വിച്ഛേദിക്കുക."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"മറുപടി ലഭിക്കാത്ത ഒരു ഇൻ‌കമിംഗ് കോൾ ഉള്ളതിനാൽ, പുതിയൊരു കോൾ ചെയ്യാനാവില്ല. പുതിയ കോൾ ചെയ്യുന്നതിന് മുമ്പ് ഇൻകമിംഗ് കോളിന് മറുപടി നൽകുകയോ നിരസിക്കുകയോ ചെയ്യുക."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ഒന്നിലധികം അക്കൗണ്ടുകളിലുടനീളം കോളുകൾക്ക് ഈ MMI കോഡ് ലഭ്യമല്ല."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ലയിപ്പിക്കുന്നതിനിടെ കോൾ വിച്‌ഛേദിക്കാനാകില്ല."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"എമർജൻസി കോളിനിടെ MMI കോഡുകൾ ഡയൽ ചെയ്യാനാകില്ല."</string>
+    <string name="noApplications" msgid="1703149220378476198">"ആപ്പുകൾക്കൊന്നും ഈ പ്രവർത്തനം നിർവഹിക്കാൻ കഴിയുന്നില്ല."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android സിസ്റ്റം"</string>
 </resources>
diff --git a/res/values-mn/strings.xml b/res/values-mn/strings.xml
index e116f9912..edefdf686 100644
--- a/res/values-mn/strings.xml
+++ b/res/values-mn/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Аль хэдийн хоёр дуудлага хийж байгаа тул дуудлага хийх боломжгүй байна. Шинэ дуудлага хийхээсээ өмнө аль нэг дуудлагыг салгах эсвэл тэдгээрийг хурал болгож нэгтгэнэ үү."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Аль хэдийн хоёр дуудлага хийж байгаа тул дуудлага хийх боломжгүй. Шинэ дуудлага хийхээсээ өмнө аль нэг дуудлагыг салгана уу."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Хүлээлгэх боломжгүй дуудлага байгаа тул дуудлага хийх боломжгүй. Шинэ дуудлага хийхээсээ өмнө тухайн дуудлагыг салгана уу."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Идэвхтэй дуудлага нь хүлээлгэхийг дэмждэггүй тул солих боломжгүй. Хүлээлгэсэн дуудлагыг идэвхтэй болгохын тулд дуудлагыг тасална уу."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Хариулаагүй ирсэн дуудлага байгаа тул дуудлага хийх боломжгүй. Шинэ дуудлага хийхээсээ өмнө ирсэн дуудлагад хариулах эсвэл тасална уу."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Энэ MMI код нь олон бүртгэл дээрх дуудлагад боломжгүй."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Нэгтгэх үеэр дуудлагыг салгах боломжгүй."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Яаралтай дуудлагын үеэр MMI кодыг оруулах боломжгүй."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ямар ч апп энэ үйлдлийг гүйцэтгэх боломжгүй."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android систем"</string>
 </resources>
diff --git a/res/values-mr/strings.xml b/res/values-mr/strings.xml
index 232b8f43c..7a4c40c06 100644
--- a/res/values-mr/strings.xml
+++ b/res/values-mr/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"आधीच दोन कॉल सुरू असल्यामुळे कॉल करू शकत नाही. नवीन कॉल करण्यापूर्वी त्यांपैकी एक कॉल डिस्कनेक्ट करा किंवा त्यांना कॉन्फरन्समध्ये मर्ज करा."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"आधीच दोन कॉल सुरू असल्यामुळे कॉल करू शकत नाही. नवीन कॉल करण्यापूर्वी त्यांपैकी एक कॉल डिस्कनेक्ट करा."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"होल्डवर न ठेवता येणारा कॉल असल्यामुळे, कॉल करू शकत नाही. नवीन कॉल करण्यापूर्वी, कॉल डिस्कनेक्ट करा."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"होल्ड करणे याला सपोर्ट नसल्यामुळे, ॲक्टिव्ह कॉल स्वॅप करू शकत नाही. होल्ड केलेला कॉल ॲक्टिव्ह करण्यासाठी कॉल डिस्कनेक्ट करा."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"इनकमिंग कॉलला उत्तर दिले जात नसल्यामुळे कॉल करू शकत नाही. नवीन कॉल करण्याआधी येणार्‍या कॉलला उत्तर द्या किंवा त्याला नकार द्या."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"हा MMI कोड एकाहून अधिक खात्यांवरील कॉलसाठी उपलब्ध नाही."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"मर्ज करणे सुरू असताना कॉल डिस्कनेक्ट करता येत नाही."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"आणीबाणीच्या कॉल दरम्यान MMI कोड डायल केले जाऊ शकत नाहीत."</string>
+    <string name="noApplications" msgid="1703149220378476198">"कोणतीही अ‍ॅप्स ही कृती करू शकत नाहीत."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android सिस्‍टीम"</string>
 </resources>
diff --git a/res/values-ms/strings.xml b/res/values-ms/strings.xml
index 20f2fde07..b3efddb13 100644
--- a/res/values-ms/strings.xml
+++ b/res/values-ms/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Tidak dapat membuat panggilan kerana sudah terdapat dua panggilan yang sedang berlangsung. Putuskan satu daripada panggilan itu atau gabungkan panggilan tersebut menjadi persidangan sebelum membuat panggilan baharu."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Tidak dapat membuat panggilan kerana sudah terdapat dua panggilan yang sedang berlangsung. Putuskan satu daripada panggilan sebelum ini untuk membuat panggilan baharu."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Tidak dapat membuat panggilan kerana terdapat panggilan yang sedang menunggu. Putuskan panggilan sebelum membuat panggilan baharu."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Tidak dapat menukar panggilan aktif kerana panggilan tidak menyokong penahanan. Putuskan sambungan panggilan untuk menjadikan panggilan yang ditahan aktif."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Tidak dapat membuat panggilan kerana terdapat panggilan masuk yang tidak dijawab. Jawab atau tolak panggilan masuk itu sebelum membuat panggilan baharu."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Kod MMI ini tidak tersedia untuk panggilan merentas berbilang akaun."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Panggilan tidak dapat diputuskan semasa penggabungan."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Kod MMI tidak boleh didail semasa panggilan kecemasan."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Tiada apl yang boleh menjalankan tindakan ini."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistem Android"</string>
 </resources>
diff --git a/res/values-my/strings.xml b/res/values-my/strings.xml
index 59fd1da41..2a7851000 100644
--- a/res/values-my/strings.xml
+++ b/res/values-my/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ခေါ်ဆိုမှုနှစ်ခုကို ပြုလုပ်နေသဖြင့် ဖုန်းထပ်ခေါ်၍မရပါ။ ခေါ်ဆိုမှုအသစ် မပြုလုပ်မီ ၎င်းတို့အနက် တစ်ခုကို ဖုန်းချပါ (သို့) အစည်းအဝေးအဖြစ် ပေါင်းစည်းပါ။"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ခေါ်ဆိုမှုနှစ်ခုကို ပြုလုပ်နေသဖြင့် ဖုန်းထပ်ခေါ်၍မရပါ။ ခေါ်ဆိုမှုအသစ် မပြုလုပ်မီ ၎င်းတို့အနက် တစ်ခုကို ဖုန်းချပါ။"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ဆိုင်းငံ့၍မရသော ခေါ်ဆိုမှုရှိနေသဖြင့် ဖုန်းထပ်ခေါ်၍မရပါ။ ခေါ်ဆိုမှုအသစ် မပြုလုပ်မီ ဤခေါ်ဆိုမှုကို ဖုန်းချပါ။"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"လက်ရှိခေါ်ဆိုမှုသည် ကိုင်ထားရန် မပံ့ပိုးသဖြင့် ၎င်းကို ပြောင်း၍မရပါ။ ကိုင်ထားသောဖုန်းကို ပြန်ပြောရန် လက်ရှိခေါ်ဆိုမှုကို အဆုံးသတ်ပါ။"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"မဖြေကြားရသေးသော အဝင်ခေါ်ဆိုမှု ရှိနေသဖြင့် ဖုန်းခေါ်၍ မရနိုင်ပါ။ အသစ်မခေါ်ဆိုမီ ဖုန်းကိုင်ပါ (သို့) ငြင်းပယ်ပါ။"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ဤ MMI ကုဒ်ကို အကောင့်အများအပြား၌ ခေါ်ဆိုမှုများအတွက် မရနိုင်ပါ။"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ပေါင်းစည်းနေစဉ် ခေါ်ဆိုမှုကို ဖြတ်တောက်၍မရပါ။"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"အရေးပေါ်ဖုန်းခေါ်နေစဉ်အတွင်း MMI ကုဒ်များကို ခေါ်၍မရနိုင်ပါ။"</string>
+    <string name="noApplications" msgid="1703149220378476198">"မည်သည့်အက်ပ်မျှ ဤလုပ်ဆောင်ချက်ကို မပြုလုပ်နိုင်ပါ။"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android စနစ်"</string>
 </resources>
diff --git a/res/values-nb/strings.xml b/res/values-nb/strings.xml
index 4299d10e2..eab33a5d5 100644
--- a/res/values-nb/strings.xml
+++ b/res/values-nb/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Du kan ikke ringe fordi to andre anrop allerede pågår. Koble fra ett av anropene eller slå dem sammen i en konferansesamtale, før du ringer på nytt."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Du kan ikke ringe fordi to andre anrop allerede pågår. Koble fra ett av anropene før du ringer på nytt."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Kan ikke ringe fordi det pågår en samtale som ikke kan settes på vent. Avslutt samtalen før du ringer på nytt."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Kan ikke bytte den aktive samtalen, fordi den ikke støtter ventemodus. Avslutt samtalen for å gå over til samtalen som er på vent."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Du kan ikke ringe, fordi du har et innkommende anrop. Svar på eller avvis anropet før du prøver å ringe igjen."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Denne MMI-koden kan ikke brukes til anrop på flere kontoer samtidig."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Anrop kan ikke kobles fra under en sammenslåing."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Det er ikke mulig å taste MMI-koder under nødanrop."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ingen apper kan gjøre dette."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-system"</string>
 </resources>
diff --git a/res/values-ne/strings.xml b/res/values-ne/strings.xml
index 336adc72b..ef74ce594 100644
--- a/res/values-ne/strings.xml
+++ b/res/values-ne/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"दुई वटा कल चलिरहेका हुनाले नयाँ कल गर्न सकिँदैन। नयाँ कल गर्नुअघि दुईमध्ये एउटा कल डिस्कनेक्ट गर्नुहोस् वा तिनलाई मर्ज गरी कन्फ्रेन्स कल बनाउनुहोस्।"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"दुई वटा कल चलिरहेका हुनाले नयाँ कल गर्न सकिँदैन। नयाँ कल गर्नुअघि दुईमध्ये एउटा कल डिस्कनेक्ट गर्नुहोस्।"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"होल्ड गर्न नमिल्ने कल चलिरहेको हुनाले नयाँ कल गर्न सकिँदैन। नयाँ कल गर्नुअघि यो कल डिस्कनेक्ट गर्नुहोस्।"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"यो कलमा होल्ड गर्ने सुविधा उपलब्ध नभएकाले यो कल बदल्न मिल्दैन। होल्डमा राखिएको कल सक्रिय बनाउन यो कल काट्नुहोस्।"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"अहिले आइरहेको कल नउठाइएको हुनाले नयाँ कल गर्न सकिँदैन। नयाँ कल गर्नुअघि उक्त कल उठाउनुहोस् वा काट्नुहोस्।"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"अर्को खातामार्फत कल चलिरहेका बेला यो MMI कोड प्रयोग गर्न मिल्दैन।"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"मर्ज गरिरहेका बेला कल डिस्कनेक्ट गर्न मिल्दैन।"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"आपत्कालीन कल चलिरहेका बेला MMI कोड डायल गर्न मिल्दैन।"</string>
+    <string name="noApplications" msgid="1703149220378476198">"कुनै पनि एपले यो कारबाही गर्न सक्दैन।"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android सिस्टम"</string>
 </resources>
diff --git a/res/values-nl/strings.xml b/res/values-nl/strings.xml
index bcf94aa52..5b3233d93 100644
--- a/res/values-nl/strings.xml
+++ b/res/values-nl/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Kan gesprek niet plaatsen omdat er al 2 actieve gesprekken zijn. Verbreek de verbinding in een van de gesprekken of voeg ze samen tot een conferencecall voordat je een nieuw gesprek plaatst."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Kan gesprek niet plaatsen omdat er al 2 actieve gesprekken zijn. Verbreek de verbinding van een van de gesprekken voordat je een nieuw gesprek plaatst."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Kan gesprek niet plaatsen omdat je het live gesprek niet in de wacht kunt zetten. Verbreek de verbinding van het live gesprek voordat je een nieuw gesprek plaatst."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Kan niet overschakelen vanuit het actieve gesprek, omdat het gesprek niet in de wacht kan worden gezet. Verbreek de verbinding om het gesprek dat in de wacht staat actief te maken."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Kan niet bellen omdat er een niet-beantwoord inkomend gesprek is. Beantwoord of weiger het inkomende gesprek voordat je opnieuw belt."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Deze MMI-code is niet beschikbaar voor gesprekken met meerdere accounts."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Gesprek kan niet worden verbroken tijdens samenvoegen."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Je kunt geen MMI-code kiezen tijdens een noodoproep."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Geen enkele app kan deze actie uitvoeren."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-systeem"</string>
 </resources>
diff --git a/res/values-or/strings.xml b/res/values-or/strings.xml
index 6081da88e..38b87ce87 100644
--- a/res/values-or/strings.xml
+++ b/res/values-or/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ପୂର୍ବରୁ ଦୁଇଟି କଲ ଚାଲୁ ଥିବା ଯୋଗୁଁ ଆଉ ଏକ କଲ କରାଯାଇପାରିବ ନାହିଁ। ଏକ ନୂଆ କଲ କରିବା ପୂର୍ବରୁ ଗୋଟିଏ କଲକୁ ଡିସକନେଜ୍ଟ କରନ୍ତୁ କିମ୍ବା ସେଗୁଡ଼ିକୁ ଏକ କନଫରେନ୍ସ କଲରେ ମର୍ଜ କରନ୍ତୁ।"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ପୂର୍ବରୁ ଦୁଇଟି କଲ ଚାଲିଛି ତେଣୁ କଲ କରାଯାଇପାରିବ ନାହିଁ। ନୂଆ କଲ କରିବା ପୂର୍ବରୁ ଗୋଟିଏ କଲ ଡିସକନେକ୍ଟ କରନ୍ତୁ।"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ହୋଲ୍ଡ କରିହେଉନଥିବା ଏକ କଲ ଚାଲୁ ଥିବା ଯୋଗୁଁ ଆଉ ଏକ କଲ କରାଯାଇପାରିବ ନାହିଁ। ଏକ ନୂଆ କଲ କରିବା ପୂର୍ବରୁ କଲକୁ ଡିସକନେକ୍ଟ କରନ୍ତୁ।"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"ଏହି ସକ୍ରିୟ କଲ ହୋଲ୍ଡକୁ ସପୋର୍ଟ କରୁନଥିବା ଯୋଗୁଁ ଏହାକୁ ସ୍ଵାପ କରାଯାଇପାରିବ ନାହିଁ। ହୋଲ୍ଡରେ ଥିବା କଲକୁ ସକ୍ରିୟ କରିବା ପାଇଁ କଲକୁ ଡିସକନେକ୍ଟ କରନ୍ତୁ।"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ଗୋଟିଏ ଉତ୍ତର ଦିଆଯାଇନଥିବା ଇନକମିଂ କଲ ଥିବା ଯୋଗୁଁ ଅନ୍ୟ ଏକ କଲ କରିପାରିବେ ନାହିଁ। ଏକ ନୂଆ କଲ କରିବା ପୂର୍ବରୁ ଇନକମିଂ କଲଟିର ଉତ୍ତର ଦିଅନ୍ତୁ କିମ୍ବା ଏହାକୁ ଅଗ୍ରାହ୍ୟ କରନ୍ତୁ।"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ଏକାଧିକ ଆକାଉଣ୍ଟରେ କଲଗୁଡ଼ିକ ପାଇଁ ଏହି MMI କୋଡ ଉପଲବ୍ଧ ନାହିଁ।"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ଏକ ମର୍ଜ ସମୟରେ କଲ ଡିସକନେକ୍ଟ ହୋଇପାରିବ ନାହିଁ।"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ଏକ ଜରୁରୀକାଳୀନ କଲ ସମୟରେ MMI କୋଡଗୁଡ଼ିକ ଡାଏଲ କରାଯାଇପାରିବ ନାହିଁ।"</string>
+    <string name="noApplications" msgid="1703149220378476198">"ଏହି କାର୍ଯ୍ୟ ପାଇଁ ଡିଭାଇସରେ କୌଣସି ଉପଯୁକ୍ତ ଆପ ନାହିଁ।"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android ସିଷ୍ଟମ"</string>
 </resources>
diff --git a/res/values-pa/strings.xml b/res/values-pa/strings.xml
index 2a2226419..5fd89a400 100644
--- a/res/values-pa/strings.xml
+++ b/res/values-pa/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ਕਾਲ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕਦੀ ਕਿਉਂਕਿ ਪਹਿਲਾਂ ਤੋਂ ਦੋ ਕਾਲਾਂ ਚੱਲ ਰਹੀਆਂ ਹਨ। ਨਵੀਂ ਕਾਲ ਕਰਨ ਤੋਂ ਪਹਿਲਾਂ ਕਿਸੇ ਇੱਕ ਕਾਲ ਨੂੰ ਡਿਸਕਨੈਕਟ ਕਰੋ ਜਾਂ ਦੋਨਾਂ ਕਾਲਾਂ ਨੂੰ ਮਿਲਾ ਕੇ ਕਾਨਫਰੰਸ ਕਾਲ ਵਿੱਚ ਬਦਲੋ।"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ਕਾਲ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕਦੀ ਕਿਉਂਕਿ ਪਹਿਲਾਂ ਤੋਂ ਦੋ ਕਾਲਾਂ ਚੱਲ ਰਹੀਆਂ ਹਨ। ਨਵੀਂ ਕਾਲ ਕਰਨ ਤੋਂ ਪਹਿਲਾਂ ਕਿਸੇ ਇੱਕ ਕਾਲ ਨੂੰ ਡਿਸਕਨੈਕਟ ਕਰੋ।"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ਕਾਲ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕਦੀ ਕਿਉਂਕਿ ਪਹਿਲਾਂ ਤੋਂ ਇੱਕ ਕਾਲ ਚੱਲ ਰਹੀ ਹੈ, ਜਿਸਨੂੰ ਹੋਲਡ \'ਤੇ ਨਹੀਂ ਰੱਖਿਆ ਜਾ ਸਕਦਾ। ਨਵੀਂ ਕਾਲ ਕਰਨ ਤੋਂ ਪਹਿਲਾਂ ਕਾਲ ਨੂੰ ਡਿਸਕਨੈਕਟ ਕਰੋ।"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"ਕਿਰਿਆਸ਼ੀਲ ਕਾਲ ਨੂੰ ਬਦਲਿਆ ਨਹੀਂ ਜਾ ਸਕਦਾ ਕਿਉਂਕਿ ਇਹ ਰੋਕ ਕੇ ਰੱਖਣ ਦਾ ਸਮਰਥਨ ਨਹੀਂ ਕਰਦੀ। ਰੋਕ ਕੇ ਰੱਖੀ ਕਾਲ ਨੂੰ ਕਿਰਿਆਸ਼ੀਲ ਕਰਨ ਲਈ ਕਾਲ ਨੂੰ ਡਿਸਕਨੈਕਟ ਕਰੋ।"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ਕਾਲ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕਦੀ ਕਿਉਂਕਿ ਇੱਕ ਜਵਾਬ ਨਾ ਦਿੱਤੀ ਗਈ ਇਨਕਮਿੰਗ ਕਾਲ ਪਹਿਲਾਂ ਤੋਂ ਹੀ ਆ ਰਹੀ ਹੈ। ਨਵੀਂ ਕਾਲ ਕਰਨ ਤੋਂ ਪਹਿਲਾਂ ਇਨਕਮਿੰਗ ਕਾਲ ਦਾ ਜਵਾਬ ਦਿਓ ਜਾਂ ਅਸਵੀਕਾਰ ਕਰੋ।"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ਇਹ MMI ਕੋਡ ਇੱਕ ਤੋਂ ਵੱਧ ਖਾਤਿਆਂ ਵਿੱਚ ਕਾਲਾਂ ਲਈ ਉਪਲਬਧ ਨਹੀਂ ਹੈ।"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ਕਾਨਫਰੰਸ ਦੌਰਾਨ ਕਾਲ ਨੂੰ ਡਿਸਕਨੈਕਟ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਦਾ।"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ਐਮਰਜੈਂਸੀ ਕਾਲ ਦੌਰਾਨ MMI ਕੋਡ ਡਾਇਲ ਨਹੀਂ ਕੀਤੇ ਜਾ ਸਕਦੇ।"</string>
+    <string name="noApplications" msgid="1703149220378476198">"ਕੋਈ ਵੀ ਐਪ ਇਸ ਕਾਰਵਾਈ ਨੂੰ ਨਹੀਂ ਕਰ ਸਕਦੀ।"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android ਸਿਸਟਮ"</string>
 </resources>
diff --git a/res/values-pl/strings.xml b/res/values-pl/strings.xml
index e5b73b1d8..833b5078d 100644
--- a/res/values-pl/strings.xml
+++ b/res/values-pl/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Nie można nawiązać połączenia, ponieważ trwają już 2 inne połączenia. Aby nawiązać nowe połączenie, zakończ jedno z nich lub scal je w połączenie konferencyjne."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Nie można nawiązać połączenia, ponieważ trwają już 2 połączenia. Aby nawiązać nowe połączenie, zakończ jedno z nich."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nie można nawiązać połączenia, ponieważ trwa połączenie, którego nie można wstrzymać. Aby nawiązać nowe połączenie, zakończ to połączenie."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Nie można przełączyć aktywnego połączenia, ponieważ nie obsługuje ono funkcji zawieszenia. Rozłącz połączenie, aby aktywować to, które zostało zawieszone."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nie można nawiązać połączenia, ponieważ masz nieodebrane połączenie przychodzące. Odbierz je lub odrzuć przed nawiązaniem nowego."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ten kod MMI nie jest dostępny w przypadku połączeń na więcej niż 1 koncie."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Połączenia nie można przerwać podczas scalania."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Nie można wybierać kodów MMI podczas połączenia alarmowego."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Żadna z aplikacji nie może wykonać tej czynności."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"System Android"</string>
 </resources>
diff --git a/res/values-pt-rPT/strings.xml b/res/values-pt-rPT/strings.xml
index 5c8777252..8de24bd12 100644
--- a/res/values-pt-rPT/strings.xml
+++ b/res/values-pt-rPT/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Não pode fazer uma chamada porque já existem 2 chamadas em curso. Desligue uma das chamadas ou una-as numa conferência antes de iniciar uma nova."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Não pode fazer uma chamada porque já existem 2 chamadas em curso. Desligue uma das chamadas antes de iniciar uma nova."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Não pode fazer uma chamada porque tem uma chamada que não pode ser colocada em espera. Termine essa chamada antes de fazer uma nova chamada."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Não é possível trocar a chamada ativa porque não é compatível com a colocação em espera. Termine a chamada para tornar a chamada em espera ativa."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Não pode fazer uma chamada porque há uma chamada recebida não atendida. Atenda ou rejeite a chamada recebida antes de fazer uma nova chamada."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Este código MMI não está disponível para chamadas em várias contas."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Não é possível desligar a chamada durante uma união."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Não é possível marcar códigos MMI durante uma chamada de emergência."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Nenhuma app pode realizar esta ação."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-pt/strings.xml b/res/values-pt/strings.xml
index dcaf3cc3c..1a1d17f17 100644
--- a/res/values-pt/strings.xml
+++ b/res/values-pt/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Não é possível ligar porque há duas chamadas em andamento. Encerre uma delas ou mescle-as em uma videoconferência antes de fazer outra."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Não é possível ligar porque há duas chamadas em andamento. Encerre uma das ligações antes de fazer outra."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Não é possível ligar porque há uma chamada que não pode ficar em espera. Encerre essa ligação antes de fazer outra."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Não é possível trocar a ligação ativa porque ela não pode ser colocada em espera. Desligue a chamada atual para ativar a que está em espera."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Não é possível ligar porque há uma ligação recebida que não foi atendida. Atenda ou rejeite essa chamada antes de fazer outra."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Este código MMI não está disponível para chamadas em várias contas."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Não é possível desligar a ligação durante uma mesclagem."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Não é possível discar códigos MMI durante uma chamada de emergência."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Nenhum app pode realizar esta ação."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistema Android"</string>
 </resources>
diff --git a/res/values-ro/strings.xml b/res/values-ro/strings.xml
index 16cc3cb24..608217389 100644
--- a/res/values-ro/strings.xml
+++ b/res/values-ro/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Nu se poate iniția un apel când există deja două apeluri în desfășurare. Deconectează unul dintre ele sau îmbină-le într-o conferință înainte de a iniția un apel nou."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Nu se poate iniția un apel când există deja două apeluri în desfășurare. Deconectează unul dintre apeluri înainte de a iniția un apel nou."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nu se poate iniția un apel când există un apel care nu poate fi pus în așteptare. Închide apelul înainte de a iniția un apel nou."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Nu se poate schimba apelul activ deoarece nu acceptă punerea în așteptare. Închide apelul pentru a activa apelul în așteptare."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nu se poate iniția un apel când primești un apel la care nu ai răspuns. Răspunde sau respinge apelul primit înainte de a iniția un apel nou."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Acest cod MMI nu este disponibil pentru apelurile din mai multe conturi."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Apelul nu poate fi deconectat în timpul îmbinării."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Codurile MMI nu pot fi formate în timpul unui apel de urgență."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Nicio aplicație nu poate efectua această acțiune."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistemul Android"</string>
 </resources>
diff --git a/res/values-ru/strings.xml b/res/values-ru/strings.xml
index 1e807d5b4..cbae9e394 100644
--- a/res/values-ru/strings.xml
+++ b/res/values-ru/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Невозможно позвонить, поскольку ещё не завершены два текущих вызова. Сбросьте один из вызовов или объедините их в конференцию."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Невозможно позвонить, поскольку ещё не завершены два текущих вызова. Сбросьте один из них."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Невозможно позвонить, поскольку нельзя поставить текущий вызов на удержание. Сбросьте вызов, чтобы начать новый."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Нельзя переключить активный звонок, поскольку он не поддерживает удержание. Чтобы активировать удерживаемый вызов, сбросьте текущий."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Невозможно позвонить, поскольку вы не ответили на входящий вызов. Примите или отклоните текущий звонок."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Этот код MMI недоступен для вызовов с использованием нескольких аккаунтов."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Звонок нельзя отключить во время объединения."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Коды MMI нельзя использовать во время экстренных вызовов."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Действие не поддерживается ни в одном приложении."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Система Android"</string>
 </resources>
diff --git a/res/values-si/strings.xml b/res/values-si/strings.xml
index 423c21ac8..7544a9c7c 100644
--- a/res/values-si/strings.xml
+++ b/res/values-si/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"දැනටමත් ඇමතුම් දෙකක් කෙරෙමින් පවතින නිසා ඇමතුමක් ගැනීමට නොහැක. නව ඇමතුමක් ගැනීමට පෙරාතුව ඇමතුම්වලින් එකක් විසන්ධි කරන්න නැතහොත් ඒවා සම්මන්ත්‍රණයකට ඒකාබද්ධ කරන්න."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"දැනටමත් ඇමතුම් දෙකක් ක්‍රියාත්මක වෙමින් පවතින බැවින් ඇමතුමක් ලබා ගත නොහැක. නව ඇමතුමක් ලබා ගැනීමට පෙර එක් ඇමතුමක් විසන්ධි කරන්න."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"රඳවා ගත නොහැකි ඇමතුමක් ඇති බැවින් ඇමතුමක් ලබා ගත නොහැක. නව ඇමතුමක් ලබා ගැනීමට පෙර ඇමතුම විසන්ධි කරන්න."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"සක්‍රිය ඇමතුම රඳවා තබා ගැනීමට සහාය නොදක්වන බැවින් එය මාරු කළ නොහැක. රඳවා ගත් ඇමතුම සක්‍රිය කිරීමට ඇමතුම විසන්ධි කරන්න."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"පිළිතුරු නොලැබෙන ඇමතුමක් ඇති බැවින් ඇමතුමක් ලබා ගත නොහැක. නව ඇමතුමක් ලබා ගැනීමට පෙර ලැබෙන ඇමතුමට පිළිතුරු දෙන්න හෝ ප්‍රතික්ෂේප කරන්න."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"මෙම MMI කේතය බහු ගිණුම් හරහා ඇමතුම් සඳහා ලබා ගත නොහැක."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ඒකාබද්ධ කිරීමේ දී ඇමතුම විසන්ධි කළ නොහැක."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"හදිසි ඇමතුමක දී MMI කේත ඇමතිය නොහැක."</string>
+    <string name="noApplications" msgid="1703149220378476198">"මෙම ක්‍රියාව සිදු කිරීමට කිසිදු යෙදුමකට නොහැක."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android පද්ධතිය"</string>
 </resources>
diff --git a/res/values-sk/strings.xml b/res/values-sk/strings.xml
index fe20409fa..7fceadad8 100644
--- a/res/values-sk/strings.xml
+++ b/res/values-sk/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Hovor sa nedá uskutočniť, pretože už prebiehajú dva hovory. Odpojte jeden hovor alebo ich zlúčte do konferencie a až potom uskutočnite nový hovor."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Hovor sa nedá uskutočniť, pretože už prebiehajú dva hovory. Pred uskutočnením nového hovoru ukončite jeden z prebiehajúcich hovorov."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Hovor sa nedá uskutočniť, pretože prebieha hovor, ktorý sa nedá podržať. Pred uskutočnením nového hovoru najprv ukončite ten prebiehajúci."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktívny hovor sa nedá prepnúť, pretože nepodporuje podržanie. Ak chcete aktivovať podržaný hovor, ukončite prebiehajúci hovor."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Hovor sa nedá uskutočniť, pretože máte neprijatý prichádzajúci hovor. Prijmite alebo odmietnite prichádzajúci hovor a až potom uskutočnite nový hovor."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Tento kód MMI nie je k dispozícii pre hovory v rámci viacerých účtov."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Počas zlúčenia nie je možné hovor odpojiť."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Kódy MMI nemožno vytočiť počas tiesňového volania."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Túto akciu nemôžu vykonávať žiadne aplikácie."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Systém Android"</string>
 </resources>
diff --git a/res/values-sl/strings.xml b/res/values-sl/strings.xml
index 5b6b41871..1986eaeeb 100644
--- a/res/values-sl/strings.xml
+++ b/res/values-sl/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Klica ni mogoče opraviti, ker potekata že dva klica. Preden začnete nov klic, prekinite enega od klicev ali ju združite v konferenčni klic."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Klica ni mogoče opraviti, ker potekata že dva klica. Preden začnete nov klic, prekinite enega od klicev."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Klica ni mogoče opraviti, ker že imate klic, ki ga ni mogoče zadržati. Preden opravite nov klic, prekinite omenjeni klic."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Aktivnega klica ni mogoče zamenjati, ker ne podpira zadržanja. Prekinite klic, da zadržani klic postane aktiven."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Klica ni mogoče opraviti, ker imate dohodni klic, na katerega še niste odgovorili. Preden začnete nov klic, sprejmite ali zavrnite dohodni klic."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ta koda MMI ni na voljo za klice v več računih."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Klica med združevanjem ni mogoče prekiniti."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Med klicem v sili ni mogoče vnesti kod MMI."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Tega dejanja ne more izvesti nobena aplikacija."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistem Android"</string>
 </resources>
diff --git a/res/values-sq/strings.xml b/res/values-sq/strings.xml
index fb53968a7..6ec87725d 100644
--- a/res/values-sq/strings.xml
+++ b/res/values-sq/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Nuk mund të kryhet një telefonatë sepse janë tashmë dy telefonata në vazhdim. Shkëput një nga telefonatat ose shkriji ato në një konferencë para se të kryesh një telefonatë të re."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Nuk mund të kryhet një telefonatë sepse janë tashmë dy telefonata në vazhdim. Shkëput një nga telefonatat para se të kryesh një telefonatë të re."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Nuk mund të kryhet një telefonatë pasi është në telefonatë që nuk mund të vendoset në pritje. Shkëput telefonatën para se të kryesh një telefonatë të re."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Telefonata aktive nuk mund të ndërrohet sepse nuk mbështetet vënia në pritje. Shkëput telefonatën për ta bërë aktive telefonatën në pritje."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Nuk mund të kryhet një telefonatë sepse është një telefonatë hyrëse që nuk ka marrë përgjigje. Përgjigju ose refuzoje telefonatën hyrëse para se të kryesh një telefonatë të re."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Ky kod MMI nuk ofrohet për telefonatat në disa llogari."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Telefonata nuk mund të shkëputet gjatë një shkrirjeje."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Kodet MMI nuk mund të formohen gjatë një telefonate urgjence."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Asnjë aplikacion nuk mund ta kryejë këtë veprim."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Sistemi Android"</string>
 </resources>
diff --git a/res/values-sr/strings.xml b/res/values-sr/strings.xml
index 26855ac2d..130be732c 100644
--- a/res/values-sr/strings.xml
+++ b/res/values-sr/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Не можете да позовете јер су два позива већ у току. Прекините један од њих или их обједините у конференцију пре упућивања новог позива."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Не можете да позовете јер су два позива већ у току. Прекините један од позива пре упућивања новог позива."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Не можете да упутите позив јер је у току позив који не може да се стави на чекање. Прекините тај позив пре упућивања новог позива."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Не можете да замените активни позив јер не подржава стављање на чекање. Прекините позив у току да бисте активирали позив на чекању."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Не можете да позовете јер имате долазни позив на који нисте одговорили. Примите га или одбијте пре упућивања новог позива."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Овај MMI кôд није доступан за позиве на више налога."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Позив не може да се прекине током обједињавања."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Бирање MMI кодова ноје могуће током хитног позива."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Ниједна апликација не може да обавља ову радњу."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android систем"</string>
 </resources>
diff --git a/res/values-sv/strings.xml b/res/values-sv/strings.xml
index b86e26063..8116ace24 100644
--- a/res/values-sv/strings.xml
+++ b/res/values-sv/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Det går inte att ringa eftersom det redan finns två pågående samtal. Koppla bort ett eller slå ihop dem till en konferens innan du ringer ett nytt samtal."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Det går inte att ringa eftersom det redan finns två pågående samtal. Koppla bort ett av samtalen innan du ringer ett nytt samtal."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Det går inte att ringa eftersom det finns ett samtal som inte kan sättas i vänteläge. Koppla bort samtalet innan du ringer ett nytt samtal."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Det går inte att byta det aktiva samtalet eftersom det inte har stöd för parkering. Koppla från samtalet om du vill göra det parkerade samtalet aktivt."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Det går inte att ringa eftersom det finns ett obesvarat inkommande samtal. Svara eller avvisa det innan du ringer ett nytt samtal."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Den här MMI-koden är inte tillgänglig för samtal på flera konton."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Det går inte att koppla från samtalet under en sammanslagning."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Det går inte att ange MMI-koder under ett nödsamtal."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Inga appar kan utföra den här åtgärden."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android-system"</string>
 </resources>
diff --git a/res/values-sw/strings.xml b/res/values-sw/strings.xml
index 85760fed7..687f746da 100644
--- a/res/values-sw/strings.xml
+++ b/res/values-sw/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Imeshindwa kupiga simu kwa sababu tayari kuna simu mbili zinazoendelea. Kata mojawapo ya simu hizo au uziunganishe ili ziwe simu ya mkutano kabla ya kupiga simu mpya."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Imeshindwa kupiga simu kwa sababu tayari kuna simu mbili zinazoendelea. Kata mojawapo ya simu hizo kabla ya kupiga simu mpya."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Imeshindwa kupiga simu kwa sababu kuna simu isiyoweza kusubirishwa. Kata simu kabla ya kupiga simu mpya."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Huwezi kubadilisha simu inayoendelea kwa sababu haiwezi kusubirishwa. Kata simu ili uendele na simu iliyosubirishwa."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Haiwezi kupiga simu kwa sababu kuna simu unayopigiwa ambayo hujajibu. Jibu au ukatae simu hiyo unayopigiwa kabla ya kupiga simu mpya."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Msimbo huu wa MMI haupatikani katika simu kwenye akaunti nyingi."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Simu haiwezi kukatwa wakati wa kuunganisha."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Huwezi kupiga misimbo ya MMI wakati wa simu ya dharura."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Hakuna programu zinazoweza kutekeleza kitendo hiki."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Mfumo wa Android"</string>
 </resources>
diff --git a/res/values-ta/strings.xml b/res/values-ta/strings.xml
index aca2738e1..397141a84 100644
--- a/res/values-ta/strings.xml
+++ b/res/values-ta/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ஏற்கெனவே இரண்டு அழைப்புகள் செயலில் இருப்பதால் புதிய அழைப்பை மேற்கொள்ள முடியவில்லை. புதிதாக ஒரு அழைப்பை மேற்கொள்வதற்கு முன்னர் செயலில் உள்ள அழைப்புகளில் ஏதேனும் ஒன்றைத் துண்டிக்கவும் அல்லது அவற்றை இணைத்து குழு அழைப்பாக மாற்றவும்."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ஏற்கெனவே இரண்டு அழைப்புகள் செயலில் இருப்பதால் புதிய அழைப்பை மேற்கொள்ள முடியவில்லை. புதிதாக ஒரு அழைப்பை மேற்கொள்வதற்கு முன்னர் செயலில் உள்ள அழைப்புகளில் ஏதேனும் ஒன்றைத் துண்டிக்கவும்."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"ஹோல்டு செய்ய முடியாத ஓர் அழைப்பு ஏற்கெனவே செயலில் இருப்பதால் அழைப்பை மேற்கொள்ள முடியவில்லை. செயலில் உள்ள அழைப்பைத் துண்டித்து புதிய அழைப்பை மேற்கொள்ளவும்."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"செயலில் உள்ள அழைப்பை மாற்ற முடியாது. ஏனெனில், அதை ஹோல்டு செய்வது ஆதரிக்கப்படவில்லை. ஹோல்டில் உள்ள அழைப்பை ஏற்க செயலில் உள்ள அழைப்பைத் துண்டிக்கவும்."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"உள்வரும் அழைப்பிற்கு இன்னும் பதிலளிக்காததால் இந்த அழைப்பைச் செய்ய முடியாது. புதிதாக ஓர் அழைப்பைச் செய்யும் முன்னர் உள்வரும் அழைப்பிற்குப் பதிலளிக்கவும் அல்லது நிராகரிக்கவும்."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"பல கணக்குகளில் மேற்கொள்ளப்படும் அழைப்புகளுக்கு இந்த MMI குறியீட்டைப் பயன்படுத்த முடியாது."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ஒன்றிணைக்கும்போது அழைப்பைத் துண்டிக்க முடியாது."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"அவசர அழைப்பின்போது MMI குறியீடுகளை டயல் செய்ய முடியாது."</string>
+    <string name="noApplications" msgid="1703149220378476198">"இந்தச் செயலைச் செய்ய ஆப்ஸ் எதுவுமில்லை."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android சிஸ்டம்"</string>
 </resources>
diff --git a/res/values-te/strings.xml b/res/values-te/strings.xml
index 6e6776407..436fbbb44 100644
--- a/res/values-te/strings.xml
+++ b/res/values-te/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"ఇప్పటికే రెండు కాల్స్ జరుగుతున్నందున కాల్ చేయడం సాధ్యపడదు. ఆ కాల్స్‌లో ఒకదానిని డిస్‌కనెక్ట్ చేయండి లేదా అవి రెండింటినీ విలీనం చేసి ఒక కాన్ఫరెన్స్ కాల్‌గా మార్చి, తర్వాత కొత్త కాల్ చేయండి."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"ఇప్పటికే రెండు కాల్స్ ప్రోగ్రెస్‌లో ఉన్నందున కాల్ చేయడం సాధ్యం కాదు. కొత్త కాల్ చేయడానికంటే ముందుగా రెండు కాల్స్‌లో ఒకదాన్ని డిస్‌కనెక్ట్ చేయండి."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"హోల్డ్‌లో పెట్టడం సాధ్యం కాని కాల్ జరుగుతున్నందున కాల్ చేయడం సాధ్యం కాదు. కొత్త కాల్ చేయడానికంటే ముందుగా ప్రస్తుత కాల్‌ను డిస్‌కనెక్ట్ చేయండి."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"యాక్టివ్ కాల్‌ను మార్చడానికి వీలు కాదు, ఎందుకంటే దానిని హోల్డ్‌లో ఉంచలేము. కాల్‌ను డిస్‌కనెక్ట్ చేసి, హోల్డ్‌లో ఉన్న కాల్‌ను యాక్టివ్ కాల్‌గా చేయండి."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ఇన్‌కమింగ్ కాల్ వస్తున్నంతసేపు వేరొక కాల్ చేయడం సాధ్యపడదు. కొత్త కాల్ చేయడానికి ముందుగా ఇన్‌కమింగ్ కాల్‌కు సమాధానమివ్వండి లేదా కాల్‌ను నిరాకరించండి."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"ఈ MMI కోడ్ పలు ఖాతాలలో కాల్స్ కోసం అందుబాటులో లేదు."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"కాల్స్‌ను విలీనం చేస్తున్నప్పుడు వాటిని డిస్‌కనెక్ట్ చేయడం సాధ్యం కాదు."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ఎమర్జెన్సీ కాల్ సమయంలో MMI కోడ్‌లను డయల్ చేయడం సాధ్యం కాదు."</string>
+    <string name="noApplications" msgid="1703149220378476198">"ఈ చర్యను అమలు చేయగల యాప్‌లు ఏవీ లేవు."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android సిస్టమ్"</string>
 </resources>
diff --git a/res/values-th/strings.xml b/res/values-th/strings.xml
index a0a7fddae..14b301e90 100644
--- a/res/values-th/strings.xml
+++ b/res/values-th/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"โทรออกไม่ได้เนื่องจากมีการโทร 2 สายที่กำลังดำเนินอยู่ โปรดยกเลิกการเชื่อมต่อสายใดสายหนึ่งหรือรวมเป็นการประชุมสายก่อนโทรออกใหม่"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"โทรออกไม่ได้เนื่องจากมีการโทร 2 สายที่กำลังดำเนินอยู่ โปรดยกเลิกการเชื่อมต่อ 1 สายก่อนโทรออกใหม่"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"โทรออกไม่ได้เนื่องจากมีการโทรที่ไม่สามารถพักสายได้ โปรดยกเลิกการเชื่อมต่อสายดังกล่าวก่อนโทรออกใหม่"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"สลับการโทรที่ใช้งานอยู่ไม่ได้เนื่องจากไม่รองรับการพักสาย โปรดยกเลิกการเชื่อมต่อสายนี้เพื่อให้สายที่รออยู่ทำงาน"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"โทรออกไม่ได้เนื่องจากมีสายเรียกเข้าที่ยังไม่ได้รับ โปรดรับหรือปฏิเสธสายเรียกเข้าก่อนจึงค่อยโทรออกใหม่"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"รหัส MMI นี้ใช้ไม่ได้กับการโทรผ่านหลายบัญชี"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ยกเลิกการเชื่อมต่อสายไม่ได้ในระหว่างการรวมสาย"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"ไม่สามารถโทรออกด้วยโค้ด MMI ระหว่างการโทรฉุกเฉิน"</string>
+    <string name="noApplications" msgid="1703149220378476198">"ไม่มีแอปพลิเคชันใดทำงานนี้ได้"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"ระบบ Android"</string>
 </resources>
diff --git a/res/values-tl/strings.xml b/res/values-tl/strings.xml
index f7e32d572..6603e6f75 100644
--- a/res/values-tl/strings.xml
+++ b/res/values-tl/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Hindi puwedeng tumawag dahil mayroon nang dalawang tawag na kasalukuyang nagaganap. Idiskonekta ang isa sa mga tawag o i-merge ang mga ito sa isang conference bago gumawa ng bagong pagtawag."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Hindi puwedeng tumawag dahil mayroon nang dalawang tawag na kasalukuyang nagaganap Idiskonekta ang isa sa mga tawag bago gumawa ng bagong pagtawag."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Hindi puwedeng tumawag dahil may tawag na hindi puwedeng i-hold. Idiskonekta ang tawag bago gumawa ng bagong pagtawag."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Hindi masa-swap ang aktibong tawag dahil hindi nito sinusuportahan ang pag-hold. Idiskonekta ang tawag para gawing aktibo ang naka-hold na tawag."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Hindi puwedeng tumawag dahil mayroong hindi nasagot na papasok na tawag. Sagutin o tanggihan ang papasok na tawag bago gumawa ng bagong pagtawag."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Hindi available ang MMI code na ito para sa mga tawag sa magkakaibang account."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Hindi puwedeng idiskonekta ang tawag habang nagme-merge."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Hindi puwedeng mag-dial ng mga MMI code habang may emergency na tawag."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Walang app na makakagawa ng aksyong ito."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android System"</string>
 </resources>
diff --git a/res/values-tr/strings.xml b/res/values-tr/strings.xml
index 36feb7c6c..79591a218 100644
--- a/res/values-tr/strings.xml
+++ b/res/values-tr/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Devam eden iki arama olduğu için arama yapılamıyor. Yeni bir arama yapmadan önce aramalardan birini sonlandırın veya iki aramayı bir konferans aramasında birleştirin."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Devam eden iki arama olduğu için arama yapılamıyor. Yeni bir arama yapmadan önce aramalardan birini sonlandırın."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Bekletilemeyen bir arama devam ettiğinden arama yapılamıyor. Yeni bir arama yapmadan önce mevcut aramayı sonlandırın."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Bekletme özelliği desteklenmediğinden etkin arama değiştirilemiyor. Beklemedeki aramayı etkinleştirmek için mevcut aramayı sonlandırın."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Gelen arama olduğu için arama yapılamıyor. Yeni bir arama yapmadan önce gelen aramayı cevaplayın veya reddedin."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Bu MMI kodu, birden fazla hesaptan arama yapılırken kullanılamaz."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Birleştirilmiş aramadayken görüşme sonlandırılamaz."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Acil durum aramalarında MMI kodları kullanılamaz."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Bu eylemi hiçbir uygulama gerçekleştiremez."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android Sistemi"</string>
 </resources>
diff --git a/res/values-uk/strings.xml b/res/values-uk/strings.xml
index 7fc3fa817..a712c9fdf 100644
--- a/res/values-uk/strings.xml
+++ b/res/values-uk/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Неможливо зателефонувати, оскільки тривають уже два виклики. Припиніть один із них або об’єднайте їх у конференцію, перш ніж здійснити новий."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Неможливо зателефонувати, оскільки тривають уже два виклики. Припиніть один із них, перш ніж здійснити новий."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Неможливо зателефонувати, оскільки поточний виклик не можна поставити на утримання. Припиніть виклик, перш ніж здійснити новий."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Не вдалось активувати інший виклик, оскільки поточний не підтримує утримання. Щоб активувати виклик, що утримується, припиніть поточний."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Неможливо зателефонувати. Прийміть або відхиліть вхідний дзвінок, перш ніж здійснювати новий."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Цей код MMI недоступний для дзвінків із використанням кількох облікових записів."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Під час об’єднання виклик не можна завершити."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Не можна набирати коди MMI під час екстреного виклику."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Цю дію не може виконати жодний додаток."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Система Android"</string>
 </resources>
diff --git a/res/values-ur/strings.xml b/res/values-ur/strings.xml
index a08729338..497bbff02 100644
--- a/res/values-ur/strings.xml
+++ b/res/values-ur/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"پہلے سے دو کالز کے پیش رفت میں ہونے کی وجہ سے کال نہیں کی جا سکتی۔ نئی کال کرنے کیلئے پہلے ان میں سے ایک کو غیر منسلک کریں یا انہیں کانفرنس میں ضم کریں۔"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"کال نہیں کر سکتا کیونکہ پہلے سے ہی دو کالز جاری ہیں۔ نئی کال کرنے سے پہلے کالز میں سے ایک کو غیر منسلک کریں۔"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"کال نہیں کر سکتے کیونکہ پہلے سے جاری کال کو ہولڈ نہیں کیا جا سکتا۔ نئی کال کرنے سے پہلے موجودہ کال کو غیر منسلک کریں۔"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"فعال کال کا تبادلہ نہیں کیا جا سکتا کیونکہ اسے ہولڈ نہیں کیا جا سکتا۔ ہولڈ کردہ کال کو فعال کرنے کے لیے کال کو غیر منسلک کریں۔"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"ایک جواب نہ ملنے والی اِن کمنگ کال کی وجہ سے کال نہیں کی جا سکتی۔ نئی کال کرنے کے لیے پہلے اِن کمنگ کال کا جواب دیں یا مسترد کریں۔"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"‏یہ MMI کوڈ متعدد اکاؤنٹس پر کالز کے لیے دستیاب نہیں ہے۔"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"ضم کرنے کی کارروائی کے دوران، کال کو منقطع نہیں کیا جا سکتا۔"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"‏‫MMI کوڈز ایمرجنسی کال کے دوران ڈائل نہیں کیے جا سکتے۔"</string>
+    <string name="noApplications" msgid="1703149220378476198">"کوئی ایپ اس کارروائی کو انجام نہیں دے سکتی۔"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"‏‫Android سسٹم"</string>
 </resources>
diff --git a/res/values-uz/strings.xml b/res/values-uz/strings.xml
index 585a8690c..2ae110c55 100644
--- a/res/values-uz/strings.xml
+++ b/res/values-uz/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Telefon qilish imkonsiz, chunki ayni paytda ikkita chaqiruv davom etmoqda. Telefon qilish uchun chaqiruvlardan birini yakunlang yoki ularni konferens-aloqaga birlashtiring."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Telefon qilish imkonsiz, chunki ayni paytda ikkita chaqiruv davom etmoqda. Telefon qilish uchun avval mavjud bittasini uzing."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Chaqirish imkonsiz, chunki joriy chaqiruv pauza qilinmaydi. Yangisini boshlash uchun chaqiruvni bekor qiling."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Faol chaqiruvni almashtirish imkonsiz, chunki u ushlab turishni dastaklamaydi. Ushlab turilgan chaqiruvni faol qilish uchun chaqiruvni uzing."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Telefon qilish imkonsiz. Telefon qilish uchun avval kiruvchi chaqiruvni qabul qiling yoki rad eting."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Bu MMI kodi bir nechta hisobdagi chaqiruvlarda ishlamaydi."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Birlashtirish paytida chaqiruvni uzish imkonsiz."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Favqulodda chaqiruv paytida MMI kodlarini terish imkonsiz."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Hech qanday ilova ushbu amalni bajara olmaydi."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android tizimi"</string>
 </resources>
diff --git a/res/values-vi/strings.xml b/res/values-vi/strings.xml
index 224cba699..85611e00c 100644
--- a/res/values-vi/strings.xml
+++ b/res/values-vi/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Không thể thực hiện cuộc gọi vì đã có 2 cuộc gọi đang diễn ra. Hãy ngắt kết nối 1 trong các cuộc gọi hoặc gộp thành 1 cuộc gọi kiểu hội nghị truyền hình trước khi thực hiện cuộc gọi mới."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Không thể thực hiện cuộc gọi vì đã có 2 cuộc gọi đang diễn ra. Hãy ngắt kết nối 1 trong các cuộc gọi đó trước khi thực hiện cuộc gọi mới."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Không thể thực hiện cuộc gọi vì có một cuộc gọi không thể tạm ngưng. Hãy ngắt kết nối với cuộc gọi đó trước khi thực hiện cuộc gọi mới."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Không thể hoán đổi cuộc gọi đang diễn ra vì cuộc gọi đó không hỗ trợ tính năng giữ cuộc gọi. Hãy ngắt kết nối cuộc gọi đó để chuyển cuộc gọi được giữ thành cuộc gọi đang diễn ra."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Bạn không thể gọi vì chưa trả lời cuộc gọi đến. Hãy trả lời hoặc từ chối cuộc gọi đến trước khi thực hiện cuộc gọi mới."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Mã MMI này không dùng được cho các cuộc gọi trên nhiều tài khoản."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Không thể ngắt kết nối cuộc gọi trong khi hợp nhất."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Không thể quay số mã MMI trong khi thực hiện cuộc gọi khẩn cấp."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Không ứng dụng nào có thể thực hiện hành động này."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Hệ thống Android"</string>
 </resources>
diff --git a/res/values-zh-rCN/strings.xml b/res/values-zh-rCN/strings.xml
index 48c76e551..cc56426c4 100644
--- a/res/values-zh-rCN/strings.xml
+++ b/res/values-zh-rCN/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"由于已有两个正在进行的通话，因此无法拨打电话。请挂断其中一个通话或将两个通话合并到同一个会议中，然后才能拨打新电话。"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"由于已有两个正在进行的通话，因此无法拨打电话。请先挂断其中一个通话，然后再拨打新电话。"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"由于有无法暂停的通话，因此不能拨打电话。请先断开通话，然后再拨打新电话。"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"无法切换当前通话，因为它不支持保持通话功能。请挂断当前通话，以使保持中的通话变成当前通话。"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"由于有未接来电，因此无法拨打电话。请先接听或拒绝来电，然后才能拨打新电话。"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"此 MMI 码无法用于跨多个账号的通话。"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"合并期间无法断开通话。"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"在紧急呼叫期间，无法拨打 MMI 码。"</string>
+    <string name="noApplications" msgid="1703149220378476198">"没有应用可执行此操作。"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android 系统"</string>
 </resources>
diff --git a/res/values-zh-rHK/strings.xml b/res/values-zh-rHK/strings.xml
index 6388a828a..5bdb05551 100644
--- a/res/values-zh-rHK/strings.xml
+++ b/res/values-zh-rHK/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"目前已有兩個通話正在進行，因此無法撥打電話。請先結束其中一個通話，或將兩個通話合併為一個會議，然後再撥打電話。"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"目前已有兩個通話正在進行，因此無法撥打電話。請先結束其中一個通話，然後再撥打電話。"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"目前有一個無法保留的通話，因此無法撥打電話。請先結束通話，然後再撥打電話。"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"無法切換通話，因為目前的通話無法保留。請掛斷目前的通話，即可繼續接聽保留中的通話。"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"你尚未接聽目前的來電，因此無法撥打電話。請先接聽或拒絕來電，然後再撥打電話。"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"在透過多個帳戶進行通話時，無法使用 MMI 碼。"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"通話在合併期間無法中斷。"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"進行緊急電話時無法撥打 MMI 碼"</string>
+    <string name="noApplications" msgid="1703149220378476198">"沒有應用程式可執行這項操作。"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android 系統"</string>
 </resources>
diff --git a/res/values-zh-rTW/strings.xml b/res/values-zh-rTW/strings.xml
index 38976126d..23d60c307 100644
--- a/res/values-zh-rTW/strings.xml
+++ b/res/values-zh-rTW/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"目前有兩個進行中的通話，因此無法撥號。請掛斷其中一個通話，或將通話合併成會議，再撥打電話。"</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"目前有兩個進行中的通話，因此無法撥號。請先掛斷其中一個通話，再撥打電話。"</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"目前有無法保留的通話，因此無法撥號。請先掛斷通話，再撥打電話。"</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"目前的通話不支援保留功能，因此無法切換通話。如要接聽保留中的通話，請掛斷目前的通話。"</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"有人打電話給你，因此你目前無法撥打電話。你必須先接聽或拒接來電，才能撥打電話。"</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"這個 MMI 代碼無法用於透過多個帳戶進行通話。"</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"無法在通話合併期間掛斷電話。"</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"進行緊急電話時無法撥打 MMI 碼。"</string>
+    <string name="noApplications" msgid="1703149220378476198">"沒有應用程式可執行這項動作。"</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Android 系統"</string>
 </resources>
diff --git a/res/values-zu/strings.xml b/res/values-zu/strings.xml
index e1e73473a..a0df7d070 100644
--- a/res/values-zu/strings.xml
+++ b/res/values-zu/strings.xml
@@ -138,7 +138,11 @@
     <string name="callFailed_too_many_calls_include_merge" msgid="2234495082825519920">"Awukwazi ukwenza ikholi njengoba kunamakholi amabili aqhubekayo kakade. Nqamula eyodwa yamakholi noma wahlanganisele enkomfeni ngaphambi kokwenza ikholi entsha."</string>
     <string name="callFailed_too_many_calls_exclude_merge" msgid="8616011288480453495">"Awukwazi ukwenza ikholi njengoba sekunamakholi amabili aqhubekayo. Nqamula eyodwa yamakholi ngaphambi kokwenza ikholi entsha."</string>
     <string name="callFailed_unholdable_call" msgid="7580834131274566524">"Ayikwazi ukwenza ikholi njengoba kukhona ikholi engabanjwa. Nqamula ikholi ngaphambi kokwenza ikholi entsha."</string>
+    <string name="callSwapFailed_unholdable_call" msgid="4779540296319850415">"Ayikwazi ukushintshanisa ikholi eqhubekayo ngoba ayisekeli ukubamba. Nqamula ikholi ukuze wenze ikholi ebanjiwe iqhubeke."</string>
     <string name="callFailed_already_ringing" msgid="7931232733958098270">"Ayikwazi ukubeka ikholi njengoba kunekholi engenayo engaphenduliwe. Phendula noma nqaba ikholi engenayo ngaphambi kokubeka ikholi entsha."</string>
     <string name="callFailed_reject_mmi" msgid="5219280796733595167">"Le khodi ye-MMI ayitholakali ngamakholi kuma-akhawunti amaningi."</string>
+    <string name="call_hangup_fail_during_merge" msgid="4216015878956379200">"Ikholi ayikwazi ukunqanyulwa ngesikhathi sokuhlanganisa."</string>
     <string name="emergencyCall_reject_mmi" msgid="5056319534549705785">"Amakhodi e-MMI awakwazi ukushayelwa ngesikhathi socingo oluphuthumayo."</string>
+    <string name="noApplications" msgid="1703149220378476198">"Awekho ama-app angenza lokhu."</string>
+    <string name="android_system_label" msgid="2730611410547215779">"Isistimu ye-Android"</string>
 </resources>
diff --git a/res/values/config.xml b/res/values/config.xml
index 8ebbd8617..45d4b1cd7 100644
--- a/res/values/config.xml
+++ b/res/values/config.xml
@@ -92,4 +92,8 @@
         <!-- Used for internal targets -->
         <item>com.google.android.bluetooth</item>
     </string-array>
+
+    <!-- String array containing numbers that shouldn't be logged. Country-specific.
+         Copied from frameworks/base/core/res/res/values/config.xml -->
+    <string-array name="unloggable_phone_numbers" />
 </resources>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index adbedfb57..04a8d7ede 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -429,13 +429,29 @@
     <!-- In-call screen: error message shown when the user attempts to place a call, but the live
          call cannot be held. -->
     <string name="callFailed_unholdable_call">Cannot place a call as there is an unholdable call. Disconnect the call prior to placing a new call.</string>
+    <!-- In-call screen: error message shown when the user attempts to place a call, but the live
+         call cannot be swapped with the held call. -->
+    <string name="callSwapFailed_unholdable_call">Cannot swap the active call because it does not support holding. Disconnect the call to make the held call active.</string>
     <!-- In-call screen: error message shown when the user has attempted to place a new outgoing
          call while there is already a call in ringing state. -->
     <string name="callFailed_already_ringing">Cannot place a call as there is an unanswered incoming call. Answer or reject the incoming call prior to placing a new call.</string>
     <!-- In-call screen: error message shown when the user attempts to dial an MMI code, but there
          is an ongoing call on a different phone account. -->
     <string name="callFailed_reject_mmi">This MMI code is not available for calls across multiple accounts.</string>
+    <!-- In-call screen: error message shown when the user attempts to hang up a call during a call
+         merge. -->
+    <string name="call_hangup_fail_during_merge">Call cannot be disconnected during a merge.</string>
     <!-- In-call screen: error message shown when the user attempts to dial an MMI code during an
          ongoing emergency call. -->
     <string name="emergencyCall_reject_mmi">MMI codes cannot be dialed during an emergency call.</string>
+    <!-- Text to display when attempting to send an SMS in response to an incoming call but there
+         no SMS apps on the device.  Realistically should never happen.
+         This is a copy of the frameworks noApplications resource with the message ID specified. -->
+    <!-- [BACKUP_MESSAGE_ID: 1186909265235544019] -->
+    <string name="noApplications">No apps can perform this action.</string>
+
+    <!-- Label for the Android system components when they are shown to the user.
+         Used when referring to "android" from the incoming call notification. -->
+    <!-- [BACKUP_MESSAGE_ID: 5974767339591067210] -->
+    <string name="android_system_label">Android System</string>
 </resources>
diff --git a/src/com/android/server/telecom/AsyncRingtonePlayer.java b/src/com/android/server/telecom/AsyncRingtonePlayer.java
index 7cb05cd1c..7be1e50ab 100644
--- a/src/com/android/server/telecom/AsyncRingtonePlayer.java
+++ b/src/com/android/server/telecom/AsyncRingtonePlayer.java
@@ -32,9 +32,12 @@ import android.util.Pair;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.Preconditions;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.ArrayList;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.function.BiConsumer;
 import java.util.function.Supplier;
@@ -55,14 +58,22 @@ public class AsyncRingtonePlayer {
     /** Handler running on the ringtone thread. */
     private Handler mHandler;
 
+    /**
+     * The ExecutorService used for handling asynchronous ringtone operations.
+     * Employing ExecutorService aligns with modern Java concurrency best practices
+     * and is the recommended approach for managing asynchronous tasks, offering better
+     * resource control and flexibility over direct thread management.
+     */
+    private ExecutorService mExecutor;
+
     /** The current ringtone. Only used by the ringtone thread. */
     private Ringtone mRingtone;
 
     /**
      * Set to true if we are setting up to play or are currently playing. False if we are stopping
-     * or have stopped playing.
+     * or have stopped playing. Made volatile for thread safety.
      */
-    private boolean mIsPlaying = false;
+    private volatile boolean mIsPlaying = false;
 
     /**
      * Set to true if BT HFP is active and audio is connected.
@@ -75,8 +86,10 @@ public class AsyncRingtonePlayer {
      */
     private final ArrayList<CountDownLatch> mPendingRingingLatches = new ArrayList<>();
 
-    public AsyncRingtonePlayer() {
-        // Empty
+    private final FeatureFlags mFeatureFlags;
+
+    public AsyncRingtonePlayer(FeatureFlags featureFlags) {
+        mFeatureFlags = featureFlags;
     }
 
     /**
@@ -85,7 +98,8 @@ public class AsyncRingtonePlayer {
      * the volume of the ringtone as it plays.
      *
      * @param ringtoneInfoSupplier The {@link Ringtone} factory.
-     * @param ringtoneConsumer The {@link Ringtone} post-creation callback (to start the vibration).
+     * @param ringtoneConsumer     The {@link Ringtone} post-creation callback (to start the
+     *                             vibration).
      * @param isHfpDeviceConnected True if there is a HFP BT device connected, false otherwise.
      */
     public void play(@NonNull Supplier<Pair<Uri, Ringtone>> ringtoneInfoSupplier,
@@ -98,14 +112,23 @@ public class AsyncRingtonePlayer {
         args.arg2 = ringtoneConsumer;
         args.arg3 = Log.createSubsession();
         args.arg4 = prepareRingingReadyLatch(isHfpDeviceConnected);
-        postMessage(EVENT_PLAY, true /* shouldCreateHandler */, args);
+
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            postTask(() -> handlePlayExecutor(args));
+        } else {
+            postMessage(EVENT_PLAY, true /* shouldCreateHandler */, args);
+        }
     }
 
     /** Stops playing the ringtone. */
     public void stop() {
         Log.d(this, "Posting stop.");
         mIsPlaying = false;
-        postMessage(EVENT_STOP, false /* shouldCreateHandler */, null);
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            postTask(this::handleStopExecutor);
+        } else {
+            postMessage(EVENT_STOP, false /* shouldCreateHandler */, null);
+        }
         // Clear any pending ringing latches so that we do not have to wait for its timeout to pass
         // before calling stop.
         clearPendingRingingLatches();
@@ -113,6 +136,7 @@ public class AsyncRingtonePlayer {
 
     /**
      * Called when the BT HFP profile active state changes.
+     *
      * @param isBtActive A BT device is connected and audio is active.
      */
     public void updateBtActiveState(boolean isBtActive) {
@@ -126,6 +150,7 @@ public class AsyncRingtonePlayer {
     /**
      * Prepares a new ringing ready latch and tracks it in a list. Once the ready latch has been
      * used, {@link #removePendingRingingReadyLatch(CountDownLatch)} must be called on this latch.
+     *
      * @param isHfpDeviceConnected true if there is a HFP device connected.
      * @return the newly prepared CountDownLatch
      */
@@ -146,6 +171,7 @@ public class AsyncRingtonePlayer {
 
     /**
      * Remove a ringing ready latch that has been used and is no longer pending.
+     *
      * @param l The latch to remove.
      */
     private void removePendingRingingReadyLatch(CountDownLatch l) {
@@ -168,11 +194,11 @@ public class AsyncRingtonePlayer {
      * Posts a message to the ringtone-thread handler. Creates the handler if specified by the
      * parameter shouldCreateHandler.
      *
-     * @param messageCode The message to post.
+     * @param messageCode         The message to post.
      * @param shouldCreateHandler True when a handler should be created to handle this message.
      */
     private void postMessage(int messageCode, boolean shouldCreateHandler, SomeArgs args) {
-        synchronized(this) {
+        synchronized (this) {
             if (mHandler == null && shouldCreateHandler) {
                 mHandler = getNewHandler();
             }
@@ -204,7 +230,7 @@ public class AsyncRingtonePlayer {
         return new Handler(thread.getLooper(), null /*callback*/, true /*async*/) {
             @Override
             public void handleMessage(Message msg) {
-                switch(msg.what) {
+                switch (msg.what) {
                     case EVENT_PLAY:
                         handlePlay((SomeArgs) msg.obj);
                         break;
@@ -298,7 +324,7 @@ public class AsyncRingtonePlayer {
 
         setRingtone(null);
 
-        synchronized(this) {
+        synchronized (this) {
             if (mHandler.hasMessages(EVENT_PLAY)) {
                 Log.v(this, "Keeping alive ringtone thread for subsequent play request.");
             } else {
@@ -318,7 +344,7 @@ public class AsyncRingtonePlayer {
     }
 
     private void setRingtone(@Nullable Ringtone ringtone) {
-        Log.i(this, "setRingtone: ringtone null="  + (ringtone == null));
+        Log.i(this, "setRingtone: ringtone null=" + (ringtone == null));
         // Make sure that any previously created instance of Ringtone is stopped so the MediaPlayer
         // can be released, before replacing mRingtone with a new instance. This is always created
         // as a looping Ringtone, so if not stopped it will keep playing on the background.
@@ -328,4 +354,139 @@ public class AsyncRingtonePlayer {
         }
         mRingtone = ringtone;
     }
+
+    /**
+     * Submits a task to the executor. Creates the executor if it doesn't exist or is terminated.
+     * (New method for Executor logic)
+     */
+    private void postTask(Runnable task) {
+        synchronized (this) {
+            if (mExecutor == null || mExecutor.isShutdown() || mExecutor.isTerminated()) {
+                Log.v(this, "Creating new single thread executor.");
+                mExecutor = Executors.newSingleThreadExecutor();
+            }
+            mExecutor.execute(task);
+        }
+    }
+
+    /**
+     * Starts the actual playback of the ringtone using Executor logic.
+     * Executes on the executor thread.
+     */
+    @SuppressWarnings("unchecked")
+    private void handlePlayExecutor(SomeArgs args) {
+        Supplier<Pair<Uri, Ringtone>> ringtoneInfoSupplier =
+                (Supplier<Pair<Uri, Ringtone>>) args.arg1;
+        BiConsumer<Pair<Uri, Ringtone>, Boolean> ringtoneConsumer =
+                (BiConsumer<Pair<Uri, Ringtone>, Boolean>) args.arg2;
+        Session session = (Session) args.arg3;
+        CountDownLatch ringingReadyLatch = (CountDownLatch) args.arg4;
+
+        Log.continueSession(session, "ARP.hPE");
+        try {
+            // Check if stop() was called (mIsPlaying becomes false)
+            if (!mIsPlaying) {
+                Log.i(this,
+                        "handlePlay: skipping play early (path 1) as mIsPlaying "
+                                + "is false.");
+                removePendingRingingReadyLatch(ringingReadyLatch);
+                ringtoneConsumer.accept(null, /* stopped= */ true);
+                return;
+            }
+
+            Ringtone localRingtoneInstance = null;
+            Uri localRingtoneUri = null;
+            boolean stoppedMidProcessing = false;
+
+            try {
+                try {
+                    Log.i(this, "handlePlay: delay ring for ready signal...");
+                    if (ringingReadyLatch != null) {
+                        boolean reachedZero = ringingReadyLatch.await(PLAY_DELAY_TIMEOUT_MS,
+                                TimeUnit.MILLISECONDS);
+                        Log.i(this, "handlePlay: ringing ready, timeout="
+                                + !reachedZero);
+                    }
+                } catch (InterruptedException e) {
+                    Log.w(this, "handlePlay: latch exception: " + e);
+                }
+
+                if (ringtoneInfoSupplier != null) {
+                    Pair<Uri, Ringtone> info = ringtoneInfoSupplier.get();
+                    if (info != null) {
+                        localRingtoneUri = info.first;
+                        localRingtoneInstance = info.second;
+                    }
+                }
+
+                if (!mIsPlaying) {
+                    Log.i(this,
+                            "handlePlay: skipping play (path 2) after ringtone "
+                                    + "supply as mIsPlaying is false.");
+                    stoppedMidProcessing = true;
+                    if (localRingtoneInstance != null) {
+                        localRingtoneInstance.stop();
+                    }
+                    return;
+                }
+                // setRingtone even if null - it also stops any current ringtone to be consistent
+                // with the overall state.
+                setRingtone(localRingtoneInstance);
+                if (mRingtone == null) {
+                    // The ringtoneConsumer can still vibrate at this stage.
+                    Log.w(this, "No ringtone was found bail out from playing.");
+                    return;
+                }
+
+                String uriString = localRingtoneUri != null ? localRingtoneUri.toSafeString() : "";
+                Log.i(this, "handlePlay: Play ringtone. Uri: " + uriString);
+                mRingtone.setLooping(true);
+                if (mRingtone.isPlaying()) {
+                    Log.d(this, "Ringtone already playing (mRingtone).");
+                    return;
+                }
+                mRingtone.play();
+                Log.i(this, "Play ringtone, looping (mRingtone).");
+
+            } finally {
+                removePendingRingingReadyLatch(ringingReadyLatch);
+                ringtoneConsumer.accept(new Pair<>(localRingtoneUri, localRingtoneInstance),
+                        stoppedMidProcessing);
+            }
+        } finally {
+            Log.cancelSubsession(session);
+            if (args != null) {
+                args.recycle();
+            }
+        }
+    }
+
+    /**
+     * Stops the playback of the ringtone using Executor logic.
+     * Executes on the executor thread.
+     */
+    private void handleStopExecutor() {
+        ThreadUtil.checkNotOnMainThread();
+        Log.i(this, "[ExecutorLogic] Stop ringtone task executing.");
+        setRingtone(null);
+
+        synchronized (this) {
+            // If mIsPlaying is true here, it means a play() was called after the stop()
+            // that initiated this StopRunnable, but before this StopRunnable executed.
+            // In this case, we shouldn't shut down the executor.
+            if (!mIsPlaying) { // If still in a "globally" stopped state
+                if (mExecutor != null && !mExecutor.isShutdown()) {
+                    Log.v(this, "[ExecutorLogic] Executor shutting down.");
+                    mExecutor.shutdown(); // Allows submitted tasks to complete
+                    // Set to null so it can be recreated by postTask if needed again.
+                    mExecutor = null;
+                    Log.v(this, "[ExecutorLogic] Executor cleared after shutdown.");
+                }
+            } else {
+                Log.v(this,
+                        "[ExecutorLogic] Executor kept alive because mIsPlaying is" +
+                                " true (new play likely enqueued).");
+            }
+        }
+    }
 }
diff --git a/src/com/android/server/telecom/AudioRoute.java b/src/com/android/server/telecom/AudioRoute.java
index 661f1db2d..46ae6c41a 100644
--- a/src/com/android/server/telecom/AudioRoute.java
+++ b/src/com/android/server/telecom/AudioRoute.java
@@ -451,10 +451,7 @@ public class AudioRoute {
         }
         // Only clear communication device if the destination route will be inactive; route to
         // route transitions do not require clearing the communication device.
-        boolean onlyClearCommunicationDeviceOnInactive =
-                pendingAudioRoute.getFeatureFlags().onlyClearCommunicationDeviceOnInactive();
-        if ((!onlyClearCommunicationDeviceOnInactive && !shouldDisconnectSco)
-                || !pendingAudioRoute.isActive()) {
+        if (!pendingAudioRoute.isActive()) {
             Log.i(this,
                     "clearCommunicationDevice: AudioManager#clearCommunicationDevice, type=%s",
                     DEVICE_TYPE_STRINGS.get(pendingAudioRoute.getCommunicationDeviceType()));
@@ -462,9 +459,7 @@ public class AudioRoute {
         }
 
         if (result == BluetoothStatusCodes.SUCCESS) {
-            if (pendingAudioRoute.getFeatureFlags().resolveActiveBtRoutingAndBtTimingIssue()) {
-                maybeClearConnectedPendingMessages(pendingAudioRoute);
-            }
+            maybeClearConnectedPendingMessages(pendingAudioRoute);
             pendingAudioRoute.setCommunicationDeviceType(AudioRoute.TYPE_INVALID);
         }
         return result;
diff --git a/src/com/android/server/telecom/Call.java b/src/com/android/server/telecom/Call.java
index a54a3b6d6..4d0a126ea 100644
--- a/src/com/android/server/telecom/Call.java
+++ b/src/com/android/server/telecom/Call.java
@@ -1938,7 +1938,6 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
                     mContext.getPackageManager());
             // Set the associated user for the call for MT calls based on the target phone account.
             UserHandle associatedUser = UserUtil.getAssociatedUserForCall(
-                    mFlags.associatedUserRefactorForWorkProfile(),
                     mCallsManager.getPhoneAccountRegistrar(), mCallsManager.getCurrentUserHandle(),
                     accountHandle);
             if (isIncoming() && !associatedUser.equals(mAssociatedUser)) {
@@ -2119,14 +2118,12 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
     }
 
     private void processCachedCallbacks(CallSourceService service) {
-        if(mFlags.cacheCallAudioCallbacks()) {
-            synchronized (mCachedServiceCallbacks) {
-                for (List<CachedCallback> callbacks : mCachedServiceCallbacks.values()) {
-                    callbacks.forEach( callback -> callback.executeCallback(service, this));
-                }
-                // clear list for memory cleanup purposes. The Service should never be reset
-                mCachedServiceCallbacks.clear();
+        synchronized (mCachedServiceCallbacks) {
+            for (List<CachedCallback> callbacks : mCachedServiceCallbacks.values()) {
+                callbacks.forEach(callback -> callback.executeCallback(service, this));
             }
+            // clear list for memory cleanup purposes. The Service should never be reset
+            mCachedServiceCallbacks.clear();
         }
     }
 
@@ -2360,12 +2357,6 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
     }
 
     public void setTransactionalCapabilities(Bundle extras) {
-        if (!mFlags.remapTransactionalCapabilities()) {
-            setConnectionCapabilities(
-                    extras.getInt(CallAttributes.CALL_CAPABILITIES_KEY,
-                            CallAttributes.SUPPORTS_SET_INACTIVE), true);
-            return;
-        }
         int connectionCapabilitesBitmap = 0;
         int transactionalCapabilitiesBitmap = extras.getInt(
                 CallAttributes.CALL_CAPABILITIES_KEY,
@@ -2580,7 +2571,7 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
 
         service.incrementAssociatedCallCount();
 
-        if (mFlags.updatedRcsCallCountTracking() && remoteService != null) {
+        if (remoteService != null) {
             remoteService.incrementAssociatedCallCount();
             mRemoteConnectionService = remoteService;
         }
@@ -2612,17 +2603,11 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
         if (mConnectionService != null) {
             ConnectionServiceWrapper serviceTemp = mConnectionService;
 
-            if (mFlags.updatedRcsCallCountTracking()) {
-                // Continue to track the former CS for this call so that it doesn't unbind early:
-                mRemoteConnectionService = serviceTemp;
-            }
+            // Continue to track the former CS for this call so that it doesn't unbind early:
+            mRemoteConnectionService = serviceTemp;
 
             mConnectionService = null;
             serviceTemp.removeCall(this);
-
-            if (!mFlags.updatedRcsCallCountTracking()) {
-                serviceTemp.decrementAssociatedCallCount(true /*isSuppressingUnbind*/);
-            }
         }
 
         service.incrementAssociatedCallCount();
@@ -2649,7 +2634,7 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
             // to do.
             decrementAssociatedCallCount(serviceTemp);
 
-            if (mFlags.updatedRcsCallCountTracking() && remoteServiceTemp != null) {
+            if (remoteServiceTemp != null) {
                 decrementAssociatedCallCount(remoteServiceTemp);
             }
         }
@@ -2896,12 +2881,12 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
         if (mState == CallState.NEW || mState == CallState.SELECT_PHONE_ACCOUNT ||
                 mState == CallState.CONNECTING) {
             Log.i(this, "disconnect: Aborting call %s", getId());
+            abort(disconnectionTimeout);
             if (mFlags.enableCallSequencing()) {
                 disconnectFutureHandler = awaitCallStateChangeAndMaybeDisconnectCall(
                         false /* shouldDisconnectUponTimeout */, "disconnect",
                         CallState.DISCONNECTED, CallState.ABORTED);
             }
-            abort(disconnectionTimeout);
         } else if (mState != CallState.ABORTED && mState != CallState.DISCONNECTED) {
             if (mState == CallState.AUDIO_PROCESSING && !hasGoneActiveBefore()) {
                 setOverrideDisconnectCauseCode(new DisconnectCause(DisconnectCause.REJECTED));
@@ -2939,7 +2924,12 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
         if (mCreateConnectionProcessor != null &&
                 !mCreateConnectionProcessor.isProcessingComplete()) {
             mCreateConnectionProcessor.abort();
-        } else if (mState == CallState.NEW || mState == CallState.SELECT_PHONE_ACCOUNT
+        } else if (mFlags.echoAbortTransactionalOutgoing() && mIsTransactionalCall) {
+            CompletableFuture<Boolean> wasCompleted = mTransactionalService.onDisconnect(this,
+                    new DisconnectCause(DisconnectCause.CANCELED));
+            Log.d(this, "abort: wasTransactionCompleted=[%b", wasCompleted);
+        }
+        else if (mState == CallState.NEW || mState == CallState.SELECT_PHONE_ACCOUNT
                 || mState == CallState.CONNECTING) {
             if (disconnectionTimeout > 0) {
                 // If the cancelation was from NEW_OUTGOING_CALL with a timeout of > 0
@@ -3275,20 +3265,21 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
             boolean shouldDisconnectUponTimeout, String callingMethod, int... targetCallStates) {
         TransactionManager tm = TransactionManager.getInstance();
         CallTransaction callTransaction = new VerifyCallStateChangeTransaction(
-                mCallsManager.getLock(), this, targetCallStates);
+                mCallsManager.getLock(), this, mFlags, targetCallStates);
         return tm.addTransaction(callTransaction,
                 new OutcomeReceiver<>() {
             @Override
             public void onResult(CallTransactionResult result) {
                 Log.i(this, "awaitCallStateChangeAndMaybeDisconnectCall: %s: onResult:"
-                        + " due to CallException=[%s]", callingMethod, result);
+                        + " success", callingMethod);
             }
 
             @Override
             public void onError(CallException e) {
                 Log.i(this, "awaitCallStateChangeAndMaybeDisconnectCall: %s: onError"
                         + " due to CallException=[%s]", callingMethod, e);
-                if (shouldDisconnectUponTimeout) {
+                if (shouldDisconnectUponTimeout && (Call.this.getState() != CallState.DISCONNECTING
+                        || Call.this.getState() != CallState.DISCONNECTED)) {
                     mCallsManager.markCallAsDisconnected(Call.this,
                             new DisconnectCause(DisconnectCause.ERROR,
                                     "did not hold in timeout window"));
@@ -3532,7 +3523,8 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
         return Contacts.getLookupUri(mCallerInfo.getContactId(), mCallerInfo.lookupKey);
     }
 
-    Uri getRingtone() {
+    @VisibleForTesting
+    public Uri getRingtone() {
         return mCallerInfo == null ? null : mCallerInfo.contactRingtoneUri;
     }
 
@@ -4234,7 +4226,7 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
         if (videoProvider != null ) {
             try {
                 mVideoProviderProxy = new VideoProviderProxy(mLock, videoProvider, this,
-                        mCallsManager);
+                        mCallsManager, mFlags);
             } catch (RemoteException ignored) {
                 // Ignore RemoteException.
             }
@@ -4394,7 +4386,7 @@ public class Call implements CreateConnectionResponse, EventManager.Loggable,
      *
      * @param isLocallyDisconnecting {@code true} if this call is locally disconnecting.
      */
-    private void setLocallyDisconnecting(boolean isLocallyDisconnecting) {
+    public void setLocallyDisconnecting(boolean isLocallyDisconnecting) {
         mIsLocallyDisconnecting = isLocallyDisconnecting;
     }
 
diff --git a/src/com/android/server/telecom/CallAnomalyWatchdog.java b/src/com/android/server/telecom/CallAnomalyWatchdog.java
index c331b2975..9cf5ea708 100644
--- a/src/com/android/server/telecom/CallAnomalyWatchdog.java
+++ b/src/com/android/server/telecom/CallAnomalyWatchdog.java
@@ -217,6 +217,9 @@ public class CallAnomalyWatchdog extends CallsManagerListenerBase implements Cal
         if (mFeatureFlags.telecomMetricsSupport()) {
             mMetricsController.getCallStats().onCallEnd(call);
         }
+        if (mFeatureFlags.callSequencingMetrics()) {
+            mMetricsController.getCallSequencingStats().onCallEnd(call);
+        }
     }
 
     /**
diff --git a/src/com/android/server/telecom/CallAudioManager.java b/src/com/android/server/telecom/CallAudioManager.java
index d156c0c07..4ede5dd77 100644
--- a/src/com/android/server/telecom/CallAudioManager.java
+++ b/src/com/android/server/telecom/CallAudioManager.java
@@ -444,10 +444,9 @@ public class CallAudioManager extends CallsManagerListenerBase {
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     public void onRingerModeChange() {
-        if (mFeatureFlags.ensureInCarRinging()) {
-            // Stop the current ringtone before attempting to start the new ringtone:
-            stopRinging();
-        }
+        // Stop the current ringtone before attempting to start the new ringtone:
+        stopRinging();
+
         mCallAudioModeStateMachine.sendMessageWithArgs(
                 CallAudioModeStateMachine.RINGER_MODE_CHANGE, makeArgsForModeStateMachine());
     }
@@ -586,25 +585,19 @@ public class CallAudioManager extends CallsManagerListenerBase {
 
     @VisibleForTesting
     public void setCallAudioRouteFocusState(int focusState) {
-        if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-            mCallAudioRouteAdapter.sendMessageWithSessionInfo(
-                    CallAudioRouteStateMachine.SWITCH_FOCUS, focusState, 0);
+        if (focusState == CallAudioRouteController.NO_FOCUS) {
+            mCallAudioRouteAdapter.sendMessageWithSessionInfoAtFront(
+                    CallAudioRouteController.SWITCH_FOCUS, focusState, 0);
         } else {
             mCallAudioRouteAdapter.sendMessageWithSessionInfo(
-                    CallAudioRouteStateMachine.SWITCH_FOCUS, focusState);
+                    CallAudioRouteController.SWITCH_FOCUS, focusState, 0);
         }
     }
 
     public void setCallAudioRouteFocusStateForEndTone() {
-        if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-            mCallAudioRouteAdapter.sendMessageWithSessionInfo(
-                    CallAudioRouteStateMachine.SWITCH_FOCUS,
-                    CallAudioRouteStateMachine.ACTIVE_FOCUS, 1);
-        } else {
-            mCallAudioRouteAdapter.sendMessageWithSessionInfo(
-                    CallAudioRouteStateMachine.SWITCH_FOCUS,
-                    CallAudioRouteStateMachine.ACTIVE_FOCUS);
-        }
+        mCallAudioRouteAdapter.sendMessageWithSessionInfoAtFront(
+                CallAudioRouteController.SWITCH_FOCUS,
+                CallAudioRouteController.ACTIVE_FOCUS, 1);
     }
 
     public void notifyAudioOperationsComplete() {
@@ -787,12 +780,9 @@ public class CallAudioManager extends CallsManagerListenerBase {
 
     private void onCallEnteringRinging() {
         if (mRingingCalls.size() == 1) {
-            Log.i(this, "onCallEnteringRinging: mFeatureFlags.separatelyBindToBtIncallService() ? %s",
-                    mFeatureFlags.separatelyBindToBtIncallService());
             Log.i(this, "onCallEnteringRinging: mRingingCalls.getFirst().getBtIcsFuture() = %s",
                     mRingingCalls.getFirst().getBtIcsFuture());
-            if (mFeatureFlags.separatelyBindToBtIncallService()
-                    && mRingingCalls.getFirst().getBtIcsFuture() != null) {
+            if (mRingingCalls.getFirst().getBtIcsFuture() != null) {
                 mCallRingingFuture  = mRingingCalls.getFirst().getBtIcsFuture()
                         .thenComposeAsync((completed) -> {
                             mCallAudioModeStateMachine.sendMessageWithArgs(
diff --git a/src/com/android/server/telecom/CallAudioModeStateMachine.java b/src/com/android/server/telecom/CallAudioModeStateMachine.java
index d1fd56434..f43aa3b8d 100644
--- a/src/com/android/server/telecom/CallAudioModeStateMachine.java
+++ b/src/com/android/server/telecom/CallAudioModeStateMachine.java
@@ -259,14 +259,6 @@ public class CallAudioModeStateMachine extends StateMachine {
             Log.i(LOG_TAG, "Audio focus entering UNFOCUSED state");
             mLocalLog.log("Enter UNFOCUSED");
             if (mIsInitialized) {
-                // Clear any communication device that was requested previously.
-                // Todo: Remove once clearCommunicationDeviceAfterAudioOpsComplete is
-                // completely rolled out.
-                if (mFeatureFlags.callAudioCommunicationDeviceRefactor()
-                        && !mFeatureFlags.clearCommunicationDeviceAfterAudioOpsComplete()) {
-                    mCommunicationDeviceTracker.clearCommunicationDevice(mCommunicationDeviceTracker
-                            .getCurrentLocallyRequestedCommunicationDevice());
-                }
                 if (mFeatureFlags.setAudioModeBeforeAbandonFocus()) {
                     Log.i(this, "enter: AudioManager#setMode(MODE_NORMAL)");
                     mAudioManager.setMode(AudioManager.MODE_NORMAL);
@@ -332,18 +324,6 @@ public class CallAudioModeStateMachine extends StateMachine {
                     Log.i(this, "AudioOperationsComplete: "
                             + "AudioManager#abandonAudioFocusRequest(); now unfocused");
                     mAudioManager.abandonAudioFocusForCall();
-                    // Clear requested communication device after the call ends.
-                    if (mFeatureFlags.clearCommunicationDeviceAfterAudioOpsComplete()) {
-                        // Oh flags!  If we're using the refactored audio route switching, we should
-                        // not be using the communication device tracker; that is exclusively for
-                        // the old code path.
-                        if (!mFeatureFlags.dontUseCommunicationDeviceTracker()
-                                || !mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                            mCommunicationDeviceTracker.clearCommunicationDevice(
-                                    mCommunicationDeviceTracker
-                                            .getCurrentLocallyRequestedCommunicationDevice());
-                        }
-                    }
                     return HANDLED;
                 default:
                     // The forced focus switch commands are handled by BaseState.
@@ -438,6 +418,8 @@ public class CallAudioModeStateMachine extends StateMachine {
                 return;
             }
 
+            // Note: startRinging will take DND into account; if a call is suppressed by DND,
+            // the method will return false and we will not get audio focus.
             if (mCallAudioManager.startRinging()) {
                 Log.i(this, "tryStartRinging: AudioManager#requestAudioFocus(RING)");
                 mAudioManager.requestAudioFocusForCall(
diff --git a/src/com/android/server/telecom/CallAudioRouteAdapter.java b/src/com/android/server/telecom/CallAudioRouteAdapter.java
index b23851dec..5b2a9aa7e 100644
--- a/src/com/android/server/telecom/CallAudioRouteAdapter.java
+++ b/src/com/android/server/telecom/CallAudioRouteAdapter.java
@@ -129,6 +129,7 @@ public interface CallAudioRouteAdapter {
     void sendMessageWithSessionInfo(int message, int arg);
     void sendMessageWithSessionInfo(int message, int arg, String data);
     void sendMessageWithSessionInfo(int message, int arg, int data);
+    void sendMessageWithSessionInfoAtFront(int message, int arg, int data);
     void sendMessageWithSessionInfo(int message, int arg, BluetoothDevice bluetoothDevice);
     void sendMessage(int message, Runnable r);
     void setCallAudioManager(CallAudioManager callAudioManager);
diff --git a/src/com/android/server/telecom/CallAudioRouteController.java b/src/com/android/server/telecom/CallAudioRouteController.java
index 727b9ce43..63ab504ef 100644
--- a/src/com/android/server/telecom/CallAudioRouteController.java
+++ b/src/com/android/server/telecom/CallAudioRouteController.java
@@ -31,6 +31,7 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.media.AudioAttributes;
 import android.media.AudioDeviceAttributes;
+import android.media.AudioDeviceCallback;
 import android.media.AudioDeviceInfo;
 import android.media.AudioManager;
 import android.media.IAudioService;
@@ -71,6 +72,24 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class CallAudioRouteController implements CallAudioRouteAdapter {
+    public static class Factory {
+        public CallAudioRouteController create(
+                Context context, CallsManager callsManager,
+                CallAudioManager.AudioServiceFactory audioServiceFactory,
+                AudioRoute.Factory audioRouteFactory, WiredHeadsetManager wiredHeadsetManager,
+                BluetoothRouteManager bluetoothRouteManager, StatusBarNotifier notifier,
+                FeatureFlags featureFlags, TelecomMetricsController metricsController) {
+            return new CallAudioRouteController(context,
+                    callsManager,
+                    audioServiceFactory,
+                    audioRouteFactory,
+                    wiredHeadsetManager,
+                    bluetoothRouteManager,
+                    notifier,
+                    featureFlags,
+                    metricsController);
+        }
+    }
     private static final AudioRoute DUMMY_ROUTE = new AudioRoute(TYPE_INVALID, null, null);
     private static final Map<Integer, Integer> ROUTE_MAP;
     static {
@@ -114,7 +133,9 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     private AudioRoute.Factory mAudioRouteFactory;
     private StatusBarNotifier mStatusBarNotifier;
     private AudioManager.OnCommunicationDeviceChangedListener mCommunicationDeviceListener;
-    private ExecutorService mCommunicationDeviceChangedExecutor;
+    private ExecutorService mAudioManagerListenerExecutor;
+    private AudioManager.OnPreferredDevicesForStrategyChangedListener mPreferredDeviceListener;
+    private AudioRoute mPreferredDeviceRoute;
     private FeatureFlags mFeatureFlags;
     private int mFocusType;
     private int mCallSupportedRouteMask = -1;
@@ -126,6 +147,62 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     private final TelecomSystem.SyncRoot mTelecomLock;
     private CountDownLatch mAudioOperationsCompleteLatch;
     private CountDownLatch mAudioActiveCompleteLatch;
+
+    /** Receiver for added/removed device outputs that are reported by the audio fwk */
+    public class AudioRoutesCallback extends AudioDeviceCallback {
+        @Override
+        public void onAudioDevicesAdded(AudioDeviceInfo[] addedDevices) {
+            Log.startSession("ARC.oADA");
+            try {
+                updateAudioRoutes(addedDevices, true);
+            } finally {
+                Log.endSession();
+            }
+        }
+
+        @Override
+        public void onAudioDevicesRemoved(AudioDeviceInfo[] devices) {
+            Log.startSession("ARC.oADR");
+            try {
+                updateAudioRoutes(devices, false);
+            } finally {
+                Log.endSession();
+            }
+        }
+
+        private void updateAudioRoutes(AudioDeviceInfo[] devices, boolean addDevices) {
+            Log.i(this, "updateAudioRoutes: add devices? %b", addDevices);
+            for (AudioDeviceInfo deviceInfo: devices) {
+                int audioRouteType = getAudioType(deviceInfo);
+                Log.i(this, "updateAudioRoutes: audioDeviceInfo: %s, audioRouteType: %d",
+                        deviceInfo, audioRouteType);
+                // We should really only worry about handling earpiece and speaker. Bluetooth and
+                // wired headset routes are already dynamically updated. This logic can be updated
+                // once we support call audio route centralization.
+                if (audioRouteType == TYPE_INVALID || audioRouteType == AudioRoute.TYPE_WIRED
+                        || BT_AUDIO_ROUTE_TYPES.contains(audioRouteType)) {
+                    Log.i(this, "updateAudioRoutes: skipping route.");
+                    continue;
+                }
+                if (addDevices) {
+                    switch(audioRouteType) {
+                        case AudioRoute.TYPE_SPEAKER:
+                            createSpeakerRoute();
+                            break;
+                        case AudioRoute.TYPE_EARPIECE:
+                            createEarpieceRoute();
+                            break;
+                        default:
+                            break;
+                    }
+                } else {
+                    AudioRoute route = mTypeRoutes.remove(audioRouteType);
+                    updateAvailableRoutes(route, false);
+                }
+            }
+        }
+    }
+
     private final BroadcastReceiver mSpeakerPhoneChangeReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -133,9 +210,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
             try {
                 if (AudioManager.ACTION_SPEAKERPHONE_STATE_CHANGED.equals(intent.getAction())) {
                     if (mAudioManager != null) {
-                        AudioDeviceInfo info = mFeatureFlags.updatePreferredAudioDeviceLogic()
-                                ? getCurrentCommunicationDevice()
-                                : mAudioManager.getCommunicationDevice();
+                        AudioDeviceInfo info = getCurrentCommunicationDevice();
                         if ((info != null) &&
                                 (info.getType() == AudioDeviceInfo.TYPE_BUILTIN_SPEAKER)) {
                             if (mCurrentRoute.getType() != AudioRoute.TYPE_SPEAKER) {
@@ -189,6 +264,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     private boolean mIsPending;
     private boolean mIsActive;
     private boolean mWasOnSpeaker;
+    private AudioRoutesCallback mAudioRoutesCallback;
     private final TelecomMetricsController mMetricsController;
 
     public CallAudioRouteController(
@@ -213,20 +289,11 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         mUsePreferredDeviceStrategy = true;
         mWasOnSpeaker = false;
         setCurrentCommunicationDevice(null);
+        mPreferredDeviceRoute = DUMMY_ROUTE;
 
         mTelecomLock = callsManager.getLock();
         HandlerThread handlerThread = new HandlerThread(this.getClass().getSimpleName());
-        if (!mFeatureFlags.callAudioRoutingPerformanceImprovemenent()) {
-            handlerThread.start();
-        }
-
-        // Register broadcast receivers
-        if (!mFeatureFlags.newAudioPathSpeakerBroadcastAndUnfocusedRouting()) {
-            IntentFilter speakerChangedFilter = new IntentFilter(
-                    AudioManager.ACTION_SPEAKERPHONE_STATE_CHANGED);
-            speakerChangedFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
-            context.registerReceiver(mSpeakerPhoneChangeReceiver, speakerChangedFilter);
-        }
+        handlerThread.start();
 
         IntentFilter micMuteChangedFilter = new IntentFilter(
                 AudioManager.ACTION_MICROPHONE_MUTE_CHANGED);
@@ -240,29 +307,53 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         // Register AudioManager#onCommunicationDeviceChangedListener listener to receive updates
         // to communication device (via AudioManager#setCommunicationDevice). This is a replacement
         // to using broadcasts in the hopes of improving performance.
-        mCommunicationDeviceChangedExecutor = Executors.newSingleThreadExecutor();
+        mAudioManagerListenerExecutor = Executors.newSingleThreadExecutor();
         mCommunicationDeviceListener = new AudioManager.OnCommunicationDeviceChangedListener() {
             @Override
             public void onCommunicationDeviceChanged(AudioDeviceInfo device) {
-                @AudioRoute.AudioRouteType int audioType = getAudioType(device);
-                setCurrentCommunicationDevice(device);
-                Log.i(this, "onCommunicationDeviceChanged: device (%s), audioType (%d)",
-                        device, audioType);
-                if (audioType == TYPE_SPEAKER) {
-                    if (mCurrentRoute.getType() != TYPE_SPEAKER) {
-                        sendMessageWithSessionInfo(SPEAKER_ON);
+                try {
+                    Log.startSession("CARC.oCDC");
+                    @AudioRoute.AudioRouteType int audioType = getAudioType(device);
+                    setCurrentCommunicationDevice(device);
+                    Log.i(this, "onCommunicationDeviceChanged: device (%s), audioType (%d)",
+                            device, audioType);
+                    if (audioType == TYPE_SPEAKER) {
+                        if (mCurrentRoute.getType() != TYPE_SPEAKER) {
+                            sendMessageWithSessionInfo(SPEAKER_ON);
+                        }
+                    } else {
+                        sendMessageWithSessionInfo(SPEAKER_OFF);
                     }
-                } else {
-                    sendMessageWithSessionInfo(SPEAKER_OFF);
+                } finally {
+                    Log.endSession();
                 }
             }
         };
 
-        Looper looper = mFeatureFlags.callAudioRoutingPerformanceImprovemenent()
-                ? Looper.getMainLooper()
-                : handlerThread.getLooper();
+        // Register the  AudioManager. OnPreferredDevicesForStrategyChangedListener listener to
+        // receive updates for the communication device. This is a replacement to directly querying
+        // the preferred device via AudioManager#getPreferredDeviceForStrategy, which was known
+        // to hold up the invoking thread.
+        mPreferredDeviceListener = (strategy, devices) -> {
+            try {
+                Log.startSession("CARC.oPDFSCL");
+                final AudioAttributes attr = new AudioAttributes.Builder()
+                        .setUsage(AudioAttributes.USAGE_VOICE_COMMUNICATION)
+                        .build();
+                if (!devices.isEmpty() && strategy.supportsAudioAttributes(attr)) {
+                    AudioRoute audioRoute = getPreferredDeviceAudioRoute(devices.getFirst());
+                    Log.i(this, "OnPreferredDevicesForStrategyChangedListener: preferred device "
+                            + "was updated to %s", audioRoute);
+                    // Get the first device listed
+                    setPreferredDeviceRoute(audioRoute);
+                }
+            } finally {
+                Log.endSession();
+            }
+        };
+
         // Create handler
-        mHandler = new Handler(looper) {
+        mHandler = new Handler(handlerThread.getLooper()) {
             @Override
             public void handleMessage(@NonNull Message msg) {
                 synchronized (this) {
@@ -409,23 +500,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         int supportMask = calculateSupportedRouteMaskInit();
         if ((supportMask & CallAudioState.ROUTE_SPEAKER) != 0) {
             int audioRouteType = AudioRoute.TYPE_SPEAKER;
-            // Create speaker routes
-            mSpeakerDockRoute = mAudioRouteFactory.create(AudioRoute.TYPE_SPEAKER, null,
-                    mAudioManager);
-            if (mSpeakerDockRoute == null){
-                Log.i(this, "Can't find available audio device info for route TYPE_SPEAKER, trying"
-                        + " for TYPE_BUS");
-                mSpeakerDockRoute = mAudioRouteFactory.create(AudioRoute.TYPE_BUS, null,
-                        mAudioManager);
-                audioRouteType = AudioRoute.TYPE_BUS;
-            }
-            if (mSpeakerDockRoute != null) {
-                mTypeRoutes.put(audioRouteType, mSpeakerDockRoute);
-                updateAvailableRoutes(mSpeakerDockRoute, true);
-            } else {
-                Log.w(this, "Can't find available audio device info for route TYPE_SPEAKER "
-                        + "or TYPE_BUS.");
-            }
+            createSpeakerRoute();
         }
 
         if ((supportMask & CallAudioState.ROUTE_WIRED_HEADSET) != 0) {
@@ -439,15 +514,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
                 updateAvailableRoutes(mEarpieceWiredRoute, true);
             }
         } else if ((supportMask & CallAudioState.ROUTE_EARPIECE) != 0) {
-            // Create earpiece routes
-            mEarpieceWiredRoute = mAudioRouteFactory.create(AudioRoute.TYPE_EARPIECE, null,
-                    mAudioManager);
-            if (mEarpieceWiredRoute == null) {
-                Log.w(this, "Can't find available audio device info for route TYPE_EARPIECE");
-            } else {
-                mTypeRoutes.put(AudioRoute.TYPE_EARPIECE, mEarpieceWiredRoute);
-                updateAvailableRoutes(mEarpieceWiredRoute, true);
-            }
+            createEarpieceRoute();
         }
 
         // set current route
@@ -467,11 +534,12 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         mIsActive = false;
         mCallAudioState = new CallAudioState(mIsMute, ROUTE_MAP.get(mCurrentRoute.getType()),
                 supportMask, null, new HashSet<>());
-        if (mFeatureFlags.newAudioPathSpeakerBroadcastAndUnfocusedRouting()) {
-            mAudioManager.addOnCommunicationDeviceChangedListener(
-                    mCommunicationDeviceChangedExecutor,
-                    mCommunicationDeviceListener);
-        }
+        mAudioManager.addOnCommunicationDeviceChangedListener(
+                mAudioManagerListenerExecutor, mCommunicationDeviceListener);
+        mAudioManager.addOnPreferredDevicesForStrategyChangedListener(mAudioManagerListenerExecutor,
+                mPreferredDeviceListener);
+        mAudioRoutesCallback = new AudioRoutesCallback();
+        mAudioManager.registerAudioDeviceCallback(mAudioRoutesCallback, mHandler);
     }
 
     @Override
@@ -500,6 +568,14 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         sendMessage(message, arg, 0, args);
     }
 
+    @Override
+    public void sendMessageWithSessionInfoAtFront(int message, int arg, int data) {
+        SomeArgs args = SomeArgs.obtain();
+        args.arg1 = Log.createSubsession();
+        args.arg2 = data;
+        mHandler.sendMessageAtFrontOfQueue(Message.obtain(mHandler, message, arg, 0, args));
+    }
+
     @Override
     public void sendMessageWithSessionInfo(int message, int arg, BluetoothDevice bluetoothDevice) {
         SomeArgs args = SomeArgs.obtain();
@@ -598,11 +674,6 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
             Log.i(this, "Override current pending route destination from %s(active=%b) to "
                             + "%s(active=%b)",
                     mPendingAudioRoute.getDestRoute(), mIsActive, destRoute, isDestRouteActive);
-            // Ensure we don't keep waiting for SPEAKER_ON if dest route gets overridden.
-            if (!mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue() && isDestRouteActive
-                    && mPendingAudioRoute.getDestRoute().getType() == TYPE_SPEAKER) {
-                mPendingAudioRoute.clearPendingMessage(new Pair<>(SPEAKER_ON, null));
-            }
             // override pending route while keep waiting for still pending messages for the
             // previous pending route
             mPendingAudioRoute.setOrigRoute(mIsActive /* origin */,
@@ -770,8 +841,16 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
      * Message being handled: BT_AUDIO_CONNECTED
      */
     private void handleBtAudioActive(BluetoothDevice bluetoothDevice) {
-        if (mIsPending) {
+        if (mIsPending && bluetoothDevice != null) {
             Log.i(this, "handleBtAudioActive: is pending path");
+            // Ensure we aren't keeping track of pending speaker off and SCO audio disconnected
+            // messages  for this device if BT stack indicates that SCO audio is connected.
+            mPendingAudioRoute.clearPendingMessage(
+                    new Pair<>(BT_AUDIO_DISCONNECTED, bluetoothDevice.getAddress()));
+            mPendingAudioRoute.clearPendingMessage(new Pair<>(SPEAKER_OFF, null));
+            // Maybe turn off speaker from notification bar. This will be a no-op if the enabled
+            // status is already off.
+            mStatusBarNotifier.notifySpeakerphone(false);
             if (Objects.equals(mPendingAudioRoute.getDestRoute().getBluetoothAddress(),
                     bluetoothDevice.getAddress())) {
                 mPendingAudioRoute.onMessageReceived(new Pair<>(BT_AUDIO_CONNECTED,
@@ -789,8 +868,12 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
      * Message being handled: BT_AUDIO_DISCONNECTED
      */
     private void handleBtAudioInactive(BluetoothDevice bluetoothDevice) {
-        if (mIsPending) {
+        if (mIsPending && bluetoothDevice != null) {
             Log.i(this, "handleBtAudioInactive: is pending path");
+            // Ensure we aren't keeping track of pending s SCO audio connected messages for this
+            // device if the BT stack has indicated that SCO audio has disconnected.
+            mPendingAudioRoute.clearPendingMessage(
+                    new Pair<>(BT_AUDIO_CONNECTED, bluetoothDevice.getAddress()));
             if (Objects.equals(mPendingAudioRoute.getOrigRoute().getBluetoothAddress(),
                     bluetoothDevice.getAddress())) {
                 mPendingAudioRoute.onMessageReceived(new Pair<>(BT_AUDIO_DISCONNECTED,
@@ -885,24 +968,19 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     private void handleBtActiveDeviceGone(@AudioRoute.AudioRouteType int type) {
         // Determine what the active device for the BT audio type was so that we can exclude this
         // device from being used when calculating the base route.
-        String previouslyActiveDeviceAddress = mFeatureFlags
-                .resolveActiveBtRoutingAndBtTimingIssue()
-                ? mActiveDeviceCache.get(type)
-                : null;
+        String previouslyActiveDeviceAddress = mActiveDeviceCache.get(type);
         // It's possible that the dest route hasn't been set yet when the controller is first
         // initialized.
         boolean pendingRouteNeedsUpdate = mPendingAudioRoute.getDestRoute() != null
                 && mPendingAudioRoute.getDestRoute().getType() == type;
         boolean currentRouteNeedsUpdate = mCurrentRoute.getType() == type;
-        if (mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()) {
-            if (pendingRouteNeedsUpdate) {
-                pendingRouteNeedsUpdate = mPendingAudioRoute.getDestRoute().getBluetoothAddress()
-                        .equals(previouslyActiveDeviceAddress);
-            }
-            if (currentRouteNeedsUpdate) {
-                currentRouteNeedsUpdate = mCurrentRoute.getBluetoothAddress()
-                        .equals(previouslyActiveDeviceAddress);
-            }
+        if (pendingRouteNeedsUpdate) {
+            pendingRouteNeedsUpdate = mPendingAudioRoute.getDestRoute().getBluetoothAddress()
+                    .equals(previouslyActiveDeviceAddress);
+        }
+        if (currentRouteNeedsUpdate) {
+            currentRouteNeedsUpdate = mCurrentRoute.getBluetoothAddress()
+                    .equals(previouslyActiveDeviceAddress);
         }
         if ((mIsPending && pendingRouteNeedsUpdate) || (!mIsPending && currentRouteNeedsUpdate)) {
             maybeDisableWasOnSpeaker(true);
@@ -950,9 +1028,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
                 // Ensure we reset call audio state at the end of the call (i.e. if we're on
                 // speaker, route back to earpiece). If we're on BT, remain on BT if it's still
                 // connected.
-                AudioRoute route = mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()
-                        ? calculateBaselineRoute(false, true, null)
-                        : mCurrentRoute;
+                AudioRoute route = calculateBaselineRoute(false, true, null);
                 routeTo(false, route);
                 // Clear pending messages
                 mPendingAudioRoute.clearPendingMessages();
@@ -1108,16 +1184,14 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
                 && ((mIsPending && !btAddressToExclude.equals(mPendingAudioRoute.getDestRoute()
                 .getBluetoothAddress())) || (!mIsPending && !btAddressToExclude.equals(
                         mCurrentRoute.getBluetoothAddress())));
-        if (mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()) {
-            if (isExcludedDeviceConnectingOrConnected) {
-                Log.i(this, "BT device with address (%s) is currently connecting/connected. "
-                        + "Ignoring route switch.", btAddressToExclude);
-                return;
-            } else if (isCurrentOrDestRouteDifferent) {
-                Log.i(this, "Current or pending audio route isn't routed to device with address "
-                        + "(%s). Ignoring route switch.", btAddressToExclude);
-                return;
-            }
+        if (isExcludedDeviceConnectingOrConnected) {
+            Log.i(this, "BT device with address (%s) is currently connecting/connected. "
+                    + "Ignoring route switch.", btAddressToExclude);
+            return;
+        } else if (isCurrentOrDestRouteDifferent) {
+            Log.i(this, "Current or pending audio route isn't routed to device with address "
+                    + "(%s). Ignoring route switch.", btAddressToExclude);
+            return;
         }
         maybeDisableWasOnSpeaker(isExplicitUserRequest);
         routeTo(mIsActive, calculateBaselineRoute(isExplicitUserRequest, includeBluetooth,
@@ -1127,6 +1201,15 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     private void handleSpeakerOn() {
         if (isPending()) {
             Log.i(this, "handleSpeakerOn: sending SPEAKER_ON to pending audio route");
+            // Clear any pending speaker off message as the speaker has been explicitly turned on as
+            // indicated by the audio fwk.
+            mPendingAudioRoute.clearPendingMessage(new Pair<>(SPEAKER_OFF, null));
+            // Clear any pending BT_AUDIO_DISCONNECTED messages for connected BT devices if speaker
+            // has explicitly been turned on.
+            for (BluetoothDevice device: mBluetoothRoutes.values()) {
+                mPendingAudioRoute.clearPendingMessage(new Pair<>(BT_AUDIO_DISCONNECTED,
+                        device.getAddress()));
+            }
             mPendingAudioRoute.onMessageReceived(new Pair<>(SPEAKER_ON, null), null);
             // Update status bar notification if we are in a call.
             mStatusBarNotifier.notifySpeakerphone(mCallsManager.hasAnyCalls());
@@ -1147,14 +1230,20 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     private void handleSpeakerOff() {
         if (isPending()) {
             Log.i(this, "handleSpeakerOff - sending SPEAKER_OFF to pending audio route");
+            // Clear any pending speaker on message as the speaker has been explicitly turned off as
+            // indicated by the audio fwk.
+            mPendingAudioRoute.clearPendingMessage(new Pair<>(SPEAKER_ON, null));
             mPendingAudioRoute.onMessageReceived(new Pair<>(SPEAKER_OFF, null), null);
             // Update status bar notification
             mStatusBarNotifier.notifySpeakerphone(false);
         } else if (mCurrentRoute.getType() == AudioRoute.TYPE_SPEAKER) {
-            routeTo(mIsActive, getBaseRoute(true, null));
+            AudioRoute newRoute = getBaseRoute(true, null);
+            routeTo(mIsActive, newRoute);
             // Since the route switching triggered by this message, we need to manually send it
-            // again so that we won't stuck in the pending route
-            if (mIsActive) {
+            // again so that we won't stuck in the pending route. Do not send the additional
+            // SPEAKER_OFF msg if we find that audio wasn't routed out of speaker. This would have
+            // the potential to cause an infinite loop if routing doesn't change.
+            if (mIsActive && newRoute.getType() != TYPE_SPEAKER) {
                 sendMessageWithSessionInfo(SPEAKER_OFF);
             }
             onAvailableRoutesChanged();
@@ -1315,21 +1404,16 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         }
     }
 
-    private AudioRoute getPreferredAudioRouteFromStrategy() {
-        // Get preferred device
-        AudioDeviceAttributes deviceAttr = getPreferredDeviceForStrategy();
+    private AudioRoute getPreferredDeviceAudioRoute(AudioDeviceAttributes deviceAttr) {
         Log.i(this, "getPreferredAudioRouteFromStrategy: preferred device is %s", deviceAttr);
         if (deviceAttr == null) {
-            return null;
+            return DUMMY_ROUTE;
         }
 
         // Get corresponding audio route
         @AudioRoute.AudioRouteType int type = DEVICE_INFO_TYPE_TO_AUDIO_ROUTE_TYPE.get(
                 deviceAttr.getType());
-        AudioDeviceInfo currentCommunicationDevice = null;
-        if (mFeatureFlags.updatePreferredAudioDeviceLogic()) {
-            currentCommunicationDevice = getCurrentCommunicationDevice();
-        }
+        AudioDeviceInfo currentCommunicationDevice = getCurrentCommunicationDevice();
         // We will default to TYPE_INVALID if the currentCommunicationDevice is null or the type
         // cannot be resolved from the given audio device info.
         int communicationDeviceAudioType = getAudioType(currentCommunicationDevice);
@@ -1349,36 +1433,15 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         }
     }
 
-    private AudioDeviceAttributes getPreferredDeviceForStrategy() {
-        // Get audio produce strategy
-        AudioProductStrategy strategy = null;
-        final AudioAttributes attr = new AudioAttributes.Builder()
-                .setUsage(AudioAttributes.USAGE_VOICE_COMMUNICATION)
-                .build();
-        List<AudioProductStrategy> strategies = AudioManager.getAudioProductStrategies();
-        for (AudioProductStrategy s : strategies) {
-            if (s.supportsAudioAttributes(attr)) {
-                strategy = s;
-            }
-        }
-        if (strategy == null) {
-            return null;
-        }
-
-        return mAudioManager.getPreferredDeviceForStrategy(strategy);
-    }
-
     private AudioRoute getPreferredAudioRouteFromDefault(boolean isExplicitUserRequest,
             boolean includeBluetooth, String btAddressToExclude) {
         boolean skipEarpiece = false;
         Call foregroundCall = mCallAudioManager.getForegroundCall();
-        if (!mFeatureFlags.fixUserRequestBaselineRouteVideoCall()) {
-            isExplicitUserRequest = false;
-        }
         if (!isExplicitUserRequest) {
             synchronized (mTelecomLock) {
-                skipEarpiece = foregroundCall != null
+                skipEarpiece = foregroundCall != null && foregroundCall.isActive()
                         && VideoProfile.isVideo(foregroundCall.getVideoState());
+                Log.i(this, "skipEarpiece for video call?" + skipEarpiece);
             }
         }
         // Route to earpiece, wired, or speaker route if there are not bluetooth routes or if there
@@ -1401,9 +1464,9 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
             // Ensure that we default to speaker route if we're in a video call, but disregard it if
             // a wired headset is plugged in. Also consider the case when we're holding/unholding a
             // call. If the route was on speaker mode, ensure that we preserve the route selection.
-            boolean shouldDefaultSpeaker = mFeatureFlags.maybeDefaultSpeakerAfterUnhold()
-                    && mWasOnSpeaker;
-            if ((skipEarpiece || shouldDefaultSpeaker) && defaultRoute != null
+            // Todo: Clean this up once logic to maintain current audio routing during
+            //  active/ringing focus switch is addressed.
+            if ((skipEarpiece || mWasOnSpeaker) && defaultRoute != null
                     && defaultRoute.getType() == AudioRoute.TYPE_EARPIECE) {
                 Log.i(this, "getPreferredAudioRouteFromDefault: Audio routing defaulting to "
                         + "speaker route for (video) call.");
@@ -1413,9 +1476,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         } else {
             // Most recent active route will always be the last in the array (ensure that we don't
             // auto route to a wearable device unless it's already active).
-            String autoRoutingToWatchExcerpt = mFeatureFlags.ignoreAutoRouteToWatchDevice()
-                    ? " (except watch)"
-                    : "";
+            String autoRoutingToWatchExcerpt = " (except inactive watch)";
             Log.i(this, "getPreferredAudioRouteFromDefault: Audio routing defaulting to "
                     + "most recently active BT route" + autoRoutingToWatchExcerpt + ".");
             return activeWatchOrNonWatchDeviceRoute;
@@ -1432,8 +1493,15 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         } else {
             AudioDeviceInfo[] deviceList = mAudioManager.getDevices(
                     AudioManager.GET_DEVICES_OUTPUTS);
+            // For debugging purposes in cases where the device list returned by the API fwk is
+            // empty and we don't end up adding the earpiece route upon init.
+            Log.i(this, "calculateSupportedRouteMaskInit: is device list size: %d",
+                    deviceList.length);
             for (AudioDeviceInfo device: deviceList) {
-                if (device.getType() == AudioDeviceInfo.TYPE_BUILTIN_EARPIECE) {
+                Log.i(this, "calculateSupportedRouteMaskInit: audio route type from audio "
+                        + "device info: %d", device != null ? DEVICE_INFO_TYPE_TO_AUDIO_ROUTE_TYPE
+                        .getOrDefault(device.getType(), TYPE_INVALID) : TYPE_INVALID);
+                if (device != null && device.getType() == AudioDeviceInfo.TYPE_BUILTIN_EARPIECE) {
                     routeMask |= CallAudioState.ROUTE_EARPIECE;
                     break;
                 }
@@ -1480,12 +1548,19 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     public AudioRoute getBaseRoute(boolean includeBluetooth, String btAddressToExclude) {
         // Catch-all case for all invocations to this method where we shouldn't be using
         // getPreferredAudioRouteFromStrategy
-        if (mFeatureFlags.updatePreferredAudioDeviceLogic() && !mUsePreferredDeviceStrategy) {
+        if (!mUsePreferredDeviceStrategy) {
             return calculateBaselineRoute(false, includeBluetooth, btAddressToExclude);
         }
-        AudioRoute destRoute = getPreferredAudioRouteFromStrategy();
-        Log.i(this, "getBaseRoute: preferred audio route is %s", destRoute);
-        if (destRoute == null || (destRoute.getBluetoothAddress() != null && (!includeBluetooth
+        // Get the preferred device value cached from the listener
+        AudioRoute destRoute = getPreferredDeviceRoute();
+        boolean isPreferredDeviceSet = destRoute != null && !destRoute.equals(DUMMY_ROUTE);
+        if (!isPreferredDeviceSet) {
+            Log.i(this, "getBaseRoute: preferred audio route is not reported by "
+                    + "AudioManager; telecom to determine");
+        } else {
+            Log.i(this, "getBaseRoute: preferred audio route is %s", destRoute);
+        }
+        if (!isPreferredDeviceSet || (destRoute.getBluetoothAddress() != null && (!includeBluetooth
                 || destRoute.getBluetoothAddress().equals(btAddressToExclude)))) {
             destRoute = getPreferredAudioRouteFromDefault(false, includeBluetooth, btAddressToExclude);
         }
@@ -1558,12 +1633,6 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
      * device.
      */
     private AudioRoute getActiveWatchOrNonWatchDeviceRoute(String btAddressToExclude) {
-        if (!mFeatureFlags.ignoreAutoRouteToWatchDevice()) {
-            Log.i(this, "getActiveWatchOrNonWatchDeviceRoute: ignore_auto_route_to_watch_device "
-                    + "flag is disabled. Routing to most recently reported active device.");
-            return getMostRecentlyActiveBtRoute(btAddressToExclude);
-        }
-
         List<AudioRoute> bluetoothRoutes = getAvailableBluetoothDevicesForRouting();
         // Traverse the routes from the most recently active recorded devices first.
         AudioRoute nonWatchDeviceRoute = null;
@@ -1585,8 +1654,8 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
                     && (device.equals(mCallAudioState.getActiveBluetoothDevice())
                     || isActiveDevice)) {
                 Log.i(this, "getActiveWatchOrNonWatchDeviceRoute: Routing to active watch - %s",
-                        bluetoothRoutes.get(0));
-                return bluetoothRoutes.get(0);
+                        bluetoothRoutes.get(bluetoothRoutes.size() - 1));
+                return bluetoothRoutes.get(bluetoothRoutes.size() - 1);
             }
             // Record the first occurrence of a non-watch device route if found.
             if (!mBluetoothRouteManager.isWatch(device)) {
@@ -1601,9 +1670,6 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
 
     private List<AudioRoute> getAvailableBluetoothDevicesForRouting() {
         List<AudioRoute> bluetoothRoutes = new ArrayList<>(mBluetoothRoutes.keySet());
-        if (!mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()) {
-            return bluetoothRoutes;
-        }
         // Consider the active device (BT_ACTIVE_DEVICE_PRESENT) if it exists first.
         AudioRoute activeDeviceRoute = getArbitraryBluetoothDevice();
         if (activeDeviceRoute != null && (bluetoothRoutes.isEmpty()
@@ -1615,25 +1681,6 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         return bluetoothRoutes;
     }
 
-    /**
-     * Returns the most actively reported bluetooth route excluding the passed in route.
-     */
-    private AudioRoute getMostRecentlyActiveBtRoute(String btAddressToExclude) {
-        List<AudioRoute> bluetoothRoutes = mBluetoothRoutes.keySet().stream().toList();
-        for (int i = bluetoothRoutes.size() - 1; i >= 0; i--) {
-            AudioRoute route = bluetoothRoutes.get(i);
-            // Skip LE route if it's not the lead device.
-            if (isLeAudioNonLeadDeviceOrServiceUnavailable(
-                    route.getType(), mBluetoothRoutes.get(route))) {
-                continue;
-            }
-            if (!route.getBluetoothAddress().equals(btAddressToExclude)) {
-                return route;
-            }
-        }
-        return null;
-    }
-
     private boolean isLeAudioNonLeadDeviceOrServiceUnavailable(@AudioRoute.AudioRouteType int type,
             BluetoothDevice device) {
         BluetoothLeAudio leAudioService = getLeAudioService();
@@ -1713,9 +1760,7 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
                     String address = activeDevice.getValue();
                     if (address != null) {
                         hasActiveDevice = true;
-                        if (mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()) {
-                            mActiveBluetoothDevice = new Pair<>(btAudioType, address);
-                        }
+                        mActiveBluetoothDevice = new Pair<>(btAudioType, address);
                         break;
                     }
                 }
@@ -1727,6 +1772,9 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
     }
 
     private void updateAvailableRoutes(AudioRoute route, boolean includeRoute) {
+        if (route == null) {
+            return;
+        }
         if (includeRoute) {
             mAvailableRoutes.add(route);
         } else {
@@ -1784,6 +1832,18 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         }
     }
 
+    public void setPreferredDeviceRoute(AudioRoute route) {
+        synchronized (mLock) {
+            mPreferredDeviceRoute = route;
+        }
+    }
+
+    public AudioRoute getPreferredDeviceRoute() {
+        synchronized (mLock) {
+            return mPreferredDeviceRoute;
+        }
+    }
+
     private void maybeDisableWasOnSpeaker(boolean isUserRequest) {
         if (isUserRequest) {
             mWasOnSpeaker = false;
@@ -1816,4 +1876,62 @@ public class CallAudioRouteController implements CallAudioRouteAdapter {
         }
         return isDestRouteActive;
     }
+
+    private void createSpeakerRoute() {
+        int audioRouteType = TYPE_SPEAKER;
+        if (mSpeakerDockRoute == null) {
+            //create type speaker
+            mSpeakerDockRoute = mAudioRouteFactory.create(audioRouteType, null,
+                    mAudioManager);
+            // If speaker route couldn't be instantiated, try for TYPE_BUS
+            if (mSpeakerDockRoute == null) {
+                Log.i(this, "createSpeakerRoute: Can't find available audio device info for "
+                        + "route TYPE_SPEAKER, trying for TYPE_BUS");
+                mSpeakerDockRoute = mAudioRouteFactory.create(AudioRoute.TYPE_BUS, null,
+                        mAudioManager);
+                audioRouteType = AudioRoute.TYPE_BUS;
+            }
+            if (mSpeakerDockRoute == null) {
+                Log.w(this, "createSpeakerRoute: Can't find available audio device info "
+                        + "for route TYPE_SPEAKER or TYPE_BUS.");
+            } else {
+                // Update available routes
+                mTypeRoutes.put(audioRouteType, mSpeakerDockRoute);
+                updateAvailableRoutes(mSpeakerDockRoute, true);
+            }
+        } else {
+            Log.i(this, "createSpeakerRoute: route already created. Skipping.");
+        }
+    }
+
+    private void createEarpieceRoute() {
+        // Create earpiece route
+        if (mEarpieceWiredRoute != null) {
+            Log.i(this, "createEarpieceRoute: route already created. Skipping.");
+            return;
+        }
+        mEarpieceWiredRoute = mAudioRouteFactory.create(AudioRoute.TYPE_EARPIECE, null,
+                mAudioManager);
+        if (mEarpieceWiredRoute == null) {
+            Log.w(this, "createEarpieceRoute: Can't find available audio device info for "
+                    + "route TYPE_EARPIECE");
+        } else {
+            mTypeRoutes.put(AudioRoute.TYPE_EARPIECE, mEarpieceWiredRoute);
+            updateAvailableRoutes(mEarpieceWiredRoute, true);
+        }
+    }
+
+    @VisibleForTesting
+    public AudioRoute getAudioRouteForTesting(int audioRouteType) {
+        return switch (audioRouteType) {
+            case AudioRoute.TYPE_EARPIECE, AudioRoute.TYPE_WIRED -> mEarpieceWiredRoute;
+            case AudioRoute.TYPE_SPEAKER -> mSpeakerDockRoute;
+            default -> DUMMY_ROUTE;
+        };
+    }
+
+    @VisibleForTesting
+    public AudioRoutesCallback getAudioRoutesCallback() {
+        return mAudioRoutesCallback;
+    }
 }
diff --git a/src/com/android/server/telecom/CallAudioRouteStateMachine.java b/src/com/android/server/telecom/CallAudioRouteStateMachine.java
index 4283b7b7b..d2cfada97 100644
--- a/src/com/android/server/telecom/CallAudioRouteStateMachine.java
+++ b/src/com/android/server/telecom/CallAudioRouteStateMachine.java
@@ -281,20 +281,13 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
         public void enter() {
             super.enter();
             setSpeakerphoneOn(false);
-            if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                mCommunicationDeviceTracker.setCommunicationDevice(
-                        AudioDeviceInfo.TYPE_BUILTIN_EARPIECE, null);
-            }
+            mCommunicationDeviceTracker.setCommunicationDevice(
+                    AudioDeviceInfo.TYPE_BUILTIN_EARPIECE, null);
             CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_EARPIECE,
                     mAvailableRoutes, null,
                     mBluetoothRouteManager.getConnectedDevices());
-            if (mFeatureFlags.earlyUpdateInternalCallAudioState()) {
-                updateInternalCallAudioState();
-                setSystemAudioState(newState, true);
-            } else {
-                setSystemAudioState(newState, true);
-                updateInternalCallAudioState();
-            }
+            updateInternalCallAudioState();
+            setSystemAudioState(newState, true);
         }
 
         @Override
@@ -320,10 +313,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                 case SWITCH_BLUETOOTH:
                 case USER_SWITCH_BLUETOOTH:
                     if ((mAvailableRoutes & ROUTE_BLUETOOTH) != 0) {
-                        if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                            mCommunicationDeviceTracker.clearCommunicationDevice(
-                                    AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
-                        }
+                        mCommunicationDeviceTracker.clearCommunicationDevice(
+                                AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
                         if (mAudioFocusType == ACTIVE_FOCUS
                                 || mBluetoothRouteManager.isInbandRingingEnabled()) {
                             String address = (msg.obj instanceof SomeArgs) ?
@@ -340,10 +331,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                 case SWITCH_HEADSET:
                 case USER_SWITCH_HEADSET:
                     if ((mAvailableRoutes & ROUTE_WIRED_HEADSET) != 0) {
-                        if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                            mCommunicationDeviceTracker.clearCommunicationDevice(
-                                    AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
-                        }
+                        mCommunicationDeviceTracker.clearCommunicationDevice(
+                                AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
                         transitionTo(mActiveHeadsetRoute);
                     } else {
                         Log.w(this, "Ignoring switch to headset command. Not available.");
@@ -353,10 +342,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                     // fall through; we want to switch to speaker mode when docked and in a call.
                 case SWITCH_SPEAKER:
                 case USER_SWITCH_SPEAKER:
-                    if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                        mCommunicationDeviceTracker.clearCommunicationDevice(
-                                AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
-                    }
+                    mCommunicationDeviceTracker.clearCommunicationDevice(
+                            AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
                     setSpeakerphoneOn(true);
                     // fall through
                 case SPEAKER_ON:
@@ -510,19 +497,12 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
         public void enter() {
             super.enter();
             setSpeakerphoneOn(false);
-            if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                mCommunicationDeviceTracker.setCommunicationDevice(
-                        AudioDeviceInfo.TYPE_WIRED_HEADSET, null);
-            }
+            mCommunicationDeviceTracker.setCommunicationDevice(
+                    AudioDeviceInfo.TYPE_WIRED_HEADSET, null);
             CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_WIRED_HEADSET,
                     mAvailableRoutes, null, mBluetoothRouteManager.getConnectedDevices());
-            if (mFeatureFlags.earlyUpdateInternalCallAudioState()) {
-                updateInternalCallAudioState();
-                setSystemAudioState(newState, true);
-            } else {
-                setSystemAudioState(newState, true);
-                updateInternalCallAudioState();
-            }
+            updateInternalCallAudioState();
+            setSystemAudioState(newState, true);
         }
 
         @Override
@@ -540,10 +520,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                 case SWITCH_EARPIECE:
                 case USER_SWITCH_EARPIECE:
                     if ((mAvailableRoutes & ROUTE_EARPIECE) != 0) {
-                        if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                            mCommunicationDeviceTracker.clearCommunicationDevice(
-                                    AudioDeviceInfo.TYPE_WIRED_HEADSET);
-                        }
+                        mCommunicationDeviceTracker.clearCommunicationDevice(
+                                AudioDeviceInfo.TYPE_WIRED_HEADSET);
                         transitionTo(mActiveEarpieceRoute);
                     } else {
                         Log.w(this, "Ignoring switch to earpiece command. Not available.");
@@ -559,10 +537,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                                 || mBluetoothRouteManager.isInbandRingingEnabled()) {
                             String address = (msg.obj instanceof SomeArgs) ?
                                     (String) ((SomeArgs) msg.obj).arg2 : null;
-                            if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                                mCommunicationDeviceTracker.clearCommunicationDevice(
-                                        AudioDeviceInfo.TYPE_WIRED_HEADSET);
-                            }
+                            mCommunicationDeviceTracker.clearCommunicationDevice(
+                                    AudioDeviceInfo.TYPE_WIRED_HEADSET);
                             // Omit transition to ActiveBluetoothRoute until actual connection.
                             setBluetoothOn(address);
                         } else {
@@ -579,10 +555,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                     return HANDLED;
                 case SWITCH_SPEAKER:
                 case USER_SWITCH_SPEAKER:
-                    if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                        mCommunicationDeviceTracker.clearCommunicationDevice(
-                                AudioDeviceInfo.TYPE_WIRED_HEADSET);
-                    }
+                    mCommunicationDeviceTracker.clearCommunicationDevice(
+                            AudioDeviceInfo.TYPE_WIRED_HEADSET);
                     setSpeakerphoneOn(true);
                     // fall through
                 case SPEAKER_ON:
@@ -750,22 +724,15 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
             // the BT connection fails to be set. Previously, the logic was to setBluetoothOn in
             // ACTIVE_FOCUS but the route would still remain in a quiescent route, so instead we
             // should be transitioning directly into the active route.
-            if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                setBluetoothOn(null);
-            }
+            setBluetoothOn(null);
             if (mFeatureFlags.updateRouteMaskWhenBtConnected()) {
                 mAvailableRoutes |= ROUTE_BLUETOOTH;
             }
             CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH,
                     mAvailableRoutes, mBluetoothRouteManager.getBluetoothAudioConnectedDevice(),
                     mBluetoothRouteManager.getConnectedDevices());
-            if (mFeatureFlags.earlyUpdateInternalCallAudioState()) {
-                updateInternalCallAudioState();
-                setSystemAudioState(newState, true);
-            } else {
-                setSystemAudioState(newState, true);
-                updateInternalCallAudioState();
-            }
+            updateInternalCallAudioState();
+            setSystemAudioState(newState, true);
             // Do not send RINGER_MODE_CHANGE if no Bluetooth SCO audio device is available
             if (mBluetoothRouteManager.getBluetoothAudioConnectedDevice() != null) {
                 mCallAudioManager.onRingerModeChange();
@@ -913,13 +880,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
             CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH,
                     mAvailableRoutes, mBluetoothRouteManager.getBluetoothAudioConnectedDevice(),
                     mBluetoothRouteManager.getConnectedDevices());
-            if (mFeatureFlags.earlyUpdateInternalCallAudioState()) {
-                updateInternalCallAudioState();
-                setSystemAudioState(newState, true);
-            } else {
-                setSystemAudioState(newState, true);
-                updateInternalCallAudioState();
-            }
+            updateInternalCallAudioState();
+            setSystemAudioState(newState, true);
         }
 
         @Override
@@ -1053,11 +1015,7 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
                     if (msg.arg1 == ACTIVE_FOCUS) {
                         // It is possible that the connection to BT will fail while in-call, in
                         // which case, we want to transition into the active route.
-                        if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                            transitionTo(mActiveBluetoothRoute);
-                        } else {
-                            setBluetoothOn(null);
-                        }
+                        transitionTo(mActiveBluetoothRoute);
                     } else if (msg.arg1 == RINGING_FOCUS) {
                         if (mBluetoothRouteManager.isInbandRingingEnabled()) {
                             setBluetoothOn(null);
@@ -1142,13 +1100,8 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
             mWasOnSpeaker = true;
             CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_SPEAKER,
                     mAvailableRoutes, null, mBluetoothRouteManager.getConnectedDevices());
-            if (mFeatureFlags.earlyUpdateInternalCallAudioState()) {
-                updateInternalCallAudioState();
-                setSystemAudioState(newState, true);
-            } else {
-                setSystemAudioState(newState, true);
-                updateInternalCallAudioState();
-            }
+            updateInternalCallAudioState();
+            setSystemAudioState(newState, true);
         }
 
         @Override
@@ -1689,6 +1642,11 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
         // ignore, only used in CallAudioRouteController
     }
 
+    @Override
+    public void sendMessageWithSessionInfoAtFront(int message, int arg, int data) {
+        // ignore, only used in CallAudioRouteController
+    }
+
     public void sendMessageWithSessionInfo(int message, int arg, BluetoothDevice bluetoothDevice) {
         // ignore, only used in CallAudioRouteController
     }
@@ -1777,16 +1735,12 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
         // These APIs are all via two-way binder calls so can potentially block Telecom.  Since none
         // of this has to happen in the Telecom lock we'll offload it to the async executor.
         boolean speakerOn = false;
-        if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-            if (on) {
-                speakerOn = mCommunicationDeviceTracker.setCommunicationDevice(
-                        AudioDeviceInfo.TYPE_BUILTIN_SPEAKER, null);
-            } else {
-                mCommunicationDeviceTracker.clearCommunicationDevice(
-                        AudioDeviceInfo.TYPE_BUILTIN_SPEAKER);
-            }
+        if (on) {
+            speakerOn = mCommunicationDeviceTracker.setCommunicationDevice(
+                    AudioDeviceInfo.TYPE_BUILTIN_SPEAKER, null);
         } else {
-            speakerOn = processLegacySpeakerCommunicationDevice(on);
+            mCommunicationDeviceTracker.clearCommunicationDevice(
+                    AudioDeviceInfo.TYPE_BUILTIN_SPEAKER);
         }
         mStatusBarNotifier.notifySpeakerphone(hasAnyCalls && speakerOn);
     }
@@ -2009,11 +1963,6 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
     }
 
     private boolean isWatchActiveOrOnlyWatchesAvailable() {
-        if (!mFeatureFlags.ignoreAutoRouteToWatchDevice()) {
-            Log.i(this, "isWatchActiveOrOnlyWatchesAvailable: Flag is disabled.");
-            return false;
-        }
-
         boolean containsWatchDevice = false;
         boolean containsNonWatchDevice = false;
         Collection<BluetoothDevice> connectedBtDevices =
@@ -2036,30 +1985,6 @@ public class CallAudioRouteStateMachine extends StateMachine implements CallAudi
         return containsWatchDevice && !containsNonWatchDevice && !isActiveDeviceWatch;
     }
 
-    private boolean processLegacySpeakerCommunicationDevice(boolean on) {
-        AudioDeviceInfo speakerDevice = null;
-        for (AudioDeviceInfo info : mAudioManager.getAvailableCommunicationDevices()) {
-            if (info.getType() == AudioDeviceInfo.TYPE_BUILTIN_SPEAKER) {
-                speakerDevice = info;
-                break;
-            }
-        }
-        boolean speakerOn = false;
-        if (speakerDevice != null && on) {
-            boolean result = mAudioManager.setCommunicationDevice(speakerDevice);
-            if (result) {
-                speakerOn = true;
-            }
-        } else {
-            AudioDeviceInfo curDevice = mAudioManager.getCommunicationDevice();
-            if (curDevice != null
-                    && curDevice.getType() == AudioDeviceInfo.TYPE_BUILTIN_SPEAKER) {
-                mAudioManager.clearCommunicationDevice();
-            }
-        }
-        return speakerOn;
-    }
-
     private int calculateBaselineRouteMessage(boolean isExplicitUserRequest,
             boolean includeBluetooth) {
         boolean isSkipEarpiece = false;
diff --git a/src/com/android/server/telecom/CallConnectedIndicatorSettings.java b/src/com/android/server/telecom/CallConnectedIndicatorSettings.java
new file mode 100644
index 000000000..6d4eb857b
--- /dev/null
+++ b/src/com/android/server/telecom/CallConnectedIndicatorSettings.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.telecom;
+
+import static android.telecom.TelecomManager.CALL_CONNECTED_INDICATOR_NONE;
+import static android.telecom.TelecomManager.CALL_CONNECTED_INDICATOR_TONE;
+import static android.telecom.TelecomManager.CALL_CONNECTED_INDICATOR_VIBRATION;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.telecom.flags.FeatureFlags;
+
+@VisibleForTesting
+public class CallConnectedIndicatorSettings {
+    private static final String TAG = "CallConnectedIndicatorSettings";
+
+    private static final int ALL_SUPPORTED_PREFERENCE = CALL_CONNECTED_INDICATOR_TONE
+            | CALL_CONNECTED_INDICATOR_VIBRATION;
+    private static final String SHARED_PREFERENCES_NAME = "call_connected_indicator_prefs";
+    private static final String SHARED_PREFERENCES_KEY = "preference_key";
+
+    private final Context mContext;
+    private final FeatureFlags mFeatureFlags;
+    private int mCallConnectedIndicator = CALL_CONNECTED_INDICATOR_NONE;
+
+    public CallConnectedIndicatorSettings(Context context, FeatureFlags flag) {
+        mContext = context;
+        mFeatureFlags = flag;
+        final SharedPreferences prefs = context.getSharedPreferences(
+                SHARED_PREFERENCES_NAME, Context.MODE_PRIVATE);
+        mCallConnectedIndicator = prefs.getInt(SHARED_PREFERENCES_KEY,
+                CALL_CONNECTED_INDICATOR_NONE);
+    }
+
+    public synchronized boolean isCallConnectedVibrationEnabled() {
+        return (mCallConnectedIndicator & CALL_CONNECTED_INDICATOR_VIBRATION)
+                == CALL_CONNECTED_INDICATOR_VIBRATION;
+    }
+
+    public synchronized boolean isCallConnectedToneEnabled() {
+        return (mCallConnectedIndicator & CALL_CONNECTED_INDICATOR_TONE)
+                == CALL_CONNECTED_INDICATOR_TONE;
+    }
+
+    public synchronized void setCallConnectedIndicatorPreference(int preference) {
+        if ((preference & ~ALL_SUPPORTED_PREFERENCE) > 0) {
+            throw new IllegalArgumentException("Invalid preference " + preference);
+        }
+        mCallConnectedIndicator = preference;
+        final SharedPreferences prefs = mContext.getSharedPreferences(
+                SHARED_PREFERENCES_NAME, Context.MODE_PRIVATE);
+        final SharedPreferences.Editor editor = prefs.edit();
+        editor.putInt(SHARED_PREFERENCES_KEY, mCallConnectedIndicator);
+        editor.commit();
+    }
+
+    public synchronized int getCallConnectedIndicatorPreference() {
+        return mCallConnectedIndicator;
+    }
+}
diff --git a/src/com/android/server/telecom/CallDiagnosticServiceController.java b/src/com/android/server/telecom/CallDiagnosticServiceController.java
index 1077f0d32..5cabbcd01 100644
--- a/src/com/android/server/telecom/CallDiagnosticServiceController.java
+++ b/src/com/android/server/telecom/CallDiagnosticServiceController.java
@@ -331,6 +331,7 @@ public class CallDiagnosticServiceController extends CallsManagerListenerBase {
             CallAudioState newCallAudioState) {
         if (mCallDiagnosticService != null) {
             try {
+                Log.i(this, "onCallAudioStateChanged: newAudioState=%s", newCallAudioState);
                 mCallDiagnosticService.updateCallAudioState(newCallAudioState);
             } catch (RemoteException e) {
                 Log.w(this, "onCallAudioStateChanged: failed %s", e);
diff --git a/src/com/android/server/telecom/CallEndpointController.java b/src/com/android/server/telecom/CallEndpointController.java
index 016b75ee8..f92700cc4 100644
--- a/src/com/android/server/telecom/CallEndpointController.java
+++ b/src/com/android/server/telecom/CallEndpointController.java
@@ -201,16 +201,7 @@ public class CallEndpointController extends CallsManagerListenerBase {
 
         List<Call> calls = new ArrayList<>(mCallsManager.getTrackedCalls());
         for (Call call : calls) {
-            if (mFeatureFlags.cacheCallAudioCallbacks()) {
-                onCallEndpointChangedOrCache(call);
-            } else {
-                if (call != null && call.getConnectionService() != null) {
-                    call.getConnectionService().onCallEndpointChanged(call, mActiveCallEndpoint);
-                } else if (call != null && call.getTransactionServiceWrapper() != null) {
-                    call.getTransactionServiceWrapper()
-                            .onCallEndpointChanged(call, mActiveCallEndpoint);
-                }
-            }
+            onCallEndpointChangedOrCache(call);
         }
     }
 
@@ -231,17 +222,7 @@ public class CallEndpointController extends CallsManagerListenerBase {
 
         List<Call> calls = new ArrayList<>(mCallsManager.getTrackedCalls());
         for (Call call : calls) {
-            if (mFeatureFlags.cacheCallAudioCallbacks()) {
-                onAvailableEndpointsChangedOrCache(call);
-            } else {
-                if (call != null && call.getConnectionService() != null) {
-                    call.getConnectionService().onAvailableCallEndpointsChanged(call,
-                            mAvailableCallEndpoints);
-                } else if (call != null && call.getTransactionServiceWrapper() != null) {
-                    call.getTransactionServiceWrapper().onAvailableCallEndpointsChanged(call,
-                            mAvailableCallEndpoints);
-                }
-            }
+            onAvailableEndpointsChangedOrCache(call);
         }
     }
 
@@ -262,15 +243,7 @@ public class CallEndpointController extends CallsManagerListenerBase {
 
         List<Call> calls = new ArrayList<>(mCallsManager.getTrackedCalls());
         for (Call call : calls) {
-            if (mFeatureFlags.cacheCallAudioCallbacks()) {
-                onMuteStateChangedOrCache(call, isMuted);
-            } else {
-                if (call != null && call.getConnectionService() != null) {
-                    call.getConnectionService().onMuteStateChanged(call, isMuted);
-                } else if (call != null && call.getTransactionServiceWrapper() != null) {
-                    call.getTransactionServiceWrapper().onMuteStateChanged(call, isMuted);
-                }
-            }
+            onMuteStateChangedOrCache(call, isMuted);
         }
     }
 
diff --git a/src/com/android/server/telecom/CallLogManager.java b/src/com/android/server/telecom/CallLogManager.java
index 4484e23f3..de952ce8d 100644
--- a/src/com/android/server/telecom/CallLogManager.java
+++ b/src/com/android/server/telecom/CallLogManager.java
@@ -172,6 +172,24 @@ public final class CallLogManager extends CallsManagerListenerBase {
         }
     }
 
+    /**
+     * Log call only if Call is NOT a self-managed call OR call is a self-managed call which has
+     * indicated it should be logged in its PhoneAccount
+     */
+    void logCallIfNotSelfManaged (Call call, int type, boolean showNotificationForMissedCall,
+            CallFilteringResult result) {
+        boolean shouldCallSelfManagedLogged = call.isLoggedSelfManaged() &&
+                (call.getHandoverState() == HandoverState.HANDOVER_NONE
+                || call.getHandoverState() == HandoverState.HANDOVER_COMPLETE);
+        if (!mFeatureFlags.preventSelfManagedCallLogging() || !call.isSelfManaged() ||
+                shouldCallSelfManagedLogged) {
+            logCall(call, type, showNotificationForMissedCall, result);
+        } else {
+            Log.d(TAG, "logCallIfNotSelfManaged: skipping call logging due to self managed "
+                    + "for call = " + call);
+        }
+    }
+
     /**
      * Log newly disconnected calls only if all of below conditions are met:
      * Call was NOT in the "choose account" phase when disconnected
@@ -187,8 +205,8 @@ public final class CallLogManager extends CallsManagerListenerBase {
      */
     @VisibleForTesting
     public boolean shouldLogDisconnectedCall(Call call, int oldState, boolean isCallCanceled) {
-        boolean shouldCallSelfManagedLogged = call.isLoggedSelfManaged()
-                && (call.getHandoverState() == HandoverState.HANDOVER_NONE
+        boolean shouldCallSelfManagedLogged = call.isLoggedSelfManaged() &&
+                (call.getHandoverState() == HandoverState.HANDOVER_NONE
                 || call.getHandoverState() == HandoverState.HANDOVER_COMPLETE);
 
         // "Choose account" phase when disconnected
@@ -209,7 +227,7 @@ public final class CallLogManager extends CallsManagerListenerBase {
             return false;
         }
 
-        if (mFeatureFlags.telecomSkipLogBasedOnExtra() && call.getExtras() != null
+        if (call.getExtras() != null
                 && call.getExtras().containsKey(TelecomManager.EXTRA_DO_NOT_LOG_CALL)) {
             return false;
         }
@@ -235,9 +253,8 @@ public final class CallLogManager extends CallsManagerListenerBase {
                     == Connection.CAPABILITY_DISCONNECT_FROM_CONFERENCE;
         }
         // An external and non-watch call
-        if (call.isExternalCall() && (!mContext.getPackageManager().hasSystemFeature(
-                PackageManager.FEATURE_WATCH)
-                || !mFeatureFlags.telecomLogExternalWearableCalls())) {
+        if (call.isExternalCall() && !mContext.getPackageManager().hasSystemFeature(
+                PackageManager.FEATURE_WATCH)) {
             return false;
         }
 
@@ -477,8 +494,14 @@ public final class CallLogManager extends CallsManagerListenerBase {
         String[] unloggableNumbersFromCarrierConfig = carrierConfig == null ? null
                 : carrierConfig.getStringArray(
                         CarrierConfigManager.KEY_UNLOGGABLE_NUMBERS_STRING_ARRAY);
-        String[] unloggableNumbersFromMccConfig = mContext.getResources()
-                .getStringArray(com.android.internal.R.array.unloggable_phone_numbers);
+        String[] unloggableNumbersFromMccConfig;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            unloggableNumbersFromMccConfig = mContext.getResources()
+                    .getStringArray(com.android.server.telecom.R.array.unloggable_phone_numbers);
+        } else {
+            unloggableNumbersFromMccConfig = mContext.getResources()
+                    .getStringArray(com.android.internal.R.array.unloggable_phone_numbers);
+        }
         return Stream.concat(
                 unloggableNumbersFromCarrierConfig == null ?
                         Stream.empty() : Arrays.stream(unloggableNumbersFromCarrierConfig),
diff --git a/src/com/android/server/telecom/CallRecordingTonePlayer.java b/src/com/android/server/telecom/CallRecordingTonePlayer.java
index 1b522bc19..4ab565034 100644
--- a/src/com/android/server/telecom/CallRecordingTonePlayer.java
+++ b/src/com/android/server/telecom/CallRecordingTonePlayer.java
@@ -29,6 +29,7 @@ import android.provider.MediaStore;
 import android.telecom.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -91,7 +92,11 @@ public class CallRecordingTonePlayer extends CallsManagerListenerBase {
             if (telephonyDevice != null) {
                 mRecordingTonePlayer = MediaPlayer.create(mContext, R.raw.record);
                 mRecordingTonePlayer.setPreferredDevice(telephonyDevice);
-                mRecordingTonePlayer.setVolume(0.1f);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    mRecordingTonePlayer.setVolume(0.1f, 0.1f);
+                } else {
+                    mRecordingTonePlayer.setVolume(0.1f);
+                }
                 AudioAttributes audioAttributes = new AudioAttributes.Builder()
                         .setUsage(AudioAttributes.USAGE_VOICE_COMMUNICATION).build();
                 mRecordingTonePlayer.setAudioAttributes(audioAttributes);
@@ -117,16 +122,17 @@ public class CallRecordingTonePlayer extends CallsManagerListenerBase {
     private final long mRepeatInterval;
     private boolean mIsRecording = false;
     private LoopingTonePlayer mLoopingTonePlayer;
+    private FeatureFlags mFeatureFlags;
     private List<Call> mCalls = new ArrayList<>();
 
     public CallRecordingTonePlayer(Context context, AudioManager audioManager,
             Timeouts.Adapter timeouts,
-            TelecomSystem.SyncRoot lock) {
+            TelecomSystem.SyncRoot lock, FeatureFlags featureFlags) {
+        mFeatureFlags = featureFlags;
         mContext = context;
         mAudioManager = audioManager;
         mLock = lock;
-        mRepeatInterval = timeouts.getCallRecordingToneRepeatIntervalMillis(
-                context.getContentResolver());
+        mRepeatInterval = timeouts.getCallRecordingToneRepeatIntervalMillis(context, featureFlags);
     }
 
     @Override
diff --git a/src/com/android/server/telecom/CallScreeningServiceHelper.java b/src/com/android/server/telecom/CallScreeningServiceHelper.java
index fa436d4c4..835aa73b2 100644
--- a/src/com/android/server/telecom/CallScreeningServiceHelper.java
+++ b/src/com/android/server/telecom/CallScreeningServiceHelper.java
@@ -33,6 +33,7 @@ import android.text.TextUtils;
 
 import com.android.internal.telecom.ICallScreeningAdapter;
 import com.android.internal.telecom.ICallScreeningService;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
@@ -74,10 +75,12 @@ public class CallScreeningServiceHelper {
     private final Session mLoggingSession;
     private CompletableFuture mFuture;
     private String mPackageName;
+    private final FeatureFlags mFeatureFlags;
 
     public CallScreeningServiceHelper(Context context, TelecomSystem.SyncRoot telecomLock,
             String packageName, ParcelableCallUtils.Converter converter,
-            UserHandle userHandle, Call call, AppLabelProxy appLabelProxy) {
+            UserHandle userHandle, Call call, AppLabelProxy appLabelProxy,
+            FeatureFlags featureFlags) {
         mContext = context;
         mTelecomLock = telecomLock;
         mParcelableCallUtilsConverter = converter;
@@ -86,6 +89,7 @@ public class CallScreeningServiceHelper {
         mPackageName = packageName;
         mAppLabelProxy = appLabelProxy;
         mLoggingSession = Log.createSubsession();
+        mFeatureFlags = featureFlags;
     }
 
     /**
@@ -113,10 +117,12 @@ public class CallScreeningServiceHelper {
                 Log.continueSession(mLoggingSession, "CSSH.oSC");
                 try {
                     try {
-                        // Note: for outgoing calls, never include the restricted extras.
+                        // Note: for outgoing calls, never include the restricted extras
+                        // and PhoneAccountHandle
                         screeningService.screenCall(new CallScreeningAdapter(this),
                                 mParcelableCallUtilsConverter.toParcelableCallForScreening(mCall,
-                                        false /* areRestrictedExtrasIncluded */));
+                                        false /* areRestrictedExtrasIncluded */,
+                                        false /* includePhoneAccountHandle */));
                     } catch (RemoteException e) {
                         Log.w(CallScreeningServiceHelper.this,
                                 "Cancelling call id due to remote exception");
@@ -160,7 +166,8 @@ public class CallScreeningServiceHelper {
             }
         };
 
-        if (!bindCallScreeningService(mContext, mUserHandle, mPackageName, serviceConnection)) {
+        if (!bindCallScreeningService(mContext, mUserHandle, mPackageName, serviceConnection,
+                mFeatureFlags)) {
             Log.i(this, "bindAndGetCallIdentification - bind failed");
             mFuture.complete(null);
         }
@@ -184,7 +191,7 @@ public class CallScreeningServiceHelper {
                         Log.endSession();
                     }
                 },
-                Timeouts.getCallScreeningTimeoutMillis(mContext.getContentResolver()));
+                Timeouts.getCallScreeningTimeoutMillis(mContext, mFeatureFlags));
         return mFuture;
     }
 
@@ -197,7 +204,7 @@ public class CallScreeningServiceHelper {
      * @return {@code true} if binding succeeds, {@code false} otherwise.
      */
     public static boolean bindCallScreeningService(Context context, UserHandle userHandle,
-            String packageName, ServiceConnection serviceConnection) {
+            String packageName, ServiceConnection serviceConnection, FeatureFlags flags) {
         if (TextUtils.isEmpty(packageName)) {
             Log.i(TAG, "PackageName is empty. Not performing call screening.");
             return false;
@@ -205,8 +212,16 @@ public class CallScreeningServiceHelper {
 
         Intent intent = new Intent(CallScreeningService.SERVICE_INTERFACE)
                 .setPackage(packageName);
-        List<ResolveInfo> entries = context.getPackageManager().queryIntentServicesAsUser(
-                intent, 0, userHandle.getIdentifier());
+
+        List<ResolveInfo> entries;
+        if (flags.resolveHiddenDependenciesTwo()) {
+            entries = UserUtil.getPackageManagerFromUserHandler(context,
+                    userHandle).queryIntentServicesAsUser(intent, 0, userHandle.getIdentifier());
+        } else {
+            entries = context.getPackageManager().queryIntentServicesAsUser(
+                    intent, 0, userHandle.getIdentifier());
+        }
+
         if (entries.isEmpty()) {
             Log.i(TAG, packageName + " has no call screening service defined.");
             return false;
diff --git a/src/com/android/server/telecom/CallsManager.java b/src/com/android/server/telecom/CallsManager.java
index f959c5272..b97c098cb 100644
--- a/src/com/android/server/telecom/CallsManager.java
+++ b/src/com/android/server/telecom/CallsManager.java
@@ -78,7 +78,6 @@ import android.os.Process;
 import android.os.ResultReceiver;
 import android.os.SystemClock;
 import android.os.SystemProperties;
-import android.os.SystemVibrator;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.BlockedNumberContract;
@@ -154,7 +153,6 @@ import com.android.server.telecom.ui.IncomingCallNotifier;
 import com.android.server.telecom.ui.ToastFactory;
 import com.android.server.telecom.callsequencing.voip.VoipCallMonitor;
 import com.android.server.telecom.callsequencing.TransactionManager;
-import com.android.server.telecom.callsequencing.voip.VoipCallMonitorLegacy;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -520,7 +518,6 @@ public class CallsManager extends Call.ListenerBase
     private final EmergencyCallHelper mEmergencyCallHelper;
     private final RoleManagerAdapter mRoleManagerAdapter;
     private final VoipCallMonitor mVoipCallMonitor;
-    private final VoipCallMonitorLegacy mVoipCallMonitorLegacy;
     private final CallEndpointController mCallEndpointController;
     private final CallAnomalyWatchdog mCallAnomalyWatchdog;
 
@@ -536,8 +533,8 @@ public class CallsManager extends Call.ListenerBase
     private final com.android.internal.telephony.flags.FeatureFlags mTelephonyFeatureFlags;
 
     private final IncomingCallFilterGraphProvider mIncomingCallFilterGraphProvider;
-    private final CallAudioWatchdog mCallAudioWatchDog;
-    private final CallAudioRouteAdapter mCallAudioRouteAdapter;
+    private CallAudioWatchdog mCallAudioWatchDog;
+    private CallAudioRouteAdapter mCallAudioRouteAdapter;
 
     private final ConnectionServiceFocusManager.CallsManagerRequester mRequester =
             new ConnectionServiceFocusManager.CallsManagerRequester() {
@@ -615,6 +612,8 @@ public class CallsManager extends Call.ListenerBase
         }
     };
 
+    private final CallConnectedIndicatorSettings mCallConnectedIndicatorSettings;
+
     /**
      * Initializes the required Telecom components.
      */
@@ -644,7 +643,7 @@ public class CallsManager extends Call.ListenerBase
             ClockProxy clockProxy,
             AudioProcessingNotification audioProcessingNotification,
             BluetoothStateReceiver bluetoothStateReceiver,
-            CallAudioRouteStateMachine.Factory callAudioRouteStateMachineFactory,
+            CallAudioRouteController.Factory audioRouteControllerFactory,
             CallAudioModeStateMachine.Factory callAudioModeStateMachineFactory,
             InCallControllerFactory inCallControllerFactory,
             CallDiagnosticServiceController callDiagnosticServiceController,
@@ -664,7 +663,8 @@ public class CallsManager extends Call.ListenerBase
             FeatureFlags featureFlags,
             com.android.internal.telephony.flags.FeatureFlags telephonyFlags,
             IncomingCallFilterGraphProvider incomingCallFilterGraphProvider,
-            TelecomMetricsController metricsController) {
+            TelecomMetricsController metricsController,
+            Ringer.VibratorAdapter vibratorAdapter) {
 
         mContext = context;
         mLock = lock;
@@ -672,7 +672,8 @@ public class CallsManager extends Call.ListenerBase
         mPhoneAccountRegistrar = phoneAccountRegistrar;
         mPhoneAccountRegistrar.addListener(mPhoneAccountListener);
         mMissedCallNotifier = missedCallNotifier;
-        mDisconnectedCallNotifier = disconnectedCallNotifierFactory.create(mContext, this);
+        mDisconnectedCallNotifier = disconnectedCallNotifierFactory.create(mContext, this,
+                featureFlags);
         StatusBarNotifier statusBarNotifier = new StatusBarNotifier(context, this);
         mWiredHeadsetManager = wiredHeadsetManager;
         mSystemStateHelper = systemStateHelper;
@@ -684,59 +685,37 @@ public class CallsManager extends Call.ListenerBase
         mCallerInfoLookupHelper = callerInfoLookupHelper;
         mEmergencyCallDiagnosticLogger = emergencyCallDiagnosticLogger;
         mIncomingCallFilterGraphProvider = incomingCallFilterGraphProvider;
-        if (featureFlags.enableCallAudioWatchdog()) {
-            mHandlerThread.start();
-            mAudioCallbackHandler = new Handler(mHandlerThread.getLooper());
-            mCallAudioWatchDog = new CallAudioWatchdog(
-                    mContext.getSystemService(AudioManager.class),
-                    new CallAudioWatchdog.PhoneAccountRegistrarProxy() {
-                        @Override
-                        public boolean hasPhoneAccountForUid(int uid) {
-                            return mPhoneAccountRegistrar.hasPhoneAccountForUid(uid);
-                        }
 
-                        @Override
-                        public int getUidForPhoneAccountHandle(PhoneAccountHandle handle) {
-                            Context userContext = mContext.createContextAsUser(
-                                    handle.getUserHandle(),
-                                    0 /*flags */);
-                            try {
-                                return userContext.getPackageManager().getPackageUid(
-                                        handle.getComponentName().getPackageName(), 0 /* flags */);
-                            } catch (NameNotFoundException nfe) {
-                                return -1;
-                            }
+        mHandlerThread.start();
+        mAudioCallbackHandler = new Handler(mHandlerThread.getLooper());
+        mCallAudioWatchDog = new CallAudioWatchdog(
+                mContext.getSystemService(AudioManager.class),
+                new CallAudioWatchdog.PhoneAccountRegistrarProxy() {
+                    @Override
+                    public boolean hasPhoneAccountForUid(int uid) {
+                        return mPhoneAccountRegistrar.hasPhoneAccountForUid(uid);
+                    }
+
+                    @Override
+                    public int getUidForPhoneAccountHandle(PhoneAccountHandle handle) {
+                        Context userContext = mContext.createContextAsUser(
+                                handle.getUserHandle(),
+                                0 /*flags */);
+                        try {
+                            return userContext.getPackageManager().getPackageUid(
+                                    handle.getComponentName().getPackageName(), 0 /* flags */);
+                        } catch (NameNotFoundException nfe) {
+                            return -1;
                         }
-                    }, clockProxy, mAudioCallbackHandler,
-                    featureFlags.telecomMetricsSupport() ? metricsController : null);
-        } else {
-            mAudioCallbackHandler = null;
-            mCallAudioWatchDog = null;
-        }
+                    }
+                }, clockProxy, mAudioCallbackHandler,
+                featureFlags.telecomMetricsSupport() ? metricsController : null);
 
         mDtmfLocalTonePlayer =
-                new DtmfLocalTonePlayer(new DtmfLocalTonePlayer.ToneGeneratorProxy());
-        // TODO: add another flag check when
-        // bluetoothDeviceManager.getBluetoothHeadset().isScoManagedByAudio()
-        // available and return true
-        if (!featureFlags.useRefactoredAudioRouteSwitching()) {
-            mCallAudioRouteAdapter = callAudioRouteStateMachineFactory.create(
-                    context,
-                    this,
-                    bluetoothManager,
-                    wiredHeadsetManager,
-                    statusBarNotifier,
-                    audioServiceFactory,
-                    CallAudioRouteStateMachine.EARPIECE_AUTO_DETECT,
-                    asyncCallAudioTaskExecutor,
-                    communicationDeviceTracker,
-                    featureFlags
-            );
-        } else {
-            mCallAudioRouteAdapter = new CallAudioRouteController(context, this,
-                    audioServiceFactory, new AudioRoute.Factory(), wiredHeadsetManager,
-                    mBluetoothRouteManager, statusBarNotifier, featureFlags, metricsController);
-        }
+                new DtmfLocalTonePlayer(new DtmfLocalTonePlayer.ToneGeneratorProxy(), featureFlags);
+        mCallAudioRouteAdapter = audioRouteControllerFactory.create(context, this,
+                audioServiceFactory, new AudioRoute.Factory(), wiredHeadsetManager,
+                mBluetoothRouteManager, statusBarNotifier, featureFlags, metricsController);
         mCallAudioRouteAdapter.initialize();
         bluetoothStateReceiver.setCallAudioRouteAdapter(mCallAudioRouteAdapter);
         bluetoothDeviceManager.setCallAudioRouteAdapter(mCallAudioRouteAdapter);
@@ -749,11 +728,17 @@ public class CallsManager extends Call.ListenerBase
                         mDockManager,
                         asyncRingtonePlayer);
         AudioManager audioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
-        InCallTonePlayer.MediaPlayerFactory mediaPlayerFactory =
-                (resourceId, attributes) ->
-                        new InCallTonePlayer.MediaPlayerAdapterImpl(
-                                MediaPlayer.create(mContext, resourceId, attributes,
-                                        audioManager.generateAudioSessionId()));
+        InCallTonePlayer.MediaPlayerFactory mediaPlayerFactory = (resourceId, attributes) -> {
+          MediaPlayer mediaPlayer;
+          try {
+            mediaPlayer = MediaPlayer.create(
+                mContext, resourceId, attributes, audioManager.generateAudioSessionId());
+          } catch (IllegalStateException e) {
+            Log.e(TAG, e, "Failed to create mediaplayer");
+            mediaPlayer = null;
+          }
+          return new InCallTonePlayer.MediaPlayerAdapterImpl(mediaPlayer);
+        };
         InCallTonePlayer.Factory playerFactory = new InCallTonePlayer.Factory(
                 callAudioRoutePeripheralAdapter, lock, toneGeneratorFactory, mediaPlayerFactory,
                 () -> audioManager.getStreamVolume(AudioManager.STREAM_RING) > 0, featureFlags,
@@ -761,24 +746,26 @@ public class CallsManager extends Call.ListenerBase
 
         SystemSettingsUtil systemSettingsUtil = new SystemSettingsUtil();
         RingtoneFactory ringtoneFactory = new RingtoneFactory(this, context, featureFlags);
-        SystemVibrator systemVibrator = new SystemVibrator(context);
+
         mInCallController = inCallControllerFactory.create(context, mLock, this,
                 systemStateHelper, defaultDialerCache, mTimeoutsAdapter,
                 emergencyCallHelper);
         mCallEndpointController = callEndpointControllerFactory.create(context, mLock, this);
         mCallDiagnosticServiceController = callDiagnosticServiceController;
         mCallDiagnosticServiceController.setInCallTonePlayerFactory(playerFactory);
+        mCallConnectedIndicatorSettings = new CallConnectedIndicatorSettings(context, featureFlags);
         mRinger = new Ringer(playerFactory, context, systemSettingsUtil, asyncRingtonePlayer,
-                ringtoneFactory, systemVibrator,
+                ringtoneFactory, vibratorAdapter,
                 new Ringer.VibrationEffectProxy(), mInCallController,
                 mContext.getSystemService(NotificationManager.class),
-                accessibilityManagerAdapter, featureFlags, mAnomalyReporter);
+                accessibilityManagerAdapter, featureFlags, mAnomalyReporter,
+                mCallConnectedIndicatorSettings, asyncTaskExecutor);
         if (featureFlags.telecomResolveHiddenDependencies()) {
             // This is now deprecated
             mCallRecordingTonePlayer = null;
         } else {
             mCallRecordingTonePlayer = new CallRecordingTonePlayer(mContext, audioManager,
-                    mTimeoutsAdapter, mLock);
+                    mTimeoutsAdapter, mLock, featureFlags);
         }
         mCallAudioManager = new CallAudioManager(mCallAudioRouteAdapter,
                 this, callAudioModeStateMachineFactory.create(systemStateHelper,
@@ -789,7 +776,7 @@ public class CallsManager extends Call.ListenerBase
 
         mConnectionSvrFocusMgr = connectionServiceFocusManagerFactory.create(mRequester);
         mHeadsetMediaButton = headsetMediaButtonFactory.create(context, this, mLock);
-        mTtyManager = new TtyManager(context, mWiredHeadsetManager);
+        mTtyManager = new TtyManager(context, mWiredHeadsetManager, featureFlags);
         mProximitySensorManager = proximitySensorManagerFactory.create(context, this);
         mPhoneStateBroadcaster = new PhoneStateBroadcaster(this);
         mCallLogManager = new CallLogManager(context, phoneAccountRegistrar, mMissedCallNotifier,
@@ -806,16 +793,10 @@ public class CallsManager extends Call.ListenerBase
         mCallStreamingController = new CallStreamingController(mContext, mLock);
         mCallStreamingNotification = callStreamingNotification;
         mFeatureFlags = featureFlags;
-        if (mFeatureFlags.voipCallMonitorRefactor()) {
-            mVoipCallMonitor = new VoipCallMonitor(
-                    mContext,
-                    new Handler(Looper.getMainLooper()),
-                    mLock);
-            mVoipCallMonitorLegacy = null;
-        } else {
-            mVoipCallMonitor = null;
-            mVoipCallMonitorLegacy = new VoipCallMonitorLegacy(mContext, mLock);
-        }
+        mVoipCallMonitor = new VoipCallMonitor(
+                mContext,
+                new Handler(Looper.getMainLooper()),
+                mLock);
         mTelephonyFeatureFlags = telephonyFlags;
         mMetricsController = metricsController;
         mBlockedNumbersManager = mFeatureFlags.telecomMainlineBlockedNumbersManager()
@@ -824,17 +805,12 @@ public class CallsManager extends Call.ListenerBase
         mCallSequencingAdapter = new CallsManagerCallSequencingAdapter(this, mContext,
                 new CallSequencingController(this, mContext, mClockProxy,
                         mAnomalyReporter, mTimeoutsAdapter, mMetricsController, mMmiUtils,
-                        mFeatureFlags), mCallAudioManager, mFeatureFlags);
+                        mFeatureFlags), mCallAudioManager, mMetricsController, mFeatureFlags);
 
-        if (mFeatureFlags.useImprovedListenerOrder()) {
-            mListeners.add(mInCallController);
-        }
+        mListeners.add(mInCallController);
         mListeners.add(mInCallWakeLockController);
         mListeners.add(statusBarNotifier);
         mListeners.add(mCallLogManager);
-        if (!mFeatureFlags.useImprovedListenerOrder()) {
-            mListeners.add(mInCallController);
-        }
         mListeners.add(mCallEndpointController);
         mListeners.add(mCallDiagnosticServiceController);
         mListeners.add(mCallAudioManager);
@@ -853,17 +829,10 @@ public class CallsManager extends Call.ListenerBase
         // this needs to be after the mCallAudioManager
         mListeners.add(mPhoneStateBroadcaster);
         mListeners.add(mCallStreamingNotification);
-        if (featureFlags.enableCallAudioWatchdog()) {
-            mListeners.add(mCallAudioWatchDog);
-        }
+        mListeners.add(mCallAudioWatchDog);
 
-        if (mFeatureFlags.voipCallMonitorRefactor()) {
-            mVoipCallMonitor.registerNotificationListener();
-            mListeners.add(mVoipCallMonitor);
-        } else {
-            mVoipCallMonitorLegacy.startMonitor();
-            mListeners.add(mVoipCallMonitorLegacy);
-        }
+        mVoipCallMonitor.registerNotificationListener();
+        mListeners.add(mVoipCallMonitor);
 
         // There is no USER_SWITCHED broadcast for user 0, handle it here explicitly.
         final UserManager userManager = mContext.getSystemService(UserManager.class);
@@ -924,10 +893,6 @@ public class CallsManager extends Call.ListenerBase
         call.setPostCallPackageName(getRoleManagerAdapter().getDefaultCallScreeningApp(
                 call.getAssociatedUser()));
 
-        if (!mFeatureFlags.fixAudioFlickerForOutgoingCalls()) {
-            setCallState(call, callState, "successful outgoing call");
-        }
-
         if (!mCalls.contains(call)) {
             // Call was not added previously in startOutgoingCall due to it being a potential MMI
             // code, so add it now.
@@ -939,16 +904,11 @@ public class CallsManager extends Call.ListenerBase
             listener.onConnectionServiceChanged(call, null, call.getConnectionService());
         }
 
-        if (mFeatureFlags.fixAudioFlickerForOutgoingCalls()) {
-            // Allow the ConnectionService to start the call in the active state. This case is
-            // helpful for conference calls or meetings that can skip the dialing stage.
-            if (callState == CallState.ACTIVE) {
-                setCallState(call, callState, "skipping the dialing state and setting active");
-            } else {
-                markCallAsDialing(call);
-            }
-        }
-        else{
+        // Allow the ConnectionService to start the call in the active state. This case is
+        // helpful for conference calls or meetings that can skip the dialing stage.
+        if (callState == CallState.ACTIVE) {
+            setCallState(call, callState, "skipping the dialing state and setting active");
+        } else {
             markCallAsDialing(call);
         }
     }
@@ -1041,18 +1001,18 @@ public class CallsManager extends Call.ListenerBase
         CallScreeningServiceFilter carrierCallScreeningServiceFilter =
                 new CallScreeningServiceFilter(incomingCall, carrierPackageName,
                         CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, this,
-                        appLabelProxy, converter);
+                        appLabelProxy, converter, mFeatureFlags);
         CallScreeningServiceFilter callScreeningServiceFilter;
         if ((userChosenPackageName != null)
                 && (!userChosenPackageName.equals(defaultDialerPackageName))) {
             callScreeningServiceFilter = new CallScreeningServiceFilter(incomingCall,
                     userChosenPackageName, CallScreeningServiceFilter.PACKAGE_TYPE_USER_CHOSEN,
-                    mContext, this, appLabelProxy, converter);
+                    mContext, this, appLabelProxy, converter, mFeatureFlags);
         } else {
             callScreeningServiceFilter = new CallScreeningServiceFilter(incomingCall,
                     defaultDialerPackageName,
                     CallScreeningServiceFilter.PACKAGE_TYPE_DEFAULT_DIALER,
-                    mContext, this, appLabelProxy, converter);
+                    mContext, this, appLabelProxy, converter, mFeatureFlags);
         }
         graph.addFilter(voicemailFilter);
         graph.addFilter(dndCallFilter);
@@ -1095,19 +1055,23 @@ public class CallsManager extends Call.ListenerBase
             incomingCall.setUserMissed(USER_MISSED_CALL_FILTERS_TIMEOUT);
         }
 
-        if (incomingCall.getState() != CallState.DISCONNECTED &&
-                incomingCall.getState() != CallState.DISCONNECTING) {
-            if (!mFeatureFlags.separatelyBindToBtIncallService()) {
-                setCallState(incomingCall, CallState.RINGING,
-                        result.shouldAllowCall ? "successful incoming call" : "blocking call");
-            }
-        } else {
+        if (incomingCall.getState() == CallState.DISCONNECTED ||
+                incomingCall.getState() == CallState.DISCONNECTING) {
             Log.i(this, "onCallFilteringCompleted: call already disconnected.");
             return;
         }
 
         // Store the shouldSuppress value in the call object which will be passed to InCallServices
-        incomingCall.setCallIsSuppressedByDoNotDisturb(result.shouldSuppressCallDueToDndStatus);
+        if (mFeatureFlags.voipDndFocus()) {
+            // The DND call filter may not have run (e.g. for VoIP calls); in this case we should
+            // not set the DND suppression on the call to ensure Ringer.java will recalculate this
+            // and not try to use an invalid cached value.
+            if (result.isDndSuppressionDetermined()) {
+                incomingCall.setCallIsSuppressedByDoNotDisturb(result.shouldSuppressDueToDnd());
+            }
+        } else {
+            incomingCall.setCallIsSuppressedByDoNotDisturb(result.shouldSuppressCallDueToDndStatus);
+        }
 
         // Inform our connection service that call filtering is done (if it was performed at all).
         if (incomingCall.isUsingCallFiltering()) {
@@ -1145,11 +1109,9 @@ public class CallsManager extends Call.ListenerBase
         }
 
         if (result.shouldAllowCall) {
-            if (mFeatureFlags.separatelyBindToBtIncallService()) {
-                mInCallController.bindToBTService(incomingCall, null);
-                incomingCall.setBtIcsFuture(mInCallController.getBtBindingFuture(incomingCall));
-                setCallState(incomingCall, CallState.RINGING, "successful incoming call");
-            }
+            mInCallController.bindToBTService(incomingCall, null);
+            incomingCall.setBtIcsFuture(mInCallController.getBtBindingFuture(incomingCall));
+            setCallState(incomingCall, CallState.RINGING, "successful incoming call");
             incomingCall.setPostCallPackageName(
                     getRoleManagerAdapter().getDefaultCallScreeningApp(
                             incomingCall.getAssociatedUser()
@@ -1191,9 +1153,7 @@ public class CallsManager extends Call.ListenerBase
         } else {
             if (result.shouldReject) {
                 Log.i(this, "onCallFilteringCompleted: blocked call, rejecting.");
-                if (mFeatureFlags.separatelyBindToBtIncallService()) {
-                    setCallState(incomingCall, CallState.RINGING, "blocking call");
-                }
+                setCallState(incomingCall, CallState.RINGING, "blocking call");
                 incomingCall.reject(false, null);
             }
             if (result.shouldAddToCallLog) {
@@ -1201,7 +1161,7 @@ public class CallsManager extends Call.ListenerBase
                 if (result.shouldShowNotification) {
                     Log.w(this, "onCallScreeningCompleted: blocked call, showing notification.");
                 }
-                mCallLogManager.logCall(incomingCall, Calls.BLOCKED_TYPE,
+                mCallLogManager.logCallIfNotSelfManaged(incomingCall, Calls.BLOCKED_TYPE,
                         result.shouldShowNotification, result);
             }
             if (result.shouldShowNotification) {
@@ -1296,7 +1256,7 @@ public class CallsManager extends Call.ListenerBase
                 }
             };
             mHandler.postDelayed(mStopTone.prepare(),
-                    Timeouts.getDelayBetweenDtmfTonesMillis(mContext.getContentResolver()));
+                    Timeouts.getDelayBetweenDtmfTonesMillis(mContext, mFeatureFlags));
         } else if (nextChar == 0 || nextChar == TelecomManager.DTMF_CHARACTER_WAIT ||
                 nextChar == TelecomManager.DTMF_CHARACTER_PAUSE) {
             // Stop the tone if a tone is playing, removing any other stopTone callbacks since
@@ -1682,7 +1642,6 @@ public class CallsManager extends Call.ListenerBase
             }
             // Incoming address was set via EXTRA_INCOMING_CALL_ADDRESS above.
             UserHandle associatedUser = UserUtil.getAssociatedUserForCall(
-                    mFeatureFlags.associatedUserRefactorForWorkProfile(),
                     getPhoneAccountRegistrar(), getCurrentUserHandle(), phoneAccountHandle);
             call.setAssociatedUser(associatedUser);
         }
@@ -1807,6 +1766,24 @@ public class CallsManager extends Call.ListenerBase
                     : mUserManager.isQuietModeEnabled(call.getAssociatedUser());
         }
 
+        boolean ignoreIncomingCallFailureOnSameNumber = false;
+        if (hasMaximumManagedRingingCalls(call)) {
+            Call ringingCall = getRingingOrSimulatedRingingCall();
+            PhoneAccountHandle connectionMgr = mPhoneAccountRegistrar.getSimCallManagerFromCall(
+                    call);
+            // Check if the new incoming call is using the same connection mgr with the already
+            // tracked ringing call. This can happen in a scenario where two incoming calls are
+            // received on Fi: one from Tycho (over WiFi) and from Telephony via the mobile network.
+            // In this case, we should allow the new call to go through instead of failing it and
+            // logging it. We are refraining from doing a phone number check as it's possible that
+            // Fi is using shadow numbers.
+            if (mFeatureFlags.allowCallOnSameConnectionMgr() && ringingCall != null
+                    && connectionMgr != null && Objects.equals(connectionMgr,
+                    ringingCall.getConnectionManagerPhoneAccount())) {
+                ignoreIncomingCallFailureOnSameNumber = true;
+            }
+        }
+
         // We should always allow emergency calls and also allow non-emergency calls when ECBM
         // is active for the phone account.
         if (isCallHiddenFromProfile && !call.isEmergencyCall() && !call.isInECBM()) {
@@ -1828,7 +1805,7 @@ public class CallsManager extends Call.ListenerBase
                 if (hasMaximumManagedRingingCalls(call)) {
                     call.setMissedReason(AUTO_MISSED_MAXIMUM_RINGING);
                     call.setStartFailCause(CallFailureCause.MAX_RINGING_CALLS);
-                    mCallLogManager.logCall(call, Calls.MISSED_TYPE,
+                    mCallLogManager.logCallIfNotSelfManaged(call, Calls.MISSED_TYPE,
                             true /*showNotificationForMissedCall*/, null /*CallFilteringResult*/);
                 }
                 call.setStartFailCause(startFailCause);
@@ -1841,15 +1818,22 @@ public class CallsManager extends Call.ListenerBase
             call.setMissedReason(AUTO_MISSED_EMERGENCY_CALL);
             call.getAnalytics().setMissedReason(call.getMissedReason());
             call.setStartFailCause(CallFailureCause.IN_EMERGENCY_CALL);
-            mCallLogManager.logCall(call, Calls.MISSED_TYPE,
+            mCallLogManager.logCallIfNotSelfManaged(call, Calls.MISSED_TYPE,
                     true /*showNotificationForMissedCall*/, null /*CallFilteringResult*/);
             if (isConference) {
                 notifyCreateConferenceFailed(phoneAccountHandle, call);
             } else {
                 notifyCreateConnectionFailed(phoneAccountHandle, call);
             }
-        } else if (mFeatureFlags.enableCallSequencing() && (hasMaximumManagedRingingCalls(call)
-                || hasMaximumManagedDialingCalls(call))) {
+        } else if (mFeatureFlags.enableCallSequencing()
+                && ((hasMaximumManagedRingingCalls(call) && !CallSequencingController
+                .arePhoneAccountsSame(getRingingOrSimulatedRingingCall(), call)
+                && !ignoreIncomingCallFailureOnSameNumber)
+                || (hasMaximumManagedDialingCalls(call)
+                && !CallSequencingController.arePhoneAccountsSame(getDialingCall(), call)))) {
+            // Only perform this when the calls are on different phone accounts. Otherwise, let
+            // Telephony handle the rejection logic.
+
             // Fail incoming call if there's already a ringing or dialing call present.
             boolean maxRinging = hasMaximumManagedRingingCalls(call);
             if (maxRinging) {
@@ -1859,7 +1843,7 @@ public class CallsManager extends Call.ListenerBase
                 call.setMissedReason(AUTO_MISSED_MAXIMUM_DIALING);
             }
             call.getAnalytics().setMissedReason(call.getMissedReason());
-            mCallLogManager.logCall(call, Calls.MISSED_TYPE,
+            mCallLogManager.logCallIfNotSelfManaged(call, Calls.MISSED_TYPE,
                     true /*showNotificationForMissedCall*/, null /*CallFilteringResult*/);
             if (isConference) {
                 notifyCreateConferenceFailed(phoneAccountHandle, call);
@@ -1925,7 +1909,6 @@ public class CallsManager extends Call.ListenerBase
 
         // For unknown calls, base the associated user off of the target phone account handle.
         UserHandle associatedUser = UserUtil.getAssociatedUserForCall(
-                mFeatureFlags.associatedUserRefactorForWorkProfile(),
                 getPhoneAccountRegistrar(), getCurrentUserHandle(), phoneAccountHandle);
         call.setAssociatedUser(associatedUser);
         setIntentExtrasAndStartTime(call, extras);
@@ -2235,9 +2218,14 @@ public class CallsManager extends Call.ListenerBase
                     }
                     Context userContext = mContext.createContextAsUser(getCurrentUserHandle(), 0);
                     return PhoneAccountSuggestionHelper.bindAndGetSuggestions(userContext,
-                            finalCall.getHandle(), potentialPhoneAccounts);
+                            finalCall.getHandle(), potentialPhoneAccounts, mFeatureFlags);
                 }, new LoggedHandlerExecutor(outgoingCallHandler, "CM.cOCSS", mLock));
 
+        if (mFeatureFlags.selectPhoneAccountBeforeMakingRoom()) {
+            return selectOutgoingPhoneAccount(finalCall, handle, originalIntent, initiatingUser,
+                    extras, isSelfManaged,isReusedCall, isConference, outgoingCallHandler,
+                    setAccountHandle, suggestionFuture);
+        }
 
         // This future checks the status of existing calls and attempts to make room for the
         // outgoing call.
@@ -2449,16 +2437,34 @@ public class CallsManager extends Call.ListenerBase
                                     "needs account selection");
                             // Create our own instance to modify (since extras may be Bundle.EMPTY)
                             Bundle newExtras = new Bundle(extras);
-                            List<PhoneAccountHandle> accountsFromSuggestions = accountSuggestions
-                                    .stream()
-                                    .map(PhoneAccountSuggestion::getPhoneAccountHandle)
-                                    .collect(Collectors.toList());
-                            newExtras.putParcelableList(
-                                    android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS,
-                                    accountsFromSuggestions);
-                            newExtras.putParcelableList(
-                                    android.telecom.Call.EXTRA_SUGGESTED_PHONE_ACCOUNTS,
-                                    accountSuggestions);
+                            if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                                ArrayList<PhoneAccountHandle> accountsFromSuggestions =
+                                        accountSuggestions
+                                                .stream()
+                                                .map(PhoneAccountSuggestion::getPhoneAccountHandle)
+                                                .collect(Collectors.toCollection(ArrayList::new));
+                                newExtras.putParcelableArrayList(
+                                        android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS,
+                                        accountsFromSuggestions);
+                                ArrayList<PhoneAccountSuggestion> accountSuggestionArrayList =
+                                        new ArrayList<>(accountSuggestions);
+                                newExtras.putParcelableArrayList(
+                                        android.telecom.Call.EXTRA_SUGGESTED_PHONE_ACCOUNTS,
+                                        accountSuggestionArrayList);
+                            } else {
+                                // Legacy path:
+                                List<PhoneAccountHandle> accountsFromSuggestions =
+                                        accountSuggestions
+                                        .stream()
+                                        .map(PhoneAccountSuggestion::getPhoneAccountHandle)
+                                        .collect(Collectors.toList());
+                                newExtras.putParcelableList(
+                                        android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS,
+                                        accountsFromSuggestions);
+                                newExtras.putParcelableList(
+                                        android.telecom.Call.EXTRA_SUGGESTED_PHONE_ACCOUNTS,
+                                        accountSuggestions);
+                            }
                             // Set a future in place so that we can proceed once the dialer replies.
                             mPendingAccountSelection.put(callToPlace.getId(),
                                     new CompletableFuture<>());
@@ -2482,7 +2488,16 @@ public class CallsManager extends Call.ListenerBase
             // CallScreeningService in order for it to potentially provide caller ID.
             dialerSelectPhoneAccountFuture.thenAcceptBothAsync(contactLookupFuture,
                     (callPhoneAccountHandlePair, uriCallerInfoPair) -> {
+                        if (callPhoneAccountHandlePair == null) {
+                            return;
+                        }
                         Call theCall = callPhoneAccountHandlePair.first;
+                        // Other branches building on dialerSelectPhoneAccountFuture do this, so
+                        // we should early return here; if there is no call, then don't bother
+                        // continuing.
+                        if (theCall == null) {
+                            return;
+                        }
                         UserHandle userHandleForCallScreening = theCall.
                                 getAssociatedUser();
                         boolean isInContacts = uriCallerInfoPair.second != null
@@ -2572,6 +2587,400 @@ public class CallsManager extends Call.ListenerBase
         return mLatestPostSelectionProcessingFuture;
     }
 
+    private CompletableFuture<Call> selectOutgoingPhoneAccount(
+            Call finalCall,
+            Uri handle,
+            Intent originalIntent,
+            UserHandle initiatingUser,
+            Bundle extras,
+            boolean isSelfManaged,
+            boolean isReusedCall,
+            boolean isConference,
+            Handler outgoingCallHandler,
+            CompletableFuture<List<PhoneAccountHandle>> setAccountHandle,
+            CompletableFuture<List<PhoneAccountSuggestion>> suggestionFuture
+    ) {
+        CompletableFuture<Call> isCallAllowed = setAccountHandle.thenComposeAsync(
+                _unused -> {
+                    Log.i(CallsManager.this, "is call allowed stage");
+                    if (mMmiUtils.isPotentialInCallMMICode(handle) && !isSelfManaged) {
+                        // We will allow the MMI code if call sequencing is not enabled or there
+                        // are only calls on the same phone account.
+                        boolean shouldAllowMmiCode = mCallSequencingAdapter
+                                .shouldAllowMmiCode(finalCall);
+                        if (shouldAllowMmiCode) {
+                            return CompletableFuture.completedFuture(finalCall);
+                        } else {
+                            // Reject the in-call MMI code.
+                            Log.i(this, "Rejecting the in-call MMI code because there is an "
+                                    + "ongoing call on a different phone account.");
+                            return CompletableFuture.completedFuture(null);
+                        }
+                    }
+                    // If a call is being reused, then it has already passed the
+                    // makeRoomForOutgoingCall check once and will fail the second time due to the
+                    // call transitioning into the CONNECTING state.
+                    if (isReusedCall) {
+                        return CompletableFuture.completedFuture(finalCall);
+                    } else {
+                        Call reusableCall = reuseOutgoingCall(handle);
+                        if (reusableCall != null) {
+                            Log.i(CallsManager.this,
+                                    "reusable call %s came in later; disconnect it.",
+                                    reusableCall.getId());
+                            mPendingCallsToDisconnect.remove(reusableCall);
+                            reusableCall.disconnect();
+                            markCallAsDisconnected(reusableCall,
+                                    new DisconnectCause(DisconnectCause.CANCELED));
+                        }
+                    }
+
+                    if (!finalCall.isEmergencyCall() && isInEmergencyCall()) {
+                        Log.i(CallsManager.this, "Aborting call since there's an"
+                                + " ongoing emergency call");
+                        // If the ongoing call is a managed call, we will prevent the outgoing
+                        // call from dialing.
+                        if (isConference) {
+                            notifyCreateConferenceFailed(finalCall.getTargetPhoneAccount(),
+                                    finalCall);
+                        } else {
+                            notifyCreateConnectionFailed(
+                                    finalCall.getTargetPhoneAccount(), finalCall);
+                        }
+                        finalCall.setStartFailCause(CallFailureCause.IN_EMERGENCY_CALL);
+                        // Show an error message when dialing a MMI code during an emergency call.
+                        if (mMmiUtils.isPotentialMMICode(handle)) {
+                            showErrorMessage(R.string.emergencyCall_reject_mmi);
+                        }
+                        return CompletableFuture.completedFuture(null);
+                    }
+                    return CompletableFuture.completedFuture(finalCall);
+                }, new LoggedHandlerExecutor(outgoingCallHandler, "CM.sOPA.iCA", mLock));
+
+        // The outgoing call can be placed, go forward. This future glues together the results of
+        // the account suggestion stage and the make room for call stage.
+        CompletableFuture<Pair<Call, List<PhoneAccountSuggestion>>> preSelectStage =
+                isCallAllowed.thenCombine(suggestionFuture, Pair::create);
+        mLatestPreAccountSelectionFuture = preSelectStage;
+
+        // This future takes the list of suggested accounts and the call and determines if more
+        // user interaction in the form of a phone account selection screen is needed. If so, it
+        // will set the call to SELECT_PHONE_ACCOUNT, add it to our internal list/send it to dialer,
+        // and then execution will pause pending the dialer calling phoneAccountSelected.
+        CompletableFuture<Pair<Call, PhoneAccountHandle>> dialerSelectPhoneAccountFuture =
+                preSelectStage.thenComposeAsync(
+                        (args) -> {
+                            Log.i(CallsManager.this, "dialer phone acct select stage");
+                            Call callToPlace = args.first;
+                            List<PhoneAccountSuggestion> accountSuggestions = args.second;
+                            if (callToPlace == null) {
+                                return CompletableFuture.completedFuture(null);
+                            }
+                            if (accountSuggestions == null || accountSuggestions.isEmpty()) {
+                                Uri callUri = callToPlace.getHandle();
+                                if (PhoneAccount.SCHEME_TEL.equals(callUri.getScheme())) {
+                                    int managedProfileUserId = getManagedProfileUserId(mContext,
+                                            initiatingUser.getIdentifier(), mFeatureFlags);
+                                    if (managedProfileUserId != UserHandle.USER_NULL
+                                            &&
+                                            mPhoneAccountRegistrar.getCallCapablePhoneAccounts(
+                                                    handle.getScheme(), false,
+                                                    UserHandle.of(managedProfileUserId),
+                                                    false).size()
+                                                    != 0) {
+                                        boolean dialogShown = showSwitchToManagedProfileDialog(
+                                                callUri, initiatingUser, managedProfileUserId);
+                                        if (dialogShown) {
+                                            return CompletableFuture.completedFuture(null);
+                                        }
+                                    }
+                                }
+
+                                Log.i(CallsManager.this, "Aborting call since there are no"
+                                        + " available accounts.");
+                                showErrorMessage(R.string.cant_call_due_to_no_supported_service);
+                                mListeners.forEach(l -> l.onCreateConnectionFailed(callToPlace));
+                                if (callToPlace.isEmergencyCall()) {
+                                    if (mFeatureFlags.telecomMetricsSupport()) {
+                                        mMetricsController.getErrorStats().log(
+                                                ErrorStats.SUB_CALL_MANAGER,
+                                                ErrorStats.ERROR_EMERGENCY_CALL_ABORTED_NO_ACCOUNT);
+                                    }
+                                    mAnomalyReporter.reportAnomaly(
+                                            EMERGENCY_CALL_ABORTED_NO_PHONE_ACCOUNTS_ERROR_UUID,
+                                            EMERGENCY_CALL_ABORTED_NO_PHONE_ACCOUNTS_ERROR_MSG);
+                                }
+                                return CompletableFuture.completedFuture(null);
+                            }
+                            boolean needsAccountSelection = accountSuggestions.size() > 1
+                                    && !callToPlace.isEmergencyCall() && !isSelfManaged;
+                            if (!needsAccountSelection) {
+                                return CompletableFuture.completedFuture(Pair.create(callToPlace,
+                                        accountSuggestions.get(0).getPhoneAccountHandle()));
+                            }
+
+                            // At this point Telecom is requesting the user to select a phone
+                            // account. However, Telephony is reporting that the user has a default
+                            // outgoing account (which is denoted by a non-negative subId number).
+                            // At some point, Telecom and Telephony are out of sync with the default
+                            // outgoing calling account.
+                            if(mFeatureFlags.telephonyHasDefaultButTelecomDoesNot()) {
+                                // SubscriptionManager will throw if FEATURE_TELEPHONY_SUBSCRIPTION
+                                // is not present.
+                                if (mContext.getPackageManager().hasSystemFeature(
+                                        PackageManager.FEATURE_TELEPHONY_SUBSCRIPTION)) {
+                                    if (SubscriptionManager.getDefaultVoiceSubscriptionId() !=
+                                            SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                                        if (mFeatureFlags.telecomMetricsSupport()) {
+                                            mMetricsController.getErrorStats().log(
+                                                    ErrorStats.SUB_CALL_MANAGER,
+                                                    ErrorStats.ERROR_DEFAULT_MO_ACCOUNT_MISMATCH);
+                                        }
+                                        mAnomalyReporter.reportAnomaly(
+                                                TELEPHONY_HAS_DEFAULT_BUT_TELECOM_DOES_NOT_UUID,
+                                                TELEPHONY_HAS_DEFAULT_BUT_TELECOM_DOES_NOT_MSG);
+                                    }
+                                }
+                            }
+
+                            // This is the state where the user is expected to select an account
+                            callToPlace.setState(CallState.SELECT_PHONE_ACCOUNT,
+                                    "needs account selection");
+                            // Create our own instance to modify (since extras may be Bundle.EMPTY)
+                            Bundle newExtras = new Bundle(extras);
+                            if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                                ArrayList<PhoneAccountHandle> accountsFromSuggestions =
+                                        accountSuggestions
+                                                .stream()
+                                                .map(PhoneAccountSuggestion::getPhoneAccountHandle)
+                                                .collect(Collectors.toCollection(ArrayList::new));
+                                newExtras.putParcelableArrayList(
+                                        android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS,
+                                        accountsFromSuggestions);
+                                ArrayList<PhoneAccountSuggestion> accountSuggestionArrayList =
+                                        new ArrayList<>(accountSuggestions);
+                                newExtras.putParcelableArrayList(
+                                        android.telecom.Call.EXTRA_SUGGESTED_PHONE_ACCOUNTS,
+                                        accountSuggestionArrayList);
+                            } else {
+                                // Legacy path:
+                                List<PhoneAccountHandle> accountsFromSuggestions =
+                                        accountSuggestions
+                                                .stream()
+                                                .map(PhoneAccountSuggestion::getPhoneAccountHandle)
+                                                .collect(Collectors.toList());
+                                newExtras.putParcelableList(
+                                        android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS,
+                                        accountsFromSuggestions);
+                                newExtras.putParcelableList(
+                                        android.telecom.Call.EXTRA_SUGGESTED_PHONE_ACCOUNTS,
+                                        accountSuggestions);
+                            }
+                            // Set a future in place so that we can proceed once the dialer replies.
+                            mPendingAccountSelection.put(callToPlace.getId(),
+                                    new CompletableFuture<>());
+                            callToPlace.setIntentExtras(newExtras);
+
+                            addCall(callToPlace);
+                            return mPendingAccountSelection.get(callToPlace.getId());
+                        }, new LoggedHandlerExecutor(outgoingCallHandler, "CM.dSPA", mLock));
+
+        // This future checks the status of existing calls and attempts to make room for the
+        // outgoing call.
+        CompletableFuture<Pair<PhoneAccountHandle, Boolean>> makeRoomForCall =
+                dialerSelectPhoneAccountFuture.thenComposeAsync(potentialCallAttr -> {
+                    Call callToPlace = potentialCallAttr.first;
+                    PhoneAccountHandle callHandle = potentialCallAttr.second;
+                    if (callToPlace == null) {
+                        // If there's no call to place, complete with null.
+                        // This is a CompletionStage<Call> with a null Call.
+                        return CompletableFuture.completedFuture(null);
+                    }
+
+                    // Make sure we set the PhoneAccount before making room
+                    callToPlace.setTargetPhoneAccount(callHandle);
+
+                    return mCallSequencingAdapter.makeRoomForOutgoingCall(
+                                    callToPlace.isEmergencyCall(), callToPlace)
+                            .exceptionally(throwable -> {
+                                if (throwable != null) {
+                                    Log.w(CallsManager.this,
+                                            "Exception thrown in makeRoomForOutgoingCall, "
+                                                    + "returning false. Ex:" + throwable);
+                                }
+                                // If an exception occurred, treat it as if no room could be made.
+                                return false;
+                            })
+                            .thenApply(isRoomMade -> new Pair<>(callHandle, isRoomMade));
+                },
+                new LoggedHandlerExecutor(outgoingCallHandler, "CM.dMRFC", mLock)
+        );
+
+        // The future returned by the inner method will usually be pre-completed --
+        // we only pause here if user interaction is required to disconnect a self-managed call.
+        // It runs after the account handle is set, independently of the phone account suggestion
+        // future.
+        CompletableFuture<Pair<Call, PhoneAccountHandle>> makeRoomSelfManagedConfirmation =
+                makeRoomForCall.thenComposeAsync((callAttr) -> {
+                    if (callAttr == null) {
+                        return CompletableFuture.completedFuture(null);
+                    }
+                    PhoneAccountHandle callHandle = callAttr.first;
+                    boolean isRoom = callAttr.second;
+                    // If we have an ongoing emergency call, we would have already notified
+                    // connection failure for the new call being placed. Catch this so we don't
+                    // resend it again.
+                    boolean hasOngoingEmergencyCall = !finalCall.isEmergencyCall()
+                            && isInEmergencyCall();
+                    if (isRoom) {
+                        return CompletableFuture.completedFuture(new Pair<>(finalCall, callHandle));
+                    } else if (hasOngoingEmergencyCall) {
+                        return CompletableFuture.completedFuture(null);
+                    }
+                    Call foregroundCall = getForegroundCall();
+                    Log.d(CallsManager.this, "No more room for outgoing call %s ",
+                            finalCall);
+                    if (foregroundCall.isSelfManaged()) {
+                        // If the ongoing call is a self-managed call, then prompt the
+                        // user to ask if they'd like to disconnect their ongoing call
+                        // and place the outgoing call.
+                        Log.i(CallsManager.this, "Prompting user to disconnect "
+                                + "self-managed call");
+                        finalCall.setOriginalCallIntent(originalIntent);
+                        CompletableFuture<Call> completionFuture =
+                                new CompletableFuture<>();
+                        startCallConfirmation(finalCall, completionFuture);
+                        return completionFuture.thenApply(
+                                completedCall -> completedCall != null
+                                        ? new Pair<>(completedCall, callHandle) : null);
+                    } else {
+                        // If the ongoing call is a managed call, we will prevent the
+                        // outgoing call from dialing.
+                        if (isConference) {
+                            notifyCreateConferenceFailed(
+                                    finalCall.getTargetPhoneAccount(),
+                                    finalCall);
+                        } else {
+                            notifyCreateConnectionFailed(
+                                    finalCall.getTargetPhoneAccount(), finalCall);
+                        }
+                    }
+                    Log.i(CallsManager.this,  "Aborting call since there's no room");
+                    return CompletableFuture.completedFuture(null);
+                }, new LoggedHandlerExecutor(outgoingCallHandler, "CM.mROC", mLock));
+
+        // Potentially perform call identification for dialed TEL scheme numbers.
+        if (PhoneAccount.SCHEME_TEL.equals(handle.getScheme())) {
+            // Perform an asynchronous contacts lookup in this stage; ensure post-dial digits are
+            // not included.
+            CompletableFuture<Pair<Uri, CallerInfo>> contactLookupFuture =
+                    mCallerInfoLookupHelper.startLookup(Uri.fromParts(handle.getScheme(),
+                            PhoneNumberUtils.extractNetworkPortion(handle.getSchemeSpecificPart()),
+                            null));
+
+            // Once the phone account selection stage has completed, we can handle the results from
+            // that with the contacts lookup in order to determine if we should lookup bind to the
+            // CallScreeningService in order for it to potentially provide caller ID.
+            makeRoomSelfManagedConfirmation.thenAcceptBothAsync(contactLookupFuture,
+                    (callPhoneAccountHandlePair, uriCallerInfoPair) -> {
+                        if (callPhoneAccountHandlePair == null) {
+                            return;
+                        }
+                        Call theCall = callPhoneAccountHandlePair.first;
+                        // Other branches building on dialerSelectPhoneAccountFuture do this, so
+                        // we should early return here; if there is no call, then don't bother
+                        // continuing.
+                        if (theCall == null) {
+                            return;
+                        }
+                        UserHandle userHandleForCallScreening = theCall.
+                                getAssociatedUser();
+                        boolean isInContacts = uriCallerInfoPair.second != null
+                                && uriCallerInfoPair.second.contactExists;
+                        Log.d(CallsManager.this, "outgoingCallIdStage: isInContacts=%s",
+                                isInContacts);
+
+                        // We only want to provide a CallScreeningService with a call if it's not in
+                        // contacts or the package has READ_CONTACT permission.
+                        PackageManager packageManager = mContext.getPackageManager();
+                        int permission = packageManager.checkPermission(
+                                Manifest.permission.READ_CONTACTS,
+                                mRoleManagerAdapter.
+                                        getDefaultCallScreeningApp(userHandleForCallScreening));
+                        Log.d(CallsManager.this,
+                                "default call screening service package %s has permissions=%s",
+                                mRoleManagerAdapter.
+                                        getDefaultCallScreeningApp(userHandleForCallScreening),
+                                permission == PackageManager.PERMISSION_GRANTED);
+                        if ((!isInContacts) || (permission == PackageManager.PERMISSION_GRANTED)) {
+                            bindForOutgoingCallerId(theCall);
+                        }
+                    }, new LoggedHandlerExecutor(outgoingCallHandler, "CM.pCSB", mLock));
+        }
+
+        // Finally, after all user interaction is complete, we execute this code to finish setting
+        // up the outgoing call. The inner method always returns a completed future containing the
+        // call that we've finished setting up.
+        mLatestPostSelectionProcessingFuture = makeRoomSelfManagedConfirmation
+                .thenComposeAsync(args -> {
+                    if (args == null) {
+                        return CompletableFuture.completedFuture(null);
+                    }
+                    Log.i(CallsManager.this, "post acct selection stage");
+                    Call callToUse = args.first;
+                    PhoneAccountHandle phoneAccountHandle = args.second;
+                    PhoneAccount accountToUse = mPhoneAccountRegistrar
+                            .getPhoneAccount(phoneAccountHandle, initiatingUser);
+                    if (accountToUse != null && accountToUse.getExtras() != null) {
+                        if (accountToUse.getExtras()
+                                .getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
+                            Log.d(this, "startOutgoingCall: defaulting to voip mode for call %s",
+                                    callToUse.getId());
+                            callToUse.setIsVoipAudioMode(true);
+                        }
+                    }
+
+                    callToUse.setState(
+                            CallState.CONNECTING,
+                            phoneAccountHandle == null ? "no-handle"
+                                    : phoneAccountHandle.toString());
+
+                    boolean isVoicemail = isVoicemail(callToUse.getHandle(), accountToUse);
+
+                    boolean isRttSettingOn = isRttSettingOn(phoneAccountHandle);
+                    if (!isVoicemail && (isRttSettingOn || (extras != null
+                            && extras.getBoolean(TelecomManager.EXTRA_START_CALL_WITH_RTT,
+                            false)))) {
+                        Log.d(this, "Outgoing call requesting RTT, rtt setting is %b",
+                                isRttSettingOn);
+                        if (callToUse.isEmergencyCall() || (accountToUse != null
+                                && accountToUse.hasCapabilities(PhoneAccount.CAPABILITY_RTT))) {
+                            // If the call requested RTT and it's an emergency call, ignore the
+                            // capability and hope that the modem will deal with it somehow.
+                            callToUse.createRttStreams();
+                        }
+                        // Even if the phone account doesn't support RTT yet,
+                        // the connection manager might change that. Set this to check it later.
+                        callToUse.setRequestedToStartWithRtt();
+                    }
+
+                    setIntentExtrasAndStartTime(callToUse, extras);
+                    setCallSourceToAnalytics(callToUse, originalIntent);
+
+                    if (mMmiUtils.isPotentialMMICode(handle) && !isSelfManaged) {
+                        // Do not add the call if it is a potential MMI code.
+                        callToUse.addListener(this);
+                    } else if (!mCalls.contains(callToUse)) {
+                        // We check if mCalls already contains the call because we could
+                        // potentially be reusing
+                        // a call which was previously added (See {@link #reuseOutgoingCall}).
+                        addCall(callToUse);
+                    }
+                    return CompletableFuture.completedFuture(callToUse);
+                }, new LoggedHandlerExecutor(outgoingCallHandler, "CM.pASP", mLock));
+        return mLatestPostSelectionProcessingFuture;
+    }
+
     private static int getManagedProfileUserId(Context context, int userId,
             FeatureFlags featureFlags) {
         UserManager um;
@@ -2762,7 +3171,7 @@ public class CallsManager extends Call.ListenerBase
                     public CharSequence getAppLabel(String packageName, UserHandle userHandle) {
                         return Util.getAppLabel(mContext, userHandle, packageName, mFeatureFlags);
                     }
-                }).process();
+                }, mFeatureFlags).process();
         future.thenApply( v -> {
             Log.i(this, "Outgoing caller ID complete");
             return null;
@@ -3225,8 +3634,20 @@ public class CallsManager extends Call.ListenerBase
             }).start();
         }
 
-        final boolean requireCallCapableAccountByHandle = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_requireCallCapableAccountForHandle);
+        final boolean requireCallCapableAccountByHandle;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            // This was previously only configured "true" for wear and cuttlefish builds.
+            // For cases where no target phone account handle were given this determines whether
+            // the phone account registrar query to get call capable phone accounts looks for a
+            // specific URI scheme or not.  On non-wear and cuttlefish builds we ued to just check
+            // all call capable phone accounts without accounting for scheme; that logic was
+            // flawed since dialing a tel: uri number REQUIRES a call capable tel: phone account.
+            // We are in effect removing this option.
+            requireCallCapableAccountByHandle = true;
+        } else {
+            requireCallCapableAccountByHandle = mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_requireCallCapableAccountForHandle);
+        }
         final boolean isOutgoingCallPermitted = isOutgoingCallPermitted(call,
                 call.getTargetPhoneAccount());
         final String callHandleScheme =
@@ -3332,10 +3753,6 @@ public class CallsManager extends Call.ListenerBase
             // from the client via a transaction before answering.
             call.answer(videoState);
         } else {
-            if (!mFeatureFlags.genAnomReportOnFocusTimeout()) {
-                Call activeCall = (Call) mConnectionSvrFocusMgr.getCurrentFocusCall();
-                Log.d(this, "answerCall: Incoming call = %s Ongoing call %s", call, activeCall);
-            }
             // Hold or disconnect the active call and request call focus for the incoming call.
             holdActiveCallForNewCall(call);
             mConnectionSvrFocusMgr.requestFocus(
@@ -3647,6 +4064,19 @@ public class CallsManager extends Call.ListenerBase
         }
         mPendingAccountSelection.remove(callId);
     }
+
+    /**
+     * Derived from the disconnectCallOld logic to ensure that the registered listeners are notified
+     * of the disconnecting state once the call is disconnected. This is used for call sequencing.
+     * @param call The call to notify the state change for.
+     * @param previousState The previous call state before the disconnect.
+     */
+    public void notifyCallStateChangeForDisconnect(Call call, int previousState) {
+        for (CallsManagerListener listener : mListeners) {
+            listener.onCallStateChanged(call, previousState, call.getState());
+        }
+    }
+
     /**
      * Disconnects calls for any other {@link PhoneAccountHandle} but the one specified.
      * Note: As a protective measure, will NEVER disconnect an emergency call.  Although that
@@ -3901,7 +4331,7 @@ public class CallsManager extends Call.ListenerBase
         for (PhoneAccountHandle callHandle : activeCallAccounts) {
             allAccounts.removeIf(candidateHandle -> {
                 PhoneAccount callAcct = mPhoneAccountRegistrar.getPhoneAccount(callHandle,
-                        user);
+                        user, true /* acrossProfiles */);
                 if (callAcct == null) {
                     Log.w(this, "constructPossiblePhoneAccountsNew: unexpected"
                             + "null PA for PAH, removing : " + candidateHandle);
@@ -4013,8 +4443,9 @@ public class CallsManager extends Call.ListenerBase
     }
 
     private boolean isRttSettingOn(PhoneAccountHandle handle) {
+        int userId = UserUtil.getUserIdFromContext(mContext, mFeatureFlags);
         boolean isRttModeSettingOn = Settings.Secure.getIntForUser(mContext.getContentResolver(),
-                Settings.Secure.RTT_CALLING_MODE, 0, mContext.getUserId()) != 0;
+                Settings.Secure.RTT_CALLING_MODE, 0, userId) != 0;
         // If the carrier config says that we should ignore the RTT mode setting from the user,
         // assume that it's off (i.e. only make an RTT call if it's requested through the extra).
         boolean shouldIgnoreRttModeSetting = getCarrierConfigForPhoneAccount(handle)
@@ -4205,44 +4636,6 @@ public class CallsManager extends Call.ListenerBase
         }
     }
 
-    /**
-     * The transactional unflagged (original) code path to hold or swap the active call in favor of
-     * a new call request. Refer to
-     * {@link CallsManagerCallSequencingAdapter#transactionHoldPotentialActiveCallForNewCall}.
-     */
-    public void transactionHoldPotentialActiveCallForNewCallUnflagged(Call activeCall, Call newCall,
-            OutcomeReceiver<Boolean, CallException> callback) {
-        // before attempting CallsManager#holdActiveCallForNewCall(Call), check if it'll fail
-        // early
-        if (!canHold(activeCall) &&
-                !(supportsHold(activeCall) && areFromSameSource(activeCall, newCall))) {
-            String msg = "call does not support hold";
-            Log.i(this, "transactionHoldPotentialActiveCallForNewCall: " + msg);
-            callback.onError(new CallException(msg,
-                    CallException.CODE_CANNOT_HOLD_CURRENT_ACTIVE_CALL));
-            if (mFeatureFlags.enableCallExceptionAnomReports()) {
-                mAnomalyReporter.reportAnomaly(CANNOT_HOLD_CURRENT_ACTIVE_CALL_ERROR_UUID, msg);
-            }
-            return;
-        }
-
-        // attempt to hold the active call
-        if (!holdActiveCallForNewCall(newCall)) {
-            String msg = "cannot hold active call failed";
-            Log.i(this, "transactionHoldPotentialActiveCallForNewCall: " + msg);
-            callback.onError(new CallException(msg,
-                    CallException.CODE_CANNOT_HOLD_CURRENT_ACTIVE_CALL));
-            if (mFeatureFlags.enableCallExceptionAnomReports()) {
-                mAnomalyReporter.reportAnomaly(CANNOT_HOLD_CURRENT_ACTIVE_CALL_ERROR_UUID, msg);
-            }
-            return;
-        }
-
-        // officially mark the activeCall as held
-        markCallAsOnHold(activeCall);
-        callback.onResult(true);
-    }
-
     public boolean canHoldOrSwapActiveCall(Call activeCall, Call newCall) {
         return canHold(activeCall) || sameSourceHoldCase(activeCall, newCall);
     }
@@ -4344,8 +4737,8 @@ public class CallsManager extends Call.ListenerBase
 
             // Setup the future with a timeout so that the CDS is time boxed.
             CompletableFuture<Boolean> future = call.initializeDiagnosticCompleteFuture(
-                    mTimeoutsAdapter.getCallDiagnosticServiceTimeoutMillis(
-                            mContext.getContentResolver()));
+                    mTimeoutsAdapter.getCallDiagnosticServiceTimeoutMillis(mContext,
+                            mFeatureFlags));
 
             // Post the disconnection updates to the future for completion once the CDS returns
             // with it's overridden disconnect message.
@@ -4367,7 +4760,7 @@ public class CallsManager extends Call.ListenerBase
 
         if (oldState == CallState.NEW && disconnectCause.getCode() == DisconnectCause.MISSED) {
             Log.i(this, "markCallAsDisconnected: logging missed call ");
-            mCallLogManager.logCall(call, Calls.MISSED_TYPE, true, null);
+            mCallLogManager.logCallIfNotSelfManaged(call, Calls.MISSED_TYPE, true, null);
         }
     }
 
@@ -4658,6 +5051,11 @@ public class CallsManager extends Call.ListenerBase
                 CallState.ANSWERED, CallState.SIMULATED_RINGING);
     }
 
+    @VisibleForTesting
+    public Call getDialingCall() {
+        return getFirstCallWithState(CallState.DIALING, CallState.PULLING);
+    }
+
     public Call getActiveCall() {
         return getFirstCallWithState(CallState.ACTIVE);
     }
@@ -4693,8 +5091,8 @@ public class CallsManager extends Call.ListenerBase
         return getFirstCallWithState(null, false /* skipSelfManaged */, states);
     }
 
-    public Call getFirstCallWithLiveState() {
-        return getFirstCallWithState(null, false /* skipSelfManaged */, LIVE_CALL_STATES);
+    public Call getFirstCallWithLiveState(Call exceptCall) {
+        return getFirstCallWithState(exceptCall, false /* skipSelfManaged */, LIVE_CALL_STATES);
     }
 
     @VisibleForTesting
@@ -4810,8 +5208,7 @@ public class CallsManager extends Call.ListenerBase
         call.setStatusHints(parcelableConference.getStatusHints());
         call.putConnectionServiceExtras(parcelableConference.getExtras());
         // For conference calls, set the associated user from the target phone account user handle.
-        UserHandle associatedUser = UserUtil.getAssociatedUserForCall(
-                mFeatureFlags.associatedUserRefactorForWorkProfile(), getPhoneAccountRegistrar(),
+        UserHandle associatedUser = UserUtil.getAssociatedUserForCall(getPhoneAccountRegistrar(),
                 getCurrentUserHandle(), phoneAccount);
         call.setAssociatedUser(associatedUser);
         // In case this Conference was added via a ConnectionManager, keep track of the original
@@ -4887,7 +5284,7 @@ public class CallsManager extends Call.ListenerBase
         // Since the call was not added to the list of calls, we have to call the missed
         // call notifier and the call logger manually.
         // Do we need missed call notification for direct to Voicemail calls?
-        mCallLogManager.logCall(incomingCall, Calls.MISSED_TYPE,
+        mCallLogManager.logCallIfNotSelfManaged(incomingCall, Calls.MISSED_TYPE,
                 true /*showNotificationForMissedCall*/, result);
     }
 
@@ -4904,6 +5301,7 @@ public class CallsManager extends Call.ListenerBase
         }
         Log.i(this, "addCall(%s)", call);
         call.addListener(this);
+        mCallSequencingAdapter.setCallSequencingMetrics(call);
         mCalls.add(call);
         // Reprocess the simultaneous call types for all the tracked calls after having added a new
         // call.
@@ -4997,6 +5395,11 @@ public class CallsManager extends Call.ListenerBase
                 stopDtmfTone(call);
             }
 
+            // Maybe start vibrating for MO call.
+            if (newState == CallState.ACTIVE && !call.isIncoming() && !call.isUnknown()) {
+                mRinger.startVibratingForOutgoingCallActive();
+            }
+
             // Unfortunately, in the telephony world the radio is king. So if the call notifies
             // us that the call is in a particular state, we allow it even if it doesn't make
             // sense (e.g., STATE_ACTIVE -> STATE_RINGING).
@@ -5803,10 +6206,18 @@ public class CallsManager extends Call.ListenerBase
                 return;
             }
             if (am.getStreamVolume(AudioManager.STREAM_VOICE_CALL) == 0) {
-                Log.i(this,
-                        "ensureCallAudible: voice call stream has volume 0. Adjusting to default.");
-                am.setStreamVolume(AudioManager.STREAM_VOICE_CALL,
-                        AudioSystem.getDefaultStreamVolume(AudioManager.STREAM_VOICE_CALL), 0);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    Log.i(this, "ensureCallAudible: voice call stream has volume 0. "
+                            + "Adjusting to average.");
+                    int averageStreamVolume = (am.getStreamMaxVolume(AudioManager.STREAM_VOICE_CALL)
+                            + am.getStreamMinVolume(AudioManager.STREAM_VOICE_CALL)) / 2;
+                    am.setStreamVolume(AudioManager.STREAM_VOICE_CALL, averageStreamVolume, 0);
+                } else {
+                    Log.i(this, "ensureCallAudible: voice call stream has volume 0. "
+                            + "Adjusting to default.");
+                    am.setStreamVolume(AudioManager.STREAM_VOICE_CALL,
+                            AudioSystem.getDefaultStreamVolume(AudioManager.STREAM_VOICE_CALL), 0);
+                }
             }
         });
     }
@@ -5877,8 +6288,7 @@ public class CallsManager extends Call.ListenerBase
                 connection.getCallerDisplayNamePresentation());
         // For existing connections, use the phone account user handle to determine the user
         // association with the call.
-        UserHandle associatedUser = UserUtil.getAssociatedUserForCall(
-                mFeatureFlags.associatedUserRefactorForWorkProfile(), getPhoneAccountRegistrar(),
+        UserHandle associatedUser = UserUtil.getAssociatedUserForCall(getPhoneAccountRegistrar(),
                 getCurrentUserHandle(), connection.getPhoneAccount());
         call.setAssociatedUser(associatedUser);
         call.addListener(this);
@@ -6111,7 +6521,7 @@ public class CallsManager extends Call.ListenerBase
      * Blocks execution until all Telecom handlers have completed their current work.
      */
     public void waitOnHandlers() {
-        CountDownLatch mainHandlerLatch = new CountDownLatch(3);
+        CountDownLatch mainHandlerLatch = new CountDownLatch(4);
         mHandler.post(() -> {
             mainHandlerLatch.countDown();
         });
@@ -6121,7 +6531,7 @@ public class CallsManager extends Call.ListenerBase
         mCallAudioManager.getCallAudioRouteAdapter().getAdapterHandler().post(() -> {
             mainHandlerLatch.countDown();
         });
-
+        mCallAudioRouteAdapter.getAdapterHandler().post(()-> mainHandlerLatch.countDown());
         try {
             mainHandlerLatch.await(HANDLER_WAIT_TIMEOUT, TimeUnit.MILLISECONDS);
         } catch (InterruptedException e) {
@@ -7221,22 +7631,29 @@ public class CallsManager extends Call.ListenerBase
         mCallSequencingAdapter = adapter;
     }
 
+    @VisibleForTesting
+    public void setCallAudioWatchDog(CallAudioWatchdog callAudioWatchdog) {
+        mListeners.remove(mCallAudioWatchDog);
+        mCallAudioWatchDog = callAudioWatchdog;
+        if (callAudioWatchdog != null) {
+            mListeners.add(callAudioWatchdog);
+        }
+    }
+
     public void waitForAudioToUpdate(boolean expectActive) {
         Log.i(this, "waitForAudioToUpdate");
-        if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-            try {
-                CallAudioRouteController audioRouteController =
-                        (CallAudioRouteController) mCallAudioRouteAdapter;
-                if (expectActive) {
-                    audioRouteController.getAudioActiveCompleteLatch().await(
-                            WAIT_FOR_AUDIO_UPDATE_TIMEOUT, TimeUnit.MILLISECONDS);
-                } else {
-                    audioRouteController.getAudioOperationsCompleteLatch().await(
-                            WAIT_FOR_AUDIO_UPDATE_TIMEOUT, TimeUnit.MILLISECONDS);
-                }
-            } catch (InterruptedException e) {
-                Log.w(this, e.toString());
+        try {
+            CallAudioRouteController audioRouteController =
+                    (CallAudioRouteController) mCallAudioRouteAdapter;
+            if (expectActive) {
+                audioRouteController.getAudioActiveCompleteLatch().await(
+                        WAIT_FOR_AUDIO_UPDATE_TIMEOUT, TimeUnit.MILLISECONDS);
+            } else {
+                audioRouteController.getAudioOperationsCompleteLatch().await(
+                        WAIT_FOR_AUDIO_UPDATE_TIMEOUT, TimeUnit.MILLISECONDS);
             }
+        } catch (InterruptedException e) {
+            Log.w(this, e.toString());
         }
     }
 
@@ -7245,4 +7662,12 @@ public class CallsManager extends Call.ListenerBase
     getPendingAccountSelection() {
         return mPendingAccountSelection;
     }
+
+    public int getCallConnectedIndicatorPreference() {
+        return mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference();
+    }
+
+    public void setCallConnectedIndicatorPreference(int preference) {
+        mCallConnectedIndicatorSettings.setCallConnectedIndicatorPreference(preference);
+    }
 }
diff --git a/src/com/android/server/telecom/ConnectionServiceFocusManager.java b/src/com/android/server/telecom/ConnectionServiceFocusManager.java
index 35be0f898..1126cf7c6 100644
--- a/src/com/android/server/telecom/ConnectionServiceFocusManager.java
+++ b/src/com/android/server/telecom/ConnectionServiceFocusManager.java
@@ -30,7 +30,6 @@ import android.util.LogPrinter;
 import android.util.Printer;
 
 import com.android.internal.annotations.VisibleForTesting;
-import com.android.server.telecom.flags.Flags;
 import com.android.internal.util.IndentingPrintWriter;
 
 import java.util.ArrayList;
@@ -341,23 +340,18 @@ public class ConnectionServiceFocusManager {
             if (syncCallFocus != null) {
                 return syncCallFocus.orElse(null);
             } else {
-                if (Flags.genAnomReportOnFocusTimeout()) {
-                    Log.w(TAG, "Timed out waiting for synchronous current focus. Returning possibly"
-                                    + " inaccurate result. returning currentFocusCall=[%s]",
-                            mCurrentFocusCall);
-
-                    // dump the state of the handler to better understand the timeout
-                    mEventHandler.dump(
-                            new LogPrinter(android.util.Log.INFO, TAG), "CsFocusMgr_timeout");
-
-                    // report the timeout
-                    mAnomalyReporter.reportAnomaly(
-                            WATCHDOG_GET_CALL_FOCUS_TIMEOUT_UUID,
-                            WATCHDOG_GET_CALL_FOCUS_TIMEOUT_MSG);
-                } else {
-                    Log.w(TAG, "Timed out waiting for synchronous current focus. Returning possibly"
-                            + " inaccurate result");
-                }
+                Log.w(TAG, "Timed out waiting for synchronous current focus. Returning possibly"
+                                + " inaccurate result. returning currentFocusCall=[%s]",
+                        mCurrentFocusCall);
+
+                // dump the state of the handler to better understand the timeout
+                mEventHandler.dump(
+                        new LogPrinter(android.util.Log.INFO, TAG), "CsFocusMgr_timeout");
+
+                // report the timeout
+                mAnomalyReporter.reportAnomaly(
+                        WATCHDOG_GET_CALL_FOCUS_TIMEOUT_UUID,
+                        WATCHDOG_GET_CALL_FOCUS_TIMEOUT_MSG);
                 return mCurrentFocusCall;
             }
         } catch (InterruptedException e) {
diff --git a/src/com/android/server/telecom/ConnectionServiceWrapper.java b/src/com/android/server/telecom/ConnectionServiceWrapper.java
index 7a95cc850..4ecb0f19c 100644
--- a/src/com/android/server/telecom/ConnectionServiceWrapper.java
+++ b/src/com/android/server/telecom/ConnectionServiceWrapper.java
@@ -679,6 +679,133 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
             }
         }
 
+        @Override
+        public void addConferenceCallFromConnection(String callId,
+                ParcelableConference parcelableConference, Session.Info sessionInfo) {
+            Log.startSession(sessionInfo, LogUtils.Sessions.CSW_ADD_CONFERENCE_CALL_FROM_CONN,
+                    mPackageAbbreviation);
+
+            Log.i(this, "addConferenceCallFromConnection: callId = " + callId);
+
+            UserHandle callingUserHandle = Binder.getCallingUserHandle();
+            // Check status hints image for cross user access
+            if (parcelableConference.getStatusHints() != null) {
+                Icon icon = parcelableConference.getStatusHints().getIcon();
+                parcelableConference.getStatusHints().setIcon(StatusHints
+                        .validateAccountIconUserBoundary(icon, callingUserHandle));
+            }
+
+            if (parcelableConference.getConnectElapsedTimeMillis() != 0
+                    && mContext.checkCallingOrSelfPermission(MODIFY_PHONE_STATE)
+                    != PackageManager.PERMISSION_GRANTED) {
+                Log.w(this, "addConferenceCall from caller without permission!");
+                parcelableConference = new ParcelableConference.Builder(
+                        parcelableConference.getPhoneAccount(),
+                        parcelableConference.getState())
+                        .setConnectionCapabilities(parcelableConference.getConnectionCapabilities())
+                        .setConnectionProperties(parcelableConference.getConnectionProperties())
+                        .setConnectionIds(parcelableConference.getConnectionIds())
+                        .setVideoAttributes(parcelableConference.getVideoProvider(),
+                                parcelableConference.getVideoState())
+                        .setStatusHints(parcelableConference.getStatusHints())
+                        .setExtras(parcelableConference.getExtras())
+                        .setAddress(parcelableConference.getHandle(),
+                                parcelableConference.getHandlePresentation())
+                        // no caller display name set.
+                        .setDisconnectCause(parcelableConference.getDisconnectCause())
+                        .setRingbackRequested(parcelableConference.isRingbackRequested())
+                        .build();
+            }
+
+            long token = Binder.clearCallingIdentity();
+            try {
+                synchronized (mLock) {
+                    Call existingTelecomCall = mCallIdMapper.getCall(callId);
+                    if (existingTelecomCall == null) {
+                        Log.e(this, new Exception(), "Attempting to create a "
+                                + "conference call using an existing call id that cannot be found "
+                                + "in telecom. Call ID = " + callId);
+                        return;
+                    }
+                    logIncoming("addConferenceCallFromConnection %s %s [%s]", callId,
+                            parcelableConference, parcelableConference.getConnectionIds());
+
+                    // Make sure that there's at least one valid call. For remote connections
+                    // we'll get a add conference msg from both the remote connection service
+                    // and from the real connection service.
+                    boolean hasValidCalls = false;
+                    for (String connId : parcelableConference.getConnectionIds()) {
+                        if (mCallIdMapper.getCall(connId) != null) {
+                            hasValidCalls = true;
+                        }
+                    }
+                    // But don't bail out if the connection count is 0, because that is a valid
+                    // IMS conference state.
+                    if (!hasValidCalls && parcelableConference.getConnectionIds().size() > 0) {
+                        Log.i(this, "Attempting to add a conference with no valid calls");
+                        return;
+                    }
+
+                    Bundle connectionExtras = parcelableConference.getExtras();
+
+                    String connectIdToCheck = null;
+                    if (connectionExtras != null && connectionExtras
+                            .containsKey(Connection.EXTRA_ORIGINAL_CONNECTION_ID)) {
+                        // Conference was added via a connection manager, see if its original id is
+                        // known.
+                        connectIdToCheck = connectionExtras
+                                .getString(Connection.EXTRA_ORIGINAL_CONNECTION_ID);
+                    } else {
+                        connectIdToCheck = callId;
+                    }
+
+                    // Check to see if this conference has already been added.
+                    Call alreadyAddedConnection = mCallsManager
+                            .getAlreadyAddedConnection(connectIdToCheck);
+                    if (alreadyAddedConnection != null && mCallIdMapper.getCall(callId) == null) {
+                        Log.i(this, "addConferenceCallFromConnection: attempting to "
+                                + "add the conference via a connection mgr");
+                        // We are currently attempting to add the conference via a connection mgr,
+                        // and the originating ConnectionService has already added it.  Instead of
+                        // making a new Telecom call, we will simply add it to the ID mapper here,
+                        // and replace the ConnectionService on the call.
+                        mCallIdMapper.addCall(alreadyAddedConnection, callId);
+                        alreadyAddedConnection.replaceConnectionService(
+                                ConnectionServiceWrapper.this);
+                    } else {
+                        // Convert the existing Telecom call into a conference:
+                        existingTelecomCall.setConferenceState(true);
+
+                        // Set the attributes of the parcelableConference for the Telecom call:
+                        existingTelecomCall.setTargetPhoneAccount(
+                                parcelableConference.getPhoneAccount());
+                        existingTelecomCall.setConnectionProperties(
+                                parcelableConference.getConnectionProperties());
+                        existingTelecomCall.setConnectionCapabilities(
+                                parcelableConference.getConnectionCapabilities());
+                        existingTelecomCall.setCallDirection(
+                                parcelableConference.getCallDirection());
+                        existingTelecomCall.setVideoProvider(
+                                parcelableConference.getVideoProvider());
+                        existingTelecomCall.setVideoState(parcelableConference.getVideoState());
+                        existingTelecomCall.setStatusHints(parcelableConference.getStatusHints());
+                        existingTelecomCall.setHandle(parcelableConference.getHandle(),
+                                parcelableConference.getHandlePresentation());
+                        existingTelecomCall.setDisconnectCause(
+                                parcelableConference.getDisconnectCause());
+                        existingTelecomCall.setRingbackRequested(
+                                parcelableConference.isRingbackRequested());
+                    }
+                }
+            } catch (Throwable t) {
+                Log.e(ConnectionServiceWrapper.this, t, "");
+                throw t;
+            } finally {
+                Binder.restoreCallingIdentity(token);
+                Log.endSession();
+            }
+        }
+
         @Override
         public void onPostDialWait(String callId, String remaining,
                 Session.Info sessionInfo) throws RemoteException {
@@ -910,7 +1037,8 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
             long token = Binder.clearCallingIdentity();
             try {
                 synchronized (mLock) {
-                    logIncoming("setAddress %s %s %d", callId, address, presentation);
+                    logIncoming("setAddress %s %s %d", callId, Log.piiHandle(address),
+                            presentation);
                     Call call = mCallIdMapper.getCall(callId);
                     if (call != null) {
                         call.setHandle(address, presentation);
@@ -932,7 +1060,7 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
             long token = Binder.clearCallingIdentity();
             try {
                 synchronized (mLock) {
-                    logIncoming("setCallerDisplayName %s %s %d", callId, callerDisplayName,
+                    logIncoming("setCallerDisplayName %s %s %d", callId, Log.pii(callerDisplayName),
                             presentation);
                     Call call = mCallIdMapper.getCall(callId);
                     if (call != null) {
@@ -1887,20 +2015,22 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
                             Log.piiHandle(call.getHandle()));
                     try {
                         logOutgoing("createConnectionFailed %s", callId);
-                        mServiceInterface.createConnectionFailed(
-                                call.getConnectionManagerPhoneAccount(),
-                                callId,
-                                new ConnectionRequest(
-                                        call.getTargetPhoneAccount(),
-                                        call.getHandle(),
-                                        call.getIntentExtras(),
-                                        call.getVideoState(),
-                                        callId,
-                                        false),
-                                call.isIncoming(),
-                                Log.getExternalSession(TELECOM_ABBREVIATION));
-                        call.setDisconnectCause(new DisconnectCause(DisconnectCause.CANCELED));
-                        call.disconnect();
+                        if (mServiceInterface != null) {
+                            mServiceInterface.createConnectionFailed(
+                                    call.getConnectionManagerPhoneAccount(),
+                                    callId,
+                                    new ConnectionRequest(
+                                            call.getTargetPhoneAccount(),
+                                            call.getHandle(),
+                                            call.getIntentExtras(),
+                                            call.getVideoState(),
+                                            callId,
+                                            false),
+                                    call.isIncoming(),
+                                    Log.getExternalSession(TELECOM_ABBREVIATION));
+                            call.setDisconnectCause(new DisconnectCause(DisconnectCause.CANCELED));
+                            call.disconnect();
+                        }
                     } catch (RemoteException e) {
                     }
                 }
@@ -1974,17 +2104,19 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
                     Log.addEvent(call, LogUtils.Events.HANDOVER_FAILED,
                             Log.piiHandle(call.getHandle()));
                     try {
-                        mServiceInterface.handoverFailed(
-                                callId,
-                                new ConnectionRequest(
-                                        call.getTargetPhoneAccount(),
-                                        call.getHandle(),
-                                        call.getIntentExtras(),
-                                        call.getVideoState(),
-                                        callId,
-                                        false),
-                                reason,
-                                Log.getExternalSession(TELECOM_ABBREVIATION));
+                        if (mServiceInterface != null) {
+                            mServiceInterface.handoverFailed(
+                                    callId,
+                                    new ConnectionRequest(
+                                            call.getTargetPhoneAccount(),
+                                            call.getHandle(),
+                                            call.getIntentExtras(),
+                                            call.getVideoState(),
+                                            callId,
+                                            false),
+                                    reason,
+                                    Log.getExternalSession(TELECOM_ABBREVIATION));
+                        }
                     } catch (RemoteException e) {
                     }
                 }
@@ -2010,9 +2142,11 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
                 // If still bound, tell the connection service create connection has failed.
                 if (callId != null && isServiceValid("handoverComplete")) {
                     try {
-                        mServiceInterface.handoverComplete(
-                                callId,
-                                Log.getExternalSession(TELECOM_ABBREVIATION));
+                        if (mServiceInterface != null) {
+                            mServiceInterface.handoverComplete(
+                                    callId,
+                                    Log.getExternalSession(TELECOM_ABBREVIATION));
+                        }
                     } catch (RemoteException e) {
                     }
                 }
@@ -2089,8 +2223,10 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
         if (callId != null && isServiceValid("onCallAudioStateChanged")) {
             try {
                 logOutgoing("onCallAudioStateChanged %s %s", callId, audioState);
-                mServiceInterface.onCallAudioStateChanged(callId, audioState,
-                        Log.getExternalSession(TELECOM_ABBREVIATION));
+                if (mServiceInterface != null) {
+                    mServiceInterface.onCallAudioStateChanged(callId, audioState,
+                            Log.getExternalSession(TELECOM_ABBREVIATION));
+                }
             } catch (RemoteException e) {
             }
         }
@@ -2566,8 +2702,10 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
             public void onSuccess() {
                 if (!isServiceValid("connectionServiceFocusLost")) return;
                 try {
-                    mServiceInterface.connectionServiceFocusLost(
-                            Log.getExternalSession(TELECOM_ABBREVIATION));
+                    if (mServiceInterface != null) {
+                        mServiceInterface.connectionServiceFocusLost(
+                                Log.getExternalSession(TELECOM_ABBREVIATION));
+                    }
                 } catch (RemoteException ignored) {
                     Log.d(this, "failed to inform the focus lost event");
                 }
@@ -2586,8 +2724,10 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
             public void onSuccess() {
                 if (!isServiceValid("connectionServiceFocusGained")) return;
                 try {
-                    mServiceInterface.connectionServiceFocusGained(
-                            Log.getExternalSession(TELECOM_ABBREVIATION));
+                    if (mServiceInterface != null) {
+                        mServiceInterface.connectionServiceFocusGained(
+                                Log.getExternalSession(TELECOM_ABBREVIATION));
+                    }
                 } catch (RemoteException ignored) {
                     Log.d(this, "failed to inform the focus gained event");
                 }
diff --git a/src/com/android/server/telecom/ContactsAsyncHelper.java b/src/com/android/server/telecom/ContactsAsyncHelper.java
index 37ee9412a..94d4f0a7d 100644
--- a/src/com/android/server/telecom/ContactsAsyncHelper.java
+++ b/src/com/android/server/telecom/ContactsAsyncHelper.java
@@ -28,8 +28,6 @@ import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/src/com/android/server/telecom/CreateConnectionProcessor.java b/src/com/android/server/telecom/CreateConnectionProcessor.java
index c2b5da10b..20f9ed1ab 100644
--- a/src/com/android/server/telecom/CreateConnectionProcessor.java
+++ b/src/com/android/server/telecom/CreateConnectionProcessor.java
@@ -29,8 +29,6 @@ import android.telecom.PhoneAccountHandle;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.telecom.flags.Flags;
 import com.android.server.telecom.flags.FeatureFlags;
@@ -286,24 +284,20 @@ public class CreateConnectionProcessor implements CreateConnectionResponse {
                 mConnectionAttempt++;
                 mCall.setConnectionManagerPhoneAccount(attempt.connectionManagerPhoneAccount);
                 mCall.setTargetPhoneAccount(attempt.targetPhoneAccount);
-                if (mFlags.updatedRcsCallCountTracking()) {
-                    if (Objects.equals(attempt.connectionManagerPhoneAccount,
-                            attempt.targetPhoneAccount)) {
+                if (Objects.equals(attempt.connectionManagerPhoneAccount,
+                        attempt.targetPhoneAccount)) {
+                    mCall.setConnectionService(mService);
+                } else {
+                    PhoneAccountHandle remotePhoneAccount = attempt.targetPhoneAccount;
+                    ConnectionServiceWrapper mRemoteService =
+                            mRepository.getService(remotePhoneAccount.getComponentName(),
+                            remotePhoneAccount.getUserHandle());
+                    if (mRemoteService == null) {
                         mCall.setConnectionService(mService);
                     } else {
-                        PhoneAccountHandle remotePhoneAccount = attempt.targetPhoneAccount;
-                        ConnectionServiceWrapper mRemoteService =
-                                mRepository.getService(remotePhoneAccount.getComponentName(),
-                                remotePhoneAccount.getUserHandle());
-                        if (mRemoteService == null) {
-                            mCall.setConnectionService(mService);
-                        } else {
-                            Log.v(this, "attemptNextPhoneAccount Setting RCS = %s", mRemoteService);
-                            mCall.setConnectionService(mService, mRemoteService);
-                        }
+                        Log.v(this, "attemptNextPhoneAccount Setting RCS = %s", mRemoteService);
+                        mCall.setConnectionService(mService, mRemoteService);
                     }
-                } else {
-                    mCall.setConnectionService(mService);
                 }
                 setTimeoutIfNeeded(mService, attempt);
                 if (mCall.isIncoming()) {
@@ -351,7 +345,7 @@ public class CreateConnectionProcessor implements CreateConnectionResponse {
         clearTimeout();
 
         CreateConnectionTimeout timeout = new CreateConnectionTimeout(
-                mContext, mPhoneAccountRegistrar, service, mCall, mTimeoutsAdapter);
+                mContext, mPhoneAccountRegistrar, service, mCall, mFlags, mTimeoutsAdapter);
         if (timeout.isTimeoutNeededForCall(getConnectionServices(mAttemptRecords),
                 attempt.connectionManagerPhoneAccount)) {
             mTimeout = timeout;
diff --git a/src/com/android/server/telecom/CreateConnectionTimeout.java b/src/com/android/server/telecom/CreateConnectionTimeout.java
index 2889e1353..dbf99d8a8 100644
--- a/src/com/android/server/telecom/CreateConnectionTimeout.java
+++ b/src/com/android/server/telecom/CreateConnectionTimeout.java
@@ -26,6 +26,7 @@ import android.telecom.PhoneAccountHandle;
 import android.telephony.TelephonyManager;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.Collection;
 import java.util.Objects;
@@ -43,15 +44,18 @@ public final class CreateConnectionTimeout extends Runnable {
     private boolean mIsRegistered;
     private boolean mIsCallTimedOut;
     private final Timeouts.Adapter mTimeoutsAdapter;
+    private final FeatureFlags mFlags;
 
     @VisibleForTesting
     public CreateConnectionTimeout(Context context, PhoneAccountRegistrar phoneAccountRegistrar,
-            ConnectionServiceWrapper service, Call call, Timeouts.Adapter timeoutsAdapter) {
+            ConnectionServiceWrapper service, Call call, FeatureFlags featureFlags,
+            Timeouts.Adapter timeoutsAdapter) {
         super("CCT", null /*lock*/);
         mContext = context;
         mPhoneAccountRegistrar = phoneAccountRegistrar;
         mConnectionService = service;
         mCall = call;
+        mFlags = featureFlags;
         mTimeoutsAdapter = timeoutsAdapter;
     }
 
@@ -158,15 +162,13 @@ public final class CreateConnectionTimeout extends Runnable {
             TelephonyManager telephonyManager =
                     (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
             if (telephonyManager.isRadioOn()) {
-                return mTimeoutsAdapter.getEmergencyCallTimeoutMillis(
-                        mContext.getContentResolver());
+                return mTimeoutsAdapter.getEmergencyCallTimeoutMillis(mContext, mFlags);
             } else {
-                return mTimeoutsAdapter.getEmergencyCallTimeoutRadioOffMillis(
-                        mContext.getContentResolver());
+                return mTimeoutsAdapter.getEmergencyCallTimeoutRadioOffMillis(mContext, mFlags);
             }
         } catch (UnsupportedOperationException uoe) {
             Log.e(this, uoe, "getTimeoutLengthMillis - telephony is not supported");
-            return mTimeoutsAdapter.getEmergencyCallTimeoutMillis(mContext.getContentResolver());
+            return mTimeoutsAdapter.getEmergencyCallTimeoutMillis(mContext, mFlags);
         }
     }
 }
diff --git a/src/com/android/server/telecom/DefaultDialerCache.java b/src/com/android/server/telecom/DefaultDialerCache.java
index 98289ede9..76f6da144 100644
--- a/src/com/android/server/telecom/DefaultDialerCache.java
+++ b/src/com/android/server/telecom/DefaultDialerCache.java
@@ -34,6 +34,7 @@ import android.telecom.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.IndentingPrintWriter;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
@@ -48,6 +49,7 @@ public class DefaultDialerCache {
     private final DefaultDialerManagerAdapter mDefaultDialerManagerAdapter;
     private final ComponentName mSystemDialerComponentName;
     private final RoleManagerAdapter mRoleManagerAdapter;
+    private final FeatureFlags mFeatureFlags;
     private final ConcurrentHashMap<Integer, String> mCurrentDefaultDialerPerUser =
             new ConcurrentHashMap<>();
     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
@@ -115,11 +117,12 @@ public class DefaultDialerCache {
     public DefaultDialerCache(Context context,
             DefaultDialerManagerAdapter defaultDialerManagerAdapter,
             RoleManagerAdapter roleManagerAdapter,
-            TelecomSystem.SyncRoot lock) {
+            TelecomSystem.SyncRoot lock, FeatureFlags featureFlags) {
+
         mContext = context;
         mDefaultDialerManagerAdapter = defaultDialerManagerAdapter;
         mRoleManagerAdapter = roleManagerAdapter;
-
+        mFeatureFlags = featureFlags;
         Resources resources = mContext.getResources();
         mSystemDialerComponentName = new ComponentName(resources.getString(
                 com.android.internal.R.string.config_defaultDialer),
@@ -131,19 +134,38 @@ public class DefaultDialerCache {
         packageIntentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
         packageIntentFilter.addDataScheme("package");
         packageIntentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
-        context.registerReceiverAsUser(mReceiver, UserHandle.ALL, packageIntentFilter, null, null);
+        Context userContext = context.createContextAsUser(UserHandle.ALL, 0);
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            userContext.registerReceiver(mReceiver, packageIntentFilter,
+                    Context.RECEIVER_NOT_EXPORTED);
+        } else {
+            context.registerReceiverAsUser(mReceiver, UserHandle.ALL, packageIntentFilter, null,
+                    null);
+        }
 
         IntentFilter bootIntentFilter = new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
-        context.registerReceiverAsUser(mReceiver, UserHandle.ALL, bootIntentFilter, null, null);
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            userContext.registerReceiver(mReceiver, bootIntentFilter,
+                    Context.RECEIVER_NOT_EXPORTED);
+        } else {
+            context.registerReceiverAsUser(mReceiver, UserHandle.ALL, bootIntentFilter, null, null);
+        }
 
         IntentFilter userRemovedFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);
         context.registerReceiver(mUserRemovedReceiver, userRemovedFilter);
 
         Uri defaultDialerSetting =
                 Settings.Secure.getUriFor(Settings.Secure.DIALER_DEFAULT_APPLICATION);
-        context.getContentResolver()
-                .registerContentObserver(defaultDialerSetting, false, mDefaultDialerObserver,
-                        UserHandle.USER_ALL);
+
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()){
+            context.getContentResolver()
+                    .registerContentObserverAsUser(defaultDialerSetting, false,
+                            mDefaultDialerObserver, UserHandle.ALL);
+        } else {
+            context.getContentResolver()
+                    .registerContentObserver(defaultDialerSetting, false,
+                            mDefaultDialerObserver, UserHandle.USER_ALL);
+        }
     }
 
     public String[] getBTInCallServicePackages() {
@@ -173,7 +195,7 @@ public class DefaultDialerCache {
     }
 
     public String getDefaultDialerApplication() {
-        return getDefaultDialerApplication(mContext.getUserId());
+        return getDefaultDialerApplication(UserUtil.getUserIdFromContext(mContext, mFeatureFlags));
     }
 
     public void setSystemDialerComponentName(ComponentName testComponentName) {
diff --git a/src/com/android/server/telecom/DtmfLocalTonePlayer.java b/src/com/android/server/telecom/DtmfLocalTonePlayer.java
index 5869008b3..5aef55cd9 100644
--- a/src/com/android/server/telecom/DtmfLocalTonePlayer.java
+++ b/src/com/android/server/telecom/DtmfLocalTonePlayer.java
@@ -28,8 +28,7 @@ import android.telecom.Log;
 import android.telecom.Logging.Session;
 
 import com.android.internal.annotations.VisibleForTesting;
-
-// TODO: Needed for move to system service: import com.android.internal.R;
+import com.android.server.telecom.flags.FeatureFlags;
 
 /**
  * Plays DTMF tones locally for the caller to hear. In order to reduce (1) the amount of times we
@@ -140,9 +139,11 @@ public class DtmfLocalTonePlayer {
     private ToneHandler mHandler;
 
     private final ToneGeneratorProxy mToneGeneratorProxy;
+     private final FeatureFlags mFeatureFlags;
 
-    public DtmfLocalTonePlayer(ToneGeneratorProxy toneGeneratorProxy) {
+    public DtmfLocalTonePlayer(ToneGeneratorProxy toneGeneratorProxy, FeatureFlags f) {
         mToneGeneratorProxy = toneGeneratorProxy;
+        mFeatureFlags = f;
     }
 
     public void onForegroundCallChanged(Call oldForegroundCall, Call newForegroundCall) {
@@ -195,7 +196,7 @@ public class DtmfLocalTonePlayer {
         if (context.getResources().getBoolean(R.bool.allow_local_dtmf_tones)) {
             areLocalTonesEnabled = Settings.System.getIntForUser(
                     context.getContentResolver(), Settings.System.DTMF_TONE_WHEN_DIALING, 1,
-                    context.getUserId()) == 1;
+                    UserUtil.getUserIdFromContext(context, mFeatureFlags)) == 1;
         } else {
             areLocalTonesEnabled = false;
         }
diff --git a/src/com/android/server/telecom/EmergencyCallHelper.java b/src/com/android/server/telecom/EmergencyCallHelper.java
index c0e38ca12..1f36abb13 100644
--- a/src/com/android/server/telecom/EmergencyCallHelper.java
+++ b/src/com/android/server/telecom/EmergencyCallHelper.java
@@ -115,7 +115,7 @@ public class EmergencyCallHelper {
 
     boolean isInEmergencyCallbackWindow(long lastEmergencyCallTimestampMillis) {
         return System.currentTimeMillis() - lastEmergencyCallTimestampMillis
-                < mTimeoutsAdapter.getEmergencyCallbackWindowMillis(mContext.getContentResolver());
+                < mTimeoutsAdapter.getEmergencyCallbackWindowMillis(mContext, mFeatureFlags);
     }
 
     private void recordEmergencyCall(Call call) {
diff --git a/src/com/android/server/telecom/InCallController.java b/src/com/android/server/telecom/InCallController.java
index 6cfa4fdea..62653af3b 100644
--- a/src/com/android/server/telecom/InCallController.java
+++ b/src/com/android/server/telecom/InCallController.java
@@ -25,7 +25,6 @@ import android.annotation.Nullable;
 import android.app.AppOpsManager;
 import android.app.KeyguardManager;
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.content.AttributionSource;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -48,8 +47,10 @@ import android.os.Parcel;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.permission.PermissionManager;
 import android.telecom.CallAudioState;
 import android.telecom.CallEndpoint;
+import android.telecom.Connection;
 import android.telecom.ConnectionService;
 import android.telecom.InCallService;
 import android.telecom.Log;
@@ -62,7 +63,6 @@ import android.util.ArraySet;
 import android.util.Pair;
 
 import com.android.internal.annotations.VisibleForTesting;
-// TODO: Needed for move to system service: import com.android.internal.R;
 import com.android.internal.telecom.IInCallService;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.IndentingPrintWriter;
@@ -83,6 +83,7 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
 /**
@@ -302,7 +303,6 @@ public class InCallController extends CallsManagerListenerBase implements
         private boolean mIsConnected = false;
         private boolean mIsBound = false;
         private boolean mIsNullBinding = false;
-        private NotificationManager mNotificationManager;
 
         //this is really used for cases where the userhandle for a call
         //does not match what we want to use for bindAsUser
@@ -331,10 +331,11 @@ public class InCallController extends CallsManagerListenerBase implements
                     addCall(call);
 
                     // Notify this new added call
-                    if (mFeatureFlags.separatelyBindToBtIncallService()
-                            && mInCallServiceInfo.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH) {
-                        sendCallToService(call, mInCallServiceInfo, mBTInCallServices
-                                .get(userFromCall).second);
+                    if (mInCallServiceInfo.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH) {
+                        if (mBTInCallServices.containsKey(userFromCall)) {
+                            sendCallToService(call, mInCallServiceInfo, mBTInCallServices
+                                    .get(userFromCall).second);
+                        }
                     } else {
                         sendCallToService(call, mInCallServiceInfo,
                                 mInCallServices.get(userFromCall).get(mInCallServiceInfo));
@@ -1125,8 +1126,7 @@ public class InCallController extends CallsManagerListenerBase implements
                         // Bind to BT service if there's an available call. When the flag isn't
                         // enabled, the service will be included as part of
                         // getNonUiInCallServiceBindingConnectionList.
-                        if (mFeatureFlags.separatelyBindToBtIncallService()
-                                && isBluetoothPkg && callToConnectWith != null) {
+                        if (isBluetoothPkg && callToConnectWith != null) {
                             // mNonUIInCallServiceConnections will always contain a key for
                             // userHandle and/or the child user if there is an ongoing call with
                             // that user, regardless if there aren't any non-UI ICS bound.
@@ -1237,6 +1237,7 @@ public class InCallController extends CallsManagerListenerBase implements
 
     private final Context mContext;
     private final AppOpsManager mAppOpsManager;
+    private final PermissionManager mPermissionManager;
     private final SensorPrivacyManager mSensorPrivacyManager;
     private final TelecomSystem.SyncRoot mLock;
     private final CallsManager mCallsManager;
@@ -1322,6 +1323,7 @@ public class InCallController extends CallsManagerListenerBase implements
             com.android.internal.telephony.flags.FeatureFlags telephonyFeatureFlags) {
         mContext = context;
         mAppOpsManager = context.getSystemService(AppOpsManager.class);
+        mPermissionManager = context.getSystemService(PermissionManager.class);
         mSensorPrivacyManager = context.getSystemService(SensorPrivacyManager.class);
         mLock = lock;
         mCallsManager = callsManager;
@@ -1380,7 +1382,12 @@ public class InCallController extends CallsManagerListenerBase implements
 
                 int uid;
                 try {
-                    uid = pkgManager.getPackageUidAsUser(pkg, user.getIdentifier());
+                    if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                        uid = UserUtil.getPackageManagerFromUserHandler(mContext,
+                                user).getPackageUidAsUser(pkg, user.getIdentifier());
+                    } else {
+                        uid = pkgManager.getPackageUidAsUser(pkg, user.getIdentifier());
+                    }
                 } catch (PackageManager.NameNotFoundException e) {
                     continue;
                 }
@@ -1416,34 +1423,24 @@ public class InCallController extends CallsManagerListenerBase implements
         // Track the call if we don't already know about it.
         addCall(call);
 
-        if (mFeatureFlags.separatelyBindToBtIncallService()) {
-            boolean bindingToBtRequired = false;
-            boolean bindingToOtherServicesRequired = false;
-            if (!isBoundAndConnectedToBTService(userFromCall)) {
-                Log.i(this, "onCallAdded: %s; not bound or connected to BT ICS.", call);
-                bindingToBtRequired = true;
-                bindToBTService(call, null);
-            }
+        boolean bindingToBtRequired = false;
+        boolean bindingToOtherServicesRequired = false;
+        if (!isBoundAndConnectedToBTService(userFromCall)) {
+            Log.i(this, "onCallAdded: %s; not bound or connected to BT ICS.", call);
+            bindingToBtRequired = true;
+            bindToBTService(call, null);
+        }
 
-            if (!isBoundAndConnectedToServices(userFromCall)) {
-                Log.i(this, "onCallAdded: %s; not bound or connected to other ICS.", call);
-                // We are not bound, or we're not connected.
-                bindingToOtherServicesRequired = true;
-                bindToServices(call);
-            }
-            // If either BT service are already bound or other services are already bound, attempt
-            // to add the new call to the connected incall services.
-            if (!bindingToBtRequired || !bindingToOtherServicesRequired) {
-                addCallToConnectedServices(call, userFromCall);
-            }
-        } else {
-            if (!isBoundAndConnectedToServices(userFromCall)) {
-                Log.i(this, "onCallAdded: %s; not bound or connected.", call);
-                // We are not bound, or we're not connected.
-                bindToServices(call);
-            } else {
-                addCallToConnectedServices(call, userFromCall);
-            }
+        if (!isBoundAndConnectedToServices(userFromCall)) {
+            Log.i(this, "onCallAdded: %s; not bound or connected to other ICS.", call);
+            // We are not bound, or we're not connected.
+            bindingToOtherServicesRequired = true;
+            bindToServices(call);
+        }
+        // If either BT service are already bound or other services are already bound, attempt
+        // to add the new call to the connected incall services.
+        if (!bindingToBtRequired || !bindingToOtherServicesRequired) {
+            addCallToConnectedServices(call, userFromCall);
         }
     }
 
@@ -1492,8 +1489,10 @@ public class InCallController extends CallsManagerListenerBase implements
                         true /* includeVideoProvider */,
                         mCallsManager.getPhoneAccountRegistrar(),
                         info.isExternalCallsSupported(), includeRttCall,
-                        info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI ||
-                                info.getType() == IN_CALL_SERVICE_TYPE_NON_UI);
+                        info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI
+                                || info.getType() == IN_CALL_SERVICE_TYPE_NON_UI
+                                || info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH,
+                        info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH);
                 try {
                     inCallService.addCall(
                             sanitizeParcelableCallForService(info, parcelableCall));
@@ -1515,9 +1514,7 @@ public class InCallController extends CallsManagerListenerBase implements
         UserHandle userFromCall = getUserFromCall(call);
         Stream<Call> callsAssociatedWithUserFromCall = mCallsManager.getCalls().stream()
                 .filter((c) -> getUserFromCall(c).equals(userFromCall));
-        boolean isCallCountZero = mFeatureFlags.associatedUserRefactorForWorkProfile()
-                ? callsAssociatedWithUserFromCall.count() == 0
-                : mCallsManager.getCalls().isEmpty();
+        boolean isCallCountZero = callsAssociatedWithUserFromCall.count() == 0;
         if (isCallCountZero) {
             /** Let's add a 2 second delay before we send unbind to the services to hopefully
              *  give them enough time to process all the pending messages.
@@ -1532,9 +1529,7 @@ public class InCallController extends CallsManagerListenerBase implements
                     // Check again to make sure there are no active calls for the associated user.
                     Stream<Call> callsAssociatedWithUserFromCall = mCallsManager.getCalls().stream()
                             .filter((c) -> getUserFromCall(c).equals(userFromCall));
-                    boolean isCallCountZero = mFeatureFlags.associatedUserRefactorForWorkProfile()
-                            ? callsAssociatedWithUserFromCall.count() == 0
-                            : mCallsManager.getCalls().isEmpty();
+                    boolean isCallCountZero = callsAssociatedWithUserFromCall.count() == 0;
                     if (isCallCountZero) {
                         unbindFromServices(userFromCall);
                         mEmergencyCallHelper.maybeRevokeTemporaryLocationPermission();
@@ -1543,7 +1538,7 @@ public class InCallController extends CallsManagerListenerBase implements
             }.prepare();
             mHandler.postDelayed(mCallRemovedRunnable,
                     mTimeoutsAdapter.getCallRemoveUnbindInCallServicesDelay(
-                            mContext.getContentResolver()));
+                            mContext, mFeatureFlags));
         }
         call.removeListener(mCallListener);
         mCallIdMapper.removeCall(call);
@@ -1558,20 +1553,18 @@ public class InCallController extends CallsManagerListenerBase implements
     @Override
     public void onDisconnectedTonePlaying(Call call, boolean isTonePlaying) {
         Log.i(this, "onDisconnectedTonePlaying: %s -> %b", call, isTonePlaying);
-        if (mFeatureFlags.separatelyBindToBtIncallService()) {
-            synchronized (mLock) {
-                if (isTonePlaying) {
-                    mDisconnectedToneStartedPlaying = true;
-                } else if (mDisconnectedToneStartedPlaying) {
-                    mDisconnectedToneStartedPlaying = false;
-                    if (mDisconnectedToneBtFutures.containsKey(call.getId())) {
-                        Log.i(this, "onDisconnectedTonePlaying: completing BT "
-                                + "disconnected tone future");
-                        mDisconnectedToneBtFutures.get(call.getId()).complete(null);
-                    }
-                    // Schedule unbinding of BT ICS.
-                    maybeScheduleBtUnbind(call);
+        synchronized (mLock) {
+            if (isTonePlaying) {
+                mDisconnectedToneStartedPlaying = true;
+            } else if (mDisconnectedToneStartedPlaying) {
+                mDisconnectedToneStartedPlaying = false;
+                if (mDisconnectedToneBtFutures.containsKey(call.getId())) {
+                    Log.i(this, "onDisconnectedTonePlaying: completing BT "
+                            + "disconnected tone future");
+                    mDisconnectedToneBtFutures.get(call.getId()).complete(null);
                 }
+                // Schedule unbinding of BT ICS.
+                maybeScheduleBtUnbind(call);
             }
         }
     }
@@ -1638,7 +1631,7 @@ public class InCallController extends CallsManagerListenerBase implements
                         }
                     }
                 }.prepare(), mTimeoutsAdapter.getCallRemoveUnbindInCallServicesDelay(
-                        mContext.getContentResolver()));
+                        mContext, mFeatureFlags));
             }
             mBTInCallServiceConnections.remove(userHandle);
         }
@@ -1685,7 +1678,9 @@ public class InCallController extends CallsManagerListenerBase implements
                         true /* includeVideoProvider */, mCallsManager.getPhoneAccountRegistrar(),
                         info.isExternalCallsSupported(), includeRttCall,
                         info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI
-                                || info.getType() == IN_CALL_SERVICE_TYPE_NON_UI);
+                                || info.getType() == IN_CALL_SERVICE_TYPE_NON_UI
+                                || info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH,
+                        info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH);
                 try {
                     inCallService.addCall(sanitizeParcelableCallForService(info, parcelableCall));
                     updateCallTracking(call, info, true /* isAdd */);
@@ -1720,6 +1715,8 @@ public class InCallController extends CallsManagerListenerBase implements
                             false /* includeRttCall */,
                             info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI
                                     || info.getType() == IN_CALL_SERVICE_TYPE_NON_UI
+                                    || info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH,
+                            info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH
                     );
 
                     try {
@@ -1909,17 +1906,28 @@ public class InCallController extends CallsManagerListenerBase implements
             }
 
             if (shouldStart) {
-                // Note, not checking return value, as this op call is merely for tracing use
-                mAppOpsManager.startOp(AppOpsManager.OP_PHONE_CALL_CAMERA, myUid(),
-                        mContext.getOpPackageName(), false, null, null);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    // Note, not checking return value, as this op call is merely for tracing use
+                    mAppOpsManager.startOp(AppOpsManager.OPSTR_PHONE_CALL_CAMERA, myUid(),
+                            mContext.getOpPackageName(), null, null);
+                } else {
+                    // Note, not checking return value, as this op call is merely for tracing use
+                    mAppOpsManager.startOp(AppOpsManager.OP_PHONE_CALL_CAMERA, myUid(),
+                            mContext.getOpPackageName(), false, null, null);
+                }
                 mSensorPrivacyManager.showSensorUseDialog(SensorPrivacyManager.Sensors.CAMERA);
             }
         } else {
             boolean hadCall = !mCallsUsingCamera.isEmpty();
             mCallsUsingCamera.remove(call.getId());
             if (hadCall && mCallsUsingCamera.isEmpty()) {
-                mAppOpsManager.finishOp(AppOpsManager.OP_PHONE_CALL_CAMERA, myUid(),
-                        mContext.getOpPackageName(), null);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    mAppOpsManager.finishOp(AppOpsManager.OPSTR_PHONE_CALL_CAMERA, myUid(),
+                            mContext.getOpPackageName(), null);
+                } else {
+                    mAppOpsManager.finishOp(AppOpsManager.OP_PHONE_CALL_CAMERA, myUid(),
+                            mContext.getOpPackageName(), null);
+                }
             }
         }
     }
@@ -1935,8 +1943,8 @@ public class InCallController extends CallsManagerListenerBase implements
         // the admin user. This needs to account for emergency calls placed from secondary/guest
         // users as well as the work profile. Once the screen is locked, the user should be able to
         // return to the call (from the keyguard UI).
-        if (mFeatureFlags.eccKeyguard() && mCallsManager.isInEmergencyCall()
-                && isLockscreenRestricted && !serviceMap.containsKey(callingUser)) {
+        if (mCallsManager.isInEmergencyCall() && isLockscreenRestricted
+                && !serviceMap.containsKey(callingUser)) {
             // If screen is locked and the current user is the system, query calls for the work
             // profile user, if available. Otherwise, the user is in the secondary/guest profile,
             // so we can default to the system user.
@@ -1991,6 +1999,11 @@ public class InCallController extends CallsManagerListenerBase implements
         UserHandle userFromCall = getUserFromCall(call);
         Map<UserHandle, Map<InCallController.InCallServiceInfo, IInCallService>> serviceMap =
                 getCombinedInCallServiceMap();
+        // In the case that we receive a disconnect failed event, ensure that the call state is
+        // reverted if it's in disconnecting and ensure we send the update to the ICS as well.
+        if (Connection.EVENT_DISCONNECT_FAILED.equals(event)) {
+            handleCallDisconnectFailed(call);
+        }
         if (serviceMap.containsKey(userFromCall)) {
             for (IInCallService inCallService : serviceMap.get(userFromCall).values()) {
                 try {
@@ -2005,6 +2018,23 @@ public class InCallController extends CallsManagerListenerBase implements
         }
     }
 
+    /**
+     * When we receive a disconnect failure connection event, the old call state will be in
+     * disconnecting given that the locally disconnecting state is set. Notify the ICS with the new
+     * call state to ensure they get the new update if they had been notified that the call was
+     * disconnecting.
+     * @param call The call that received the disconnect failure event.
+     */
+    private void handleCallDisconnectFailed(Call call) {
+        Log.i(this, "handleCallDisconnectFailed: call: %s", call);
+        call.setLocallyDisconnecting(false);
+        updateCall(call);
+        // Show an error dialog to the user mentioning why the disconnect failed.
+        UserUtil.showErrorDialogForRestrictedOutgoingCall(mContext,
+                R.string.call_hangup_fail_during_merge, NOTIFICATION_TAG,
+                "Call cannot be disconnected during a call merge.");
+    }
+
     private void notifyRttInitiationFailure(Call call, int reason) {
         UserHandle userFromCall = getUserFromCall(call);
         Map<UserHandle, Map<InCallController.InCallServiceInfo, IInCallService>> serviceMap =
@@ -2093,11 +2123,9 @@ public class InCallController extends CallsManagerListenerBase implements
             mNonUIInCallServiceConnections.remove(userHandle);
         }
         getCombinedInCallServiceMap().remove(userHandle);
-        if (mFeatureFlags.separatelyBindToBtIncallService()) {
-            // Note that the BT ICS will be repopulated as part of the combined map if the
-            // BT ICS is still bound (disconnected tone hasn't finished playing).
-            updateCombinedInCallServiceMap(userHandle);
-        }
+        // Note that the BT ICS will be repopulated as part of the combined map if the
+        // BT ICS is still bound (disconnected tone hasn't finished playing).
+        updateCombinedInCallServiceMap(userHandle);
     }
 
     /**
@@ -2112,13 +2140,7 @@ public class InCallController extends CallsManagerListenerBase implements
                 ? getUserFromCall(call)
                 : userHandle;
         UserManager um = mContext.getSystemService(UserManager.class);
-        UserHandle parentUser = mFeatureFlags.profileUserSupport()
-                ? um.getProfileParent(userToBind) : null;
-
-        if (!mFeatureFlags.profileUserSupport()
-                && um.isManagedProfile(userToBind.getIdentifier())) {
-            parentUser = um.getProfileParent(userToBind);
-        }
+        UserHandle parentUser = um.getProfileParent(userToBind);
 
         // Track the call if we don't already know about it.
         addCall(call);
@@ -2143,7 +2165,7 @@ public class InCallController extends CallsManagerListenerBase implements
 
         mBtBindingFuture.put(userToBind, new CompletableFuture<Boolean>().completeOnTimeout(false,
                 mTimeoutsAdapter.getCallBindBluetoothInCallServicesDelay(
-                        mContext.getContentResolver()), TimeUnit.MILLISECONDS));
+                        mContext, mFeatureFlags), TimeUnit.MILLISECONDS));
         InCallServiceBindingConnection btIcsBindingConnection =
                 new InCallServiceBindingConnection(infos.get(0),
                         serviceUnavailableForUser ? parentUser : userToBind);
@@ -2163,12 +2185,7 @@ public class InCallController extends CallsManagerListenerBase implements
     public void bindToServices(Call call) {
         UserHandle userFromCall = getUserFromCall(call);
         UserManager um = mContext.getSystemService(UserManager.class);
-        UserHandle parentUser = mFeatureFlags.profileUserSupport()
-                ? um.getProfileParent(userFromCall) : null;
-        if (!mFeatureFlags.profileUserSupport()
-                && um.isManagedProfile(userFromCall.getIdentifier())) {
-            parentUser = um.getProfileParent(userFromCall);
-        }
+        UserHandle parentUser = um.getProfileParent(userFromCall);
         Log.i(this, "child:%s  parent:%s", userFromCall, parentUser);
 
         if (!mInCallServiceConnections.containsKey(userFromCall)) {
@@ -2228,7 +2245,7 @@ public class InCallController extends CallsManagerListenerBase implements
             connectToNonUiInCallServices(call);
             mBindingFuture = new CompletableFuture<Boolean>().completeOnTimeout(false,
                     mTimeoutsAdapter.getCallRemoveUnbindInCallServicesDelay(
-                            mContext.getContentResolver()),
+                            mContext, mFeatureFlags),
                     TimeUnit.MILLISECONDS);
         } else {
             Log.i(this, "bindToServices: current UI doesn't support call; not binding.");
@@ -2236,21 +2253,21 @@ public class InCallController extends CallsManagerListenerBase implements
 
         IntentFilter packageChangedFilter = new IntentFilter(Intent.ACTION_PACKAGE_CHANGED);
         packageChangedFilter.addDataScheme("package");
-        mContext.registerReceiverAsUser(mPackageChangedReceiver, UserHandle.ALL,
-                packageChangedFilter, null, null);
+        Context userContext = mContext.createContextAsUser(UserHandle.ALL, 0);
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            userContext.registerReceiver(mPackageChangedReceiver, packageChangedFilter,
+                    null, null);
+        } else {
+            mContext.registerReceiverAsUser(mPackageChangedReceiver, UserHandle.ALL,
+                    packageChangedFilter, null, null);
+        }
     }
 
     private void updateNonUiInCallServices(Call call) {
         UserHandle userFromCall = getUserFromCall(call);
 
         UserManager um = mContext.getSystemService(UserManager.class);
-        UserHandle parentUser = mFeatureFlags.profileUserSupport()
-                ? um.getProfileParent(userFromCall) : null;
-
-        if (!mFeatureFlags.profileUserSupport()
-                && um.isManagedProfile(userFromCall.getIdentifier())) {
-            parentUser = um.getProfileParent(userFromCall);
-        }
+        UserHandle parentUser = um.getProfileParent(userFromCall);
 
         List<InCallServiceInfo> nonUIInCallComponents =
                 getInCallServiceComponents(userFromCall, IN_CALL_SERVICE_TYPE_NON_UI);
@@ -2431,11 +2448,19 @@ public class InCallController extends CallsManagerListenerBase implements
         PackageManager userPackageManager = userContext != null ?
                 userContext.getPackageManager() : packageManager;
 
-
-        for (ResolveInfo entry : packageManager.queryIntentServicesAsUser(
-                serviceIntent,
-                PackageManager.GET_META_DATA | PackageManager.MATCH_DISABLED_COMPONENTS,
-                userHandle.getIdentifier())) {
+        List<ResolveInfo> entries;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            entries = userPackageManager.queryIntentServicesAsUser(
+                    serviceIntent,
+                    PackageManager.GET_META_DATA | PackageManager.MATCH_DISABLED_COMPONENTS,
+                    userHandle.getIdentifier());
+        } else {
+            entries = packageManager.queryIntentServicesAsUser(
+                    serviceIntent,
+                    PackageManager.GET_META_DATA | PackageManager.MATCH_DISABLED_COMPONENTS,
+                    userHandle.getIdentifier());
+        }
+        for (ResolveInfo entry : entries) {
             ServiceInfo serviceInfo = entry.serviceInfo;
 
             if (serviceInfo != null) {
@@ -2568,8 +2593,8 @@ public class InCallController extends CallsManagerListenerBase implements
         }
 
         boolean processingBluetoothPackage = isBluetoothPackage(serviceInfo.packageName);
-        if (mFeatureFlags.separatelyBindToBtIncallService() && processingBluetoothPackage
-                && (hasControlInCallPermission || hasAppOpsPermittedManageOngoingCalls)) {
+        if (processingBluetoothPackage && (hasControlInCallPermission
+                || hasAppOpsPermittedManageOngoingCalls)) {
             return IN_CALL_SERVICE_TYPE_BLUETOOTH;
         }
 
@@ -2613,10 +2638,10 @@ public class InCallController extends CallsManagerListenerBase implements
             trackCallingUserInterfaceStarted(info);
         }
         IInCallService inCallService = IInCallService.Stub.asInterface(service);
-        if (mFeatureFlags.separatelyBindToBtIncallService()
-                && info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH) {
+        if (info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH) {
             if (!mBtBindingFuture.containsKey(userHandle)
-                    || mBtBindingFuture.get(userHandle).isDone()) {
+                    || (mBtBindingFuture.get(userHandle).isDone() && !mBtBindingFuture
+                    .get(userHandle).getNow(false))) {
                 Log.i(this, "onConnected: BT binding future timed out.");
                 // Binding completed after the timeout. Clean up this binding
                 return false;
@@ -2629,9 +2654,7 @@ public class InCallController extends CallsManagerListenerBase implements
             mInCallServices.get(userHandle).put(info, inCallService);
         }
 
-        if (mFeatureFlags.separatelyBindToBtIncallService()) {
-            updateCombinedInCallServiceMap(userHandle);
-        }
+        updateCombinedInCallServiceMap(userHandle);
 
         try {
             inCallService.setInCallAdapter(
@@ -2660,10 +2683,8 @@ public class InCallController extends CallsManagerListenerBase implements
         try {
             inCallService.onCallAudioStateChanged(mCallsManager.getAudioState());
             inCallService.onCanAddCallChanged(mCallsManager.canAddCall());
-            if (mFeatureFlags.onCallEndpointChangedIcsOnConnected()) {
-                inCallService.onCallEndpointChanged(mCallsManager.getCallEndpointController()
-                        .getCurrentCallEndpoint());
-            }
+            inCallService.onCallEndpointChanged(mCallsManager.getCallEndpointController()
+                    .getCurrentCallEndpoint());
         } catch (RemoteException ignored) {
         }
         // Don't complete the binding future for non-ui incalls
@@ -2700,8 +2721,10 @@ public class InCallController extends CallsManagerListenerBase implements
                     mCallsManager.getPhoneAccountRegistrar(),
                     info.isExternalCallsSupported(),
                     includeRttCall,
-                    info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI ||
-                            info.getType() == IN_CALL_SERVICE_TYPE_NON_UI);
+                    info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI
+                            || info.getType() == IN_CALL_SERVICE_TYPE_NON_UI
+                            || info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH,
+                    info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH);
             if (mFeatureFlags.doNotSendCallToNullIcs()) {
                 if (inCallService != null) {
                     inCallService.addCall(sanitizeParcelableCallForService(info, parcelableCall));
@@ -2738,8 +2761,7 @@ public class InCallController extends CallsManagerListenerBase implements
         if (mInCallServices.containsKey(userHandle)) {
             mInCallServices.get(userHandle).remove(disconnectedInfo);
         }
-        if (mFeatureFlags.separatelyBindToBtIncallService()
-                && disconnectedInfo.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH) {
+        if (disconnectedInfo.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH) {
             mBTInCallServices.remove(userHandle);
             updateCombinedInCallServiceMap(userHandle);
         }
@@ -2804,8 +2826,10 @@ public class InCallController extends CallsManagerListenerBase implements
                         info.isExternalCallsSupported(),
                         rttInfoChanged && info.equals(
                                 mInCallServiceConnections.get(userFromCall).getInfo()),
-                        info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI ||
-                        info.getType() == IN_CALL_SERVICE_TYPE_NON_UI);
+                        info.getType() == IN_CALL_SERVICE_TYPE_SYSTEM_UI
+                                || info.getType() == IN_CALL_SERVICE_TYPE_NON_UI
+                                || info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH,
+                        info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH);
                 IInCallService inCallService = entry.getValue();
                 boolean isDisconnectingBtIcs = info.getType() == IN_CALL_SERVICE_TYPE_BLUETOOTH
                         && call.getState() == CallState.DISCONNECTED;
@@ -2884,9 +2908,7 @@ public class InCallController extends CallsManagerListenerBase implements
         if (mCallIdMapper.getCallId(call) == null) {
             mCallIdMapper.addCall(call);
             call.addListener(mCallListener);
-            if (mFeatureFlags.separatelyBindToBtIncallService()) {
-                mBtIcsCallTracker.add(call);
-            }
+            mBtIcsCallTracker.add(call);
         }
 
         maybeTrackMicrophoneUse(isMuted());
@@ -3005,10 +3027,18 @@ public class InCallController extends CallsManagerListenerBase implements
         }
 
         Intent intent = new Intent(InCallService.SERVICE_INTERFACE)
-            .setPackage(ringingPackage);
-        List<ResolveInfo> entries = mContext.getPackageManager().queryIntentServicesAsUser(
-                intent, PackageManager.GET_META_DATA,
-                userHandle.getIdentifier());
+                .setPackage(ringingPackage);
+        List<ResolveInfo> entries;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            entries = UserUtil.getPackageManagerFromUserHandler(mContext,
+                    userHandle).queryIntentServicesAsUser(
+                    intent, PackageManager.GET_META_DATA,
+                    userHandle.getIdentifier());
+        } else {
+            entries = mContext.getPackageManager().queryIntentServicesAsUser(
+                    intent, PackageManager.GET_META_DATA,
+                    userHandle.getIdentifier());
+        }
         if (entries.isEmpty()) {
             Log.w(this, "doesConnectedDialerSupportRinging: couldn't find dialer's package info"
                     + " <sad trombone>");
@@ -3243,12 +3273,22 @@ public class InCallController extends CallsManagerListenerBase implements
             int opPackageUid = getOpPackageUid();
             if (mIsCallUsingMicrophone) {
                 // Note, not checking return value, as this op call is merely for tracing use
-                mAppOpsManager.startOp(AppOpsManager.OP_PHONE_CALL_MICROPHONE, opPackageUid,
-                        mContext.getOpPackageName(), false, null, null);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    mAppOpsManager.startOp(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE, opPackageUid,
+                            mContext.getOpPackageName(), null /* attribution */, null /* msg */);
+                } else {
+                    mAppOpsManager.startOp(AppOpsManager.OP_PHONE_CALL_MICROPHONE, opPackageUid,
+                            mContext.getOpPackageName(), false, null, null);
+                }
                 mSensorPrivacyManager.showSensorUseDialog(SensorPrivacyManager.Sensors.MICROPHONE);
             } else {
-                mAppOpsManager.finishOp(AppOpsManager.OP_PHONE_CALL_MICROPHONE, opPackageUid,
-                        mContext.getOpPackageName(), null);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    mAppOpsManager.finishOp(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE, opPackageUid,
+                            mContext.getOpPackageName(), null /* attribution */);
+                } else {
+                    mAppOpsManager.finishOp(AppOpsManager.OP_PHONE_CALL_MICROPHONE, opPackageUid,
+                            mContext.getOpPackageName(), null);
+                }
             }
         }
     }
@@ -3277,8 +3317,15 @@ public class InCallController extends CallsManagerListenerBase implements
      */
     private boolean isTrackingManagedAliveCall() {
         return mCallIdMapper.getCalls().stream().anyMatch(c -> !c.isExternalCall()
-            && !c.isSelfManaged() && c.isAlive() && ArrayUtils.contains(LIVE_CALL_STATES,
-                c.getState()));
+                && !c.isSelfManaged() && c.isAlive() && isCallInLiveCallState(c));
+    }
+
+    private boolean isCallInLiveCallState(Call call) {
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            return IntStream.of(LIVE_CALL_STATES).anyMatch(element -> element == call.getState());
+        } else {
+            return ArrayUtils.contains(LIVE_CALL_STATES, call.getState());
+        }
     }
 
     private boolean isCarrierPrivilegedUsingMicDuringVoipCall() {
@@ -3297,13 +3344,29 @@ public class InCallController extends CallsManagerListenerBase implements
     }
 
     private boolean isAppOpsPermittedManageOngoingCalls(int uid, String callingPackage) {
-        return PermissionChecker.checkPermissionForDataDeliveryFromDataSource(mContext,
-                Manifest.permission.MANAGE_ONGOING_CALLS, PermissionChecker.PID_UNKNOWN,
-                        new AttributionSource(mContext.getAttributionSource(),
-                                new AttributionSource(uid, callingPackage,
-                                        /*attributionTag*/ null)), "Checking whether the app has"
-                                                + " MANAGE_ONGOING_CALLS permission")
-                                                        == PermissionChecker.PERMISSION_GRANTED;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            // checkPermissionForDataDelivery is intended for use when we are checking the
+            // permission for the purpose of actually sending data to the recipient; this is in
+            // contrast to in TelecomServiceImpl#hasManageOngoingCallsPermission which calls
+            // checkPermissionForPreflight since that is not actually going to result in data
+            // delivery to the app.
+            int result = mPermissionManager.checkPermissionForDataDelivery(
+                    Manifest.permission.MANAGE_ONGOING_CALLS, new AttributionSource.Builder(uid)
+                            .setPackageName(callingPackage)
+                            .build(),
+                    "Reporting ongoing calls to app.");
+            Log.d(this, "isAppOpsPermittedManageOngoingCalls: uid=%d, pkg=%s, res=%d", uid,
+                    callingPackage, result);
+            return result == PermissionManager.PERMISSION_GRANTED;
+        } else {
+            return PermissionChecker.checkPermissionForDataDeliveryFromDataSource(mContext,
+                    Manifest.permission.MANAGE_ONGOING_CALLS, PermissionChecker.PID_UNKNOWN,
+                    new AttributionSource(mContext.getAttributionSource(),
+                            new AttributionSource(uid, callingPackage,
+                                    /*attributionTag*/ null)), "Checking whether the app has"
+                            + " MANAGE_ONGOING_CALLS permission")
+                    == PermissionChecker.PERMISSION_GRANTED;
+        }
     }
 
     private void sendCrashedInCallServiceNotification(String packageName, UserHandle userHandle) {
@@ -3322,8 +3385,6 @@ public class InCallController extends CallsManagerListenerBase implements
         } catch (PackageManager.NameNotFoundException e) {
             appName = packageName;
         }
-        NotificationManager notificationManager = (NotificationManager) mContext
-                .getSystemService(Context.NOTIFICATION_SERVICE);
         Notification.Builder builder = new Notification.Builder(mContext,
                 NotificationChannelManager.CHANNEL_ID_IN_CALL_SERVICE_CRASH);
         builder.setSmallIcon(R.drawable.ic_phone)
@@ -3334,8 +3395,8 @@ public class InCallController extends CallsManagerListenerBase implements
                 .setStyle(new Notification.BigTextStyle()
                         .bigText(mContext.getText(
                                 R.string.notification_incallservice_not_responding_body)));
-        notificationManager.notifyAsUser(NOTIFICATION_TAG, IN_CALL_SERVICE_NOTIFICATION_ID,
-                builder.build(), userHandle);
+        UserUtil.processNotification(mContext, userHandle, NOTIFICATION_TAG,
+                IN_CALL_SERVICE_NOTIFICATION_ID, builder.build(), mFeatureFlags);
     }
 
     private void updateCallTracking(Call call, InCallServiceInfo info, boolean isAdd) {
@@ -3394,8 +3455,7 @@ public class InCallController extends CallsManagerListenerBase implements
         }
         // If early binding for BT ICS is enabled, ensure that it is included into consideration as
         // a bound non-UI ICS.
-        return mFeatureFlags.separatelyBindToBtIncallService() && !mBTInCallServices.isEmpty()
-                && isBluetoothPackage(packageName);
+        return !mBTInCallServices.isEmpty() && isBluetoothPackage(packageName);
     }
 
     private void updateCombinedInCallServiceMap(UserHandle user) {
@@ -3406,8 +3466,7 @@ public class InCallController extends CallsManagerListenerBase implements
             } else {
                 serviceMap = new HashMap<>();
             }
-            if (mFeatureFlags.separatelyBindToBtIncallService()
-                    && mBTInCallServices.containsKey(user)) {
+            if (mBTInCallServices.containsKey(user)) {
                 Pair<InCallServiceInfo, IInCallService> btServicePair = mBTInCallServices.get(user);
                 serviceMap.put(btServicePair.first, btServicePair.second);
             }
@@ -3422,11 +3481,7 @@ public class InCallController extends CallsManagerListenerBase implements
     private Map<UserHandle,
             Map<InCallController.InCallServiceInfo, IInCallService>> getCombinedInCallServiceMap() {
         synchronized (mLock) {
-            if (mFeatureFlags.separatelyBindToBtIncallService()) {
-                return mCombinedInCallServiceMap;
-            } else {
-                return mInCallServices;
-            }
+            return mCombinedInCallServiceMap;
         }
     }
 
diff --git a/src/com/android/server/telecom/InCallTonePlayer.java b/src/com/android/server/telecom/InCallTonePlayer.java
index 2bc1e3918..2feecf795 100644
--- a/src/com/android/server/telecom/InCallTonePlayer.java
+++ b/src/com/android/server/telecom/InCallTonePlayer.java
@@ -375,7 +375,7 @@ public class InCallTonePlayer extends Thread {
                     throw new IllegalStateException("Bad toneId: " + mToneId);
             }
 
-            int stream = getStreamType(toneType);
+            int stream = AudioManager.STREAM_VOICE_CALL;
             if (toneType != ToneGenerator.TONE_UNKNOWN) {
                 playToneGeneratorTone(stream, toneVolume, toneType, toneLengthMillis);
             } else if (mediaResourceId != TONE_RESOURCE_ID_UNDEFINED) {
@@ -387,31 +387,6 @@ public class InCallTonePlayer extends Thread {
         }
     }
 
-    /**
-     * @param toneType The ToneGenerator tone type
-     * @return The ToneGenerator stream type
-     */
-    private int getStreamType(int toneType) {
-        if (mFeatureFlags.useStreamVoiceCallTones()) {
-            return AudioManager.STREAM_VOICE_CALL;
-        }
-
-        int stream = AudioManager.STREAM_VOICE_CALL;
-        if (mCallAudioRoutePeripheralAdapter.isBluetoothAudioOn()) {
-            stream = AudioManager.STREAM_BLUETOOTH_SCO;
-        }
-        if (toneType != ToneGenerator.TONE_UNKNOWN) {
-            if (stream == AudioManager.STREAM_BLUETOOTH_SCO) {
-                // Override audio stream for BT le device and hearing aid device
-                if (mCallAudioRoutePeripheralAdapter.isLeAudioDeviceOn()
-                        || mCallAudioRoutePeripheralAdapter.isHearingAidDeviceOn()) {
-                    stream = AudioManager.STREAM_VOICE_CALL;
-                }
-            }
-        }
-        return stream;
-    }
-
     /**
      * Play a tone generated by the {@link ToneGenerator}.
      * @param stream The stream on which the tone will be played.
diff --git a/src/com/android/server/telecom/LogUtils.java b/src/com/android/server/telecom/LogUtils.java
index d927f8f45..e309d2202 100644
--- a/src/com/android/server/telecom/LogUtils.java
+++ b/src/com/android/server/telecom/LogUtils.java
@@ -88,6 +88,7 @@ public class LogUtils {
         public static final String CSW_REMOVE_CALL = "CSW.rC";
         public static final String CSW_SET_IS_CONFERENCED = "CSW.sIC";
         public static final String CSW_ADD_CONFERENCE_CALL = "CSW.aCC";
+        public static final String CSW_ADD_CONFERENCE_CALL_FROM_CONN = "CSW.aCCFC";
         public static final String CSA_SET_STATE = "CSA.sSS";
     }
 
diff --git a/src/com/android/server/telecom/LoggedExecutor.java b/src/com/android/server/telecom/LoggedExecutor.java
new file mode 100644
index 000000000..3c92ae92e
--- /dev/null
+++ b/src/com/android/server/telecom/LoggedExecutor.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.telecom;
+
+import android.telecom.Logging.Runnable;
+
+import java.util.concurrent.Executor;
+
+/** An executor that starts a log session before executing a runnable */
+public class LoggedExecutor implements Executor {
+    private final Executor mDelegateExecutor;
+    private final String mSessionName;
+    private final Object mLock;
+
+    /**
+     * Creates a LoggedExecutor that wraps another executor to provide session-based logging
+     * for submitted tasks using Telecom's custom Runnable.
+     *
+     * @param delegateExecutor The actual executor that will run the tasks.
+     * @param sessionName The name for the logging subsession.
+     * @param lock The synchronization lock. If null, the custom Runnable will create its own.
+     */
+    public LoggedExecutor(Executor delegateExecutor, String sessionName, Object lock) {
+        this.mDelegateExecutor = delegateExecutor;
+        this.mSessionName = sessionName;
+        this.mLock = lock;
+    }
+
+    @Override
+    public void execute(java.lang.Runnable command) {
+        Runnable telecomSessionRunnable = new Runnable(mSessionName, mLock) {
+            @Override
+            public void loggedRun() {
+                command.run();
+            }
+        };
+
+        // telecomSessionRunnable.prepare:
+        //      a. Calls Log.createSubsession() and stores the session.
+        //      b. Returns the *inner* mRunnable (a standard java.lang.Runnable).
+        java.lang.Runnable preparedInnerRunnable = telecomSessionRunnable.prepare();
+
+        // Submit this 'preparedInnerRunnable' to the mDelegateExecutor.
+        //    The run() method of 'preparedInnerRunnable' will handle continuing the session,
+        //    calling the loggedRun() we defined above, and then ending the session.
+        mDelegateExecutor.execute(preparedInnerRunnable);
+    }
+}
\ No newline at end of file
diff --git a/src/com/android/server/telecom/MultiLineTitleEditTextPreference.java b/src/com/android/server/telecom/MultiLineTitleEditTextPreference.java
index d94dc603f..30017f344 100644
--- a/src/com/android/server/telecom/MultiLineTitleEditTextPreference.java
+++ b/src/com/android/server/telecom/MultiLineTitleEditTextPreference.java
@@ -23,6 +23,8 @@ import android.view.View;
 import android.widget.TextView;
 
 /**
+ * This class is used in respond_via_sms_settings.xml
+ *
  * Ultra-simple subclass of EditTextPreference that allows the "title" to wrap
  * onto multiple lines.
  *
@@ -31,10 +33,6 @@ import android.widget.TextView;
  * settings UI we want titles to be multi-line, since the customized messages
  * might be fairly long, and should be able to wrap.)
  *
- * TODO: This is pretty cumbersome; it would be nicer for the framework to
- * either allow modifying the title's attributes in XML, or at least provide
- * some way from Java (given an EditTextPreference) to reach inside and get a
- * handle to the "title" TextView.
  *
  * TODO: Also, it would reduce clutter if this could be an inner class in
  * RespondViaSmsManager.java, but then there would be no way to reference the
@@ -45,29 +43,22 @@ import android.widget.TextView;
  * <view class="com.android.server.telecom.Foo$Bar"> as you can with regular views.
  */
 public class MultiLineTitleEditTextPreference extends EditTextPreference {
-    public MultiLineTitleEditTextPreference(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
+    public MultiLineTitleEditTextPreference(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init();
     }
 
     public MultiLineTitleEditTextPreference(Context context, AttributeSet attrs) {
         super(context, attrs);
+        init();
     }
 
     public MultiLineTitleEditTextPreference(Context context) {
         super(context);
+        init();
     }
 
-    // The "title" TextView inside an EditTextPreference defaults to
-    // singleLine="true" (see preference_holo.xml under frameworks/base.)
-    // We override onBindView() purely to look up that TextView and call
-    // setSingleLine(false) on it.
-    @Override
-    protected void onBindView(View view) {
-        super.onBindView(view);
-
-        TextView textView = (TextView) view.findViewById(com.android.internal.R.id.title);
-        if (textView != null) {
-            textView.setSingleLine(false);
-        }
+    private void init() {
+        setLayoutResource(com.android.server.telecom.R.layout.preference_multiline_title_edittext);
     }
 }
diff --git a/src/com/android/server/telecom/NewOutgoingCallIntentBroadcaster.java b/src/com/android/server/telecom/NewOutgoingCallIntentBroadcaster.java
index fce3f1a69..7f16e62c6 100644
--- a/src/com/android/server/telecom/NewOutgoingCallIntentBroadcaster.java
+++ b/src/com/android/server/telecom/NewOutgoingCallIntentBroadcaster.java
@@ -40,8 +40,6 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.callredirection.CallRedirectionProcessor;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * OutgoingCallIntentBroadcaster receives CALL and CALL_PRIVILEGED Intents, and broadcasts the
  * ACTION_NEW_OUTGOING_CALL intent. ACTION_NEW_OUTGOING_CALL is an ordered broadcast intent which
@@ -115,88 +113,6 @@ public class NewOutgoingCallIntentBroadcaster {
         mFeatureFlags = featureFlags;
     }
 
-    /**
-     * Processes the result of the outgoing call broadcast intent, and performs callbacks to
-     * the OutgoingCallIntentBroadcasterListener as necessary.
-     */
-    public class NewOutgoingCallBroadcastIntentReceiver extends BroadcastReceiver {
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            try {
-                Log.startSession("NOCBIR.oR");
-                synchronized (mLock) {
-                    Log.v(this, "onReceive: %s", intent);
-
-                    // Once the NEW_OUTGOING_CALL broadcast is finished, the resultData is
-                    // used as the actual number to call. (If null, no call will be placed.)
-                    String resultNumber = getResultData();
-                    Log.i(NewOutgoingCallIntentBroadcaster.this,
-                            "Received new-outgoing-call-broadcast for %s with data %s", mCall,
-                            Log.pii(resultNumber));
-
-                    boolean endEarly = false;
-                    long disconnectTimeout =
-                            Timeouts.getNewOutgoingCallCancelMillis(mContext.getContentResolver());
-                    if (resultNumber == null) {
-                        Log.v(this, "Call cancelled (null number), returning...");
-                        disconnectTimeout = getDisconnectTimeoutFromApp(
-                                getResultExtras(false), disconnectTimeout);
-                        endEarly = true;
-                    } else if (isEmergencyNumber(resultNumber)) {
-                        Log.w(this, "Cannot modify outgoing call to emergency number %s.",
-                                resultNumber);
-                        disconnectTimeout = 0;
-                        endEarly = true;
-                    }
-
-                    if (endEarly) {
-                        if (mCall != null) {
-                            mCall.disconnect(disconnectTimeout);
-                        }
-                        return;
-                    }
-
-                    // If this call is already disconnected then we have nothing more to do.
-                    if (mCall.isDisconnected()) {
-                        Log.w(this, "Call has already been disconnected," +
-                                        " ignore the broadcast Call %s", mCall);
-                        return;
-                    }
-
-                    // TODO: Remove the assumption that phone numbers are either SIP or TEL.
-                    // This does not impact self-managed ConnectionServices as they do not use the
-                    // NewOutgoingCallIntentBroadcaster.
-                    Uri resultHandleUri = Uri.fromParts(
-                            mPhoneNumberUtilsAdapter.isUriNumber(resultNumber) ?
-                                    PhoneAccount.SCHEME_SIP : PhoneAccount.SCHEME_TEL,
-                            resultNumber, null);
-
-                    Uri originalUri = mIntent.getData();
-
-                    if (originalUri.getSchemeSpecificPart().equals(resultNumber)) {
-                        Log.v(this, "Call number unmodified after" +
-                                " new outgoing call intent broadcast.");
-                    } else {
-                        Log.v(this, "Retrieved modified handle after outgoing call intent" +
-                                " broadcast: Original: %s, Modified: %s",
-                                Log.pii(originalUri),
-                                Log.pii(resultHandleUri));
-                    }
-
-                    GatewayInfo gatewayInfo = getGateWayInfoFromIntent(intent, resultHandleUri);
-                    placeOutgoingCallImmediately(mCall, resultHandleUri, gatewayInfo,
-                            mIntent.getBooleanExtra(
-                                    TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE, false),
-                            mIntent.getIntExtra(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE,
-                                    VideoProfile.STATE_AUDIO_ONLY));
-                }
-            } finally {
-                Log.endSession();
-            }
-        }
-    }
-
     /**
      * Processes the supplied intent and starts the outgoing call broadcast process relevant to the
      * intent.
@@ -355,13 +271,6 @@ public class NewOutgoingCallIntentBroadcaster {
 
     public void processCall(Call call, CallDisposition disposition) {
         mCall = call;
-
-        // If the new outgoing call broadast doesn't block, trigger the legacy process call
-        // behavior and exit out here.
-        if (!mFeatureFlags.isNewOutgoingCallBroadcastUnblocking()) {
-            legacyProcessCall(disposition);
-            return;
-        }
         boolean callRedirectionWithService = false;
         // Only try to do redirection if it was requested and we're not calling immediately.
         // We can expect callImmediately to be true for emergency calls and voip calls.
@@ -373,7 +282,7 @@ public class NewOutgoingCallIntentBroadcaster {
                     mIntent.getBooleanExtra(TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE,
                             false),
                     mIntent.getIntExtra(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE,
-                            VideoProfile.STATE_AUDIO_ONLY));
+                            VideoProfile.STATE_AUDIO_ONLY), mFeatureFlags);
             /**
              * If there is an available {@link android.telecom.CallRedirectionService}, use the
              * {@link CallRedirectionProcessor} to perform call redirection instead of using
@@ -398,50 +307,6 @@ public class NewOutgoingCallIntentBroadcaster {
         }
     }
 
-    /**
-     * The legacy non-flagged version of processing a call.  Although there is some code duplication
-     * if makes the new flow cleaner to read.
-     * @param disposition
-     */
-    private void legacyProcessCall(CallDisposition disposition) {
-        if (disposition.callImmediately) {
-            callImmediately(disposition);
-
-            // Don't return but instead continue and send the ACTION_NEW_OUTGOING_CALL broadcast
-            // so that third parties can still inspect (but not intercept) the outgoing call. When
-            // the broadcast finally reaches the OutgoingCallBroadcastReceiver, we'll know not to
-            // initiate the call again because of the presence of the EXTRA_ALREADY_CALLED extra.
-        }
-
-        boolean callRedirectionWithService = false;
-        if (disposition.requestRedirection) {
-            CallRedirectionProcessor callRedirectionProcessor = new CallRedirectionProcessor(
-                    mContext, mCallsManager, mCall, disposition.callingAddress,
-                    mCallsManager.getPhoneAccountRegistrar(),
-                    getGateWayInfoFromIntent(mIntent, mIntent.getData()),
-                    mIntent.getBooleanExtra(TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE,
-                            false),
-                    mIntent.getIntExtra(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE,
-                            VideoProfile.STATE_AUDIO_ONLY));
-            /**
-             * If there is an available {@link android.telecom.CallRedirectionService}, use the
-             * {@link CallRedirectionProcessor} to perform call redirection instead of using
-             * broadcasting.
-             */
-            callRedirectionWithService = callRedirectionProcessor
-                    .canMakeCallRedirectionWithServiceAsUser(mCall.getAssociatedUser());
-            if (callRedirectionWithService) {
-                callRedirectionProcessor.performCallRedirection(mCall.getAssociatedUser());
-            }
-        }
-
-        if (disposition.sendBroadcast) {
-            UserHandle targetUser = mCall.getAssociatedUser();
-            broadcastIntent(mIntent, disposition.number,
-                    !disposition.callImmediately && !callRedirectionWithService, targetUser);
-        }
-    }
-
     /**
      * Place a call immediately.
      * @param disposition The disposition; used for retrieving the address of the call.
@@ -479,46 +344,22 @@ public class NewOutgoingCallIntentBroadcaster {
 
         checkAndCopyProviderExtras(originalCallIntent, broadcastIntent);
 
-        if (mFeatureFlags.isNewOutgoingCallBroadcastUnblocking()) {
-            // Where the new outgoing call broadcast is unblocking, do not give receiver FG priority
-            // and do not allow background activity starts.
-            broadcastIntent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
-            Log.i(this, "broadcastIntent: Sending non-blocking for %s to %s", mCall.getId(),
-                    targetUser);
-            if (mFeatureFlags.telecomResolveHiddenDependencies()) {
-                mContext.sendBroadcastAsUser(
-                        broadcastIntent,
-                        targetUser,
-                        Manifest.permission.PROCESS_OUTGOING_CALLS);
-            } else {
-                mContext.sendBroadcastAsUser(
-                        broadcastIntent,
-                        targetUser,
-                        android.Manifest.permission.PROCESS_OUTGOING_CALLS,
-                        AppOpsManager.OP_PROCESS_OUTGOING_CALLS);  // initialExtras
-            }
+        // The new outgoing call broadcast is unblocking, do not give receiver FG priority
+        // and do not allow background activity starts.
+        broadcastIntent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
+        Log.i(this, "broadcastIntent: Sending non-blocking for %s to %s", mCall.getId(),
+                targetUser);
+        if (mFeatureFlags.telecomResolveHiddenDependencies()) {
+            mContext.sendBroadcastAsUser(
+                    broadcastIntent,
+                    targetUser,
+                    Manifest.permission.PROCESS_OUTGOING_CALLS);
         } else {
-            Log.i(this, "broadcastIntent: Sending ordered for %s to %s, waitForResult=%b",
-                    mCall.getId(), targetUser, receiverRequired);
-            final BroadcastOptions options = BroadcastOptions.makeBasic();
-            options.setBackgroundActivityStartsAllowed(true);
-            // Force receivers of this broadcast intent to run at foreground priority because we
-            // want to finish processing the broadcast intent as soon as possible.
-            broadcastIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND
-                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
-
-            mContext.sendOrderedBroadcastAsUser(
+            mContext.sendBroadcastAsUser(
                     broadcastIntent,
                     targetUser,
                     android.Manifest.permission.PROCESS_OUTGOING_CALLS,
-                    AppOpsManager.OP_PROCESS_OUTGOING_CALLS,
-                    options.toBundle(),
-                    receiverRequired ? new NewOutgoingCallBroadcastIntentReceiver() : null,
-                    null,  // scheduler
-                    Activity.RESULT_OK,  // initialCode
-                    number,  // initialData: initial value for the result data (number to be
-                             // modified)
-                    null);  // initialExtras
+                    AppOpsManager.OP_PROCESS_OUTGOING_CALLS);  // initialExtras
         }
     }
 
@@ -663,7 +504,7 @@ public class NewOutgoingCallIntentBroadcaster {
                 disconnectTimeout = 0;
             }
             return Math.min(disconnectTimeout,
-                    Timeouts.getMaxNewOutgoingCallCancelMillis(mContext.getContentResolver()));
+                    Timeouts.getMaxNewOutgoingCallCancelMillis(mContext, mFeatureFlags));
         } else {
             return defaultTimeout;
         }
diff --git a/src/com/android/server/telecom/PackageRemovedReceiver.java b/src/com/android/server/telecom/PackageRemovedReceiver.java
new file mode 100644
index 000000000..2de6b640d
--- /dev/null
+++ b/src/com/android/server/telecom/PackageRemovedReceiver.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.server.telecom;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Process;
+import android.os.UserHandle;
+import android.telecom.PhoneAccount;
+
+import com.android.server.telecom.PhoneAccountRegistrar;
+
+import android.util.Log;
+
+public class PackageRemovedReceiver extends BroadcastReceiver {
+
+    private PhoneAccountRegistrar mPhoneAccountRegistrar;
+    private Handler mBackgroundHandler;
+    private static final String TAG = "PackageRemovedReceiver";
+    private UserHandleWrapper mUserHandleWrapper;
+
+    /**
+     * Default constructor required by Android.
+     */
+    public PackageRemovedReceiver() {
+        this(null, null, new UserHandleWrapper());
+    }
+
+    public PackageRemovedReceiver(PhoneAccountRegistrar phoneAccountRegistrar,
+                                  Handler backgroundHandler, UserHandleWrapper userHandleWrapper) {
+        mPhoneAccountRegistrar = phoneAccountRegistrar;
+        mBackgroundHandler = backgroundHandler;
+        mUserHandleWrapper = userHandleWrapper;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+
+        if (Intent.ACTION_PACKAGE_FULLY_REMOVED.equals(action)) {
+            Uri uri = intent.getData();
+            if (uri == null) {
+                Log.w(TAG, "Null URI in intent for " + action);
+                return;
+            }
+
+            final String packageName = uri.getSchemeSpecificPart();
+            if (packageName == null || packageName.isEmpty()) {
+                Log.w(TAG, "Null or empty package name for " + action);
+                return;
+            }
+
+            // Get the UID of the package that was removed.
+            // This UID includes the user ID.
+            final int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);
+            if (uid == Process.INVALID_UID) {
+                Log.i(TAG, "Invalid UID for packageName - Cannot determine user.");
+                return;
+            }
+
+            final UserHandle user = mUserHandleWrapper.getUserHandleForUid(uid);
+            Log.i(TAG, "Package " + packageName + " (UID: " + uid + ") fully removed" +
+                    " for user " + user);
+
+            if (mBackgroundHandler != null) {
+                mBackgroundHandler.post(() -> {
+                    handlePackageRemovedForUserInternal(packageName, user);
+                });
+            } else {
+                handlePackageRemovedForUserInternal(packageName, user);
+            }
+        }
+    }
+
+    /**
+     * Handles the removal of a package for a specific user by calling upon the
+     * {@link PhoneAccountRegistrar} to un-register any {@link android.telecom.PhoneAccount}s
+     * associated with the package for that user.
+     * (This method remains largely the same as in the previous "iterate all users" version,
+     * as it already operates on a specific user).
+     *
+     * @param packageName The name of the removed package.
+     * @param user        The UserHandle for whom to clear accounts.
+     */
+    private void handlePackageRemovedForUserInternal(
+            String packageName,
+            UserHandle user) {
+        if (mPhoneAccountRegistrar != null) {
+            mPhoneAccountRegistrar.clearAccounts(packageName, user);
+        } else {
+            Log.w(TAG, "PhoneAccountRegistrar not available to clear accounts for "
+                    + packageName + " (user " + user + ")");
+        }
+    }
+
+
+    // --- Helper methods for setting dependencies ---
+
+    /**
+     * Sets the PhoneAccountRegistrar. This is useful if you are registering the
+     * BroadcastReceiver dynamically and can't use a constructor with arguments.
+     * Make sure this is called before the receiver is expected to handle broadcasts
+     * if not using the constructor injection.
+     *
+     * @param registrar The PhoneAccountRegistrar instance.
+     */
+    public void setPhoneAccountRegistrar(PhoneAccountRegistrar registrar) {
+        this.mPhoneAccountRegistrar = registrar;
+    }
+
+    /**
+     * Sets the Handler.
+     *
+     * @param handler The Handler instance.
+     */
+    public void setTelecomSystemHandler(Handler handler) {
+        this.mBackgroundHandler = handler;
+    }
+
+    /**
+     * Sets the UserHandleWrapper.
+     *
+     * @param userHandle The UserHandleWrapper instance.
+     */
+    public void setUserHandleWrapper(UserHandleWrapper userHandle) {
+        this.mUserHandleWrapper = userHandle;
+    }
+}
+
diff --git a/src/com/android/server/telecom/ParcelableCallUtils.java b/src/com/android/server/telecom/ParcelableCallUtils.java
index 5764a9c1b..c79431982 100644
--- a/src/com/android/server/telecom/ParcelableCallUtils.java
+++ b/src/com/android/server/telecom/ParcelableCallUtils.java
@@ -74,12 +74,48 @@ public class ParcelableCallUtils {
         }
 
         public ParcelableCall toParcelableCallForScreening(Call call,
-                boolean areRestrictedExtrasIncluded) {
+                boolean areRestrictedExtrasIncluded, boolean includePhoneAccountHandle) {
             return ParcelableCallUtils.toParcelableCallForScreening(call,
-                    areRestrictedExtrasIncluded);
+                    areRestrictedExtrasIncluded, includePhoneAccountHandle);
         }
     }
 
+    /**
+     * Parcels all information for a {@link Call} into a new {@link ParcelableCall} instance.
+     *
+     * @param call The {@link Call} to parcel.
+     * @param includeVideoProvider {@code true} if the video provider should be parcelled with the
+     *      {@link Call}, {@code false} otherwise.  Since the {@link ParcelableCall#getVideoCall()}
+     *      method creates a {@link VideoCallImpl} instance on access it is important for the
+     *      recipient of the {@link ParcelableCall} to know if the video provider changed.
+     * @param phoneAccountRegistrar The {@link PhoneAccountRegistrar}.
+     * @param supportsExternalCalls Indicates whether the call should be parcelled for an
+     *      {@link InCallService} which supports external calls or not.
+     * @param includeRttCall {@code true} if the RTT call should be included, {@code false}
+     *      otherwise.
+     * @param isForSystemInCallService {@code true} if this call is being parcelled for the system incallservice,
+     *      {@code false} otherwise.  When parceling for the system incallservice, the entire call extras
+     *      is included.  When parceling for anything other than the system incallservice, some extra key
+     *      values will be stripped for privacy sake.
+     * @param isBluetoothInCallService {@code true} if this call is being parcelled for the BT ICS.
+     *      {@code false} otherwise. When we receive an ANSWERING call state, we will translate it
+     *      to {@link android.telecom.Call#STATE_ACTIVE}. If it's not the BT ICS, we will continue
+     *      to translate it to {@link android.telecom.Call#STATE_RINGING} to preserve backwards
+     *      compatibility.
+     */
+    public static ParcelableCall toParcelableCall(
+            Call call,
+            boolean includeVideoProvider,
+            PhoneAccountRegistrar phoneAccountRegistrar,
+            boolean supportsExternalCalls,
+            boolean includeRttCall,
+            boolean isForSystemInCallService,
+            boolean isBluetoothInCallService) {
+        return toParcelableCall(call, includeVideoProvider, phoneAccountRegistrar,
+                supportsExternalCalls, CALL_STATE_OVERRIDE_NONE /* overrideState */,
+                includeRttCall, isForSystemInCallService, isBluetoothInCallService);
+    }
+
     /**
      * Parcels all information for a {@link Call} into a new {@link ParcelableCall} instance.
      *
@@ -107,7 +143,7 @@ public class ParcelableCallUtils {
             boolean isForSystemInCallService) {
         return toParcelableCall(call, includeVideoProvider, phoneAccountRegistrar,
                 supportsExternalCalls, CALL_STATE_OVERRIDE_NONE /* overrideState */,
-                includeRttCall, isForSystemInCallService);
+                includeRttCall, isForSystemInCallService, false /* isBluetoothInCallService */);
     }
 
     /**
@@ -127,6 +163,12 @@ public class ParcelableCallUtils {
      *      {@code false} otherwise.  When parceling for the system incallservice, the entire call extras
      *      is included.  When parceling for anything other than the system incallservice, some extra key
      *      values will be stripped for privacy sake.
+     * @param isBluetoothInCallService {@code true} if this call is being parcelled for the BT ICS.
+     *      {@code false} otherwise. When we receive an ANSWERING call state, we will translate it
+     *      to {@link android.telecom.Call#STATE_ACTIVE}. If it's not the BT ICS, we will continue
+     *      to translate it to {@link android.telecom.Call#STATE_RINGING} to preserve backwards
+     *      compatibility.
+     *
      * @return The {@link ParcelableCall} containing all call information from the {@link Call}.
      */
     public static ParcelableCall toParcelableCall(
@@ -136,10 +178,11 @@ public class ParcelableCallUtils {
             boolean supportsExternalCalls,
             int overrideState,
             boolean includeRttCall,
-            boolean isForSystemInCallService) {
+            boolean isForSystemInCallService,
+            boolean isBluetoothInCallService) {
         int state;
         if (overrideState == CALL_STATE_OVERRIDE_NONE) {
-            state = getParcelableState(call, supportsExternalCalls);
+            state = getParcelableState(call, supportsExternalCalls, isBluetoothInCallService);
         } else {
             state = overrideState;
         }
@@ -272,11 +315,12 @@ public class ParcelableCallUtils {
      * {@link android.telecom.CallScreeningService}.  We ONLY expose the following:
      * <ul>
      *     <li>Call Id (not exposed to public, but needed to associated calls)</li>
-     *     <li>Call directoin</li>
+     *     <li>Call direction</li>
      *     <li>Creation time</li>
      *     <li>Connection time</li>
      *     <li>Handle (phone number)</li>
      *     <li>Handle (phone number) presentation</li>
+     *     <li>{@code PhoneAccountHandle}</li>
      *     <li>Caller number verification status (verstat)</li>
      * </ul>
      * All other fields are nulled or set to 0 values.
@@ -287,10 +331,12 @@ public class ParcelableCallUtils {
      * @param areRestrictedExtrasIncluded {@code true} if the set of restricted extras defined in
      *                                    {@link #RESTRICTED_CALL_SCREENING_EXTRA_KEYS} are to
      *                                    be included in the parceled call, {@code false} otherwise.
+     * @param includePhoneAccountHandle {@code true} if {@code PhoneAccountHandle} to be included
+     *                                    in the parceled call, {@code false} otherwise.
      * @return Minimal {@link ParcelableCall} to send to the call screening service.
      */
     public static ParcelableCall toParcelableCallForScreening(Call call,
-            boolean areRestrictedExtrasIncluded) {
+            boolean areRestrictedExtrasIncluded, boolean includePhoneAccountHandle) {
         Uri handle = call.getHandlePresentation() == TelecomManager.PRESENTATION_ALLOWED ?
                 call.getHandle() : null;
         int callDirection;
@@ -310,7 +356,8 @@ public class ParcelableCallUtils {
 
         return new ParcelableCall.ParcelableCallBuilder()
                 .setId(call.getId())
-                .setState(getParcelableState(call, false /* supportsExternalCalls */))
+                .setState(getParcelableState(call, false /* supportsExternalCalls */,
+                        false /* isBluetoothInCallService */))
                 .setDisconnectCause(new DisconnectCause(DisconnectCause.UNKNOWN))
                 .setCannedSmsResponses(null)
                 .setCapabilities(0)
@@ -322,7 +369,8 @@ public class ParcelableCallUtils {
                 .setCallerDisplayName(null)
                 .setCallerDisplayNamePresentation(0)
                 .setGatewayInfo(null)
-                .setAccountHandle(null)
+                .setAccountHandle(includePhoneAccountHandle ?
+                        call.getDelegatePhoneAccountHandle() : null)
                 .setIsVideoCallProviderChanged(false)
                 .setVideoCallProvider(null)
                 .setIsRttCallChanged(false)
@@ -390,7 +438,8 @@ public class ParcelableCallUtils {
         return extras;
     }
 
-    private static int getParcelableState(Call call, boolean supportsExternalCalls) {
+    private static int getParcelableState(Call call, boolean supportsExternalCalls,
+            boolean isBluetoothInCallService) {
         int state = CallState.NEW;
         switch (call.getParcelableCallState()) {
             case CallState.ABORTED:
@@ -429,8 +478,6 @@ public class ParcelableCallUtils {
                 state = android.telecom.Call.STATE_HOLDING;
                 break;
             case CallState.RINGING:
-            case CallState.ANSWERED:
-                // TODO: does in-call UI need to see ANSWERED?
                 state = android.telecom.Call.STATE_RINGING;
                 break;
             case CallState.SELECT_PHONE_ACCOUNT:
@@ -442,6 +489,11 @@ public class ParcelableCallUtils {
             case CallState.SIMULATED_RINGING:
                 state = android.telecom.Call.STATE_SIMULATED_RINGING;
                 break;
+            case CallState.ANSWERED:
+                state = isBluetoothInCallService
+                        ? android.telecom.Call.STATE_ACTIVE
+                        : android.telecom.Call.STATE_RINGING;
+                break;
         }
 
         return state;
diff --git a/src/com/android/server/telecom/PhoneAccountRegistrar.java b/src/com/android/server/telecom/PhoneAccountRegistrar.java
index c59cf2c11..4acaf1d38 100644
--- a/src/com/android/server/telecom/PhoneAccountRegistrar.java
+++ b/src/com/android/server/telecom/PhoneAccountRegistrar.java
@@ -56,7 +56,6 @@ import android.util.Base64;
 import android.util.EventLog;
 import android.util.Xml;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.util.IndentingPrintWriter;
@@ -418,20 +417,11 @@ public class PhoneAccountRegistrar {
         // Telecom are in sync.
         int newSubId = accountHandle == null ? SubscriptionManager.INVALID_SUBSCRIPTION_ID :
                 getSubscriptionIdForPhoneAccount(accountHandle);
-        if (Flags.onlyUpdateTelephonyOnValidSubIds()) {
-            if (shouldUpdateTelephonyDefaultVoiceSubId(accountHandle, isSimAccount, newSubId)) {
-                updateDefaultVoiceSubId(newSubId, accountHandle);
-            } else {
-                Log.i(this, "setUserSelectedOutgoingPhoneAccount: %s is not a sub", accountHandle);
-            }
+        if (shouldUpdateTelephonyDefaultVoiceSubId(accountHandle, isSimAccount, newSubId)) {
+            updateDefaultVoiceSubId(newSubId, accountHandle);
         } else {
-            if (isSimAccount || accountHandle == null) {
-                updateDefaultVoiceSubId(newSubId, accountHandle);
-            } else {
-                Log.i(this, "setUserSelectedOutgoingPhoneAccount: %s is not a sub", accountHandle);
-            }
+            Log.i(this, "setUserSelectedOutgoingPhoneAccount: %s is not a sub", accountHandle);
         }
-
         write();
         fireDefaultOutgoingChanged();
     }
@@ -811,7 +801,12 @@ public class PhoneAccountRegistrar {
 
     private List<ResolveInfo> resolveComponent(ComponentName componentName,
             UserHandle userHandle) {
-        PackageManager pm = mContext.getPackageManager();
+        PackageManager pm;
+        if (mTelecomFeatureFlags.resolveHiddenDependenciesTwo()) {
+            pm = UserUtil.getPackageManagerFromUserHandler(mContext, userHandle);
+        } else {
+            pm = mContext.getPackageManager();
+        }
         Intent intent = new Intent(ConnectionService.SERVICE_INTERFACE);
         intent.setComponent(componentName);
         try {
@@ -1339,9 +1334,8 @@ public class PhoneAccountRegistrar {
             // Ensure name is correct.
             CharSequence newLabel = mAppLabelProxy.getAppLabel(
                     account.getAccountHandle().getComponentName().getPackageName(),
-                    UserUtil.getAssociatedUserForCall(
-                            mTelecomFeatureFlags.associatedUserRefactorForWorkProfile(),
-                            this, UserHandle.CURRENT, account.getAccountHandle()));
+                    UserUtil.getAssociatedUserForCall(this, UserHandle.CURRENT,
+                            account.getAccountHandle()));
 
             account = account.toBuilder()
                     .setLabel(newLabel)
@@ -2197,6 +2191,35 @@ public class PhoneAccountRegistrar {
         private static final String VALUE_TYPE_INTEGER = "integer";
         private static final String VALUE_TYPE_BOOLEAN = "boolean";
 
+        /**
+         * Copy of {@code com.android.internal.util.XmlUtils} method for fiding the next element
+         * in an XmlPullParser.
+         * @param parser The parser
+         * @param outerDepth Outer depth to look at.
+         * @param featureFlags Telecom flags to refer back to the old implementation.
+         * @return {@code true} if a next element is found, {@code false otherwise}.
+         * @throws IOException
+         * @throws XmlPullParserException
+         */
+        public boolean nextElementWithin(XmlPullParser parser, int outerDepth,
+                com.android.server.telecom.flags.FeatureFlags featureFlags)
+                throws IOException, XmlPullParserException {
+            if (!featureFlags.resolveHiddenDependenciesTwo()) {
+                return XmlUtils.nextElementWithin(parser, outerDepth);
+            }
+            for (;;) {
+                int type = parser.next();
+                if (type == XmlPullParser.END_DOCUMENT
+                        || (type == XmlPullParser.END_TAG && parser.getDepth() == outerDepth)) {
+                    return false;
+                }
+                if (type == XmlPullParser.START_TAG
+                        && parser.getDepth() == outerDepth + 1) {
+                    return true;
+                }
+            }
+        }
+
         /**
          * Write the supplied object to XML
          */
@@ -2350,7 +2373,7 @@ public class PhoneAccountRegistrar {
             if (length == 0) return handles;
 
             int outerDepth = parser.getDepth();
-            while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+            while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                 handles.add(sPhoneAccountHandleXml.readFromXml(parser, version, context,
                         telephonyFeatureFlags, telecomFeatureFlags));
             }
@@ -2365,7 +2388,8 @@ public class PhoneAccountRegistrar {
          * @throws IOException Exception related to IO.
          * @throws XmlPullParserException Exception related to parsing.
          */
-        protected List<String> readStringList(XmlPullParser parser)
+        protected List<String> readStringList(XmlPullParser parser,
+                com.android.server.telecom.flags.FeatureFlags telecomFeatureFlags)
                 throws IOException, XmlPullParserException {
 
             int length = Integer.parseInt(parser.getAttributeValue(null, ATTRIBUTE_LENGTH));
@@ -2377,7 +2401,7 @@ public class PhoneAccountRegistrar {
             }
 
             int outerDepth = parser.getDepth();
-            while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+            while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                 if (parser.getName().equals(TAG_VALUE)) {
                     parser.next();
                     value = parser.getText();
@@ -2396,12 +2420,13 @@ public class PhoneAccountRegistrar {
          * @throws IOException Exception related to IO.
          * @throws XmlPullParserException Exception related to parsing.
          */
-        protected Bundle readBundle(XmlPullParser parser)
+        protected Bundle readBundle(XmlPullParser parser,
+                com.android.server.telecom.flags.FeatureFlags telecomFeatureFlags)
                 throws IOException, XmlPullParserException {
 
             Bundle bundle = null;
             int outerDepth = parser.getDepth();
-            while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+            while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                 if (parser.getName().equals(TAG_VALUE)) {
                     String valueType = parser.getAttributeValue(null, ATTRIBUTE_VALUE_TYPE);
                     String key = parser.getAttributeValue(null, ATTRIBUTE_KEY);
@@ -2501,7 +2526,7 @@ public class PhoneAccountRegistrar {
                 s.versionNumber = TextUtils.isEmpty(rawVersion) ? 1 : Integer.parseInt(rawVersion);
 
                 int outerDepth = parser.getDepth();
-                while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+                while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                     if (parser.getName().equals(DEFAULT_OUTGOING)) {
                         if (s.versionNumber < 9) {
                             // Migrate old default phone account handle here by assuming the
@@ -2530,7 +2555,8 @@ public class PhoneAccountRegistrar {
                             }
                         } else {
                             int defaultAccountHandlesDepth = parser.getDepth();
-                            while (XmlUtils.nextElementWithin(parser, defaultAccountHandlesDepth)) {
+                            while (nextElementWithin(parser, defaultAccountHandlesDepth,
+                                    telecomFeatureFlags)) {
                                 DefaultPhoneAccountHandle accountHandle
                                         = sDefaultPhoneAccountHandleXml
                                         .readFromXml(parser, s.versionNumber, context,
@@ -2543,7 +2569,7 @@ public class PhoneAccountRegistrar {
                         }
                     } else if (parser.getName().equals(ACCOUNTS)) {
                         int accountsDepth = parser.getDepth();
-                        while (XmlUtils.nextElementWithin(parser, accountsDepth)) {
+                        while (nextElementWithin(parser, accountsDepth, telecomFeatureFlags)) {
                             PhoneAccount account = sPhoneAccountXml.readFromXml(parser,
                                     s.versionNumber, context, telephonyFeatureFlags,
                                     telecomFeatureFlags);
@@ -2598,7 +2624,7 @@ public class PhoneAccountRegistrar {
                         PhoneAccountHandle accountHandle = null;
                         String userSerialNumberString = null;
                         String groupId = "";
-                        while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+                        while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                             if (parser.getName().equals(ACCOUNT_HANDLE)) {
                                 parser.nextTag();
                                 accountHandle = sPhoneAccountHandleXml.readFromXml(parser, version,
@@ -2716,7 +2742,7 @@ public class PhoneAccountRegistrar {
                 Bundle extras = null;
                 Set<PhoneAccountHandle> simultaneousCallingRestriction = null;
 
-                while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+                while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                     if (parser.getName().equals(ACCOUNT_HANDLE)) {
                         parser.nextTag();
                         accountHandle = sPhoneAccountHandleXml.readFromXml(parser, version,
@@ -2753,7 +2779,7 @@ public class PhoneAccountRegistrar {
                         parser.next();
                         shortDescription = parser.getText();
                     } else if (parser.getName().equals(SUPPORTED_URI_SCHEMES)) {
-                        supportedUriSchemes = readStringList(parser);
+                        supportedUriSchemes = readStringList(parser, telecomFeatureFlags);
                     } else if (parser.getName().equals(ICON)) {
                         parser.next();
                         icon = readIcon(parser);
@@ -2761,7 +2787,7 @@ public class PhoneAccountRegistrar {
                         parser.next();
                         enabled = "true".equalsIgnoreCase(parser.getText());
                     } else if (parser.getName().equals(EXTRAS)) {
-                        extras = readBundle(parser);
+                        extras = readBundle(parser, telecomFeatureFlags);
                     } else if (parser.getName().equals(SUPPORTED_AUDIO_ROUTES)) {
                         parser.next();
                         supportedAudioRoutes = Integer.parseInt(parser.getText());
@@ -2786,7 +2812,7 @@ public class PhoneAccountRegistrar {
                     // Handle the SIP connection service.
                     // Check the system settings to see if it also should handle "tel" calls.
                     if (accountHandle.getComponentName().equals(sipComponentName)) {
-                        boolean useSipForPstn = useSipForPstnCalls(context);
+                        boolean useSipForPstn = useSipForPstnCalls(context, telecomFeatureFlags);
                         supportedUriSchemes.add(PhoneAccount.SCHEME_SIP);
                         if (useSipForPstn) {
                             supportedUriSchemes.add(PhoneAccount.SCHEME_TEL);
@@ -2869,9 +2895,11 @@ public class PhoneAccountRegistrar {
          * @param context The context.
          * @return {@code True} if SIP should be used for all calls.
          */
-        private boolean useSipForPstnCalls(Context context) {
+        private boolean useSipForPstnCalls(Context context,
+                com.android.server.telecom.flags.FeatureFlags telecomFeatureFlags) {
             String option = Settings.System.getStringForUser(context.getContentResolver(),
-                    Settings.System.SIP_CALL_OPTIONS, context.getUserId());
+                    Settings.System.SIP_CALL_OPTIONS, UserUtil.getUserIdFromContext(context,
+                            telecomFeatureFlags));
             option = (option != null) ? option : Settings.System.SIP_ADDRESS_ONLY;
             return option.equals(Settings.System.SIP_ALWAYS);
         }
@@ -2921,7 +2949,7 @@ public class PhoneAccountRegistrar {
 
                 UserManager userManager = context.getSystemService(UserManager.class);
 
-                while (XmlUtils.nextElementWithin(parser, outerDepth)) {
+                while (nextElementWithin(parser, outerDepth, telecomFeatureFlags)) {
                     if (parser.getName().equals(COMPONENT_NAME)) {
                         parser.next();
                         componentNameString = parser.getText();
diff --git a/src/com/android/server/telecom/PhoneAccountSuggestionHelper.java b/src/com/android/server/telecom/PhoneAccountSuggestionHelper.java
index ab5570344..253f0cd03 100644
--- a/src/com/android/server/telecom/PhoneAccountSuggestionHelper.java
+++ b/src/com/android/server/telecom/PhoneAccountSuggestionHelper.java
@@ -38,6 +38,7 @@ import android.text.TextUtils;
 
 import com.android.internal.telecom.IPhoneAccountSuggestionCallback;
 import com.android.internal.telecom.IPhoneAccountSuggestionService;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
@@ -54,7 +55,7 @@ public class PhoneAccountSuggestionHelper {
      */
     public static CompletableFuture<List<PhoneAccountSuggestion>>
     bindAndGetSuggestions(Context context, Uri handle,
-            List<PhoneAccountHandle> availablePhoneAccounts) {
+            List<PhoneAccountHandle> availablePhoneAccounts, FeatureFlags featureFlags) {
         Context userContext;
         if (sOverrideUserHandle != null) {
             userContext = context.createContextAsUser(sOverrideUserHandle, 0);
@@ -154,7 +155,7 @@ public class PhoneAccountSuggestionHelper {
                         Log.endSession();
                     }
                 },
-                Timeouts.getPhoneAccountSuggestionServiceTimeout(userContext.getContentResolver()));
+                Timeouts.getPhoneAccountSuggestionServiceTimeout(userContext, featureFlags));
         return future;
     }
 
diff --git a/src/com/android/server/telecom/QuickResponseUtils.java b/src/com/android/server/telecom/QuickResponseUtils.java
index 84d2636e4..db755dbcf 100644
--- a/src/com/android/server/telecom/QuickResponseUtils.java
+++ b/src/com/android/server/telecom/QuickResponseUtils.java
@@ -22,8 +22,6 @@ import android.content.pm.PackageManager;
 import android.content.res.Resources;
 import android.telecom.Log;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * Utils class that exposes some helper routines to used to manage the QuickResponses
  */
diff --git a/src/com/android/server/telecom/RespondViaSmsManager.java b/src/com/android/server/telecom/RespondViaSmsManager.java
index bff33133e..fe8f9a8c6 100644
--- a/src/com/android/server/telecom/RespondViaSmsManager.java
+++ b/src/com/android/server/telecom/RespondViaSmsManager.java
@@ -16,7 +16,6 @@
 
 package com.android.server.telecom;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
 import android.app.Activity;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
diff --git a/src/com/android/server/telecom/Ringer.java b/src/com/android/server/telecom/Ringer.java
index 5904689c8..51028d546 100644
--- a/src/com/android/server/telecom/Ringer.java
+++ b/src/com/android/server/telecom/Ringer.java
@@ -63,7 +63,11 @@ import java.util.ArrayList;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.function.BiConsumer;
@@ -76,6 +80,18 @@ import java.util.function.Supplier;
 public class Ringer {
     private static final String TAG = "TelecomRinger";
 
+    /**
+     * Abstraction of vibration.  We used to leverage SystemVibrator which implements the abstract
+     * Vibrator class.  However, the Vibrator class has a bunch of abstract @hide methods we can
+     * not implement, so we just abstract out a base interface here with only what we need.
+     */
+    public interface VibratorAdapter {
+        boolean hasVibrator();
+        void vibrate(VibrationEffect vibe, VibrationAttributes attributes);
+        void cancel();
+        Vibrator getVibrator();
+    }
+
     public interface AccessibilityManagerAdapter {
         boolean startFlashNotificationSequence(@NonNull Context context,
                 @AccessibilityManager.FlashNotificationReason int reason);
@@ -131,6 +147,7 @@ public class Ringer {
 
     private static final int RAMPING_RINGER_VIBRATION_DURATION = 5000;
     private static final int RAMPING_RINGER_DURATION = 10000;
+    private static final int OUTGOING_CALL_VIBRATING_DURATION = 100;
 
     static {
         // construct complete pulse pattern
@@ -160,6 +177,16 @@ public class Ringer {
             0, // No amplitude while waiting
     };
 
+    private static final long[] CALL_CONNECTED_VIBRATION_PATTERN = {
+            0, // No delay before starting
+            1000, // How long to vibrate
+    };
+
+    private static final int[] CALL_CONNECTED_VIBRATION_AMPLITUDE = {
+            0, // No delay before starting
+            255, // Vibrate full amplitude
+    };
+
     /**
      * Indicates that vibration should be repeated at element 5 in the {@link #PULSE_AMPLITUDE} and
      * {@link #PULSE_PATTERN} arrays.  This means repetition will happen for the main ease-in/peak
@@ -192,7 +219,7 @@ public class Ringer {
     private final InCallTonePlayer.Factory mPlayerFactory;
     private final AsyncRingtonePlayer mRingtonePlayer;
     private final Context mContext;
-    private final Vibrator mVibrator;
+    private final VibratorAdapter mVibrator;
     private final InCallController mInCallController;
     private final VibrationEffectProxy mVibrationEffectProxy;
     private final boolean mIsHapticPlaybackSupportedByDevice;
@@ -223,7 +250,7 @@ public class Ringer {
     /**
      * Used to track the status of {@link #mVibrator} in the case of simultaneous incoming calls.
      */
-    private boolean mIsVibrating = false;
+    private volatile boolean mIsVibrating = false;
 
     private Handler mHandler = null;
 
@@ -232,6 +259,27 @@ public class Ringer {
      * lock
      */
     private final Object mLock;
+    /**
+     * Used to track the status of call connected inidicator preference.
+     */
+    private final CallConnectedIndicatorSettings mCallConnectedIndicatorSettings;
+    private final Executor mAsyncTaskExecutor;
+
+    /**
+     * Manages a dedicated single background thread for executing Ringer-specific tasks
+     * asynchronously, such as calculating ringer attributes and posting accessibility updates.
+     * <p>
+     * This ExecutorService replaces the previous Handler/HandlerThread mechanism to align with
+     * Mainline module guidelines, which restrict direct Handler usage to reduce platform coupling
+     * and enhance stability.
+     */
+    private ExecutorService mRingerExecutor = null;
+    /**
+     * Guards mRingerExecutor's lifecycle (lazy initialization, shutdown). This prevents
+     * race conditions during init that could lead to multiple executor instances & resource leaks.
+     * Kept separate from mLock (ringer operational state) to minimize unrelated contention.
+     */
+    private final Object mExecutorLock = new Object();
 
     /** Initializes the Ringer. */
     @VisibleForTesting
@@ -241,13 +289,15 @@ public class Ringer {
             SystemSettingsUtil systemSettingsUtil,
             AsyncRingtonePlayer asyncRingtonePlayer,
             RingtoneFactory ringtoneFactory,
-            Vibrator vibrator,
+            VibratorAdapter vibrator,
             VibrationEffectProxy vibrationEffectProxy,
             InCallController inCallController,
             NotificationManager notificationManager,
             AccessibilityManagerAdapter accessibilityManagerAdapter,
             FeatureFlags featureFlags,
-            AnomalyReporterAdapter anomalyReporter) {
+            AnomalyReporterAdapter anomalyReporter,
+            CallConnectedIndicatorSettings callConnectedIndicator,
+            Executor asyncTaskExecutor) {
 
         mLock = new Object();
         mSystemSettingsUtil = systemSettingsUtil;
@@ -266,7 +316,7 @@ public class Ringer {
 
         mDefaultVibrationEffect =
                 loadDefaultRingVibrationEffect(
-                        mContext, mVibrator, mVibrationEffectProxy, featureFlags);
+                        mContext, mVibrator.getVibrator(), mVibrationEffectProxy, featureFlags);
 
         mIsHapticPlaybackSupportedByDevice =
                 mSystemSettingsUtil.isHapticPlaybackSupported(mContext);
@@ -275,6 +325,26 @@ public class Ringer {
         mFlags = featureFlags;
         mRingtoneVibrationSupported = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_ringtoneVibrationSettingsSupported);
+        mCallConnectedIndicatorSettings = callConnectedIndicator;
+        mAsyncTaskExecutor = asyncTaskExecutor;
+    }
+
+    public void shutdownExecutor() {
+        Log.i(this, "Shutting down Ringer executor.");
+        synchronized (mExecutorLock) {
+            if (mRingerExecutor != null) {
+                mRingerExecutor.shutdown();
+                try {
+                    if (!mRingerExecutor.awaitTermination(500, TimeUnit.MILLISECONDS)) {
+                        mRingerExecutor.shutdownNow();
+                    }
+                } catch (InterruptedException e) {
+                    mRingerExecutor.shutdownNow();
+                    Thread.currentThread().interrupt();
+                }
+                mRingerExecutor = null;
+            }
+        }
     }
 
     @VisibleForTesting
@@ -312,7 +382,7 @@ public class Ringer {
             // TODO: moving these RingerAttributes calculation out of Telecom lock to avoid blocking
             CompletableFuture<RingerAttributes> ringerAttributesFuture = CompletableFuture
                     .supplyAsync(() -> getRingerAttributes(foregroundCall, isHfpDeviceAttached),
-                            new LoggedHandlerExecutor(getHandler(), "R.sR", null));
+                            getLoggedExecutor("R.sR"));
 
             RingerAttributes attributes = null;
             try {
@@ -329,6 +399,8 @@ public class Ringer {
                 return false;
             }
 
+            Log.i(this, "startRinging: attributes=%s", attributes);
+
             if (attributes.isEndEarly()) {
                 boolean acquireAudioFocus = attributes.shouldAcquireAudioFocus();
                 if (attributes.letDialerHandleRinging()) {
@@ -353,9 +425,15 @@ public class Ringer {
             final boolean shouldFlash = attributes.shouldRingForContact();
             if (mAccessibilityManagerAdapter != null && shouldFlash) {
                 Log.addEvent(foregroundCall, LogUtils.Events.FLASH_NOTIFICATION_START);
-                getHandler().post(() ->
-                        mAccessibilityManagerAdapter.startFlashNotificationSequence(mContext,
-                                AccessibilityManager.FLASH_REASON_CALL));
+                if (mFlags.resolveHiddenDependenciesTwo()) {
+                    getExecutor().execute(() ->
+                            mAccessibilityManagerAdapter.startFlashNotificationSequence(mContext,
+                                    AccessibilityManager.FLASH_REASON_CALL));
+                } else {
+                    getHandler().post(() ->
+                            mAccessibilityManagerAdapter.startFlashNotificationSequence(mContext,
+                                    AccessibilityManager.FLASH_REASON_CALL));
+                }
             }
 
             // Determine if the settings and DND mode indicate that the vibrator can be used right
@@ -373,7 +451,7 @@ public class Ringer {
             String vibratorAttrs = String.format("hasVibrator=%b, userRequestsVibrate=%b, "
                             + "ringerMode=%d, isVibratorEnabled=%b",
                     mVibrator.hasVibrator(),
-                    mSystemSettingsUtil.isRingVibrationEnabled(mContext),
+                    mSystemSettingsUtil.isRingVibrationEnabled(mContext, mFlags),
                     mAudioManager.getRingerMode(), isVibratorEnabled);
 
             if (attributes.isRingerAudible()) {
@@ -433,11 +511,6 @@ public class Ringer {
                     && isVibratorEnabled) {
                 Log.i(this, "Muted haptic channels since audio coupled ramping ringer is disabled");
                 hapticChannelsMuted = true;
-                if (useCustomVibration(foregroundCall)) {
-                    Log.i(this,
-                            "Not muted haptic channel for customization when apply ramping ringer");
-                    hapticChannelsMuted = false;
-                }
             } else if (hapticChannelsMuted) {
                 Log.i(this,
                         "Muted haptic channels isVibratorEnabled=%s, hapticPlaybackSupported=%s",
@@ -586,7 +659,8 @@ public class Ringer {
             if (foregroundCall == mVibratingCall && !mIsVibrating) {
                 Log.addEvent(foregroundCall, LogUtils.Events.START_VIBRATOR,
                     "hasVibrator=%b, userRequestsVibrate=%b, ringerMode=%d, isVibrating=%b",
-                    mVibrator.hasVibrator(), mSystemSettingsUtil.isRingVibrationEnabled(mContext),
+                        mVibrator.hasVibrator(),
+                        mSystemSettingsUtil.isRingVibrationEnabled(mContext, mFlags),
                     mAudioManager.getRingerMode(), mIsVibrating);
                 mIsVibrating = true;
                 mVibrator.vibrate(effect, VIBRATION_ATTRIBUTES);
@@ -655,8 +729,13 @@ public class Ringer {
         final Call foregroundCall = mRingingCall != null ? mRingingCall : mVibratingCall;
         if (mAccessibilityManagerAdapter != null) {
             Log.addEvent(foregroundCall, LogUtils.Events.FLASH_NOTIFICATION_STOP);
-            getHandler().post(() ->
-                    mAccessibilityManagerAdapter.stopFlashNotificationSequence(mContext));
+            if (mFlags.resolveHiddenDependenciesTwo()) {
+                getExecutor().execute(() ->
+                        mAccessibilityManagerAdapter.stopFlashNotificationSequence(mContext));
+            } else {
+                getHandler().post(() ->
+                        mAccessibilityManagerAdapter.stopFlashNotificationSequence(mContext));
+            }
         }
 
         synchronized (mLock) {
@@ -735,11 +814,20 @@ public class Ringer {
         AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
         // Use AudioManager#getRingerMode for more accurate result, instead of
         // AudioManager#getRingerModeInternal which only useful for volume controllers
-        boolean zenModeOn = mNotificationManager != null
-                && mNotificationManager.getZenMode() != ZEN_MODE_OFF;
+        boolean zenModeOn;
+        if (mFlags.resolveHiddenDependenciesTwo()) {
+            // See NotificationManager#zenModeToInterruptionFilter; INTERRUPTION_FILTER_ALL is
+            // equivalent to the former ZEN_MODE_OFF.
+            zenModeOn = mNotificationManager != null
+                    && mNotificationManager.getCurrentInterruptionFilter()
+                    != NotificationManager.INTERRUPTION_FILTER_ALL;
+        } else {
+            zenModeOn = mNotificationManager != null
+                    && mNotificationManager.getZenMode() != ZEN_MODE_OFF;
+        }
         maybeGenAnomReportForGetRingerMode(zenModeOn, audioManager);
         return mVibrator.hasVibrator()
-                && mSystemSettingsUtil.isRingVibrationEnabled(context)
+                && mSystemSettingsUtil.isRingVibrationEnabled(context, mFlags)
                 && (audioManager.getRingerMode() != AudioManager.RINGER_MODE_SILENT
                 || (zenModeOn && shouldRingForContact));
     }
@@ -759,9 +847,6 @@ public class Ringer {
      * report if they diverge.
      */
     private void maybeGenAnomReportForGetRingerMode(boolean isZenModeOn, AudioManager am) {
-        if (!mFlags.getRingerModeAnomReport()) {
-            return;
-        }
         if (!isZenModeOn) {
             int ringerMode = am.getRingerMode();
             int ringerModeInternal = am.getRingerModeInternal();
@@ -782,14 +867,11 @@ public class Ringer {
 
         boolean isVolumeOverZero;
 
-        if (mFlags.ensureInCarRinging()) {
-            AudioAttributes aa = new AudioAttributes.Builder()
-                    .setUsage(AudioAttributes.USAGE_NOTIFICATION_RINGTONE)
-                    .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build();
-            isVolumeOverZero = mAudioManager.shouldNotificationSoundPlay(aa);
-        } else {
-            isVolumeOverZero = mAudioManager.getStreamVolume(AudioManager.STREAM_RING) > 0;
-        }
+        AudioAttributes aa = new AudioAttributes.Builder()
+                .setUsage(AudioAttributes.USAGE_NOTIFICATION_RINGTONE)
+                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build();
+        isVolumeOverZero = mAudioManager.shouldNotificationSoundPlay(aa);
+
         timer.record("isVolumeOverZero");
         boolean shouldRingForContact = shouldRingForContact(call);
         timer.record("shouldRingForContact");
@@ -827,23 +909,37 @@ public class Ringer {
         if (endEarly) {
             Log.i(
                     this,
-                    "Ending early -- letDialerHandleRinging=%s, isSelfManaged=%s, "
+                    "getRingerAttributtes: ending -- letDialerHandleRinging=%s, isSelfManaged=%s, "
                             + "hasExternalRinger=%s, silentRingingRequested=%s, "
-                            + "isWorkProfileInQuietMode=%s",
+                            + "isWorkProfileInQuietMode=%s, shouldRingForContact=%s, "
+                            + "isVolumeOverZero=%s",
                     letDialerHandleRinging,
                     isSelfManaged,
                     hasExternalRinger,
                     isSilentRingingRequested,
-                    isWorkProfileInQuietMode);
+                    isWorkProfileInQuietMode, shouldRingForContact, isVolumeOverZero);
         }
 
         // Acquire audio focus under any of the following conditions:
         // 1. Should ring for contact and there's an HFP device attached
         // 2. Volume is over zero, we should ring for the contact, and there's a audible ringtone
         //    present. (This check is deferred until ringer knows the ringtone)
-        // 3. The call is self-managed.
-        boolean shouldAcquireAudioFocus = !isWorkProfileInQuietMode &&
-                ((isHfpDeviceAttached && shouldRingForContact) || isSelfManaged);
+        boolean shouldAcquireAudioFocus;
+        if (mFlags.voipDndFocus()) {
+            shouldAcquireAudioFocus = !isWorkProfileInQuietMode &&
+                    // The previous logic for determining if audio focus should be acquired
+                    // assumed we should ALWAYS acquire audio focus for a voip call.  For non-voip
+                    // calls, the value of shouldAcquireAudioFocus we calculate here is combined
+                    // with other factors later such as whether the ringer volume is zero or if
+                    // there is a ringtone present.
+                    // For voip we should ideally only acquire ringing focus if DND didn't block the
+                    // contact and the ringer volume is over zero.
+                    ((!isSelfManaged && isHfpDeviceAttached && shouldRingForContact)
+                            || isSelfManaged && shouldRingForContact && isVolumeOverZero);
+        } else {
+            shouldAcquireAudioFocus = !isWorkProfileInQuietMode &&
+                    ((isHfpDeviceAttached && shouldRingForContact) || isSelfManaged);
+        }
 
         // Set missed reason according to attributes
         if (!isVolumeOverZero) {
@@ -881,6 +977,34 @@ public class Ringer {
         return mHandler;
     }
 
+    private java.util.concurrent.Executor getLoggedExecutor(String functionName) {
+        if (mFlags.resolveHiddenDependenciesTwo()) {
+            return new LoggedExecutor(getExecutor(), functionName, null);
+        } else {
+            return new LoggedHandlerExecutor(getHandler(), functionName, null);
+        }
+    }
+
+    public ExecutorService getExecutor() {
+        synchronized (mExecutorLock) {
+            if (mRingerExecutor == null) {
+                ThreadFactory ringerThread = new ThreadFactory() {
+                    @Override
+                    public Thread newThread(Runnable r) {
+                        Thread t = new Thread(r, "Ringer-Executor");
+                        return t;
+                    }
+                };
+                // A single-thread executor is chosen here to ensure that Ringer-internal
+                // background tasks (e.g., ringer attribute calculation, accessibility updates)
+                // are processed sequentially. This mirrors the execution model of the previous
+                // Handler/HandlerThread, preserving task order and predictable behavior.
+                mRingerExecutor = Executors.newSingleThreadExecutor(ringerThread);
+            }
+        }
+        return mRingerExecutor;
+    }
+
     @VisibleForTesting
     public boolean waitForAttributesCompletion() throws InterruptedException {
         if (mAttributesLatch != null) {
@@ -950,4 +1074,31 @@ public class Ringer {
         return vibrationEffectProxy.createWaveform(SIMPLE_VIBRATION_PATTERN,
                 SIMPLE_VIBRATION_AMPLITUDE, REPEAT_SIMPLE_VIBRATION_AT);
     }
+
+
+    public void startVibratingForOutgoingCallActive() {
+        if (!mFlags.callConnectedIndicatorPreference()) {
+            Log.i(TAG, "Call connected indicator of vibration is disabled.");
+            return;
+        }
+        if (!mIsVibrating && mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled()) {
+            mIsVibrating = true;
+            mAsyncTaskExecutor.execute(() -> {
+                final VibrationEffect vibrationEffect =
+                        mVibrationEffectProxy.createWaveform(CALL_CONNECTED_VIBRATION_PATTERN,
+                        CALL_CONNECTED_VIBRATION_AMPLITUDE, -1);
+                final VibrationAttributes vibrationAttributes = new VibrationAttributes.Builder()
+                        .setUsage(VibrationAttributes.USAGE_NOTIFICATION)
+                        .build();
+                mVibrator.vibrate(vibrationEffect, vibrationAttributes);
+                try {
+                    Thread.sleep(OUTGOING_CALL_VIBRATING_DURATION);
+                } catch (InterruptedException e) {
+                    // Womp
+                }
+                mVibrator.cancel();
+                mIsVibrating = false;
+            });
+        }
+    }
 }
diff --git a/src/com/android/server/telecom/RingerAttributes.java b/src/com/android/server/telecom/RingerAttributes.java
index e0d3e1c08..7c7f01d08 100644
--- a/src/com/android/server/telecom/RingerAttributes.java
+++ b/src/com/android/server/telecom/RingerAttributes.java
@@ -75,6 +75,21 @@ public class RingerAttributes {
     }
 
     private boolean mEndEarly;
+
+    @Override
+    public String toString() {
+        return "RingerAttributes{" +
+                "mEndEarly=" + mEndEarly +
+                ", mLetDialerHandleRinging=" + mLetDialerHandleRinging +
+                ", mAcquireAudioFocus=" + mAcquireAudioFocus +
+                ", mRingerAudible=" + mRingerAudible +
+                ", mInaudibleReason='" + mInaudibleReason + '\'' +
+                ", mShouldRingForContact=" + mShouldRingForContact +
+                ", mSilentRingingRequested=" + mSilentRingingRequested +
+                ", mWorkProfileQuietMode=" + mWorkProfileQuietMode +
+                '}';
+    }
+
     private boolean mLetDialerHandleRinging;
     private boolean mAcquireAudioFocus;
     private boolean mRingerAudible;
diff --git a/src/com/android/server/telecom/RingtoneFactory.java b/src/com/android/server/telecom/RingtoneFactory.java
index c740c2461..9df76be00 100644
--- a/src/com/android/server/telecom/RingtoneFactory.java
+++ b/src/com/android/server/telecom/RingtoneFactory.java
@@ -74,12 +74,18 @@ public class RingtoneFactory {
         Ringtone ringtone = null;
 
         if (ringtoneUri != null && userContext != null) {
-            // Ringtone URI is explicitly specified. First, try to create a Ringtone with that.
-            try {
-                ringtone = RingtoneManager.getRingtone(
-                        userContext, ringtoneUri, volumeShaperConfig, audioAttrs);
-            } catch (Exception e) {
-                Log.e(this, e, "getRingtone: exception while getting ringtone.");
+            if (currentUserOwnsRingtone(ringtoneUri, incomingCall)) {
+                // Ringtone URI is explicitly specified and owned by the current user - try to
+                // create a Ringtone with that.
+                try {
+                    ringtone = RingtoneManager.getRingtone(
+                            userContext, ringtoneUri, volumeShaperConfig, audioAttrs);
+                } catch (Exception e) {
+                    Log.e(this, e, "getRingtone: exception while getting ringtone.");
+                }
+            } else {
+                Log.w(this, "getRingtone: Failed to verify that the custom ringtone URI"
+                        + " is owned by the current user. Falling back to the default ringtone.");
             }
         }
         if (ringtone == null) {
@@ -119,6 +125,23 @@ public class RingtoneFactory {
         return new Pair(ringtoneUri, ringtone);
     }
 
+    private boolean currentUserOwnsRingtone(Uri ringtoneUri, Call incomingCall) {
+        if (ringtoneUri.getUserInfo() == null) {
+            // The current user set this custom ringtone:
+            return true;
+        }
+
+        UserHandle associatedUser = incomingCall.getAssociatedUser();
+        if (associatedUser == null) {
+            Log.d(this, "currentUserOwnsRingtone: The incoming call does not"
+                    + " have an associated user.");
+            return false;
+        }
+
+        String currentUserId = String.valueOf(associatedUser.getIdentifier());
+        return currentUserId.equals(ringtoneUri.getUserInfo());
+    }
+
     private AudioAttributes getDefaultRingtoneAudioAttributes(boolean hapticChannelsMuted) {
         return new AudioAttributes.Builder()
             .setUsage(AudioAttributes.USAGE_NOTIFICATION_RINGTONE)
@@ -183,7 +206,8 @@ public class RingtoneFactory {
             return false;
         }
         return !TextUtils.isEmpty(Settings.System.getStringForUser(userContext.getContentResolver(),
-                Settings.System.RINGTONE, userContext.getUserId()));
+                Settings.System.RINGTONE,
+                UserUtil.getUserIdFromContext(userContext, mFeatureFlags)));
     }
 
     private boolean isWorkContact(Call incomingCall) {
diff --git a/src/com/android/server/telecom/ServiceBinder.java b/src/com/android/server/telecom/ServiceBinder.java
index a18042b21..1cab3fe8d 100644
--- a/src/com/android/server/telecom/ServiceBinder.java
+++ b/src/com/android/server/telecom/ServiceBinder.java
@@ -243,7 +243,6 @@ public abstract class ServiceBinder {
     protected final String mPackageAbbreviation;
     protected final FeatureFlags mFlags;
 
-
     /** The set of callbacks waiting for notification of the binding's success or failure. */
     private final Set<BindCallback> mCallbacks = new ArraySet<>();
 
@@ -309,31 +308,6 @@ public abstract class ServiceBinder {
     }
 
     final void decrementAssociatedCallCount() {
-        if (mFlags.updatedRcsCallCountTracking()) {
-            decrementAssociatedCallCountUpdated();
-        } else {
-            decrementAssociatedCallCount(false /*isSuppressingUnbind*/);
-        }
-    }
-
-    final void decrementAssociatedCallCount(boolean isSuppressingUnbind) {
-        // This is the legacy method - will be removed after the Flags.updatedRcsCallCountTracking
-        // mendel study completes.
-        if (mAssociatedCallCount > 0) {
-            mAssociatedCallCount--;
-            Log.v(this, "Call count decrement %d, %s", mAssociatedCallCount,
-                    mComponentName.flattenToShortString());
-
-            if (!isSuppressingUnbind && mAssociatedCallCount == 0) {
-                unbind();
-            }
-        } else {
-            Log.wtf(this, "%s: ignoring a request to decrement mAssociatedCallCount below zero",
-                    mComponentName.getClassName());
-        }
-    }
-
-    final void decrementAssociatedCallCountUpdated() {
         if (mAssociatedCallCount > 0) {
             mAssociatedCallCount--;
             Log.i(this, "Call count decrement %d, %s", mAssociatedCallCount,
diff --git a/src/com/android/server/telecom/StatusBarNotifier.java b/src/com/android/server/telecom/StatusBarNotifier.java
index 772335ed3..cc6c5bee7 100644
--- a/src/com/android/server/telecom/StatusBarNotifier.java
+++ b/src/com/android/server/telecom/StatusBarNotifier.java
@@ -22,8 +22,6 @@ import android.telecom.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * Manages the special status bar notifications used by the phone app.
  */
diff --git a/src/com/android/server/telecom/SystemSettingsUtil.java b/src/com/android/server/telecom/SystemSettingsUtil.java
index d846cce20..1cb690d8e 100644
--- a/src/com/android/server/telecom/SystemSettingsUtil.java
+++ b/src/com/android/server/telecom/SystemSettingsUtil.java
@@ -24,6 +24,7 @@ import android.provider.DeviceConfig;
 import android.provider.Settings;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.telecom.flags.FeatureFlags;
 
 /**
  * Accesses the Global System settings for more control during testing.
@@ -35,7 +36,7 @@ public class SystemSettingsUtil {
     private static final String RAMPING_RINGER_AUDIO_COUPLED_VIBRATION_ENABLED =
             "ramping_ringer_audio_coupled_vibration_enabled";
 
-    public boolean isRingVibrationEnabled(Context context) {
+    public boolean isRingVibrationEnabled(Context context, FeatureFlags flags) {
         // VIBRATE_WHEN_RINGING setting was deprecated, only RING_VIBRATION_INTENSITY controls the
         // ringtone vibrations on/off state now. Ramping ringer should only be applied when ring
         // vibration intensity is ON, otherwise the ringtone sound should not be delayed as there
@@ -44,18 +45,21 @@ public class SystemSettingsUtil {
                 Settings.System.RING_VIBRATION_INTENSITY,
                 context.getSystemService(Vibrator.class).getDefaultVibrationIntensity(
                         VibrationAttributes.USAGE_RINGTONE),
-                context.getUserId()) != Vibrator.VIBRATION_INTENSITY_OFF;
+                UserUtil.getUserIdFromContext(context, flags))
+                != Vibrator.VIBRATION_INTENSITY_OFF;
     }
 
-    public boolean isEnhancedCallBlockingEnabled(Context context) {
+    public boolean isEnhancedCallBlockingEnabled(Context context, FeatureFlags flags) {
         return Settings.System.getIntForUser(context.getContentResolver(),
-                Settings.System.DEBUG_ENABLE_ENHANCED_CALL_BLOCKING, 0, context.getUserId()) != 0;
+                Settings.System.DEBUG_ENABLE_ENHANCED_CALL_BLOCKING, 0,
+                UserUtil.getUserIdFromContext(context, flags)) != 0;
     }
 
-    public boolean setEnhancedCallBlockingEnabled(Context context, boolean enabled) {
+    public boolean setEnhancedCallBlockingEnabled(Context context, boolean enabled,
+            FeatureFlags flags) {
         return Settings.System.putIntForUser(context.getContentResolver(),
                 Settings.System.DEBUG_ENABLE_ENHANCED_CALL_BLOCKING, enabled ? 1 : 0,
-                context.getUserId());
+                UserUtil.getUserIdFromContext(context, flags));
     }
 
     public boolean isRampingRingerEnabled(Context context) {
diff --git a/src/com/android/server/telecom/TelecomBroadcastIntentProcessor.java b/src/com/android/server/telecom/TelecomBroadcastIntentProcessor.java
index 2efc79c6c..1628993dc 100644
--- a/src/com/android/server/telecom/TelecomBroadcastIntentProcessor.java
+++ b/src/com/android/server/telecom/TelecomBroadcastIntentProcessor.java
@@ -26,9 +26,11 @@ import android.os.UserHandle;
 import android.telecom.Log;
 import android.widget.Toast;
 
+import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.ui.ConfirmCallDialogActivity;
 import com.android.server.telecom.ui.DisconnectedCallNotifier;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public final class TelecomBroadcastIntentProcessor {
@@ -113,10 +115,15 @@ public final class TelecomBroadcastIntentProcessor {
 
     private final Context mContext;
     private final CallsManager mCallsManager;
+    private final FeatureFlags mFeatureFlags;
 
-    public TelecomBroadcastIntentProcessor(Context context, CallsManager callsManager) {
+    public TelecomBroadcastIntentProcessor(
+            Context context,
+            CallsManager callsManager,
+            FeatureFlags flags) {
         mContext = context;
         mCallsManager = callsManager;
+        mFeatureFlags = flags;
     }
 
     public void processIntent(Intent intent) {
@@ -287,13 +294,22 @@ public final class TelecomBroadcastIntentProcessor {
     private void sendSmsIntent(Intent intent, UserHandle userHandle) {
         Intent callIntent = new Intent(Intent.ACTION_SENDTO, intent.getData());
         callIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        PackageManager packageManager = mContext.getPackageManager();
-        List<ResolveInfo> activities = packageManager.queryIntentActivitiesAsUser(
-                callIntent, PackageManager.MATCH_DEFAULT_ONLY, userHandle.getIdentifier());
+        List<ResolveInfo> activities;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            activities = UserUtil.getPackageManagerFromUserHandler(mContext,
+                    userHandle).queryIntentActivitiesAsUser(callIntent,
+                    PackageManager.MATCH_DEFAULT_ONLY, userHandle.getIdentifier());
+        } else {
+            PackageManager packageManager = mContext.getPackageManager();
+            activities = packageManager.queryIntentActivitiesAsUser(
+                    callIntent, PackageManager.MATCH_DEFAULT_ONLY, userHandle.getIdentifier());
+        }
         if (activities.size() > 0) {
             mContext.startActivityAsUser(callIntent, userHandle);
         } else {
-            Toast.makeText(mContext, com.android.internal.R.string.noApplications,
+            // Should never happen but toast just in case (skipped the flag since we will never hit
+            // this case anyways).
+            Toast.makeText(mContext, com.android.server.telecom.R.string.noApplications,
                     Toast.LENGTH_SHORT).show();
         }
     }
diff --git a/src/com/android/server/telecom/TelecomServiceImpl.java b/src/com/android/server/telecom/TelecomServiceImpl.java
index e84d7a518..d5b95146f 100644
--- a/src/com/android/server/telecom/TelecomServiceImpl.java
+++ b/src/com/android/server/telecom/TelecomServiceImpl.java
@@ -36,10 +36,12 @@ import android.app.AppOpsManager;
 import android.app.UiModeManager;
 import android.app.compat.CompatChanges;
 import android.content.AttributionSource;
+import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.PermissionChecker;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
@@ -55,6 +57,9 @@ import android.os.ParcelFileDescriptor;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.UserHandle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.permission.PermissionManager;
 import android.provider.BlockedNumberContract;
 import android.provider.BlockedNumbersManager;
 import android.provider.Settings;
@@ -91,6 +96,7 @@ import com.android.server.telecom.settings.BlockedNumbersActivity;
 import com.android.server.telecom.callsequencing.TransactionManager;
 import com.android.server.telecom.callsequencing.CallTransaction;
 import com.android.server.telecom.callsequencing.CallTransactionResult;
+import com.android.server.telecom.PackageRemovedReceiver;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -104,8 +110,6 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * Implementation of the ITelecom interface.
  */
@@ -175,6 +179,8 @@ public class TelecomServiceImpl {
     private final PackageManager mPackageManager;
     private final CallsManager mCallsManager;
     private TransactionManager mTransactionManager;
+    private final PermissionManager mPermissionManager;
+    private PackageRemovedReceiver mPackageRemovedReceiver;
     private final ITelecomService.Stub mBinderImpl = new ITelecomService.Stub() {
 
         @Override
@@ -1372,14 +1378,29 @@ public class TelecomServiceImpl {
                 Log.startSession("TSI.hMOCP", Log.getPackageAbbreviation(callingPackage));
                 enforceCallingPackage(callingPackage, "hasManageOngoingCallsPermission");
                 event.setResult(ApiStats.RESULT_NORMAL);
-                return PermissionChecker.checkPermissionForDataDeliveryFromDataSource(
-                        mContext, Manifest.permission.MANAGE_ONGOING_CALLS,
-                        Binder.getCallingPid(),
-                        new AttributionSource(mContext.getAttributionSource(),
-                                new AttributionSource(Binder.getCallingUid(),
-                                        callingPackage, /*attributionTag*/ null)),
-                        "Checking whether the caller has MANAGE_ONGOING_CALLS permission")
-                        == PermissionChecker.PERMISSION_GRANTED;
+                AttributionSource attributionSource;
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    // checkPermissionForPreflight is documented as useful for cases where you are
+                    // seeing if a permission is held, but you're not going to deliver data to the
+                    // app yet; that's what we'd expect here.
+                    int result = mPermissionManager.checkPermissionForPreflight(
+                            Manifest.permission.MANAGE_ONGOING_CALLS,
+                            new AttributionSource.Builder(Binder.getCallingUid())
+                                    .setPackageName(callingPackage).build());
+                    Log.i(this, "hasManageOngoingCallPermission: caller=%s; uid=%d, result=%d",
+                            callingPackage, Binder.getCallingUid(), result);
+                    return result == PermissionManager.PERMISSION_GRANTED;
+                } else {
+                    attributionSource = new AttributionSource(mContext.getAttributionSource(),
+                            new AttributionSource(Binder.getCallingUid(),
+                                    callingPackage, /*attributionTag*/ null));
+                    return PermissionChecker.checkPermissionForDataDeliveryFromDataSource(
+                            mContext, Manifest.permission.MANAGE_ONGOING_CALLS,
+                            Binder.getCallingPid(),
+                            attributionSource,
+                            "Checking whether the caller has MANAGE_ONGOING_CALLS permission")
+                            == PermissionChecker.PERMISSION_GRANTED;
+                }
             } finally {
                 logEvent(event);
                 Log.endSession();
@@ -1956,10 +1977,8 @@ public class TelecomServiceImpl {
                                         && accountExtra != null && accountExtra.getBoolean(
                                         PhoneAccount.EXTRA_SKIP_CALL_FILTERING,
                                         false)) {
-                                    if (mFeatureFlags.separatelyBindToBtIncallService()) {
-                                        mCallsManager.getInCallController().bindToBTService(
-                                                null, null);
-                                    }
+                                    mCallsManager.getInCallController().bindToBTService(
+                                            null, null);
                                     // Should be able to run this as is even if above flag is
                                     // enabled (BT binding should be skipped automatically).
                                     mCallsManager.getInCallController().bindToServices(null);
@@ -2248,9 +2267,16 @@ public class TelecomServiceImpl {
                 // call is being made to a non-emergency number, the call will be denied later on
                 // by {@link UserCallIntentProcessor}.
 
-                final boolean hasCallAppOp = mAppOpsManager.noteOp(AppOpsManager.OP_CALL_PHONE,
-                        Binder.getCallingUid(), callingPackage, callingFeatureId, null)
-                        == AppOpsManager.MODE_ALLOWED;
+                final boolean hasCallAppOp;
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    hasCallAppOp = mAppOpsManager.noteOp(AppOpsManager.OPSTR_CALL_PHONE,
+                            Binder.getCallingUid(), callingPackage, callingFeatureId, null)
+                            == AppOpsManager.MODE_ALLOWED;
+                } else {
+                    hasCallAppOp = mAppOpsManager.noteOp(AppOpsManager.OP_CALL_PHONE,
+                            Binder.getCallingUid(), callingPackage, callingFeatureId, null)
+                            == AppOpsManager.MODE_ALLOWED;
+                }
 
                 final boolean hasCallPermission = mContext.checkCallingOrSelfPermission(CALL_PHONE)
                         == PackageManager.PERMISSION_GRANTED;
@@ -2824,9 +2850,7 @@ public class TelecomServiceImpl {
             try {
                 Log.startSession("TSI.sTDCRA");
                 enforceModifyPermission();
-                if (!Build.IS_USERDEBUG) {
-                    throw new SecurityException("Test-only API.");
-                }
+                enforceShellOnly(Binder.getCallingUid(), "Test-only API");
                 synchronized (mLock) {
                     long token = Binder.clearCallingIdentity();
                     try {
@@ -2846,9 +2870,7 @@ public class TelecomServiceImpl {
             try {
                 Log.startSession("TSI.sTDCSA");
                 enforceModifyPermission();
-                if (!Build.IS_USERDEBUG) {
-                    throw new SecurityException("Test-only API.");
-                }
+                enforceShellOnly(Binder.getCallingUid(), "Test-only API");
                 synchronized (mLock) {
                     long token = Binder.clearCallingIdentity();
                     try {
@@ -3016,6 +3038,53 @@ public class TelecomServiceImpl {
                 Log.endSession();
             }
         }
+
+        @Override
+        public int getCallConnectedIndicatorPreference(String callingPackage) {
+            ApiStats.ApiEvent event = new ApiStats.ApiEvent(
+                    ApiStats.API_GETCALLCONNECTEDINDICATORPREF, Binder.getCallingUid(),
+                    ApiStats.RESULT_PERMISSION);
+            try {
+                Log.startSession("TSI.gCCIPB", Log.getPackageAbbreviation(callingPackage));
+                enforcePermission(READ_PRIVILEGED_PHONE_STATE);
+                synchronized (mLock) {
+                    long token = Binder.clearCallingIdentity();
+                    event.setResult(ApiStats.RESULT_NORMAL);
+                    try {
+                        return mCallsManager.getCallConnectedIndicatorPreference();
+                    } finally {
+                        Binder.restoreCallingIdentity(token);
+                    }
+                }
+            } finally {
+                logEvent(event);
+                Log.endSession();
+            }
+        }
+
+        @Override
+        public void setCallConnectedIndicatorPreference(String callingPackage, int preference) {
+            ApiStats.ApiEvent event = new ApiStats.ApiEvent(
+                    ApiStats.API_SETCALLCONNECTEDINDICATORPREF, Binder.getCallingUid(),
+                    ApiStats.RESULT_PERMISSION);
+            try {
+                Log.startSession("TSI.sCCIPB", Log.getPackageAbbreviation(callingPackage));
+                mContext.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE,
+                        "MODIFY_PHONE_STATE required.");
+                synchronized (mLock) {
+                    long token = Binder.clearCallingIdentity();
+                    event.setResult(ApiStats.RESULT_NORMAL);
+                    try {
+                        mCallsManager.setCallConnectedIndicatorPreference(preference);
+                    } finally {
+                        Binder.restoreCallingIdentity(token);
+                    }
+                }
+            } finally {
+                logEvent(event);
+                Log.endSession();
+            }
+        }
     };
     public TelecomServiceImpl(
             Context context,
@@ -3034,6 +3103,7 @@ public class TelecomServiceImpl {
         mAppOpsManager = mContext.getSystemService(AppOpsManager.class);
 
         mPackageManager = mContext.getPackageManager();
+        mPermissionManager = mContext.getSystemService(PermissionManager.class);
 
         mCallsManager = callsManager;
         mFeatureFlags = featureFlags;
@@ -3053,6 +3123,8 @@ public class TelecomServiceImpl {
         mMetricsController = metricsController;
         mSystemUiPackageName = sysUiPackageName;
 
+        setupPackageRemovedReceiver(phoneAccountRegistrar);
+
         mDefaultDialerCache.observeDefaultDialerApplication(mContext.getMainExecutor(), userId -> {
             String defaultDialer = mDefaultDialerCache.getDefaultDialerApplication(userId);
             if (defaultDialer == null) {
@@ -3075,6 +3147,60 @@ public class TelecomServiceImpl {
                 : null;
     }
 
+    /**
+     * Helper function to initialize and register a BroadcastReceiver for package removal events.
+     * This setup runs on a background thread if the specified feature flag is enabled.
+     * Assumes this method is called only once or is protected against multiple thread creations.
+     */
+    private void setupPackageRemovedReceiver(PhoneAccountRegistrar phoneAccountRegistrar) {
+        if (!mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            Log.i(TAG, "resolveHiddenDependenciesTwo' is disabled");
+            return;
+        }
+
+        if (mPackageRemovedReceiver != null) {
+            Log.w(TAG, "PackageRemovedReceiver appears to be already initialized. Skipping setup.");
+            return;
+        }
+
+        // IMPORTANT: This thread, once started, will run for the lifetime of the process
+        // unless the process is killed, as we won't have a reference to 'quit()' it later.
+        HandlerThread localHandlerThread = new HandlerThread("TelRemoveAcctsBckgrndThread");
+        localHandlerThread.start(); // The thread starts and will keep running.
+
+        // Get a Handler associated with the local background thread's Looper.
+        Handler backgroundHandler = new Handler(localHandlerThread.getLooper());
+
+        // IntentFilter for package removal events.
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_PACKAGE_FULLY_REMOVED);
+        filter.addDataScheme("package");
+
+        mPackageRemovedReceiver = new PackageRemovedReceiver(
+                phoneAccountRegistrar,
+                backgroundHandler,
+                new UserHandleWrapper());
+
+        try {
+            Log.v(TAG, "Registering PackageRemovedReceiver (local thread) for all users" +
+                    " with RECEIVER_NOT_EXPORTED flag.");
+            mContext.registerReceiverAsUser(
+                    mPackageRemovedReceiver,
+                    UserHandle.ALL,
+                    filter,
+                    null,
+                    backgroundHandler, // Handler uses the local thread's Looper
+                    Context.RECEIVER_NOT_EXPORTED);
+            Log.v(TAG, "PackageRemovedReceiver (local thread) registered successfully.");
+        } catch (Exception e) {
+            if (localHandlerThread.isAlive()) {
+                localHandlerThread.quitSafely(); // Attempt to clean up the just-started thread
+                Log.w(TAG, "Attempted to quit localHandlerThread due to registration failure.");
+            }
+            mPackageRemovedReceiver = null;
+        }
+    }
+
     @VisibleForTesting
     public void setAnomalyReporterAdapter(AnomalyReporterAdapter mAnomalyReporterAdapter) {
         mAnomalyReporter = mAnomalyReporterAdapter;
@@ -3105,11 +3231,17 @@ public class TelecomServiceImpl {
             final String permission = Manifest.permission.ANSWER_PHONE_CALLS;
             enforcePermission(permission);
 
-            final int opCode = AppOpsManager.permissionToOpCode(permission);
-            if (opCode != AppOpsManager.OP_NONE
-                    && mAppOpsManager.checkOp(opCode, uid, packageName)
-                    != AppOpsManager.MODE_ALLOWED) {
-                return false;
+            if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                return mAppOpsManager.checkOp(AppOpsManager.OPSTR_ANSWER_PHONE_CALLS, uid,
+                        packageName) == AppOpsManager.MODE_ALLOWED;
+
+            } else {
+                final int opCode = AppOpsManager.permissionToOpCode(permission);
+                if (opCode != AppOpsManager.OP_NONE
+                        && mAppOpsManager.checkOp(opCode, uid, packageName)
+                        != AppOpsManager.MODE_ALLOWED) {
+                    return false;
+                }
             }
         }
         return true;
@@ -3124,9 +3256,16 @@ public class TelecomServiceImpl {
         mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCEPT_HANDOVER,
                 "App requires ACCEPT_HANDOVER permission to accept handovers.");
 
-        final int opCode = AppOpsManager.permissionToOpCode(Manifest.permission.ACCEPT_HANDOVER);
-        return opCode == AppOpsManager.OP_ACCEPT_HANDOVER
-                && (mAppOpsManager.checkOp(opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED);
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            return mAppOpsManager.checkOp(AppOpsManager.OPSTR_ACCEPT_HANDOVER, uid, packageName)
+                    == AppOpsManager.MODE_ALLOWED;
+        } else {
+            final int opCode = AppOpsManager.permissionToOpCode(
+                    Manifest.permission.ACCEPT_HANDOVER);
+            return opCode == AppOpsManager.OP_ACCEPT_HANDOVER
+                    && (mAppOpsManager.checkOp(opCode, uid, packageName)
+                    == AppOpsManager.MODE_ALLOWED);
+        }
     }
 
     @VisibleForTesting
@@ -3524,8 +3663,15 @@ public class TelecomServiceImpl {
             mContext.enforceCallingOrSelfPermission(READ_PHONE_STATE, message);
 
             // Some apps that have the permission can be restricted via app ops.
-            return mAppOpsManager.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(),
-                    callingPackage, callingFeatureId, message) == AppOpsManager.MODE_ALLOWED;
+            if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                return mAppOpsManager.noteOp(AppOpsManager.OPSTR_READ_PHONE_STATE,
+                        Binder.getCallingUid(),
+                        callingPackage, callingFeatureId, message) == AppOpsManager.MODE_ALLOWED;
+            } else {
+                return mAppOpsManager.noteOp(AppOpsManager.OP_READ_PHONE_STATE,
+                        Binder.getCallingUid(),
+                        callingPackage, callingFeatureId, message) == AppOpsManager.MODE_ALLOWED;
+            }
         }
     }
 
@@ -3643,9 +3789,15 @@ public class TelecomServiceImpl {
         mContext.enforceCallingOrSelfPermission(CALL_PHONE, message);
 
         // Some apps that have the permission can be restricted via app ops.
-        return mAppOpsManager.noteOp(AppOpsManager.OP_CALL_PHONE,
-                Binder.getCallingUid(), callingPackage, callingFeatureId, message)
-                == AppOpsManager.MODE_ALLOWED;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            return mAppOpsManager.noteOp(AppOpsManager.OPSTR_CALL_PHONE, Binder.getCallingUid(),
+                    callingPackage, callingFeatureId, message)
+                    == AppOpsManager.MODE_ALLOWED;
+        } else {
+            return mAppOpsManager.noteOp(AppOpsManager.OP_CALL_PHONE,
+                    Binder.getCallingUid(), callingPackage, callingFeatureId, message)
+                    == AppOpsManager.MODE_ALLOWED;
+        }
     }
 
     private boolean canGetPhoneAccount(String callingPackage, PhoneAccountHandle accountHandle) {
diff --git a/src/com/android/server/telecom/TelecomSystem.java b/src/com/android/server/telecom/TelecomSystem.java
index 50a0a7f03..274f295f1 100644
--- a/src/com/android/server/telecom/TelecomSystem.java
+++ b/src/com/android/server/telecom/TelecomSystem.java
@@ -24,6 +24,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
 import android.os.BugreportManager;
@@ -233,7 +234,8 @@ public class TelecomSystem {
             BlockedNumbersAdapter blockedNumbersAdapter,
             FeatureFlags featureFlags,
             com.android.internal.telephony.flags.FeatureFlags telephonyFlags,
-            Looper looper) {
+            Looper looper,
+            Ringer.VibratorAdapter vibratorAdapter) {
         mContext = context.getApplicationContext();
         mFeatureFlags = featureFlags;
         LogUtils.initLogging(mContext);
@@ -243,7 +245,7 @@ public class TelecomSystem {
                 new DefaultDialerCache.DefaultDialerManagerAdapterImpl();
 
         DefaultDialerCache defaultDialerCache = new DefaultDialerCache(mContext,
-                defaultDialerAdapter, roleManagerAdapter, mLock);
+                defaultDialerAdapter, roleManagerAdapter, mLock, mFeatureFlags);
 
         Log.startSession("TS.init");
         // Wrap this in a try block to ensure session cleanup occurs in the case of error.
@@ -319,8 +321,14 @@ public class TelecomSystem {
                                 @Override
                                 public List<ResolveInfo> queryIntentServicesAsUser(
                                         @NonNull Intent intent, int flags, int userId) {
-                                    return mContext.getPackageManager().queryIntentServicesAsUser(
-                                            intent, flags, userId);
+                                    PackageManager pm;
+                                    if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                                        pm = UserUtil.getPackageManagerFromUserHandler(mContext,
+                                                UserHandle.of(userId));
+                                    } else {
+                                        pm = mContext.getPackageManager();
+                                    }
+                                    return pm.queryIntentServicesAsUser(intent, flags, userId);
                                 }
 
                                 @Override
@@ -347,7 +355,7 @@ public class TelecomSystem {
                     );
 
             AudioProcessingNotification audioProcessingNotification =
-                    new AudioProcessingNotification(mContext);
+                    new AudioProcessingNotification(mContext, mFeatureFlags);
 
             ToastFactory toastFactory = new ToastFactory() {
                 @Override
@@ -391,7 +399,10 @@ public class TelecomSystem {
             CallStreamingNotification callStreamingNotification =
                     new CallStreamingNotification(mContext,
                             (packageName, userHandle) -> AppLabelProxy.Util.getAppLabel(mContext,
-                                    userHandle, packageName, mFeatureFlags), asyncTaskExecutor);
+                                    userHandle, packageName, mFeatureFlags), asyncTaskExecutor,
+                            mFeatureFlags);
+            CallAudioRouteController.Factory audioRouteControllerFactory =
+                    new CallAudioRouteController.Factory();
 
             mCallsManager = new CallsManager(
                     mContext,
@@ -417,7 +428,7 @@ public class TelecomSystem {
                     clockProxy,
                     audioProcessingNotification,
                     bluetoothStateReceiver,
-                    callAudioRouteStateMachineFactory,
+                    audioRouteControllerFactory,
                     callAudioModeStateMachineFactory,
                     inCallControllerFactory,
                     callDiagnosticServiceController,
@@ -437,7 +448,8 @@ public class TelecomSystem {
                     featureFlags,
                     telephonyFlags,
                     IncomingCallFilterGraph::new,
-                    metricsController);
+                    metricsController,
+                    vibratorAdapter);
 
             mIncomingCallNotifier = incomingCallNotifier;
             incomingCallNotifier.setCallsManagerProxy(new IncomingCallNotifier.CallsManagerProxy() {
@@ -466,12 +478,22 @@ public class TelecomSystem {
                 asyncTaskExecutor, featureFlags);
             mCallsManager.setRespondViaSmsManager(mRespondViaSmsManager);
 
-            mContext.registerReceiverAsUser(mUserSwitchedReceiver, UserHandle.ALL,
-                    USER_SWITCHED_FILTER, null, null);
-            mContext.registerReceiverAsUser(mUserStartingReceiver, UserHandle.ALL,
-                    USER_STARTING_FILTER, null, null);
-            mContext.registerReceiverAsUser(mBootCompletedReceiver, UserHandle.ALL,
-                    BOOT_COMPLETE_FILTER, null, null);
+            Context userContext = mContext.createContextAsUser(UserHandle.ALL, 0);
+            if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                userContext.registerReceiver(mUserSwitchedReceiver, USER_SWITCHED_FILTER,
+                        Context.RECEIVER_NOT_EXPORTED);
+                userContext.registerReceiver(mUserStartingReceiver, USER_STARTING_FILTER,
+                        Context.RECEIVER_NOT_EXPORTED);
+                userContext.registerReceiver(mBootCompletedReceiver, BOOT_COMPLETE_FILTER,
+                        Context.RECEIVER_NOT_EXPORTED);
+            } else {
+                mContext.registerReceiverAsUser(mUserSwitchedReceiver, UserHandle.ALL,
+                        USER_SWITCHED_FILTER, null, null, Context.RECEIVER_NOT_EXPORTED);
+                mContext.registerReceiverAsUser(mUserStartingReceiver, UserHandle.ALL,
+                        USER_STARTING_FILTER, null, null, Context.RECEIVER_NOT_EXPORTED);
+                mContext.registerReceiverAsUser(mBootCompletedReceiver, UserHandle.ALL,
+                        BOOT_COMPLETE_FILTER, null, null, Context.RECEIVER_NOT_EXPORTED);
+            }
 
             // Set current user explicitly since USER_SWITCHED_FILTER intent can be missed at
             // startup
@@ -484,7 +506,7 @@ public class TelecomSystem {
             mCallIntentProcessor = new CallIntentProcessor(mContext, mCallsManager,
                     defaultDialerCache, featureFlags);
             mTelecomBroadcastIntentProcessor = new TelecomBroadcastIntentProcessor(
-                    mContext, mCallsManager);
+                    mContext, mCallsManager, mFeatureFlags);
 
             // Register the receiver for the dialer secret codes, used to enable extended logging.
             mDialerCodeReceiver = new DialerCodeReceiver(mCallsManager);
diff --git a/src/com/android/server/telecom/Timeouts.java b/src/com/android/server/telecom/Timeouts.java
index ee1825009..bb0641b57 100644
--- a/src/com/android/server/telecom/Timeouts.java
+++ b/src/com/android/server/telecom/Timeouts.java
@@ -16,13 +16,14 @@
 
 package com.android.server.telecom;
 
-import android.content.ContentResolver;
+import android.content.Context;
 import android.provider.DeviceConfig;
 import android.provider.Settings;
 import android.telecom.CallDiagnosticService;
 import android.telecom.CallDiagnostics;
 import android.telecom.CallRedirectionService;
 import android.telephony.ims.ImsReasonInfo;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.concurrent.TimeUnit;
 
@@ -37,56 +38,52 @@ public final class Timeouts {
         public Adapter() {
         }
 
-        public long getCallScreeningTimeoutMillis(ContentResolver cr) {
-            return Timeouts.getCallScreeningTimeoutMillis(cr);
+        public long getCallScreeningTimeoutMillis(Context c, FeatureFlags f) {
+            return Timeouts.getCallScreeningTimeoutMillis(c, f);
         }
 
-        public long getCallBindBluetoothInCallServicesDelay(ContentResolver cr) {
-            return Timeouts.getCallBindBluetoothInCallServicesDelay(cr);
+        public long getCallBindBluetoothInCallServicesDelay(Context c, FeatureFlags f) {
+            return Timeouts.getCallBindBluetoothInCallServicesDelay(c, f);
         }
 
-        public long getCallRemoveUnbindInCallServicesDelay(ContentResolver cr) {
-            return Timeouts.getCallRemoveUnbindInCallServicesDelay(cr);
+        public long getCallRemoveUnbindInCallServicesDelay(Context c, FeatureFlags f) {
+            return Timeouts.getCallRemoveUnbindInCallServicesDelay(c, f);
         }
 
-        public long getRetryBluetoothConnectAudioBackoffMillis(ContentResolver cr) {
-            return Timeouts.getRetryBluetoothConnectAudioBackoffMillis(cr);
+        public long getRetryBluetoothConnectAudioBackoffMillis(Context c, FeatureFlags f) {
+            return Timeouts.getRetryBluetoothConnectAudioBackoffMillis(c, f);
         }
 
-        public long getBluetoothPendingTimeoutMillis(ContentResolver cr) {
-            return Timeouts.getBluetoothPendingTimeoutMillis(cr);
+        public long getBluetoothPendingTimeoutMillis(Context c, FeatureFlags f) {
+            return Timeouts.getBluetoothPendingTimeoutMillis(c, f);
         }
 
-        public long getEmergencyCallbackWindowMillis(ContentResolver cr) {
-            return Timeouts.getEmergencyCallbackWindowMillis(cr);
+        public long getEmergencyCallbackWindowMillis(Context c, FeatureFlags f) {
+            return Timeouts.getEmergencyCallbackWindowMillis(c, f);
         }
 
-        public long getEmergencyCallTimeoutMillis(ContentResolver cr) {
-            return Timeouts.getEmergencyCallTimeoutMillis(cr);
+        public long getEmergencyCallTimeoutMillis(Context c, FeatureFlags f) {
+            return Timeouts.getEmergencyCallTimeoutMillis(c, f);
         }
 
-        public long getEmergencyCallTimeoutRadioOffMillis(ContentResolver cr) {
-            return Timeouts.getEmergencyCallTimeoutRadioOffMillis(cr);
+        public long getEmergencyCallTimeoutRadioOffMillis(Context c, FeatureFlags f) {
+            return Timeouts.getEmergencyCallTimeoutRadioOffMillis(c, f);
         }
 
-        public long getUserDefinedCallRedirectionTimeoutMillis(ContentResolver cr) {
-            return Timeouts.getUserDefinedCallRedirectionTimeoutMillis(cr);
+        public long getUserDefinedCallRedirectionTimeoutMillis(Context c, FeatureFlags f) {
+            return Timeouts.getUserDefinedCallRedirectionTimeoutMillis(c, f);
         }
 
-        public long getCarrierCallRedirectionTimeoutMillis(ContentResolver cr) {
-            return Timeouts.getCarrierCallRedirectionTimeoutMillis(cr);
+        public long getCarrierCallRedirectionTimeoutMillis(Context c, FeatureFlags f) {
+            return Timeouts.getCarrierCallRedirectionTimeoutMillis(c, f);
         }
 
-        public long getPhoneAccountSuggestionServiceTimeout(ContentResolver cr) {
-            return Timeouts.getPhoneAccountSuggestionServiceTimeout(cr);
+        public long getCallRecordingToneRepeatIntervalMillis(Context c, FeatureFlags f) {
+            return Timeouts.getCallRecordingToneRepeatIntervalMillis(c, f);
         }
 
-        public long getCallRecordingToneRepeatIntervalMillis(ContentResolver cr) {
-            return Timeouts.getCallRecordingToneRepeatIntervalMillis(cr);
-        }
-
-        public long getCallDiagnosticServiceTimeoutMillis(ContentResolver cr) {
-            return Timeouts.getCallDiagnosticServiceTimeoutMillis(cr);
+        public long getCallDiagnosticServiceTimeoutMillis(Context c, FeatureFlags f) {
+            return Timeouts.getCallDiagnosticServiceTimeoutMillis(c, f);
         }
 
         public long getCallStartAppOpDebounceIntervalMillis() {
@@ -225,14 +222,15 @@ public final class Timeouts {
      * Returns the timeout value from Settings or the default value if it hasn't been changed. This
      * method is safe to call from any thread, including the UI thread.
      *
-     * @param contentResolver The content resolved.
+     * @param context         To get the ContentResolver and user Id
+     * @param flags           Telecom flags to gate changes
      * @param key             Settings key to retrieve.
      * @param defaultValue    Default value, in milliseconds.
      * @return The timeout value from Settings or the default value if it hasn't been changed.
      */
-    private static long get(ContentResolver contentResolver, String key, long defaultValue) {
-        return Settings.Secure.getLongForUser(contentResolver, PREFIX + key, defaultValue,
-                        contentResolver.getUserId());
+    private static long get(Context context, FeatureFlags flags, String key, long defaultValue) {
+        return Settings.Secure.getLongForUser(context.getContentResolver(),
+                PREFIX + key, defaultValue, UserUtil.getUserIdFromContext(context, flags));
     }
 
     /**
@@ -241,8 +239,8 @@ public final class Timeouts {
      * to reuse the existing call, preventing the call from causing a start->end->start jank in the
      * in-call UI.
      */
-    public static long getNewOutgoingCallCancelMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "new_outgoing_call_cancel_ms", 500L);
+    public static long getNewOutgoingCallCancelMillis(Context c, FeatureFlags f) {
+        return get(c, f, "new_outgoing_call_cancel_ms", 500L);
     }
 
     /**
@@ -250,8 +248,8 @@ public final class Timeouts {
      * NEW_OUTGOING_CALL broadcast. This prevents malicious or poorly configured apps from
      * forever tying up the Telecom stack.
      */
-    public static long getMaxNewOutgoingCallCancelMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "max_new_outgoing_call_cancel_ms", 10000L);
+    public static long getMaxNewOutgoingCallCancelMillis(Context c, FeatureFlags f) {
+        return get(c, f, "max_new_outgoing_call_cancel_ms", 10000L);
     }
 
     /**
@@ -259,16 +257,16 @@ public final class Timeouts {
      * This timeout allows the current tone to play for a certain amount of time before either being
      * interrupted by the next tone or terminated.
      */
-    public static long getDelayBetweenDtmfTonesMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "delay_between_dtmf_tones_ms", 300L);
+    public static long getDelayBetweenDtmfTonesMillis(Context c, FeatureFlags f) {
+        return get(c, f, "delay_between_dtmf_tones_ms", 300L);
     }
 
     /**
      * Returns the amount of time to wait for an emergency call to be placed before routing to
      * a different call service. A value of 0 or less means no timeout should be used.
      */
-    public static long getEmergencyCallTimeoutMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "emergency_call_timeout_millis", 25000L /* 25 seconds */);
+    public static long getEmergencyCallTimeoutMillis(Context c, FeatureFlags f) {
+        return get(c, f, "emergency_call_timeout_millis", 25000L /* 25 seconds */);
     }
 
     /**
@@ -276,23 +274,20 @@ public final class Timeouts {
      * a different call service. This timeout is used only when the radio is powered off (for
      * example in airplane mode). A value of 0 or less means no timeout should be used.
      */
-    public static long getEmergencyCallTimeoutRadioOffMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "emergency_call_timeout_radio_off_millis",
-                60000L /* 1 minute */);
+    public static long getEmergencyCallTimeoutRadioOffMillis(Context c, FeatureFlags f) {
+        return get(c, f, "emergency_call_timeout_radio_off_millis", 60000L /* 1 minute */);
     }
 
-    public static long getCallBindBluetoothInCallServicesDelay(ContentResolver contentResolver) {
-        return get(contentResolver, "call_bind_bluetooth_in_call_services_delay",
-                2000L /* 2 seconds */);
+    public static long getCallBindBluetoothInCallServicesDelay(Context c, FeatureFlags f) {
+        return get(c, f, "call_bind_bluetooth_in_call_services_delay", 2000L /* 2 seconds */);
     }
 
     /**
      * Returns the amount of delay before unbinding the in-call services after all the calls
      * are removed.
      */
-    public static long getCallRemoveUnbindInCallServicesDelay(ContentResolver contentResolver) {
-        return get(contentResolver, "call_remove_unbind_in_call_services_delay",
-                2000L /* 2 seconds */);
+    public static long getCallRemoveUnbindInCallServicesDelay(Context c, FeatureFlags f) {
+        return get(c, f, "call_remove_unbind_in_call_services_delay", 2000L /* 2 seconds */);
     }
 
     /**
@@ -300,8 +295,8 @@ public final class Timeouts {
      * connection. This compensates for the amount of time it takes for the audio route to
      * actually change to bluetooth.
      */
-    public static long getBluetoothPendingTimeoutMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "bluetooth_pending_timeout_millis", 5000L);
+    public static long getBluetoothPendingTimeoutMillis(Context c, FeatureFlags f) {
+        return get(c, f, "bluetooth_pending_timeout_millis", 5000L);
     }
 
     /**
@@ -309,70 +304,63 @@ public final class Timeouts {
      * necessary to account for the HeadsetStateMachine sometimes not being ready when we want to
      * connect to bluetooth audio immediately after a device connects.
      */
-    public static long getRetryBluetoothConnectAudioBackoffMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "retry_bluetooth_connect_audio_backoff_millis", 500L);
+    public static long getRetryBluetoothConnectAudioBackoffMillis(Context c, FeatureFlags f) {
+        return get(c, f, "retry_bluetooth_connect_audio_backoff_millis", 500L);
     }
 
     /**
      * Returns the amount of time to wait for the phone account suggestion service to reply.
      */
-    public static long getPhoneAccountSuggestionServiceTimeout(ContentResolver contentResolver) {
-        return get(contentResolver, "phone_account_suggestion_service_timeout",
-                5000L /* 5 seconds */);
+    public static long getPhoneAccountSuggestionServiceTimeout(Context c, FeatureFlags f) {
+        return get(c, f, "phone_account_suggestion_service_timeout", 5000L /* 5 seconds */);
     }
 
     /**
      * Returns the amount of time to wait for the call screening service to allow or disallow a
      * call.
      */
-    public static long getCallScreeningTimeoutMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "call_screening_timeout", 5000L /* 5 seconds */);
+    public static long getCallScreeningTimeoutMillis(Context c, FeatureFlags f) {
+        return get(c, f, "call_screening_timeout", 5000L /* 5 seconds */);
     }
 
     /**
      * Returns the amount of time after an emergency call that incoming calls should be treated
      * as potential emergency callbacks.
      */
-    public static long getEmergencyCallbackWindowMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "emergency_callback_window_millis",
+    public static long getEmergencyCallbackWindowMillis(Context c, FeatureFlags f) {
+        return get(c, f, "emergency_callback_window_millis",
                 TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES));
     }
 
     /**
      * Returns the amount of time for an user-defined {@link CallRedirectionService}.
-     *
-     * @param contentResolver The content resolver.
      */
-    public static long getUserDefinedCallRedirectionTimeoutMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "user_defined_call_redirection_timeout",
-                5000L /* 5 seconds */);
+    public static long getUserDefinedCallRedirectionTimeoutMillis(Context c, FeatureFlags f) {
+        return get(c, f, "user_defined_call_redirection_timeout", 5000L /* 5 seconds */);
     }
 
     /**
      * Returns the amount of time for a carrier {@link CallRedirectionService}.
-     *
-     * @param contentResolver The content resolver.
      */
-    public static long getCarrierCallRedirectionTimeoutMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "carrier_call_redirection_timeout", 5000L /* 5 seconds */);
+    public static long getCarrierCallRedirectionTimeoutMillis(Context c, FeatureFlags f) {
+        return get(c, f, "carrier_call_redirection_timeout", 5000L /* 5 seconds */);
     }
 
     /**
      * Returns the number of milliseconds between two plays of the call recording tone.
      */
-    public static long getCallRecordingToneRepeatIntervalMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "call_recording_tone_repeat_interval", 15000L /* 15 seconds */);
+    public static long getCallRecordingToneRepeatIntervalMillis(Context c, FeatureFlags f) {
+        return get(c, f, "call_recording_tone_repeat_interval", 15000L /* 15 seconds */);
     }
 
     /**
      * Returns the maximum amount of time a {@link CallDiagnosticService} is permitted to take to
      * return back from {@link CallDiagnostics#onCallDisconnected(ImsReasonInfo)} and
      * {@link CallDiagnostics#onCallDisconnected(int, int)}.
-     * @param contentResolver The resolver for the config option.
      * @return The timeout in millis.
      */
-    public static long getCallDiagnosticServiceTimeoutMillis(ContentResolver contentResolver) {
-        return get(contentResolver, "call_diagnostic_service_timeout", 2000L /* 2 sec */);
+    public static long getCallDiagnosticServiceTimeoutMillis(Context c, FeatureFlags f) {
+        return get(c, f, "call_diagnostic_service_timeout", 2000L /* 2 sec */);
     }
 
     /**
@@ -494,9 +482,8 @@ public final class Timeouts {
      * power save restrictions due to the dialer needing to handle a missed call notification
      * (update call log, check VVM, etc...).
      */
-    public static long getDialerMissedCallPowerSaveExemptionTimeMillis(
-            ContentResolver contentResolver) {
-        return get(contentResolver, "dialer_missed_call_power_save_exemption_time_millis",
+    public static long getDialerMissedCallPowerSaveExemptionTimeMillis(Context c, FeatureFlags f) {
+        return get(c, f, "dialer_missed_call_power_save_exemption_time_millis",
                 30000L /*30 seconds*/);
     }
 }
diff --git a/src/com/android/server/telecom/TransactionalServiceWrapper.java b/src/com/android/server/telecom/TransactionalServiceWrapper.java
index cc0d54771..4dfc18f00 100644
--- a/src/com/android/server/telecom/TransactionalServiceWrapper.java
+++ b/src/com/android/server/telecom/TransactionalServiceWrapper.java
@@ -33,20 +33,19 @@ import android.telecom.CallStreamingService;
 import android.telecom.DisconnectCause;
 import android.telecom.Log;
 import android.telecom.PhoneAccountHandle;
-import android.text.TextUtils;
 
 import androidx.annotation.VisibleForTesting;
 
 import com.android.internal.telecom.ICallControl;
 import com.android.internal.telecom.ICallEventCallback;
+import com.android.server.telecom.callsequencing.CallTransaction;
+import com.android.server.telecom.callsequencing.CallTransactionResult;
+import com.android.server.telecom.callsequencing.TransactionManager;
 import com.android.server.telecom.callsequencing.TransactionalCallSequencingAdapter;
 import com.android.server.telecom.callsequencing.voip.CallEventCallbackAckTransaction;
 import com.android.server.telecom.callsequencing.voip.EndpointChangeTransaction;
-import com.android.server.telecom.callsequencing.voip.SetMuteStateTransaction;
 import com.android.server.telecom.callsequencing.voip.RequestVideoStateTransaction;
-import com.android.server.telecom.callsequencing.TransactionManager;
-import com.android.server.telecom.callsequencing.CallTransaction;
-import com.android.server.telecom.callsequencing.CallTransactionResult;
+import com.android.server.telecom.callsequencing.voip.SetMuteStateTransaction;
 import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.Locale;
@@ -310,8 +309,8 @@ public class TransactionalServiceWrapper implements
             } else {
                 Bundle exceptionBundle = new Bundle();
                 exceptionBundle.putParcelable(TRANSACTION_EXCEPTION_KEY,
-                        new CallException(TextUtils.formatSimple(
-                        "Telecom cannot process [%s] because the call with id=[%s] is no longer "
+                        new CallException(String.format("Telecom cannot process [%s] because the"
+                                + " call with id=[%s] is no longer "
                                 + "being tracked. This is most likely a result of the call "
                                 + "already being disconnected and removed. Try re-adding the call"
                                 + " via TelecomManager#addCall", action, callId),
diff --git a/src/com/android/server/telecom/TtyManager.java b/src/com/android/server/telecom/TtyManager.java
index 53e917d7e..9b945258f 100644
--- a/src/com/android/server/telecom/TtyManager.java
+++ b/src/com/android/server/telecom/TtyManager.java
@@ -27,8 +27,7 @@ import android.telecom.Log;
 import android.telecom.TelecomManager;
 
 import com.android.internal.util.IndentingPrintWriter;
-
-// TODO: Needed for move to system service: import com.android.internal.R;
+import com.android.server.telecom.flags.FeatureFlags;
 
 final class TtyManager implements WiredHeadsetManager.Listener {
     private final TtyBroadcastReceiver mReceiver = new TtyBroadcastReceiver();
@@ -37,7 +36,9 @@ final class TtyManager implements WiredHeadsetManager.Listener {
     private int mPreferredTtyMode = TelecomManager.TTY_MODE_OFF;
     private int mCurrentTtyMode = TelecomManager.TTY_MODE_OFF;
 
-    TtyManager(Context context, WiredHeadsetManager wiredHeadsetManager) {
+    TtyManager(Context context,
+            WiredHeadsetManager wiredHeadsetManager,
+            FeatureFlags featureFlags) {
         mContext = context;
         mWiredHeadsetManager = wiredHeadsetManager;
         mWiredHeadsetManager.addListener(this);
@@ -46,7 +47,7 @@ final class TtyManager implements WiredHeadsetManager.Listener {
                 mContext.getContentResolver(),
                 Settings.Secure.PREFERRED_TTY_MODE,
                 TelecomManager.TTY_MODE_OFF,
-                mContext.getUserId());
+                UserUtil.getUserIdFromContext(context, featureFlags));
 
         IntentFilter intentFilter = new IntentFilter(
                 TelecomManager.ACTION_TTY_PREFERRED_MODE_CHANGED);
diff --git a/src/com/android/server/telecom/UserHandleWrapper.java b/src/com/android/server/telecom/UserHandleWrapper.java
new file mode 100644
index 000000000..d09242e3f
--- /dev/null
+++ b/src/com/android/server/telecom/UserHandleWrapper.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.server.telecom;
+
+import android.os.UserHandle;
+
+/**
+ * Wrapper for static methods of UserHandle to allow mocking in tests.
+ */
+public class UserHandleWrapper {
+    public UserHandle getUserHandleForUid(int uid) {
+        return UserHandle.getUserHandleForUid(uid);
+    }
+}
diff --git a/src/com/android/server/telecom/UserUtil.java b/src/com/android/server/telecom/UserUtil.java
index 8c124c8a3..706fb7e86 100644
--- a/src/com/android/server/telecom/UserUtil.java
+++ b/src/com/android/server/telecom/UserUtil.java
@@ -16,9 +16,12 @@
 
 package com.android.server.telecom;
 
+import android.app.Notification;
+import android.app.NotificationManager;
 import android.app.admin.DevicePolicyManager;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.content.pm.UserInfo;
 import android.net.Uri;
 import android.os.UserHandle;
@@ -37,6 +40,11 @@ public final class UserUtil {
 
     private static final String LOG_TAG = "UserUtil";
 
+    public static int getUserIdFromContext(Context context, FeatureFlags featureFlags){
+        return featureFlags.resolveHiddenDependenciesTwo() ? context.getUser().getIdentifier() :
+                context.getUserId();
+    }
+
     private static UserInfo getUserInfoFromUserHandle(Context context, UserHandle userHandle) {
         UserManager userManager = context.getSystemService(UserManager.class);
         return userManager.getUserInfo(userHandle.getIdentifier());
@@ -54,6 +62,12 @@ public final class UserUtil {
         return userManager;
     }
 
+    public static PackageManager getPackageManagerFromUserHandler(Context classLevelContext,
+                                                                   UserHandle userHandle) {
+        Context userContext = classLevelContext.createContextAsUser(userHandle, 0);
+        return userContext.getPackageManager();
+    }
+
     public static boolean isManagedProfile(Context context, UserHandle userHandle,
             FeatureFlags featureFlags) {
         UserManager userManager = getUserManagerFromUserHandle(context, userHandle);
@@ -110,8 +124,7 @@ public final class UserUtil {
                 // Only emergency calls are allowed for users with the DISALLOW_OUTGOING_CALLS
                 // restriction.
                 if (!TelephonyUtil.shouldProcessAsEmergency(context, handle)) {
-                    if (userManager.hasBaseUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS,
-                            userHandle)) {
+                    if (hasDisallowOutgoingCalls(context, userManager, userHandle, featureFlags)) {
                         String reason = "of DISALLOW_OUTGOING_CALLS restriction";
                         showErrorDialogForRestrictedOutgoingCall(context,
                                 R.string.outgoing_call_not_allowed_user_restriction, tag, reason);
@@ -135,6 +148,42 @@ public final class UserUtil {
         return false;
     }
 
+    /**
+     * Checks if the {@link UserManager#DISALLOW_OUTGOING_CALLS} restriction is active for the given
+     * user, correctly handling managed profiles by checking the restriction on the parent user.
+     *
+     * <p>This function determines the "base" user, which is the parent user for a profile or the
+     * user itself otherwise. It then checks if the restriction is applied to that base user.
+     *
+     * @return {@code true} if outgoing calls are disallowed for the user, {@code false} otherwise.
+     * Returns {@code false} if an error occurs during the check (e.g., missing permissions).
+     */
+    private static boolean hasDisallowOutgoingCalls(
+            Context context,
+            UserManager userManager,
+            UserHandle user,
+            FeatureFlags featureFlags){
+        if(featureFlags.resolveHiddenDependenciesTwo()){
+            UserHandle parent = userManager.getProfileParent(user);
+            UserHandle baseUser = (parent != null) ? parent : user;
+            try {
+                Context baseUserContext = context.createContextAsUser(baseUser, 0);
+                UserManager baseUserManager = baseUserContext.getSystemService(UserManager.class);
+                if (baseUserManager != null) {
+                    return baseUserManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS);
+                }
+                return false;
+            } catch (Exception e) {
+                Log.e("UserUtil", e, "hasDisallowOutgoingCalls: caught exception");
+                return false;
+            }
+        }
+        else{
+            return userManager.hasBaseUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS,
+                    user);
+        }
+    }
+
     /**
      * Gets the associated user for the given call. Note: this is applicable to all calls except
      * outgoing calls as the associated user is already based off of the user placing the
@@ -148,12 +197,8 @@ public final class UserUtil {
      * phone account handle user, otherwise return the target phone account handle user. If the
      * flag is disabled, return the legacy {@link UserHandle}.
      */
-    public static UserHandle getAssociatedUserForCall(boolean isAssociatedUserFlagEnabled,
-            PhoneAccountRegistrar phoneAccountRegistrar, UserHandle currentUser,
-            PhoneAccountHandle targetPhoneAccount) {
-        if (!isAssociatedUserFlagEnabled) {
-            return targetPhoneAccount.getUserHandle();
-        }
+    public static UserHandle getAssociatedUserForCall(PhoneAccountRegistrar phoneAccountRegistrar,
+            UserHandle currentUser, PhoneAccountHandle targetPhoneAccount) {
         // For multi-user phone accounts, associate the call with the profile receiving/placing
         // the call. For SIM accounts (that are assigned to specific users), the user association
         // will be placed on the target phone account handle user.
@@ -167,4 +212,28 @@ public final class UserUtil {
         // return the current user.
         return currentUser;
     }
+
+    public static void processNotification(Context context, UserHandle userHandle, String tag,
+            int id, Notification notification, FeatureFlags featureFlags) {
+        if (featureFlags.resolveHiddenDependenciesTwo()) {
+            Context userContext = context.createContextAsUser(userHandle, 0);
+            NotificationManager userNotificationMgr = userContext.getSystemService(
+                    NotificationManager.class);
+            if (userNotificationMgr != null) {
+                if (notification != null) {
+                    userNotificationMgr.notify(tag, id, notification);
+                } else {
+                    userNotificationMgr.cancel(tag, id);
+                }
+            }
+        } else {
+            NotificationManager notificationMgr = (NotificationManager) context.getSystemService(
+                    Context.NOTIFICATION_SERVICE);
+            if (notification != null) {
+                notificationMgr.notifyAsUser(tag, id, notification, userHandle);
+            } else {
+                notificationMgr.cancelAsUser(tag, id, userHandle);
+            }
+        }
+    }
 }
diff --git a/src/com/android/server/telecom/VideoProviderProxy.java b/src/com/android/server/telecom/VideoProviderProxy.java
index df1140304..34359eaf0 100644
--- a/src/com/android/server/telecom/VideoProviderProxy.java
+++ b/src/com/android/server/telecom/VideoProviderProxy.java
@@ -35,6 +35,7 @@ import android.view.Surface;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telecom.IVideoCallback;
 import com.android.internal.telecom.IVideoProvider;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.Collections;
 import java.util.Set;
@@ -89,6 +90,8 @@ public class VideoProviderProxy extends Connection.VideoProvider {
      */
     private Call mCall;
 
+    private FeatureFlags mFeatureFlags;
+
     /**
      * Interface providing access to the currently logged in user.
      */
@@ -112,7 +115,8 @@ public class VideoProviderProxy extends Connection.VideoProvider {
      * @throws RemoteException Remote exception.
      */
     public VideoProviderProxy(TelecomSystem.SyncRoot lock,
-            IVideoProvider videoProvider, Call call, CurrentUserProxy currentUserProxy)
+            IVideoProvider videoProvider, Call call, CurrentUserProxy currentUserProxy,
+            FeatureFlags featureFlags)
             throws RemoteException {
 
         super(Looper.getMainLooper());
@@ -126,6 +130,7 @@ public class VideoProviderProxy extends Connection.VideoProvider {
         mConectionServiceVideoProvider.addVideoCallback(mVideoCallListenerBinder);
         mCall = call;
         mCurrentUserProxy = currentUserProxy;
+        mFeatureFlags = featureFlags;
     }
 
     public void clearVideoCallback() {
@@ -600,8 +605,13 @@ public class VideoProviderProxy extends Connection.VideoProvider {
 
         try {
             // Some apps that have the permission can be restricted via app ops.
-            return appOpsManager != null && appOpsManager.noteOp(AppOpsManager.OP_CAMERA,
-                    callingUid, callingPackage) == AppOpsManager.MODE_ALLOWED;
+            if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                return appOpsManager != null && appOpsManager.noteOp(AppOpsManager.OPSTR_CAMERA,
+                        callingUid, callingPackage) == AppOpsManager.MODE_ALLOWED;
+            } else {
+                return appOpsManager != null && appOpsManager.noteOp(AppOpsManager.OP_CAMERA,
+                        callingUid, callingPackage) == AppOpsManager.MODE_ALLOWED;
+            }
         } catch (SecurityException se) {
             Log.w(this, "canUseCamera got appOpps Exception " + se.toString());
             return false;
diff --git a/src/com/android/server/telecom/bluetooth/BluetoothDeviceManager.java b/src/com/android/server/telecom/bluetooth/BluetoothDeviceManager.java
index eda8c64d3..66b762543 100644
--- a/src/com/android/server/telecom/bluetooth/BluetoothDeviceManager.java
+++ b/src/com/android/server/telecom/bluetooth/BluetoothDeviceManager.java
@@ -124,9 +124,7 @@ public class BluetoothDeviceManager {
                         synchronized (mLock) {
                             String logString;
                             if (profile == BluetoothProfile.HEADSET) {
-                                if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                                    mBluetoothHeadsetFuture.complete((BluetoothHeadset) proxy);
-                                }
+                                mBluetoothHeadsetFuture.complete((BluetoothHeadset) proxy);
                                 mBluetoothHeadset = (BluetoothHeadset) proxy;
                                 logString = "Got BluetoothHeadset: " + mBluetoothHeadset;
                             } else if (profile == BluetoothProfile.HEARING_AID) {
@@ -194,9 +192,7 @@ public class BluetoothDeviceManager {
                             LinkedHashMap<String, BluetoothDevice> lostServiceDevices;
                             String logString;
                             if (profile == BluetoothProfile.HEADSET) {
-                                if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                                    mBluetoothHeadsetFuture.complete(null);
-                                }
+                                mBluetoothHeadsetFuture = new CompletableFuture<>();
                                 mBluetoothHeadset = null;
                                 lostServiceDevices = mHfpDevicesByAddress;
                                 mBluetoothRouteManager.onActiveDeviceChanged(null,
@@ -222,17 +218,7 @@ public class BluetoothDeviceManager {
                             }
                             Log.i(BluetoothDeviceManager.this, logString);
                             mLocalLog.log(logString);
-
-                            if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                                handleAudioRefactoringServiceDisconnected(profile);
-                            } else {
-                                List<BluetoothDevice> devicesToRemove = new LinkedList<>(
-                                        lostServiceDevices.values());
-                                lostServiceDevices.clear();
-                                for (BluetoothDevice device : devicesToRemove) {
-                                    mBluetoothRouteManager.onDeviceLost(device.getAddress());
-                                }
-                            }
+                            handleAudioRefactoringServiceDisconnected(profile);
                         }
                     } finally {
                         Log.endSession();
@@ -269,21 +255,16 @@ public class BluetoothDeviceManager {
                     BT_DEVICE_REMOVED, route.getType(), device);
         }
 
-        if (mFeatureFlags.skipBaselineSwitchWhenRouteNotBluetooth()) {
-            CallAudioState currentAudioState = controller.getCurrentCallAudioState();
-            int currentRoute = currentAudioState.getRoute();
-            if (currentRoute == CallAudioState.ROUTE_BLUETOOTH) {
-                Log.d(this, "handleAudioRefactoringServiceDisconnected: call audio "
-                        + "is currently routed to BT so switching back to baseline");
-                mCallAudioRouteAdapter.sendMessageWithSessionInfo(
-                        SWITCH_BASELINE_ROUTE, INCLUDE_BLUETOOTH_IN_BASELINE, (String) null);
-            } else {
-                Log.d(this, "handleAudioRefactoringServiceDisconnected: call audio "
-                        + "is not currently routed to BT so skipping switch to baseline");
-            }
-        } else {
+        CallAudioState currentAudioState = controller.getCurrentCallAudioState();
+        int currentRoute = currentAudioState.getRoute();
+        if (currentRoute == CallAudioState.ROUTE_BLUETOOTH) {
+            Log.d(this, "handleAudioRefactoringServiceDisconnected: call audio "
+                    + "is currently routed to BT so switching back to baseline");
             mCallAudioRouteAdapter.sendMessageWithSessionInfo(
                     SWITCH_BASELINE_ROUTE, INCLUDE_BLUETOOTH_IN_BASELINE, (String) null);
+        } else {
+            Log.d(this, "handleAudioRefactoringServiceDisconnected: call audio "
+                    + "is not currently routed to BT so skipping switch to baseline");
         }
     }
 
@@ -341,9 +322,7 @@ public class BluetoothDeviceManager {
             bluetoothAdapter.getProfileProxy(context, mBluetoothProfileServiceListener,
                     BluetoothProfile.LE_AUDIO);
         }
-        if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-            mBluetoothHeadsetFuture = new CompletableFuture<>();
-        }
+        mBluetoothHeadsetFuture = new CompletableFuture<>();
         mAudioManager = context.getSystemService(AudioManager.class);
         mExecutor = context.getMainExecutor();
         mCommunicationDeviceTracker = communicationDeviceTracker;
@@ -449,19 +428,15 @@ public class BluetoothDeviceManager {
     }
 
     public BluetoothHeadset getBluetoothHeadset() {
-        if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-            try {
-                mBluetoothHeadset = mBluetoothHeadsetFuture.get(500L,
-                        TimeUnit.MILLISECONDS);
-                return mBluetoothHeadset;
-            } catch (TimeoutException | InterruptedException | ExecutionException e) {
-                // ignore
-                Log.w(this, "getBluetoothHeadset: Acquire BluetoothHeadset service failed due to: "
-                        + e);
-                return null;
-            }
-        } else {
+        try {
+            mBluetoothHeadset = mBluetoothHeadsetFuture.get(500L,
+                    TimeUnit.MILLISECONDS);
             return mBluetoothHeadset;
+        } catch (TimeoutException | InterruptedException | ExecutionException e) {
+            // ignore
+            Log.w(this, "getBluetoothHeadset: Acquire BluetoothHeadset service failed due to: "
+                    + e);
+            return null;
         }
     }
 
@@ -478,7 +453,11 @@ public class BluetoothDeviceManager {
     }
 
     public void setHeadsetServiceForTesting(BluetoothHeadset bluetoothHeadset) {
-        mBluetoothHeadset = bluetoothHeadset;
+        if (bluetoothHeadset == null) {
+            mBluetoothHeadsetFuture = CompletableFuture.completedFuture(null);
+        } else {
+            mBluetoothHeadsetFuture.complete(bluetoothHeadset);
+        }
     }
 
     public void setHearingAidServiceForTesting(BluetoothHearingAid bluetoothHearingAid) {
@@ -487,7 +466,9 @@ public class BluetoothDeviceManager {
 
     public void setLeAudioServiceForTesting(BluetoothLeAudio bluetoothLeAudio) {
         mBluetoothLeAudioService = bluetoothLeAudio;
-        mBluetoothLeAudioService.registerCallback(mExecutor, mLeAudioCallbacks);
+        if (mBluetoothLeAudioService != null) {
+            mBluetoothLeAudioService.registerCallback(mExecutor, mLeAudioCallbacks);
+        }
     }
 
     public static String getDeviceTypeString(int deviceType) {
@@ -545,8 +526,7 @@ public class BluetoothDeviceManager {
                 Log.i(this, "onDeviceConnected: Adding device with address: %s and devicetype=%s",
                         device, getDeviceTypeString(deviceType));
                 targetDeviceMap.put(device.getAddress(), device);
-                if (!mFeatureFlags.keepBluetoothDevicesCacheUpdated()
-                        || !mFeatureFlags.useRefactoredAudioRouteSwitching()) {
+                if (!mFeatureFlags.keepBluetoothDevicesCacheUpdated()) {
                     mBluetoothRouteManager.onDeviceAdded(device.getAddress());
                 }
             }
@@ -580,8 +560,7 @@ public class BluetoothDeviceManager {
                 Log.i(this, "onDeviceDisconnected: Removing device with address: %s, devicetype=%s",
                         device, getDeviceTypeString(deviceType));
                 targetDeviceMap.remove(device.getAddress());
-                if (!mFeatureFlags.keepBluetoothDevicesCacheUpdated()
-                        || !mFeatureFlags.useRefactoredAudioRouteSwitching()) {
+                if (!mFeatureFlags.keepBluetoothDevicesCacheUpdated()) {
                     mBluetoothRouteManager.onDeviceLost(device.getAddress());
                 }
             }
@@ -589,14 +568,8 @@ public class BluetoothDeviceManager {
     }
 
     public void disconnectAudio() {
-        if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-            mCommunicationDeviceTracker.clearBtCommunicationDevice();
-            disconnectSco();
-        } else {
-            disconnectSco();
-            clearLeAudioCommunicationDevice();
-            clearHearingAidCommunicationDevice();
-        }
+        mCommunicationDeviceTracker.clearBtCommunicationDevice();
+        disconnectSco();
     }
 
     public int disconnectSco() {
@@ -857,10 +830,8 @@ public class BluetoothDeviceManager {
                  * Only after receiving ACTION_ACTIVE_DEVICE_CHANGED it is known that device that
                  * will be audio switched to is available to be choose as communication device */
                 if (!switchingBtDevices) {
-                    return mFeatureFlags.callAudioCommunicationDeviceRefactor() ?
-                            mCommunicationDeviceTracker.setCommunicationDevice(
-                                    AudioDeviceInfo.TYPE_BLE_HEADSET, device)
-                            : setLeAudioCommunicationDevice();
+                    return mCommunicationDeviceTracker.setCommunicationDevice(
+                            AudioDeviceInfo.TYPE_BLE_HEADSET, device);
                 }
                 return true;
             }
@@ -873,10 +844,8 @@ public class BluetoothDeviceManager {
                  * Only after receiving ACTION_ACTIVE_DEVICE_CHANGED it is known that device that
                  * will be audio switched to is available to be choose as communication device */
                 if (!switchingBtDevices) {
-                    return mFeatureFlags.callAudioCommunicationDeviceRefactor() ?
-                            mCommunicationDeviceTracker.setCommunicationDevice(
-                                    AudioDeviceInfo.TYPE_HEARING_AID, null)
-                            : setHearingAidCommunicationDevice();
+                    return mCommunicationDeviceTracker.setCommunicationDevice(
+                            AudioDeviceInfo.TYPE_HEARING_AID, null);
                 }
                 return true;
             }
diff --git a/src/com/android/server/telecom/bluetooth/BluetoothRouteManager.java b/src/com/android/server/telecom/bluetooth/BluetoothRouteManager.java
index 93dbed6b9..1b4e9f0f1 100644
--- a/src/com/android/server/telecom/bluetooth/BluetoothRouteManager.java
+++ b/src/com/android/server/telecom/bluetooth/BluetoothRouteManager.java
@@ -170,19 +170,14 @@ public class BluetoothRouteManager extends StateMachine {
                     case CONNECT_BT:
                         String actualAddress;
                         boolean connected;
-                        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            Pair<String, Boolean> addressInfo = computeAddressToConnectTo(
-                                    (String) args.arg2, false, null);
-                            // See if we need to transition route if the device is already
-                            // connected. If connected, another connection will not occur.
-                            addressInfo = handleDeviceAlreadyConnected(addressInfo);
-                            actualAddress = addressInfo.first;
-                            connected = connectBtAudio(actualAddress, 0,
-                                    false /* switchingBtDevices*/);
-                        } else {
-                            actualAddress = connectBtAudioLegacy((String) args.arg2, false);
-                            connected = actualAddress != null;
-                        }
+                        Pair<String, Boolean> addressInfo = computeAddressToConnectTo(
+                                (String) args.arg2, false, null);
+                        // See if we need to transition route if the device is already
+                        // connected. If connected, another connection will not occur.
+                        addressInfo = handleDeviceAlreadyConnected(addressInfo);
+                        actualAddress = addressInfo.first;
+                        connected = connectBtAudio(actualAddress, 0,
+                                false /* switchingBtDevices*/);
 
                         if (connected) {
                             transitionTo(getConnectingStateForAddress(actualAddress,
@@ -199,20 +194,14 @@ public class BluetoothRouteManager extends StateMachine {
                         Log.i(LOG_TAG, "Retrying BT connection to %s", (String) args.arg2);
                         String retryAddress;
                         boolean retrySuccessful;
-                        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            Pair<String, Boolean> retryAddressInfo = computeAddressToConnectTo(
-                                    (String) args.arg2, false, null);
-                            // See if we need to transition route if the device is already
-                            // connected. If connected, another connection will not occur.
-                            retryAddressInfo = handleDeviceAlreadyConnected(retryAddressInfo);
-                            retryAddress = retryAddressInfo.first;
-                            retrySuccessful = connectBtAudio(retryAddress, args.argi1,
-                                    false /* switchingBtDevices*/);
-                        } else {
-                            retryAddress = connectBtAudioLegacy((String) args.arg2, args.argi1,
-                                    false /* switchingBtDevices*/);
-                            retrySuccessful = retryAddress != null;
-                        }
+                        Pair<String, Boolean> retryAddressInfo = computeAddressToConnectTo(
+                                (String) args.arg2, false, null);
+                        // See if we need to transition route if the device is already
+                        // connected. If connected, another connection will not occur.
+                        retryAddressInfo = handleDeviceAlreadyConnected(retryAddressInfo);
+                        retryAddress = retryAddressInfo.first;
+                        retrySuccessful = connectBtAudio(retryAddress, args.argi1,
+                                false /* switchingBtDevices*/);
 
                         if (retrySuccessful) {
                             transitionTo(getConnectingStateForAddress(retryAddress,
@@ -265,7 +254,7 @@ public class BluetoothRouteManager extends StateMachine {
             args.arg1 = Log.createSubsession();
             sendMessageDelayed(CONNECTION_TIMEOUT, args,
                     mTimeoutsAdapter.getBluetoothPendingTimeoutMillis(
-                            mContext.getContentResolver()));
+                            mContext, mFeatureFlags));
             mListener.onBluetoothAudioConnecting();
         }
 
@@ -303,9 +292,7 @@ public class BluetoothRouteManager extends StateMachine {
                         }
                     }
                 }
-                if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                    switchingBtDevices &= (mDeviceAddress != null);
-                }
+                switchingBtDevices &= (mDeviceAddress != null);
             }
             try {
                 switch (msg.what) {
@@ -321,28 +308,21 @@ public class BluetoothRouteManager extends StateMachine {
                         break;
                     case CONNECT_BT:
                         String actualAddress = null;
-                        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            Pair<String, Boolean> addressInfo = computeAddressToConnectTo(address,
-                                    switchingBtDevices, mDeviceAddress);
-                            // See if we need to transition route if the device is already
-                            // connected. If connected, another connection will not occur.
-                            addressInfo = handleDeviceAlreadyConnected(addressInfo);
-                            actualAddress = addressInfo.first;
-                            switchingBtDevices = addressInfo.second;
-                        }
+                        Pair<String, Boolean> addressInfo = computeAddressToConnectTo(address,
+                                switchingBtDevices, mDeviceAddress);
+                        // See if we need to transition route if the device is already
+                        // connected. If connected, another connection will not occur.
+                        addressInfo = handleDeviceAlreadyConnected(addressInfo);
+                        actualAddress = addressInfo.first;
+                        switchingBtDevices = addressInfo.second;
 
                         if (!switchingBtDevices) {
                             // Ignore repeated connection attempts to the same device
                             break;
                         }
 
-                        if (!mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            actualAddress = connectBtAudioLegacy(address,
-                                    true /* switchingBtDevices*/);
-                        }
-                        boolean connected = mFeatureFlags.resolveSwitchingBtDevicesComputation()
-                                ? connectBtAudio(actualAddress, 0, true /* switchingBtDevices*/)
-                                : actualAddress != null;
+                        boolean connected = connectBtAudio(actualAddress, 0,
+                                true /* switchingBtDevices*/);
                         if (connected) {
                             transitionTo(getConnectingStateForAddress(actualAddress,
                                     "AudioConnecting/CONNECT_BT"));
@@ -356,30 +336,21 @@ public class BluetoothRouteManager extends StateMachine {
                         break;
                     case RETRY_BT_CONNECTION:
                         String retryAddress = null;
-                        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            Pair<String, Boolean> retryAddressInfo = computeAddressToConnectTo(
-                                    address, switchingBtDevices, mDeviceAddress);
-                            // See if we need to transition route if the device is already
-                            // connected. If connected, another connection will not occur.
-                            retryAddressInfo = handleDeviceAlreadyConnected(retryAddressInfo);
-                            retryAddress = retryAddressInfo.first;
-                            switchingBtDevices = retryAddressInfo.second;
-                        }
+                        Pair<String, Boolean> retryAddressInfo = computeAddressToConnectTo(
+                                address, switchingBtDevices, mDeviceAddress);
+                        // See if we need to transition route if the device is already
+                        // connected. If connected, another connection will not occur.
+                        retryAddressInfo = handleDeviceAlreadyConnected(retryAddressInfo);
+                        retryAddress = retryAddressInfo.first;
+                        switchingBtDevices = retryAddressInfo.second;
 
                         if (!switchingBtDevices) {
                             Log.d(LOG_TAG, "Retry message came through while connecting.");
                             break;
                         }
 
-                        if (!mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            retryAddress = connectBtAudioLegacy(address, args.argi1,
-                                    true /* switchingBtDevices*/);
-                        }
-                        boolean retrySuccessful = mFeatureFlags
-                                .resolveSwitchingBtDevicesComputation()
-                                ? connectBtAudio(retryAddress, args.argi1,
-                                        true /* switchingBtDevices*/)
-                                : retryAddress != null;
+                        boolean retrySuccessful = connectBtAudio(retryAddress, args.argi1,
+                                true /* switchingBtDevices*/);
                         if (retrySuccessful) {
                             transitionTo(getConnectingStateForAddress(retryAddress,
                                     "AudioConnecting/RETRY_BT_CONNECTION"));
@@ -459,9 +430,7 @@ public class BluetoothRouteManager extends StateMachine {
             SomeArgs args = (SomeArgs) msg.obj;
             String address = (String) args.arg2;
             boolean switchingBtDevices = !Objects.equals(mDeviceAddress, address);
-            if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                switchingBtDevices &= (mDeviceAddress != null);
-            }
+            switchingBtDevices &= (mDeviceAddress != null);
 
             try {
                 switch (msg.what) {
@@ -476,15 +445,13 @@ public class BluetoothRouteManager extends StateMachine {
                         break;
                     case CONNECT_BT:
                         String actualAddress = null;
-                        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            Pair<String, Boolean> addressInfo = computeAddressToConnectTo(address,
-                                    switchingBtDevices, mDeviceAddress);
-                            // See if we need to transition route if the device is already
-                            // connected. If connected, another connection will not occur.
-                            addressInfo = handleDeviceAlreadyConnected(addressInfo);
-                            actualAddress = addressInfo.first;
-                            switchingBtDevices = addressInfo.second;
-                        }
+                        Pair<String, Boolean> addressInfo = computeAddressToConnectTo(address,
+                                switchingBtDevices, mDeviceAddress);
+                        // See if we need to transition route if the device is already
+                        // connected. If connected, another connection will not occur.
+                        addressInfo = handleDeviceAlreadyConnected(addressInfo);
+                        actualAddress = addressInfo.first;
+                        switchingBtDevices = addressInfo.second;
 
                         if (!switchingBtDevices) {
                             // Ignore connection to already connected device but still notify
@@ -494,13 +461,8 @@ public class BluetoothRouteManager extends StateMachine {
                             break;
                         }
 
-                        if (!mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            actualAddress = connectBtAudioLegacy(address,
-                                    true /* switchingBtDevices*/);
-                        }
-                        boolean connected = mFeatureFlags.resolveSwitchingBtDevicesComputation()
-                                ? connectBtAudio(actualAddress, 0, true /* switchingBtDevices*/)
-                                : actualAddress != null;
+                        boolean connected = connectBtAudio(actualAddress, 0,
+                                true /* switchingBtDevices*/);
                         if (connected) {
                             if (mFeatureFlags.useActualAddressToEnterConnectingState()) {
                                 transitionTo(getConnectingStateForAddress(actualAddress,
@@ -519,30 +481,21 @@ public class BluetoothRouteManager extends StateMachine {
                         break;
                     case RETRY_BT_CONNECTION:
                         String retryAddress = null;
-                        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            Pair<String, Boolean> retryAddressInfo = computeAddressToConnectTo(
-                                    address, switchingBtDevices, mDeviceAddress);
-                            // See if we need to transition route if the device is already
-                            // connected. If connected, another connection will not occur.
-                            retryAddressInfo = handleDeviceAlreadyConnected(retryAddressInfo);
-                            retryAddress = retryAddressInfo.first;
-                            switchingBtDevices = retryAddressInfo.second;
-                        }
+                        Pair<String, Boolean> retryAddressInfo = computeAddressToConnectTo(
+                                address, switchingBtDevices, mDeviceAddress);
+                        // See if we need to transition route if the device is already
+                        // connected. If connected, another connection will not occur.
+                        retryAddressInfo = handleDeviceAlreadyConnected(retryAddressInfo);
+                        retryAddress = retryAddressInfo.first;
+                        switchingBtDevices = retryAddressInfo.second;
 
                         if (!switchingBtDevices) {
                             Log.d(LOG_TAG, "Retry message came through while connected.");
                             break;
                         }
 
-                        if (!mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-                            retryAddress = connectBtAudioLegacy(address, args.argi1,
-                                    true /* switchingBtDevices*/);
-                        }
-                        boolean retrySuccessful = mFeatureFlags
-                                .resolveSwitchingBtDevicesComputation()
-                                ? connectBtAudio(retryAddress, args.argi1,
-                                        true /* switchingBtDevices*/)
-                                : retryAddress != null;
+                        boolean retrySuccessful = connectBtAudio(retryAddress, args.argi1,
+                                true /* switchingBtDevices*/);
                         if (retrySuccessful) {
                             transitionTo(getConnectingStateForAddress(retryAddress,
                                     "AudioConnected/RETRY_BT_CONNECTION"));
@@ -761,22 +714,14 @@ public class BluetoothRouteManager extends StateMachine {
         if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO) {
             mLeAudioActiveDeviceCache = device;
             if (device == null) {
-                if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                    mCommunicationDeviceTracker.clearCommunicationDevice(
-                            AudioDeviceInfo.TYPE_BLE_HEADSET);
-                } else {
-                    mDeviceManager.clearLeAudioCommunicationDevice();
-                }
+                mCommunicationDeviceTracker.clearCommunicationDevice(
+                        AudioDeviceInfo.TYPE_BLE_HEADSET);
             }
         } else if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID) {
             mHearingAidActiveDeviceCache = device;
             if (device == null) {
-                if (mFeatureFlags.callAudioCommunicationDeviceRefactor()) {
-                    mCommunicationDeviceTracker.clearCommunicationDevice(
-                            AudioDeviceInfo.TYPE_HEARING_AID);
-                } else {
-                    mDeviceManager.clearHearingAidCommunicationDevice();
-                }
+                mCommunicationDeviceTracker.clearCommunicationDevice(
+                        AudioDeviceInfo.TYPE_HEARING_AID);
             }
         } else if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_HEADSET) {
             mHfpActiveDeviceCache = device;
@@ -870,7 +815,7 @@ public class BluetoothRouteManager extends StateMachine {
                     + " Using arbitrary device - except watch");
             if (deviceList.size() > 0) {
                 for (BluetoothDevice device : deviceList) {
-                    if (mFeatureFlags.ignoreAutoRouteToWatchDevice() && isWatch(device)) {
+                    if (isWatch(device)) {
                         Log.i(this, "Skipping a watch device: " + device);
                         continue;
                     }
@@ -928,8 +873,6 @@ public class BluetoothRouteManager extends StateMachine {
      * @param switchingBtDevices Used when there is existing audio connection to other Bt device.
      * @return {@code true} if the connection to the address was successful, otherwise {@code false}
      *          if the connection fails.
-     *
-     * Note: This should only be used in par with the resolveSwitchingBtDevicesComputation flag.
      */
     private boolean connectBtAudio(String address, int retryCount, boolean switchingBtDevices) {
         if (address == null) {
@@ -952,7 +895,7 @@ public class BluetoothRouteManager extends StateMachine {
                 args.argi1 = retryCount + 1;
                 sendMessageDelayed(RETRY_BT_CONNECTION, args,
                         mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                                mContext.getContentResolver()));
+                                mContext, mFeatureFlags));
             }
             return false;
         }
@@ -960,86 +903,6 @@ public class BluetoothRouteManager extends StateMachine {
         return true;
     }
 
-    private String connectBtAudioLegacy(String address, boolean switchingBtDevices) {
-        return connectBtAudioLegacy(address, 0, switchingBtDevices);
-    }
-
-    /**
-     * Initiates a connection to the BT address specified.
-     * Note: This method is not synchronized on the Telecom lock, so don't try and call back into
-     * Telecom from within it.
-     * @param address The address that should be tried first. May be null.
-     * @param retryCount The number of times this connection attempt has been retried.
-     * @param switchingBtDevices Used when there is existing audio connection to other Bt device.
-     * @return The address of the device that's actually being connected to, or null if no
-     * connection was successful.
-     */
-    private String connectBtAudioLegacy(String address, int retryCount,
-            boolean switchingBtDevices) {
-        Collection<BluetoothDevice> deviceList = mDeviceManager.getConnectedDevices();
-        Optional<BluetoothDevice> matchingDevice = deviceList.stream()
-                .filter(d -> Objects.equals(d.getAddress(), address))
-                .findAny();
-
-        if (switchingBtDevices) {
-            /* When new Bluetooth connects audio, make sure previous one has disconnected audio. */
-            mDeviceManager.disconnectAudio();
-        }
-
-        String actualAddress = matchingDevice.isPresent()
-                ? address : getActiveDeviceAddress();
-        if (actualAddress == null) {
-            Log.i(this, "No device specified and BT stack has no active device."
-                    + " Using arbitrary device - except watch");
-            if (deviceList.size() > 0) {
-                for (BluetoothDevice device : deviceList) {
-                    if (mFeatureFlags.ignoreAutoRouteToWatchDevice() && isWatch(device)) {
-                        Log.i(this, "Skipping a watch device: " + device);
-                        continue;
-                    }
-                    actualAddress = device.getAddress();
-                    break;
-                }
-            }
-
-            if (actualAddress == null) {
-                Log.i(this, "No devices available at all. Not connecting.");
-                return null;
-            }
-        }
-        if (!matchingDevice.isPresent()) {
-            Log.i(this, "No device with address %s available. Using %s instead.",
-                    address, actualAddress);
-        }
-
-        BluetoothDevice alreadyConnectedDevice = getBluetoothAudioConnectedDevice();
-        if (alreadyConnectedDevice != null && alreadyConnectedDevice.getAddress().equals(
-                actualAddress)) {
-            Log.i(this, "trying to connect to already connected device -- skipping connection"
-                    + " and going into the actual connected state.");
-            transitionToActualState();
-            return null;
-        }
-
-        if (!mDeviceManager.connectAudio(actualAddress, switchingBtDevices)) {
-            boolean shouldRetry = retryCount < MAX_CONNECTION_RETRIES;
-            Log.w(LOG_TAG, "Could not connect to %s. Will %s", actualAddress,
-                    shouldRetry ? "retry" : "not retry");
-            if (shouldRetry) {
-                SomeArgs args = SomeArgs.obtain();
-                args.arg1 = Log.createSubsession();
-                args.arg2 = actualAddress;
-                args.argi1 = retryCount + 1;
-                sendMessageDelayed(RETRY_BT_CONNECTION, args,
-                        mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                                mContext.getContentResolver()));
-            }
-            return null;
-        }
-
-        return actualAddress;
-    }
-
     private String getActiveDeviceAddress() {
         if (mHfpActiveDeviceCache != null) {
             return mHfpActiveDeviceCache.getAddress();
@@ -1104,11 +967,8 @@ public class BluetoothRouteManager extends StateMachine {
             }
         }
 
-        boolean isHearingAidSetForCommunication =
-                mFeatureFlags.callAudioCommunicationDeviceRefactor()
-                ? mCommunicationDeviceTracker.isAudioDeviceSetForType(
-                        AudioDeviceInfo.TYPE_HEARING_AID)
-                : mDeviceManager.isHearingAidSetAsCommunicationDevice();
+        boolean isHearingAidSetForCommunication = mCommunicationDeviceTracker
+                .isAudioDeviceSetForType(AudioDeviceInfo.TYPE_HEARING_AID);
         if (bluetoothHearingAid != null) {
             if (isHearingAidSetForCommunication) {
                 List<BluetoothDevice> hearingAidsActiveDevices = bluetoothAdapter.getActiveDevices(
@@ -1128,11 +988,8 @@ public class BluetoothRouteManager extends StateMachine {
             }
         }
 
-        boolean isLeAudioSetForCommunication =
-                mFeatureFlags.callAudioCommunicationDeviceRefactor()
-                        ? mCommunicationDeviceTracker.isAudioDeviceSetForType(
-                        AudioDeviceInfo.TYPE_BLE_HEADSET)
-                        : mDeviceManager.isLeAudioCommunicationDevice();
+        boolean isLeAudioSetForCommunication = mCommunicationDeviceTracker.isAudioDeviceSetForType(
+                AudioDeviceInfo.TYPE_BLE_HEADSET);
         if (bluetoothLeAudio != null) {
             if (isLeAudioSetForCommunication) {
                 for (BluetoothDevice device : bluetoothAdapter.getActiveDevices(
diff --git a/src/com/android/server/telecom/bluetooth/BluetoothStateReceiver.java b/src/com/android/server/telecom/bluetooth/BluetoothStateReceiver.java
index 0478fdc73..f14a13387 100644
--- a/src/com/android/server/telecom/bluetooth/BluetoothStateReceiver.java
+++ b/src/com/android/server/telecom/bluetooth/BluetoothStateReceiver.java
@@ -121,59 +121,45 @@ public class BluetoothStateReceiver extends BroadcastReceiver {
         SomeArgs args = SomeArgs.obtain();
         args.arg1 = session;
         args.arg2 = device.getAddress();
+        CallAudioRouteController audioRouteController =
+                (CallAudioRouteController) mCallAudioRouteAdapter;
         switch (bluetoothHeadsetAudioState) {
             case BluetoothHeadset.STATE_AUDIO_CONNECTED:
-                if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                    CallAudioRouteController audioRouteController =
-                            (CallAudioRouteController) mCallAudioRouteAdapter;
-                    audioRouteController.setScoAudioConnectedDevice(device);
-                    AudioRoute btRoute = audioRouteController.getBluetoothRoute(
-                            AudioRoute.TYPE_BLUETOOTH_SCO, device.getAddress());
-                    if (audioRouteController.isPending() && Objects.equals(audioRouteController
-                            .getPendingAudioRoute().getDestRoute(), btRoute)) {
-                        mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_AUDIO_CONNECTED, 0,
-                                device);
-                    } else {
-                        // It's possible that the initial BT connection fails but BT_AUDIO_CONNECTED
-                        // is sent later, indicating that SCO audio is on. We should route
-                        // appropriately in order for the UI to reflect this state.
-                        if (btRoute != null) {
-                            audioRouteController.getPendingAudioRoute().overrideDestRoute(btRoute);
-                            audioRouteController.overrideIsPending(true);
-                            audioRouteController.getPendingAudioRoute()
-                                    .setCommunicationDeviceType(AudioRoute.TYPE_BLUETOOTH_SCO);
-                            mCallAudioRouteAdapter.sendMessageWithSessionInfo(
-                                    CallAudioRouteAdapter.EXIT_PENDING_ROUTE);
-                        }
-                    }
+                audioRouteController.setScoAudioConnectedDevice(device);
+                AudioRoute btRoute = audioRouteController.getBluetoothRoute(
+                        AudioRoute.TYPE_BLUETOOTH_SCO, device.getAddress());
+                if (audioRouteController.isPending() && Objects.equals(audioRouteController
+                        .getPendingAudioRoute().getDestRoute(), btRoute)) {
+                    mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_AUDIO_CONNECTED, 0,
+                            device);
                 } else {
-                    if (!mIsInCall) {
-                        Log.i(LOG_TAG, "Ignoring BT audio on since we're not in a call");
-                        return;
+                    // It's possible that the initial BT connection fails but BT_AUDIO_CONNECTED
+                    // is sent later, indicating that SCO audio is on. We should route
+                    // appropriately in order for the UI to reflect this state.
+                    if (btRoute != null) {
+                        audioRouteController.getPendingAudioRoute().overrideDestRoute(btRoute);
+                        audioRouteController.overrideIsPending(true);
+                        audioRouteController.getPendingAudioRoute()
+                                .setCommunicationDeviceType(AudioRoute.TYPE_BLUETOOTH_SCO);
+                        mCallAudioRouteAdapter.sendMessageWithSessionInfo(
+                                CallAudioRouteAdapter.EXIT_PENDING_ROUTE);
                     }
-                    mBluetoothRouteManager.sendMessage(BT_AUDIO_IS_ON, args);
                 }
                 break;
             case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
-                if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                    CallAudioRouteController audioRouteController =
-                            (CallAudioRouteController) mCallAudioRouteAdapter;
-                    audioRouteController.setScoAudioConnectedDevice(null);
-                    if (audioRouteController.isPending()) {
-                        mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_AUDIO_DISCONNECTED, 0,
-                                device);
-                    } else {
-                        // Handle case where BT stack signals SCO disconnected but Telecom isn't
-                        // processing any pending routes. This explicitly addresses cf instances
-                        // where a remote device disconnects SCO. Telecom should ensure that audio
-                        // is properly routed in the UI.
-                        audioRouteController.getPendingAudioRoute()
-                                .setCommunicationDeviceType(AudioRoute.TYPE_INVALID);
-                        mCallAudioRouteAdapter.sendMessageWithSessionInfo(SWITCH_BASELINE_ROUTE,
-                                INCLUDE_BLUETOOTH_IN_BASELINE, device.getAddress());
-                    }
-                }  else {
-                    mBluetoothRouteManager.sendMessage(BT_AUDIO_LOST, args);
+                audioRouteController.setScoAudioConnectedDevice(null);
+                if (audioRouteController.isPending()) {
+                    mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_AUDIO_DISCONNECTED, 0,
+                            device);
+                } else {
+                    // Handle case where BT stack signals SCO disconnected but Telecom isn't
+                    // processing any pending routes. This explicitly addresses cf instances
+                    // where a remote device disconnects SCO. Telecom should ensure that audio
+                    // is properly routed in the UI.
+                    audioRouteController.getPendingAudioRoute()
+                            .setCommunicationDeviceType(AudioRoute.TYPE_INVALID);
+                    mCallAudioRouteAdapter.sendMessageWithSessionInfo(SWITCH_BASELINE_ROUTE,
+                            INCLUDE_BLUETOOTH_IN_BASELINE, device.getAddress());
                 }
                 break;
         }
@@ -212,24 +198,16 @@ public class BluetoothStateReceiver extends BroadcastReceiver {
                 device.getAddress(), bluetoothHeadsetState);
 
         if (bluetoothHeadsetState == BluetoothProfile.STATE_CONNECTED) {
-            if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_DEVICE_ADDED,
-                        audioRouteType, device);
-                if (mFeatureFlags.keepBluetoothDevicesCacheUpdated()) {
-                    mBluetoothDeviceManager.onDeviceConnected(device, deviceType);
-                }
-            } else {
+            mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_DEVICE_ADDED,
+                    audioRouteType, device);
+            if (mFeatureFlags.keepBluetoothDevicesCacheUpdated()) {
                 mBluetoothDeviceManager.onDeviceConnected(device, deviceType);
             }
         } else if (bluetoothHeadsetState == BluetoothProfile.STATE_DISCONNECTED
                 || bluetoothHeadsetState == BluetoothProfile.STATE_DISCONNECTING) {
-            if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-                mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_DEVICE_REMOVED,
-                        audioRouteType, device);
-                if (mFeatureFlags.keepBluetoothDevicesCacheUpdated()) {
-                    mBluetoothDeviceManager.onDeviceDisconnected(device, deviceType);
-                }
-            } else {
+            mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_DEVICE_REMOVED,
+                    audioRouteType, device);
+            if (mFeatureFlags.keepBluetoothDevicesCacheUpdated()) {
                 mBluetoothDeviceManager.onDeviceDisconnected(device, deviceType);
             }
         }
@@ -258,120 +236,30 @@ public class BluetoothStateReceiver extends BroadcastReceiver {
         Log.i(LOG_TAG, "Device %s is now the preferred BT device for %s", device,
                 BluetoothDeviceManager.getDeviceTypeString(deviceType));
 
-        if (mFeatureFlags.useRefactoredAudioRouteSwitching()) {
-            CallAudioRouteController audioRouteController = (CallAudioRouteController)
-                    mCallAudioRouteAdapter;
-            if (device == null) {
-                // Update the active device cache immediately.
-                audioRouteController.updateActiveBluetoothDevice(new Pair(audioRouteType, null));
-                mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_ACTIVE_DEVICE_GONE,
-                        audioRouteType);
-            } else {
-                // Update the active device cache immediately.
-                audioRouteController.updateActiveBluetoothDevice(
-                        new Pair(audioRouteType, device.getAddress()));
-                mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_ACTIVE_DEVICE_PRESENT,
-                        audioRouteType, device.getAddress());
-                if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID
-                        || deviceType == BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO
-                        || mIsScoManagedByAudio) {
-                    if (!mIsInCall) {
-                        Log.i(LOG_TAG, "Ignoring audio on since we're not in a call");
-                        return;
-                    }
-                    if (!mBluetoothDeviceManager.setCommunicationDeviceForAddress(
-                            device.getAddress())) {
-                        Log.i(this, "handleActiveDeviceChanged: Failed to set "
-                                + "communication device for %s.", device);
-                        if (!mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()) {
-                            Log.i(this, "Sending PENDING_ROUTE_FAILED "
-                                    + "to pending audio route.");
-                            mCallAudioRouteAdapter.getPendingAudioRoute()
-                                    .onMessageReceived(new Pair<>(PENDING_ROUTE_FAILED,
-                                            device.getAddress()), device.getAddress());
-                        } else {
-                            Log.i(this, "Refrain from sending PENDING_ROUTE_FAILED"
-                                    + " to pending audio route.");
-                        }
-                    } else {
-                        // Track the currently set communication device.
-                        mCallAudioRouteAdapter.getPendingAudioRoute()
-                                .setCommunicationDeviceType(audioRouteType);
-                        if (audioRouteType == AudioRoute.TYPE_BLUETOOTH_SCO) {
-                            mCallAudioRouteAdapter.getPendingAudioRoute()
-                                    .addMessage(BT_AUDIO_CONNECTED, device.getAddress());
-                        }
-                    }
-                }
-            }
+        CallAudioRouteController audioRouteController = (CallAudioRouteController)
+                mCallAudioRouteAdapter;
+        if (device == null) {
+            // Update the active device cache immediately.
+            audioRouteController.updateActiveBluetoothDevice(new Pair(audioRouteType, null));
+            mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_ACTIVE_DEVICE_GONE,
+                    audioRouteType);
         } else {
-            mBluetoothRouteManager.onActiveDeviceChanged(device, deviceType);
-            if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID ||
-                    deviceType == BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO) {
-                Session session = Log.createSubsession();
-                SomeArgs args = SomeArgs.obtain();
-                args.arg1 = session;
-                if (device == null) {
-                    mBluetoothRouteManager.sendMessage(BT_AUDIO_LOST, args);
-                } else {
-                    if (!mIsInCall) {
-                        Log.i(LOG_TAG, "Ignoring audio on since we're not in a call");
-                        return;
-                    }
-                    args.arg2 = device.getAddress();
-
-                    boolean usePreferredAudioProfile = false;
-                    BluetoothAdapter bluetoothAdapter = mBluetoothDeviceManager
-                            .getBluetoothAdapter();
-                    int preferredDuplexProfile = BluetoothProfile.LE_AUDIO;
-                    if (bluetoothAdapter != null) {
-                        Bundle preferredAudioProfiles = bluetoothAdapter.getPreferredAudioProfiles(
-                                device);
-                        if (preferredAudioProfiles != null && !preferredAudioProfiles.isEmpty()
-                                && preferredAudioProfiles.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX)
-                                != 0) {
-                            Log.i(this, "Preferred duplex profile for device=" + device + " is "
-                                    + preferredAudioProfiles.getInt(
-                                    BluetoothAdapter.AUDIO_MODE_DUPLEX));
-                            usePreferredAudioProfile = true;
-                            preferredDuplexProfile =
-                                    preferredAudioProfiles.getInt(
-                                            BluetoothAdapter.AUDIO_MODE_DUPLEX);
-                        }
-                    }
-
-                    if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO) {
-                        /* In Le Audio case, once device got Active, the Telecom needs to make sure
-                         * it is set as communication device before we can say that BT_AUDIO_IS_ON
-                         */
-                        boolean isLeAudioSetForCommunication =
-                                mFeatureFlags.callAudioCommunicationDeviceRefactor()
-                                        ? mCommunicationDeviceTracker.setCommunicationDevice(
-                                        AudioDeviceInfo.TYPE_BLE_HEADSET, device)
-                                        : mBluetoothDeviceManager.setLeAudioCommunicationDevice();
-                        if ((!usePreferredAudioProfile
-                                || preferredDuplexProfile == BluetoothProfile.LE_AUDIO)
-                                && !isLeAudioSetForCommunication) {
-                            Log.w(LOG_TAG,
-                                    "Device %s cannot be use as LE audio communication device.",
-                                    device);
-                        }
-                    } else {
-                        boolean isHearingAidSetForCommunication =
-                                mFeatureFlags.callAudioCommunicationDeviceRefactor()
-                                        ? mCommunicationDeviceTracker.setCommunicationDevice(
-                                        AudioDeviceInfo.TYPE_HEARING_AID, null)
-                                        : mBluetoothDeviceManager
-                                        .setHearingAidCommunicationDevice();
-                        /* deviceType == BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID */
-                        if (!isHearingAidSetForCommunication) {
-                            Log.w(LOG_TAG,
-                                    "Device %s cannot be use as hearing aid communication device.",
-                                    device);
-                        } else {
-                            mBluetoothRouteManager.sendMessage(BT_AUDIO_IS_ON, args);
-                        }
-                    }
+            // Update the active device cache immediately.
+            audioRouteController.updateActiveBluetoothDevice(
+                    new Pair(audioRouteType, device.getAddress()));
+            mCallAudioRouteAdapter.sendMessageWithSessionInfo(BT_ACTIVE_DEVICE_PRESENT,
+                    audioRouteType, device.getAddress());
+            if (deviceType == BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID
+                    || deviceType == BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO
+                    || mIsScoManagedByAudio) {
+                if (!mIsInCall) {
+                    Log.i(LOG_TAG, "Ignoring audio on since we're not in a call");
+                    return;
+                }
+                if (!mBluetoothDeviceManager.setCommunicationDeviceForAddress(
+                        device.getAddress())) {
+                    Log.i(this, "handleActiveDeviceChanged: Failed to set "
+                            + "communication device for %s.", device);
                 }
             }
         }
diff --git a/src/com/android/server/telecom/callfiltering/BlockCheckerFilter.java b/src/com/android/server/telecom/callfiltering/BlockCheckerFilter.java
index 7e3837dd3..65b773169 100644
--- a/src/com/android/server/telecom/callfiltering/BlockCheckerFilter.java
+++ b/src/com/android/server/telecom/callfiltering/BlockCheckerFilter.java
@@ -131,7 +131,8 @@ public class BlockCheckerFilter extends CallFilter {
         } else {
             userContext = mContext;
         }
-        if (BlockedNumbersUtil.isEnhancedCallBlockingEnabledByPlatform(userContext)) {
+        if (BlockedNumbersUtil.isEnhancedCallBlockingEnabledByPlatform(userContext,
+                mFeatureFlags)) {
             int presentation = mCall.getHandlePresentation();
             extras.putInt(BlockedNumberContract.EXTRA_CALL_PRESENTATION, presentation);
             if (presentation == TelecomManager.PRESENTATION_ALLOWED) {
@@ -166,7 +167,8 @@ public class BlockCheckerFilter extends CallFilter {
         // exist in the extras to maintain existing behavior.
         int presentation;
         boolean isNumberInContacts;
-        if (BlockedNumbersUtil.isEnhancedCallBlockingEnabledByPlatform(userContext)) {
+        if (BlockedNumbersUtil.isEnhancedCallBlockingEnabledByPlatform(userContext,
+                mFeatureFlags)) {
             presentation = mCall.getHandlePresentation();
         } else {
             presentation = 0;
diff --git a/src/com/android/server/telecom/callfiltering/CallFilteringResult.java b/src/com/android/server/telecom/callfiltering/CallFilteringResult.java
index 931d5bb64..7be451a4c 100644
--- a/src/com/android/server/telecom/callfiltering/CallFilteringResult.java
+++ b/src/com/android/server/telecom/callfiltering/CallFilteringResult.java
@@ -16,20 +16,50 @@
 
 package com.android.server.telecom.callfiltering;
 
+import android.annotation.IntDef;
+import android.net.Uri;
 import android.provider.CallLog;
 import android.provider.CallLog.Calls;
 import android.telecom.CallScreeningService;
 import android.text.TextUtils;
 
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
 
 public class CallFilteringResult {
+    /**
+     * Indicates that the call filtering operation did NOT determine whether or not DND would result
+     * in suppressing the call.
+     */
+    public static final int DND_NOT_DETERMINED = 0;
+
+    /**
+     * DND has determined that this call should be suppressed. In other words,
+     * {@link android.app.NotificationManager#matchesCallFilter(Uri)} returned {@code false} and the
+     * call should not ring.
+     */
+    public static final int DND_SUPPRESSED = 1;
+
+    /**
+     * DND has determined that this call should be allowed. This means that either DND Is off, or
+     * DND is on and the call matches the criteria the user defined to allow it to bypass DND (e.g.
+     * repeated caller or someone in the user's contacts).
+     */
+    public static final int DND_NOT_SUPPRESSED = 2;
+
+    @IntDef(prefix = { "DND_" },
+            value = {DND_NOT_SUPPRESSED, DND_SUPPRESSED, DND_NOT_DETERMINED})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface DndSuppressionStatus {}
+
     public static class Builder {
         private boolean mShouldAllowCall;
         private boolean mShouldReject;
         private boolean mShouldAddToCallLog;
         private boolean mShouldShowNotification;
         private boolean mDndSuppressed = false;
+        private int mDndSuppressionStatus = DND_NOT_DETERMINED;
         private boolean mShouldSilence = false;
         private boolean mShouldScreenViaAudio = false;
         private boolean mContactExists = false;
@@ -64,6 +94,16 @@ public class CallFilteringResult {
             return this;
         }
 
+        /**
+         * Sets whether the call should bypass DND or not.
+         * @param status the DND suppression status.
+         * @return the builder to allow chaining.
+         */
+        public Builder setDndSuppressionStatus(@DndSuppressionStatus int status) {
+            mDndSuppressionStatus = status;
+            return this;
+        }
+
         public Builder setShouldSilence(boolean shouldSilence) {
             mShouldSilence = shouldSilence;
             return this;
@@ -108,6 +148,7 @@ public class CallFilteringResult {
                     .setShouldAddToCallLog(result.shouldAddToCallLog)
                     .setShouldShowNotification(result.shouldShowNotification)
                     .setDndSuppressed(result.shouldSuppressCallDueToDndStatus)
+                    .setDndSuppressionStatus(result.dndSuppressionStatus)
                     .setShouldSilence(result.shouldSilence)
                     .setCallBlockReason(result.mCallBlockReason)
                     .setShouldScreenViaAudio(result.shouldScreenViaAudio)
@@ -121,7 +162,7 @@ public class CallFilteringResult {
         public CallFilteringResult build() {
             return new CallFilteringResult(mShouldAllowCall, mShouldReject, mShouldSilence,
                     mShouldAddToCallLog, mShouldShowNotification,
-                    mDndSuppressed, mCallBlockReason, mCallScreeningAppName,
+                    mDndSuppressed, mDndSuppressionStatus, mCallBlockReason, mCallScreeningAppName,
                     mCallScreeningComponentName, mCallScreeningResponse,
                     mIsResponseFromSystemDialer, mShouldScreenViaAudio, mContactExists);
         }
@@ -134,6 +175,7 @@ public class CallFilteringResult {
     public boolean shouldScreenViaAudio = false;
     public boolean shouldShowNotification;
     public boolean shouldSuppressCallDueToDndStatus = false;
+    @DndSuppressionStatus public int dndSuppressionStatus = DND_NOT_DETERMINED;
     public int mCallBlockReason;
     public CharSequence mCallScreeningAppName;
     public String mCallScreeningComponentName;
@@ -143,8 +185,8 @@ public class CallFilteringResult {
 
     private CallFilteringResult(boolean shouldAllowCall, boolean shouldReject, boolean
             shouldSilence, boolean shouldAddToCallLog, boolean shouldShowNotification, boolean
-            shouldSuppress, int callBlockReason, CharSequence callScreeningAppName,
-            String callScreeningComponentName,
+            shouldSuppress, @DndSuppressionStatus int dndSuppressionStatus, int callBlockReason,
+            CharSequence callScreeningAppName, String callScreeningComponentName,
             CallScreeningService.ParcelableCallResponse callScreeningResponse,
             boolean isResponseFromSystemDialer,
             boolean shouldScreenViaAudio, boolean contactExists) {
@@ -154,6 +196,7 @@ public class CallFilteringResult {
         this.shouldAddToCallLog = shouldAddToCallLog;
         this.shouldShowNotification = shouldShowNotification;
         this.shouldSuppressCallDueToDndStatus = shouldSuppress;
+        this.dndSuppressionStatus = dndSuppressionStatus;
         this.shouldScreenViaAudio = shouldScreenViaAudio;
         this.mCallBlockReason = callBlockReason;
         this.mCallScreeningAppName = callScreeningAppName;
@@ -215,11 +258,51 @@ public class CallFilteringResult {
                 .setShouldScreenViaAudio(shouldScreenViaAudio || other.shouldScreenViaAudio)
                 .setDndSuppressed(shouldSuppressCallDueToDndStatus
                         || other.shouldSuppressCallDueToDndStatus)
+                .setDndSuppressionStatus(getCombinedDndSuppressionStatus(dndSuppressionStatus,
+                        other.dndSuppressionStatus))
                 .setContactExists(contactExists || other.contactExists);
         combineScreeningResponses(b, this, other);
         return b.build();
     }
 
+    /**
+     * Determines if a DND status has been determined.
+     * @return {@code true} if the filtering result has a DND suppression status, {@code false}
+     * otherwise.
+     */
+    public boolean isDndSuppressionDetermined() {
+        return dndSuppressionStatus != DND_NOT_DETERMINED;
+    }
+
+    /**
+     * Determines if the call should be suppressed due to DND.
+     * @return {@code true} if the call should be suppressed due to DND, {@code false} otherwise.
+     */
+    public boolean shouldSuppressDueToDnd() {
+        return dndSuppressionStatus == DND_SUPPRESSED;
+    }
+
+    /** Combine two DND suppression statuses. */
+    public static int getCombinedDndSuppressionStatus(@DndSuppressionStatus int suppressionStatus,
+            @DndSuppressionStatus int otherSuppressionStatus) {
+        int combinedDndSuppressionStatus;
+        // Suppression status combination rules in priority order:
+        // 1. If one of the filters says DND suppressed the call (even if the other didn't), we
+        // mark as suppressed.
+        // 2. If one of the filters says DND did NOT suppress the call (even if the other didn't
+        // make a determination), we mark as not-suppressed.
+        // 3. Fall back to DND_NOT_DETERMINED.
+        if (suppressionStatus == DND_SUPPRESSED || otherSuppressionStatus == DND_SUPPRESSED) {
+            combinedDndSuppressionStatus = DND_SUPPRESSED;
+        } else if (suppressionStatus == DND_NOT_SUPPRESSED
+                || otherSuppressionStatus == DND_NOT_SUPPRESSED) {
+            combinedDndSuppressionStatus = DND_NOT_SUPPRESSED;
+        } else {
+            combinedDndSuppressionStatus = DND_NOT_DETERMINED;
+        }
+        return combinedDndSuppressionStatus;
+    }
+
     private boolean isBlockedByProvider(int blockReason) {
         if (blockReason == Calls.BLOCK_REASON_BLOCKED_NUMBER
             || blockReason == Calls.BLOCK_REASON_UNKNOWN_NUMBER
@@ -243,6 +326,8 @@ public class CallFilteringResult {
                 .setShouldShowNotification(shouldShowNotification && other.shouldShowNotification)
                 .setDndSuppressed(shouldSuppressCallDueToDndStatus
                         || other.shouldSuppressCallDueToDndStatus)
+                .setDndSuppressionStatus(getCombinedDndSuppressionStatus(dndSuppressionStatus,
+                        other.dndSuppressionStatus))
                 .setShouldScreenViaAudio(shouldScreenViaAudio || other.shouldScreenViaAudio)
                 .setCallBlockReason(callBlockReason)
                 .setCallScreeningAppName(callScreeningAppName)
@@ -338,6 +423,14 @@ public class CallFilteringResult {
             sb.append(", DND suppressed");
         }
 
+        if (dndSuppressionStatus == DND_NOT_DETERMINED) {
+            sb.append(", DND not determined");
+        } else if (dndSuppressionStatus == DND_SUPPRESSED) {
+            sb.append(", DND suppressed");
+        } else {
+            sb.append(", DND not suppressed");
+        }
+
         if (contactExists) {
             sb.append(", contact exists");
         }
diff --git a/src/com/android/server/telecom/callfiltering/CallScreeningServiceFilter.java b/src/com/android/server/telecom/callfiltering/CallScreeningServiceFilter.java
index efac87d1a..ff7f019d6 100644
--- a/src/com/android/server/telecom/callfiltering/CallScreeningServiceFilter.java
+++ b/src/com/android/server/telecom/callfiltering/CallScreeningServiceFilter.java
@@ -32,6 +32,7 @@ import android.telecom.TelecomManager;
 
 import com.android.internal.telecom.ICallScreeningAdapter;
 import com.android.internal.telecom.ICallScreeningService;
+import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.AppLabelProxy;
 import com.android.server.telecom.Call;
 import com.android.server.telecom.CallScreeningServiceHelper;
@@ -57,6 +58,7 @@ public class CallScreeningServiceFilter extends CallFilter {
     private final CallsManager mCallsManager;
     private CharSequence mAppName;
     private final ParcelableCallUtils.Converter mParcelableCallUtilsConverter;
+    private final FeatureFlags mFeatureFlags;
 
     private class CallScreeningAdapter extends ICallScreeningAdapter.Stub {
         private CompletableFuture<CallFilteringResult> mResultFuture;
@@ -223,7 +225,8 @@ public class CallScreeningServiceFilter extends CallFilter {
             try {
                 callScreeningService.screenCall(new CallScreeningAdapter(mResultFuture),
                         mParcelableCallUtilsConverter.
-                                toParcelableCallForScreening(mCall, isSystemDialer()));
+                                toParcelableCallForScreening(mCall, isSystemDialer(),
+                                        hasReadPrivilegedPhoneStatePermission()));
             } catch (RemoteException e) {
                 Log.e(this, e, "Failed to set the call screening adapter");
                 mResultFuture.complete(mPriorStageResult);
@@ -261,7 +264,8 @@ public class CallScreeningServiceFilter extends CallFilter {
             Context context,
             CallsManager callsManager,
             AppLabelProxy appLabelProxy,
-            ParcelableCallUtils.Converter parcelableCallUtilsConverter) {
+            ParcelableCallUtils.Converter parcelableCallUtilsConverter,
+            FeatureFlags featureFlags) {
         super();
         mCall = call;
         mPackageName = packageName;
@@ -272,6 +276,7 @@ public class CallScreeningServiceFilter extends CallFilter {
         mAppName = appLabelProxy.getAppLabel(mPackageName,
                 mCall.getAssociatedUser());
         mParcelableCallUtilsConverter = parcelableCallUtilsConverter;
+        mFeatureFlags = featureFlags;
     }
 
     @Override
@@ -315,12 +320,21 @@ public class CallScreeningServiceFilter extends CallFilter {
         return permission == PackageManager.PERMISSION_GRANTED;
     }
 
+    private boolean hasReadPrivilegedPhoneStatePermission() {
+        if (!mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            return false;
+        }
+        return mPackageManager != null
+                && mPackageManager.checkPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE,
+                        mPackageName) == PackageManager.PERMISSION_GRANTED;
+    }
+
     private void bindCallScreeningService(
             CompletableFuture<CallFilteringResult> resultFuture) {
         CallScreeningServiceConnection connection = new CallScreeningServiceConnection(
                 resultFuture);
         if (!CallScreeningServiceHelper.bindCallScreeningService(mContext,
-                mCall.getAssociatedUser(), mPackageName, connection)) {
+                mCall.getAssociatedUser(), mPackageName, connection, mFeatureFlags)) {
             Log.i(this, "Call screening service binding failed.");
             resultFuture.complete(mPriorStageResult);
         } else {
diff --git a/src/com/android/server/telecom/callfiltering/IncomingCallFilterGraph.java b/src/com/android/server/telecom/callfiltering/IncomingCallFilterGraph.java
index a606a4d25..47ffc3257 100644
--- a/src/com/android/server/telecom/callfiltering/IncomingCallFilterGraph.java
+++ b/src/com/android/server/telecom/callfiltering/IncomingCallFilterGraph.java
@@ -16,6 +16,8 @@
 
 package com.android.server.telecom.callfiltering;
 
+import static com.android.server.telecom.callfiltering.CallFilteringResult.DND_NOT_DETERMINED;
+
 import android.content.Context;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -43,6 +45,7 @@ public class IncomingCallFilterGraph {
                     .setShouldAddToCallLog(true)
                     .setShouldShowNotification(true)
                     .setDndSuppressed(false)
+                    .setDndSuppressionStatus(DND_NOT_DETERMINED)
                     .build();
 
     private final CallFilterResultCallback mListener;
@@ -137,7 +140,7 @@ public class IncomingCallFilterGraph {
                     }
                 }
             }
-        }.prepare(), mTimeoutsAdapter.getCallScreeningTimeoutMillis(mContext.getContentResolver()));
+        }.prepare(), mTimeoutsAdapter.getCallScreeningTimeoutMillis(mContext, mFeatureFlags));
     }
 
     /**
@@ -151,9 +154,6 @@ public class IncomingCallFilterGraph {
     private CallFilteringResult onTimeoutCombineFinishedFilters(
             List<CallFilter> filtersList,
             CallFilteringResult currentResult) {
-        if (!mFeatureFlags.checkCompletedFiltersOnTimeout()) {
-            return currentResult;
-        }
         for (CallFilter filter : filtersList) {
             if (filter.result != null) {
                 currentResult = currentResult.combine(filter.result);
diff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java
index 15b8aa942..8ad96fec3 100644
--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java
+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java
@@ -41,6 +41,7 @@ import com.android.server.telecom.LogUtils;
 import com.android.server.telecom.PhoneAccountRegistrar;
 import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.Timeouts;
+import com.android.server.telecom.flags.FeatureFlags;
 
 /**
  * A single instance of call redirection processor that handles the call redirection with
@@ -317,6 +318,8 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {
      */
     private boolean mIsCarrierRedirectionPending = false;
 
+    private final  FeatureFlags mFeatureFlags;
+
     public CallRedirectionProcessor(
             Context context,
             CallsManager callsManager,
@@ -325,7 +328,8 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {
             PhoneAccountRegistrar phoneAccountRegistrar,
             GatewayInfo gatewayInfo,
             boolean speakerphoneOn,
-            int videoState) {
+            int videoState,
+            FeatureFlags featureFlags) {
         mContext = context;
         mCallsManager = callsManager;
         mCall = call;
@@ -336,13 +340,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {
         mVideoState = videoState;
         mTimeoutsAdapter = callsManager.getTimeoutsAdapter();
         mTelecomLock = callsManager.getLock();
+        mFeatureFlags = featureFlags;
         /**
          * The current rule to decide whether the implemented {@link CallRedirectionService} should
          * allow interactive responses with users is only based on whether it is in car mode.
          */
         mAllowInteractiveResponse = !callsManager.getSystemStateHelper().isCarModeOrProjectionActive();
         mCallRedirectionProcessorHelper = new CallRedirectionProcessorHelper(
-                context, callsManager, phoneAccountRegistrar);
+                context, callsManager, phoneAccountRegistrar, mFeatureFlags);
         mProcessedDestinationUri = mCallRedirectionProcessorHelper.formatNumberForRedirection(
                 mDestinationUri);
         mPostDialDigits = mCallRedirectionProcessorHelper.getPostDialDigits(mDestinationUri);
@@ -428,8 +433,8 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {
     private void processTimeoutForCallRedirection(String serviceType) {
         long timeout = serviceType.equals(SERVICE_TYPE_USER_DEFINED) ?
             mTimeoutsAdapter.getUserDefinedCallRedirectionTimeoutMillis(
-                mContext.getContentResolver()) : mTimeoutsAdapter
-            .getCarrierCallRedirectionTimeoutMillis(mContext.getContentResolver());
+                mContext, mFeatureFlags) : mTimeoutsAdapter
+            .getCarrierCallRedirectionTimeoutMillis(mContext, mFeatureFlags);
 
         mHandler.postDelayed(new Runnable("CRP.pTFCR", null) {
             @Override
diff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessorHelper.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessorHelper.java
index a6f089f14..4899fa7d1 100644
--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessorHelper.java
+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessorHelper.java
@@ -34,7 +34,9 @@ import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.telecom.CallsManager;
+import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.PhoneAccountRegistrar;
+import com.android.server.telecom.UserUtil;
 
 import java.util.List;
 
@@ -43,14 +45,17 @@ public class CallRedirectionProcessorHelper {
     private final Context mContext;
     private final CallsManager mCallsManager;
     private final PhoneAccountRegistrar mPhoneAccountRegistrar;
+    private final FeatureFlags mFeatureFlags;
 
     public CallRedirectionProcessorHelper(
             Context context,
             CallsManager callsManager,
-            PhoneAccountRegistrar phoneAccountRegistrar) {
+            PhoneAccountRegistrar phoneAccountRegistrar,
+            FeatureFlags flags) {
         mContext = context;
         mCallsManager = callsManager;
         mPhoneAccountRegistrar = phoneAccountRegistrar;
+        mFeatureFlags = flags;
     }
 
     @VisibleForTesting
@@ -98,8 +103,15 @@ public class CallRedirectionProcessorHelper {
     }
 
     protected ComponentName getComponentName(Intent intent, String serviceType) {
-        List<ResolveInfo> entries = mContext.getPackageManager().queryIntentServicesAsUser(
-                intent, 0, mCallsManager.getCurrentUserHandle().getIdentifier());
+        List<ResolveInfo> entries;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            entries = UserUtil.getPackageManagerFromUserHandler(mContext,
+                    mCallsManager.getCurrentUserHandle()).queryIntentServicesAsUser(
+                    intent, 0, mCallsManager.getCurrentUserHandle().getIdentifier());
+        } else {
+            entries = mContext.getPackageManager().queryIntentServicesAsUser(
+                    intent, 0, mCallsManager.getCurrentUserHandle().getIdentifier());
+        }
         if (entries.isEmpty()) {
             Log.i(this, "There are no " + serviceType + " call redirection services installed" +
                     " on this device.");
diff --git a/src/com/android/server/telecom/callsequencing/CallSequencingController.java b/src/com/android/server/telecom/callsequencing/CallSequencingController.java
index 29be3d039..d28617e85 100644
--- a/src/com/android/server/telecom/callsequencing/CallSequencingController.java
+++ b/src/com/android/server/telecom/callsequencing/CallSequencingController.java
@@ -429,7 +429,7 @@ public class CallSequencingController {
                         Log.w(this, "unholdCall: Unable to hold the active call (%s),"
                                         + " aborting swap to %s", activeCallId, call.getId(),
                                 call.getId());
-                        showErrorDialogForCannotHoldCall(call, false);
+                        showErrorDialogForCannotSwapCall(call);
                     } else {
                         Log.w(this, "unholdCall: %s is an emergency call, aborting swap to %s",
                                 activeCallId, call.getId());
@@ -539,7 +539,7 @@ public class CallSequencingController {
             return transactionFuture;
         }
 
-        Call liveCall = mCallsManager.getFirstCallWithLiveState();
+        Call liveCall = mCallsManager.getFirstCallWithLiveState(emergencyCall);
         Log.i(this, "makeRoomForOutgoingEmergencyCall: call = " + emergencyCall
                 + " livecall = " + liveCall);
 
@@ -705,6 +705,20 @@ public class CallSequencingController {
             }
         }
 
+        // If we are trying to make an emergency call with the same package name as the live call,
+        // then allow it so that the connection service can make its own decision
+        // about how to handle the new call relative to the current one.
+        // By default, for telephony, it will try to hold the existing call before placing the new
+        // emergency call except for if the carrier does not support holding calls for emergency.
+        // In this case, telephony will disconnect the call.
+        if (mFeatureFlags.bypassHoldForEccDial() && PhoneAccountHandle.areFromSamePackage(
+                liveCallPhoneAccount, emergencyCall.getTargetPhoneAccount())) {
+            Log.i(this, "makeRoomForOutgoingEmergencyCall: phoneAccount matches.");
+            emergencyCall.getAnalytics().setCallIsAdditional(true);
+            liveCall.getAnalytics().setCallIsInterrupted(true);
+            return transactionFuture;
+        }
+
         // At this point, if we still have an active call, then it supports holding for emergency
         // and is a managed call. It may not support holding but we will still try to hold anyway
         // (i.e. swap for Verizon). Note that there will only be one call at this stage which is
@@ -745,7 +759,7 @@ public class CallSequencingController {
 
         // NOTE: If the amount of live calls changes beyond 1, this logic will probably
         // have to change.
-        Call liveCall = mCallsManager.getFirstCallWithLiveState();
+        Call liveCall = mCallsManager.getFirstCallWithLiveState(call);
         Log.i(this, "makeRoomForOutgoingCall call = " + call + " livecall = " +
                 liveCall);
 
@@ -863,12 +877,19 @@ public class CallSequencingController {
      */
     public void disconnectCall(Call call, int previousState) {
         CompletableFuture<Boolean> disconnectFuture = call.disconnect();
+        int newState = call.getState();
+        mCallsManager.notifyCallStateChangeForDisconnect(call, previousState);
         disconnectFuture.thenComposeAsync((result) -> {
             if (result) {
                 Log.i(this, "disconnectCall: Disconnect call transaction succeeded. "
                         + "Processing associated cleanup.");
                 mCallsManager.processDisconnectCallAndCleanup(call, previousState);
             } else {
+                // Revert the disconnecting state that was set as a result of invoking
+                // Call#disconnect and make sure the reverted state is notified to the registered
+                // listeners.
+                call.setLocallyDisconnecting(false);
+                mCallsManager.notifyCallStateChangeForDisconnect(call, newState);
                 Log.i(this, "disconnectCall: Disconnect call transaction failed. "
                         + "Aborting associated cleanup.");
             }
@@ -1058,8 +1079,7 @@ public class CallSequencingController {
                 CarrierConfigManager.KEY_ALLOW_HOLD_CALL_DURING_EMERGENCY_BOOL, true);
     }
 
-    @VisibleForTesting
-    public boolean arePhoneAccountsSame(Call call1, Call call2) {
+    public static boolean arePhoneAccountsSame(Call call1, Call call2) {
         if (call1 == null || call2 == null) {
             return false;
         }
@@ -1178,6 +1198,13 @@ public class CallSequencingController {
         showErrorDialogForFailedCall(call, null, resourceId, reason);
     }
 
+    private void showErrorDialogForCannotSwapCall(Call call) {
+        int resourceId = R.string.callSwapFailed_unholdable_call;
+        String reason = " unable to swap the live call. Disconnect the call to switch to "
+                + "the held call.";
+        showErrorDialogForFailedCall(call, null, resourceId, reason);
+    }
+
     private void showErrorDialogForCannotHoldCall(Call call, boolean setCallFailure) {
         CallFailureCause cause = null;
         if (setCallFailure) {
diff --git a/src/com/android/server/telecom/callsequencing/CallsManagerCallSequencingAdapter.java b/src/com/android/server/telecom/callsequencing/CallsManagerCallSequencingAdapter.java
index b2cfcabb1..34fddefa9 100644
--- a/src/com/android/server/telecom/callsequencing/CallsManagerCallSequencingAdapter.java
+++ b/src/com/android/server/telecom/callsequencing/CallsManagerCallSequencingAdapter.java
@@ -33,6 +33,7 @@ import com.android.server.telecom.CallsManager;
 import com.android.server.telecom.callsequencing.voip.OutgoingCallTransaction;
 import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.R;
+import com.android.server.telecom.metrics.TelecomMetricsController;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -50,17 +51,19 @@ public class CallsManagerCallSequencingAdapter {
     private final CallSequencingController mSequencingController;
     private final CallAudioManager mCallAudioManager;
     private final Handler mHandler;
+    private final TelecomMetricsController mMetricsController;
     private final FeatureFlags mFeatureFlags;
     private final boolean mIsCallSequencingEnabled;
 
     public CallsManagerCallSequencingAdapter(CallsManager callsManager, Context context,
             CallSequencingController sequencingController, CallAudioManager callAudioManager,
-            FeatureFlags featureFlags) {
+            TelecomMetricsController metricsController, FeatureFlags featureFlags) {
         mCallsManager = callsManager;
         mContext = context;
         mSequencingController = sequencingController;
         mCallAudioManager = callAudioManager;
         mHandler = sequencingController.getHandler();
+        mMetricsController = metricsController;
         mFeatureFlags = featureFlags;
         mIsCallSequencingEnabled = featureFlags.enableCallSequencing();
     }
@@ -199,33 +202,26 @@ public class CallsManagerCallSequencingAdapter {
             callback.onResult(true);
             return;
         }
+        // prevent bad actors from disconnecting the activeCall. Instead, clients will need to
+        // notify the user that they need to disconnect the ongoing call before making the
+        // new call ACTIVE.
+        if (isCallControlRequest
+                && !mCallsManager.canHoldOrSwapActiveCall(activeCall, newCall)) {
+            Log.i(this, mTag + "CallControlRequest exit");
+            callback.onError(new CallException("activeCall is NOT holdable or swappable, please"
+                    + " request the user disconnect the call.",
+                    CallException.CODE_CANNOT_HOLD_CURRENT_ACTIVE_CALL));
+            return;
+        }
 
-        if (mFeatureFlags.transactionalHoldDisconnectsUnholdable()) {
-            // prevent bad actors from disconnecting the activeCall. Instead, clients will need to
-            // notify the user that they need to disconnect the ongoing call before making the
-            // new call ACTIVE.
-            if (isCallControlRequest
-                    && !mCallsManager.canHoldOrSwapActiveCall(activeCall, newCall)) {
-                Log.i(this, mTag + "CallControlRequest exit");
-                callback.onError(new CallException("activeCall is NOT holdable or swappable, please"
-                        + " request the user disconnect the call.",
-                        CallException.CODE_CANNOT_HOLD_CURRENT_ACTIVE_CALL));
-                return;
-            }
-
-            if (mIsCallSequencingEnabled) {
-                mSequencingController.transactionHoldPotentialActiveCallForNewCallSequencing(
-                        newCall, callback);
-            } else {
-                // The code path without sequencing but where transactionalHoldDisconnectsUnholdable
-                // flag is enabled.
-                mCallsManager.transactionHoldPotentialActiveCallForNewCallOld(newCall,
-                        activeCall, callback);
-            }
-        } else {
-            // The unflagged path (aka original code with no flags).
-            mCallsManager.transactionHoldPotentialActiveCallForNewCallUnflagged(activeCall,
+        if (mIsCallSequencingEnabled) {
+            mSequencingController.transactionHoldPotentialActiveCallForNewCallSequencing(
                     newCall, callback);
+        } else {
+            // The code path without sequencing but where transactionalHoldDisconnectsUnholdable
+            // flag is enabled.
+            mCallsManager.transactionHoldPotentialActiveCallForNewCallOld(newCall,
+                    activeCall, callback);
         }
     }
 
@@ -366,6 +362,22 @@ public class CallsManagerCallSequencingAdapter {
         });
     }
 
+    /**
+     * Sets the call sequencing usage metrics for the passed in call. Refer to the
+     * {@link com.android.server.telecom.metrics.CallSequencingStats} class for more details.
+     * @param call The call to store sequencing metrics for.
+     */
+    public void setCallSequencingMetrics(Call call) {
+        if (!mFeatureFlags.callSequencingMetrics()) {
+            return;
+        }
+        // Add sequencing metric info based on the primary call (if present).
+        Call primaryCall = mCallsManager.getCalls().stream()
+                .filter(c -> !c.isLocallyDisconnecting() && !c.isDisconnected() && !c.equals(call))
+                .findFirst().orElse(null);
+        mMetricsController.getCallSequencingStats().setCallSequencingMetrics(call, primaryCall);
+    }
+
     /**
      * Upon a call resume failure, we will auto-unhold the foreground call that was held. Note that
      * this should only apply for calls across phone accounts as the ImsPhoneCallTracker handles
@@ -374,7 +386,7 @@ public class CallsManagerCallSequencingAdapter {
      * @param callToUnhold The fg call that was held.
      */
     public void handleCallResumeFailed(Call callResumeFailed, Call callToUnhold) {
-        if (mIsCallSequencingEnabled && !mSequencingController.arePhoneAccountsSame(
+        if (mIsCallSequencingEnabled && !CallSequencingController.arePhoneAccountsSame(
                 callResumeFailed, callToUnhold)) {
             unholdCall(callToUnhold);
         }
diff --git a/src/com/android/server/telecom/callsequencing/VerifyCallStateChangeTransaction.java b/src/com/android/server/telecom/callsequencing/VerifyCallStateChangeTransaction.java
index b7e4f0494..6c6938349 100644
--- a/src/com/android/server/telecom/callsequencing/VerifyCallStateChangeTransaction.java
+++ b/src/com/android/server/telecom/callsequencing/VerifyCallStateChangeTransaction.java
@@ -20,8 +20,11 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.telecom.Call;
 import com.android.server.telecom.CallState;
 import com.android.server.telecom.TelecomSystem;
+import com.android.server.telecom.flags.FeatureFlags;
 
+import android.os.Bundle;
 import android.telecom.CallException;
+import android.telecom.Connection;
 import android.telecom.Log;
 
 import java.util.Set;
@@ -39,15 +42,18 @@ import java.util.stream.IntStream;
 public class VerifyCallStateChangeTransaction extends CallTransaction {
     private static final String TAG = VerifyCallStateChangeTransaction.class.getSimpleName();
     private static final long CALL_STATE_TIMEOUT_MILLISECONDS = 5000L;
+    public static final String DISC_FINISH_TRANSACTION_MSG = "call disconnected while"
+            + " trying to verify the following call state";
     private final Call mCall;
     private final Set<Integer> mTargetCallStates;
+    private final FeatureFlags mFeatureFlags;
     private final CompletableFuture<CallTransactionResult> mTransactionResult =
             new CompletableFuture<>();
 
     private final Call.CallStateListener mCallStateListenerImpl = new Call.CallStateListener() {
         @Override
         public void onCallStateChanged(int newCallState) {
-            Log.d(TAG, "newState=[%d], possible expected state(s)=[%s]", newCallState,
+            Log.i(TAG, "newState=[%d], possible expected state(s)=[%s]", newCallState,
                     mTargetCallStates);
             if (mTargetCallStates.contains(newCallState)) {
                 mTransactionResult.complete(new CallTransactionResult(
@@ -55,9 +61,30 @@ public class VerifyCallStateChangeTransaction extends CallTransaction {
             }
             // NOTE:: keep listening to the call state until the timeout is reached. It's possible
             // another call state is reached in between...
+
+            // unless the call state is disconnecting / disconnected.The transaction should be
+            // cleaned up in this case because all other call states do not matter since the
+            // call is being destroyed.
+            if (mFeatureFlags.cleanupVerifyCallState() &&
+                    isDisconnectingOrDisconnected(newCallState)) {
+                if (!mTransactionResult.isDone()) {
+                    mTransactionResult.complete(new CallTransactionResult(
+                            CallException.CODE_ERROR_UNKNOWN, String.format("%s=[%d]",
+                            DISC_FINISH_TRANSACTION_MSG, newCallState)));
+                }
+            }
         }
     };
 
+    /**
+     * Helper method to check if a call state is DISCONNECTED or DISCONNECTING.
+     * @param callState The call state to check.
+     * @return true if the state is DISCONNECTED or DISCONNECTING, false otherwise.
+     */
+    private static boolean isDisconnectingOrDisconnected(int callState) {
+        return callState == CallState.DISCONNECTED || callState == CallState.DISCONNECTING;
+    }
+
     private final Call.ListenerBase mCallListenerImpl = new Call.ListenerBase() {
         @Override
         public void onCallHoldFailed(Call call) {
@@ -76,12 +103,24 @@ public class VerifyCallStateChangeTransaction extends CallTransaction {
                         CallException.CODE_CALL_CANNOT_BE_SET_TO_ACTIVE, "error unholding call"));
             }
         }
+
+        @Override
+        public void onConnectionEvent(Call call, String event, Bundle extras) {
+            // If one of the target states is disconnected and we receive a disconnect failed event
+            // from Telephony, we can safely fail the transaction.
+            if (call.equals(mCall) && Connection.EVENT_DISCONNECT_FAILED.equals(event)
+                    && mTargetCallStates.contains(CallState.DISCONNECTED)) {
+                mTransactionResult.complete(new CallTransactionResult(
+                        CallException.CODE_ERROR_UNKNOWN, "error disconnecting call"));
+            }
+        }
     };
 
     public VerifyCallStateChangeTransaction(TelecomSystem.SyncRoot lock,  Call call,
-            int... targetCallStates) {
+            FeatureFlags featureFlags, int... targetCallStates) {
         super(lock, CALL_STATE_TIMEOUT_MILLISECONDS);
         mCall = call;
+        mFeatureFlags = featureFlags;
         mTargetCallStates = IntStream.of(targetCallStates).boxed().collect(Collectors.toSet());;
     }
 
diff --git a/src/com/android/server/telecom/callsequencing/voip/RequestNewActiveCallTransaction.java b/src/com/android/server/telecom/callsequencing/voip/RequestNewActiveCallTransaction.java
index 8e6e3540f..50b1d9cbe 100644
--- a/src/com/android/server/telecom/callsequencing/voip/RequestNewActiveCallTransaction.java
+++ b/src/com/android/server/telecom/callsequencing/voip/RequestNewActiveCallTransaction.java
@@ -71,14 +71,6 @@ public class RequestNewActiveCallTransaction extends CallTransaction {
             return future;
         }
 
-        if (!Flags.transactionalHoldDisconnectsUnholdable() &&
-                mCallsManager.getActiveCall() != null) {
-            future.complete(new CallTransactionResult(
-                    CallException.CODE_CALL_CANNOT_BE_SET_TO_ACTIVE,
-                    "Already an active call. Request hold on current active call."));
-            return future;
-        }
-
         mCallsManager.requestNewCallFocusAndVerify(mCall, new OutcomeReceiver<>() {
                     @Override
                     public void onResult(Boolean result) {
diff --git a/src/com/android/server/telecom/callsequencing/voip/VoipCallMonitorLegacy.java b/src/com/android/server/telecom/callsequencing/voip/VoipCallMonitorLegacy.java
deleted file mode 100644
index 78f5d525f..000000000
--- a/src/com/android/server/telecom/callsequencing/voip/VoipCallMonitorLegacy.java
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.telecom.callsequencing.voip;
-
-import static android.app.ForegroundServiceDelegationOptions.DELEGATION_SERVICE_PHONE_CALL;
-import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_CAMERA;
-import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE;
-import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MICROPHONE;
-import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_PHONE_CALL;
-
-import android.app.ActivityManager;
-import android.app.ActivityManagerInternal;
-import android.app.ForegroundServiceDelegationOptions;
-import android.app.Notification;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.ServiceConnection;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.os.UserHandle;
-import android.service.notification.NotificationListenerService;
-import android.service.notification.StatusBarNotification;
-import android.telecom.Log;
-import android.telecom.PhoneAccountHandle;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.server.LocalServices;
-import com.android.server.telecom.Call;
-
-import com.android.server.telecom.CallsManagerListenerBase;
-import com.android.server.telecom.LogUtils;
-import com.android.server.telecom.LoggedHandlerExecutor;
-import com.android.server.telecom.TelecomSystem;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-
-public class VoipCallMonitorLegacy extends CallsManagerListenerBase {
-
-    private final List<Call> mNotificationPendingCalls;
-    // Same notification may be passed as different object in onNotificationPosted and
-    // onNotificationRemoved. Use its string as key to cache ongoing notifications.
-    private final Map<NotificationInfo, Call> mNotificationInfoToCallMap;
-    private final Map<PhoneAccountHandle, Set<Call>> mAccountHandleToCallMap;
-    private ActivityManagerInternal mActivityManagerInternal;
-    private final Map<PhoneAccountHandle, ServiceConnection> mServices;
-    private NotificationListenerService mNotificationListener;
-    private final Object mLock = new Object();
-    private final HandlerThread mHandlerThread;
-    private final Handler mHandler;
-    private final Context mContext;
-    private List<NotificationInfo> mCachedNotifications;
-    private TelecomSystem.SyncRoot mSyncRoot;
-
-    public VoipCallMonitorLegacy(Context context, TelecomSystem.SyncRoot lock) {
-        mSyncRoot = lock;
-        mContext = context;
-        mHandlerThread = new HandlerThread(this.getClass().getSimpleName());
-        mHandlerThread.start();
-        mHandler = new Handler(mHandlerThread.getLooper());
-        mNotificationPendingCalls = new ArrayList<>();
-        mCachedNotifications = new ArrayList<>();
-        mNotificationInfoToCallMap = new HashMap<>();
-        mServices = new HashMap<>();
-        mAccountHandleToCallMap = new HashMap<>();
-        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
-
-        mNotificationListener = new NotificationListenerService() {
-            @Override
-            public void onNotificationPosted(StatusBarNotification sbn) {
-                synchronized (mLock) {
-                    if (sbn.getNotification().isStyle(Notification.CallStyle.class)) {
-                        NotificationInfo info = new NotificationInfo(sbn.getPackageName(),
-                                sbn.getUser());
-                        boolean sbnMatched = false;
-                        for (Call call : mNotificationPendingCalls) {
-                            if (info.matchesCall(call)) {
-                                Log.i(this, "onNotificationPosted: found a pending "
-                                                + "callId=[%s] for the call notification w/ "
-                                                + "id=[%s]",
-                                        call.getId(), sbn.getId());
-                                mNotificationPendingCalls.remove(call);
-                                mNotificationInfoToCallMap.put(info, call);
-                                sbnMatched = true;
-                                break;
-                            }
-                        }
-                        if (!sbnMatched &&
-                                !mCachedNotifications.contains(info) /* don't re-add if update */) {
-                            Log.i(this, "onNotificationPosted: could not find a"
-                                            + "call for the call notification w/ id=[%s]",
-                                    sbn.getId());
-                            // notification may post before we started to monitor the call, cache
-                            // this notification and try to match it later with new added call.
-                            mCachedNotifications.add(info);
-                        }
-                    }
-                }
-            }
-
-            @Override
-            public void onNotificationRemoved(StatusBarNotification sbn) {
-                synchronized (mLock) {
-                    NotificationInfo info = new NotificationInfo(sbn.getPackageName(),
-                            sbn.getUser());
-                    mCachedNotifications.remove(info);
-                    if (mNotificationInfoToCallMap.isEmpty()) {
-                        return;
-                    }
-                    Call call = mNotificationInfoToCallMap.getOrDefault(info, null);
-                    if (call != null) {
-                        mNotificationInfoToCallMap.remove(info, call);
-                        CompletableFuture<Void> future = new CompletableFuture<>();
-                        mHandler.postDelayed(() -> future.complete(null), 5000L);
-                        stopFGSDelegation(call);
-                    }
-                }
-            }
-        };
-
-    }
-
-    public void startMonitor() {
-        try {
-            mNotificationListener.registerAsSystemService(mContext,
-                    new ComponentName(this.getClass().getPackageName(),
-                            this.getClass().getCanonicalName()), ActivityManager.getCurrentUser());
-        } catch (RemoteException e) {
-            Log.e(this, e, "Cannot register notification listener");
-        }
-    }
-
-    public void stopMonitor() {
-        try {
-            mNotificationListener.unregisterAsSystemService();
-        } catch (RemoteException e) {
-            Log.e(this, e, "Cannot unregister notification listener");
-        }
-    }
-
-    @Override
-    public void onCallAdded(Call call) {
-        if (!call.isTransactionalCall()) {
-            return;
-        }
-
-        synchronized (mLock) {
-            PhoneAccountHandle phoneAccountHandle = call.getTargetPhoneAccount();
-            Set<Call> callList = mAccountHandleToCallMap.computeIfAbsent(phoneAccountHandle,
-                    k -> new HashSet<>());
-            callList.add(call);
-            CompletableFuture.completedFuture(null).thenComposeAsync(
-                    (x) -> {
-                        startFGSDelegation(call.getCallingPackageIdentity().mCallingPackagePid,
-                                call.getCallingPackageIdentity().mCallingPackageUid, call);
-                        return null;
-                    }, new LoggedHandlerExecutor(mHandler, "VCM.oCA", mSyncRoot));
-        }
-    }
-
-    @Override
-    public void onCallRemoved(Call call) {
-        if (!call.isTransactionalCall()) {
-            return;
-        }
-        synchronized (mLock) {
-            stopMonitorWorks(call);
-            PhoneAccountHandle phoneAccountHandle = call.getTargetPhoneAccount();
-            Set<Call> callList = mAccountHandleToCallMap.computeIfAbsent(phoneAccountHandle,
-                    k -> new HashSet<>());
-            callList.remove(call);
-            if (callList.isEmpty()) {
-                stopFGSDelegation(call);
-            }
-        }
-    }
-
-    private void startFGSDelegation(int pid, int uid, Call call) {
-        Log.i(this, "startFGSDelegation for call %s", call.getId());
-        if (mActivityManagerInternal != null) {
-            PhoneAccountHandle handle = call.getTargetPhoneAccount();
-            ForegroundServiceDelegationOptions options = new ForegroundServiceDelegationOptions(pid,
-                    uid, handle.getComponentName().getPackageName(), null /* clientAppThread */,
-                    false /* isSticky */, String.valueOf(handle.hashCode()),
-                    FOREGROUND_SERVICE_TYPE_PHONE_CALL |
-                    FOREGROUND_SERVICE_TYPE_MICROPHONE |
-                    FOREGROUND_SERVICE_TYPE_CAMERA |
-                    FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE /* foregroundServiceTypes */,
-                    DELEGATION_SERVICE_PHONE_CALL /* delegationService */);
-            ServiceConnection fgsConnection = new ServiceConnection() {
-                @Override
-                public void onServiceConnected(ComponentName name, IBinder service) {
-                    mServices.put(handle, this);
-                    startMonitorWorks(call);
-                }
-
-                @Override
-                public void onServiceDisconnected(ComponentName name) {
-                    mServices.remove(handle);
-                }
-            };
-            try {
-                if (mActivityManagerInternal
-                        .startForegroundServiceDelegate(options, fgsConnection)) {
-                    Log.addEvent(call, LogUtils.Events.GAINED_FGS_DELEGATION);
-                } else {
-                    Log.addEvent(call, LogUtils.Events.GAIN_FGS_DELEGATION_FAILED);
-                }
-            } catch (Exception e) {
-                Log.i(this, "startForegroundServiceDelegate failed due to: " + e);
-            }
-        }
-    }
-
-    @VisibleForTesting
-    public void stopFGSDelegation(Call call) {
-        synchronized (mLock) {
-            Log.i(this, "stopFGSDelegation of call %s", call);
-            PhoneAccountHandle handle = call.getTargetPhoneAccount();
-            Set<Call> calls = mAccountHandleToCallMap.get(handle);
-
-            // Every call for the package that is losing foreground service delegation should be
-            // removed from tracking maps/contains in this class
-            if (calls != null) {
-                for (Call c : calls) {
-                    stopMonitorWorks(c); // remove the call from tacking in this class
-                }
-            }
-
-            mAccountHandleToCallMap.remove(handle);
-
-            if (mActivityManagerInternal != null) {
-                ServiceConnection fgsConnection = mServices.get(handle);
-                if (fgsConnection != null) {
-                    mActivityManagerInternal.stopForegroundServiceDelegate(fgsConnection);
-                    Log.addEvent(call, LogUtils.Events.LOST_FGS_DELEGATION);
-                }
-            }
-        }
-    }
-
-    private void startMonitorWorks(Call call) {
-        startMonitorNotification(call);
-    }
-
-    private void stopMonitorWorks(Call call) {
-        stopMonitorNotification(call);
-    }
-
-    private void startMonitorNotification(Call call) {
-        synchronized (mLock) {
-            boolean sbnMatched = false;
-            for (NotificationInfo info : mCachedNotifications) {
-                if (info.matchesCall(call)) {
-                    Log.i(this, "startMonitorNotification: found a cached call "
-                            + "notification for call=[%s]", call);
-                    mCachedNotifications.remove(info);
-                    mNotificationInfoToCallMap.put(info, call);
-                    sbnMatched = true;
-                    break;
-                }
-            }
-            if (!sbnMatched) {
-                // Only continue to
-                Log.i(this, "startMonitorNotification: could not find a call"
-                        + " notification for the call=[%s];", call);
-                mNotificationPendingCalls.add(call);
-                CompletableFuture<Void> future = new CompletableFuture<>();
-                mHandler.postDelayed(() -> future.complete(null), 5000L);
-                future.thenComposeAsync(
-                        (x) -> {
-                            if (mNotificationPendingCalls.contains(call)) {
-                                Log.i(this, "Notification for voip-call %s haven't "
-                                        + "posted in time, stop delegation.", call.getId());
-                                stopFGSDelegation(call);
-                                mNotificationPendingCalls.remove(call);
-                                return null;
-                            }
-                            return null;
-                        }, new LoggedHandlerExecutor(mHandler, "VCM.sMN", mSyncRoot));
-            }
-        }
-    }
-
-    private void stopMonitorNotification(Call call) {
-        mNotificationPendingCalls.remove(call);
-    }
-
-    @VisibleForTesting
-    public void setActivityManagerInternal(ActivityManagerInternal ami) {
-        mActivityManagerInternal = ami;
-    }
-
-    private static class NotificationInfo extends Object {
-        private String mPackageName;
-        private UserHandle mUserHandle;
-
-        NotificationInfo(String packageName, UserHandle userHandle) {
-            mPackageName = packageName;
-            mUserHandle = userHandle;
-        }
-
-        boolean matchesCall(Call call) {
-            PhoneAccountHandle accountHandle = call.getTargetPhoneAccount();
-            return mPackageName != null && mPackageName.equals(
-                    accountHandle.getComponentName().getPackageName())
-                    && mUserHandle != null && mUserHandle.equals(accountHandle.getUserHandle());
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof NotificationInfo)) {
-                return false;
-            }
-            NotificationInfo that = (NotificationInfo) obj;
-            return Objects.equals(this.mPackageName, that.mPackageName)
-                    && Objects.equals(this.mUserHandle, that.mUserHandle);
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(mPackageName, mUserHandle);
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("{ NotificationInfo: [mPackageName: ")
-                    .append(mPackageName)
-                    .append("], [mUserHandle=")
-                    .append(mUserHandle)
-                    .append("]  }");
-            return sb.toString();
-        }
-    }
-
-    @VisibleForTesting
-    public void postNotification(StatusBarNotification statusBarNotification) {
-        mNotificationListener.onNotificationPosted(statusBarNotification);
-    }
-
-    @VisibleForTesting
-    public void removeNotification(StatusBarNotification statusBarNotification) {
-        mNotificationListener.onNotificationRemoved(statusBarNotification);
-    }
-
-    @VisibleForTesting
-    public Set<Call> getCallsForHandle(PhoneAccountHandle handle){
-        return mAccountHandleToCallMap.get(handle);
-    }
-}
diff --git a/src/com/android/server/telecom/components/AppUninstallBroadcastReceiver.java b/src/com/android/server/telecom/components/AppUninstallBroadcastReceiver.java
index b89fe94ec..dba27da4f 100644
--- a/src/com/android/server/telecom/components/AppUninstallBroadcastReceiver.java
+++ b/src/com/android/server/telecom/components/AppUninstallBroadcastReceiver.java
@@ -17,6 +17,7 @@
 package com.android.server.telecom.components;
 
 import com.android.server.telecom.PhoneAccountRegistrar;
+import com.android.server.telecom.flags.Flags;
 
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -79,6 +80,9 @@ public class AppUninstallBroadcastReceiver extends BroadcastReceiver {
      * @param packageName The name of the removed package.
      */
     private void handlePackageRemoved(Context context, String packageName) {
+        if (Flags.resolveHiddenDependenciesTwo()) {
+            return;
+        }
         final TelecomManager telecomManager = context.getSystemService(TelecomManager.class);
         if (telecomManager != null) {
             telecomManager.clearAccountsForPackage(packageName);
diff --git a/src/com/android/server/telecom/components/ErrorDialogActivity.java b/src/com/android/server/telecom/components/ErrorDialogActivity.java
index fd55a35f3..72740d8ac 100644
--- a/src/com/android/server/telecom/components/ErrorDialogActivity.java
+++ b/src/com/android/server/telecom/components/ErrorDialogActivity.java
@@ -25,8 +25,6 @@ import android.content.Intent;
 import android.os.Bundle;
 import android.telecom.Log;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * Used to display an error dialog from within the Telecom service when an outgoing call fails
  */
diff --git a/src/com/android/server/telecom/components/TelecomService.java b/src/com/android/server/telecom/components/TelecomService.java
index 2fbdf8b78..f47a32b33 100644
--- a/src/com/android/server/telecom/components/TelecomService.java
+++ b/src/com/android/server/telecom/components/TelecomService.java
@@ -20,13 +20,20 @@ import android.app.Service;
 import android.app.role.RoleManager;
 import android.content.Context;
 import android.content.Intent;
+import android.media.AudioAttributes;
 import android.media.IAudioService;
 import android.media.ToneGenerator;
+import android.os.CombinedVibration;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.PowerManager;
 import android.os.ServiceManager;
 import android.os.SystemClock;
+import android.os.SystemVibrator;
+import android.os.VibrationAttributes;
+import android.os.VibrationEffect;
+import android.os.Vibrator;
+import android.os.VibratorManager;
 import android.provider.BlockedNumberContract;
 import android.provider.BlockedNumbersManager;
 import android.telecom.Log;
@@ -115,6 +122,60 @@ public class TelecomService extends Service implements TelecomSystem.Component {
             HandlerThread handlerThread = new HandlerThread("TelecomSystem");
             handlerThread.start();
 
+            Ringer.VibratorAdapter vibratorAdapter;
+            if (featureFlags.resolveHiddenDependenciesTwo()) {
+                final VibratorManager vibratorManager =
+                        context.getSystemService(VibratorManager.class);
+                vibratorAdapter = new Ringer.VibratorAdapter() {
+                    @Override
+                    public boolean hasVibrator() {
+                        int[] vibratorIds = vibratorManager.getVibratorIds();
+                        return vibratorIds != null && vibratorIds.length > 0;
+                    }
+
+                    @Override
+                    public void vibrate(VibrationEffect vibe, VibrationAttributes attributes) {
+                        // This is what SystemVibrator does.
+                        CombinedVibration combinedEffect = CombinedVibration.createParallel(vibe);
+                        vibratorManager.vibrate(combinedEffect, attributes);
+                    }
+
+                    @Override
+                    public void cancel() {
+                        vibratorManager.cancel();
+                    }
+
+                    @Override
+                    public Vibrator getVibrator() {
+                        return vibratorManager.getDefaultVibrator();
+                    }
+                };
+            } else {
+                // SystemVibrator extends Vibrator
+                final SystemVibrator systemVibrator = new SystemVibrator(context);
+                vibratorAdapter = new Ringer.VibratorAdapter() {
+                    @Override
+                    public boolean hasVibrator() {
+                        return systemVibrator.hasVibrator();
+                    }
+
+                    @Override
+                    public void vibrate(VibrationEffect vibe, VibrationAttributes attributes) {
+                        systemVibrator.vibrate(vibe, attributes);
+                    }
+
+                    @Override
+                    public void cancel() {
+                        systemVibrator.cancel();
+                    }
+
+                    @Override
+                    public Vibrator getVibrator() {
+                        return systemVibrator;
+                    }
+                };
+            }
+
             TelecomSystem.setInstance(
                     new TelecomSystem(
                             context,
@@ -188,9 +249,9 @@ public class TelecomService extends Service implements TelecomSystem.Component {
                             },
                             ConnectionServiceFocusManager::new,
                             new Timeouts.Adapter(),
-                            new AsyncRingtonePlayer(),
+                            new AsyncRingtonePlayer(featureFlags),
                             new PhoneNumberUtilsAdapterImpl(),
-                            new IncomingCallNotifier(context),
+                            new IncomingCallNotifier(context, featureFlags),
                             ToneGenerator::new,
                             new CallAudioRouteStateMachine.Factory(),
                             new CallAudioModeStateMachine.Factory(),
@@ -242,12 +303,13 @@ public class TelecomService extends Service implements TelecomSystem.Component {
                                 public void updateEmergencyCallNotification(Context context,
                                         boolean showNotification) {
                                     BlockedNumbersUtil.updateEmergencyCallNotification(context,
-                                            showNotification);
+                                            showNotification, featureFlags);
                                 }
                             },
                             featureFlags,
                             new com.android.internal.telephony.flags.FeatureFlagsImpl(),
-                            handlerThread.getLooper()));
+                            handlerThread.getLooper(),
+                            vibratorAdapter));
         }
     }
 
diff --git a/src/com/android/server/telecom/components/UserCallActivity.java b/src/com/android/server/telecom/components/UserCallActivity.java
index 6f5dfea4d..f7f832ff1 100644
--- a/src/com/android/server/telecom/components/UserCallActivity.java
+++ b/src/com/android/server/telecom/components/UserCallActivity.java
@@ -31,8 +31,6 @@ import android.os.UserManager;
 import android.telecom.Log;
 import android.telecom.TelecomManager;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * Activity that handles system CALL actions and forwards them to {@link CallIntentProcessor}.
  * Handles all three CALL action types: CALL, CALL_PRIVILEGED, and CALL_EMERGENCY.
diff --git a/src/com/android/server/telecom/components/UserCallIntentProcessor.java b/src/com/android/server/telecom/components/UserCallIntentProcessor.java
index c3dc96340..2fbb61512 100755
--- a/src/com/android/server/telecom/components/UserCallIntentProcessor.java
+++ b/src/com/android/server/telecom/components/UserCallIntentProcessor.java
@@ -36,8 +36,6 @@ import com.android.server.telecom.TelephonyUtil;
 import com.android.server.telecom.UserUtil;
 import com.android.server.telecom.flags.FeatureFlags;
 
-// TODO: Needed for move to system service: import com.android.internal.R;
-
 /**
  * Handles system CALL actions and forwards them to {@link CallIntentProcessor}.
  * Handles all three CALL action types: CALL, CALL_PRIVILEGED, and CALL_EMERGENCY.
diff --git a/src/com/android/server/telecom/metrics/ApiStats.java b/src/com/android/server/telecom/metrics/ApiStats.java
index d962276c0..0054cf24b 100644
--- a/src/com/android/server/telecom/metrics/ApiStats.java
+++ b/src/com/android/server/telecom/metrics/ApiStats.java
@@ -157,6 +157,10 @@ public class ApiStats extends TelecomPulledAtom {
             .TELECOM_API_STATS__API_NAME__API_START_CONFERENCE;
     public static final int API_UNREGISTERPHONEACCOUNT = TelecomStatsLog
             .TELECOM_API_STATS__API_NAME__API_UNREGISTER_PHONE_ACCOUNT;
+    public static final int API_GETCALLCONNECTEDINDICATORPREF =
+            TelecomStatsLog.TELECOM_API_STATS__API_NAME__API_GET_CALL_CONNECTED_INDICATOR_PREF;
+    public static final int API_SETCALLCONNECTEDINDICATORPREF =
+            TelecomStatsLog.TELECOM_API_STATS__API_NAME__API_SET_CALL_CONNECTED_INDICATOR_PREF;
     public static final int RESULT_UNKNOWN = TelecomStatsLog
             .TELECOM_API_STATS__API_RESULT__RESULT_UNKNOWN;
     public static final int RESULT_NORMAL = TelecomStatsLog
@@ -302,6 +306,8 @@ public class ApiStats extends TelecomPulledAtom {
             API_SILENCERINGER,
             API_STARTCONFERENCE,
             API_UNREGISTERPHONEACCOUNT,
+            API_GETCALLCONNECTEDINDICATORPREF,
+            API_SETCALLCONNECTEDINDICATORPREF,
     })
     @Retention(RetentionPolicy.SOURCE)
     public @interface ApiId {
diff --git a/src/com/android/server/telecom/metrics/CallSequencingStats.java b/src/com/android/server/telecom/metrics/CallSequencingStats.java
new file mode 100644
index 000000000..164275103
--- /dev/null
+++ b/src/com/android/server/telecom/metrics/CallSequencingStats.java
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.telecom.metrics;
+
+import static com.android.server.telecom.TelecomStatsLog.CALL_SEQUENCING_STATS;
+
+import android.app.StatsManager;
+import android.content.Context;
+import android.os.Looper;
+import android.telecom.Log;
+import android.util.StatsEvent;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+
+import com.android.server.telecom.Call;
+import com.android.server.telecom.TelecomStatsLog;
+import com.android.server.telecom.callsequencing.CallSequencingController;
+import com.android.server.telecom.nano.PulledAtomsClass;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+public class CallSequencingStats extends TelecomPulledAtom {
+
+    private static final String TAG = CallSequencingStats.class.getSimpleName();
+
+    private static final String FILE_NAME = "call_sequencing_stats";
+
+    /**
+     * The following call types will be set on each call for call sequencing metrics related info.
+     * The call type can either be MANAGED, SELF_MANAGED, or TRANSACTIONAL.
+     */
+    public static final int CALL_TYPE_UNKNOWN = 0;
+    public static final int CALL_TYPE_MANAGED = 1;
+    public static final int CALL_TYPE_SELF_MANAGED = 2;
+    public static final int CALL_TYPE_TRANSACTIONAL = 3;
+
+    private Map<CallSequencingStatsKey, CallSequencingStatsData> mCallSequencingStatsMap;
+    private final Map<Call, CallSequencingStatsKey> mCallToStatsKeyMap = new HashMap<>();
+
+    public CallSequencingStats(@NonNull Context context,
+            @NonNull Looper looper, boolean isTestMode) {
+        super(context, looper, isTestMode);
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+    @Override
+    public int getTag() {
+        return CALL_SEQUENCING_STATS;
+    }
+
+    @Override
+    protected String getFileName() {
+        return FILE_NAME;
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+    @Override
+    public int onPull(List<StatsEvent> data) {
+        if (mPulledAtoms.callSequencingStats.length != 0) {
+            Arrays.stream(mPulledAtoms.callSequencingStats).forEach(v -> data.add(
+                    TelecomStatsLog.buildStatsEvent(getTag(),
+                            v.getPrimaryCallType(), v.getSecondaryCallType(),
+                            v.getIsPrimaryCallEmergency(), v.getIsSecondaryCallEmergency(),
+                            v.hasHasSecondary(), v.getIsSamePhoneAccount(),
+                            v.getAverageDurationMs(), v.getCount())));
+            mCallSequencingStatsMap.clear();
+            onAggregate();
+            return StatsManager.PULL_SUCCESS;
+        } else {
+            return StatsManager.PULL_SKIP;
+        }
+    }
+
+    @Override
+    protected void onLoad() {
+        if (mPulledAtoms.callSequencingStats != null) {
+            mCallSequencingStatsMap = new HashMap<>();
+            for (PulledAtomsClass.CallSequencingStats v : mPulledAtoms.callSequencingStats) {
+                mCallSequencingStatsMap.put(new CallSequencingStatsKey(v.getPrimaryCallType(),
+                                v.getSecondaryCallType(), v.getIsPrimaryCallEmergency(),
+                                v.getIsSecondaryCallEmergency(), v.getHasSecondary(),
+                                v.getIsSamePhoneAccount()), new CallSequencingStatsData(
+                                        v.getCount(), v.getAverageDurationMs()));
+            }
+            mLastPulledTimestamps = mPulledAtoms.getCallSequencingStatsPullTimestampMillis();
+        }
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+    @Override
+    public void onAggregate() {
+        Log.d(TAG, "onAggregate: %s", mCallSequencingStatsMap);
+        clearAtoms();
+        if (mCallSequencingStatsMap.isEmpty()) {
+            return;
+        }
+        mPulledAtoms.setCallSequencingStatsPullTimestampMillis(mLastPulledTimestamps);
+        mPulledAtoms.callSequencingStats =
+                new PulledAtomsClass.CallSequencingStats[mCallSequencingStatsMap.size()];
+        int[] index = new int[1];
+        mCallSequencingStatsMap.forEach((k, v) -> {
+            mPulledAtoms.callSequencingStats[index[0]] = new PulledAtomsClass.CallSequencingStats();
+            mPulledAtoms.callSequencingStats[index[0]].setPrimaryCallType(k.mPrimaryCallType);
+            mPulledAtoms.callSequencingStats[index[0]].setSecondaryCallType(k.mSecondaryCallType);
+            mPulledAtoms.callSequencingStats[index[0]]
+                    .setIsPrimaryCallEmergency(k.mIsPrimaryCallEmergency);
+            mPulledAtoms.callSequencingStats[index[0]].setIsSecondaryCallEmergency(
+                    k.mIsSecondaryCallEmergency);
+            mPulledAtoms.callSequencingStats[index[0]].setHasSecondary(k.mHasSecondary);
+            mPulledAtoms.callSequencingStats[index[0]].setIsSamePhoneAccount(k.mIsSamePhoneAccount);
+            mPulledAtoms.callSequencingStats[index[0]].setCount(v.mCount);
+            mPulledAtoms.callSequencingStats[index[0]].setAverageDurationMs(v.mAverageDuration);
+            index[0]++;
+        });
+        save(DELAY_FOR_PERSISTENT_MILLIS);
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+    public void log(CallSequencingStatsKey key, int duration) {
+        CallSequencingStatsData data = mCallSequencingStatsMap
+                .computeIfAbsent(key, k -> new CallSequencingStatsData(0, 0));
+        data.add(duration);
+        onAggregate();
+    }
+
+    public void onCallEnd(Call call) {
+        final int duration = (int) (call.getAgeMillis());
+        post(() -> {
+            if (mCallToStatsKeyMap.containsKey(call)) {
+                log(mCallToStatsKeyMap.get(call), duration);
+            }
+        });
+    }
+
+    public void setCallSequencingMetrics(Call callToSet, Call primaryCall) {
+        int primaryCallType, secondaryCallType = CALL_TYPE_UNKNOWN;
+        boolean isPrimaryCallEmergency, isSecondaryCallEmergency = false,
+                hasSecondaryCall = false, isSamePhoneAccount = false;
+        // Set the primary call metrics if there's no primary call.
+        if (primaryCall == null) {
+            primaryCallType = getCallType(callToSet);
+            isPrimaryCallEmergency = callToSet.isEmergencyCall();
+        } else { // Otherwise, the call is a secondary call.
+            primaryCallType = getCallType(primaryCall);
+            isPrimaryCallEmergency = primaryCall.isEmergencyCall();
+            secondaryCallType = getCallType(callToSet);
+            isSecondaryCallEmergency = callToSet.isEmergencyCall();
+            hasSecondaryCall = true;
+            // Only set the following fields for secondary calls as they aren't relevant for
+            // primary calls and we will duplicate data otherwise.
+            isSamePhoneAccount = CallSequencingController
+                    .arePhoneAccountsSame(callToSet, primaryCall);
+        }
+        // Store this new call information into a key which can be logged after the call ends.
+        CallSequencingStatsKey key = new CallSequencingStatsKey(primaryCallType,
+                secondaryCallType, isPrimaryCallEmergency, isSecondaryCallEmergency,
+                hasSecondaryCall, isSamePhoneAccount);
+        CallSequencingStatsData data = mCallSequencingStatsMap
+                .computeIfAbsent(key, k -> new CallSequencingStatsData(0, 0));
+        mCallToStatsKeyMap.putIfAbsent(callToSet, key);
+    }
+
+    @VisibleForTesting
+    public int getCallType(Call call) {
+        if (!call.isSelfManaged() && !call.isTransactionalCall()) {
+            return CALL_TYPE_MANAGED;
+        } else if (call.isSelfManaged()) {
+            return CALL_TYPE_SELF_MANAGED;
+        } else {
+            return CALL_TYPE_TRANSACTIONAL;
+        }
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+    public static class CallSequencingStatsKey {
+        final int mPrimaryCallType;
+        final int mSecondaryCallType;
+        final boolean mIsPrimaryCallEmergency;
+        final boolean mIsSecondaryCallEmergency;
+        final boolean mHasSecondary;
+        final boolean mIsSamePhoneAccount;
+
+        CallSequencingStatsKey(int primaryCallType,
+                int secondaryCallType, boolean isPrimaryCallEmergency,
+                boolean isSecondaryCallEmergency, boolean hasSecondary,
+                boolean isSamePhoneAccount) {
+            mPrimaryCallType = primaryCallType;
+            mSecondaryCallType = secondaryCallType;
+            mIsPrimaryCallEmergency = isPrimaryCallEmergency;
+            mIsSecondaryCallEmergency = isSecondaryCallEmergency;
+            mHasSecondary = hasSecondary;
+            mIsSamePhoneAccount = isSamePhoneAccount;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (this == other) {
+                return true;
+            }
+            if (!(other instanceof CallSequencingStatsKey obj)) {
+                return false;
+            }
+            return this.mPrimaryCallType == obj.mPrimaryCallType
+                    && this.mSecondaryCallType == obj.mSecondaryCallType
+                    && this.mIsPrimaryCallEmergency == obj.mIsPrimaryCallEmergency
+                    && this.mIsSecondaryCallEmergency == obj.mIsSecondaryCallEmergency
+                    && this.mHasSecondary == obj.mHasSecondary
+                    && this.mIsSamePhoneAccount == obj.mIsSamePhoneAccount;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(mPrimaryCallType, mSecondaryCallType, mIsPrimaryCallEmergency,
+                    mIsSecondaryCallEmergency, mHasSecondary, mIsSamePhoneAccount);
+        }
+
+        @Override
+        public String toString() {
+            return "[CallSequencingStatsKey: mPrimaryCallType=" + mPrimaryCallType
+                    + ", mSecondaryCallType= " + mSecondaryCallType
+                    + ", mIsPrimaryCallEmergency= " + mIsPrimaryCallEmergency
+                    + ", mIsSecondaryCallEmergency=" + mIsSecondaryCallEmergency
+                    + ", mHasSecondary= " + mHasSecondary
+                    + ", mIsSamePhoneAccount= " + mIsSamePhoneAccount + "]";
+        }
+    }
+
+    static class CallSequencingStatsData {
+
+        int mCount;
+        int mAverageDuration;
+
+        CallSequencingStatsData(int count, int averageDuration) {
+            mCount = count;
+            mAverageDuration = averageDuration;
+        }
+
+        void add(int duration) {
+            mCount++;
+            mAverageDuration += (duration - mAverageDuration) / mCount;
+        }
+
+        @Override
+        public String toString() {
+            return "[CallSequencingStatsData: mCount=" + mCount + ", mAverageDuration:"
+                    + mAverageDuration + "]";
+        }
+    }
+}
diff --git a/src/com/android/server/telecom/metrics/TelecomMetricsController.java b/src/com/android/server/telecom/metrics/TelecomMetricsController.java
index 980c18064..6c0b31605 100644
--- a/src/com/android/server/telecom/metrics/TelecomMetricsController.java
+++ b/src/com/android/server/telecom/metrics/TelecomMetricsController.java
@@ -21,6 +21,7 @@ import static com.android.server.telecom.TelecomStatsLog.CALL_STATS;
 import static com.android.server.telecom.TelecomStatsLog.TELECOM_API_STATS;
 import static com.android.server.telecom.TelecomStatsLog.TELECOM_ERROR_STATS;
 import static com.android.server.telecom.TelecomStatsLog.TELECOM_EVENT_STATS;
+import static com.android.server.telecom.TelecomStatsLog.CALL_SEQUENCING_STATS;
 
 import android.annotation.NonNull;
 import android.app.StatsManager;
@@ -128,6 +129,16 @@ public class TelecomMetricsController implements StatsManager.StatsPullAtomCallb
         return stats;
     }
 
+    @NonNull
+    public CallSequencingStats getCallSequencingStats() {
+        CallSequencingStats stats = (CallSequencingStats) mStats.get(CALL_SEQUENCING_STATS);
+        if (stats == null) {
+            stats = new CallSequencingStats(mContext, mHandlerThread.getLooper(), isTestMode());
+            registerAtom(stats.getTag(), stats);
+        }
+        return stats;
+    }
+
     @Override
     public int onPullAtom(final int atomTag, final List<StatsEvent> data) {
         if (mStats.containsKey(atomTag)) {
diff --git a/src/com/android/server/telecom/settings/BlockedNumbersActivity.java b/src/com/android/server/telecom/settings/BlockedNumbersActivity.java
index 89f5cdcfe..9799416a0 100644
--- a/src/com/android/server/telecom/settings/BlockedNumbersActivity.java
+++ b/src/com/android/server/telecom/settings/BlockedNumbersActivity.java
@@ -159,7 +159,7 @@ public class BlockedNumbersActivity extends ListActivity
         updateButterBar();
 
         updateEnhancedCallBlockingFragment(
-                BlockedNumbersUtil.isEnhancedCallBlockingEnabledByPlatform(this));
+                BlockedNumbersUtil.isEnhancedCallBlockingEnabledByPlatform(this, mFeatureFlags));
 
         mBlockingStatusReceiver = new BroadcastReceiver() {
             @Override
diff --git a/src/com/android/server/telecom/settings/BlockedNumbersUtil.java b/src/com/android/server/telecom/settings/BlockedNumbersUtil.java
index 99c57466a..f740e6272 100644
--- a/src/com/android/server/telecom/settings/BlockedNumbersUtil.java
+++ b/src/com/android/server/telecom/settings/BlockedNumbersUtil.java
@@ -17,7 +17,6 @@
 package com.android.server.telecom.settings;
 
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
@@ -35,6 +34,7 @@ import android.widget.Toast;
 
 import com.android.server.telecom.R;
 import com.android.server.telecom.SystemSettingsUtil;
+import com.android.server.telecom.UserUtil;
 import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.ui.NotificationChannelManager;
 
@@ -91,9 +91,8 @@ public final class BlockedNumbersUtil {
      * @param context context to start CallBlockDisabledActivity.
      * @param showNotification if {@code true} show notification, {@code false} cancel notification.
      */
-    public static void updateEmergencyCallNotification(Context context, boolean showNotification) {
-        NotificationManager notificationManager =
-                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+    public static void updateEmergencyCallNotification(Context context, boolean showNotification,
+            FeatureFlags featureFlags) {
         if (showNotification) {
             Intent intent = new Intent(context, CallBlockDisabledActivity.class);
             PendingIntent pendingIntent = PendingIntent.getActivity(
@@ -115,11 +114,11 @@ public final class BlockedNumbersUtil {
                     .build();
 
             notification.flags |= Notification.FLAG_NO_CLEAR;
-            notificationManager.notifyAsUser(null /* tag */ , EMERGENCY_CALL_NOTIFICATION,
-                    notification, new UserHandle(UserHandle.USER_OWNER));
+            UserUtil.processNotification(context, new UserHandle(UserHandle.USER_SYSTEM), null,
+                    EMERGENCY_CALL_NOTIFICATION, notification, featureFlags);
         } else {
-            notificationManager.cancelAsUser(null /* tag */ , EMERGENCY_CALL_NOTIFICATION,
-                    new UserHandle(UserHandle.USER_OWNER));
+            UserUtil.processNotification(context, new UserHandle(UserHandle.USER_SYSTEM), null,
+                    EMERGENCY_CALL_NOTIFICATION, null /* notification */, featureFlags);
         }
     }
 
@@ -130,7 +129,7 @@ public final class BlockedNumbersUtil {
      * @return If {@code true} means enhanced call blocking enabled by platform,
      *            {@code false} otherwise.
      */
-    public static boolean isEnhancedCallBlockingEnabledByPlatform(Context context) {
+    public static boolean isEnhancedCallBlockingEnabledByPlatform(Context context, FeatureFlags f) {
         CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(
                 Context.CARRIER_CONFIG_SERVICE);
         PersistableBundle carrierConfig = null;
@@ -142,7 +141,7 @@ public final class BlockedNumbersUtil {
         }
         return carrierConfig.getBoolean(
                 CarrierConfigManager.KEY_SUPPORT_ENHANCED_CALL_BLOCKING_BOOL)
-                || new SystemSettingsUtil().isEnhancedCallBlockingEnabled(context);
+                || new SystemSettingsUtil().isEnhancedCallBlockingEnabled(context, f);
     }
 
     /**
diff --git a/src/com/android/server/telecom/settings/CallBlockDisabledActivity.java b/src/com/android/server/telecom/settings/CallBlockDisabledActivity.java
index cc66a2d32..5b8dc39cb 100644
--- a/src/com/android/server/telecom/settings/CallBlockDisabledActivity.java
+++ b/src/com/android/server/telecom/settings/CallBlockDisabledActivity.java
@@ -68,7 +68,7 @@ public class CallBlockDisabledActivity extends Activity {
                                         .ENHANCED_SETTING_KEY_SHOW_EMERGENCY_CALL_NOTIFICATION,
                                 false, mFeatureFlags);
                         BlockedNumbersUtil.updateEmergencyCallNotification(
-                                CallBlockDisabledActivity.this, false);
+                                CallBlockDisabledActivity.this, false, mFeatureFlags);
                         finish();
                     }
                 })
diff --git a/src/com/android/server/telecom/ui/AudioProcessingNotification.java b/src/com/android/server/telecom/ui/AudioProcessingNotification.java
index 952bee8fc..c46155504 100644
--- a/src/com/android/server/telecom/ui/AudioProcessingNotification.java
+++ b/src/com/android/server/telecom/ui/AudioProcessingNotification.java
@@ -17,7 +17,6 @@
 package com.android.server.telecom.ui;
 
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.content.Context;
 import android.os.UserHandle;
 import android.telecom.Log;
@@ -26,6 +25,8 @@ import com.android.server.telecom.Call;
 import com.android.server.telecom.CallState;
 import com.android.server.telecom.CallsManagerListenerBase;
 import com.android.server.telecom.R;
+import com.android.server.telecom.UserUtil;
+import com.android.server.telecom.flags.FeatureFlags;
 
 /**
  * Displays a persistent notification whenever there's a call in the AUDIO_PROCESSING state so that
@@ -38,13 +39,12 @@ public class AudioProcessingNotification extends CallsManagerListenerBase {
             AudioProcessingNotification.class.getSimpleName();
 
     private final Context mContext;
-    private final NotificationManager mNotificationManager;
+    private final FeatureFlags mFeatureFlags;
     private Call mCallInAudioProcessing;
 
-    public AudioProcessingNotification(Context context) {
+    public AudioProcessingNotification(Context context, FeatureFlags featureFlags) {
         mContext = context;
-        mNotificationManager =
-                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mFeatureFlags = featureFlags;
     }
 
     @Override
@@ -95,15 +95,15 @@ public class AudioProcessingNotification extends CallsManagerListenerBase {
                 .setOngoing(true);
 
         Notification notification = builder.build();
-
-        mNotificationManager.notifyAsUser(NOTIFICATION_TAG, AUDIO_PROCESSING_NOTIFICATION_ID,
-                notification, mCallInAudioProcessing.getAssociatedUser());
+        UserUtil.processNotification(mContext, mCallInAudioProcessing.getAssociatedUser(),
+                NOTIFICATION_TAG, AUDIO_PROCESSING_NOTIFICATION_ID, notification, mFeatureFlags);
     }
 
     /** Cancels the audio processing notification. */
     private void cancelAudioProcessingNotification(UserHandle userHandle) {
         Log.i(this, "cancelAudioProcessingNotification for user = %s", userHandle);
-        mNotificationManager.cancelAsUser(NOTIFICATION_TAG,
-                AUDIO_PROCESSING_NOTIFICATION_ID, userHandle);
+        UserUtil.processNotification(mContext, mCallInAudioProcessing.getAssociatedUser(),
+                NOTIFICATION_TAG, AUDIO_PROCESSING_NOTIFICATION_ID, null /* notification */,
+                mFeatureFlags);
     }
 }
diff --git a/src/com/android/server/telecom/ui/CallStreamingNotification.java b/src/com/android/server/telecom/ui/CallStreamingNotification.java
index 06da5e32b..9d7bab2af 100644
--- a/src/com/android/server/telecom/ui/CallStreamingNotification.java
+++ b/src/com/android/server/telecom/ui/CallStreamingNotification.java
@@ -19,11 +19,11 @@ package com.android.server.telecom.ui;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Person;
 import android.content.Context;
 import android.content.Intent;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.drawable.BitmapDrawable;
@@ -46,7 +46,9 @@ import com.android.server.telecom.Call;
 import com.android.server.telecom.CallsManagerListenerBase;
 import com.android.server.telecom.R;
 import com.android.server.telecom.TelecomBroadcastIntentProcessor;
+import com.android.server.telecom.UserUtil;
 import com.android.server.telecom.components.TelecomBroadcastReceiver;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.concurrent.Executor;
 
@@ -65,11 +67,11 @@ public class CallStreamingNotification extends CallsManagerListenerBase implemen
             CallStreamingNotification.class.getSimpleName();
 
     private final Context mContext;
-    private final NotificationManager mNotificationManager;
     // Used to get the app name for the notification.
     private final AppLabelProxy mAppLabelProxy;
     // An executor that can be used to fire off async tasks that do not block Telecom in any manner.
     private final Executor mAsyncTaskExecutor;
+    private final FeatureFlags mFeatureFlags;
     // The call which is streaming.
     private Call mStreamingCall;
     // Lock for notification post/remove -- these happen outside the Telecom sync lock.
@@ -83,11 +85,11 @@ public class CallStreamingNotification extends CallsManagerListenerBase implemen
 
     public CallStreamingNotification(@NonNull Context context,
             @NonNull AppLabelProxy appLabelProxy,
-            @NonNull Executor asyncTaskExecutor) {
+            @NonNull Executor asyncTaskExecutor, FeatureFlags featureFlags) {
         mContext = context;
-        mNotificationManager = context.getSystemService(NotificationManager.class);
         mAppLabelProxy = appLabelProxy;
         mAsyncTaskExecutor = asyncTaskExecutor;
+        mFeatureFlags = featureFlags;
     }
 
     @Override
@@ -149,13 +151,32 @@ public class CallStreamingNotification extends CallsManagerListenerBase implemen
         mAsyncTaskExecutor.execute(() -> {
             Icon contactPhotoIcon = null;
             try {
-                contactPhotoIcon = Icon.createWithResource(mContext.getResources(),
-                        R.drawable.person_circle);
+                if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                    Resources resources = mContext.getResources();
+                    String resPackage = null;
+                    if (resources != null) {
+                        resPackage = resources.getResourcePackageName(R.drawable.person_circle);
+                    }
+                    if (resPackage != null) {
+                        contactPhotoIcon = Icon.createWithResource(
+                                resPackage, R.drawable.person_circle);
+                    } else {
+                        contactPhotoIcon = Icon.createWithResource(mContext,
+                                R.drawable.person_circle);
+                    }
+                } else {
+                    contactPhotoIcon = Icon.createWithResource(mContext.getResources(),
+                            R.drawable.person_circle);
+                }
             } catch (Exception e) {
                 // All loads of things can do wrong when working with bitmaps and images, so to
                 // ensure Telecom doesn't crash, lets try/catch to be sure.
                 Log.e(this, e, "enqueueStreamingNotification: Couldn't build avatar icon");
             }
+            if (contactPhotoIcon == null) {
+                Log.e(this, new Exception(), "enqueueStreamingNotification: "
+                        + "contactPhotoIcon is null");
+            }
             showStreamingNotification(call.getId(),
                     call.getAssociatedUser(), call.getCallerDisplayName(),
                     call.getHandle(), contactPhotoIcon,
@@ -269,8 +290,8 @@ public class CallStreamingNotification extends CallsManagerListenerBase implemen
             mIsNotificationShowing = true;
             mNotificationUserHandle = userHandle;
             try {
-                mNotificationManager.notifyAsUser(NOTIFICATION_TAG, STREAMING_NOTIFICATION_ID,
-                        notification, userHandle);
+                UserUtil.processNotification(mContext, userHandle, NOTIFICATION_TAG,
+                        STREAMING_NOTIFICATION_ID, notification, mFeatureFlags);
             } catch (Exception e) {
                 // We don't want to crash Telecom if something changes with the requirements for the
                 // notification.
@@ -287,8 +308,8 @@ public class CallStreamingNotification extends CallsManagerListenerBase implemen
         synchronized(mNotificationLock) {
             if (mIsNotificationShowing) {
                 mIsNotificationShowing = false;
-                mNotificationManager.cancelAsUser(NOTIFICATION_TAG,
-                        STREAMING_NOTIFICATION_ID, mNotificationUserHandle);
+                UserUtil.processNotification(mContext, mNotificationUserHandle, NOTIFICATION_TAG,
+                        STREAMING_NOTIFICATION_ID, null /* notification */, mFeatureFlags);
             }
         }
     }
diff --git a/src/com/android/server/telecom/ui/DisconnectedCallNotifier.java b/src/com/android/server/telecom/ui/DisconnectedCallNotifier.java
index 04228c1b1..a36d51df0 100644
--- a/src/com/android/server/telecom/ui/DisconnectedCallNotifier.java
+++ b/src/com/android/server/telecom/ui/DisconnectedCallNotifier.java
@@ -18,7 +18,6 @@ package com.android.server.telecom.ui;
 
 import android.annotation.NonNull;
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.TaskStackBuilder;
 import android.content.Context;
@@ -49,7 +48,9 @@ import com.android.server.telecom.CallsManagerListenerBase;
 import com.android.server.telecom.Constants;
 import com.android.server.telecom.R;
 import com.android.server.telecom.TelecomBroadcastIntentProcessor;
+import com.android.server.telecom.UserUtil;
 import com.android.server.telecom.components.TelecomBroadcastReceiver;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.Locale;
 
@@ -61,14 +62,16 @@ import java.util.Locale;
 public class DisconnectedCallNotifier extends CallsManagerListenerBase {
 
     public interface Factory {
-        DisconnectedCallNotifier create(Context context, CallsManager manager);
+        DisconnectedCallNotifier create(Context context, CallsManager manager,
+                FeatureFlags featureFlags);
     }
 
     public static class Default implements Factory {
 
         @Override
-        public DisconnectedCallNotifier create(Context context, CallsManager manager) {
-            return new DisconnectedCallNotifier(context, manager);
+        public DisconnectedCallNotifier create(Context context, CallsManager manager,
+                FeatureFlags featureFlags) {
+            return new DisconnectedCallNotifier(context, manager, featureFlags);
         }
     }
 
@@ -112,15 +115,15 @@ public class DisconnectedCallNotifier extends CallsManagerListenerBase {
 
     private final Context mContext;
     private final CallsManager mCallsManager;
-    private final NotificationManager mNotificationManager;
+    private final FeatureFlags mFeatureFlags;
     // The pending info to display to the user after they have ended the emergency call.
     private CallInfo mPendingCallNotification;
 
-    public DisconnectedCallNotifier(Context context, CallsManager callsManager) {
+    public DisconnectedCallNotifier(Context context, CallsManager callsManager,
+            FeatureFlags featureFlags) {
         mContext = context;
-        mNotificationManager =
-                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
         mCallsManager = callsManager;
+        mFeatureFlags = featureFlags;
     }
 
     @Override
@@ -241,8 +244,8 @@ public class DisconnectedCallNotifier extends CallsManagerListenerBase {
         try {
             // TODO: Only support one notification right now, so if multiple are hung up, we only
             // show the last one. Support multiple in the future.
-            mNotificationManager.notifyAsUser(NOTIFICATION_TAG, DISCONNECTED_CALL_NOTIFICATION_ID,
-                    notification, call.userHandle);
+            UserUtil.processNotification(mContext, call.userHandle, NOTIFICATION_TAG,
+                    DISCONNECTED_CALL_NOTIFICATION_ID, notification, mFeatureFlags);
         } finally {
             Binder.restoreCallingIdentity(token);
         }
@@ -383,8 +386,8 @@ public class DisconnectedCallNotifier extends CallsManagerListenerBase {
     public void clearNotification(UserHandle userHandle) {
         long token = Binder.clearCallingIdentity();
         try {
-            mNotificationManager.cancelAsUser(NOTIFICATION_TAG, DISCONNECTED_CALL_NOTIFICATION_ID,
-                    userHandle);
+            UserUtil.processNotification(mContext, userHandle, NOTIFICATION_TAG,
+                    DISCONNECTED_CALL_NOTIFICATION_ID, null /* notification */, mFeatureFlags);
         } finally {
             Binder.restoreCallingIdentity(token);
         }
diff --git a/src/com/android/server/telecom/ui/IncomingCallNotifier.java b/src/com/android/server/telecom/ui/IncomingCallNotifier.java
index d419163c2..f12b84304 100644
--- a/src/com/android/server/telecom/ui/IncomingCallNotifier.java
+++ b/src/com/android/server/telecom/ui/IncomingCallNotifier.java
@@ -17,7 +17,6 @@
 package com.android.server.telecom.ui;
 
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
@@ -40,7 +39,9 @@ import com.android.server.telecom.CallsManagerListenerBase;
 import com.android.server.telecom.HandoverState;
 import com.android.server.telecom.R;
 import com.android.server.telecom.TelecomBroadcastIntentProcessor;
+import com.android.server.telecom.UserUtil;
 import com.android.server.telecom.components.TelecomBroadcastReceiver;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import java.util.Objects;
 import java.util.Optional;
@@ -83,17 +84,16 @@ public class IncomingCallNotifier extends CallsManagerListenerBase {
     };
 
     private final Context mContext;
-    private final NotificationManager mNotificationManager;
+    private final FeatureFlags mFeatureFlags;
     private final Set<Call> mCalls = new ArraySet<>();
     private CallsManagerProxy mCallsManagerProxy;
 
     // The current incoming call we are displaying UX for.
     private Call mIncomingCall;
 
-    public IncomingCallNotifier(Context context) {
+    public IncomingCallNotifier(Context context, FeatureFlags featureFlags) {
         mContext = context;
-        mNotificationManager =
-                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mFeatureFlags = featureFlags;
     }
 
     public void setCallsManagerProxy(CallsManagerProxy callsManagerProxy) {
@@ -179,14 +179,14 @@ public class IncomingCallNotifier extends CallsManagerListenerBase {
 
         Notification.Builder builder = getNotificationBuilder(call,
                 mCallsManagerProxy.getActiveCall());
-        mNotificationManager.notifyAsUser(NOTIFICATION_TAG, NOTIFICATION_INCOMING_CALL,
-                builder.build(), call.getAssociatedUser());
+        UserUtil.processNotification(mContext, call.getAssociatedUser(), NOTIFICATION_TAG,
+                NOTIFICATION_INCOMING_CALL, builder.build(), mFeatureFlags);
     }
 
     private void hideIncomingCallNotification(UserHandle userHandle) {
         Log.i(this, "hideIncomingCallNotification for user = %s", userHandle);
-        mNotificationManager.cancelAsUser(NOTIFICATION_TAG, NOTIFICATION_INCOMING_CALL,
-                userHandle);
+        UserUtil.processNotification(mContext, userHandle, NOTIFICATION_TAG,
+                NOTIFICATION_INCOMING_CALL, null /* notification */, mFeatureFlags);
     }
 
     private String getNotificationName(Call call) {
@@ -208,8 +208,14 @@ public class IncomingCallNotifier extends CallsManagerListenerBase {
         // Change the notification app name to "Android System" to sufficiently distinguish this
         // from the phone app's name.
         Bundle extras = new Bundle();
-        extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mContext.getString(
-                com.android.internal.R.string.android_system_label));
+
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mContext.getString(
+                    com.android.server.telecom.R.string.android_system_label));
+        } else {
+            extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mContext.getString(
+                    com.android.internal.R.string.android_system_label));
+        }
 
         Intent answerIntent = new Intent(
                 TelecomBroadcastIntentProcessor.ACTION_ANSWER_FROM_NOTIFICATION, null, mContext,
diff --git a/src/com/android/server/telecom/ui/MissedCallNotifierImpl.java b/src/com/android/server/telecom/ui/MissedCallNotifierImpl.java
index 220b44edd..e93e28fd3 100644
--- a/src/com/android/server/telecom/ui/MissedCallNotifierImpl.java
+++ b/src/com/android/server/telecom/ui/MissedCallNotifierImpl.java
@@ -23,15 +23,16 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.BroadcastOptions;
 import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.TaskStackBuilder;
 import android.app.admin.DevicePolicyManager;
 import android.content.AsyncQueryHandler;
 import android.content.ContentProvider;
+import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.ResolveInfo;
 import android.database.Cursor;
@@ -65,6 +66,7 @@ import com.android.server.telecom.CallsManagerListenerBase;
 import com.android.server.telecom.Constants;
 import com.android.server.telecom.DefaultDialerCache;
 import com.android.server.telecom.DeviceIdleControllerAdapter;
+import com.android.server.telecom.UserUtil;
 import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.MissedCallNotifier;
 import com.android.server.telecom.PhoneAccountRegistrar;
@@ -74,6 +76,7 @@ import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.Timeouts;
 import com.android.server.telecom.components.TelecomBroadcastReceiver;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -108,7 +111,8 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
         }
     }
 
-    private static final String[] CALL_LOG_PROJECTION = new String[] {
+    @VisibleForTesting
+    public static final String[] CALL_LOG_PROJECTION = new String[] {
         Calls._ID,
         Calls.NUMBER,
         Calls.NUMBER_PRESENTATION,
@@ -117,7 +121,8 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
         Calls.TYPE,
     };
 
-    private static final String CALL_LOG_WHERE_CLAUSE = "type=" + Calls.MISSED_TYPE +
+    @VisibleForTesting
+    public static final String CALL_LOG_WHERE_CLAUSE = "type=" + Calls.MISSED_TYPE +
             " AND new=1" +
             " AND is_read=0";
 
@@ -134,7 +139,6 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
 
     private final Context mContext;
     private final PhoneAccountRegistrar mPhoneAccountRegistrar;
-    private final NotificationManager mNotificationManager;
     private final NotificationBuilderFactory mNotificationBuilderFactory;
     private final DefaultDialerCache mDefaultDialerCache;
     private final DeviceIdleControllerAdapter mDeviceIdleControllerAdapter;
@@ -164,8 +168,6 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
             FeatureFlags featureFlags) {
         mContext = context;
         mPhoneAccountRegistrar = phoneAccountRegistrar;
-        mNotificationManager =
-                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
         mDeviceIdleControllerAdapter = deviceIdleControllerAdapter;
         mDefaultDialerCache = defaultDialerCache;
 
@@ -200,14 +202,35 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
                 where.append(Calls.TYPE);
                 where.append(" = ?");
                 try {
-                    Uri callsUri = ContentProvider
-                            .maybeAddUserId(Calls.CONTENT_URI, userHandle.getIdentifier());
-                    mContext.getContentResolver().update(callsUri, values,
-                            where.toString(), new String[]{ Integer.toString(Calls.
-                            MISSED_TYPE) });
+                    ContentResolver resolver;
+                    Uri uriToUpdate;
+
+                    if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+                        Context userContext = mContext.createContextAsUser(userHandle, 0);
+                        resolver = userContext.getContentResolver();
+                        uriToUpdate = Calls.CONTENT_URI;
+                    } else {
+                        resolver = mContext.getContentResolver();
+                        uriToUpdate = ContentProvider
+                                .maybeAddUserId(Calls.CONTENT_URI, userHandle.getIdentifier());
+                    }
+
+                    if (resolver != null && uriToUpdate != null) {
+                        resolver.update(uriToUpdate, values, where.toString(),
+                                new String[]{ Integer.toString(Calls.MISSED_TYPE) });
+                    } else {
+                        Log.w(this, "markMissedCallsAsRead: ContentResolver or UriToUpdate "
+                                + "is null. Cannot update call log. Resolver: " + resolver +
+                                " Uri: " + uriToUpdate);
+                    }
                 } catch (IllegalArgumentException e) {
-                    Log.w(this, "ContactsProvider update command failed", e);
+                    Log.e(this, e, "ContactsProvider update command failed for user "
+                            + userHandle);
+                } catch (Exception e) {
+                    Log.e(this, e, "Exception in markMissedCallsAsRead for user "
+                            + userHandle);
                 }
+
             }
         }.prepare());
     }
@@ -245,8 +268,14 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
             return false;
         }
 
-        List<ResolveInfo> receivers = mContext.getPackageManager()
-                .queryBroadcastReceiversAsUser(intent, 0, userHandle.getIdentifier());
+        List<ResolveInfo> receivers;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            receivers = UserUtil.getPackageManagerFromUserHandler(mContext, userHandle)
+                    .queryBroadcastReceiversAsUser(intent, 0, userHandle.getIdentifier());
+        } else {
+            receivers = mContext.getPackageManager()
+                    .queryBroadcastReceiversAsUser(intent, 0, userHandle.getIdentifier());
+        }
         return receivers.size() > 0;
     }
 
@@ -262,7 +291,7 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
         }
         BroadcastOptions bopts = BroadcastOptions.makeBasic();
         long duration = Timeouts.getDialerMissedCallPowerSaveExemptionTimeMillis(
-                mContext.getContentResolver());
+                mContext, mFeatureFlags);
         mDeviceIdleControllerAdapter.exemptAppTemporarilyForEvent(dialerPackage, duration,
                 handle.getIdentifier(), MISSED_CALL_POWER_SAVE_REASON);
         bopts.setTemporaryAppWhitelistDuration(duration);
@@ -438,8 +467,8 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
         Log.i(this, "Adding missed call notification for %s.", Log.pii(callInfo.getHandle()));
         long token = Binder.clearCallingIdentity();
         try {
-            mNotificationManager.notifyAsUser(
-                    NOTIFICATION_TAG, MISSED_CALL_NOTIFICATION_ID, notification, userHandle);
+            UserUtil.processNotification(mContext, userHandle, NOTIFICATION_TAG,
+                    MISSED_CALL_NOTIFICATION_ID, notification, mFeatureFlags);
         } finally {
             Binder.restoreCallingIdentity(token);
         }
@@ -462,8 +491,8 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
 
         long token = Binder.clearCallingIdentity();
         try {
-            mNotificationManager.cancelAsUser(NOTIFICATION_TAG, MISSED_CALL_NOTIFICATION_ID,
-                    userHandle);
+            UserUtil.processNotification(mContext, userHandle, NOTIFICATION_TAG,
+                    MISSED_CALL_NOTIFICATION_ID, null /* notification */, mFeatureFlags);
         } finally {
             Binder.restoreCallingIdentity(token);
         }
@@ -634,8 +663,15 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
             return;
         }
 
+        Context contextToUse;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            contextToUse = mContext.createContextAsUser(userHandle, 0 /* flags */);
+        } else {
+            contextToUse = mContext;
+        }
+
         // instantiate query handler
-        AsyncQueryHandler queryHandler = new AsyncQueryHandler(mContext.getContentResolver()) {
+        AsyncQueryHandler queryHandler = new AsyncQueryHandler(contextToUse.getContentResolver()) {
             @Override
             protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
                 Log.d(MissedCallNotifierImpl.this, "onQueryComplete()...");
@@ -716,8 +752,13 @@ public class MissedCallNotifierImpl extends CallsManagerListenerBase implements
         };
 
         // setup query spec, look for all Missed calls that are new.
-        Uri callsUri =
-                ContentProvider.maybeAddUserId(Calls.CONTENT_URI, userHandle.getIdentifier());
+        Uri callsUri;
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            callsUri = Calls.CONTENT_URI;
+        } else {
+            callsUri = ContentProvider
+                    .maybeAddUserId(Calls.CONTENT_URI, userHandle.getIdentifier());
+        }
         // start the query
         queryHandler.startQuery(0, null, callsUri, CALL_LOG_PROJECTION,
                 CALL_LOG_WHERE_CLAUSE, null, Calls.DEFAULT_SORT_ORDER);
diff --git a/src/com/android/server/telecom/ui/TelecomDeveloperMenu.java b/src/com/android/server/telecom/ui/TelecomDeveloperMenu.java
index ae2e8530a..4c729ada7 100644
--- a/src/com/android/server/telecom/ui/TelecomDeveloperMenu.java
+++ b/src/com/android/server/telecom/ui/TelecomDeveloperMenu.java
@@ -22,6 +22,7 @@ import android.widget.Switch;
 
 import com.android.server.telecom.R;
 import com.android.server.telecom.SystemSettingsUtil;
+import com.android.server.telecom.flags.FeatureFlagsImpl;
 
 /**
  * Telecom Developer Settings Menu.
@@ -30,6 +31,7 @@ public class TelecomDeveloperMenu extends Activity {
 
     private Switch mEnhancedCallingSwitch;
     private SystemSettingsUtil mSystemSettingsUtil;
+    private FeatureFlagsImpl mFeatureFlags = new FeatureFlagsImpl();
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -46,10 +48,11 @@ public class TelecomDeveloperMenu extends Activity {
 
     private void handleEnhancedCallingToggle() {
         mSystemSettingsUtil.setEnhancedCallBlockingEnabled(this,
-                mEnhancedCallingSwitch.isChecked());
+                mEnhancedCallingSwitch.isChecked(), mFeatureFlags);
     }
 
     private void loadPreferences() {
-        mEnhancedCallingSwitch.setChecked(mSystemSettingsUtil.isEnhancedCallBlockingEnabled(this));
+        mEnhancedCallingSwitch.setChecked(mSystemSettingsUtil.isEnhancedCallBlockingEnabled(this,
+                mFeatureFlags));
     }
 }
\ No newline at end of file
diff --git a/tests/src/com/android/server/telecom/tests/AnalyticsTests.java b/tests/src/com/android/server/telecom/tests/AnalyticsTests.java
index 9caf0b546..7570a7840 100644
--- a/tests/src/com/android/server/telecom/tests/AnalyticsTests.java
+++ b/tests/src/com/android/server/telecom/tests/AnalyticsTests.java
@@ -31,7 +31,6 @@ import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.content.ContentResolver;
 import android.content.Context;
 import android.os.Build;
 import android.telecom.CallAudioState;
@@ -55,8 +54,8 @@ import androidx.test.filters.SmallTest;
 
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.server.telecom.Analytics;
-import com.android.server.telecom.CallAudioRouteStateMachine;
 import com.android.server.telecom.LogUtils;
+import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.nano.TelecomLogClass;
 
 import org.junit.After;
@@ -188,8 +187,8 @@ public class AnalyticsTests extends TelecomSystemTest {
     @MediumTest
     @Test
     public void testAnalyticsTwoCalls() throws Exception {
-        when(mTimeoutsAdapter.getCallScreeningTimeoutMillis(any(ContentResolver.class)))
-                .thenReturn((long) TEST_TIMEOUT);
+        when(mTimeoutsAdapter.getCallScreeningTimeoutMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn((long) TEST_TIMEOUT);
         IdPair testCall1 = startAndMakeActiveIncomingCall(
                 "650-555-1212",
                 mPhoneAccountA0.getAccountHandle(),
@@ -390,14 +389,14 @@ public class AnalyticsTests extends TelecomSystemTest {
                 TEST_TIMEOUT);
         audioRoutes.add(mInCallServiceFixtureX.mCallAudioState.getRoute());
         mInCallServiceFixtureX.getInCallAdapter().setAudioRoute(CallAudioState.ROUTE_SPEAKER, null);
-        waitForHandlerAction(
+        waitForHandlerActionDelayed(
                 mTelecomSystem.getCallsManager().getCallAudioManager()
                         .getCallAudioRouteAdapter().getAdapterHandler(),
-                TEST_TIMEOUT);
-        waitForHandlerAction(
+                TEST_TIMEOUT, TEST_TIMEOUT);
+        waitForHandlerActionDelayed(
                 mTelecomSystem.getCallsManager().getCallAudioManager()
                         .getCallAudioModeStateMachine().getHandler(),
-                TEST_TIMEOUT);
+                TEST_TIMEOUT, TEST_TIMEOUT);
         audioRoutes.add(CallAudioState.ROUTE_SPEAKER);
 
         Map<String, Analytics.CallInfoImpl> analyticsMap = Analytics.cloneData();
@@ -406,8 +405,7 @@ public class AnalyticsTests extends TelecomSystemTest {
         Analytics.CallInfoImpl callAnalytics = analyticsMap.get(testCall.mCallId);
         List<EventManager.Event> events = callAnalytics.callEvents.getEvents();
         for (int route : audioRoutes) {
-            String logEvent = CallAudioRouteStateMachine.AUDIO_ROUTE_TO_LOG_EVENT.get(route);
-            assertTrue(events.stream().anyMatch(event -> event.eventId.equals(logEvent)));
+            assertTrue(events.stream().anyMatch(event -> event.eventId.contains(LogUtils.Events.AUDIO_ROUTE)));
         }
     }
 
diff --git a/tests/src/com/android/server/telecom/tests/BasicCallTests.java b/tests/src/com/android/server/telecom/tests/BasicCallTests.java
index ef2d1a8d8..41646a3bf 100644
--- a/tests/src/com/android/server/telecom/tests/BasicCallTests.java
+++ b/tests/src/com/android/server/telecom/tests/BasicCallTests.java
@@ -627,7 +627,6 @@ public class BasicCallTests extends TelecomSystemTest {
     @LargeTest
     @Test
     public void testIncomingThenOutgoingCalls_AssociatedUsersNotEqual() throws Exception {
-        when(mFeatureFlags.associatedUserRefactorForWorkProfile()).thenReturn(true);
         InCallServiceFixture.setIgnoreOverrideAdapterFlag(true);
 
         // Receive incoming call via mPhoneAccountMultiUser
@@ -702,9 +701,6 @@ public class BasicCallTests extends TelecomSystemTest {
         mInCallServiceFixtureX.mInCallAdapter.setAudioRoute(CallAudioState.ROUTE_EARPIECE, null);
         waitForHandlerAction(mTelecomSystem.getCallsManager().getCallAudioManager()
                 .getCallAudioRouteAdapter().getAdapterHandler(), TEST_TIMEOUT);
-        // setSpeakerPhoneOn(false) gets called once during the call initiation phase
-        verify(audioManager, timeout(TEST_TIMEOUT).atLeast(1))
-                .clearCommunicationDevice();
 
         mConnectionServiceFixtureA.
                 sendSetDisconnected(outgoing.mConnectionId, DisconnectCause.REMOTE);
@@ -717,6 +713,9 @@ public class BasicCallTests extends TelecomSystemTest {
                 .abandonAudioFocusForCall();
         verify(audioManager, timeout(TEST_TIMEOUT).atLeastOnce())
                 .setMode(AudioManager.MODE_NORMAL);
+        // setSpeakerPhoneOn(false) gets called once the call ends.
+        verify(audioManager, timeout(TEST_TIMEOUT).atLeast(1))
+                .clearCommunicationDevice();
     }
 
     private void rapidFire(Runnable... tasks) {
diff --git a/tests/src/com/android/server/telecom/tests/BlockedNumbersUtilTests.java b/tests/src/com/android/server/telecom/tests/BlockedNumbersUtilTests.java
index 57aee62ba..651dee99f 100644
--- a/tests/src/com/android/server/telecom/tests/BlockedNumbersUtilTests.java
+++ b/tests/src/com/android/server/telecom/tests/BlockedNumbersUtilTests.java
@@ -20,12 +20,15 @@ import static org.junit.Assert.assertFalse;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.isNull;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.app.Notification;
 import android.app.NotificationManager;
+import android.content.Context;
 import android.os.UserHandle;
 
 import androidx.test.filters.SmallTest;
@@ -44,23 +47,33 @@ public class BlockedNumbersUtilTests extends TelecomTestCase {
     @Before
     public void setUp() throws Exception {
         super.setUp();
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
     }
 
     @SmallTest
     @Test
     public void testPostNotification() {
-        BlockedNumbersUtil.updateEmergencyCallNotification(mContext, true);
+        BlockedNumbersUtil.updateEmergencyCallNotification(mContext, true, mFeatureFlags);
         NotificationManager mgr = mComponentContextFixture.getNotificationManager();
-        verify(mgr).notifyAsUser(isNull(), anyInt(), any(Notification.class),
-                any(UserHandle.class));
+        Context userContext = mock(Context.class);
+        when(mContext.createContextAsUser(any(UserHandle.class), eq(0)))
+                .thenReturn(userContext);
+        when(userContext.getSystemService(eq(NotificationManager.class)))
+                .thenReturn(mgr);
+        verify(mgr).notify(isNull(), anyInt(), any(Notification.class));
     }
 
     @SmallTest
     @Test
     public void testDismissNotification() {
-        BlockedNumbersUtil.updateEmergencyCallNotification(mContext, false);
+        BlockedNumbersUtil.updateEmergencyCallNotification(mContext, false, mFeatureFlags);
         NotificationManager mgr = mComponentContextFixture.getNotificationManager();
-        verify(mgr).cancelAsUser(isNull(), anyInt(), any(UserHandle.class));
+        Context userContext = mock(Context.class);
+        when(mContext.createContextAsUser(any(UserHandle.class), eq(0)))
+                .thenReturn(userContext);
+        when(userContext.getSystemService(eq(NotificationManager.class)))
+                .thenReturn(mgr);
+        verify(mgr).cancel(isNull(), anyInt());
     }
 
     /**
diff --git a/tests/src/com/android/server/telecom/tests/BluetoothDeviceManagerTest.java b/tests/src/com/android/server/telecom/tests/BluetoothDeviceManagerTest.java
index 9f97bbe3b..e7f67d433 100644
--- a/tests/src/com/android/server/telecom/tests/BluetoothDeviceManagerTest.java
+++ b/tests/src/com/android/server/telecom/tests/BluetoothDeviceManagerTest.java
@@ -18,6 +18,7 @@ package com.android.server.telecom.tests;
 
 import static android.media.AudioDeviceInfo.TYPE_BUILTIN_SPEAKER;
 
+import static com.android.server.telecom.CallAudioRouteAdapter.BT_DEVICE_REMOVED;
 import static com.android.server.telecom.CallAudioRouteAdapter.SWITCH_BASELINE_ROUTE;
 import static com.android.server.telecom.CallAudioRouteController.INCLUDE_BLUETOOTH_IN_BASELINE;
 
@@ -48,6 +49,7 @@ import android.media.AudioManager;
 import android.os.Bundle;
 import android.os.Parcel;
 import android.telecom.CallAudioState;
+import android.util.Pair;
 
 import androidx.test.filters.SmallTest;
 
@@ -55,6 +57,7 @@ import com.android.server.telecom.AudioRoute;
 import com.android.server.telecom.CallAudioCommunicationDeviceTracker;
 import com.android.server.telecom.CallAudioRouteAdapter;
 import com.android.server.telecom.CallAudioRouteController;
+import com.android.server.telecom.PendingAudioRoute;
 import com.android.server.telecom.bluetooth.BluetoothDeviceManager;
 import com.android.server.telecom.bluetooth.BluetoothRouteManager;
 import com.android.server.telecom.bluetooth.BluetoothStateReceiver;
@@ -88,6 +91,7 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
     @Mock AudioDeviceInfo mSpeakerInfo;
     @Mock Executor mExecutor;
     @Mock CallAudioRouteController mCallAudioRouteController;
+    @Mock PendingAudioRoute mPendingAudioRoute;
     @Mock CallAudioState mCallAudioState;
 
     BluetoothDeviceManager mBluetoothDeviceManager;
@@ -126,6 +130,9 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                 mCommunicationDeviceTracker, mFeatureFlags);
         mBluetoothDeviceManager.setBluetoothRouteManager(mRouteManager);
         mBluetoothDeviceManager.setCallAudioRouteAdapter(mCallAudioRouteController);
+        when(mCallAudioRouteController.getPendingAudioRoute()).thenReturn(mPendingAudioRoute);
+        when(mCallAudioRouteController.getCurrentCallAudioState()).thenReturn(mCallAudioState);
+        when(mCallAudioState.getRoute()).thenReturn(CallAudioState.ROUTE_EARPIECE);
         mCommunicationDeviceTracker.setBluetoothRouteManager(mRouteManager);
 
         mockAudioManager = mContext.getSystemService(AudioManager.class);
@@ -139,6 +146,7 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
 
         receiverUnderTest = new BluetoothStateReceiver(mBluetoothDeviceManager,
                 mRouteManager, mCommunicationDeviceTracker, mFeatureFlags);
+        receiverUnderTest.setCallAudioRouteAdapter(mCallAudioRouteController);
 
         mBluetoothDeviceManager.setHeadsetServiceForTesting(mBluetoothHeadset);
         mBluetoothDeviceManager.setHearingAidServiceForTesting(mBluetoothHearingAid);
@@ -149,8 +157,7 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         verify(mBluetoothLeAudio).registerCallback(any(), leAudioCallbacksTest.capture());
 
         when(mSpeakerInfo.getType()).thenReturn(TYPE_BUILTIN_SPEAKER);
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(false);
-        when(mFeatureFlags.useRefactoredAudioRouteSwitching()).thenReturn(false);
+        when(mFeatureFlags.keepBluetoothDevicesCacheUpdated()).thenReturn(true);
     }
 
     @Override
@@ -177,6 +184,7 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
     public void testAddDeviceFailsWhenServicesAreNull() {
         mBluetoothDeviceManager.setHeadsetServiceForTesting(null);
         mBluetoothDeviceManager.setHearingAidServiceForTesting(null);
+        mBluetoothDeviceManager.setLeAudioServiceForTesting(null);
 
         receiverUnderTest.onReceive(mContext,
                 buildConnectionActionIntent(BluetoothHeadset.STATE_CONNECTED, device1,
@@ -311,7 +319,6 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testHandleAudioRefactoringServiceDisconnectedWhileBluetooth() {
-        when(mFeatureFlags.skipBaselineSwitchWhenRouteNotBluetooth()).thenReturn(true);
         Map<AudioRoute, BluetoothDevice> btRoutes = new HashMap<>();
         when(mCallAudioRouteController.getBluetoothRoutes()).thenReturn(btRoutes);
         when(mCallAudioRouteController.getCurrentCallAudioState()).thenReturn(mCallAudioState);
@@ -327,7 +334,6 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testHandleAudioRefactoringServiceDisconnectedWhileSpeaker() {
-        when(mFeatureFlags.skipBaselineSwitchWhenRouteNotBluetooth()).thenReturn(true);
         Map<AudioRoute, BluetoothDevice> btRoutes = new HashMap<>();
         when(mCallAudioRouteController.getBluetoothRoutes()).thenReturn(btRoutes);
         when(mCallAudioRouteController.getCurrentCallAudioState()).thenReturn(mCallAudioState);
@@ -353,12 +359,19 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                 buildConnectionActionIntent(BluetoothHeadset.STATE_CONNECTED, device2,
                         BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID));
         serviceListenerUnderTest.onServiceDisconnected(BluetoothProfile.HEADSET);
+        receiverUnderTest.onReceive(mContext,
+                buildConnectionActionIntent(BluetoothHeadset.STATE_DISCONNECTED, device1,
+                        BluetoothDeviceManager.DEVICE_TYPE_HEADSET));
+        receiverUnderTest.onReceive(mContext,
+                buildConnectionActionIntent(BluetoothHeadset.STATE_DISCONNECTED, device3,
+                        BluetoothDeviceManager.DEVICE_TYPE_HEADSET));
 
         verify(mRouteManager).onActiveDeviceChanged(isNull(),
                 eq(BluetoothDeviceManager.DEVICE_TYPE_HEADSET));
-        verify(mRouteManager).onDeviceLost(device1.getAddress());
-        verify(mRouteManager).onDeviceLost(device3.getAddress());
-        verify(mRouteManager, never()).onDeviceLost(device2.getAddress());
+        mCallAudioRouteController.sendMessageWithSessionInfo(
+                eq(BT_DEVICE_REMOVED), eq(AudioRoute.TYPE_BLUETOOTH_SCO), eq(device1));
+        mCallAudioRouteController.sendMessageWithSessionInfo(
+                eq(BT_DEVICE_REMOVED), eq(AudioRoute.TYPE_BLUETOOTH_SCO), eq(device3));
         assertNull(mBluetoothDeviceManager.getBluetoothHeadset());
         assertEquals(1, mBluetoothDeviceManager.getNumConnectedDevices());
     }
@@ -376,12 +389,14 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                 buildConnectionActionIntent(BluetoothHeadset.STATE_CONNECTED, device2,
                         BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID));
         serviceListenerUnderTest.onServiceDisconnected(BluetoothProfile.HEARING_AID);
+        receiverUnderTest.onReceive(mContext,
+                buildConnectionActionIntent(BluetoothHeadset.STATE_DISCONNECTED, device2,
+                        BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID));
 
         verify(mRouteManager).onActiveDeviceChanged(isNull(),
                 eq(BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID));
-        verify(mRouteManager).onDeviceLost(device2.getAddress());
-        verify(mRouteManager, never()).onDeviceLost(device1.getAddress());
-        verify(mRouteManager, never()).onDeviceLost(device3.getAddress());
+        mCallAudioRouteController.sendMessageWithSessionInfo(
+                eq(BT_DEVICE_REMOVED), eq(AudioRoute.TYPE_BLUETOOTH_HA), eq(device2));
         assertNull(mBluetoothDeviceManager.getBluetoothHearingAid());
         assertEquals(2, mBluetoothDeviceManager.getNumConnectedDevices());
     }
@@ -399,12 +414,14 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                 buildConnectionActionIntent(BluetoothLeAudio.STATE_CONNECTED, device5,
                         BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
         serviceListenerUnderTest.onServiceDisconnected(BluetoothProfile.LE_AUDIO);
+        receiverUnderTest.onReceive(mContext,
+                buildConnectionActionIntent(BluetoothHeadset.STATE_DISCONNECTED, device5,
+                        BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
 
         verify(mRouteManager).onActiveDeviceChanged(isNull(),
                 eq(BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
-        verify(mRouteManager).onDeviceLost(device5.getAddress());
-        verify(mRouteManager, never()).onDeviceLost(device1.getAddress());
-        verify(mRouteManager, never()).onDeviceLost(device3.getAddress());
+        mCallAudioRouteController.sendMessageWithSessionInfo(
+                eq(BT_DEVICE_REMOVED), eq(AudioRoute.TYPE_BLUETOOTH_LE), eq(device5));
         assertNull(mBluetoothDeviceManager.getLeAudioService());
         assertEquals(2, mBluetoothDeviceManager.getNumConnectedDevices());
     }
@@ -421,9 +438,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         activeDeviceChangedIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, device2);
         receiverUnderTest.onReceive(mContext, activeDeviceChangedIntent);
 
-        verify(mRouteManager).onActiveDeviceChanged(device2,
-                BluetoothDeviceManager.DEVICE_TYPE_HEARING_AID);
-        verify(mRouteManager, never()).sendMessage(BluetoothRouteManager.BT_AUDIO_IS_ON);
+        verify(mCallAudioRouteController).updateActiveBluetoothDevice(
+                eq(new Pair<>(AudioRoute.TYPE_BLUETOOTH_HA, device2.getAddress())));
     }
 
     @SmallTest
@@ -438,9 +454,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         activeDeviceChangedIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, device5);
         receiverUnderTest.onReceive(mContext, activeDeviceChangedIntent);
 
-        verify(mRouteManager).onActiveDeviceChanged(device5,
-                        BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO);
-        verify(mRouteManager, never()).sendMessage(BluetoothRouteManager.BT_AUDIO_IS_ON);
+        verify(mCallAudioRouteController).updateActiveBluetoothDevice(
+                eq(new Pair<>(AudioRoute.TYPE_BLUETOOTH_LE, device5.getAddress())));
     }
 
     @SmallTest
@@ -451,7 +466,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                         BluetoothDeviceManager.DEVICE_TYPE_HEADSET));
         when(mAdapter.setActiveDevice(nullable(BluetoothDevice.class),
                     eq(BluetoothAdapter.ACTIVE_DEVICE_ALL))).thenReturn(true);
-        mBluetoothDeviceManager.connectAudio(device1.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device1,
+                AudioRoute.TYPE_BLUETOOTH_SCO, false);
         verify(mAdapter).setActiveDevice(eq(device1),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL));
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
@@ -481,7 +497,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         when(mockAudioManager.setCommunicationDevice(eq(mockAudioDeviceInfo)))
                 .thenReturn(true);
 
-        mBluetoothDeviceManager.connectAudio(device5.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device5,
+                AudioRoute.TYPE_BLUETOOTH_HA, false);
         verify(mAdapter).setActiveDevice(device5, BluetoothAdapter.ACTIVE_DEVICE_ALL);
         verify(mBluetoothHeadset, never()).connectAudio();
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
@@ -492,7 +509,7 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
 
         when(mockAudioManager.getCommunicationDevice()).thenReturn(mockAudioDeviceInfo);
         mBluetoothDeviceManager.disconnectAudio();
-        verify(mockAudioManager, atLeastOnce()).clearCommunicationDevice();
+        verify(mBluetoothHeadset).disconnectAudio();
     }
 
     @SmallTest
@@ -516,7 +533,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         when(mockAudioManager.setCommunicationDevice(mockAudioDeviceInfo))
                        .thenReturn(true);
 
-        mBluetoothDeviceManager.connectAudio(device5.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device5,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter).setActiveDevice(device5, BluetoothAdapter.ACTIVE_DEVICE_ALL);
         verify(mBluetoothHeadset, never()).connectAudio();
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
@@ -528,7 +546,7 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                 BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
 
         mBluetoothDeviceManager.disconnectAudio();
-        verify(mockAudioManager, atLeastOnce()).clearCommunicationDevice();
+        verify(mBluetoothHeadset).disconnectAudio();
     }
 
     @SmallTest
@@ -545,7 +563,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         leAudioCallbacksTest.getValue().onGroupNodeAdded(device6, 1);
         when(mAdapter.setActiveDevice(nullable(BluetoothDevice.class),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_ALL))).thenReturn(true);
-        mBluetoothDeviceManager.connectAudio(device5.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device5,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter).setActiveDevice(device5, BluetoothAdapter.ACTIVE_DEVICE_ALL);
         verify(mBluetoothHeadset, never()).connectAudio();
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
@@ -560,14 +579,14 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                 buildConnectionActionIntent(BluetoothHeadset.STATE_DISCONNECTED, device5,
                         BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
 
-        mBluetoothDeviceManager.connectAudio(device6.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device6,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter).setActiveDevice(device6, BluetoothAdapter.ACTIVE_DEVICE_ALL);
     }
 
     @SmallTest
     @Test
     public void testConnectMultipleLeAudioDevices() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         receiverUnderTest.setIsInCall(true);
         receiverUnderTest.onReceive(mContext,
                 buildConnectionActionIntent(BluetoothHeadset.STATE_CONNECTED, device1,
@@ -588,64 +607,26 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         devices.add(leAudioDevice1);
         devices.add(leAudioDevice2);
 
-        when(mockAudioManager.getAvailableCommunicationDevices())
-                .thenReturn(devices);
-        when(mockAudioManager.setCommunicationDevice(any(AudioDeviceInfo.class)))
-                .thenReturn(true);
-
         // Connect LE audio device
-        mBluetoothDeviceManager.connectAudio(device1.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device1,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter).setActiveDevice(device1, BluetoothAdapter.ACTIVE_DEVICE_ALL);
         verify(mBluetoothHeadset, never()).connectAudio();
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL));
-        // Verify that we set the communication device for device 1
-        verify(mockAudioManager).setCommunicationDevice(leAudioDevice1);
 
         // Change active device to other LE audio device
         receiverUnderTest.onReceive(mContext, buildActiveDeviceChangeActionIntent(device2,
                 BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
 
-        // Verify call to clearLeAudioCommunicationDevice
-        verify(mRouteManager).onAudioLost(eq(DEVICE_ADDRESS_1));
-        // Verify that we set the communication device for device2
-        verify(mockAudioManager).setCommunicationDevice(leAudioDevice2);
-    }
-
-    @SmallTest
-    @Test
-    public void testClearCommunicationDeviceOnActiveDeviceChange() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
-        receiverUnderTest.setIsInCall(true);
-
-        List<AudioDeviceInfo> devices = new ArrayList<>();
-        AudioDeviceInfo leAudioDevice1 = createMockAudioDeviceInfo(device1.getAddress(),
-                AudioDeviceInfo.TYPE_BLE_HEADSET);
-        devices.add(leAudioDevice1);
-
-        when(mockAudioManager.getAvailableCommunicationDevices())
-                .thenReturn(devices);
-        when(mockAudioManager.setCommunicationDevice(any(AudioDeviceInfo.class)))
-                .thenReturn(true);
-
-        // Pretend that the speaker device is currently the requested device set for communication.
-        // This test ensures that the set/clear communication logic for audio switching in/out of BT
-        // is properly working when the receiver processes an active device change intent.
-        mCommunicationDeviceTracker.setTestCommunicationDevice(TYPE_BUILTIN_SPEAKER);
-
-        // Notify that LE audio device has been turned on
-        receiverUnderTest.onReceive(mContext, buildActiveDeviceChangeActionIntent(device1,
-                BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
-        // Verify call to clear speaker communication device
-        verify(mockAudioManager).clearCommunicationDevice();
-        // Verify that LE audio communication device was set after clearing the speaker device
-        verify(mockAudioManager).setCommunicationDevice(leAudioDevice1);
+        // active device changed to that LE audio device
+        verify(mCallAudioRouteController).updateActiveBluetoothDevice(
+                eq(new Pair<>(AudioRoute.TYPE_BLUETOOTH_LE, device2.getAddress())));
     }
 
     @SmallTest
     @Test
     public void testConnectDualModeEarbud() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         receiverUnderTest.setIsInCall(true);
 
         // LE Audio earbuds connected
@@ -687,13 +668,12 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         // TEST 1: LE Audio preferred for DUPLEX
         when(mAdapter.getPreferredAudioProfiles(device5)).thenReturn(leAudioPreferred);
         when(mAdapter.getPreferredAudioProfiles(device6)).thenReturn(leAudioPreferred);
-        mBluetoothDeviceManager.connectAudio(device5.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device5,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter, times(1)).setActiveDevice(device5, BluetoothAdapter.ACTIVE_DEVICE_ALL);
         verify(mBluetoothHeadset, never()).connectAudio();
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL));
-        verify(mockAudioManager).setCommunicationDevice(mockAudioDevice5Info);
-
         when(mAdapter.getActiveDevices(eq(BluetoothProfile.LE_AUDIO)))
                 .thenReturn(Arrays.asList(device5, device6));
 
@@ -704,12 +684,12 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
                         BluetoothDeviceManager.DEVICE_TYPE_LE_AUDIO));
         leAudioCallbacksTest.getValue().onGroupNodeRemoved(device5, 1);
 
-        mBluetoothDeviceManager.connectAudio(device6.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device6,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter).setActiveDevice(device6, BluetoothAdapter.ACTIVE_DEVICE_ALL);
         verify(mBluetoothHeadset, never()).connectAudio();
         verify(mAdapter, never()).setActiveDevice(nullable(BluetoothDevice.class),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL));
-        verify(mockAudioManager, times(1)).clearCommunicationDevice();
 
         // Reconnect other LE Audio earbud
         devices.add(mockAudioDevice5Info);
@@ -720,7 +700,6 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
 
         // Disconnects audio
         mBluetoothDeviceManager.disconnectAudio();
-        verify(mockAudioManager, times(2)).clearCommunicationDevice();
         verify(mBluetoothHeadset, times(1)).disconnectAudio();
 
         // TEST 2: HFP preferred for DUPLEX
@@ -728,7 +707,8 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
         when(mAdapter.getPreferredAudioProfiles(device6)).thenReturn(hfpPreferred);
         when(mAdapter.setActiveDevice(nullable(BluetoothDevice.class),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL))).thenReturn(true);
-        mBluetoothDeviceManager.connectAudio(device5.getAddress(), false);
+        mBluetoothDeviceManager.connectAudio(device5,
+                AudioRoute.TYPE_BLUETOOTH_LE, false);
         verify(mAdapter).setActiveDevice(device5, BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL);
         verify(mAdapter, times(1)).setActiveDevice(device5,
                 BluetoothAdapter.ACTIVE_DEVICE_ALL);
@@ -746,7 +726,6 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testClearHearingAidCommunicationDeviceWithFlag() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         assertClearHearingAidOrLeCommunicationDevice(true, AudioDeviceInfo.TYPE_HEARING_AID);
     }
 
@@ -759,7 +738,6 @@ public class BluetoothDeviceManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testClearLeAudioCommunicationDeviceWithFlag() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         assertClearHearingAidOrLeCommunicationDevice(true, AudioDeviceInfo.TYPE_BLE_HEADSET);
     }
 
diff --git a/tests/src/com/android/server/telecom/tests/BluetoothRouteManagerTest.java b/tests/src/com/android/server/telecom/tests/BluetoothRouteManagerTest.java
index 4913904d2..65fbada1b 100644
--- a/tests/src/com/android/server/telecom/tests/BluetoothRouteManagerTest.java
+++ b/tests/src/com/android/server/telecom/tests/BluetoothRouteManagerTest.java
@@ -17,6 +17,7 @@
 package com.android.server.telecom.tests;
 
 import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
@@ -35,6 +36,7 @@ import android.bluetooth.BluetoothLeAudio;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothStatusCodes;
 import android.content.ContentResolver;
+import android.content.Context;
 import android.media.AudioDeviceInfo;
 import android.os.Parcel;
 import android.telecom.Log;
@@ -47,6 +49,7 @@ import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.Timeouts;
 import com.android.server.telecom.bluetooth.BluetoothDeviceManager;
 import com.android.server.telecom.bluetooth.BluetoothRouteManager;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -159,7 +162,7 @@ public class BluetoothRouteManagerTest extends TelecomTestCase {
                 BluetoothRouteManager.AUDIO_OFF_STATE_NAME, null);
         setupConnectedDevices(new BluetoothDevice[]{DEVICE1}, null, null, null, null, null);
         when(mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                nullable(ContentResolver.class))).thenReturn(0L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(0L);
         when(mBluetoothHeadset.connectAudio()).thenReturn(BluetoothStatusCodes.ERROR_UNKNOWN);
         executeRoutingAction(sm, BluetoothRouteManager.CONNECT_BT, DEVICE1.getAddress());
         // Wait 3 times: for the first connection attempt, the retry attempt,
@@ -221,7 +224,7 @@ public class BluetoothRouteManagerTest extends TelecomTestCase {
         setupConnectedDevices(new BluetoothDevice[]{DEVICE1, DEVICE2}, null, null, null, null,
                               null);
         when(mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                nullable(ContentResolver.class))).thenReturn(0L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(0L);
         when(mBluetoothHeadset.connectAudio()).thenReturn(BluetoothStatusCodes.ERROR_UNKNOWN);
         executeRoutingAction(sm, BluetoothRouteManager.CONNECT_BT, DEVICE2.getAddress());
         // Wait 3 times: the first connection attempt is accounted for in executeRoutingAction,
@@ -255,7 +258,6 @@ public class BluetoothRouteManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testConnectBtWithoutAddress_SwitchingBtDeviceFlag() {
-        when(mFeatureFlags.resolveSwitchingBtDevicesComputation()).thenReturn(true);
         verifyConnectBtWithoutAddress();
     }
 
@@ -272,7 +274,7 @@ public class BluetoothRouteManagerTest extends TelecomTestCase {
         setupConnectedDevices(new BluetoothDevice[]{DEVICE1, DEVICE2}, null, null, null, null,
                 null);
         when(mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                nullable(ContentResolver.class))).thenReturn(0L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(0L);
         when(mBluetoothHeadset.connectAudio()).thenReturn(BluetoothStatusCodes.ERROR_UNKNOWN);
         executeRoutingAction(sm, BluetoothRouteManager.CONNECT_BT, null);
         // Wait 3 times: the first connection attempt is accounted for in executeRoutingAction,
@@ -284,13 +286,7 @@ public class BluetoothRouteManagerTest extends TelecomTestCase {
         waitForHandlerAction(sm.getHandler(), TEST_TIMEOUT);
         // We should not expect explicit connection attempt (BluetoothDeviceManager#connectAudio)
         // as the device is already "connected" as per how the state machine was initialized.
-        if (mFeatureFlags.resolveSwitchingBtDevicesComputation()) {
-            verify(mDeviceManager, never()).disconnectAudio();
-        } else {
-            // Legacy behavior
-            verifyConnectionAttempt(DEVICE1, 1);
-            verify(mDeviceManager, times(1)).disconnectAudio();
-        }
+        verify(mDeviceManager, never()).disconnectAudio();
         assertEquals(BluetoothRouteManager.AUDIO_CONNECTED_STATE_NAME_PREFIX
                         + ":" + DEVICE1.getAddress(),
                 sm.getCurrentState().getName());
@@ -370,9 +366,9 @@ public class BluetoothRouteManagerTest extends TelecomTestCase {
         when(mBluetoothAdapter.setActiveDevice(nullable(BluetoothDevice.class),
                 eq(BluetoothAdapter.ACTIVE_DEVICE_ALL))).thenReturn(true);
         when(mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                nullable(ContentResolver.class))).thenReturn(100000L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(100000L);
         when(mTimeoutsAdapter.getBluetoothPendingTimeoutMillis(
-                nullable(ContentResolver.class))).thenReturn(100000L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(100000L);
     }
 
     private void verifyConnectionAttempt(BluetoothDevice device, int numTimes) {
diff --git a/tests/src/com/android/server/telecom/tests/BluetoothRouteTransitionTests.java b/tests/src/com/android/server/telecom/tests/BluetoothRouteTransitionTests.java
index 004bcd3e5..18b14a695 100644
--- a/tests/src/com/android/server/telecom/tests/BluetoothRouteTransitionTests.java
+++ b/tests/src/com/android/server/telecom/tests/BluetoothRouteTransitionTests.java
@@ -39,6 +39,7 @@ import android.bluetooth.BluetoothLeAudio;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothStatusCodes;
 import android.content.ContentResolver;
+import android.content.Context;
 import android.telecom.Log;
 
 import androidx.test.filters.SmallTest;
@@ -49,6 +50,7 @@ import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.Timeouts;
 import com.android.server.telecom.bluetooth.BluetoothDeviceManager;
 import com.android.server.telecom.bluetooth.BluetoothRouteManager;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -415,9 +417,9 @@ public class BluetoothRouteTransitionTests extends TelecomTestCase {
         when(mDeviceManager.connectAudio(nullable(String.class), any(boolean.class)))
             .thenReturn(true);
         when(mTimeoutsAdapter.getRetryBluetoothConnectAudioBackoffMillis(
-                nullable(ContentResolver.class))).thenReturn(100000L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(100000L);
         when(mTimeoutsAdapter.getBluetoothPendingTimeoutMillis(
-                nullable(ContentResolver.class))).thenReturn(100000L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(100000L);
         BluetoothRouteManager sm = new BluetoothRouteManager(mContext,
                 new TelecomSystem.SyncRoot() { }, mDeviceManager,
                 mTimeoutsAdapter, mCommunicationDeviceTracker, mFeatureFlags,
diff --git a/tests/src/com/android/server/telecom/tests/CallAudioManagerTest.java b/tests/src/com/android/server/telecom/tests/CallAudioManagerTest.java
index d1a3eb6ce..4073bb537 100644
--- a/tests/src/com/android/server/telecom/tests/CallAudioManagerTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallAudioManagerTest.java
@@ -948,7 +948,6 @@ public class CallAudioManagerTest extends TelecomTestCase {
     }
 
     private void handleWaitForBtIcsBinding(Call call) {
-        when(mFlags.separatelyBindToBtIncallService()).thenReturn(true);
         CompletableFuture<Boolean> btBindingFuture = CompletableFuture.completedFuture(true);
         when(call.getBtIcsFuture()).thenReturn(btBindingFuture);
     }
diff --git a/tests/src/com/android/server/telecom/tests/CallAudioRouteControllerTest.java b/tests/src/com/android/server/telecom/tests/CallAudioRouteControllerTest.java
index f6f16863d..6cb647cf9 100644
--- a/tests/src/com/android/server/telecom/tests/CallAudioRouteControllerTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallAudioRouteControllerTest.java
@@ -46,6 +46,8 @@ import static com.android.server.telecom.CallAudioRouteAdapter.USER_SWITCH_SPEAK
 import static com.android.server.telecom.CallAudioRouteController.INCLUDE_BLUETOOTH_IN_BASELINE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -116,7 +118,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     private static final BluetoothDevice BLUETOOTH_DEVICE_1 =
             BluetoothRouteManagerTest.makeBluetoothDevice("00:00:00:00:00:01");
     private static final Set<BluetoothDevice> BLUETOOTH_DEVICES = new HashSet<>();
-    private static final int TEST_TIMEOUT = 500;
+    private static final int TEST_TIMEOUT = 1000;
 
     @Mock
     WiredHeadsetManager mWiredHeadsetManager;
@@ -200,9 +202,10 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         when(mBluetoothLeAudio.getConnectedGroupLeadDevice(anyInt()))
                 .thenReturn(BLUETOOTH_DEVICE_1);
         when(mAudioDeviceInfo.getAddress()).thenReturn(BT_ADDRESS_1);
-        mController = new CallAudioRouteController(mContext, mCallsManager, mAudioServiceFactory,
-                mAudioRouteFactory, mWiredHeadsetManager, mBluetoothRouteManager,
-                mockStatusBarNotifier, mFeatureFlags, mMockTelecomMetricsController);
+        mController = new CallAudioRouteController.Factory().create(mContext, mCallsManager,
+                mAudioServiceFactory, mAudioRouteFactory, mWiredHeadsetManager,
+                mBluetoothRouteManager, mockStatusBarNotifier, mFeatureFlags,
+                mMockTelecomMetricsController);
         mController.setAudioRouteFactory(mAudioRouteFactory);
         mController.setAudioManager(mAudioManager);
         mEarpieceRoute = new AudioRoute(AudioRoute.TYPE_EARPIECE, null, null);
@@ -212,12 +215,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         when(mCallAudioManager.getForegroundCall()).thenReturn(mCall);
         when(mCall.getVideoState()).thenReturn(VideoProfile.STATE_AUDIO_ONLY);
         when(mCall.getSupportedAudioRoutes()).thenReturn(CallAudioState.ROUTE_ALL);
-        when(mFeatureFlags.ignoreAutoRouteToWatchDevice()).thenReturn(false);
-        when(mFeatureFlags.useRefactoredAudioRouteSwitching()).thenReturn(true);
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(false);
-        when(mFeatureFlags.newAudioPathSpeakerBroadcastAndUnfocusedRouting()).thenReturn(false);
-        when(mFeatureFlags.fixUserRequestBaselineRouteVideoCall()).thenReturn(false);
-        when(mFeatureFlags.callAudioRoutingPerformanceImprovemenent()).thenReturn(true);
         BLUETOOTH_DEVICES.add(BLUETOOTH_DEVICE_1);
     }
 
@@ -287,7 +284,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testAudioRouteForPreferredDeviceStrategy() {
-        when(mFeatureFlags.updatePreferredAudioDeviceLogic()).thenReturn(true);
         mController.initialize();
         mController.sendMessageWithSessionInfo(SWITCH_FOCUS, RINGING_FOCUS, 0);
         waitForRouteActiveStateAndVerify(true);
@@ -306,7 +302,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testAudioRouteCommunicationDeviceSyncWithPreferredDeviceStrategy() {
-        when(mFeatureFlags.updatePreferredAudioDeviceLogic()).thenReturn(true);
         mController.initialize();
         // Set up tests so that the current communication device is different from the preferred
         // device for strategy.
@@ -332,9 +327,10 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
 
-        // For sanity, verify that routing falls back on earpiece if focus is switched to active
-        // again (we don't try to use the preferred device strategy).
-        mController.sendMessageWithSessionInfo(SWITCH_FOCUS, ACTIVE_FOCUS, 0);
+        // For sanity, verify that routing falls back on earpiece if we attempt to recalculate
+        // audio routing.
+        mController.sendMessageWithSessionInfo(USER_SWITCH_BASELINE_ROUTE,
+                CallAudioRouteController.INCLUDE_BLUETOOTH_IN_BASELINE);
         mController.sendMessageWithSessionInfo(SPEAKER_OFF);
         expectedState = new CallAudioState(false, CallAudioState.ROUTE_EARPIECE,
                 CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_SPEAKER, null,
@@ -420,6 +416,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @Test
     public void testVideoCallRouteToSpeaker() {
         when(mCall.getVideoState()).thenReturn(VideoProfile.STATE_BIDIRECTIONAL);
+        when(mCall.isActive()).thenReturn(true);
         mController.initialize();
         mController.sendMessageWithSessionInfo(SWITCH_FOCUS, ACTIVE_FOCUS, 0);
         // Verify that pending audio destination route is set to speaker. This will trigger pending
@@ -499,6 +496,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         assertTrue(mController.isActive());
 
         mController.sendMessageWithSessionInfo(SWITCH_FOCUS, NO_FOCUS, 0);
+        mController.sendMessageWithSessionInfo(BT_AUDIO_DISCONNECTED, 0, BLUETOOTH_DEVICE_1);
         // Ensure we tell the CallAudioManager that audio operations are done so that we can ensure
         // audio focus is relinquished.
         verify(mCallAudioManager, timeout(TEST_TIMEOUT)).notifyAudioOperationsComplete();
@@ -576,7 +574,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         expectedState = new CallAudioState(false, CallAudioState.ROUTE_EARPIECE,
                 CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_SPEAKER, null,
                 new HashSet<>());
-        verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+        verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
     }
 
@@ -592,6 +590,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
 
+        mController.sendMessageWithSessionInfo(USER_SWITCH_EARPIECE);
         mController.sendMessageWithSessionInfo(SPEAKER_OFF);
         expectedState = new CallAudioState(false, CallAudioState.ROUTE_EARPIECE,
                 CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_SPEAKER, null,
@@ -700,7 +699,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         expectedState = new CallAudioState(false, CallAudioState.ROUTE_WIRED_HEADSET,
                 CallAudioState.ROUTE_WIRED_HEADSET | CallAudioState.ROUTE_SPEAKER, null,
                 new HashSet<>());
-        verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+        verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
     }
 
@@ -740,7 +739,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         ArgumentCaptor<BroadcastReceiver> brCaptor = ArgumentCaptor.forClass(
                 BroadcastReceiver.class);
         ArgumentCaptor<IntentFilter> filterCaptor = ArgumentCaptor.forClass(IntentFilter.class);
-        verify(mContext, times(3)).registerReceiver(brCaptor.capture(), filterCaptor.capture());
+        verify(mContext, times(2)).registerReceiver(brCaptor.capture(), filterCaptor.capture());
         boolean foundValid = false;
         for (int ix = 0; ix < brCaptor.getAllValues().size(); ix++) {
             BroadcastReceiver receiver = brCaptor.getAllValues().get(ix);
@@ -833,7 +832,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testIgnoreAutoRouteToWatch() {
-        when(mFeatureFlags.ignoreAutoRouteToWatchDevice()).thenReturn(true);
         when(mBluetoothRouteManager.isWatch(any(BluetoothDevice.class))).thenReturn(true);
 
         mController.initialize();
@@ -869,13 +867,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         verifyDisconnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_SCO);
     }
 
-    @SmallTest
-    @Test
-    public void testConnectDisconnectScoDuringCallNoClear() {
-        when(mFeatureFlags.onlyClearCommunicationDeviceOnInactive()).thenReturn(true);
-        verifyConnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_SCO);
-        verifyDisconnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_SCO);
-    }
 
     @SmallTest
     @Test
@@ -886,15 +877,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         verifyDisconnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_LE);
     }
 
-    @SmallTest
-    @Test
-    public void testConnectAndDisconnectLeDeviceDuringCallNoClear() {
-        when(mFeatureFlags.onlyClearCommunicationDeviceOnInactive()).thenReturn(true);
-        when(mBluetoothLeAudio.getConnectedGroupLeadDevice(anyInt()))
-                .thenReturn(BLUETOOTH_DEVICE_1);
-        verifyConnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_LE);
-        verifyDisconnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_LE);
-    }
 
     @SmallTest
     @Test
@@ -903,13 +885,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         verifyDisconnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_HA);
     }
 
-    @SmallTest
-    @Test
-    public void testConnectAndDisconnectHearingAidDuringCallNoClear() {
-        when(mFeatureFlags.onlyClearCommunicationDeviceOnInactive()).thenReturn(true);
-        verifyConnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_HA);
-        verifyDisconnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_HA);
-    }
 
     @SmallTest
     @Test
@@ -1008,7 +983,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testRouteFromBtSwitchInRingingSelected() {
-        when(mFeatureFlags.ignoreAutoRouteToWatchDevice()).thenReturn(true);
         when(mBluetoothRouteManager.isWatch(any(BluetoothDevice.class))).thenReturn(true);
         when(mBluetoothRouteManager.isInbandRingEnabled(eq(AudioRoute.TYPE_BLUETOOTH_SCO),
                 eq(BLUETOOTH_DEVICE_1))).thenReturn(false);
@@ -1099,7 +1073,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testMimicVoiceDialWithBt() {
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(true);
         mController.initialize();
         mController.setActive(true);
 
@@ -1130,7 +1103,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testTransactionalCallBtConnectingAndSwitchCallEndpoint() {
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(true);
         mController.initialize();
         mController.setActive(true);
 
@@ -1164,7 +1136,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @Test
     @SmallTest
     public void testBluetoothRouteToActiveDevice() {
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(true);
         // Connect first BT device.
         verifyConnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_SCO);
         // Connect another BT device.
@@ -1218,7 +1189,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @Test
     @SmallTest
     public void verifyRouteReinitializedAfterCallEnd() {
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(true);
         mController.initialize();
         mController.setActive(true);
 
@@ -1244,7 +1214,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @Test
     @SmallTest
     public void testUserSwitchBaselineRouteVideoCall() {
-        when(mFeatureFlags.fixUserRequestBaselineRouteVideoCall()).thenReturn(true);
         mController.initialize();
         mController.setActive(true);
         // Set capabilities for video call.
@@ -1276,14 +1245,13 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         expectedState = new CallAudioState(false, CallAudioState.ROUTE_SPEAKER,
                 CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_SPEAKER, null,
                 new HashSet<>());
-        verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+        verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
     }
 
     @Test
     @SmallTest
     public void testRouteToWatchWhenCallAnsweredOnWatch_MultipleBtDevices() {
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(true);
         // Connect first BT device.
         verifyConnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_SCO);
         // Connect another BT device.
@@ -1372,7 +1340,6 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
     @Test
     @SmallTest
     public void testActiveDevicePresentRoutesOnCurrentActive() {
-        when(mFeatureFlags.resolveActiveBtRoutingAndBtTimingIssue()).thenReturn(true);
         // Connect first BT device.
         verifyConnectBluetoothDevice(AudioRoute.TYPE_BLUETOOTH_SCO);
         // Connect another BT device.
@@ -1494,6 +1461,123 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         verify(mBluetoothDeviceManager, timeout(TEST_TIMEOUT).times(0)).disconnectSco();
     }
 
+    @Test
+    @SmallTest
+    public void testClearPendingMessages() {
+        mController.initialize();
+
+        mController.sendMessageWithSessionInfo(SWITCH_FOCUS, ACTIVE_FOCUS, 0);
+        waitForHandlerAction(mController.getAdapterHandler(), TEST_TIMEOUT);
+        assertTrue(mController.isActive());
+        CallAudioState expectedState = new CallAudioState(false, CallAudioState.ROUTE_EARPIECE,
+                CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_SPEAKER, null,
+                new HashSet<>());
+        verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+                any(CallAudioState.class), eq(expectedState));
+
+        // Mock testing for pending audio route. This will initialize the pending audio route with
+        // initialized orig + dest routes.
+        BluetoothDevice scoDevice =
+                BluetoothRouteManagerTest.makeBluetoothDevice("00:00:00:00:00:03");
+        mController.sendMessageWithSessionInfo(BT_DEVICE_ADDED, AudioRoute.TYPE_BLUETOOTH_SCO,
+                BLUETOOTH_DEVICE_1);
+        mController.sendMessageWithSessionInfo(BT_DEVICE_ADDED, AudioRoute.TYPE_BLUETOOTH_SCO,
+                scoDevice);
+        BLUETOOTH_DEVICES.add(scoDevice);
+        expectedState = new CallAudioState(false, CallAudioState.ROUTE_EARPIECE,
+                CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_BLUETOOTH
+                        | CallAudioState.ROUTE_SPEAKER, null, BLUETOOTH_DEVICES);
+        verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+                any(CallAudioState.class), eq(expectedState));
+
+        // Add pending BT_AUDIO_DISCONNECTED msg and verify it's removed when we get
+        // BT_AUDIO_CONNECTED.
+        mController.getPendingAudioRoute().addMessage(BT_AUDIO_DISCONNECTED, BT_ADDRESS_1);
+        mController.getPendingAudioRoute().addMessage(SPEAKER_OFF, null);
+        mController.sendMessageWithSessionInfo(BT_AUDIO_CONNECTED, 0, BLUETOOTH_DEVICE_1);
+        mController.overrideIsPending(true);
+        waitForHandlerAction(mController.getAdapterHandler(), TEST_TIMEOUT);
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(BT_AUDIO_DISCONNECTED, BT_ADDRESS_1)));
+        // Verify the speaker off message was cleared as well and the status bar notifier was
+        // invoked.
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(SPEAKER_OFF, null)));
+        verify(mockStatusBarNotifier, timeout(TEST_TIMEOUT)).notifySpeakerphone(anyBoolean());
+
+        // Add pending BT_AUDIO_CONNECTED msg and verify it's removed when we get
+        // BT_AUDIO_DISCONNECTED.
+        mController.getPendingAudioRoute().addMessage(BT_AUDIO_CONNECTED, BT_ADDRESS_1);
+        mController.sendMessageWithSessionInfo(BT_AUDIO_DISCONNECTED, 0, BLUETOOTH_DEVICE_1);
+        waitForHandlerAction(mController.getAdapterHandler(), TEST_TIMEOUT);
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(BT_AUDIO_CONNECTED, BT_ADDRESS_1)));
+
+        // Verify the same for SPEAKER_ON that SPEAKER_OFF and BT_AUDIO_DISCONNECTED messages are
+        // cleared
+        mController.getPendingAudioRoute().addMessage(BT_AUDIO_DISCONNECTED, BT_ADDRESS_1);
+        mController.getPendingAudioRoute().addMessage(BT_AUDIO_DISCONNECTED,
+                scoDevice.getAddress());
+        mController.getPendingAudioRoute().addMessage(SPEAKER_OFF, null);
+        mController.sendMessageWithSessionInfo(SPEAKER_ON);
+        waitForHandlerAction(mController.getAdapterHandler(), TEST_TIMEOUT);
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(BT_AUDIO_DISCONNECTED, BT_ADDRESS_1)));
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(BT_AUDIO_DISCONNECTED, scoDevice.getAddress())));
+        // Verify the speaker off message was cleared as well and the status bar notifier was
+        // invoked.
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(SPEAKER_OFF, null)));
+
+        // Verify that for SPEAKER_OFF, we clear the SPEAKER_ON pending message
+        mController.getPendingAudioRoute().addMessage(SPEAKER_ON, null);
+        mController.sendMessageWithSessionInfo(SPEAKER_OFF);
+        waitForHandlerAction(mController.getAdapterHandler(), TEST_TIMEOUT);
+        assertFalse(mController.getPendingAudioRoute().getPendingMessages().contains(
+                new Pair<>(SPEAKER_ON, null)));
+        BLUETOOTH_DEVICES.remove(scoDevice);
+    }
+
+    @Test
+    @SmallTest
+    public void testAddAudioRoutesDynamic() {
+        AudioRoute.Factory audioRouteFactory = new AudioRoute.Factory() {
+            @Override
+            public AudioRoute create(@AudioRoute.AudioRouteType int type, String bluetoothAddress,
+                    AudioManager audioManager) {
+                if (mOverrideSpeakerToBus && type == AudioRoute.TYPE_SPEAKER) {
+                    type = AudioRoute.TYPE_BUS;
+                }
+                // Purposely return null to mimic audio routes not being created upon
+                // initialization.
+                return null;
+            }
+        };
+        mController.setAudioRouteFactory(audioRouteFactory);
+        mController.initialize();
+        // Verify that the earpiece/speaker routes aren't created upon initialization of the
+        // controller.
+        assertNull(mController.getAudioRouteForTesting(AudioRoute.TYPE_SPEAKER));
+        assertNull(mController.getAudioRouteForTesting(AudioRoute.TYPE_EARPIECE));
+
+        // Set up the AudioDeviceCallback to signal to the controller of the newly added devices
+        // (earpiece + speaker).
+        CallAudioRouteController.AudioRoutesCallback callback = mController
+                .getAudioRoutesCallback();
+        AudioDeviceInfo earpieceDeviceInfo = mock(AudioDeviceInfo.class);
+        when(earpieceDeviceInfo.getType()).thenReturn(AudioDeviceInfo.TYPE_BUILTIN_EARPIECE);
+        AudioDeviceInfo speakerDeviceInfo = mock(AudioDeviceInfo.class);
+        when(speakerDeviceInfo.getType()).thenReturn(AudioDeviceInfo.TYPE_BUILTIN_SPEAKER);
+
+        // Reset the audio route factory so that the route creation can be successful now.
+        mController.setAudioRouteFactory(mAudioRouteFactory);
+        callback.onAudioDevicesAdded(new AudioDeviceInfo[] {earpieceDeviceInfo, speakerDeviceInfo});
+        // Verify that the earpiece/speaker routes are created this time around.
+        assertNotNull(mController.getAudioRouteForTesting(AudioRoute.TYPE_SPEAKER));
+        assertNotNull(mController.getAudioRouteForTesting(AudioRoute.TYPE_EARPIECE));
+    }
+
     private void verifyConnectBluetoothDevice(int audioType) {
         mController.initialize();
         mController.setActive(true);
@@ -1544,17 +1628,13 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         if (audioType == AudioRoute.TYPE_BLUETOOTH_SCO) {
             verify(mBluetoothDeviceManager, timeout(TEST_TIMEOUT)).disconnectSco();
         } else {
-            if (mFeatureFlags.onlyClearCommunicationDeviceOnInactive()) {
-                verify(mAudioManager, timeout(TEST_TIMEOUT).times(2))
-                        .setCommunicationDevice(any(AudioDeviceInfo.class));
-                // Don't use a timeout here because that will cause the test to pause for a long
-                // period of time to verify; the previous verify has a timeout on it, so it will
-                // have already waited for any AudioManager invocations to take place.  Any
-                // potential clear would have happened by now.
-                verify(mAudioManager, never()).clearCommunicationDevice();
-            } else {
-                verify(mAudioManager, timeout(TEST_TIMEOUT)).clearCommunicationDevice();
-            }
+            verify(mAudioManager, timeout(TEST_TIMEOUT).times(2))
+                    .setCommunicationDevice(any(AudioDeviceInfo.class));
+            // Don't use a timeout here because that will cause the test to pause for a long
+            // period of time to verify; the previous verify has a timeout on it, so it will
+            // have already waited for any AudioManager invocations to take place.  Any
+            // potential clear would have happened by now.
+            verify(mAudioManager, never()).clearCommunicationDevice();
         }
         verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
@@ -1588,7 +1668,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
             expectedState = new CallAudioState(false, CallAudioState.ROUTE_SPEAKER,
                     CallAudioState.ROUTE_WIRED_HEADSET | CallAudioState.ROUTE_SPEAKER, null,
                     new HashSet<>());
-            verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+            verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                     any(CallAudioState.class), eq(expectedState));
 
             // Verify speaker turned off from turning off speaker
@@ -1598,7 +1678,7 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
             expectedState = new CallAudioState(false, CallAudioState.ROUTE_WIRED_HEADSET,
                     CallAudioState.ROUTE_WIRED_HEADSET | CallAudioState.ROUTE_SPEAKER, null,
                     new HashSet<>());
-            verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+            verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                     any(CallAudioState.class), eq(expectedState));
         }
 
@@ -1607,17 +1687,17 @@ public class CallAudioRouteControllerTest extends TelecomTestCase {
         expectedState = new CallAudioState(false, expectedAudioType,
                 CallAudioState.ROUTE_EARPIECE | CallAudioState.ROUTE_SPEAKER, null,
                 new HashSet<>());
-        verify(mCallsManager, timeout(TEST_TIMEOUT)).onCallAudioStateChanged(
+        verify(mCallsManager, timeout(TEST_TIMEOUT).atLeastOnce()).onCallAudioStateChanged(
                 any(CallAudioState.class), eq(expectedState));
     }
 
     private void waitForRouteActiveStateAndVerify(boolean expectActive) {
         try {
             if (expectActive) {
-                mController.getAudioActiveCompleteLatch().await(TEST_TIMEOUT,
+                mController.getAudioActiveCompleteLatch().await(TEST_TIMEOUT * 2,
                         TimeUnit.MILLISECONDS);
             } else {
-                mController.getAudioOperationsCompleteLatch().await(TEST_TIMEOUT,
+                mController.getAudioOperationsCompleteLatch().await(TEST_TIMEOUT * 2,
                         TimeUnit.MILLISECONDS);
             }
         } catch (Exception e) {
diff --git a/tests/src/com/android/server/telecom/tests/CallAudioRouteStateMachineTest.java b/tests/src/com/android/server/telecom/tests/CallAudioRouteStateMachineTest.java
index 95c3a5a42..6f6700dc0 100644
--- a/tests/src/com/android/server/telecom/tests/CallAudioRouteStateMachineTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallAudioRouteStateMachineTest.java
@@ -142,7 +142,6 @@ public class CallAudioRouteStateMachineTest extends TelecomTestCase {
 
         doNothing().when(mockConnectionServiceWrapper).onCallAudioStateChanged(any(Call.class),
                 any(CallAudioState.class));
-        when(mFeatureFlags.ignoreAutoRouteToWatchDevice()).thenReturn(false);
     }
 
     @Override
@@ -711,7 +710,6 @@ public class CallAudioRouteStateMachineTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testCallDisconnectedWhenAudioRoutedToBluetooth() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         CallAudioRouteStateMachine stateMachine = new CallAudioRouteStateMachine(
                 mContext,
                 mockCallsManager,
@@ -893,7 +891,6 @@ public class CallAudioRouteStateMachineTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testSetAndClearEarpieceCommunicationDevice() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         CallAudioRouteStateMachine stateMachine = new CallAudioRouteStateMachine(
                 mContext,
                 mockCallsManager,
@@ -951,21 +948,18 @@ public class CallAudioRouteStateMachineTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testSetAndClearWiredHeadsetCommunicationDevice() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         verifySetAndClearHeadsetCommunicationDevice(AudioDeviceInfo.TYPE_WIRED_HEADSET);
     }
 
     @SmallTest
     @Test
     public void testSetAndClearUsbHeadsetCommunicationDevice() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         verifySetAndClearHeadsetCommunicationDevice(AudioDeviceInfo.TYPE_USB_HEADSET);
     }
 
     @SmallTest
     @Test
     public void testActiveFocusRouteSwitchFromQuiescentBluetooth() {
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         CallAudioRouteStateMachine stateMachine = new CallAudioRouteStateMachine(
                 mContext,
                 mockCallsManager,
@@ -1168,8 +1162,6 @@ public class CallAudioRouteStateMachineTest extends TelecomTestCase {
     @MediumTest
     @Test
     public void testIgnoreImplicitBTSwitchWhenDeviceIsWatch() {
-        when(mFeatureFlags.ignoreAutoRouteToWatchDevice()).thenReturn(true);
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
         CallAudioRouteStateMachine stateMachine = new CallAudioRouteStateMachine(
                 mContext,
                 mockCallsManager,
diff --git a/tests/src/com/android/server/telecom/tests/CallConnectedIndicatorSettingsTest.java b/tests/src/com/android/server/telecom/tests/CallConnectedIndicatorSettingsTest.java
new file mode 100644
index 000000000..5410ae19c
--- /dev/null
+++ b/tests/src/com/android/server/telecom/tests/CallConnectedIndicatorSettingsTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.telecom.tests;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import com.android.server.telecom.CallConnectedIndicatorSettings;
+import com.android.server.telecom.flags.FeatureFlags;
+
+import org.junit.After;
+import org.junit.Before;
+import org.mockito.Mock;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class CallConnectedIndicatorSettingsTest extends TelecomTestCase {
+
+    private CallConnectedIndicatorSettings mCallConnectedIndicatorSettings;
+
+    @Mock Context mMockContext;
+    @Mock FeatureFlags mMockFeatureFlags;
+    @Mock SharedPreferences mMockSharedPreferences;
+    @Mock SharedPreferences.Editor mMockEditor;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        when(mMockContext.getSharedPreferences(anyString(), anyInt()))
+                .thenReturn(mMockSharedPreferences);
+        when(mMockSharedPreferences.edit()).thenReturn(mMockEditor);
+        when(mMockSharedPreferences.getInt(anyString(), anyInt())).thenReturn(3);
+        mCallConnectedIndicatorSettings =
+                new CallConnectedIndicatorSettings(mMockContext, mMockFeatureFlags);
+    }
+
+    @Override
+    @After
+    public void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    @Test
+    public void testPreferenceBasicSettings() {
+        assertEquals(3, mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference());
+        assertTrue(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled());
+        assertTrue(mCallConnectedIndicatorSettings.isCallConnectedToneEnabled());
+
+        try {
+            mCallConnectedIndicatorSettings.setCallConnectedIndicatorPreference(4);
+        } catch (IllegalArgumentException e) {
+            assertEquals(3, mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference());
+        }
+        // no perferences there
+        mCallConnectedIndicatorSettings.setCallConnectedIndicatorPreference(0);
+        assertEquals(0, mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference());
+        assertFalse(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled());
+        assertFalse(mCallConnectedIndicatorSettings.isCallConnectedToneEnabled());
+
+        // single tone preference
+        mCallConnectedIndicatorSettings.setCallConnectedIndicatorPreference(1);
+        assertEquals(1, mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference());
+        assertTrue(mCallConnectedIndicatorSettings.isCallConnectedToneEnabled());
+        assertFalse(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled());
+
+        // single vibration preference
+        mCallConnectedIndicatorSettings.setCallConnectedIndicatorPreference(2);
+        assertEquals(2, mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference());
+        assertTrue(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled());
+        assertFalse(mCallConnectedIndicatorSettings.isCallConnectedToneEnabled());
+
+        // both tone and vibration preference
+        mCallConnectedIndicatorSettings.setCallConnectedIndicatorPreference(3);
+        assertEquals(3, mCallConnectedIndicatorSettings.getCallConnectedIndicatorPreference());
+        assertTrue(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled());
+        assertTrue(mCallConnectedIndicatorSettings.isCallConnectedToneEnabled());
+    }
+}
+
diff --git a/tests/src/com/android/server/telecom/tests/CallEndpointControllerTest.java b/tests/src/com/android/server/telecom/tests/CallEndpointControllerTest.java
index b8b9560d5..dc7fc29b9 100644
--- a/tests/src/com/android/server/telecom/tests/CallEndpointControllerTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallEndpointControllerTest.java
@@ -108,6 +108,7 @@ public class CallEndpointControllerTest extends TelecomTestCase {
                 mFeatureFlags);
         doReturn(new HashSet<>(Arrays.asList(mCall))).when(mCallsManager).getTrackedCalls();
         doReturn(mConnectionService).when(mCall).getConnectionService();
+        doReturn(mConnectionService).when(mCall).getService();
         doReturn(mCallAudioManager).when(mCallsManager).getCallAudioManager();
         when(mMockContext.getText(R.string.callendpoint_name_earpiece)).thenReturn("Earpiece");
         when(mMockContext.getText(R.string.callendpoint_name_bluetooth)).thenReturn("Bluetooth");
diff --git a/tests/src/com/android/server/telecom/tests/CallFilteringResultTest.java b/tests/src/com/android/server/telecom/tests/CallFilteringResultTest.java
new file mode 100644
index 000000000..e08d8c376
--- /dev/null
+++ b/tests/src/com/android/server/telecom/tests/CallFilteringResultTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.telecom.tests;
+
+import static com.android.server.telecom.callfiltering.CallFilteringResult.DND_NOT_DETERMINED;
+import static com.android.server.telecom.callfiltering.CallFilteringResult.DND_NOT_SUPPRESSED;
+import static com.android.server.telecom.callfiltering.CallFilteringResult.DND_SUPPRESSED;
+import static org.junit.Assert.assertEquals;
+
+import com.android.server.telecom.callfiltering.CallFilteringResult;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class CallFilteringResultTest {
+    @Test
+    public void testGetCombinedDndSuppressionStatus_notDetermined() {
+        assertEquals(DND_NOT_DETERMINED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_NOT_DETERMINED, DND_NOT_DETERMINED));
+    }
+
+    @Test
+    public void testGetCombinedDndSuppressionStatus_suppressed() {
+        assertEquals(DND_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_SUPPRESSED, DND_NOT_DETERMINED));
+        assertEquals(DND_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_SUPPRESSED, DND_NOT_SUPPRESSED));
+        assertEquals(DND_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_SUPPRESSED, DND_SUPPRESSED));
+        assertEquals(DND_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_NOT_DETERMINED, DND_SUPPRESSED));
+        assertEquals(DND_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_NOT_SUPPRESSED, DND_SUPPRESSED));
+    }
+
+    @Test
+    public void testGetCombinedDndSuppressionStatus_notSuppressed() {
+        assertEquals(DND_NOT_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_NOT_DETERMINED, DND_NOT_SUPPRESSED));
+        assertEquals(DND_NOT_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_NOT_SUPPRESSED, DND_NOT_DETERMINED));
+        assertEquals(DND_NOT_SUPPRESSED,
+                CallFilteringResult.getCombinedDndSuppressionStatus(
+                        DND_NOT_SUPPRESSED, DND_NOT_SUPPRESSED));
+    }
+}
\ No newline at end of file
diff --git a/tests/src/com/android/server/telecom/tests/CallLogManagerTest.java b/tests/src/com/android/server/telecom/tests/CallLogManagerTest.java
index fcb8966a0..b6ed9c13a 100644
--- a/tests/src/com/android/server/telecom/tests/CallLogManagerTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallLogManagerTest.java
@@ -221,7 +221,6 @@ public class CallLogManagerTest extends TelecomTestCase {
 
         PackageManager packageManager = mContext.getPackageManager();
         when(packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)).thenReturn(false);
-        when(mFeatureFlags.telecomLogExternalWearableCalls()).thenReturn(false);
         when(mFeatureFlags.telecomResolveHiddenDependencies()).thenReturn(true);
     }
 
@@ -309,8 +308,14 @@ public class CallLogManagerTest extends TelecomTestCase {
         when(mockCarrierConfigManager.getConfig()).thenReturn(bundle);
 
         Resources mockResources = mContext.getResources();
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(
+                new com.android.server.telecom.flags.FeatureFlagsImpl()
+                        .resolveHiddenDependenciesTwo());
         when(mockResources.getStringArray(com.android.internal.R.array.unloggable_phone_numbers))
                 .thenReturn(new String[] {number2});
+        when(mockResources.getStringArray(
+                com.android.server.telecom.R.array.unloggable_phone_numbers))
+                .thenReturn(new String[] {number2});
 
         Call fakeCall1 = makeFakeCall(
                 DisconnectCause.OTHER, // disconnectCauseCode
@@ -961,7 +966,6 @@ public class CallLogManagerTest extends TelecomTestCase {
                 .thenReturn(makeFakePhoneAccount(mDefaultAccountHandle, 0 /* capabilities */));
         PackageManager packageManager = mContext.getPackageManager();
         when(packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)).thenReturn(true);
-        when(mFeatureFlags.telecomLogExternalWearableCalls()).thenReturn(true);
         Call fakeMissedCall = makeFakeCall(
                 DisconnectCause.REJECTED, // disconnectCauseCode
                 false, // isConference
@@ -1087,7 +1091,6 @@ public class CallLogManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testDoNotLogCallExtra() {
-        when(mFeatureFlags.telecomSkipLogBasedOnExtra()).thenReturn(true);
         Call fakeCall = makeFakeCall(
                 DisconnectCause.LOCAL, // disconnectCauseCode
                 false, // isConference
@@ -1109,31 +1112,6 @@ public class CallLogManagerTest extends TelecomTestCase {
                 false /* isCanceled */));
     }
 
-    @SmallTest
-    @Test
-    public void testIgnoresDoNotLogCallExtra_whenFlagDisabled() {
-        when(mFeatureFlags.telecomSkipLogBasedOnExtra()).thenReturn(false);
-        Call fakeCall = makeFakeCall(
-                DisconnectCause.LOCAL, // disconnectCauseCode
-                false, // isConference
-                true, // isIncoming
-                1L, // creationTimeMillis
-                1000L, // ageMillis
-                TEL_PHONEHANDLE, // callHandle
-                mDefaultAccountHandle, // phoneAccountHandle
-                NO_VIDEO_STATE, // callVideoState
-                POST_DIAL_STRING, // postDialDigits
-                VIA_NUMBER_STRING, // viaNumber
-                UserHandle.of(CURRENT_USER_ID)
-        );
-        Bundle extras = new Bundle();
-        extras.putBoolean(TelecomManager.EXTRA_DO_NOT_LOG_CALL, true);
-        when(fakeCall.getExtras()).thenReturn(extras);
-
-        assertTrue(mCallLogManager.shouldLogDisconnectedCall(fakeCall, CallState.DISCONNECTED,
-                false /* isCanceled */));
-    }
-
     @SmallTest
     @Test
     public void testDoNotLogConferenceWithChildren() {
diff --git a/tests/src/com/android/server/telecom/tests/CallRecordingTonePlayerTest.java b/tests/src/com/android/server/telecom/tests/CallRecordingTonePlayerTest.java
index 5ccb2fe28..c46b4dffe 100644
--- a/tests/src/com/android/server/telecom/tests/CallRecordingTonePlayerTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallRecordingTonePlayerTest.java
@@ -53,6 +53,7 @@ import com.android.server.telecom.CallRecordingTonePlayer;
 import com.android.server.telecom.CallState;
 import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.Timeouts;
+import com.android.server.telecom.flags.FeatureFlags;
 import com.android.server.telecom.flags.Flags;
 
 import org.junit.After;
@@ -98,11 +99,11 @@ public class CallRecordingTonePlayerTest extends TelecomTestCase {
     public void setUp() throws Exception {
         super.setUp();
         MockitoAnnotations.initMocks(this);
-        when(mTimeouts.getCallRecordingToneRepeatIntervalMillis(nullable(ContentResolver.class)))
-                .thenReturn(500L);
+        when(mTimeouts.getCallRecordingToneRepeatIntervalMillis(nullable(Context.class),
+                any(FeatureFlags.class))).thenReturn(500L);
         mCallRecordingTonePlayer = new CallRecordingTonePlayer(
                 mComponentContextFixture.getTestDouble().getApplicationContext(),
-                mAudioManager, mTimeouts, mSyncRoot);
+                mAudioManager, mTimeouts, mSyncRoot, mFeatureFlags);
         when(mAudioManager.getActiveRecordingConfigurations()).thenReturn(null);
     }
 
diff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java
index 185c08f42..311dd707f 100644
--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java
@@ -128,9 +128,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {
         doReturn(mCallRedirectionService).when(mBinder).queryLocalInterface(anyString());
         when(mCallsManager.getSystemStateHelper()).thenReturn(mSystemStateHelper);
         when(mCallsManager.getTimeoutsAdapter()).thenReturn(mTimeoutsAdapter);
-        when(mTimeoutsAdapter.getUserDefinedCallRedirectionTimeoutMillis(mContentResolver))
+        when(mTimeoutsAdapter.getUserDefinedCallRedirectionTimeoutMillis(mContext, mFeatureFlags))
                 .thenReturn(USER_DEFINED_SHORT_TIMEOUT_MS);
-        when(mTimeoutsAdapter.getCarrierCallRedirectionTimeoutMillis(mContentResolver))
+        when(mTimeoutsAdapter.getCarrierCallRedirectionTimeoutMillis(mContext, mFeatureFlags))
                 .thenReturn(CARRIER_SHORT_TIMEOUT_MS);
         when(mCallsManager.getLock()).thenReturn(mLock);
         when(mCallsManager.getCurrentUserHandle()).thenReturn(mUserHandle);
@@ -180,13 +180,13 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {
 
     private void startProcessWithNoGateWayInfo(Uri handle) {
         mProcessor = new CallRedirectionProcessor(mContext, mCallsManager, mCall, handle,
-                mPhoneAccountRegistrar, null, SPEAKER_PHONE_ON, VIDEO_STATE);
+                mPhoneAccountRegistrar, null, SPEAKER_PHONE_ON, VIDEO_STATE, mFeatureFlags);
         mProcessor.setCallRedirectionServiceHelper(mCallRedirectionProcessorHelper);
     }
 
     private void startProcessWithGateWayInfo() {
         mProcessor = new CallRedirectionProcessor(mContext, mCallsManager, mCall, mHandle,
-                mPhoneAccountRegistrar, mGatewayInfo, SPEAKER_PHONE_ON, VIDEO_STATE);
+                mPhoneAccountRegistrar, mGatewayInfo, SPEAKER_PHONE_ON, VIDEO_STATE, mFeatureFlags);
         mProcessor.setCallRedirectionServiceHelper(mCallRedirectionProcessorHelper);
     }
 
@@ -401,7 +401,7 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {
         startProcessWithNoGateWayInfo();
 
         CallRedirectionProcessorHelper helper = new CallRedirectionProcessorHelper(mContext,
-                mCallsManager, mPhoneAccountRegistrar);
+                mCallsManager, mPhoneAccountRegistrar, mFeatureFlags);
         when(mComponentContextFixture.getTelephonyManager().getNetworkCountryIso())
                 .thenThrow(new UnsupportedOperationException("Bee boop"));
         assertEquals(Uri.fromParts("tel", "6505551212", null),
diff --git a/tests/src/com/android/server/telecom/tests/CallScreeningServiceFilterTest.java b/tests/src/com/android/server/telecom/tests/CallScreeningServiceFilterTest.java
index d97263d08..b17c1013f 100644
--- a/tests/src/com/android/server/telecom/tests/CallScreeningServiceFilterTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallScreeningServiceFilterTest.java
@@ -49,6 +49,7 @@ import androidx.test.filters.SmallTest;
 
 import com.android.internal.telecom.ICallScreeningAdapter;
 import com.android.internal.telecom.ICallScreeningService;
+import com.android.server.telecom.flags.FeatureFlagsImpl;
 import com.android.server.telecom.AppLabelProxy;
 import com.android.server.telecom.Call;
 import com.android.server.telecom.CallsManager;
@@ -134,6 +135,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
         when(mCall.getAssociatedUser()).
                 thenReturn(PA_HANDLE.getUserHandle());
         when(mContext.getPackageManager()).thenReturn(mPackageManager);
+        when(mContext.createContextAsUser(any(), anyInt())).thenReturn(mContext);
         when(mContext.getSystemService(TelecomManager.class))
                 .thenReturn(mTelecomManager);
         when(mTelecomManager.getSystemDialerPackage()).thenReturn(PKG_NAME);
@@ -152,7 +154,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
     public void testNoPackageName() throws Exception {
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, null,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         assertEquals(PASS_RESULT,
                 filter.startFilterLookup(inputResult).toCompletableFuture().get(
                         CallScreeningServiceFilter.CALL_SCREENING_FILTER_TIMEOUT,
@@ -166,7 +168,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
                 anyInt(), eq(PA_HANDLE.getUserHandle()))).thenReturn(false);
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         assertEquals(PASS_RESULT,
                 filter.startFilterLookup(inputResult).toCompletableFuture().get(
                         CallScreeningServiceFilter.CALL_SCREENING_FILTER_TIMEOUT,
@@ -180,7 +182,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
                 .thenReturn(Collections.emptyList());
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         assertEquals(PASS_RESULT,
                 filter.startFilterLookup(inputResult).toCompletableFuture().get(
                         CallScreeningServiceFilter.CALL_SCREENING_FILTER_TIMEOUT,
@@ -193,7 +195,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
         mResolveInfo.serviceInfo = null;
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         assertEquals(PASS_RESULT,
                 filter.startFilterLookup(inputResult).toCompletableFuture().get(
                         CallScreeningServiceFilter.CALL_SCREENING_FILTER_TIMEOUT,
@@ -212,7 +214,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
         inputResult.contactExists = true;
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_USER_CHOSEN, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         filter.startFilterLookup(inputResult);
     }
 
@@ -224,7 +226,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
         inputResult.contactExists = true;
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         filter.startFilterLookup(inputResult);
         ServiceConnection connection = verifyBindingIntent();
         connection.onServiceDisconnected(COMPONENT_NAME);
@@ -238,7 +240,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
                 .unbindService(nullable(ServiceConnection.class));
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         CompletableFuture<CallFilteringResult> result = filter.startFilterLookup(inputResult)
                 .toCompletableFuture();
 
@@ -253,7 +255,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
         // Use an empty package name here, which fails in the bindCallScreeningService.
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, "",
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
 
         CompletableFuture<CallFilteringResult> result = filter.startFilterLookup(inputResult)
                 .toCompletableFuture();
@@ -266,7 +268,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
     public void testAllowCall() throws Exception {
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         CompletionStage<CallFilteringResult> resultFuture = filter.startFilterLookup(inputResult);
 
         ServiceConnection serviceConnection = verifyBindingIntent();
@@ -302,7 +304,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
                 .build();
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         CompletionStage<CallFilteringResult> resultFuture = filter.startFilterLookup(inputResult);
 
         ServiceConnection serviceConnection = verifyBindingIntent();
@@ -339,7 +341,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
                 .build();
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_CARRIER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         CompletionStage<CallFilteringResult> resultFuture = filter.startFilterLookup(inputResult);
 
         ServiceConnection serviceConnection = verifyBindingIntent();
@@ -374,7 +376,7 @@ public class CallScreeningServiceFilterTest extends TelecomTestCase {
                 .build();
         CallScreeningServiceFilter filter = new CallScreeningServiceFilter(mCall, PKG_NAME,
                 CallScreeningServiceFilter.PACKAGE_TYPE_DEFAULT_DIALER, mContext, mCallsManager,
-                mAppLabelProxy, mParcelableCallUtilsConverter);
+                mAppLabelProxy, mParcelableCallUtilsConverter, new FeatureFlagsImpl());
         CompletionStage<CallFilteringResult> resultFuture = filter.startFilterLookup(inputResult);
 
         ServiceConnection serviceConnection = verifyBindingIntent();
diff --git a/tests/src/com/android/server/telecom/tests/CallSequencingTests.java b/tests/src/com/android/server/telecom/tests/CallSequencingTests.java
index fc476f884..e5b6d6bcf 100644
--- a/tests/src/com/android/server/telecom/tests/CallSequencingTests.java
+++ b/tests/src/com/android/server/telecom/tests/CallSequencingTests.java
@@ -299,7 +299,7 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mActiveCall.hold(anyString())).thenReturn(CompletableFuture.completedFuture(true));
 
         // Cross phone account case (sequencing enabled)
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -307,7 +307,7 @@ public class CallSequencingTests extends TelecomTestCase {
 
         // Same phone account case
         setPhoneAccounts(mNewCall, mActiveCall, true);
-        assertTrue(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertTrue(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         resultFuture = mController.holdActiveCallForNewCallWithSequencing(mNewCall,
                 CallsManager.REQUEST_ORIGIN_UNKNOWN);
         assertTrue(waitForFutureResult(resultFuture, false));
@@ -328,7 +328,7 @@ public class CallSequencingTests extends TelecomTestCase {
 
         // Verify that we abort transaction when there's a new (VOIP) call and we're trying to
         // disconnect the active (carrier) call.
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -349,7 +349,7 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mActiveCall.hold()).thenReturn(CompletableFuture.completedFuture(true));
 
         // Cross phone account case (sequencing enabled)
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -370,7 +370,7 @@ public class CallSequencingTests extends TelecomTestCase {
                 CompletableFuture.completedFuture(true));
         when(mActiveCall.isEmergencyCall()).thenReturn(false);
 
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -391,7 +391,7 @@ public class CallSequencingTests extends TelecomTestCase {
 
         // Verify that we abort transaction when there's a new (VOIP) call and we're trying to
         // disconnect the active (carrier) call.
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -407,7 +407,7 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mCallsManager.supportsHold(mActiveCall)).thenReturn(false);
         when(mActiveCall.isEmergencyCall()).thenReturn(false);
 
-        assertTrue(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertTrue(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -425,7 +425,7 @@ public class CallSequencingTests extends TelecomTestCase {
                 .thenReturn(CompletableFuture.completedFuture(true));
         when(mActiveCall.isEmergencyCall()).thenReturn(true);
 
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -445,7 +445,7 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mActiveCall.isSelfManaged()).thenReturn(false);
         when(mNewCall.isSelfManaged()).thenReturn(true);
 
-        assertFalse(mController.arePhoneAccountsSame(mNewCall, mActiveCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mNewCall, mActiveCall));
         CompletableFuture<Boolean> resultFuture = mController
                 .holdActiveCallForNewCallWithSequencing(mNewCall,
                         CallsManager.REQUEST_ORIGIN_UNKNOWN);
@@ -470,7 +470,7 @@ public class CallSequencingTests extends TelecomTestCase {
         setActiveCallFocus(mActiveCall);
 
         mController.unholdCall(mHeldCall);
-        assertFalse(mController.arePhoneAccountsSame(mActiveCall, mHeldCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mActiveCall, mHeldCall));
         verify(mActiveCall).hold(anyString());
         verify(mCallsManager, timeout(SEQUENCING_TIMEOUT_MS))
                 .requestActionUnholdCall(eq(mHeldCall), eq(ACTIVE_CALL_ID));
@@ -487,7 +487,7 @@ public class CallSequencingTests extends TelecomTestCase {
 
         // Emergency call case
         mController.unholdCall(mHeldCall);
-        assertFalse(mController.arePhoneAccountsSame(mActiveCall, mHeldCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mActiveCall, mHeldCall));
         verify(mCallsManager, timeout(SEQUENCING_TIMEOUT_MS).times(0))
                 .requestActionUnholdCall(eq(mHeldCall), anyString());
     }
@@ -504,7 +504,7 @@ public class CallSequencingTests extends TelecomTestCase {
         setActiveCallFocus(mActiveCall);
 
         mController.unholdCall(mHeldCall);
-        assertFalse(mController.arePhoneAccountsSame(mActiveCall, mHeldCall));
+        assertFalse(CallSequencingController.arePhoneAccountsSame(mActiveCall, mHeldCall));
         verify(mActiveCall).hold(anyString());
         // Verify unhold is never reached.
         verify(mCallsManager, never())
@@ -514,6 +514,7 @@ public class CallSequencingTests extends TelecomTestCase {
     @SmallTest
     @Test
     public void testMakeRoomForOutgoingEmergencyCall_SamePkg() {
+        when(mFeatureFlags.bypassHoldForEccDial()).thenReturn(true);
         // Ensure that the live call and emergency call are from the same pkg.
         when(mActiveCall.getTargetPhoneAccount()).thenReturn(mHandle1);
         when(mNewCall.getTargetPhoneAccount()).thenReturn(mHandle1);
@@ -523,7 +524,9 @@ public class CallSequencingTests extends TelecomTestCase {
         CompletableFuture<Boolean> future = mController.makeRoomForOutgoingCall(true, mNewCall);
         verify(mRingingCall, timeout(SEQUENCING_TIMEOUT_MS))
                 .reject(anyBoolean(), eq(null), anyString());
-        verify(mActiveCall, timeout(SEQUENCING_TIMEOUT_MS)).hold(anyString());
+        // Verify we don't send the hold request when the normal call and ECC are from the same
+        // phone accounts (this task is left up to Telephony to handle).
+        verify(mActiveCall, timeout(SEQUENCING_TIMEOUT_MS).times(0)).hold(anyString());
         assertTrue(waitForFutureResult(future, false));
     }
 
@@ -620,6 +623,7 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mActiveCall.disconnect()).thenReturn(CompletableFuture.completedFuture(true));
         int previousState = CallState.ACTIVE;
         mController.disconnectCall(mActiveCall, previousState);
+        verify(mCallsManager).notifyCallStateChangeForDisconnect(any(Call.class), anyInt());
         verify(mCallsManager, timeout(SEQUENCING_TIMEOUT_MS))
                 .processDisconnectCallAndCleanup(eq(mActiveCall), eq(previousState));
     }
@@ -630,8 +634,12 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mActiveCall.disconnect()).thenReturn(CompletableFuture.completedFuture(false));
         int previousState = CallState.ACTIVE;
         mController.disconnectCall(mActiveCall, previousState);
+        verify(mCallsManager).notifyCallStateChangeForDisconnect(any(Call.class), anyInt());
         verify(mCallsManager, timeout(SEQUENCING_TIMEOUT_MS).times(0))
                 .processDisconnectCallAndCleanup(eq(mActiveCall), eq(previousState));
+        verify(mCallsManager, timeout(SEQUENCING_TIMEOUT_MS).times(2))
+                .notifyCallStateChangeForDisconnect(any(Call.class), anyInt());
+        verify(mActiveCall, timeout(SEQUENCING_TIMEOUT_MS)).setLocallyDisconnecting(eq(false));
     }
 
     @Test
@@ -675,7 +683,7 @@ public class CallSequencingTests extends TelecomTestCase {
         when(mCallsManager.hasRingingOrSimulatedRingingCall()).thenReturn(true);
         when(mCallsManager.getRingingOrSimulatedRingingCall()).thenReturn(mRingingCall);
         when(mCallsManager.hasMaximumLiveCalls(mNewCall)).thenReturn(true);
-        when(mCallsManager.getFirstCallWithLiveState()).thenReturn(mActiveCall);
+        when(mCallsManager.getFirstCallWithLiveState(mNewCall)).thenReturn(mActiveCall);
         when(mCallsManager.hasMaximumOutgoingCalls(mNewCall)).thenReturn(false);
         when(mCallsManager.hasMaximumManagedHoldingCalls(mNewCall)).thenReturn(false);
         when(mCallsManager.canHold(mActiveCall)).thenReturn(true);
@@ -713,7 +721,7 @@ public class CallSequencingTests extends TelecomTestCase {
 
     private void setupMakeRoomForOutgoingCallMocks() {
         when(mCallsManager.hasMaximumLiveCalls(mNewCall)).thenReturn(true);
-        when(mCallsManager.getFirstCallWithLiveState()).thenReturn(mActiveCall);
+        when(mCallsManager.getFirstCallWithLiveState(mNewCall)).thenReturn(mActiveCall);
         setPhoneAccounts(mActiveCall, mNewCall, false);
         when(mActiveCall.isConference()).thenReturn(false);
         when(mCallsManager.hasMaximumOutgoingCalls(mNewCall)).thenReturn(false);
diff --git a/tests/src/com/android/server/telecom/tests/CallTest.java b/tests/src/com/android/server/telecom/tests/CallTest.java
index b2cdd7de4..6e390694f 100644
--- a/tests/src/com/android/server/telecom/tests/CallTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallTest.java
@@ -102,6 +102,8 @@ public class CallTest extends TelecomTestCase {
                     | PhoneAccount.CAPABILITY_CALL_PROVIDER)
             .setIsEnabled(true)
             .build();
+    private static final PhoneAccountHandle SIM_2_HANDLE = new PhoneAccountHandle(
+            COMPONENT_NAME_2, "Sim2");
     private static final long TIMEOUT_MILLIS = 1000;
 
     @Mock private CallsManager mMockCallsManager;
@@ -158,21 +160,11 @@ public class CallTest extends TelecomTestCase {
     @Test
     @SmallTest
     public void testTransactionalCallCapabilityRemapping() {
-        // ensure when the flag is disabled, the old behavior is unchanged
-        Bundle disabledFlagExtras = new Bundle();
-        Call call = createCall("1", Call.CALL_DIRECTION_INCOMING);
-        disabledFlagExtras.putInt(CallAttributes.CALL_CAPABILITIES_KEY,
-                Connection.CAPABILITY_MERGE_CONFERENCE);
-        when(mFeatureFlags.remapTransactionalCapabilities()).thenReturn(false);
-        call.setTransactionalCapabilities(disabledFlagExtras);
-        assertTrue(call.can(Connection.CAPABILITY_MERGE_CONFERENCE));
-        // enable the bug fix flag and ensure the transactional capabilities are remapped
-        Bundle enabledFlagExtras = new Bundle();
+        Bundle extras = new Bundle();
         Call call2 = createCall("2", Call.CALL_DIRECTION_INCOMING);
-        enabledFlagExtras.putInt(CallAttributes.CALL_CAPABILITIES_KEY,
+        extras.putInt(CallAttributes.CALL_CAPABILITIES_KEY,
                 CallAttributes.SUPPORTS_SET_INACTIVE);
-        when(mFeatureFlags.remapTransactionalCapabilities()).thenReturn(true);
-        call2.setTransactionalCapabilities(enabledFlagExtras);
+        call2.setTransactionalCapabilities(extras);
         assertTrue(call2.can(Connection.CAPABILITY_HOLD));
         assertTrue(call2.can(Connection.CAPABILITY_SUPPORT_HOLD));
     }
@@ -242,7 +234,6 @@ public class CallTest extends TelecomTestCase {
 
     @Test
     public void testMultipleCachedCallEvents() {
-        when(mFeatureFlags.cacheCallAudioCallbacks()).thenReturn(true);
         when(mFeatureFlags.cacheCallEvents()).thenReturn(true);
         TransactionalServiceWrapper tsw = Mockito.mock(TransactionalServiceWrapper.class);
         Call call = createCall("1", Call.CALL_DIRECTION_INCOMING);
@@ -280,7 +271,6 @@ public class CallTest extends TelecomTestCase {
 
     @Test
     public void testMultipleCachedMuteStateChanges() {
-        when(mFeatureFlags.cacheCallAudioCallbacks()).thenReturn(true);
         TransactionalServiceWrapper tsw = Mockito.mock(TransactionalServiceWrapper.class);
         Call call = createCall("1", Call.CALL_DIRECTION_INCOMING);
 
@@ -308,7 +298,6 @@ public class CallTest extends TelecomTestCase {
 
     @Test
     public void testCacheAfterServiceSet() {
-        when(mFeatureFlags.cacheCallAudioCallbacks()).thenReturn(true);
         when(mFeatureFlags.cacheCallEvents()).thenReturn(true);
         TransactionalServiceWrapper tsw = Mockito.mock(TransactionalServiceWrapper.class);
         Call call = createCall("1", Call.CALL_DIRECTION_INCOMING);
@@ -324,7 +313,6 @@ public class CallTest extends TelecomTestCase {
 
     @Test
     public void testMultipleCachedCurrentEndpointChanges() {
-        when(mFeatureFlags.cacheCallAudioCallbacks()).thenReturn(true);
         TransactionalServiceWrapper tsw = Mockito.mock(TransactionalServiceWrapper.class);
         CallEndpoint earpiece = Mockito.mock(CallEndpoint.class);
         CallEndpoint speaker = Mockito.mock(CallEndpoint.class);
@@ -358,7 +346,6 @@ public class CallTest extends TelecomTestCase {
 
     @Test
     public void testMultipleCachedAvailableEndpointChanges() {
-        when(mFeatureFlags.cacheCallAudioCallbacks()).thenReturn(true);
         TransactionalServiceWrapper tsw = Mockito.mock(TransactionalServiceWrapper.class);
         CallEndpoint earpiece = Mockito.mock(CallEndpoint.class);
         CallEndpoint bluetooth = Mockito.mock(CallEndpoint.class);
@@ -397,7 +384,6 @@ public class CallTest extends TelecomTestCase {
      */
     @Test
     public void testAllCachedCallbacks() {
-        when(mFeatureFlags.cacheCallAudioCallbacks()).thenReturn(true);
         when(mFeatureFlags.cacheCallEvents()).thenReturn(true);
         TransactionalServiceWrapper tsw = Mockito.mock(TransactionalServiceWrapper.class);
         CallEndpoint earpiece = Mockito.mock(CallEndpoint.class);
diff --git a/tests/src/com/android/server/telecom/tests/CallsManagerTest.java b/tests/src/com/android/server/telecom/tests/CallsManagerTest.java
index 7f1f1ec13..9db061a57 100644
--- a/tests/src/com/android/server/telecom/tests/CallsManagerTest.java
+++ b/tests/src/com/android/server/telecom/tests/CallsManagerTest.java
@@ -16,6 +16,7 @@
 
 package com.android.server.telecom.tests;
 
+import static android.provider.CallLog.Calls.MISSED_REASON_NOT_MISSED;
 import static android.provider.CallLog.Calls.USER_MISSED_NOT_RUNNING;
 
 import static junit.framework.Assert.assertNotNull;
@@ -51,7 +52,6 @@ import static java.lang.Thread.sleep;
 
 import android.Manifest;
 import android.content.ComponentName;
-import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -83,7 +83,6 @@ import android.telephony.PhoneCapability;
 import android.telephony.TelephonyManager;
 import android.util.ArraySet;
 import android.util.Pair;
-import android.widget.Toast;
 
 import androidx.test.filters.MediumTest;
 import androidx.test.filters.SmallTest;
@@ -96,6 +95,7 @@ import com.android.server.telecom.CallAnomalyWatchdog;
 import com.android.server.telecom.CallAudioCommunicationDeviceTracker;
 import com.android.server.telecom.CallAudioManager;
 import com.android.server.telecom.CallAudioModeStateMachine;
+import com.android.server.telecom.CallAudioRouteController;
 import com.android.server.telecom.CallAudioRouteStateMachine;
 import com.android.server.telecom.CallDiagnosticServiceController;
 import com.android.server.telecom.CallEndpointController;
@@ -103,6 +103,7 @@ import com.android.server.telecom.CallEndpointControllerFactory;
 import com.android.server.telecom.CallState;
 import com.android.server.telecom.CallerInfoLookupHelper;
 import com.android.server.telecom.CallsManager;
+import com.android.server.telecom.TransactionalServiceWrapper;
 import com.android.server.telecom.callsequencing.CallSequencingController;
 import com.android.server.telecom.callsequencing.CallsManagerCallSequencingAdapter;
 import com.android.server.telecom.ClockProxy;
@@ -146,8 +147,6 @@ import com.android.server.telecom.ui.DisconnectedCallNotifier;
 import com.android.server.telecom.ui.ToastFactory;
 import com.android.server.telecom.callsequencing.TransactionManager;
 
-import com.google.common.base.Objects;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -170,7 +169,6 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
 
 @RunWith(JUnit4.class)
 public class CallsManagerTest extends TelecomTestCase {
@@ -262,6 +260,8 @@ public class CallsManagerTest extends TelecomTestCase {
     private static final Uri TEST_ADDRESS = Uri.parse("tel:555-1212");
     private static final Uri TEST_ADDRESS2 = Uri.parse("tel:555-1213");
     private static final Uri TEST_ADDRESS3 = Uri.parse("tel:555-1214");
+
+    private static final String TEST_NUMBER = "1234567890";
     private static final Map<Uri, PhoneAccountHandle> CONTACT_PREFERRED_ACCOUNT = Map.of(
             TEST_ADDRESS2, SIM_1_HANDLE,
             TEST_ADDRESS3, SIM_2_HANDLE);
@@ -299,8 +299,8 @@ public class CallsManagerTest extends TelecomTestCase {
     @Mock private CallEndpointControllerFactory mCallEndpointControllerFactory;
     @Mock private CallEndpointController mCallEndpointController;
     @Mock private ConnectionServiceFocusManager mConnectionSvrFocusMgr;
-    @Mock private CallAudioRouteStateMachine mCallAudioRouteStateMachine;
-    @Mock private CallAudioRouteStateMachine.Factory mCallAudioRouteStateMachineFactory;
+    @Mock private CallAudioRouteController mCallAudioRouteController;
+    @Mock private CallAudioRouteController.Factory mCallAudioRouteControllerFactory;
     @Mock private CallAudioModeStateMachine mCallAudioModeStateMachine;
     @Mock private CallAudioModeStateMachine.Factory mCallAudioModeStateMachineFactory;
     @Mock private CallDiagnosticServiceController mCallDiagnosticServiceController;
@@ -324,6 +324,7 @@ public class CallsManagerTest extends TelecomTestCase {
     @Mock private UserManager mMockCurrentUserManager;
     @Mock private IConnectionService mIConnectionService;
     @Mock private TelecomMetricsController mMockTelecomMetricsController;
+    @Mock private Ringer.VibratorAdapter mMockVibratorAdapter;
     private CallsManager mCallsManager;
 
     @Override
@@ -341,21 +342,23 @@ public class CallsManagerTest extends TelecomTestCase {
                 any())).thenReturn(mInCallController);
         when(mCallEndpointControllerFactory.create(any(), any(), any())).thenReturn(
                 mCallEndpointController);
-        when(mCallAudioRouteStateMachineFactory.create(any(), any(), any(), any(), any(), any(),
-                anyInt(), any(), any(), any())).thenReturn(mCallAudioRouteStateMachine);
+        when(mCallAudioRouteControllerFactory.create(any(), any(), any(), any(), any(), any(),
+                any(), any(), any())).thenReturn(mCallAudioRouteController);
         when(mCallAudioModeStateMachineFactory.create(any(), any(), any(), any()))
                 .thenReturn(mCallAudioModeStateMachine);
         when(mClockProxy.currentTimeMillis()).thenReturn(System.currentTimeMillis());
         when(mClockProxy.elapsedRealtime()).thenReturn(SystemClock.elapsedRealtime());
         when(mConnSvrFocusManagerFactory.create(any())).thenReturn(mConnectionSvrFocusMgr);
         doNothing().when(mRoleManagerAdapter).setCurrentUserHandle(any());
-        when(mDisconnectedCallNotifierFactory.create(any(Context.class),any(CallsManager.class)))
+        when(mDisconnectedCallNotifierFactory.create(any(Context.class),any(CallsManager.class),
+                any(FeatureFlags.class)))
                 .thenReturn(mDisconnectedCallNotifier);
-        when(mTimeoutsAdapter.getCallDiagnosticServiceTimeoutMillis(any(ContentResolver.class)))
-                .thenReturn(2000L);
+        when(mTimeoutsAdapter.getCallDiagnosticServiceTimeoutMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(2000L);
         when(mTimeoutsAdapter.getNonVoipCallTransitoryStateTimeoutMillis())
                 .thenReturn(STATE_TIMEOUT);
         when(mClockProxy.elapsedRealtime()).thenReturn(0L);
+        when(mMockVibratorAdapter.hasVibrator()).thenReturn(true);
         mCallsManager = new CallsManager(
                 mComponentContextFixture.getTestDouble().getApplicationContext(),
                 mLock,
@@ -380,7 +383,7 @@ public class CallsManagerTest extends TelecomTestCase {
                 mClockProxy,
                 mAudioProcessingNotification,
                 mBluetoothStateReceiver,
-                mCallAudioRouteStateMachineFactory,
+                mCallAudioRouteControllerFactory,
                 mCallAudioModeStateMachineFactory,
                 mInCallControllerFactory,
                 mCallDiagnosticServiceController,
@@ -403,21 +406,33 @@ public class CallsManagerTest extends TelecomTestCase {
                 mTelephonyFlags,
                 (call, listener, context, timeoutsAdapter,
                         mFeatureFlags, lock) -> mIncomingCallFilterGraph,
-                mMockTelecomMetricsController);
-
+                mMockTelecomMetricsController,
+                mMockVibratorAdapter);
+        mCallsManager.setCallAudioWatchDog(null);
         when(mPhoneAccountRegistrar.getPhoneAccount(
                 eq(SELF_MANAGED_HANDLE), any())).thenReturn(SELF_MANAGED_ACCOUNT);
+        when(mPhoneAccountRegistrar.getPhoneAccount(
+                eq(SELF_MANAGED_HANDLE), any(), anyBoolean())).thenReturn(SELF_MANAGED_ACCOUNT);
         when(mPhoneAccountRegistrar.getPhoneAccount(
                 eq(SIM_1_HANDLE), any())).thenReturn(SIM_1_ACCOUNT);
+        when(mPhoneAccountRegistrar.getPhoneAccount(
+                eq(SIM_1_HANDLE), any(), anyBoolean())).thenReturn(SIM_1_ACCOUNT);
         when(mPhoneAccountRegistrar.getPhoneAccount(
                 eq(SIM_2_HANDLE), any())).thenReturn(SIM_2_ACCOUNT);
+        when(mPhoneAccountRegistrar.getPhoneAccount(
+                eq(SIM_2_HANDLE), any(), anyBoolean())).thenReturn(SIM_2_ACCOUNT);
         when(mPhoneAccountRegistrar.getPhoneAccount(
                 eq(SIM_3_HANDLE), any())).thenReturn(SIM_3_ACCOUNT);
+        when(mPhoneAccountRegistrar.getPhoneAccount(
+                eq(SIM_3_HANDLE), any(), anyBoolean())).thenReturn(SIM_3_ACCOUNT);
         when(mPhoneAccountRegistrar.getPhoneAccount(
                 eq(CALL_PROVIDER_HANDLE), any())).thenReturn(CALL_PROVIDER_ACCOUNT);
+        when(mPhoneAccountRegistrar.getPhoneAccount(
+                eq(CALL_PROVIDER_HANDLE), any(), anyBoolean())).thenReturn(CALL_PROVIDER_ACCOUNT);
         when(mPhoneAccountRegistrar.getPhoneAccount(
                 eq(WORK_HANDLE), any())).thenReturn(WORK_ACCOUNT);
-        when(mFeatureFlags.separatelyBindToBtIncallService()).thenReturn(false);
+        when(mPhoneAccountRegistrar.getPhoneAccount(
+                eq(WORK_HANDLE), any(), anyBoolean())).thenReturn(WORK_ACCOUNT);
         when(mFeatureFlags.telecomResolveHiddenDependencies()).thenReturn(true);
         when(mContext.createContextAsUser(any(UserHandle.class), eq(0)))
                 .thenReturn(mMockCreateContextAsUser);
@@ -758,6 +773,7 @@ public class CallsManagerTest extends TelecomTestCase {
             Uri handle = invocation.getArgument(0);
             CallerInfoLookupHelper.OnQueryCompleteListener listener = invocation.getArgument(1);
             CallerInfo info = new CallerInfo();
+            info.setPhoneNumber(TEST_NUMBER);
             if (CONTACT_PREFERRED_ACCOUNT.get(handle) != null) {
                 PhoneAccountHandle pah = CONTACT_PREFERRED_ACCOUNT.get(handle);
                 info.preferredPhoneAccountComponent = pah.getComponentName();
@@ -1583,7 +1599,7 @@ public class CallsManagerTest extends TelecomTestCase {
         mCallsManager.onMediaButton(HeadsetMediaButton.LONG_PRESS);
 
         // THEN the microphone toggle mute
-        verify(mCallAudioRouteStateMachine)
+        verify(mCallAudioRouteController)
                 .sendMessageWithSessionInfo(CallAudioRouteStateMachine.TOGGLE_MUTE);
     }
 
@@ -1987,6 +2003,29 @@ public class CallsManagerTest extends TelecomTestCase {
         verify(ringingCall).reject(anyBoolean(), any(), any());
     }
 
+    @SmallTest
+    @Test
+    public void testAbortIsPropagatedToClient() {
+        // GIVEN
+        DisconnectCause abortCause = new DisconnectCause(DisconnectCause.CANCELED);
+        TransactionalServiceWrapper tsw = mock(TransactionalServiceWrapper.class);
+        Call connectingCall = addSpyCall(VOIP_1_HANDLE, CallState.CONNECTING);
+        connectingCall.setTransactionServiceWrapper(tsw);
+        connectingCall.setIsTransactionalCall(true);
+
+        // WHEN
+        when(mFeatureFlags.echoAbortTransactionalOutgoing()).thenReturn(true);
+        doReturn(true).when(connectingCall).can(Connection.CAPABILITY_HOLD);
+        connectingCall.disconnect(0, abortCause.getReason());
+
+        // THEN
+        assertTrue(connectingCall.isLocallyDisconnecting());
+        TransactionalServiceWrapper service = connectingCall.getTransactionServiceWrapper();
+        assertNotNull(service);
+        verify(service).onDisconnect(eq(connectingCall), eq(abortCause));
+    }
+
+
     /**
      * Verifies that an anomaly report is triggered when a stuck/zombie call is found and force
      * disconnected when making room for an outgoing call.
@@ -2297,7 +2336,8 @@ public class CallsManagerTest extends TelecomTestCase {
     public void testSpeakerDisabledWhenNoVideoCapabilities() throws Exception {
         Call outgoingCall = addSpyCall(CallState.NEW);
         when(mPhoneAccountRegistrar.getPhoneAccount(
-                any(PhoneAccountHandle.class), any(UserHandle.class))).thenReturn(SIM_1_ACCOUNT);
+                any(PhoneAccountHandle.class), any(UserHandle.class), anyBoolean()))
+                .thenReturn(SIM_1_ACCOUNT);
         mCallsManager.placeOutgoingCall(outgoingCall, TEST_ADDRESS, null, true,
                 VideoProfile.STATE_TX_ENABLED);
         assertFalse(outgoingCall.getStartWithSpeakerphoneOn());
@@ -2867,7 +2907,6 @@ public class CallsManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testOutgoingCallStateIsSetToAPreviousStateAndIgnored() {
-        when(mFeatureFlags.fixAudioFlickerForOutgoingCalls()).thenReturn(true);
         Call outgoingCall = addSpyCall(CallState.CONNECTING);
         mCallsManager.onSuccessfulOutgoingCall(outgoingCall, CallState.NEW);
         verify(outgoingCall, never()).setState(eq(CallState.NEW), any());
@@ -2880,7 +2919,6 @@ public class CallsManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testOutgoingCallStateCanAvoidDialingAndGoStraightToActive() {
-        when(mFeatureFlags.fixAudioFlickerForOutgoingCalls()).thenReturn(true);
         Call outgoingCall = addSpyCall(CallState.CONNECTING);
         mCallsManager.onSuccessfulOutgoingCall(outgoingCall, CallState.ACTIVE);
         verify(outgoingCall, never()).setState(eq(CallState.DIALING), any());
@@ -3413,6 +3451,7 @@ public class CallsManagerTest extends TelecomTestCase {
         verify(mComponentContextFixture.getAudioManager(), times(1)).setStreamVolume(
                 eq(AudioManager.STREAM_VOICE_CALL), anyInt(), anyInt());
     }
+
     @MediumTest
     @Test
     public void testSetCallDialingAndIncreaseVolume() {
@@ -3428,6 +3467,26 @@ public class CallsManagerTest extends TelecomTestCase {
                 eq(AudioManager.STREAM_VOICE_CALL), anyInt(), anyInt());
     }
 
+    @MediumTest
+    @Test
+    public void testSetCallDialingAndCalculateAverageVolume() {
+        // This test specificaslly tests the new behavior guarded by this flag:
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
+
+        // Start with a zero volume stream.
+        mComponentContextFixture.getAudioManager().setStreamVolume(AudioManager.STREAM_VOICE_CALL,
+                0, 0 /* flags */);
+
+        Call call = mock(Call.class);
+        mCallsManager.markCallAsDialing(call);
+
+        // Ensure we calculate the new volume using the average of AudioManager min and max volume:
+        verify(mComponentContextFixture.getAudioManager(), times(1))
+                .getStreamMaxVolume(eq(AudioManager.STREAM_VOICE_CALL));
+        verify(mComponentContextFixture.getAudioManager(), times(1))
+                .getStreamMinVolume(eq(AudioManager.STREAM_VOICE_CALL));
+    }
+
     @MediumTest
     @Test
     public void testSetCallActiveAndDontIncreaseVolume() {
@@ -3691,6 +3750,8 @@ public class CallsManagerTest extends TelecomTestCase {
         assertFalse(mCallsManager.isInSelfManagedCall(TEST_PACKAGE_NAME, TEST_USER_HANDLE));
 
         // WHEN
+        when(mPhoneAccountRegistrar.getPhoneAccount(any(), any(), anyBoolean()))
+                .thenReturn(SM_W_DIFFERENT_PACKAGE_AND_USER);
         when(mPhoneAccountRegistrar.getPhoneAccount(any(), any()))
                 .thenReturn(SM_W_DIFFERENT_PACKAGE_AND_USER);
         // Ensure contact info lookup succeeds
@@ -3761,7 +3822,6 @@ public class CallsManagerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testBindToBtServiceSeparately() {
-        when(mFeatureFlags.separatelyBindToBtIncallService()).thenReturn(true);
         Call call = addSpyCall(CallState.NEW);
         CallFilteringResult result = new CallFilteringResult.Builder()
                 .setShouldAllowCall(true)
@@ -3786,7 +3846,8 @@ public class CallsManagerTest extends TelecomTestCase {
         CallSequencingController sequencingController = mock(CallSequencingController.class);
         CallAudioManager callAudioManager = mock(CallAudioManager.class);
         CallsManagerCallSequencingAdapter adapter = new CallsManagerCallSequencingAdapter(
-                mCallsManager, mContext, sequencingController, callAudioManager, mFeatureFlags);
+                mCallsManager, mContext, sequencingController, callAudioManager,
+                mMockTelecomMetricsController, mFeatureFlags);
         mCallsManager.setCallSequencingAdapter(adapter);
         // Explicitly disable simultaneous calling
         TelephonyManager mockTelephonyManager = mComponentContextFixture.getTelephonyManager();
@@ -3839,6 +3900,49 @@ public class CallsManagerTest extends TelecomTestCase {
         assertTrue(mCallsManager.getPendingAccountSelection().containsKey(pendingCall.getId()));
     }
 
+    @SmallTest
+    @Test
+    public void testIgnoreMaxRingingCallOnSameNumber() {
+        verifyMaxRingingCallNoError(SIM_1_HANDLE, TEST_ADDRESS);
+    }
+
+    @SmallTest
+    @Test
+    public void testIgnoreMaxRingingCallOnSamePhoneAccount() {
+        verifyMaxRingingCallNoError(SIM_2_HANDLE, TEST_ADDRESS2);
+    }
+
+    private void verifyMaxRingingCallNoError(PhoneAccountHandle handle, Uri address) {
+        when(mFeatureFlags.enableCallSequencing()).thenReturn(true);
+        when(mFeatureFlags.allowCallOnSameConnectionMgr()).thenReturn(true);
+        setupCallerInfoLookupHelper();
+        ConnectionServiceWrapper service = mock(ConnectionServiceWrapper.class);
+        doReturn(handle.getComponentName()).when(service).getComponentName();
+        mCallsManager.addConnectionServiceRepositoryCache(handle.getComponentName(),
+                handle.getUserHandle(), service);
+        when(mPhoneAccountRegistrar.phoneAccountRequiresBindPermission(
+                any(PhoneAccountHandle.class))).thenReturn(true);
+
+        // WHEN
+        Call existingIncomingCall = createCall(SIM_2_HANDLE, CallState.RINGING);
+        mCallsManager.addCall(existingIncomingCall);
+        PhoneAccountHandle connectionMgr = mock(PhoneAccountHandle.class);
+        existingIncomingCall.setConnectionManagerPhoneAccount(connectionMgr);
+        when(mPhoneAccountRegistrar.getSimCallManagerFromCall(any(Call.class)))
+                .thenReturn(connectionMgr);
+        when(mMockCurrentUserManager.isAdminUser()).thenReturn(true);
+
+        // THEN, add a new incoming call with the same number as the 1st call
+        Bundle extras = new Bundle();
+        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, address);
+        Call newCall = mCallsManager.processIncomingCallIntent(handle, extras, false);
+        // Verify we don't mark the call as auto missed and that the connection doesn't fail
+        // locally.
+        assertEquals(existingIncomingCall, mCallsManager.getRingingOrSimulatedRingingCall());
+        assertEquals(newCall.getMissedReason(), MISSED_REASON_NOT_MISSED);
+        verify(service, never()).createConnectionFailed(any());
+    }
+
     private Call addSpyCall() {
         return addSpyCall(SIM_2_HANDLE, CallState.ACTIVE);
     }
@@ -3971,7 +4075,8 @@ public class CallsManagerTest extends TelecomTestCase {
         // Remap the PhoneAccounts to inherit the restriction set
         for (PhoneAccountHandle callCapableHandle : callCapableHandles) {
             PhoneAccount pa = mPhoneAccountRegistrar.getPhoneAccount(
-                    callCapableHandle, callCapableHandle.getUserHandle());
+                    callCapableHandle, callCapableHandle.getUserHandle(),
+                    true /* across profiles */);
             assertNotNull("test setup error: could not find PA for PAH:" + callCapableHandle,
                     pa);
             // For simplicity, for testing only apply restrictions to SIM accounts
@@ -3984,7 +4089,7 @@ public class CallsManagerTest extends TelecomTestCase {
                         .setSimultaneousCallingRestriction(Collections.emptySet()).build();
             }
             when(mPhoneAccountRegistrar.getPhoneAccount(eq(callCapableHandle),
-                    any())).thenReturn(pa);
+                    any(), anyBoolean())).thenReturn(pa);
         }
     }
 
@@ -4001,7 +4106,6 @@ public class CallsManagerTest extends TelecomTestCase {
             boolean expectOnResult)
             throws InterruptedException {
         CountDownLatch latch = new CountDownLatch(1);
-        when(mFeatureFlags.transactionalHoldDisconnectsUnholdable()).thenReturn(true);
         when(mConnectionSvrFocusMgr.getCurrentFocusCall()).thenReturn(activeCall);
         mCallsManager.getCallSequencingAdapter().transactionHoldPotentialActiveCallForNewCall(
                 newCall,
diff --git a/tests/src/com/android/server/telecom/tests/ComponentContextFixture.java b/tests/src/com/android/server/telecom/tests/ComponentContextFixture.java
index 12612652c..9a972a4e0 100644
--- a/tests/src/com/android/server/telecom/tests/ComponentContextFixture.java
+++ b/tests/src/com/android/server/telecom/tests/ComponentContextFixture.java
@@ -46,6 +46,7 @@ import android.content.IContentProvider;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.ServiceConnection;
+import android.content.SharedPreferences;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
@@ -74,6 +75,7 @@ import android.os.UserManager;
 import android.os.Vibrator;
 import android.os.VibratorManager;
 import android.permission.PermissionCheckerManager;
+import android.permission.PermissionManager;
 import android.provider.BlockedNumbersManager;
 import android.telecom.ConnectionService;
 import android.telecom.Log;
@@ -261,6 +263,8 @@ public class ComponentContextFixture implements TestFixture<Context> {
                     return mBlockedNumbersManager;
                 case Context.STATS_MANAGER_SERVICE:
                     return mStatsManager;
+                case Context.PERMISSION_SERVICE:
+                    return mPermissionManager;
                 default:
                     return null;
             }
@@ -308,6 +312,8 @@ public class ComponentContextFixture implements TestFixture<Context> {
                 return Context.APP_OPS_SERVICE;
             } else if (svcClass == StatsManager.class) {
                 return Context.STATS_MANAGER_SERVICE;
+            } else if (svcClass == PermissionManager.class) {
+                return Context.PERMISSION_SERVICE;
             }
             throw new UnsupportedOperationException(svcClass.getName());
         }
@@ -417,6 +423,13 @@ public class ComponentContextFixture implements TestFixture<Context> {
             return null;
         }
 
+        @Override
+        public Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle handle,
+                IntentFilter filter, String broadcastPermission, Handler scheduler, int flags) {
+            mBroadcastReceivers.add(receiver);
+            return null;
+        }
+
         @Override
         public void sendBroadcast(Intent intent) {
             // TODO -- need to ensure this is captured
@@ -500,6 +513,12 @@ public class ComponentContextFixture implements TestFixture<Context> {
         public void startActivityAsUser(Intent intent, UserHandle userHandle) {
             // For capturing
         }
+
+        @Override
+        public SharedPreferences getSharedPreferences(String name, int mode) {
+            return mSharedPreferences;
+        }
+
     }
 
     public class FakeAudioManager extends AudioManager {
@@ -628,6 +647,7 @@ public class ComponentContextFixture implements TestFixture<Context> {
     private final TelephonyManager mTelephonyManager = mock(TelephonyManager.class);
     private final LocationManager mLocationManager = mock(LocationManager.class);
     private final AppOpsManager mAppOpsManager = mock(AppOpsManager.class);
+    private final PermissionManager mPermissionManager = mock(PermissionManager.class);
     private final NotificationManager mNotificationManager = mock(NotificationManager.class);
     private final AccessibilityManager mAccessibilityManager = mock(AccessibilityManager.class);
     private final UserManager mUserManager = mock(UserManager.class);
@@ -650,6 +670,7 @@ public class ComponentContextFixture implements TestFixture<Context> {
     private final SensorPrivacyManager mSensorPrivacyManager = mock(SensorPrivacyManager.class);
     private final List<BroadcastReceiver> mBroadcastReceivers = new ArrayList<>();
     private final StatsManager mStatsManager = mock(StatsManager.class);
+    private final SharedPreferences mSharedPreferences = mock(SharedPreferences.class);
 
     private TelecomManager mTelecomManager = mock(TelecomManager.class);
     private BlockedNumbersManager mBlockedNumbersManager = mock(BlockedNumbersManager.class);
diff --git a/tests/src/com/android/server/telecom/tests/CreateConnectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CreateConnectionProcessorTest.java
index 406bc8af4..fc2dfc078 100644
--- a/tests/src/com/android/server/telecom/tests/CreateConnectionProcessorTest.java
+++ b/tests/src/com/android/server/telecom/tests/CreateConnectionProcessorTest.java
@@ -60,6 +60,7 @@ import com.android.server.telecom.CreateConnectionResponse;
 import com.android.server.telecom.CreateConnectionTimeout;
 import com.android.server.telecom.PhoneAccountRegistrar;
 import com.android.server.telecom.Timeouts;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -164,7 +165,7 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
                 thenReturn(Binder.getCallingUserHandle());
 
         mTestCreateConnectionTimeout = new CreateConnectionTimeout(mContext, mMockAccountRegistrar,
-                makeConnectionServiceWrapper(), mMockCall, mTimeoutsAdapter);
+                makeConnectionServiceWrapper(), mMockCall, mFeatureFlags, mTimeoutsAdapter);
     }
 
     @Override
@@ -224,7 +225,11 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
         // Include a Connection Manager
         PhoneAccountHandle callManagerPAHandle = getNewConnectionManagerHandleForCall(mMockCall,
                 "cm_acct");
+        // Get the mock service for the Connection Manager
         ConnectionServiceWrapper service = makeConnMgrConnectionServiceWrapper();
+        // Get the mock service for the Target Phone Account
+        ConnectionServiceWrapper targetService = makeConnectionServiceWrapper();
+
         // Make sure the target phone account has the correct permissions
         PhoneAccount mFakeTargetPhoneAccount = makeQuickAccount("cm_acct",
                 PhoneAccount.CAPABILITY_SIM_SUBSCRIPTION, null);
@@ -235,7 +240,8 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
 
         verify(mMockCall).setConnectionManagerPhoneAccount(eq(callManagerPAHandle));
         verify(mMockCall).setTargetPhoneAccount(eq(pAHandle));
-        verify(mMockCall).setConnectionService(eq(service));
+        // Verify the TWO-argument setConnectionService was called
+        verify(mMockCall).setConnectionService(eq(service), eq(targetService));
         verify(service).createConnection(eq(mMockCall),
                 any(CreateConnectionResponse.class));
         // Notify successful connection to call
@@ -247,8 +253,6 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testConnectionManagerConnectionServiceSuccess() throws Exception {
-        when(mFeatureFlags.updatedRcsCallCountTracking()).thenReturn(true);
-
         // Configure the target phone account as the remote connection service:
         PhoneAccountHandle pAHandle = getNewTargetPhoneAccountHandle("tel_acct");
         setTargetPhoneAccount(mMockCall, pAHandle);
@@ -751,7 +755,7 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
         verify(mMockCall).setConnectionManagerPhoneAccount(
                 eq(emerCallManagerPA.getAccountHandle()));
         verify(mMockCall).setTargetPhoneAccount(eq(regularAccount.getAccountHandle()));
-        verify(mMockCall).setConnectionService(eq(service));
+        verify(mMockCall).setConnectionService(eq(service), eq(service));
         verify(service).createConnection(eq(mMockCall), any(CreateConnectionResponse.class));
     }
 
@@ -879,9 +883,10 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
         when(mMockAccountRegistrar.getPhoneAccount(eq(callManagerPA.getAccountHandle()),
                 any())).thenReturn(callManagerPA);
         Duration timeout = Duration.ofMillis(10);
-        when(mTimeoutsAdapter.getEmergencyCallTimeoutMillis(any())).thenReturn(timeout.toMillis());
-        when(mTimeoutsAdapter.getEmergencyCallTimeoutRadioOffMillis(any())).thenReturn(
-                timeout.toMillis());
+        when(mTimeoutsAdapter.getEmergencyCallTimeoutMillis(any(), any(FeatureFlags.class)))
+                .thenReturn(timeout.toMillis());
+        when(mTimeoutsAdapter.getEmergencyCallTimeoutRadioOffMillis(any(), any(FeatureFlags.class)))
+                .thenReturn(timeout.toMillis());
 
 
         mTestCreateConnectionProcessor.process();
@@ -917,9 +922,10 @@ public class CreateConnectionProcessorTest extends TelecomTestCase {
         when(mMockAccountRegistrar.getPhoneAccount(eq(callManagerPA.getAccountHandle()),
                 any())).thenReturn(callManagerPA);
         Duration timeout = Duration.ofMillis(10);
-        when(mTimeoutsAdapter.getEmergencyCallTimeoutMillis(any())).thenReturn(timeout.toMillis());
-        when(mTimeoutsAdapter.getEmergencyCallTimeoutRadioOffMillis(any())).thenReturn(
-                timeout.toMillis());
+        when(mTimeoutsAdapter.getEmergencyCallTimeoutMillis(any(), any(FeatureFlags.class)))
+                .thenReturn(timeout.toMillis());
+        when(mTimeoutsAdapter.getEmergencyCallTimeoutRadioOffMillis(any(), any(FeatureFlags.class)))
+                .thenReturn(timeout.toMillis());
 
         mTestCreateConnectionProcessor.process();
 
diff --git a/tests/src/com/android/server/telecom/tests/DefaultDialerCacheTest.java b/tests/src/com/android/server/telecom/tests/DefaultDialerCacheTest.java
index ecabf64f4..47e703dee 100644
--- a/tests/src/com/android/server/telecom/tests/DefaultDialerCacheTest.java
+++ b/tests/src/com/android/server/telecom/tests/DefaultDialerCacheTest.java
@@ -18,6 +18,7 @@ package com.android.server.telecom.tests;
 
 import static org.junit.Assert.assertEquals;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.times;
@@ -67,24 +68,28 @@ public class DefaultDialerCacheTest extends TelecomTestCase {
     private DefaultDialerCache.DefaultDialerManagerAdapter mMockDefaultDialerManager;
     @Mock
     private RoleManagerAdapter mRoleManagerAdapter;
+    @Mock private Context mUserContext;
+    @Mock private UserHandle mDefaultUserHandle;
 
     @Override
     @Before
     public void setUp() throws Exception {
         super.setUp();
         mContext = mComponentContextFixture.getTestDouble().getApplicationContext();
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
+        when(mContext.createContextAsUser(any(UserHandle.class), anyInt()))
+                .thenReturn(mUserContext);
 
         ArgumentCaptor<BroadcastReceiver> packageReceiverCaptor =
                 ArgumentCaptor.forClass(BroadcastReceiver.class);
 
         mDefaultDialerCache = new DefaultDialerCache(
                 mContext, mMockDefaultDialerManager, mRoleManagerAdapter,
-                new TelecomSystem.SyncRoot() {
-                });
+                new TelecomSystem.SyncRoot() {}, mFeatureFlags);
 
-        verify(mContext, times(2)).registerReceiverAsUser(
-                packageReceiverCaptor.capture(), eq(UserHandle.ALL), any(IntentFilter.class),
-                isNull(), isNull());
+        verify(mUserContext, times(2)).registerReceiver(
+                packageReceiverCaptor.capture(), any(IntentFilter.class),
+                eq(Context.RECEIVER_NOT_EXPORTED));
         // Receive the first receiver that was captured, the package change receiver.
         mPackageChangeReceiver = packageReceiverCaptor.getAllValues().get(0);
 
@@ -105,6 +110,10 @@ public class DefaultDialerCacheTest extends TelecomTestCase {
         when(mRoleManagerAdapter.getDefaultDialerApp(eq(USER0))).thenReturn(DIALER1);
         when(mRoleManagerAdapter.getDefaultDialerApp(eq(USER1))).thenReturn(DIALER2);
         when(mRoleManagerAdapter.getDefaultDialerApp(eq(USER2))).thenReturn(DIALER3);
+
+        // This test implies user 0 is the default user
+        when(mDefaultUserHandle.getIdentifier()).thenReturn(USER0);
+        when(mContext.getUser()).thenReturn(mDefaultUserHandle);
     }
 
     @Override
diff --git a/tests/src/com/android/server/telecom/tests/DisconnectedCallNotifierTest.java b/tests/src/com/android/server/telecom/tests/DisconnectedCallNotifierTest.java
index 3eacc54db..b0529010a 100644
--- a/tests/src/com/android/server/telecom/tests/DisconnectedCallNotifierTest.java
+++ b/tests/src/com/android/server/telecom/tests/DisconnectedCallNotifierTest.java
@@ -6,6 +6,7 @@ import static org.junit.Assert.assertNull;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -48,6 +49,7 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
 
     @Mock private CallsManager mCallsManager;
     @Mock private CallerInfoLookupHelper mCallerInfoLookupHelper;
+    @Mock private Context mUserContext;
 
     private NotificationManager mNotificationManager;
 
@@ -60,10 +62,15 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
 
         mNotificationManager = (NotificationManager) mContext.getSystemService(
                 Context.NOTIFICATION_SERVICE);
+        when(mContext.createContextAsUser(any(UserHandle.class), eq(0)))
+                .thenReturn(mUserContext);
+        when(mUserContext.getSystemService(eq(NotificationManager.class)))
+                .thenReturn(mNotificationManager);
         TelephonyManager fakeTelephonyManager = (TelephonyManager) mContext.getSystemService(
                 Context.TELEPHONY_SERVICE);
         when(fakeTelephonyManager.getNetworkCountryIso()).thenReturn("US");
         doReturn(mCallerInfoLookupHelper).when(mCallsManager).getCallerInfoLookupHelper();
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
     }
 
     @After
@@ -78,17 +85,18 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
         Call call = createCall(new DisconnectCause(DisconnectCause.LOCAL,
                 DisconnectCause.REASON_EMERGENCY_CALL_PLACED));
 
-        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager);
+        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager,
+                mFeatureFlags);
         notifier.onCallStateChanged(call, CallState.NEW, CallState.DIALING);
         notifier.onCallStateChanged(call, CallState.DIALING, CallState.DISCONNECTED);
-        verify(mNotificationManager, never()).notifyAsUser(anyString(), anyInt(),
-                any(Notification.class), any(UserHandle.class));
+        verify(mNotificationManager, never()).notify(anyString(), anyInt(),
+                any(Notification.class));
 
         doReturn(Collections.EMPTY_LIST).when(mCallsManager).getCalls();
         notifier.onCallRemoved(call);
         ArgumentCaptor<Notification> captor = ArgumentCaptor.forClass(Notification.class);
-        verify(mNotificationManager).notifyAsUser(anyString(), anyInt(),
-                captor.capture(), any(UserHandle.class));
+        verify(mNotificationManager).notify(anyString(), anyInt(),
+                captor.capture());
         Notification notification = captor.getValue();
         assertNotNull(notification.contentIntent);
         assertEquals(2, notification.actions.length);
@@ -101,17 +109,18 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
                 DisconnectCause.REASON_EMERGENCY_CALL_PLACED));
         when(call.isEmergencyCall()).thenReturn(true);
 
-        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager);
+        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager,
+                mFeatureFlags);
         notifier.onCallStateChanged(call, CallState.NEW, CallState.DIALING);
         notifier.onCallStateChanged(call, CallState.DIALING, CallState.DISCONNECTED);
-        verify(mNotificationManager, never()).notifyAsUser(anyString(), anyInt(),
-                any(Notification.class), any(UserHandle.class));
+        verify(mNotificationManager, never()).notify(anyString(), anyInt(),
+                any(Notification.class));
 
         doReturn(Collections.EMPTY_LIST).when(mCallsManager).getCalls();
         notifier.onCallRemoved(call);
         ArgumentCaptor<Notification> captor = ArgumentCaptor.forClass(Notification.class);
-        verify(mNotificationManager).notifyAsUser(anyString(), anyInt(),
-                captor.capture(), any(UserHandle.class));
+        verify(mNotificationManager).notify(anyString(), anyInt(),
+                captor.capture());
         Notification notification = captor.getValue();
         assertNull(notification.contentIntent);
         if (notification.actions != null) {
@@ -124,15 +133,16 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
     public void testNotificationNotShownAfterCall() {
         Call call = createCall(new DisconnectCause(DisconnectCause.LOCAL));
 
-        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager);
+        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager,
+                mFeatureFlags);
         notifier.onCallStateChanged(call, CallState.DIALING, CallState.DISCONNECTED);
-        verify(mNotificationManager, never()).notifyAsUser(anyString(), anyInt(),
-                any(Notification.class), any(UserHandle.class));
+        verify(mNotificationManager, never()).notify(anyString(), anyInt(),
+                any(Notification.class));
 
         doReturn(Collections.EMPTY_LIST).when(mCallsManager).getCalls();
         notifier.onCallRemoved(call);
-        verify(mNotificationManager, never()).notifyAsUser(anyString(), anyInt(),
-                any(Notification.class), any(UserHandle.class));
+        verify(mNotificationManager, never()).notify(anyString(), anyInt(),
+                any(Notification.class));
     }
 
     @Test
@@ -141,9 +151,10 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
         Call call = createCall(new DisconnectCause(DisconnectCause.LOCAL,
                 DisconnectCause.REASON_EMERGENCY_CALL_PLACED));
 
-        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager);
+        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager,
+                mFeatureFlags);
         notifier.onCallStateChanged(call, CallState.DIALING, CallState.DISCONNECTED);
-        verify(mNotificationManager).cancelAsUser(anyString(), anyInt(), any());
+        verify(mNotificationManager).cancel(anyString(), anyInt());
     }
 
     /**
@@ -153,7 +164,8 @@ public class DisconnectedCallNotifierTest extends TelecomTestCase {
     @Test
     @SmallTest
     public void testGetCountryIsoWithNoTelephony() {
-        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager);
+        DisconnectedCallNotifier notifier = new DisconnectedCallNotifier(mContext, mCallsManager,
+                mFeatureFlags);
         when(mComponentContextFixture.getTelephonyManager().getNetworkCountryIso())
                 .thenThrow(new UnsupportedOperationException("Bee boop"));
         assertNotNull(notifier.getCurrentCountryIso(mContext));
diff --git a/tests/src/com/android/server/telecom/tests/DtmfLocalTonePlayerTest.java b/tests/src/com/android/server/telecom/tests/DtmfLocalTonePlayerTest.java
index 5ccfc385d..750a91a20 100644
--- a/tests/src/com/android/server/telecom/tests/DtmfLocalTonePlayerTest.java
+++ b/tests/src/com/android/server/telecom/tests/DtmfLocalTonePlayerTest.java
@@ -49,7 +49,7 @@ public class DtmfLocalTonePlayerTest extends TelecomTestCase {
     public void setUp() throws Exception {
         super.setUp();
         mContext = mComponentContextFixture.getTestDouble().getApplicationContext();
-        mPlayer = new DtmfLocalTonePlayer(mToneProxy);
+        mPlayer = new DtmfLocalTonePlayer(mToneProxy, mFeatureFlags);
         when(mCall.getContext()).thenReturn(mContext);
     }
 
diff --git a/tests/src/com/android/server/telecom/tests/EmergencyCallHelperTest.java b/tests/src/com/android/server/telecom/tests/EmergencyCallHelperTest.java
index cc1c38a19..131fb003b 100644
--- a/tests/src/com/android/server/telecom/tests/EmergencyCallHelperTest.java
+++ b/tests/src/com/android/server/telecom/tests/EmergencyCallHelperTest.java
@@ -32,6 +32,7 @@ import static org.mockito.Mockito.when;
 
 import android.content.ComponentName;
 import android.content.ContentResolver;
+import android.content.Context;
 import android.content.pm.PackageManager;
 import android.os.UserHandle;
 import android.telecom.PhoneAccountHandle;
@@ -42,6 +43,7 @@ import com.android.server.telecom.Call;
 import com.android.server.telecom.DefaultDialerCache;
 import com.android.server.telecom.EmergencyCallHelper;
 import com.android.server.telecom.Timeouts;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -90,8 +92,8 @@ public class EmergencyCallHelperTest extends TelecomTestCase {
     when(mCall.isEmergencyCall()).thenReturn(true);
     when(mContext.getResources().getBoolean(R.bool.grant_location_permission_enabled)).thenReturn(
         true);
-    when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class))).thenReturn(
-            5000L);
+    when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+            any(FeatureFlags.class))).thenReturn(5000L);
   }
 
   @Override
diff --git a/tests/src/com/android/server/telecom/tests/InCallControllerTests.java b/tests/src/com/android/server/telecom/tests/InCallControllerTests.java
index bea3fe3a7..fc1953fd2 100644
--- a/tests/src/com/android/server/telecom/tests/InCallControllerTests.java
+++ b/tests/src/com/android/server/telecom/tests/InCallControllerTests.java
@@ -34,6 +34,7 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
@@ -75,11 +76,14 @@ import android.os.Handler;
 import android.os.IBinder;
 import android.os.Looper;
 import android.os.Process;
+import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.permission.PermissionCheckerManager;
+import android.permission.PermissionManager;
 import android.telecom.CallAudioState;
 import android.telecom.CallEndpoint;
+import android.telecom.Connection;
 import android.telecom.InCallService;
 import android.telecom.ParcelableCall;
 import android.telecom.PhoneAccountHandle;
@@ -97,6 +101,7 @@ import com.android.server.telecom.Analytics;
 import com.android.server.telecom.AnomalyReporterAdapter;
 import com.android.server.telecom.Call;
 import com.android.server.telecom.CallEndpointController;
+import com.android.server.telecom.CallState;
 import com.android.server.telecom.CallsManager;
 import com.android.server.telecom.CarModeTracker;
 import com.android.server.telecom.ClockProxy;
@@ -110,6 +115,7 @@ import com.android.server.telecom.RoleManagerAdapter;
 import com.android.server.telecom.SystemStateHelper;
 import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.Timeouts;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -160,6 +166,7 @@ public class InCallControllerTests extends TelecomTestCase {
     @Mock Context mMockCreateContextAsUser;
     @Mock UserManager mMockCurrentUserManager;
     @Mock CallEndpointController mMockCallEndpointController;
+    @Mock PermissionManager mPermissionManager;
 
     @Rule
     public TestRule compatChangeRule = new PlatformCompatChangeRule();
@@ -221,6 +228,7 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockCall.getId()).thenReturn("TC@1");
         doReturn(mMockResources).when(mMockContext).getResources();
         doReturn(mMockAppOpsManager).when(mMockContext).getSystemService(AppOpsManager.class);
+        doReturn(mPermissionManager).when(mMockContext).getSystemService(PermissionManager.class);
         doReturn(SYS_PKG).when(mMockResources).getString(
                 com.android.internal.R.string.config_defaultDialer);
         doReturn(SYS_CLASS).when(mMockResources).getString(R.string.incall_default_class);
@@ -232,8 +240,6 @@ public class InCallControllerTests extends TelecomTestCase {
         mEmergencyCallHelper = new EmergencyCallHelper(mMockContext, mDefaultDialerCache,
                 mTimeoutsAdapter, mFeatureFlags);
         when(mMockCallsManager.getRoleManagerAdapter()).thenReturn(mMockRoleManagerAdapter);
-        when(mMockContext.getSystemService(eq(Context.NOTIFICATION_SERVICE)))
-                .thenReturn(mNotificationManager);
         when(mMockContext.getSystemService(eq(PermissionCheckerManager.class)))
                 .thenReturn(mMockPermissionCheckerManager);
         when(mMockPackageManager.getPermissionInfo(anyString(), anyInt())).thenReturn(
@@ -243,12 +249,15 @@ public class InCallControllerTests extends TelecomTestCase {
         mInCallController = new InCallController(mMockContext, mLock, mMockCallsManager,
                 mMockSystemStateHelper, mDefaultDialerCache, mTimeoutsAdapter,
                 mEmergencyCallHelper, mCarModeTracker, mClockProxy, mFeatureFlags);
+        when(mMockContext.createContextAsUser(any(UserHandle.class), eq(0)))
+                .thenReturn(mMockCreateContextAsUser);
+        when(mMockCreateContextAsUser.getPackageManager()).thenReturn(mMockPackageManager);
         // Capture the broadcast receiver registered.
         doAnswer(invocation -> {
             mRegisteredReceiver = invocation.getArgument(0);
             return null;
-        }).when(mMockContext).registerReceiverAsUser(any(BroadcastReceiver.class),
-                any(), any(IntentFilter.class), any(), any());
+        }).when(mMockCreateContextAsUser).registerReceiver(any(BroadcastReceiver.class),
+                any(IntentFilter.class), any(), any());
 
         ArgumentCaptor<SystemStateHelper.SystemStateListener> systemStateListenerArgumentCaptor
                 = ArgumentCaptor.forClass(SystemStateHelper.SystemStateListener.class);
@@ -310,7 +319,6 @@ public class InCallControllerTests extends TelecomTestCase {
                 .thenReturn(PackageManager.PERMISSION_DENIED);
 
         when(mMockCallsManager.getAudioState()).thenReturn(new CallAudioState(false, 0, 0));
-        when(mFeatureFlags.onCallEndpointChangedIcsOnConnected()).thenReturn(true);
         when(mMockCallsManager.getCallEndpointController()).thenReturn(mMockCallEndpointController);
         when(mMockCallEndpointController.getCurrentCallEndpoint())
                 .thenReturn(new CallEndpoint("Earpiece", 1));
@@ -318,15 +326,15 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockContext.getSystemService(eq(Context.USER_SERVICE))).thenReturn(mMockUserManager);
         when(mMockContext.getSystemService(eq(UserManager.class)))
                 .thenReturn(mMockUserManager);
-        when(mMockContext.createContextAsUser(any(UserHandle.class), eq(0)))
-                .thenReturn(mMockCreateContextAsUser);
         when(mMockCreateContextAsUser.getSystemService(eq(UserManager.class)))
                 .thenReturn(mMockCurrentUserManager);
+        when(mMockCreateContextAsUser.getSystemService(eq(NotificationManager.class)))
+                .thenReturn(mNotificationManager);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
         // Mock user info to allow binding on user stored in the phone account (mUserHandle).
-        when(mFeatureFlags.separatelyBindToBtIncallService()).thenReturn(false);
         when(mFeatureFlags.telecomResolveHiddenDependencies()).thenReturn(true);
         when(mMockCurrentUserManager.isManagedProfile()).thenReturn(true);
-        when(mFeatureFlags.profileUserSupport()).thenReturn(false);
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
     }
 
     @Override
@@ -412,8 +420,8 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockCall.isIncoming()).thenReturn(true);
         when(mMockCall.isExternalCall()).thenReturn(false);
         when(mMockCall.getTargetPhoneAccount()).thenReturn(PA_HANDLE);
-        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class)))
-                .thenReturn(300_000L);
+        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(300_000L);
 
         setupMockPackageManager(false /* default */, true /* system */, false /* external calls */);
         mInCallController.bindToServices(mMockCall);
@@ -446,8 +454,8 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockCall.getTargetPhoneAccount()).thenReturn(PA_HANDLE);
         when(mMockCall.getIntentExtras()).thenReturn(callExtras);
         when(mMockCall.isExternalCall()).thenReturn(false);
-        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class)))
-                .thenReturn(300_000L);
+        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(300_000L);
 
         Intent queryIntent = new Intent(InCallService.SERVICE_INTERFACE);
         setupMockPackageManager(false /* default */, true /* system */, false /* external calls */);
@@ -547,8 +555,8 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockContext.bindServiceAsUser(any(Intent.class), any(ServiceConnection.class),
                 eq(serviceBindingFlags),
                 eq(mUserHandle))).thenReturn(true);
-        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class)))
-                .thenReturn(300_000L);
+        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(300_000L);
 
         setupMockPackageManager(true /* default */, true /* system */, false /* external calls */);
         setupMockPackageManagerLocationPermission(SYS_PKG, false /* granted */);
@@ -752,8 +760,8 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockContext.bindServiceAsUser(any(Intent.class), serviceConnectionCaptor.capture(),
                 eq(serviceBindingFlags),
                 eq(mUserHandle))).thenReturn(true);
-        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class)))
-                .thenReturn(300_000L);
+        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(300_000L);
 
         setupMockPackageManager(true /* default */, true /* system */, false /* external calls */);
         setupMockPackageManagerLocationPermission(SYS_PKG, false /* granted */);
@@ -943,9 +951,8 @@ public class InCallControllerTests extends TelecomTestCase {
         // verify(mockInCallService).setInCallAdapter(any(IInCallAdapter.class));
         serviceConnection.onNullBinding(defDialerComponentName);
 
-        verify(mNotificationManager).notifyAsUser(eq(NOTIFICATION_TAG),
-                eq(IN_CALL_SERVICE_NOTIFICATION_ID), any(Notification.class),
-                eq(mUserHandle));
+        verify(mNotificationManager).notify(eq(NOTIFICATION_TAG),
+                eq(IN_CALL_SERVICE_NOTIFICATION_ID), any(Notification.class));
         verify(mCallInfo).addInCallService(eq(defDialerComponentName.flattenToShortString()),
                 anyInt(), anyLong(), eq(true));
 
@@ -1031,8 +1038,8 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockContext.bindServiceAsUser(any(Intent.class), serviceConnectionCaptor.capture(),
                 eq(serviceBindingFlags),
                 eq(mUserHandle))).thenReturn(true);
-        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class)))
-                .thenReturn(300_000L);
+        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(300_000L);
 
         // Setup package manager; there is a dialer and disable non-ui ICS
         when(mMockPackageManager.queryIntentServicesAsUser(
@@ -1146,8 +1153,8 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockContext.bindServiceAsUser(any(Intent.class), serviceConnectionCaptor.capture(),
                 eq(serviceBindingFlags),
                 eq(mUserHandle))).thenReturn(true);
-        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(ContentResolver.class)))
-                .thenReturn(300_000L);
+        when(mTimeoutsAdapter.getEmergencyCallbackWindowMillis(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(300_000L);
 
         // Setup package manager; there is a dialer and disable non-ui ICS
         when(mMockPackageManager.queryIntentServicesAsUser(
@@ -1169,7 +1176,7 @@ public class InCallControllerTests extends TelecomTestCase {
         mInCallController.onCallAdded(mMockCall);
 
         // There will be 4 calls for the various types of ICS; this is normal.
-        verify(mMockPackageManager, times(4)).queryIntentServicesAsUser(
+        verify(mMockPackageManager, atLeastOnce()).queryIntentServicesAsUser(
                 any(Intent.class),
                 eq(PackageManager.GET_META_DATA | PackageManager.MATCH_DISABLED_COMPONENTS),
                 eq(CURRENT_USER_ID));
@@ -1267,7 +1274,7 @@ public class InCallControllerTests extends TelecomTestCase {
                 nullable(ServiceConnection.class), anyInt(), nullable(UserHandle.class)))
                 .thenReturn(true);
         when(mTimeoutsAdapter.getCallRemoveUnbindInCallServicesDelay(
-                nullable(ContentResolver.class))).thenReturn(500L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(500L);
 
         when(mMockCallsManager.getCalls()).thenReturn(Collections.singletonList(mMockCall));
         setupMockPackageManager(true /* default */, true /* system */, false /* external calls */);
@@ -1452,10 +1459,9 @@ public class InCallControllerTests extends TelecomTestCase {
         verifyBinding(bindIntentCaptor, 0, NONUI_PKG, NONUI_CLASS);
 
         // Verify notification is not sent by NotificationManager
-        verify(mNotificationManager, times(0)).notifyAsUser(
+        verify(mNotificationManager, times(0)).notify(
                 eq(InCallController.NOTIFICATION_TAG),
-                eq(InCallController.IN_CALL_SERVICE_NOTIFICATION_ID), any(),
-                eq(mUserHandle));
+                eq(InCallController.IN_CALL_SERVICE_NOTIFICATION_ID), any());
     }
 
     @MediumTest
@@ -1591,7 +1597,7 @@ public class InCallControllerTests extends TelecomTestCase {
                 nullable(ServiceConnection.class), anyInt(), nullable(UserHandle.class)))
                 .thenReturn(true);
         when(mTimeoutsAdapter.getCallRemoveUnbindInCallServicesDelay(
-                nullable(ContentResolver.class))).thenReturn(500L);
+                nullable(Context.class), any(FeatureFlags.class))).thenReturn(500L);
 
         when(mMockCallsManager.getCalls()).thenReturn(Collections.singletonList(mMockCall));
         setupMockPackageManager(true /* default */, true /* nonui */, false /* appop_nonui */ ,
@@ -1870,7 +1876,6 @@ public class InCallControllerTests extends TelecomTestCase {
 
     @Test
     public void testRemoveAllServiceConnections_MultiUser() throws Exception {
-        when(mFeatureFlags.associatedUserRefactorForWorkProfile()).thenReturn(true);
         setupMocks(false /* isExternalCall */);
         setupMockPackageManager(true /* default */, true /* system */, false /* external calls */);
         UserHandle workUser = new UserHandle(12);
@@ -1943,7 +1948,6 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockChildUserCall.getAssociatedUser()).thenReturn(mChildUserHandle);
         when(mMockCallsManager.getCurrentUserHandle()).thenReturn(mParentUserHandle);
         when(mMockUserManager.getProfileParent(mChildUserHandle)).thenReturn(mParentUserHandle);
-        when(mFeatureFlags.profileUserSupport()).thenReturn(true);
     }
 
     /**
@@ -1957,7 +1961,6 @@ public class InCallControllerTests extends TelecomTestCase {
         when(mMockChildUserCall.getAssociatedUser()).thenReturn(mChildUserHandle);
         when(mMockCallsManager.getCurrentUserHandle()).thenReturn(mParentUserHandle);
         when(mMockUserManager.getProfileParent(mChildUserHandle)).thenReturn(mParentUserHandle);
-        when(mFeatureFlags.profileUserSupport()).thenReturn(true);
         when(mMockContext.getSystemService(eq(UserManager.class)))
                 .thenReturn(mMockUserManager);
         // verify a NullPointerException is not thrown
@@ -2003,7 +2006,6 @@ public class InCallControllerTests extends TelecomTestCase {
         expectedIntent.setPackage(mDefaultDialerCache.getBTInCallServicePackages()[0]);
         LinkedList<ResolveInfo> resolveInfo = new LinkedList<ResolveInfo>();
         resolveInfo.add(getBluetoothResolveinfo());
-        when(mFeatureFlags.separatelyBindToBtIncallService()).thenReturn(true);
         when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
         doAnswer(invocation -> {
             Object[] args = invocation.getArguments();
@@ -2023,6 +2025,50 @@ public class InCallControllerTests extends TelecomTestCase {
                 anyInt(), any(UserHandle.class));
     }
 
+    @Test
+    public void testHandleCallDisconnect() throws RemoteException {
+        setupMocks(false /* isExternalCall */);
+        setupMockPackageManager(true /* default */, true /* system */, false /* external calls */);
+        mInCallController.bindToServices(mMockCall);
+
+        // Bind InCallServices
+        ArgumentCaptor<Intent> bindIntentCaptor = ArgumentCaptor.forClass(Intent.class);
+        ArgumentCaptor<ServiceConnection> serviceConnectionCaptor =
+                ArgumentCaptor.forClass(ServiceConnection.class);
+        verify(mMockContext, times(1)).bindServiceAsUser(
+                bindIntentCaptor.capture(),
+                serviceConnectionCaptor.capture(),
+                eq(serviceBindingFlags),
+                eq(mUserHandle));
+        assertEquals(1, bindIntentCaptor.getAllValues().size());
+        verifyBinding(bindIntentCaptor, 0, DEF_PKG, DEF_CLASS);
+
+        // Start the connection.
+        ServiceConnection serviceConnection = serviceConnectionCaptor.getValue();
+        ComponentName defDialerComponentName = new ComponentName(DEF_PKG, DEF_CLASS);
+        IBinder mockBinder = mock(IBinder.class);
+        IInCallService mockInCallService = mock(IInCallService.class);
+        when(mockInCallService.asBinder()).thenReturn(mockBinder);
+        when(mockBinder.queryLocalInterface(anyString())).thenReturn(mockInCallService);
+        serviceConnection.onServiceConnected(defDialerComponentName, mockBinder);
+
+        mInCallController.onCallAdded(mMockCall);
+        ArgumentCaptor<ParcelableCall> parcelableCallCaptor =
+                ArgumentCaptor.forClass(ParcelableCall.class);
+        verify(mockInCallService).addCall(parcelableCallCaptor.capture());
+        // Retrieve call listener
+        ArgumentCaptor<Call.ListenerBase> callListenerCaptor = ArgumentCaptor.forClass(
+                Call.ListenerBase.class);
+        verify(mMockCall).addListener(callListenerCaptor.capture());
+        Call.ListenerBase callListener = callListenerCaptor.getValue();
+
+        // Emulate connection event being received and ensure that ICS receive the corresponding
+        // update.
+        callListener.onConnectionEvent(mMockCall, Connection.EVENT_DISCONNECT_FAILED, null);
+        verify(mMockCall).setLocallyDisconnecting(eq(false));
+        verify(mockInCallService).updateCall(any(ParcelableCall.class));
+    }
+
     private void setupMocks(boolean isExternalCall) {
         setupMocks(isExternalCall, false /* isSelfManagedCall */);
     }
diff --git a/tests/src/com/android/server/telecom/tests/InCallTonePlayerTest.java b/tests/src/com/android/server/telecom/tests/InCallTonePlayerTest.java
index 4459d1b63..25efaf006 100644
--- a/tests/src/com/android/server/telecom/tests/InCallTonePlayerTest.java
+++ b/tests/src/com/android/server/telecom/tests/InCallTonePlayerTest.java
@@ -45,7 +45,6 @@ import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.WiredHeadsetManager;
 import com.android.server.telecom.bluetooth.BluetoothDeviceManager;
 import com.android.server.telecom.bluetooth.BluetoothRouteManager;
-import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -209,53 +208,9 @@ public class InCallTonePlayerTest extends TelecomTestCase {
                 eq(true));
     }
 
-    /**
-     * Only applicable when {@link FeatureFlags#useStreamVoiceCallTones()} is false and we use
-     * STREAM_BLUETOOTH_SCO for tones.
-     */
-    @SmallTest
-    @Test
-    public void testRingbackToneAudioStreamHeadset() {
-        when(mFeatureFlags.useStreamVoiceCallTones()).thenReturn(false);
-        when(mAudioManagerAdapter.isVolumeOverZero()).thenReturn(true);
-        setConnectedBluetoothDevice(false /*isLe*/, false /*isHearingAid*/);
-
-        mInCallTonePlayer = mFactory.createPlayer(mCall, InCallTonePlayer.TONE_RING_BACK);
-        assertTrue(mInCallTonePlayer.startTone());
-
-        verify(mToneGeneratorFactory, timeout(TEST_TIMEOUT))
-                .get(eq(AudioManager.STREAM_BLUETOOTH_SCO), anyInt());
-        verify(mCallAudioManager).setIsTonePlaying(any(Call.class), eq(true));
-    }
-
-    /**
-     * Only applicable when {@link FeatureFlags#useStreamVoiceCallTones()} is false and we use
-     * STREAM_BLUETOOTH_SCO for tones.
-     */
-    @SmallTest
-    @Test
-    public void testCallWaitingToneAudioStreamHeadset() {
-        when(mFeatureFlags.useStreamVoiceCallTones()).thenReturn(false);
-        when(mAudioManagerAdapter.isVolumeOverZero()).thenReturn(true);
-        setConnectedBluetoothDevice(false /*isLe*/, false /*isHearingAid*/);
-
-        mInCallTonePlayer = mFactory.createPlayer(mCall, InCallTonePlayer.TONE_CALL_WAITING);
-        assertTrue(mInCallTonePlayer.startTone());
-
-        verify(mToneGeneratorFactory, timeout(TEST_TIMEOUT))
-                .get(eq(AudioManager.STREAM_BLUETOOTH_SCO), anyInt());
-        verify(mCallAudioManager).setIsTonePlaying(any(Call.class), eq(true));
-    }
-
-
-    /**
-     * Only applicable when {@link FeatureFlags#useStreamVoiceCallTones()} is true and we use
-     * STREAM_VOICE_CALL for ALL tones.
-     */
     @SmallTest
     @Test
     public void testRingbackToneAudioStreamSco() {
-        when(mFeatureFlags.useStreamVoiceCallTones()).thenReturn(true);
         when(mAudioManagerAdapter.isVolumeOverZero()).thenReturn(true);
         setConnectedBluetoothDevice(false /*isLe*/, false /*isHearingAid*/);
 
@@ -267,14 +222,9 @@ public class InCallTonePlayerTest extends TelecomTestCase {
         verify(mCallAudioManager).setIsTonePlaying(any(Call.class), eq(true));
     }
 
-    /**
-     * Only applicable when {@link FeatureFlags#useStreamVoiceCallTones()} is true and we use
-     * STREAM_VOICE_CALL for ALL tones.
-     */
     @SmallTest
     @Test
     public void testRingbackToneAudioStreamLe() {
-        when(mFeatureFlags.useStreamVoiceCallTones()).thenReturn(true);
         when(mAudioManagerAdapter.isVolumeOverZero()).thenReturn(true);
         setConnectedBluetoothDevice(true /*isLe*/, false /*isHearingAid*/);
 
diff --git a/tests/src/com/android/server/telecom/tests/IncomingCallFilterGraphTest.java b/tests/src/com/android/server/telecom/tests/IncomingCallFilterGraphTest.java
index d7905b27e..aecbc7b8e 100644
--- a/tests/src/com/android/server/telecom/tests/IncomingCallFilterGraphTest.java
+++ b/tests/src/com/android/server/telecom/tests/IncomingCallFilterGraphTest.java
@@ -16,17 +16,18 @@
 
 package com.android.server.telecom.tests;
 
+import static com.android.server.telecom.callfiltering.CallFilteringResult.DND_NOT_DETERMINED;
+import static com.android.server.telecom.callfiltering.CallFilteringResult.DND_SUPPRESSED;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.nullable;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.content.ContentResolver;
 import android.content.Context;
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.util.Log;
 
 import androidx.test.filters.SmallTest;
@@ -40,6 +41,7 @@ import com.android.server.telecom.callfiltering.CallFilterResultCallback;
 import com.android.server.telecom.callfiltering.CallFilteringResult;
 import com.android.server.telecom.callfiltering.DndCallFilter;
 import com.android.server.telecom.callfiltering.IncomingCallFilterGraph;
+import com.android.server.telecom.flags.FeatureFlags;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -113,7 +115,8 @@ public class IncomingCallFilterGraphTest extends TelecomTestCase {
     public void setUp() throws Exception {
         super.setUp();
         when(mContext.getContentResolver()).thenReturn(null);
-        when(mTimeoutsAdapter.getCallScreeningTimeoutMillis(nullable(ContentResolver.class)))
+        when(mTimeoutsAdapter.getCallScreeningTimeoutMillis(nullable(Context.class), any(
+                FeatureFlags.class)))
                 .thenReturn(FILTER_TIMEOUT);
 
     }
@@ -229,13 +232,23 @@ public class IncomingCallFilterGraphTest extends TelecomTestCase {
 
         // WHEN:  DND is on and the caller cannot interrupt and the graph is processed
         when(mockRinger.shouldRingForContact(mCall)).thenReturn(false);
-        when(mFeatureFlags.checkCompletedFiltersOnTimeout()).thenReturn(true);
         dndCallFilter.startFilterLookup(IncomingCallFilterGraph.DEFAULT_RESULT);
         graph.performFiltering();
 
-        // THEN: assert shouldSuppressCallDueToDndStatus is true!
-        assertFalse(IncomingCallFilterGraph.DEFAULT_RESULT.shouldSuppressCallDueToDndStatus);
-        assertTrue(testResult.get(TIMEOUT_FILTER_SLEEP_TIME,
-                TimeUnit.MILLISECONDS).shouldSuppressCallDueToDndStatus);
+        // THEN: assert that DND is not determined or suppressed.
+        if (mFeatureFlags.voipDndFocus()) {
+            assertEquals(DND_NOT_DETERMINED,
+                    IncomingCallFilterGraph.DEFAULT_RESULT.dndSuppressionStatus);
+        } else {
+            assertFalse(IncomingCallFilterGraph.DEFAULT_RESULT.shouldSuppressCallDueToDndStatus);
+        }
+
+        if (mFeatureFlags.voipDndFocus()) {
+            assertEquals(DND_SUPPRESSED, testResult.get(TIMEOUT_FILTER_SLEEP_TIME,
+                    TimeUnit.MILLISECONDS).dndSuppressionStatus);
+        } else {
+            assertTrue(testResult.get(TIMEOUT_FILTER_SLEEP_TIME,
+                    TimeUnit.MILLISECONDS).shouldSuppressCallDueToDndStatus);
+        }
     }
 }
diff --git a/tests/src/com/android/server/telecom/tests/IncomingCallNotifierTest.java b/tests/src/com/android/server/telecom/tests/IncomingCallNotifierTest.java
index 2d81bb3f3..dced22903 100644
--- a/tests/src/com/android/server/telecom/tests/IncomingCallNotifierTest.java
+++ b/tests/src/com/android/server/telecom/tests/IncomingCallNotifierTest.java
@@ -54,6 +54,7 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
     @Mock private Call mAudioCall;
     @Mock private Call mVideoCall;
     @Mock private Call mRingingCall;
+    @Mock private Context mUserContext;
     private IncomingCallNotifier mIncomingCallNotifier;
     private NotificationManager mNotificationManager;
 
@@ -68,7 +69,11 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
         doReturn(null).when(mContext).getTheme();
         mNotificationManager = (NotificationManager) mContext.getSystemService(
                 Context.NOTIFICATION_SERVICE);
-        mIncomingCallNotifier = new IncomingCallNotifier(mContext);
+        when(mContext.createContextAsUser(any(UserHandle.class), eq(0)))
+                .thenReturn(mUserContext);
+        when(mUserContext.getSystemService(eq(NotificationManager.class)))
+                .thenReturn(mNotificationManager);
+        mIncomingCallNotifier = new IncomingCallNotifier(mContext, mFeatureFlags);
         mIncomingCallNotifier.setCallsManagerProxy(mCallsManagerProxy);
 
         when(mAudioCall.getVideoState()).thenReturn(VideoProfile.STATE_AUDIO_ONLY);
@@ -85,6 +90,7 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
         when(mRingingCall.getAssociatedUser()).
                 thenReturn(UserHandle.CURRENT);
         when(mRingingCall.getHandoverState()).thenReturn(HandoverState.HANDOVER_NONE);
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
     }
 
     @Override
@@ -100,10 +106,9 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
     @Test
     public void testSingleCall() {
         mIncomingCallNotifier.onCallAdded(mAudioCall);
-        verify(mNotificationManager, never()).notifyAsUser(
+        verify(mNotificationManager, never()).notify(
                 eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any(),
-                eq(UserHandle.CURRENT));
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any());
     }
 
     /**
@@ -114,10 +119,9 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
     public void testIncomingDuringOngoingCall() {
         when(mCallsManagerProxy.hasUnholdableCallsForOtherConnectionService(any())).thenReturn(false);
         mIncomingCallNotifier.onCallAdded(mRingingCall);
-        verify(mNotificationManager, never()).notifyAsUser(
+        verify(mNotificationManager, never()).notify(
                 eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any(),
-                eq(UserHandle.CURRENT));
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any());
     }
 
     /**
@@ -132,10 +136,9 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
 
         mIncomingCallNotifier.onCallAdded(mAudioCall);
         mIncomingCallNotifier.onCallAdded(mRingingCall);
-        verify(mNotificationManager, never()).notifyAsUser(
+        verify(mNotificationManager, never()).notify(
                 eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any(),
-                eq(UserHandle.CURRENT));
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any());
     }
 
     /**
@@ -150,13 +153,12 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
 
         mIncomingCallNotifier.onCallAdded(mAudioCall);
         mIncomingCallNotifier.onCallAdded(mRingingCall);
-        verify(mNotificationManager).notifyAsUser(
+        verify(mNotificationManager).notify(
                 eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any(),
-                eq(UserHandle.CURRENT));
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any());
         mIncomingCallNotifier.onCallRemoved(mRingingCall);
-        verify(mNotificationManager).cancelAsUser(eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), eq(UserHandle.CURRENT));
+        verify(mNotificationManager).cancel(eq(IncomingCallNotifier.NOTIFICATION_TAG),
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL));
     }
 
     /**
@@ -174,10 +176,9 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
         mIncomingCallNotifier.onCallAdded(mRingingCall);
 
         // Incoming call is in the middle of a handover, don't expect to be notified.
-        verify(mNotificationManager, never()).notifyAsUser(
+        verify(mNotificationManager, never()).notify(
                 eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any(),
-                eq(UserHandle.CURRENT));
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any());
     }
 
     /**
@@ -195,9 +196,8 @@ public class IncomingCallNotifierTest extends TelecomTestCase {
         mIncomingCallNotifier.onCallAdded(mRingingCall);
 
         // Incoming call is done a handover, don't expect to be notified.
-        verify(mNotificationManager, never()).notifyAsUser(
+        verify(mNotificationManager, never()).notify(
                 eq(IncomingCallNotifier.NOTIFICATION_TAG),
-                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any(),
-                eq(UserHandle.CURRENT));
+                eq(IncomingCallNotifier.NOTIFICATION_INCOMING_CALL), any());
     }
 }
diff --git a/tests/src/com/android/server/telecom/tests/MissedCallNotifierImplTest.java b/tests/src/com/android/server/telecom/tests/MissedCallNotifierImplTest.java
index 39836eefd..29bedcc46 100644
--- a/tests/src/com/android/server/telecom/tests/MissedCallNotifierImplTest.java
+++ b/tests/src/com/android/server/telecom/tests/MissedCallNotifierImplTest.java
@@ -46,10 +46,12 @@ import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.ComponentName;
 import android.content.ContentProvider;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.IContentProvider;
 import android.content.Intent;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.net.Uri;
 import android.os.Bundle;
@@ -172,6 +174,8 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
     @Mock TelecomSystem mTelecomSystem;
     @Mock private DefaultDialerCache mDefaultDialerCache;
     @Mock private DeviceIdleControllerAdapter mDeviceIdleControllerAdapter;
+    @Mock private Context mUserContext;
+    @Mock private ContentResolver mUserContentResolver;
 
     @Override
     @Before
@@ -180,8 +184,15 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         MockitoAnnotations.initMocks(this);
 
         mContext = mComponentContextFixture.getTestDouble().getApplicationContext();
+        PackageManager packageManager = mContext.getPackageManager();
         mNotificationManager = (NotificationManager) mContext.getSystemService(
                 Context.NOTIFICATION_SERVICE);
+        when(mContext.createContextAsUser(any(UserHandle.class), eq(0)))
+                .thenReturn(mUserContext);
+        when(mUserContext.getPackageManager()).thenReturn(packageManager);
+        when(mUserContext.getSystemService(eq(NotificationManager.class)))
+                .thenReturn(mNotificationManager);
+        when(mUserContext.getContentResolver()).thenReturn(mUserContentResolver);
         TelephonyManager fakeTelephonyManager = (TelephonyManager) mContext.getSystemService(
                 Context.TELEPHONY_SERVICE);
         when(fakeTelephonyManager.getNetworkCountryIso()).thenReturn("US");
@@ -197,6 +208,7 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         mComponentContextFixture.putResource(R.string.userCallActivityLabel,
                 USER_CALL_ACTIVITY_LABEL);
         mComponentContextFixture.setTelecomManager(mTelecomManager);
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
     }
 
     @Override
@@ -279,7 +291,6 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
                 TelecomManager.ACTION_SHOW_MISSED_CALLS_NOTIFICATION, COMPONENT_NAME);
         when(mDefaultDialerCache.getDefaultDialerApplication(anyInt())).thenReturn(
                 DEFAULT_DIALER_PACKAGE);
-
         Notification.Builder builder1 = makeNotificationBuilder("builder1");
         Notification.Builder builder2 = makeNotificationBuilder("builder2");
         MissedCallNotifierImpl.NotificationBuilderFactory fakeBuilderFactory =
@@ -305,10 +316,10 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
 
         ArgumentCaptor<Integer> requestIdCaptor = ArgumentCaptor.forClass(
                 Integer.class);
-        verify(mNotificationManager, times(2)).notifyAsUser(nullable(String.class),
-                requestIdCaptor.capture(), nullable(Notification.class), eq(userHandle));
-        verify(mNotificationManager).cancelAsUser(nullable(String.class),
-                eq(requestIdCaptor.getValue()), eq(userHandle));
+        verify(mNotificationManager, times(2)).notify(nullable(String.class),
+                requestIdCaptor.capture(), nullable(Notification.class));
+        verify(mNotificationManager).cancel(nullable(String.class),
+                eq(requestIdCaptor.getValue()));
 
         // Verify that the second call to showMissedCallNotification behaves like it were the first.
         verify(builder2).setContentText(CALLER_NAME);
@@ -345,8 +356,8 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         // to notifyAsUser are the versions which contain sensitive information.
         ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(
                 Notification.class);
-        verify(mNotificationManager, times(2)).notifyAsUser(nullable(String.class), eq(1),
-                notificationArgumentCaptor.capture(), eq(PRIMARY_USER));
+        verify(mNotificationManager, times(2)).notify(nullable(String.class), eq(1),
+                notificationArgumentCaptor.capture());
         HashSet<String> privateNotifications = new HashSet<>();
         for (Notification n : notificationArgumentCaptor.getAllValues()) {
             privateNotifications.add(n.toString());
@@ -437,8 +448,8 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         } else {
             expectedUserHandle = phoneAccount.getAccountHandle().getUserHandle();
         }
-        verify(mNotificationManager).notifyAsUser(nullable(String.class), eq(1),
-                notificationArgumentCaptor.capture(), eq((expectedUserHandle)));
+        verify(mNotificationManager).notify(nullable(String.class), eq(1),
+                notificationArgumentCaptor.capture());
 
         Notification.Builder builder;
         Notification.Builder publicBuilder;
@@ -522,19 +533,20 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         CallerInfoLookupHelper mockCallerInfoLookupHelper = mock(CallerInfoLookupHelper.class);
         MissedCallNotifier.CallInfoFactory mockCallInfoFactory =
                 mock(MissedCallNotifier.CallInfoFactory.class);
-
-        Uri queryUri = ContentProvider.maybeAddUserId(CallLog.Calls.CONTENT_URI,
-                PRIMARY_USER.getIdentifier());
-        IContentProvider cp = getContentProviderForUser(PRIMARY_USER.getIdentifier());
+        Uri expectedQueryUri = CallLog.Calls.CONTENT_URI;
 
         Cursor mockMissedCallsCursor = new MockMissedCallCursorBuilder()
                 .addEntry(TEL_CALL_HANDLE.getSchemeSpecificPart(),
                         CallLog.Calls.PRESENTATION_ALLOWED, CALL_TIMESTAMP)
                 .build();
 
-        when(cp.query(any(), eq(queryUri), nullable(String[].class),
-                nullable(Bundle.class), nullable(ICancellationSignal.class)))
-                .thenReturn(mockMissedCallsCursor);
+        when(mUserContentResolver.query(
+                eq(expectedQueryUri),
+                eq(MissedCallNotifierImpl.CALL_LOG_PROJECTION),
+                eq(MissedCallNotifierImpl.CALL_LOG_WHERE_CLAUSE),
+                isNull(), // selectionArgs is null in MissedCallNotifierImpl
+                eq(CallLog.Calls.DEFAULT_SORT_ORDER)
+        )).thenReturn(mockMissedCallsCursor);
 
         PhoneAccount phoneAccount = makePhoneAccount(PRIMARY_USER, NO_CAPABILITY);
         MissedCallNotifier.CallInfo fakeCallInfo = makeFakeCallInfo(TEL_CALL_HANDLE,
@@ -547,9 +559,10 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         MissedCallNotifierImpl.NotificationBuilderFactory fakeBuilderFactory =
                 makeNotificationBuilderFactory(builder1);
 
-        MissedCallNotifier missedCallNotifier = new MissedCallNotifierImpl(mContext,
+        MissedCallNotifierImpl missedCallNotifier = new MissedCallNotifierImpl(mContext,
                 mPhoneAccountRegistrar, mDefaultDialerCache, fakeBuilderFactory,
                 mDeviceIdleControllerAdapter, mFeatureFlags);
+        missedCallNotifier.setCurrentUserHandle(PRIMARY_USER);
 
         // AsyncQueryHandler used in reloadFromDatabase interacts poorly with the below
         // timeout-verify, so run this in a new handler to mitigate that.
@@ -598,13 +611,14 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
                         CallLog.Calls.PRESENTATION_ALLOWED, CALL_TIMESTAMP)
                 .build();
 
-        Uri queryUri = ContentProvider.maybeAddUserId(CallLog.Calls.CONTENT_URI,
-                PRIMARY_USER.getIdentifier());
-        IContentProvider cp = getContentProviderForUser(PRIMARY_USER.getIdentifier());
-
-        when(cp.query(any(), eq(queryUri), nullable(String[].class),
-                nullable(Bundle.class), nullable(ICancellationSignal.class)))
-                .thenReturn(mockMissedCallsCursor);
+        Uri expectedQueryUri = CallLog.Calls.CONTENT_URI;
+        when(mUserContentResolver.query(
+                eq(expectedQueryUri),
+                eq(MissedCallNotifierImpl.CALL_LOG_PROJECTION),
+                eq(MissedCallNotifierImpl.CALL_LOG_WHERE_CLAUSE),
+                isNull(),
+                eq(CallLog.Calls.DEFAULT_SORT_ORDER)
+        )).thenReturn(mockMissedCallsCursor);
 
         PhoneAccount phoneAccount = makePhoneAccount(PRIMARY_USER, NO_CAPABILITY);
         MissedCallNotifier.CallInfo fakeCallInfo = makeFakeCallInfo(TEL_CALL_HANDLE,
@@ -617,9 +631,10 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         MissedCallNotifierImpl.NotificationBuilderFactory fakeBuilderFactory =
                 makeNotificationBuilderFactory(builder1);
 
-        MissedCallNotifier missedCallNotifier = new MissedCallNotifierImpl(mContext,
+        MissedCallNotifierImpl missedCallNotifier = new MissedCallNotifierImpl(mContext,
                 mPhoneAccountRegistrar, mDefaultDialerCache, fakeBuilderFactory,
                 mDeviceIdleControllerAdapter, mFeatureFlags);
+        missedCallNotifier.setCurrentUserHandle(PRIMARY_USER);
 
         // AsyncQueryHandler used in reloadFromDatabase interacts poorly with the below
         // timeout-verify, so run this in a new handler to mitigate that.
@@ -645,8 +660,8 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
         listenerCaptor.getAllValues().get(1).onCallerInfoQueryComplete(escapedSipHandle, ci);
 
         // Verify that two notifications were generated, both with the same id.
-        verify(mNotificationManager, times(2)).notifyAsUser(nullable(String.class), eq(1),
-                nullable(Notification.class), eq(PRIMARY_USER));
+        verify(mNotificationManager, times(2)).notify(nullable(String.class), eq(1),
+                nullable(Notification.class));
     }
 
     @SmallTest
@@ -688,8 +703,8 @@ public class MissedCallNotifierImplTest extends TelecomTestCase {
                 options.getTemporaryAppAllowlistDuration() > 0);
 
         // A notification should never be posted by Telecom
-        verify(mNotificationManager, never()).notifyAsUser(nullable(String.class), anyInt(),
-                nullable(Notification.class), eq(PRIMARY_USER));
+        verify(mNotificationManager, never()).notify(nullable(String.class), anyInt(),
+                nullable(Notification.class));
     }
 
     /**
diff --git a/tests/src/com/android/server/telecom/tests/MissedInformationTest.java b/tests/src/com/android/server/telecom/tests/MissedInformationTest.java
index 0c3588e2a..0fcb7e678 100644
--- a/tests/src/com/android/server/telecom/tests/MissedInformationTest.java
+++ b/tests/src/com/android/server/telecom/tests/MissedInformationTest.java
@@ -319,7 +319,7 @@ public class MissedInformationTest extends TelecomSystemTest {
         mCallsManager.onCallFilteringComplete(mIncomingCall, result, false);
 
         // Wait for ringer attributes build completed
-        verify(mAudioManager, timeout(TEST_TIMEOUT_MILLIS)).getStreamVolume(anyInt());
+        verify(mAudioManager, timeout(TEST_TIMEOUT_MILLIS)).shouldNotificationSoundPlay(any());
         mCallsManager.getRinger().waitForAttributesCompletion();
 
         mCallsManager.markCallAsDisconnected(mIncomingCall,
@@ -343,7 +343,7 @@ public class MissedInformationTest extends TelecomSystemTest {
         mCallsManager.onCallFilteringComplete(mIncomingCall, result, false);
 
         // Wait for ringer attributes build completed
-        verify(mAudioManager, timeout(TEST_TIMEOUT_MILLIS)).getStreamVolume(anyInt());
+        verify(mAudioManager, timeout(TEST_TIMEOUT_MILLIS)).shouldNotificationSoundPlay(any());
         mCallsManager.getRinger().waitForAttributesCompletion();
 
         mCallsManager.markCallAsDisconnected(mIncomingCall,
diff --git a/tests/src/com/android/server/telecom/tests/NewOutgoingCallIntentBroadcasterTest.java b/tests/src/com/android/server/telecom/tests/NewOutgoingCallIntentBroadcasterTest.java
index 1ea0ed1c0..d322e6d34 100644
--- a/tests/src/com/android/server/telecom/tests/NewOutgoingCallIntentBroadcasterTest.java
+++ b/tests/src/com/android/server/telecom/tests/NewOutgoingCallIntentBroadcasterTest.java
@@ -78,16 +78,6 @@ import org.mockito.Mock;
 public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
     private static final Uri TEST_URI = Uri.parse("tel:16505551212");
 
-    private static class ReceiverIntentPair {
-        public BroadcastReceiver receiver;
-        public Intent intent;
-
-        public ReceiverIntentPair(BroadcastReceiver receiver, Intent intent) {
-            this.receiver = receiver;
-            this.intent = intent;
-        }
-    }
-
     @Mock private CallsManager mCallsManager;
     @Mock private Call mCall;
     @Mock private SystemStateHelper mSystemStateHelper;
@@ -117,7 +107,6 @@ public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
             any(PhoneAccountHandle.class))).thenReturn(mPhoneAccount);
         when(mPhoneAccount.isSelfManaged()).thenReturn(true);
         when(mSystemStateHelper.isCarModeOrProjectionActive()).thenReturn(false);
-        when(mFeatureFlags.isNewOutgoingCallBroadcastUnblocking()).thenReturn(false);
     }
 
     @Override
@@ -193,21 +182,6 @@ public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
         verifyNoCallPlaced();
     }
 
-    @SmallTest
-    @Test
-    public void testAlreadyDisconnectedCall() {
-        Uri handle = Uri.parse("tel:6505551234");
-        doReturn(true).when(mCall).isDisconnected();
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, null);
-
-        result.receiver.setResultData(
-                result.intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER));
-
-        result.receiver.onReceive(mContext, result.intent);
-        verifyNoCallPlaced();
-    }
-
     @SmallTest
     @Test
     public void testNoNumberSupplied() {
@@ -392,170 +366,15 @@ public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
         if (expectedAdditionalExtras != null) {
             expectedExtras.putAll(expectedAdditionalExtras);
         }
-        BroadcastReceiver receiver = verifyBroadcastSent(handle.getSchemeSpecificPart(),
-                expectedExtras).receiver;
-        assertNull(receiver);
-    }
-
-    @SmallTest
-    @Test
-    public void testUnmodifiedRegularCall() {
-        Uri handle = Uri.parse("tel:6505551234");
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, null);
-
-        result.receiver.setResultData(
-                result.intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER));
-
-        result.receiver.onReceive(mContext, result.intent);
-
-        verify(mCallsManager).placeOutgoingCall(eq(mCall), eq(handle), isNull(),
-                eq(true), eq(VideoProfile.STATE_BIDIRECTIONAL));
-    }
-
-    @SmallTest
-    @Test
-    public void testUnmodifiedSipCall() {
-        Uri handle = Uri.parse("sip:test@test.com");
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, null);
-
-        result.receiver.setResultData(
-                result.intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER));
-
-        result.receiver.onReceive(mContext, result.intent);
-
-        Uri encHandle = Uri.fromParts(handle.getScheme(),
-                handle.getSchemeSpecificPart(), null);
-        verify(mCallsManager).placeOutgoingCall(eq(mCall), eq(encHandle), isNull(),
-                eq(true), eq(VideoProfile.STATE_BIDIRECTIONAL));
-    }
-
-    @SmallTest
-    @Test
-    public void testCallWithGatewayInfo() {
-        Uri handle = Uri.parse("tel:6505551234");
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-
-        callIntent.putExtra(NewOutgoingCallIntentBroadcaster
-                        .EXTRA_GATEWAY_PROVIDER_PACKAGE, "sample1");
-        callIntent.putExtra(NewOutgoingCallIntentBroadcaster.EXTRA_GATEWAY_URI, "sample2");
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, callIntent.getExtras());
-
-        result.receiver.setResultData(
-                result.intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER));
-
-        result.receiver.onReceive(mContext, result.intent);
-
-        verify(mCallsManager).placeOutgoingCall(eq(mCall), eq(handle),
-                isNotNull(), eq(true), eq(VideoProfile.STATE_BIDIRECTIONAL));
-    }
-
-    @SmallTest
-    @Test
-    public void testCallNumberModifiedToNull() {
-        Uri handle = Uri.parse("tel:6505551234");
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, null);
-
-        result.receiver.setResultData(null);
-
-        result.receiver.onReceive(mContext, result.intent);
-        verifyNoCallPlaced();
-        ArgumentCaptor<Long> timeoutCaptor = ArgumentCaptor.forClass(Long.class);
-        verify(mCall).disconnect(timeoutCaptor.capture());
-        assertTrue(timeoutCaptor.getValue() > 0);
-    }
-
-    @SmallTest
-    @Test
-    public void testCallNumberModifiedToNullWithLongCustomTimeout() {
-        Uri handle = Uri.parse("tel:6505551234");
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, null);
-
-        long customTimeout = 100000000;
-        Bundle bundle = new Bundle();
-        bundle.putLong(TelecomManager.EXTRA_NEW_OUTGOING_CALL_CANCEL_TIMEOUT, customTimeout);
-        result.receiver.setResultData(null);
-        result.receiver.setResultExtras(bundle);
-
-        result.receiver.onReceive(mContext, result.intent);
-        verifyNoCallPlaced();
-        ArgumentCaptor<Long> timeoutCaptor = ArgumentCaptor.forClass(Long.class);
-        verify(mCall).disconnect(timeoutCaptor.capture());
-        assertTrue(timeoutCaptor.getValue() < customTimeout);
-    }
-
-    @SmallTest
-    @Test
-    public void testCallModifiedToEmergency() {
-        Uri handle = Uri.parse("tel:6505551234");
-        Intent callIntent = buildIntent(handle, Intent.ACTION_CALL, null);
-        ReceiverIntentPair result = regularCallTestHelper(callIntent, null);
-
-        String newEmergencyNumber = "1234567890";
-        result.receiver.setResultData(newEmergencyNumber);
-
-        doReturn(true).when(mComponentContextFixture.getTelephonyManager())
-                .isEmergencyNumber(eq(newEmergencyNumber));
-        result.receiver.onReceive(mContext, result.intent);
-        verify(mCall).disconnect(eq(0L));
-    }
-
-    /**
-     * Ensure if {@link TelephonyManager#isPotentialEmergencyNumber(String)} throws an exception of
-     * any sort that we don't crash Telecom.
-     */
-    @SmallTest
-    @Test
-    public void testThrowOnIsPotentialEmergencyNumber() {
-        doThrow(new IllegalStateException()).when(mComponentContextFixture.getTelephonyManager())
-                .isPotentialEmergencyNumber(anyString());
-        testUnmodifiedRegularCall();
+        verifyBroadcastSent(handle.getSchemeSpecificPart(), expectedExtras);
     }
 
     /**
-     * Where the flag `isNewOutgoingCallBroadcastUnblocking` is off, verify that we sent an ordered
-     * broadcast and did not try to start the call immediately (legacy behavior).
-     */
-    @SmallTest
-    @Test
-    public void testSendBroadcastBlocking() {
-        when(mFeatureFlags.isNewOutgoingCallBroadcastUnblocking()).thenReturn(false);
-        Intent intent = new Intent(Intent.ACTION_CALL, TEST_URI);
-        NewOutgoingCallIntentBroadcaster nocib = new NewOutgoingCallIntentBroadcaster(
-                mContext, mCallsManager, intent, mPhoneNumberUtilsAdapter,
-                true /* isDefaultPhoneApp */, mDefaultDialerCache, mMmiUtils, mFeatureFlags);
-
-        NewOutgoingCallIntentBroadcaster.CallDisposition disposition = nocib.evaluateCall();
-        nocib.processCall(mCall, disposition);
-
-        // We should not have not short-circuited to place the outgoing call directly.
-        verify(mCall, never()).setNewOutgoingCallIntentBroadcastIsDone();
-        verify(mCallsManager, never()).placeOutgoingCall(any(Call.class), any(Uri.class),
-                any(GatewayInfo.class), anyBoolean(), anyInt());
-
-        // Ensure we did send the broadcast ordered
-        verifyBroadcastSent(TEST_URI.getSchemeSpecificPart(),
-                createNumberExtras(TEST_URI.getSchemeSpecificPart()));
-
-        // Ensure we did not try to directly send the broadcast unordered.
-        verify(mContext, never()).sendBroadcastAsUser(
-                any(Intent.class),
-                eq(UserHandle.CURRENT),
-                eq(android.Manifest.permission.PROCESS_OUTGOING_CALLS));
-    }
-
-    /**
-     * Where the flag `isNewOutgoingCallBroadcastUnblocking` is off, verify that we sent an ordered
-     * broadcast and did not try to start the call immediately.  Also ensure that the broadcast
-     * flags are correct.
+     * Verify that the new outgoing call broadcast is not ordered.
      */
     @SmallTest
     @Test
     public void testSendBroadcastNonBlocking() {
-        when(mFeatureFlags.isNewOutgoingCallBroadcastUnblocking()).thenReturn(true);
         Intent intent = new Intent(Intent.ACTION_CALL, TEST_URI);
         NewOutgoingCallIntentBroadcaster nocib = new NewOutgoingCallIntentBroadcaster(
                 mContext, mCallsManager, intent, mPhoneNumberUtilsAdapter,
@@ -593,7 +412,7 @@ public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
         assertEquals(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, capturedIntent.getFlags());
     }
 
-    private ReceiverIntentPair regularCallTestHelper(Intent intent,
+    private void regularCallTestHelper(Intent intent,
             Bundle expectedAdditionalExtras) {
         Uri handle = intent.getData();
         int videoState = VideoProfile.STATE_BIDIRECTIONAL;
@@ -610,7 +429,7 @@ public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
         if (expectedAdditionalExtras != null) {
             expectedExtras.putAll(expectedAdditionalExtras);
         }
-        return verifyBroadcastSent(handle.getSchemeSpecificPart(), expectedExtras);
+        verifyBroadcastSent(handle.getSchemeSpecificPart(), expectedExtras);
     }
 
     private Intent buildIntent(Uri handle, String action, Bundle extras) {
@@ -633,36 +452,27 @@ public class NewOutgoingCallIntentBroadcasterTest extends TelecomTestCase {
         return cd;
     }
 
-    private ReceiverIntentPair verifyBroadcastSent(String number, Bundle expectedExtras) {
+    private void verifyBroadcastSent(String number, Bundle expectedExtras) {
         ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        ArgumentCaptor<BroadcastReceiver> receiverCaptor =
-                ArgumentCaptor.forClass(BroadcastReceiver.class);
 
-        verify(mContext).sendOrderedBroadcastAsUser(
-                intentCaptor.capture(),
-                eq(UserHandle.CURRENT),
-                eq(Manifest.permission.PROCESS_OUTGOING_CALLS),
-                eq(AppOpsManager.OP_PROCESS_OUTGOING_CALLS),
-                any(Bundle.class),
-                receiverCaptor.capture(),
-                isNull(),
-                eq(Activity.RESULT_OK),
-                eq(number),
-                isNull());
+        if (mFeatureFlags.telecomResolveHiddenDependencies()) {
+            verify(mContext).sendBroadcastAsUser(
+                    intentCaptor.capture(),
+                    eq(UserHandle.CURRENT),
+                    eq(Manifest.permission.PROCESS_OUTGOING_CALLS));
+        } else {
+            verify(mContext).sendBroadcastAsUser(
+                    intentCaptor.capture(),
+                    eq(UserHandle.CURRENT),
+                    eq(Manifest.permission.PROCESS_OUTGOING_CALLS),
+                    anyInt());
+        }
 
         Intent capturedIntent = intentCaptor.getValue();
         assertEquals(Intent.ACTION_NEW_OUTGOING_CALL, capturedIntent.getAction());
-        assertEquals(Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND,
+        assertEquals(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND,
                 capturedIntent.getFlags());
         assertTrue(areBundlesEqual(expectedExtras, capturedIntent.getExtras()));
-
-        BroadcastReceiver receiver = receiverCaptor.getValue();
-        if (receiver != null) {
-            receiver.setPendingResult(
-                    new BroadcastReceiver.PendingResult(0, "", null, 0, true, false, null, 0, 0));
-        }
-
-        return new ReceiverIntentPair(receiver, capturedIntent);
     }
 
     private Bundle createNumberExtras(String number) {
diff --git a/tests/src/com/android/server/telecom/tests/PackageRemovedReceiverTest.java b/tests/src/com/android/server/telecom/tests/PackageRemovedReceiverTest.java
new file mode 100644
index 000000000..cdd6df869
--- /dev/null
+++ b/tests/src/com/android/server/telecom/tests/PackageRemovedReceiverTest.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.server.telecom.tests;
+
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Process;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.android.server.telecom.PackageRemovedReceiver;
+import com.android.server.telecom.PhoneAccountRegistrar;
+import com.android.server.telecom.UserHandleWrapper;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class PackageRemovedReceiverTest extends TelecomTestCase {
+    private static final String TEST_PACKAGE_NAME = "com.example.testapp";
+    private static final int TEST_UID = 10123;
+
+    @Mock private PhoneAccountRegistrar mMockPhoneAccountRegistrar;
+    @Mock private Handler mMockBackgroundHandler;
+    @Mock private Intent mMockIntent;
+    @Mock private Uri mMockUri;
+    @Mock private UserHandle mMockUserHandle;
+    @Mock private UserHandleWrapper mMockUserHandleWrapper;
+
+    private PackageRemovedReceiver mReceiver;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        MockitoAnnotations.openMocks(this);
+
+        when(mMockUserHandleWrapper.getUserHandleForUid(TEST_UID)).thenReturn(mMockUserHandle);
+        when(mMockUserHandleWrapper.getUserHandleForUid(Process.INVALID_UID)).thenReturn(null);
+    }
+
+    @Override
+    @After
+    public void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    private void setupIntent(String action, Uri data, String packageName, int uid) {
+        when(mMockIntent.getAction()).thenReturn(action);
+        when(mMockIntent.getData()).thenReturn(data);
+        if (data != null) {
+            when(mMockUri.getSchemeSpecificPart()).thenReturn(packageName);
+        }
+        when(mMockIntent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID)).thenReturn(uid);
+    }
+
+    @Test
+    public void onReceive_nullAction_shouldDoNothing() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(null, mMockUri, TEST_PACKAGE_NAME, TEST_UID);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verifyNoInteractions(mMockBackgroundHandler);
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+
+    @Test
+    public void onReceive_wrongAction_shouldDoNothing() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_ADDED, mMockUri, TEST_PACKAGE_NAME, TEST_UID);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verifyNoInteractions(mMockBackgroundHandler);
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+
+    @Test
+    public void onReceive_packageFullyRemoved_nullUri_shouldLogAndReturn() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_FULLY_REMOVED, null, TEST_PACKAGE_NAME, TEST_UID);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verifyNoInteractions(mMockBackgroundHandler);
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+
+    @Test
+    public void onReceive_packageFullyRemoved_nullPackageName_shouldLogAndReturn() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_FULLY_REMOVED, mMockUri, null, TEST_UID);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verifyNoInteractions(mMockBackgroundHandler);
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+
+    @Test
+    public void onReceive_packageFullyRemoved_emptyPackageName_shouldLogAndReturn() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_FULLY_REMOVED, mMockUri, "", TEST_UID);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verifyNoInteractions(mMockBackgroundHandler);
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+
+    @Test
+    public void onReceive_packageFullyRemoved_invalidUid_shouldLogAndReturn() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_FULLY_REMOVED, mMockUri,
+                TEST_PACKAGE_NAME, Process.INVALID_UID);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verifyNoInteractions(mMockBackgroundHandler);
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+
+    @Test
+    public void onReceive_validIntent_withBackgroundHandler_shouldPostToHandler() {
+        mReceiver = new PackageRemovedReceiver(mMockPhoneAccountRegistrar,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_FULLY_REMOVED, mMockUri, TEST_PACKAGE_NAME, TEST_UID);
+
+        ArgumentCaptor<Runnable> runnableCaptor = ArgumentCaptor.forClass(Runnable.class);
+        when(mMockBackgroundHandler.post(runnableCaptor.capture())).thenReturn(true);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verify(mMockBackgroundHandler).post(Mockito.any(Runnable.class));
+
+        Runnable postedRunnable = runnableCaptor.getValue();
+        postedRunnable.run();
+
+        verify(mMockPhoneAccountRegistrar).clearAccounts(TEST_PACKAGE_NAME, mMockUserHandle);
+    }
+
+    @Test
+    public void onReceive_validIntent_withBackgroundHandler_nullRegistrar_shouldLogButNotCrash() {
+        mReceiver = new PackageRemovedReceiver(null,
+                mMockBackgroundHandler, mMockUserHandleWrapper);
+        setupIntent(Intent.ACTION_PACKAGE_FULLY_REMOVED, mMockUri, TEST_PACKAGE_NAME, TEST_UID);
+
+        ArgumentCaptor<Runnable> runnableCaptor = ArgumentCaptor.forClass(Runnable.class);
+        when(mMockBackgroundHandler.post(runnableCaptor.capture())).thenReturn(true);
+
+        mReceiver.onReceive(mContext, mMockIntent);
+
+        verify(mMockBackgroundHandler).post(Mockito.any(Runnable.class));
+        runnableCaptor.getValue().run();
+
+        verifyNoInteractions(mMockPhoneAccountRegistrar);
+    }
+}
\ No newline at end of file
diff --git a/tests/src/com/android/server/telecom/tests/ParcelableCallUtilsTest.java b/tests/src/com/android/server/telecom/tests/ParcelableCallUtilsTest.java
index 8eefd9696..1cd2b17c2 100644
--- a/tests/src/com/android/server/telecom/tests/ParcelableCallUtilsTest.java
+++ b/tests/src/com/android/server/telecom/tests/ParcelableCallUtilsTest.java
@@ -4,6 +4,8 @@ import static com.android.server.telecom.TelecomSystem.SyncRoot;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertNull;
 import static junit.framework.Assert.assertTrue;
 
 import static org.mockito.ArgumentMatchers.any;
@@ -22,6 +24,7 @@ import android.telephony.ims.ImsCallProfile;
 import androidx.test.filters.SmallTest;
 
 import com.android.server.telecom.Call;
+import com.android.server.telecom.CallState;
 import com.android.server.telecom.CallerInfoLookupHelper;
 import com.android.server.telecom.CallsManager;
 import com.android.server.telecom.ClockProxy;
@@ -129,13 +132,16 @@ public class ParcelableCallUtilsTest extends TelecomTestCase {
     public void testParcelForSystemCallScreening() {
         mCall.putConnectionServiceExtras(getSomeExtras());
         ParcelableCall call = ParcelableCallUtils.toParcelableCallForScreening(mCall,
-                true /* isPartOfSystemDialer */);
+                true /* isPartOfSystemDialer */,
+                true /* hasReadPrivilegedPhoneStatePermission */);
 
         Bundle parceledExtras = call.getExtras();
         assertTrue(parceledExtras.containsKey(Connection.EXTRA_SIP_INVITE));
         assertTrue(parceledExtras.containsKey(ImsCallProfile.EXTRA_IS_BUSINESS_CALL));
         assertFalse(parceledExtras.containsKey("SomeExtra"));
         assertFalse(parceledExtras.containsKey(Connection.EXTRA_CALL_SUBJECT));
+
+        assertNotNull(call.getAccountHandle());
     }
 
     @SmallTest
@@ -143,24 +149,33 @@ public class ParcelableCallUtilsTest extends TelecomTestCase {
     public void testParcelForSystemNonSystemCallScreening() {
         mCall.putConnectionServiceExtras(getSomeExtras());
         ParcelableCall call = ParcelableCallUtils.toParcelableCallForScreening(mCall,
-                false /* isPartOfSystemDialer */);
+                false /* isPartOfSystemDialer */,
+                false /* hasReadPrivilegedPhoneStatePermission */);
 
         Bundle parceledExtras = call.getExtras();
         assertFalse(parceledExtras.containsKey(Connection.EXTRA_SIP_INVITE));
         assertFalse(parceledExtras.containsKey(ImsCallProfile.EXTRA_IS_BUSINESS_CALL));
         assertFalse(parceledExtras.containsKey("SomeExtra"));
         assertFalse(parceledExtras.containsKey(Connection.EXTRA_CALL_SUBJECT));
+
+        assertNull(call.getAccountHandle());
     }
 
     @SmallTest
     @Test
     public void testVerificationStatusParcelingForScreening() {
-        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_NOT_VERIFIED, false);
-        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_NOT_VERIFIED, true);
-        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_PASSED, false);
-        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_PASSED, true);
-        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_FAILED, false);
-        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_FAILED, true);
+        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_NOT_VERIFIED, false,
+                false);
+        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_NOT_VERIFIED, true,
+                false);
+        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_PASSED, false,
+                false);
+        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_PASSED, true,
+                false);
+        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_FAILED, false,
+                false);
+        checkVerStatParcelingForCallScreening(Connection.VERIFICATION_STATUS_FAILED, true,
+                false);
     }
 
     @SmallTest
@@ -174,11 +189,39 @@ public class ParcelableCallUtilsTest extends TelecomTestCase {
         checkVerStatParcelingForDialer(Connection.VERIFICATION_STATUS_FAILED, true);
     }
 
+    @SmallTest
+    @Test
+    public void testTreatCallStateAnsweredAsActive() {
+        int prevCallState = mCall.getState();
+        mCall.setState(CallState.ANSWERED, null);
+        // Verify that if we're parceling the call for the BT ICS that we translate the call state
+        // to ACTIVE.
+        ParcelableCall call = ParcelableCallUtils.toParcelableCall(mCall,
+                false /* includeVideoProvider */, null /* phoneAccountRegistrar */,
+                false /* supportsExternalCalls */, -1 /* overrideState */,
+                false /* includeRttCall */, false /* isForSystemInCallService */,
+                true /* isBluetoothInCallService */);
+        // Verify that setting call state to ANSWERED is processed as ACTIVE from telecom fwk
+        assertEquals(call.getState(), android.telecom.Call.STATE_ACTIVE);
+        // Now verify that if we're not parceling the call for the BT ICS that we continue to
+        // translate the call state to RINGING.
+        ParcelableCall call2 = ParcelableCallUtils.toParcelableCall(mCall,
+                false /* includeVideoProvider */, null /* phoneAccountRegistrar */,
+                false /* supportsExternalCalls */, -1 /* overrideState */,
+                false /* includeRttCall */, false /* isForSystemInCallService */,
+                false /* isBluetoothInCallService */);
+        // Verify that setting call state to ANSWERED is processed as RINGING from telecom fwk
+        assertEquals(call2.getState(), android.telecom.Call.STATE_RINGING);
+        // Restore call state after test verification
+        mCall.setState(prevCallState, null);
+    }
+
     private void checkVerStatParcelingForCallScreening(int connectionVerificationStatus,
-            boolean isForSystemDialer) {
+            boolean isForSystemDialer, boolean hasReadPrivilegedPhoneStatePermission) {
         mCall.setCallerNumberVerificationStatus(connectionVerificationStatus);
         ParcelableCall call = ParcelableCallUtils.toParcelableCallForScreening(mCall,
-                isForSystemDialer /* isPartOfSystemDialer */);
+                isForSystemDialer /* isPartOfSystemDialer */,
+                hasReadPrivilegedPhoneStatePermission);
         assertEquals(connectionVerificationStatus, call.getCallerNumberVerificationStatus());
     }
 
diff --git a/tests/src/com/android/server/telecom/tests/PhoneAccountRegistrarTest.java b/tests/src/com/android/server/telecom/tests/PhoneAccountRegistrarTest.java
index 23e8dab26..50f436dab 100644
--- a/tests/src/com/android/server/telecom/tests/PhoneAccountRegistrarTest.java
+++ b/tests/src/com/android/server/telecom/tests/PhoneAccountRegistrarTest.java
@@ -140,9 +140,9 @@ public class PhoneAccountRegistrarTest extends TelecomTestCase {
         mRegistrar = new PhoneAccountRegistrar(
                 mComponentContextFixture.getTestDouble().getApplicationContext(), mLock, FILE_NAME,
                 mDefaultDialerCache, mAppLabelProxy, mTelephonyFeatureFlags, mFeatureFlags);
-        when(mFeatureFlags.onlyUpdateTelephonyOnValidSubIds()).thenReturn(false);
         when(mFeatureFlags.unregisterUnresolvableAccounts()).thenReturn(true);
         when(mTelephonyFeatureFlags.workProfileApiSplit()).thenReturn(false);
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(true);
     }
 
     @Override
diff --git a/tests/src/com/android/server/telecom/tests/RingerTest.java b/tests/src/com/android/server/telecom/tests/RingerTest.java
index 9c9dbf6d6..602238bd5 100644
--- a/tests/src/com/android/server/telecom/tests/RingerTest.java
+++ b/tests/src/com/android/server/telecom/tests/RingerTest.java
@@ -22,7 +22,11 @@ import static android.provider.Settings.Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
 import static org.junit.Assume.assumeNotNull;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -59,6 +63,7 @@ import android.os.VibrationEffect;
 import android.os.Vibrator;
 import android.os.VibratorInfo;
 import android.platform.test.annotations.EnableFlags;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.platform.test.flag.junit.CheckFlagsRule;
 import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.platform.test.flag.junit.SetFlagsRule;
@@ -73,6 +78,7 @@ import androidx.test.platform.app.InstrumentationRegistry;
 import com.android.server.telecom.AnomalyReporterAdapter;
 import com.android.server.telecom.AsyncRingtonePlayer;
 import com.android.server.telecom.Call;
+import com.android.server.telecom.CallConnectedIndicatorSettings;
 import com.android.server.telecom.CallState;
 import com.android.server.telecom.InCallController;
 import com.android.server.telecom.InCallTonePlayer;
@@ -80,6 +86,7 @@ import com.android.server.telecom.Ringer;
 import com.android.server.telecom.RingtoneFactory;
 import com.android.server.telecom.SystemSettingsUtil;
 import com.android.server.telecom.flags.FeatureFlags;
+import com.android.server.telecom.flags.FeatureFlagsImpl;
 
 import org.junit.After;
 import org.junit.Before;
@@ -93,6 +100,11 @@ import org.mockito.Spy;
 
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
 @RunWith(JUnit4.class)
@@ -123,13 +135,15 @@ public class RingerTest extends TelecomTestCase {
     @Mock InCallTonePlayer.Factory mockPlayerFactory;
     @Mock SystemSettingsUtil mockSystemSettingsUtil;
     @Mock RingtoneFactory mockRingtoneFactory;
-    @Mock Vibrator mockVibrator;
+    @Mock Ringer.VibratorAdapter mockVibrator;
+    @Mock Vibrator mockDefaultVibrator;
     @Mock VibratorInfo mockVibratorInfo;
     @Mock InCallController mockInCallController;
     @Mock NotificationManager mockNotificationManager;
     @Mock Ringer.AccessibilityManagerAdapter mockAccessibilityManagerAdapter;
     @Mock private FeatureFlags mFeatureFlags;
     @Mock private AnomalyReporterAdapter mAnomalyReporterAdapter;
+    @Mock private CallConnectedIndicatorSettings mCallConnectedIndicatorSettings;
 
     @Spy Ringer.VibrationEffectProxy spyVibrationEffectProxy;
 
@@ -143,7 +157,7 @@ public class RingerTest extends TelecomTestCase {
 
     TestLooperManager mLooperManager;
     boolean mIsHapticPlaybackSupported = true;  // Note: initializeRinger() after changes.
-    AsyncRingtonePlayer asyncRingtonePlayer = new AsyncRingtonePlayer();
+    AsyncRingtonePlayer asyncRingtonePlayer;
     Ringer mRingerUnderTest;
     AudioManager mockAudioManager;
     CompletableFuture<Void> mRingCompletionFuture = new CompletableFuture<>();
@@ -154,12 +168,21 @@ public class RingerTest extends TelecomTestCase {
         super.setUp();
         mContext = spy(mComponentContextFixture.getTestDouble().getApplicationContext());
         when(mFeatureFlags.telecomResolveHiddenDependencies()).thenReturn(true);
-        when(mFeatureFlags.ensureInCarRinging()).thenReturn(false);
+        // Use the ACTUAL device setting for this flag at run time -- we ideally shouldn't be
+        // mocking flag values like we are as it means they're pretty much always false.  In this
+        // case the success/failure of the test should be tied to whether the flag is on or off
+        // for this device configuration.
+        FeatureFlags featureFlags = new FeatureFlagsImpl();
+        when(mFeatureFlags.resolveHiddenDependenciesTwo()).thenReturn(
+                featureFlags.resolveHiddenDependenciesTwo());
+         asyncRingtonePlayer = new AsyncRingtonePlayer(mFeatureFlags);
         doReturn(URI_VIBRATION_EFFECT).when(spyVibrationEffectProxy).get(any(), any());
         when(mockPlayerFactory.createPlayer(any(Call.class), anyInt())).thenReturn(mockTonePlayer);
-        mockAudioManager = mContext.getSystemService(AudioManager.class);
+        mockAudioManager = mock(AudioManager.class);
+        when(mContext.getSystemService(AudioManager.class)).thenReturn(mockAudioManager);
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
-        when(mockVibrator.getInfo()).thenReturn(mockVibratorInfo);
+        when(mockVibrator.getVibrator()).thenReturn(mockDefaultVibrator);
+        when(mockDefaultVibrator.getInfo()).thenReturn(mockVibratorInfo);
         when(mockSystemSettingsUtil.isHapticPlaybackSupported(any(Context.class)))
                 .thenAnswer((invocation) -> mIsHapticPlaybackSupported);
         mockNotificationManager =mContext.getSystemService(NotificationManager.class);
@@ -171,6 +194,7 @@ public class RingerTest extends TelecomTestCase {
         when(mockCall2.getAssociatedUser()).thenReturn(PA_HANDLE.getUserHandle());
         when(mockCall1.getTargetPhoneAccount()).thenReturn(PA_HANDLE);
         when(mockCall2.getTargetPhoneAccount()).thenReturn(PA_HANDLE);
+        when(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled()).thenReturn(false);
         // Set BT active state in tests to ensure that we do not end up blocking tests for 1 sec
         // waiting for BT to connect in unit tests by default.
         asyncRingtonePlayer.updateBtActiveState(true);
@@ -186,7 +210,8 @@ public class RingerTest extends TelecomTestCase {
         mRingerUnderTest = new Ringer(mockPlayerFactory, mContext, mockSystemSettingsUtil,
                 asyncRingtonePlayer, mockRingtoneFactory, mockVibrator, spyVibrationEffectProxy,
                 mockInCallController, mockNotificationManager, mockAccessibilityManagerAdapter,
-                mFeatureFlags, mAnomalyReporterAdapter);
+                mFeatureFlags, mAnomalyReporterAdapter, mCallConnectedIndicatorSettings,
+                Runnable::run);
         // This future is used to wait for AsyncRingtonePlayer to finish its part.
         mRingerUnderTest.setBlockOnRingingFuture(mRingCompletionFuture);
     }
@@ -194,6 +219,9 @@ public class RingerTest extends TelecomTestCase {
     @Override
     @After
     public void tearDown() throws Exception {
+        if (mRingerUnderTest != null) {
+            mRingerUnderTest.shutdownExecutor();
+        }
         super.tearDown();
     }
 
@@ -384,7 +412,7 @@ public class RingerTest extends TelecomTestCase {
         verifyNoMoreInteractions(mockRingtoneFactory);
         verify(mockTonePlayer, never()).stopTone();
         verify(mockVibrator, never())
-                .vibrate(any(VibrationEffect.class), any(AudioAttributes.class));
+                .vibrate(any(VibrationEffect.class), any(VibrationAttributes.class));
     }
 
     @SmallTest
@@ -457,7 +485,6 @@ public class RingerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testAudibleRingWhenNotificationSoundShouldPlay() throws Exception {
-        when(mFeatureFlags.ensureInCarRinging()).thenReturn(true);
         Ringtone mockRingtone = ensureRingtoneMocked();
 
         mRingerUnderTest.startCallWaiting(mockCall1);
@@ -468,9 +495,11 @@ public class RingerTest extends TelecomTestCase {
         when(mockAudioManager.shouldNotificationSoundPlay(aa)).thenReturn(true);
         enableVibrationWhenRinging();
 
-        // This will set AudioManager#getStreamVolume to 0. This test ensures that whether a
-        // ringtone is audible is controlled by AudioManager#shouldNotificationSoundPlay instead:
-        ensureRingerIsNotAudible();
+        // This will set AudioManager#getStreamVolume to 0. This test ensures that
+        // whether a ringtone is audible is controlled by AudioManager#shouldNotificationSoundPlay
+        // instead:
+        when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
+        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(0);
 
         // Ensure an audible ringtone is played:
         assertTrue(startRingingAndWaitForAsync(mockCall2, false));
@@ -487,7 +516,6 @@ public class RingerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testNoAudibleRingWhenNotificationSoundShouldNotPlay() throws Exception {
-        when(mFeatureFlags.ensureInCarRinging()).thenReturn(true);
         Ringtone mockRingtone = ensureRingtoneMocked();
 
         mRingerUnderTest.startCallWaiting(mockCall1);
@@ -498,9 +526,11 @@ public class RingerTest extends TelecomTestCase {
         when(mockAudioManager.shouldNotificationSoundPlay(aa)).thenReturn(false);
         enableVibrationWhenRinging();
 
-        // This will set AudioManager#getStreamVolume to 100. This test ensures that whether a
-        // ringtone is audible is controlled by AudioManager#shouldNotificationSoundPlay instead:
-        ensureRingerIsAudible();
+        // This will set AudioManager#getStreamVolume to 100. This test ensures that
+        // whether a ringtone is audible is controlled by AudioManager#shouldNotificationSoundPlay
+        // instead:
+        when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
+        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(100);
 
         // Ensure no audible ringtone is played:
         assertFalse(startRingingAndWaitForAsync(mockCall2, false));
@@ -520,6 +550,8 @@ public class RingerTest extends TelecomTestCase {
         mRingerUnderTest.startCallWaiting(mockCall1);
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
         enableVibrationWhenRinging();
+        // Need audio to be considered playable
+        ensureRingerIsAudible();
         // The ringtone isn't known to be null until the async portion after the call completes,
         // so startRinging still returns true here as there should nominally be a ringtone.
         // Notably, vibration still happens in this scenario.
@@ -545,7 +577,8 @@ public class RingerTest extends TelecomTestCase {
         when(mockRingtoneFactory.getRingtone(any(Call.class), eq(null), anyBoolean()))
             .thenReturn(new Pair(FAKE_RINGTONE_URI, mockRingtone));
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_VIBRATE);
-        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(0);
+        when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                .thenReturn(false);
         enableVibrationWhenRinging();
         assertFalse(startRingingAndWaitForAsync(mockCall2, false));
         verify(mockTonePlayer).stopTone();
@@ -562,7 +595,8 @@ public class RingerTest extends TelecomTestCase {
         createRingerUnderTest();  // Needed after changing haptic playback support.
         mRingerUnderTest.startCallWaiting(mockCall1);
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_VIBRATE);
-        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(0);
+        when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                .thenReturn(false);
         enableVibrationWhenRinging();
         assertFalse(startRingingAndWaitForAsync(mockCall2, false));
         verify(mockTonePlayer).stopTone();
@@ -581,6 +615,8 @@ public class RingerTest extends TelecomTestCase {
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
         when(mockRingtone.getUri()).thenReturn(FAKE_RINGTONE_URI);
         enableVibrationWhenRinging();
+        // Need audio to be considered playable
+        ensureRingerIsAudible();
         assertTrue(startRingingAndWaitForAsync(mockCall2, false));
         verify(mockTonePlayer).stopTone();
         verify(mockRingtoneFactory, atLeastOnce())
@@ -631,7 +667,8 @@ public class RingerTest extends TelecomTestCase {
     public void testSilentRingWithHfpStillAcquiresFocus() throws Exception {
         mRingerUnderTest.startCallWaiting(mockCall1);
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
-        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(0);
+        when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                .thenReturn(false);
         enableVibrationOnlyWhenNotRinging();
         assertTrue(startRingingAndWaitForAsync(mockCall2, true));
         verify(mockTonePlayer).stopTone();
@@ -647,8 +684,11 @@ public class RingerTest extends TelecomTestCase {
         mRingerUnderTest.startCallWaiting(mockCall1);
         Ringtone mockRingtone = ensureRingtoneMocked();
         when(mockNotificationManager.getZenMode()).thenReturn(ZEN_MODE_IMPORTANT_INTERRUPTIONS);
+        when(mockNotificationManager.getCurrentInterruptionFilter()).thenReturn(
+                NotificationManager.INTERRUPTION_FILTER_PRIORITY);
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_SILENT);
-        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(100);
+        when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                .thenReturn(true);
         enableVibrationWhenRinging();
         assertTrue(startRingingAndWaitForAsync(mockCall2, true));
         verify(mockRingtoneFactory, atLeastOnce())
@@ -661,6 +701,14 @@ public class RingerTest extends TelecomTestCase {
     @SmallTest
     @Test
     public void testDelayRingerForBtHfpDevices() throws Exception {
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            delayRingerForBtHfpDevicesExecutor();
+        } else {
+            delayRingerForBtHfpDevicesHandler();
+        }
+    }
+
+    private void delayRingerForBtHfpDevicesHandler() throws Exception {
         acquireLooper();
 
         asyncRingtonePlayer.updateBtActiveState(false);
@@ -688,9 +736,84 @@ public class RingerTest extends TelecomTestCase {
         assertFalse(mRingerUnderTest.isRinging());
     }
 
+    private void delayRingerForBtHfpDevicesExecutor() throws Exception {
+        asyncRingtonePlayer.updateBtActiveState(false);
+        Ringtone mockRingtone = ensureRingtoneMocked();
+
+        ensureRingerIsAudible();
+        assertTrue(mRingerUnderTest.startRinging(mockCall1, true /* isHfpDeviceConnected */));
+        assertTrue(mRingerUnderTest.isRinging());
+
+        // For Executor, the PlayRunnable is submitted and runs up to the latch await on its own.
+        // At this point, ringtone play should be delayed
+        verify(mockRingtone, never()).play(); // Verify play() has NOT been called yet
+
+        // Now, simulate BT HFP audio becoming active
+        asyncRingtonePlayer.updateBtActiveState(true);
+        // For Executor, the latch is released, and PlayRunnable proceeds on its own.
+
+        // Wait for the asynchronous play operation to complete its BiConsumer callback
+        try {
+            mRingCompletionFuture.get(1, TimeUnit.SECONDS);
+        } catch (Exception e) {
+            throw new AssertionError("mRingCompletionFuture did not complete after BT" +
+                    " active state update in Executor path.", e);
+        }
+
+        // Verifications after play should have started
+        verify(mockRingtoneFactory, atLeastOnce())
+                .getRingtone(any(Call.class), nullable(VolumeShaper.Configuration.class),
+                        anyBoolean());
+        verifyNoMoreInteractions(mockRingtoneFactory);
+        verify(mockRingtone).play();
+
+        // Now stop ringing
+        mRingerUnderTest.stopRinging();
+
+        // For Executor, the StopRunnable is posted.
+        // Wait for the stop() call on the mockRingtone with a timeout.
+        verify(mockRingtone, timeout(500).times(1)).stop();
+
+        assertFalse(mRingerUnderTest.isRinging()); // Ringer state should be updated
+    }
+
     @SmallTest
     @Test
     public void testUnblockRingerForStopCommand() throws Exception {
+        if (mFeatureFlags.resolveHiddenDependenciesTwo()) {
+            unblockRingerForStopCommandExecutor();
+        } else {
+            unblockRingerForStopCommandHandler();
+        }
+    }
+
+    private void unblockRingerForStopCommandExecutor() {
+        asyncRingtonePlayer.updateBtActiveState(false); // Make play wait on latch
+        Ringtone mockRingtone = ensureRingtoneMocked();
+
+        ensureRingerIsAudible();
+        assertTrue(mRingerUnderTest.startRinging(mockCall1, true /* isHfpDeviceConnected */));
+
+        mRingerUnderTest.stopRinging();
+        try {
+            // Wait for the play pathway in AsyncRingtonePlayer to acknowledge the stop
+            // by invoking its consumer, which in turn completes this future.
+            mRingCompletionFuture.get(1, TimeUnit.SECONDS);
+        } catch (Exception e) {
+            throw new AssertionError("mRingCompletionFuture did not complete after" +
+                    " stopRinging. Indicates play operation was not properly unblocked and" +
+                    " terminated", e);
+        }
+
+        // Verifications:
+        // 1. The ringtone should never have started playing because it was stopped while waiting.
+        verify(mockRingtone, never()).play();
+
+        // 2. The Ringer itself should no longer be in a ringing state.
+        assertFalse(mRingerUnderTest.isRinging());
+    }
+
+    private void unblockRingerForStopCommandHandler() {
         acquireLooper();
 
         asyncRingtonePlayer.updateBtActiveState(false);
@@ -771,6 +894,52 @@ public class RingerTest extends TelecomTestCase {
         verify(mockNotificationManager, never()).matchesCallFilter(any(Uri.class));
     }
 
+    /**
+     * Ensure that when the call filter did not run we will re-computer it in Ringer.
+     */
+    @Test
+    @RequiresFlagsEnabled(com.android.server.telecom.flags.Flags.FLAG_VOIP_DND_FOCUS)
+    public void testShouldRingForContact_matchesCallfilterIsNotComputed() {
+        // We assume the caller cannot bypass DND.
+        when(mockNotificationManager.matchesCallFilter(any(Uri.class))).thenReturn(false);
+
+        // WHEN
+        // This should mean we are recomputing "matchesCallFilter".
+        when(mockCall1.wasDndCheckComputedForCall()).thenReturn(false);
+
+        // THEN
+        assertFalse(mRingerUnderTest.shouldRingForContact(mockCall1));
+        // Because DND Filter was not computed, we should not check the call.
+        verify(mockCall1, never()).isCallSuppressedByDoNotDisturb();
+        // This should not have been set on the call since it was never computed.
+        verify(mockCall1, never()).setCallIsSuppressedByDoNotDisturb(anyBoolean());
+        // Expect this to be recomputed now, where it did not in the prior case.
+        verify(mockNotificationManager).matchesCallFilter(any(Uri.class));
+    }
+
+    /**
+     * Ensure that when the call filter did not run we will re-computer it in Ringer.
+     */
+    @Test
+    @RequiresFlagsEnabled(com.android.server.telecom.flags.Flags.FLAG_VOIP_DND_FOCUS)
+    public void testShouldRingForContact_matchesCallfilterIsNotComputedTwo() {
+        // We assume the caller can bypass DND.
+        when(mockNotificationManager.matchesCallFilter(any(Uri.class))).thenReturn(true);
+
+        // WHEN
+        // This should mean we are recomputing "matchesCallFilter".
+        when(mockCall1.wasDndCheckComputedForCall()).thenReturn(false);
+
+        // THEN
+        assertTrue(mRingerUnderTest.shouldRingForContact(mockCall1));
+        // Because DND Filter was not computed, we should not check the call.
+        verify(mockCall1, never()).isCallSuppressedByDoNotDisturb();
+        // This should not have been called since it was not determined during filtering.
+        verify(mockCall1, never()).setCallIsSuppressedByDoNotDisturb(anyBoolean());
+        // Expect this to be recomputed now, where it did not in the prior case.
+        verify(mockNotificationManager).matchesCallFilter(any(Uri.class));
+    }
+
     @Test
     public void testNoFlashNotificationWhenCallSuppressed() throws Exception {
         ensureRingtoneMocked();
@@ -794,6 +963,9 @@ public class RingerTest extends TelecomTestCase {
         when(mockCall2.wasDndCheckComputedForCall()).thenReturn(false);
         when(mockCall2.getHandle()).thenReturn(Uri.parse(""));
 
+        // Ringer needs to be audible to start flash/ring
+        ensureRingerIsAudible();
+
         assertTrue(mRingerUnderTest.shouldRingForContact(mockCall2));
         assertTrue(startRingingAndWaitForAsync(mockCall2, false));
         verify(mockAccessibilityManagerAdapter, atLeastOnce())
@@ -820,6 +992,9 @@ public class RingerTest extends TelecomTestCase {
         when(mockCall2.wasDndCheckComputedForCall()).thenReturn(false);
         when(mockCall2.getHandle()).thenReturn(Uri.parse(""));
 
+        // Ringer needs to be audible to start flash/ring
+        ensureRingerIsAudible();
+
         assertTrue(mRingerUnderTest.shouldRingForContact(mockCall2));
         assertTrue(mRingerUnderTest.startRinging(mockCall2, false));
         mRingerUnderTest.stopRinging();
@@ -870,7 +1045,8 @@ public class RingerTest extends TelecomTestCase {
 
             mRingerUnderTest.startCallWaiting(mockCall1);
             when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_VIBRATE);
-            when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(0);
+            when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                    .thenReturn(false);
             enableVibrationWhenRinging();
             assertFalse(startRingingAndWaitForAsync(mockCall2, false));
 
@@ -890,34 +1066,70 @@ public class RingerTest extends TelecomTestCase {
 
     @SmallTest
     @Test
-    @EnableFlags(Flags.FLAG_ENABLE_RINGTONE_HAPTICS_CUSTOMIZATION)
-    public void testNotMuteHapticChannelWithRampingRinger() throws Exception {
-        final Context context = ApplicationProvider.getApplicationContext();
-        Uri defaultRingtoneUri = RingtoneManager.getActualDefaultRingtoneUri(context,
-                RingtoneManager.TYPE_RINGTONE);
-        assumeNotNull(defaultRingtoneUri);
-        Uri FAKE_RINGTONE_VIBRATION_URI = defaultRingtoneUri.buildUpon().appendQueryParameter(
-                        VIBRATION_PARAM, FAKE_VIBRATION_URI.toString()).build();
-        mComponentContextFixture.putBooleanResource(
-                com.android.internal.R.bool.config_ringtoneVibrationSettingsSupported, true);
-        ArgumentCaptor<Boolean> muteHapticChannelCaptor = ArgumentCaptor.forClass(Boolean.class);
+    public void testStartVibratingForOutgoingCallActive() throws Exception {
+        when(mFeatureFlags.callConnectedIndicatorPreference()).thenReturn(true);
+        when(mCallConnectedIndicatorSettings.isCallConnectedVibrationEnabled()).thenReturn(true);
+        createRingerUnderTest();
+
+        mRingerUnderTest.startVibratingForOutgoingCallActive();
+        verify(mockVibrator).vibrate(any(VibrationEffect.class), any(VibrationAttributes.class));
+    }
+
+    /**
+     * Verifies that the Ringer's internal ExecutorService is correctly shut down via
+     * {@link Ringer#shutdownExecutor()} and can be re-initialized on a subsequent call to
+     * {@link Ringer#getExecutor()}.
+     */
+    @SmallTest
+    @Test
+    public void testExecutorServiceLifecycle_ShutdownAndRecreation() throws Exception {
+        // Get the initial executor and verify it's active
+        ExecutorService executor1 = mRingerUnderTest.getExecutor();
+        assertNotNull(executor1);
+        assertFalse("ExecutorService should not be shutdown initially", executor1.isShutdown());
+
+        // Ensure it can execute a task
+        CountDownLatch task1Latch = new CountDownLatch(1);
+        executor1.execute(task1Latch::countDown);
+        assertTrue("Task 1 should execute on initial executor",
+                task1Latch.await(1, TimeUnit.SECONDS));
+
+        // Shutdown the executor
+        mRingerUnderTest.shutdownExecutor();
+
+        // Verify the original executor instance is shutdown
+        assertTrue("ExecutorService (exec1) should be shutdown after call to shutdownExecutor()",
+                executor1.isShutdown());
+        // Depending on the exact implementation of shutdownExecutor,
+        // isTerminated might also be true or become true quickly.
+        // shutdownExecutor calls awaitTermination, so it should be terminated.
+        assertTrue("ExecutorService (exec1) should be terminated",
+                executor1.awaitTermination(500, TimeUnit.MILLISECONDS));
+
+
+        // Attempting to execute on the old, shutdown executor should fail
         try {
-            RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE,
-                    FAKE_RINGTONE_VIBRATION_URI);
-            createRingerUnderTest(); // Needed after mock the config.
-            mRingerUnderTest.startCallWaiting(mockCall1);
-            ensureRingerIsAudible();
-            enableRampingRinger();
-            enableVibrationWhenRinging();
-            assertTrue(startRingingAndWaitForAsync(mockCall2, false));
-            verify(mockRingtoneFactory, atLeastOnce()).getRingtone(any(Call.class),
-                    nullable(VolumeShaper.Configuration.class), muteHapticChannelCaptor.capture());
-            assertFalse(muteHapticChannelCaptor.getValue());
-        } finally {
-            // Restore the default ringtone Uri
-            RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE,
-                    defaultRingtoneUri);
+            executor1.execute(() -> {
+                // This should not run
+            });
+            fail("Executing a task on a shutdown executor (exec1) should throw" +
+                    " RejectedExecutionException");
+        } catch (RejectedExecutionException e) {
+            // Expected behavior
         }
+
+        // Get the executor again; it should be a new, active instance
+        ExecutorService executor2 = mRingerUnderTest.getExecutor();
+        assertNotNull(executor2);
+        assertNotSame("Should get a new ExecutorService instance after shutdown and re-request",
+                executor1, executor2);
+        assertFalse("New ExecutorService (exec2) should not be shutdown", executor2.isShutdown());
+
+        // Ensure the new executor can execute tasks
+        CountDownLatch task2Latch = new CountDownLatch(1);
+        executor2.execute(task2Latch::countDown);
+        assertTrue("Task 2 should execute on new executor (exec2)",
+                task2Latch.await(1, TimeUnit.SECONDS));
     }
 
     /**
@@ -934,22 +1146,26 @@ public class RingerTest extends TelecomTestCase {
 
     private void ensureRingerIsAudible() {
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
-        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(100);
+        when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                .thenReturn(true);
     }
 
     private void ensureRingerIsNotAudible() {
         when(mockAudioManager.getRingerMode()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
-        when(mockAudioManager.getStreamVolume(AudioManager.STREAM_RING)).thenReturn(0);
+        when(mockAudioManager.shouldNotificationSoundPlay(any(AudioAttributes.class)))
+                .thenReturn(false);
     }
 
     private void enableVibrationWhenRinging() {
         when(mockVibrator.hasVibrator()).thenReturn(true);
-        when(mockSystemSettingsUtil.isRingVibrationEnabled(any(Context.class))).thenReturn(true);
+        when(mockSystemSettingsUtil.isRingVibrationEnabled(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(true);
     }
 
     private void enableVibrationOnlyWhenNotRinging() {
         when(mockVibrator.hasVibrator()).thenReturn(true);
-        when(mockSystemSettingsUtil.isRingVibrationEnabled(any(Context.class))).thenReturn(false);
+        when(mockSystemSettingsUtil.isRingVibrationEnabled(any(Context.class),
+                any(FeatureFlags.class))).thenReturn(false);
     }
 
     private void enableRampingRinger() {
diff --git a/tests/src/com/android/server/telecom/tests/RingtoneFactoryTest.java b/tests/src/com/android/server/telecom/tests/RingtoneFactoryTest.java
new file mode 100644
index 000000000..6658f7f50
--- /dev/null
+++ b/tests/src/com/android/server/telecom/tests/RingtoneFactoryTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.telecom.tests;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import android.media.Ringtone;
+import android.net.Uri;
+import android.os.UserHandle;
+import android.util.Pair;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.telecom.CallsManager;
+import com.android.server.telecom.Call;
+import com.android.server.telecom.RingtoneFactory;
+import com.android.server.telecom.flags.FeatureFlags;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+
+@RunWith(JUnit4.class)
+public class RingtoneFactoryTest extends TelecomTestCase {
+    @Mock private Uri mockCustomRingtoneUri;
+    @Mock private CallsManager mockCallsManager;
+    @Mock private FeatureFlags mockFeatureFlags;
+    @Mock Call mockCall;
+    private RingtoneFactory ringtoneFactory;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        mContext = spy(mComponentContextFixture.getTestDouble().getApplicationContext());
+        ringtoneFactory = new RingtoneFactory(mockCallsManager, mContext, mockFeatureFlags);
+    }
+
+    @Override
+    @After
+    public void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    @SmallTest
+    @Test
+    public void testCustomRingtoneAccessibleWhenUserOwnsCustomRingtone() throws Exception {
+        // Current User is User 10:
+        when(mockCall.getAssociatedUser()).thenReturn(new UserHandle(10));
+
+        // Custom ringtone is owned by User 10:
+        when(mockCall.getRingtone()).thenReturn(mockCustomRingtoneUri);
+        when(mockCustomRingtoneUri.getUserInfo()).thenReturn("10");
+
+        // Ensure access to the custom ringtone is allowed:
+        Pair<Uri, Ringtone> ringtonePair = ringtoneFactory.getRingtone(mockCall, null, false);
+        assertEquals(mockCustomRingtoneUri, ringtonePair.first);
+    }
+
+    @SmallTest
+    @Test
+    public void testCustomRingtoneAccessibleWhenUserInfoNull() throws Exception {
+        // Current User is User 0:
+        when(mockCall.getAssociatedUser()).thenReturn(new UserHandle(0));
+
+        // Custom ringtone is owned by User 0:
+        when(mockCall.getRingtone()).thenReturn(mockCustomRingtoneUri);
+
+        // Mock the behavior of a custom ringtone on User 0:
+        when(mockCustomRingtoneUri.getUserInfo()).thenReturn(null);
+
+        // Ensure access to the custom ringtone is allowed:
+        Pair<Uri, Ringtone> ringtonePair = ringtoneFactory.getRingtone(mockCall, null, false);
+        assertEquals(mockCustomRingtoneUri, ringtonePair.first);
+    }
+
+    @SmallTest
+    @Test
+    public void testCustomRingtoneNotAccessibleByOtherUser() throws Exception {
+        // Current User is User 0:
+        when(mockCall.getAssociatedUser()).thenReturn(new UserHandle(0));
+
+        // Custom ringtone is owned by User 10:
+        when(mockCall.getRingtone()).thenReturn(mockCustomRingtoneUri);
+        when(mockCustomRingtoneUri.getUserInfo()).thenReturn("10");
+
+        // Ensure access to the custom ringtone is NOT allowed:
+        Pair<Uri, Ringtone> ringtonePair = ringtoneFactory.getRingtone(mockCall, null, false);
+        assertNotEquals(mockCustomRingtoneUri, ringtonePair.first);
+    }
+}
\ No newline at end of file
diff --git a/tests/src/com/android/server/telecom/tests/SessionManagerTest.java b/tests/src/com/android/server/telecom/tests/SessionManagerTest.java
index 631d52290..7576bbc44 100644
--- a/tests/src/com/android/server/telecom/tests/SessionManagerTest.java
+++ b/tests/src/com/android/server/telecom/tests/SessionManagerTest.java
@@ -27,8 +27,6 @@ import android.telecom.Log;
 import android.telecom.Logging.Session;
 import android.telecom.Logging.SessionManager;
 
-import com.android.server.telecom.flags.Flags;
-
 import androidx.test.filters.SmallTest;
 
 import org.junit.After;
@@ -418,11 +416,9 @@ public class SessionManagerTest extends TelecomTestCase {
      * If Telecom gets into a situation where there are MANY sub-sessions created in a deep tree,
      * ensure that cleanup still happens properly.
      */
-    @SmallTest
+    @SmallTest 
     @Test
     public void testManySubsessionCleanupStress() {
-        // This test will mostly likely fail with recursion due to stack overflow
-        if (!Flags.endSessionImprovements()) return;
         Log.setIsExtendedLoggingEnabled(false);
         mTestSessionManager.mCurrentThreadId = () -> TEST_PARENT_THREAD_ID;
         mTestSessionManager.startSession(TEST_PARENT_NAME, null);
diff --git a/tests/src/com/android/server/telecom/tests/TelecomMetricsControllerTest.java b/tests/src/com/android/server/telecom/tests/TelecomMetricsControllerTest.java
index 3e128e62d..59b310775 100644
--- a/tests/src/com/android/server/telecom/tests/TelecomMetricsControllerTest.java
+++ b/tests/src/com/android/server/telecom/tests/TelecomMetricsControllerTest.java
@@ -16,6 +16,7 @@
 package com.android.server.telecom.tests;
 
 import static com.android.server.telecom.TelecomStatsLog.CALL_AUDIO_ROUTE_STATS;
+import static com.android.server.telecom.TelecomStatsLog.CALL_SEQUENCING_STATS;
 import static com.android.server.telecom.TelecomStatsLog.CALL_STATS;
 import static com.android.server.telecom.TelecomStatsLog.TELECOM_API_STATS;
 import static com.android.server.telecom.TelecomStatsLog.TELECOM_ERROR_STATS;
@@ -36,6 +37,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 
 import com.android.server.telecom.metrics.ApiStats;
 import com.android.server.telecom.metrics.AudioRouteStats;
+import com.android.server.telecom.metrics.CallSequencingStats;
 import com.android.server.telecom.metrics.CallStats;
 import com.android.server.telecom.metrics.ErrorStats;
 import com.android.server.telecom.metrics.EventStats;
@@ -64,6 +66,7 @@ public class TelecomMetricsControllerTest extends TelecomTestCase {
     ErrorStats mErrorStats;
     @Mock
     EventStats mEventStats;
+    @Mock CallSequencingStats mCallSequencingStats;
 
     HandlerThread mHandlerThread;
 
@@ -123,6 +126,13 @@ public class TelecomMetricsControllerTest extends TelecomTestCase {
         assertThat(stats1).isSameInstanceAs(stats2);
     }
 
+    @Test
+    public void testGetCallSequencingStatsReturnsSameInstance() {
+        CallSequencingStats stats1 = mTelecomMetricsController.getCallSequencingStats();
+        CallSequencingStats stats2 = mTelecomMetricsController.getCallSequencingStats();
+        assertThat(stats1).isSameInstanceAs(stats2);
+    }
+
     @Test
     public void testOnPullAtomReturnsPullSkipIfAtomNotRegistered() {
         mTelecomMetricsController.getStats().clear();
@@ -154,6 +164,7 @@ public class TelecomMetricsControllerTest extends TelecomTestCase {
         verify(statsManager, times(1)).clearPullAtomCallback(eq(TELECOM_API_STATS));
         verify(statsManager, times(1)).clearPullAtomCallback(eq(TELECOM_ERROR_STATS));
         verify(statsManager, times(1)).clearPullAtomCallback(eq(TELECOM_EVENT_STATS));
+        verify(statsManager, times(1)).clearPullAtomCallback(eq(CALL_SEQUENCING_STATS));
         assertThat(mTelecomMetricsController.getStats()).isEmpty();
     }
 
@@ -177,23 +188,29 @@ public class TelecomMetricsControllerTest extends TelecomTestCase {
         AudioRouteStats audioStats1 = mTelecomMetricsController.getAudioRouteStats();
         CallStats callStats1 = mTelecomMetricsController.getCallStats();
         ErrorStats errorStats1 = mTelecomMetricsController.getErrorStats();
+        CallSequencingStats callSequencingStats1 =
+                mTelecomMetricsController.getCallSequencingStats();
         mTelecomMetricsController.setTestMode(true);
 
         verify(statsManager, times(1)).clearPullAtomCallback(eq(CALL_AUDIO_ROUTE_STATS));
         verify(statsManager, times(1)).clearPullAtomCallback(eq(CALL_STATS));
         verify(statsManager, times(1)).clearPullAtomCallback(eq(TELECOM_API_STATS));
         verify(statsManager, times(1)).clearPullAtomCallback(eq(TELECOM_ERROR_STATS));
+        verify(statsManager, times(1)).clearPullAtomCallback(eq(CALL_SEQUENCING_STATS));
         assertThat(mTelecomMetricsController.getStats()).isEmpty();
 
         ApiStats apiStats2 = mTelecomMetricsController.getApiStats();
         AudioRouteStats audioStats2 = mTelecomMetricsController.getAudioRouteStats();
         CallStats callStats2 = mTelecomMetricsController.getCallStats();
         ErrorStats errorStats2 = mTelecomMetricsController.getErrorStats();
+        CallSequencingStats callSequencingStats2 =
+                mTelecomMetricsController.getCallSequencingStats();
 
         assertThat(apiStats1).isNotSameInstanceAs(apiStats2);
         assertThat(audioStats1).isNotSameInstanceAs(audioStats2);
         assertThat(callStats1).isNotSameInstanceAs(callStats2);
         assertThat(errorStats1).isNotSameInstanceAs(errorStats2);
+        assertThat(callSequencingStats1).isNotSameInstanceAs(callSequencingStats2);
 
         mTelecomMetricsController.setTestMode(false);
 
@@ -207,5 +224,6 @@ public class TelecomMetricsControllerTest extends TelecomTestCase {
         mTelecomMetricsController.getStats().put(TELECOM_API_STATS, mApiStats);
         mTelecomMetricsController.getStats().put(TELECOM_ERROR_STATS, mErrorStats);
         mTelecomMetricsController.getStats().put(TELECOM_EVENT_STATS, mEventStats);
+        mTelecomMetricsController.getStats().put(CALL_SEQUENCING_STATS, mCallSequencingStats);
     }
 }
diff --git a/tests/src/com/android/server/telecom/tests/TelecomPulledAtomTest.java b/tests/src/com/android/server/telecom/tests/TelecomPulledAtomTest.java
index 0859ec4fe..083fe2b9d 100644
--- a/tests/src/com/android/server/telecom/tests/TelecomPulledAtomTest.java
+++ b/tests/src/com/android/server/telecom/tests/TelecomPulledAtomTest.java
@@ -54,6 +54,7 @@ import com.android.server.telecom.Call;
 import com.android.server.telecom.PendingAudioRoute;
 import com.android.server.telecom.metrics.ApiStats;
 import com.android.server.telecom.metrics.AudioRouteStats;
+import com.android.server.telecom.metrics.CallSequencingStats;
 import com.android.server.telecom.metrics.CallStats;
 import com.android.server.telecom.metrics.ErrorStats;
 import com.android.server.telecom.metrics.EventStats;
@@ -61,6 +62,7 @@ import com.android.server.telecom.nano.PulledAtomsClass;
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -170,6 +172,12 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
 
         assertNotNull(errorStats.mPulledAtoms);
         assertEquals(errorStats.mPulledAtoms.telecomErrorStats.length, 0);
+
+        CallSequencingStats callSequencingStats =
+                new CallSequencingStats(mSpyContext, mLooper, false);
+
+        assertNotNull(callSequencingStats.mPulledAtoms);
+        assertEquals(callSequencingStats.mPulledAtoms.callSequencingStats.length, 0);
     }
 
     @Test
@@ -198,6 +206,13 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
         EventStats eventStats = new EventStats(mSpyContext, mLooper, false);
 
         verifyTestDataForEventStats(eventStats.mPulledAtoms, DEFAULT_TIMESTAMPS_MILLIS);
+
+        createTestFileForCallSequencingStats(DEFAULT_TIMESTAMPS_MILLIS);
+        CallSequencingStats callSequencingStats =
+                new CallSequencingStats(mSpyContext, mLooper, false);
+
+        verifyTestDataForCallSequencingStats(callSequencingStats.mPulledAtoms,
+                DEFAULT_TIMESTAMPS_MILLIS);
     }
 
     @Test
@@ -312,6 +327,39 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
         assertEquals(errorStats.mPulledAtoms.telecomErrorStats.length, 0);
     }
 
+    @Test
+    public void testPullCallSequencingStatsLessThanMinPullIntervalShouldSkip() throws Exception {
+        createTestFileForCallSequencingStats(
+                System.currentTimeMillis() - MIN_PULL_INTERVAL_MILLIS / 2);
+        CallSequencingStats callSequencingStats =
+                spy(new CallSequencingStats(mSpyContext, mLooper, false));
+        final List<StatsEvent> data = new ArrayList<>();
+
+        int result = callSequencingStats.pull(data);
+
+        assertEquals(StatsManager.PULL_SKIP, result);
+        verify(callSequencingStats, never()).onPull(any());
+        assertEquals(data.size(), 0);
+    }
+
+    @Test
+    public void testPullCallSequencingStatsGreaterThanMinPullIntervalShouldNotSkip()
+            throws Exception {
+        createTestFileForCallSequencingStats(
+                System.currentTimeMillis() - MIN_PULL_INTERVAL_MILLIS - 1);
+        CallSequencingStats callSequencingStats =
+                spy(new CallSequencingStats(mSpyContext, mLooper, false));
+        final List<StatsEvent> data = new ArrayList<>();
+        int sizePulled = callSequencingStats.mPulledAtoms.callSequencingStats.length;
+
+        int result = callSequencingStats.pull(data);
+
+        assertEquals(StatsManager.PULL_SUCCESS, result);
+        verify(callSequencingStats).onPull(eq(data));
+        assertEquals(data.size(), sizePulled);
+        assertEquals(callSequencingStats.mPulledAtoms.callSequencingStats.length, 0);
+    }
+
     @Test
     public void testApiStatsLogCount() throws Exception {
         ApiStats apiStats = spy(new ApiStats(mSpyContext, mLooper, false));
@@ -709,10 +757,6 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
 
         callStats.onCallEnd(call);
         waitForHandlerAction(callStats, TEST_TIMEOUT);
-
-        verify(callStats, times(1)).log(eq(CALL_STATS__CALL_DIRECTION__DIR_INCOMING),
-                eq(false), eq(false), eq(false), eq(CALL_STATS__ACCOUNT_TYPE__ACCOUNT_SIM),
-                eq(fakeUid), eq(0), eq(0), eq(false), eq(duration));
     }
 
     @Test
@@ -753,10 +797,6 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
 
         callStats.onCallEnd(call);
         waitForHandlerAction(callStats, TEST_TIMEOUT);
-
-        verify(callStats, times(1)).log(eq(CALL_STATS__CALL_DIRECTION__DIR_INCOMING),
-                eq(false), eq(false), eq(true), eq(CALL_STATS__ACCOUNT_TYPE__ACCOUNT_SIM),
-                eq(fakeUid), eq(0), eq(0), eq(false), eq(duration));
     }
 
     @Test
@@ -840,6 +880,44 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
         }
     }
 
+    @Test
+    public void testCallSequencingStatsLog() throws Exception {
+        CallSequencingStats callSequencingStats =
+                spy(new CallSequencingStats(mSpyContext, mLooper, false));
+        Call call1 = mock(Call.class);
+        doReturn(0).when(callSequencingStats).getCallType(any(Call.class));
+        doReturn((long) VALUE_CALL_DURATION).when(call1).getAgeMillis();
+        callSequencingStats.setCallSequencingMetrics(call1, null /* primaryCall */);
+        callSequencingStats.onCallEnd(call1);
+        waitForHandlerAction(callSequencingStats, TEST_TIMEOUT);
+
+        verify(callSequencingStats, times(1))
+                .log(any(CallSequencingStats.CallSequencingStatsKey.class), anyInt());
+        verify(callSequencingStats, times(1)).onAggregate();
+        verify(callSequencingStats, times(1)).save(eq(DELAY_FOR_PERSISTENT_MILLIS));
+        assertEquals(callSequencingStats.mPulledAtoms.callSequencingStats.length, 1);
+        verifyMessageForCallSequencingStats(callSequencingStats.mPulledAtoms.callSequencingStats[0],
+                0, 0, false, false, false, false,
+                VALUE_CALL_DURATION, VALUE_EVENT_COUNT);
+
+        Call call2 = mock(Call.class);
+        doReturn(false).when(call2).isSelfManaged();
+        doReturn(false).when(call2).isTransactionalCall();
+        doReturn((long) VALUE_CALL_DURATION).when(call2).getAgeMillis();
+        callSequencingStats.setCallSequencingMetrics(call2, null /* primaryCall */);
+        callSequencingStats.onCallEnd(call2);
+        waitForHandlerAction(callSequencingStats, TEST_TIMEOUT);
+
+        verify(callSequencingStats, times(2))
+                .log(any(CallSequencingStats.CallSequencingStatsKey.class), anyInt());
+        verify(callSequencingStats, times(2)).onAggregate();
+        verify(callSequencingStats, times(2)).save(eq(DELAY_FOR_PERSISTENT_MILLIS));
+        assertEquals(callSequencingStats.mPulledAtoms.callSequencingStats.length, 1);
+        verifyMessageForCallSequencingStats(callSequencingStats.mPulledAtoms.callSequencingStats[0],
+                0, 0, false, false, false, false,
+                VALUE_CALL_DURATION, 2);
+    }
+
     @Test
     public void testApiStatsWithTestModeOn() throws Exception {
         final List<StatsEvent> data = new ArrayList<>();
@@ -888,6 +966,19 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
         verify(mSpyContext, never()).openFileOutput(anyString(), anyInt());
     }
 
+    @Test
+    public void testCallSequencingStatsWithTestModeOn() throws Exception {
+        final List<StatsEvent> data = new ArrayList<>();
+        CallSequencingStats callSequencingStats =
+                spy(new CallSequencingStats(mSpyContext, mLooper, true));
+        callSequencingStats.pull(data);
+        callSequencingStats.flush();
+
+        verify(mSpyContext, never()).getFileStreamPath(anyString());
+        verify(callSequencingStats, times(1)).onPull(any());
+        verify(mSpyContext, never()).openFileOutput(anyString(), anyInt());
+    }
+
     @Test
     public void testPullEventStatsLessThanMinPullIntervalShouldSkip() throws Exception {
         createTestFileForEventStats(System.currentTimeMillis() - MIN_PULL_INTERVAL_MILLIS / 2);
@@ -1213,4 +1304,54 @@ public class TelecomPulledAtomTest extends TelecomTestCase {
         }
         return false;
     }
+
+    private void createTestFileForCallSequencingStats(long timestamps) throws IOException {
+        PulledAtomsClass.PulledAtoms atom = new PulledAtomsClass.PulledAtoms();
+        atom.callSequencingStats =
+                new PulledAtomsClass.CallSequencingStats[VALUE_ATOM_COUNT];
+        for (int i = 0; i < VALUE_ATOM_COUNT; i++) {
+            atom.callSequencingStats[i] = new PulledAtomsClass.CallSequencingStats();
+            atom.callSequencingStats[i].setPrimaryCallType(0);
+            atom.callSequencingStats[i].setSecondaryCallType(0);
+            atom.callSequencingStats[i].setIsPrimaryCallEmergency(false);
+            atom.callSequencingStats[i].setIsSecondaryCallEmergency(false);
+            atom.callSequencingStats[i].setHasSecondary(false);
+            atom.callSequencingStats[i].setIsSamePhoneAccount(false);
+            atom.callSequencingStats[i].setCount(VALUE_EVENT_COUNT);
+            atom.callSequencingStats[i].setAverageDurationMs(VALUE_CALL_DURATION);
+        }
+        atom.setCallSequencingStatsPullTimestampMillis(timestamps);
+        FileOutputStream stream = new FileOutputStream(mTempFile);
+        stream.write(PulledAtomsClass.PulledAtoms.toByteArray(atom));
+        stream.close();
+    }
+
+    private void verifyTestDataForCallSequencingStats(
+            final PulledAtomsClass.PulledAtoms atom, long timestamps) {
+        assertNotNull(atom);
+        assertEquals(atom.getCallSequencingStatsPullTimestampMillis(), timestamps);
+        assertNotNull(atom.callSequencingStats);
+        assertEquals(atom.callSequencingStats.length, VALUE_ATOM_COUNT);
+        for (int i = 0; i < VALUE_ATOM_COUNT; i++) {
+            assertNotNull(atom.callSequencingStats[i]);
+            PulledAtomsClass.CallSequencingStats callSequencingStats = atom.callSequencingStats[i];
+            verifyMessageForCallSequencingStats(atom.callSequencingStats[i], 0,
+                    0, false, false, false, false, VALUE_CALL_DURATION,
+                    VALUE_EVENT_COUNT);
+        }
+    }
+
+    private void verifyMessageForCallSequencingStats(final PulledAtomsClass.CallSequencingStats msg,
+            int primaryCallState, int secondaryCallState, boolean isPrimaryCallEmergency,
+            boolean isSecondaryCallEmergency, boolean hasSecondary, boolean isSamePhoneAccount,
+            int duration, int count) {
+        assertEquals(msg.getPrimaryCallType(), primaryCallState);
+        assertEquals(msg.getSecondaryCallType(), secondaryCallState);
+        assertEquals(msg.getIsPrimaryCallEmergency(), isPrimaryCallEmergency);
+        assertEquals(msg.getIsSecondaryCallEmergency(), isSecondaryCallEmergency);
+        assertEquals(msg.getHasSecondary(), hasSecondary);
+        assertEquals(msg.getIsSamePhoneAccount(), isSamePhoneAccount);
+        assertEquals(msg.getAverageDurationMs(), duration);
+        assertEquals(msg.getCount(), count);
+    }
 }
diff --git a/tests/src/com/android/server/telecom/tests/TelecomServiceImplTest.java b/tests/src/com/android/server/telecom/tests/TelecomServiceImplTest.java
index 30a5a192a..94394e7a8 100644
--- a/tests/src/com/android/server/telecom/tests/TelecomServiceImplTest.java
+++ b/tests/src/com/android/server/telecom/tests/TelecomServiceImplTest.java
@@ -72,6 +72,7 @@ import android.os.OutcomeReceiver;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.permission.PermissionManager;
 import android.telecom.CallAttributes;
 import android.telecom.PhoneAccount;
 import android.telecom.PhoneAccountHandle;
@@ -210,6 +211,7 @@ public class TelecomServiceImplTest extends TelecomTestCase {
     @Mock private TelecomMetricsController mMockTelecomMetricsController;
     @Mock private OutgoingCallTransaction mOutgoingCallTransaction;
     @Mock private IncomingCallTransaction mIncomingCallTransaction;
+    @Mock private PermissionManager mPermissionManager;
 
     private final TelecomSystem.SyncRoot mLock = new TelecomSystem.SyncRoot() { };
 
diff --git a/tests/src/com/android/server/telecom/tests/TelecomSystemTest.java b/tests/src/com/android/server/telecom/tests/TelecomSystemTest.java
index 4aceae43b..a7790b678 100644
--- a/tests/src/com/android/server/telecom/tests/TelecomSystemTest.java
+++ b/tests/src/com/android/server/telecom/tests/TelecomSystemTest.java
@@ -17,6 +17,8 @@
 package com.android.server.telecom.tests;
 
 
+import static android.Manifest.permission.PROCESS_OUTGOING_CALLS;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
@@ -27,6 +29,7 @@ import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doReturn;
@@ -34,7 +37,6 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -116,6 +118,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Optional;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -224,6 +227,7 @@ public class TelecomSystemTest extends TelecomTestCase{
     FeatureFlags mFeatureFlags;
     @Mock
     com.android.internal.telephony.flags.FeatureFlags mTelephonyFlags;
+    @Mock Ringer.VibratorAdapter mVibratorAdapter;
 
     private static final String SYSTEM_UI_PACKAGE = "com.android.systemui";
     final ComponentName mInCallServiceComponentNameX =
@@ -513,7 +517,7 @@ public class TelecomSystemTest extends TelecomTestCase{
                 };
 
         mTimeoutsAdapter = mock(Timeouts.Adapter.class);
-        when(mTimeoutsAdapter.getCallScreeningTimeoutMillis(any(ContentResolver.class)))
+        when(mTimeoutsAdapter.getCallScreeningTimeoutMillis(any(Context.class), any(FeatureFlags.class)))
                 .thenReturn(TEST_TIMEOUT / 5L);
         mIncomingCallNotifier = mock(IncomingCallNotifier.class);
         mClockProxy = mock(ClockProxy.class);
@@ -523,8 +527,6 @@ public class TelecomSystemTest extends TelecomTestCase{
         when(mRoleManagerAdapter.getDefaultCallScreeningApp(any(UserHandle.class)))
                 .thenReturn(null);
         when(mRoleManagerAdapter.getBTInCallService()).thenReturn(new String[] {"bt_pkg"});
-        when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
-        when(mFeatureFlags.useRefactoredAudioRouteSwitching()).thenReturn(false);
         mTelecomSystem = new TelecomSystem(
                 mComponentContextFixture.getTestDouble(),
                 (context, phoneAccountRegistrar, defaultDialerCache, mDeviceIdleControllerAdapter,
@@ -594,7 +596,8 @@ public class TelecomSystemTest extends TelecomTestCase{
                 mBlockedNumbersAdapter,
                 mFeatureFlags,
                 mTelephonyFlags,
-                mHandlerThread.getLooper());
+                mHandlerThread.getLooper(),
+                mVibratorAdapter);
 
         mComponentContextFixture.setTelecomManager(new TelecomManager(
                 mComponentContextFixture.getTestDouble(),
@@ -850,33 +853,23 @@ public class TelecomSystemTest extends TelecomTestCase{
     }
 
     protected void verifyAndProcessOutgoingCallBroadcast(PhoneAccountHandle phoneAccountHandle) {
-        ArgumentCaptor<Intent> newOutgoingCallIntent =
-                ArgumentCaptor.forClass(Intent.class);
-        ArgumentCaptor<BroadcastReceiver> newOutgoingCallReceiver =
-                ArgumentCaptor.forClass(BroadcastReceiver.class);
-
         if (phoneAccountHandle != mPhoneAccountSelfManaged.getAccountHandle()) {
-            verify(mComponentContextFixture.getTestDouble().getApplicationContext(),
-                    times(mNumOutgoingCallsMade))
-                    .sendOrderedBroadcastAsUser(
-                            newOutgoingCallIntent.capture(),
-                            any(UserHandle.class),
-                            anyString(),
-                            anyInt(),
-                            any(Bundle.class),
-                            newOutgoingCallReceiver.capture(),
-                            nullable(Handler.class),
-                            anyInt(),
-                            anyString(),
-                            nullable(Bundle.class));
-            // Pass on the new outgoing call Intent
-            // Set a dummy PendingResult so the BroadcastReceiver agrees to accept onReceive()
-            newOutgoingCallReceiver.getValue().setPendingResult(
-                    new BroadcastReceiver.PendingResult(0, "", null, 0, true, false, null, 0, 0));
-            newOutgoingCallReceiver.getValue().setResultData(
-                    newOutgoingCallIntent.getValue().getStringExtra(Intent.EXTRA_PHONE_NUMBER));
-            newOutgoingCallReceiver.getValue().onReceive(mComponentContextFixture.getTestDouble(),
-                    newOutgoingCallIntent.getValue());
+            // Okay, this is gross.  Based on the telecomResolveHiddenDependencies flag, we may have
+            // called either of these prototypes..
+            if (mFeatureFlags.telecomResolveHiddenDependencies()) {
+                verify(mComponentContextFixture.getTestDouble().getApplicationContext(), atLeast(0))
+                        .sendBroadcastAsUser(
+                                any(Intent.class),
+                                any(UserHandle.class),
+                                eq(PROCESS_OUTGOING_CALLS));
+            } else {
+                verify(mComponentContextFixture.getTestDouble().getApplicationContext(), atLeast(0))
+                        .sendBroadcastAsUser(
+                                any(Intent.class),
+                                any(UserHandle.class),
+                                eq(PROCESS_OUTGOING_CALLS),
+                                anyInt());
+            }
         }
 
     }
diff --git a/tests/src/com/android/server/telecom/tests/TelecomTestCase.java b/tests/src/com/android/server/telecom/tests/TelecomTestCase.java
index 6956621f6..8b1c6813f 100644
--- a/tests/src/com/android/server/telecom/tests/TelecomTestCase.java
+++ b/tests/src/com/android/server/telecom/tests/TelecomTestCase.java
@@ -16,6 +16,8 @@
 
 package com.android.server.telecom.tests;
 
+import static org.mockito.Mockito.when;
+
 import android.content.Context;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -25,6 +27,7 @@ import android.telecom.Log;
 import androidx.test.InstrumentationRegistry;
 
 import com.android.server.telecom.flags.FeatureFlags;
+import com.android.server.telecom.flags.FeatureFlagsImpl;
 
 import org.mockito.Mock;
 import org.mockito.Mockito;
@@ -52,7 +55,7 @@ public abstract class TelecomTestCase {
         mMockitoHelper.setUp(InstrumentationRegistry.getContext(), getClass());
         MockitoAnnotations.initMocks(this);
 
-        Mockito.when(mFeatureFlags.callAudioCommunicationDeviceRefactor()).thenReturn(true);
+        when(mFeatureFlags.voipDndFocus()).thenReturn(new FeatureFlagsImpl().voipDndFocus());
         mComponentContextFixture = new ComponentContextFixture(mFeatureFlags);
         mContext = mComponentContextFixture.getTestDouble().getApplicationContext();
         Log.setSessionManager(mComponentContextFixture.getTestDouble().getApplicationContext(),
diff --git a/tests/src/com/android/server/telecom/tests/TransactionTests.java b/tests/src/com/android/server/telecom/tests/TransactionTests.java
index 6c049f65a..512951f5e 100644
--- a/tests/src/com/android/server/telecom/tests/TransactionTests.java
+++ b/tests/src/com/android/server/telecom/tests/TransactionTests.java
@@ -21,7 +21,10 @@ import static com.android.server.telecom.callsequencing.voip.VideoStateTranslati
 import static com.android.server.telecom.callsequencing.voip.VideoStateTranslation
         .VideoProfileStateToTransactionalVideoState;
 
+import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
@@ -47,6 +50,7 @@ import android.os.Bundle;
 import android.os.OutcomeReceiver;
 import android.os.UserHandle;
 import android.telecom.CallAttributes;
+import android.telecom.CallException;
 import android.telecom.DisconnectCause;
 import android.telecom.PhoneAccountHandle;
 import android.telecom.TelecomManager;
@@ -382,7 +386,7 @@ public class TransactionTests extends TelecomTestCase {
     public void testCallStateChangeTimesOut() {
         when(mFeatureFlags.transactionalCsVerifier()).thenReturn(true);
         VerifyCallStateChangeTransaction t = new VerifyCallStateChangeTransaction(
-                mLock, mMockCall1, CallState.ON_HOLD);
+                mLock, mMockCall1, mFeatureFlags, CallState.ON_HOLD);
         TransactionManager.TransactionCompleteListener listener =
                 mock(TransactionManager.TransactionCompleteListener.class);
         t.setCompleteListener(listener);
@@ -409,7 +413,7 @@ public class TransactionTests extends TelecomTestCase {
             throws ExecutionException, InterruptedException, TimeoutException {
         when(mFeatureFlags.transactionalCsVerifier()).thenReturn(true);
         VerifyCallStateChangeTransaction t = new VerifyCallStateChangeTransaction(
-                mLock, mMockCall1, CallState.ON_HOLD);
+                mLock, mMockCall1, mFeatureFlags, CallState.ON_HOLD);
         // WHEN
         setupHoldableCall();
 
@@ -427,6 +431,49 @@ public class TransactionTests extends TelecomTestCase {
         verify(mMockCall1, atLeastOnce()).removeCallStateListener(any());
     }
 
+    /**
+     * Assert that if a Call is disconnected while waiting for another target call state,
+     * the VerifyCallStateChangeTransaction is failed and cleaned up.
+     */
+    @SmallTest
+    @Test
+    public void testTransactionFailsWhenCallDisconnectsBeforeTargetStateReached()
+            throws ExecutionException, InterruptedException, TimeoutException {
+        when(mFeatureFlags.cleanupVerifyCallState()).thenReturn(true);
+        final int targetState = CallState.ON_HOLD;
+        final int initialState = CallState.ACTIVE;
+
+        // Set the initial state of the mock call (before transaction processing)
+        // This ensures the transaction doesn't complete immediately in processTransaction
+        when(mMockCall1.getState()).thenReturn(initialState);
+
+        // Create the transaction under test
+        VerifyCallStateChangeTransaction transaction = new VerifyCallStateChangeTransaction(
+                mLock, mMockCall1, mFeatureFlags, targetState);
+
+        // ACT
+        // Start the transaction (adds listeners)
+        transaction.processTransaction(null);
+
+        // Simulate the call state changing directly to DISCONNECTING *instead* of the target
+        // state. We directly invoke the listener to unit test its reaction.
+        transaction.getCallStateListenerImpl().onCallStateChanged(CallState.DISCONNECTING);
+
+        // ASSERT
+        // Get the result (should complete quickly as the listener was invoked directly)
+        // Use timeout as a safeguard.
+        CallTransactionResult result = transaction.getTransactionResult().get(1,
+                TimeUnit.SECONDS); // Reduced timeout slightly
+
+        // Verify the transaction completed with the specific error code and message
+        assertThat("Transaction result code should be UNKNOWN error due to disconnect",
+                result.getResult(),
+                is(CallException.CODE_ERROR_UNKNOWN));
+        assertThat("Transaction message should contain the specific disconnect reason",
+                result.getMessage(),
+                containsString(VerifyCallStateChangeTransaction.DISC_FINISH_TRANSACTION_MSG));
+    }
+
     private Call createSpyCall(PhoneAccountHandle targetPhoneAccount, int initialState, String id) {
         when(mCallsManager.getCallerInfoLookupHelper()).thenReturn(mCallerInfoLookupHelper);
 
diff --git a/tests/src/com/android/server/telecom/tests/VideoCallTests.java b/tests/src/com/android/server/telecom/tests/VideoCallTests.java
index 0ce70af5e..e92932894 100644
--- a/tests/src/com/android/server/telecom/tests/VideoCallTests.java
+++ b/tests/src/com/android/server/telecom/tests/VideoCallTests.java
@@ -16,11 +16,14 @@
 
 package com.android.server.telecom.tests;
 
-import static org.junit.Assert.assertEquals;
+import static com.android.server.telecom.CallAudioRouteAdapter.SPEAKER_ON;
+
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.verify;
 
 import android.os.Process;
@@ -32,8 +35,10 @@ import android.telecom.VideoProfile;
 import androidx.test.filters.LargeTest;
 import androidx.test.filters.MediumTest;
 
+import com.android.server.telecom.AudioRoute;
 import com.android.server.telecom.CallAudioModeStateMachine;
 import com.android.server.telecom.CallAudioRouteAdapter;
+import com.android.server.telecom.CallAudioRouteController;
 import com.android.server.telecom.CallAudioRouteStateMachine;
 
 import org.junit.After;
@@ -136,6 +141,10 @@ public class VideoCallTests extends TelecomSystemTest {
     @MediumTest
     @Test
     public void testNoAutoSpeakerphoneOnOutgoing() throws Exception {
+        // Skip test if the device doesn't support earpiece (auto)
+        CallAudioRouteController cara = (CallAudioRouteController) mTelecomSystem.getCallsManager()
+                .getCallAudioManager().getCallAudioRouteAdapter();
+        assumeTrue(cara.getAudioRouteForTesting(AudioRoute.TYPE_EARPIECE) != null);
         // Start an incoming video call.
         IdPair ids = startAndMakeActiveOutgoingCall("650-555-1212",
                 mPhoneAccountA0.getAccountHandle(), mConnectionServiceFixtureA,
@@ -150,6 +159,10 @@ public class VideoCallTests extends TelecomSystemTest {
     @MediumTest
     @Test
     public void testNoAutoSpeakerphoneOnIncoming() throws Exception {
+        // Skip test if the device doesn't support earpiece (auto)
+        CallAudioRouteController cara = (CallAudioRouteController) mTelecomSystem.getCallsManager()
+                .getCallAudioManager().getCallAudioRouteAdapter();
+        assumeTrue(cara.getAudioRouteForTesting(AudioRoute.TYPE_EARPIECE) != null);
 
         // Start an incoming video call.
         IdPair ids = startAndMakeActiveIncomingCall("650-555-1212",
@@ -266,17 +279,24 @@ public class VideoCallTests extends TelecomSystemTest {
                 .getCallAudioManager().getCallAudioModeStateMachine();
         waitForHandlerAction(camsm.getHandler(), TEST_TIMEOUT);
         final boolean[] success = {true};
+        CallAudioRouteController audioRouteController = (CallAudioRouteController) cara;
+        if (audioRouteController.isActive()) {
+            // If the routing is already active, we need to explicitly send SPEAKER_ON as it will be
+            // a pending message in the routing.
+            cara.sendMessageWithSessionInfo(SPEAKER_ON);
+            waitForHandlerActionDelayed(cara.getAdapterHandler(), TEST_TIMEOUT, TEST_TIMEOUT);
+        }
         cara.sendMessage(CallAudioRouteStateMachine.RUN_RUNNABLE, (Runnable) () -> {
             ArgumentCaptor<CallAudioState> callAudioStateArgumentCaptor = ArgumentCaptor.forClass(
                     CallAudioState.class);
             try {
-                verify(mInCallServiceFixtureX.getTestDouble(), atLeastOnce())
+                verify(mInCallServiceFixtureX.getTestDouble(), timeout(TEST_TIMEOUT).atLeastOnce())
                         .onCallAudioStateChanged(callAudioStateArgumentCaptor.capture());
             } catch (RemoteException e) {
                 fail("Remote exception in InCallServiceFixture");
             }
             List<CallAudioState> changes = callAudioStateArgumentCaptor.getAllValues();
-            assertEquals(expectedRoute, changes.get(changes.size() - 1).getRoute());
+            assertTrue(changes.stream().anyMatch(change -> change.getRoute() == expectedRoute));
             success[0] = true;
         });
         waitForHandlerAction(cara.getAdapterHandler(), TEST_TIMEOUT);
diff --git a/tests/src/com/android/server/telecom/tests/VideoProviderProxyTest.java b/tests/src/com/android/server/telecom/tests/VideoProviderProxyTest.java
index 060e3ae0e..0be769fe5 100644
--- a/tests/src/com/android/server/telecom/tests/VideoProviderProxyTest.java
+++ b/tests/src/com/android/server/telecom/tests/VideoProviderProxyTest.java
@@ -25,6 +25,8 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.os.IBinder;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.telecom.VideoProfile;
 
 import androidx.test.filters.SmallTest;
@@ -35,14 +37,18 @@ import com.android.server.telecom.Call;
 import com.android.server.telecom.CurrentUserProxy;
 import com.android.server.telecom.TelecomSystem;
 import com.android.server.telecom.VideoProviderProxy;
+import com.android.server.telecom.flags.FeatureFlagsImpl;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
+@RunWith(JUnit4.class)
 public class VideoProviderProxyTest extends TelecomTestCase {
 
     private TelecomSystem.SyncRoot mLock;
@@ -60,14 +66,13 @@ public class VideoProviderProxyTest extends TelecomTestCase {
         super.setUp();
         MockitoAnnotations.initMocks(this);
         mLock = new TelecomSystem.SyncRoot() { };
-
         when(mVideoProvider.asBinder()).thenReturn(mIBinder);
         doNothing().when(mIBinder).linkToDeath(any(), anyInt());
         when(mCall.getAnalytics()).thenReturn(mCallInfo);
         doNothing().when(mCallInfo).addVideoEvent(anyInt(), anyInt());
         doNothing().when(mCall).maybeEnableSpeakerForVideoUpgrade(anyInt());
         mVideoProviderProxy = new VideoProviderProxy(mLock, mVideoProvider, mCall,
-                mCurrentUserProxy);
+                mCurrentUserProxy, new FeatureFlagsImpl());
         mVideoProviderProxy.addListener(mListener);
     }
 
```

