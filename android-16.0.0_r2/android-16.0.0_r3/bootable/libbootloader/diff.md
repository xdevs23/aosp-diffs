```diff
diff --git a/BUILD b/BUILD
deleted file mode 100644
index f9c9199..0000000
--- a/BUILD
+++ /dev/null
@@ -1,29 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_pkg//pkg:install.bzl", "pkg_install")
-load("@rules_pkg//pkg:mappings.bzl", "pkg_files", "strip_prefix")
-
-pkg_files(
-    name = "gbl_efi_dist_files",
-    srcs = ["@gbl//efi:all_platforms"],
-    strip_prefix = strip_prefix.files_only(),
-    visibility = ["//visibility:private"],
-)
-
-pkg_install(
-    name = "gbl_efi_dist",
-    srcs = [":gbl_efi_dist_files"],
-    destdir = "out/gbl_efi/",
-)
diff --git a/gbl/BUILD b/gbl/BUILD
deleted file mode 100644
index 283421a..0000000
--- a/gbl/BUILD
+++ /dev/null
@@ -1,44 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load(":readme.bzl", "readme_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-readme_test(
-    name = "readme_test",
-    readme = "docs/efi_protocols.md",
-    # Note: can't read files in subpackages, not sure how to add a dependency on all,
-    # globbed, subpackages and all the rust_lib targets they contain.
-    deps = [
-        "@gbl//efi:app",
-        "@gbl//efi:libgbl_efi",
-        "@gbl//libavb:sysdeps",
-        "@gbl//libboot",
-        "@gbl//libbootimg",
-        "@gbl//libbootparams",
-        "@gbl//libc",
-        "@gbl//libefi",
-        "@gbl//libefi_types",
-        "@gbl//liberror",
-        "@gbl//libfastboot",
-        "@gbl//libfdt",
-        "@gbl//libgbl",
-        "@gbl//libmisc",
-        "@gbl//libsafemath",
-        "@gbl//libstorage",
-    ],
-)
diff --git a/gbl/MODULE.bazel b/gbl/MODULE.bazel
deleted file mode 100644
index 00bb183..0000000
--- a/gbl/MODULE.bazel
+++ /dev/null
@@ -1,6 +0,0 @@
-###############################################################################
-# Bazel now uses Bzlmod by default to manage external dependencies.
-# Please consider migrating your external dependencies from WORKSPACE to MODULE.bazel.
-#
-# For more details, please check https://github.com/bazelbuild/bazel/issues/18958
-###############################################################################
diff --git a/gbl/OWNERS b/gbl/OWNERS
index f0899b9..6c15443 100644
--- a/gbl/OWNERS
+++ b/gbl/OWNERS
@@ -3,4 +3,5 @@ dovs@google.com
 dpursell@google.com
 rammuthiah@google.com
 sergiip@google.com
+yochiang@google.com
 zyecheng@google.com
diff --git a/gbl/README.md b/gbl/README.md
deleted file mode 100644
index eaf0f6e..0000000
--- a/gbl/README.md
+++ /dev/null
@@ -1,180 +0,0 @@
-# Generic Bootloader Library
-
-This directory hosts the Generic Bootloader Library project. A Bazel
-workspace is setup for building the library as well as an EFI executable that
-can be loaded directly from the firmware.
-
-## Get source tree and build
-
-To successfully get and build the tree your machine must have the following dependencies installed:
-
-```
-# repo to work with android repositories (https://source.android.com/docs/setup/reference/repo)
-# bazel-bootstrap to build (https://bazel.build/)
-sudo apt install repo bazel-bootstrap
-```
-
-The GBL project are intended to be built from the
-[Android UEFI Manifest](https://android.googlesource.com/kernel/manifest/+/refs/heads/uefi-gbl-mainline/default.xml)
-checkout:
-
-```
-repo init -u https://android.googlesource.com/kernel/manifest -b uefi-gbl-mainline
-repo sync -j16
-```
-
-To build the EFI application:
-
-```
-./tools/bazel run //bootable/libbootloader:gbl_efi_dist --extra_toolchains=@gbl//toolchain:all
-```
-
-The above builds the EFI application for all of `x86_64`, `x86_32`, `aarch64`
-and `riscv64` platforms.
-
-To run the set of unit tests:
-
-```
-./tools/bazel test @gbl//tests --extra_toolchains=@gbl//toolchain:all
-```
-
-## IDE Setup
-
-For rust development, we recommend use VSCode + rust-analyzer plugin.
-
-rust-analyzer requires `rust-project.json` to work properly. Luckily, bazel has
-support for generating `rust-project.json`:
-
-```
-./tools/bazel run @rules_rust//tools/rust_analyzer:gen_rust_project --norepository_disable_download -- --bazel ./tools/bazel @gbl//efi/...
-```
-
-`@gbl//efi/...` is the target to generate rust project for, here it means
-"everything under @gbl//efi/ directory" . Omitting the target specifier would
-result in analyzing "@/..." , which would most likely fail due to some obscure
-reason. Should targets get moved around in the future, this path spec also need
-to be updated.
-
-After generating `rust-project.json`, you would notice that your IDE still
-doesn't offer auto completion. This is because some source file paths pointing
-to bazel-output dir, and you are most likely editing source files in
-`bootable/libbootloader/gbl`. In addition, the generated rust-project.json sets
-"cfg=test" for all targets, which causes certain dependency graph to resolve
-incorrectly. To fix this, run
-
-```
-python3 bootable/libbootloader/gbl/rewrite_rust_project_path.py rust-project.json
-```
-
-And reload your IDE.
-
-## Run the EFI application
-
-### Boot Android on Cuttlefish
-
-If you have a main AOSP checkout and is setup to run
-[Cuttlefish](https://source.android.com/docs/setup/create/cuttlefish), you can
-run the EFI image directly with:
-
-```
-cvd start --android_efi_loader=<path to the EFI image> ...
-```
-
-The above uses the same setting as a normal `cvd start` run, except that
-instead of booting Android directly, the emulator first hands off to the EFI
-application, which will take over booting android.
-
-Note: For x86 platform, use the EFI image built for `x86_32`.
-
-### Boot Fuchsia on Vim3
-
-Booting Fuchsia on a Vim3 development board is supported. To run the
-application:
-
-1. Complete all
-[bootstrap steps](https://fuchsia.dev/fuchsia-src/development/hardware/khadas-vim3?hl=en)
-to setup Vim3 as a Fuchsia device.
-2. Reboot the device into fastboot mode.
-3. Run fastboot command:
-```
-fastboot stage <path to the EFI binary> && fastboot oem run-staged-efi
-```
-
-### Run on standalone QEMU
-
-If you want to test the EFI image directly on QEMU with your custom
-configurations:
-
-1. Install EDK, QEMU and u-boot prebuilts
-
-   ```
-   sudo apt-get install qemu-system ovmf u-boot-qemu
-   ```
-
-1. Depending on the target architecture you want to run:
-
-   For `x86_64`:
-   ```
-   mkdir -p /tmp/esp/EFI/BOOT && \
-   cp <path to EFI image> /tmp/esp/EFI/BOOT/bootx64.efi && \
-   qemu-system-x86_64 -nographic \
-       -drive if=pflash,format=raw,readonly=on,file=/usr/share/OVMF/OVMF_CODE.fd \
-       -drive format=raw,file=fat:rw:/tmp/esp
-   ```
-
-   For `aarch64`:
-   ```
-   mkdir -p /tmp/esp/EFI/BOOT && \
-   cp <path to EFI image> /tmp/esp/EFI/BOOT/bootaa64.efi && \
-   qemu-system-aarch64 -nographic -machine virt -m 1G -cpu cortex-a57 \
-       -drive if=pflash,format=raw,readonly=on,file=/usr/share/AAVMF/AAVMF_CODE.fd \
-       -drive format=raw,file=fat:rw:/tmp/esp
-   ```
-
-   For `riscv64`:
-   ```
-   mkdir -p /tmp/esp/EFI/BOOT && \
-   cp <path to EFI image> /tmp/esp/EFI/BOOT/bootriscv64.efi && \
-   qemu-system-riscv64 -nographic -machine virt -m 256M \
-       -bios /usr/lib/u-boot/qemu-riscv64/u-boot.bin \
-       -drive format=raw,file=fat:rw:/tmp/esp,id=blk0 \
-       -device virtio-blk-device,drive=blk0
-   ```
-
-### Boot Fuchsia on emulator
-
-1. Make sure Fuchsia target pass control to GBL.
-
-   Set path to GBL binary here: [fuchsia/src/firmware/gigaboot/cpp/backends.gni : gigaboot_gbl_efi_app](https://cs.opensource.google/fuchsia/fuchsia/+/main:src/firmware/gigaboot/cpp/backends.gni;l=25?q=gigaboot_gbl_efi_app)
-
-   Temporarily  need to enable GBL usage in gigaboot: [fuchsia/src/firmware/gigaboot/cpp/backends.gni : gigaboot_use_gbl](https://cs.opensource.google/fuchsia/fuchsia/+/main:src/firmware/gigaboot/cpp/backends.gni;l=25?q=gigaboot_gbl_efi_app#:~:text=to%20use%20GBL.-,gigaboot_use_gbl)
-
-   E.g. in `fuchsia/src/firmware/gigaboot/cpp/backends.gni`:
-   ```
-   $ cat ./fuchsia/src/firmware/gigaboot/cpp/backends.gni
-   ...
-   declare_args() {
-      ...
-      gigaboot_gbl_efi_app = "<path to EFI image>/gbl_x86_64.efi"
-      gigaboot_use_gbl = true
-   }
-   ```
-
-   Or in `fx set`:
-   ```
-   fx set core.x64 --args=gigaboot_gbl_efi_app='"<path to EFI image>/gbl_x86_64.efi"' --args=gigaboot_use_gbl=true
-   ```
-
-2. Build: (this has to be done every time if EFI app changes)
-
-   `fx build`
-
-3. Run emulator in UEFI mode with raw disk
-
-   ```
-   fx qemu -a x64 --uefi --disktype=nvme -D ./out/default/obj/build/images/disk.raw
-   ```
-
-## EFI Protocols
-
-List of EFI protocols used by GBL and a brief description of each [here](./docs/efi_protocols.md).
diff --git a/gbl/WORKSPACE.bazel b/gbl/WORKSPACE.bazel
deleted file mode 100644
index b151725..0000000
--- a/gbl/WORKSPACE.bazel
+++ /dev/null
@@ -1,15 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-workspace(name = "gbl")
diff --git a/gbl/bazel.MODULE.bazel b/gbl/bazel.MODULE.bazel
deleted file mode 100644
index c55a05b..0000000
--- a/gbl/bazel.MODULE.bazel
+++ /dev/null
@@ -1,100 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""Custom MODULE.bazel definition for GBL.
-
-This is a stripped down version of Kleaf's MODULE.bazel because this repository does not build
-kernel.
-"""
-
-module(
-    name = "uefi-gbl",
-    version = "0.0.0",
-)
-
-register_toolchains(
-    "//prebuilts/build-tools:py_exec_tools_toolchain",
-    "//prebuilts/build-tools:py_toolchain",
-)
-
-bazel_dep(
-    name = "bazel_skylib",
-)
-bazel_dep(
-    name = "platforms",
-)
-bazel_dep(
-    name = "rules_cc",
-)
-bazel_dep(
-    name = "rules_pkg",
-)
-bazel_dep(
-    name = "rules_python",
-)
-
-local_path_override(
-    module_name = "bazel_features",
-    path = "external/bazel-contrib-bazel_features",
-)
-
-local_path_override(
-    module_name = "bazel_skylib",
-    path = "external/bazel-skylib",
-)
-
-local_path_override(
-    module_name = "platforms",
-    path = "external/bazelbuild-platforms",
-)
-
-local_path_override(
-    module_name = "rules_cc",
-    path = "external/bazelbuild-rules_cc",
-)
-
-local_path_override(
-    module_name = "rules_java",
-    path = "bootable/libbootloader/gbl/fake_modules/rules_java",
-)
-
-local_path_override(
-    module_name = "rules_kotlin",
-    path = "bootable/libbootloader/gbl/fake_modules/rules_kotlin",
-)
-
-local_path_override(
-    module_name = "rules_license",
-    path = "external/bazelbuild-rules_license",
-)
-
-local_path_override(
-    module_name = "rules_pkg",
-    path = "external/bazelbuild-rules_pkg",
-)
-
-local_path_override(
-    module_name = "rules_python",
-    path = "external/bazelbuild-rules_python",
-)
-
-local_path_override(
-    module_name = "rules_shell",
-    path = "external/bazelbuild-rules_shell",
-)
-
-local_path_override(
-    module_name = "protobuf",
-    path = "bootable/libbootloader/gbl/fake_modules/protobuf",
-)
diff --git a/gbl/bazel.WORKSPACE b/gbl/bazel.WORKSPACE
deleted file mode 100644
index 1cc0747..0000000
--- a/gbl/bazel.WORKSPACE
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""Remaining repositories not yet migrated to bzlmod."""
-
-local_repository(
-    name = "gbl",
-    path = "bootable/libbootloader/gbl",
-)
-
-# buildifier: disable=load-on-top
-load("@gbl//integration/aosp_uefi-gbl-mainline:workspace.bzl", "define_gbl_workspace")
-
-define_gbl_workspace()
-
-load("@rules_rust//tools/rust_analyzer:deps.bzl", "rust_analyzer_dependencies")
-
-rust_analyzer_dependencies()
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "GBL_RUST_VERSION")
-load("@rules_rust//rust:repositories.bzl", "rust_analyzer_toolchain_repository")
-
-register_toolchains(rust_analyzer_toolchain_repository(
-    name = "rust_analyzer_toolchain",
-    version = GBL_RUST_VERSION,
-))
diff --git a/gbl/bazel.bazelrc b/gbl/bazel.bazelrc
deleted file mode 100644
index 2fb3f2f..0000000
--- a/gbl/bazel.bazelrc
+++ /dev/null
@@ -1,69 +0,0 @@
-# Lock down the PATH variable in actions to /usr/bin and /usr/local/bin.
-build --incompatible_strict_action_env
-
-# By default, output all the logs to stdout/stderr by disabling the console limit
-build --experimental_ui_max_stdouterr_bytes=-1
-
-# Make output directories writable so `rm -rf out/` works.
-build --experimental_writable_outputs
-
-# NOTE: To ensure a strict no external access policy, the following three flags
-#   need to be set/unset, see https://github.com/bazelbuild/bazel/discussions/18281
-#   for more details about this.
-# An empty string as argument requests the cache to be disabled.
-common --repository_cache=
-# Additional places to search for archives before accessing the network to download them.
-common --distdir=
-# If set, downloading using ctx.download{,_and_extract} is not allowed during repository fetching.
-common --repository_disable_download
-
-# bzlmod
-common --enable_bzlmod
-common --registry=file://%workspace%/external/bazelbuild-bazel-central-registry
-# Set --lockfile_mode=off to prevent generation of MODULE.bazel.lock
-# and caching of source declarations in the registry.
-# See https://github.com/bazelbuild/bazel/issues/20477
-# Note: If the registry files are modified, one needs to run `bazel shutdown`
-#   as well as setting this flag. Usually, files are only added to the registry.
-common --lockfile_mode=off
-
-# CC toolchain
-# Use --platforms to select toolchains, not the legacy --cpu --cross_top --compiler.
-# See https://bazel.build/concepts/platforms#cxx
-build --incompatible_enable_cc_toolchain_resolution
-
-# Do not use host toolchain
-build --action_env=BAZEL_DO_NOT_DETECT_CPP_TOOLCHAIN=1
-
-build --@rules_rust//rust/settings:experimental_toolchain_generated_sysroot=false
-common --extra_toolchains=@gbl//toolchain:all
-test  --test_output=errors
-
-# Set up remote caching
-# https://developers.google.com/remote-build-execution/docs/set-up/set-up-caching
-test:ants --remote_cache=grpcs://remotebuildexecution.googleapis.com
-test:ants --google_default_credentials=true
-test:ants --remote_instance_name=projects/android-build-farm/instances/default_instance
-test:ants --noremote_upload_local_results
-
-# Upload results to BES backend.
-# Refer to go/bazel-ants-docs
-test:ants --bes_backend=buildeventservice-pa.googleapis.com
-test:ants --bes_keywords=android-test-storage
-test:ants --bes_instance_name=android-build-farm
-test:ants --build_metadata=run_type=critical
-
-# Show URI to test results
-test:ants --build_metadata=generate_test_uri=fusion
-
-# These need to be set in the command line
-# test:ants --build_metadata="ab_build_id=${BUILD_ID}"
-# test:ants --build_metadata="ab_target=???",
-# test:ants --build_metadata="test_definition_name=kernel/kleaf/???"
-
-common:android_ci --noshow_progress
-test:android_ci --config=ants
-
-common --enable_workspace
-common --incompatible_autoload_externally=+@rules_python,-ProguardSpecProvider,-java_binary,-java_import,-java_library,-java_plugin,-java_test,-java_runtime,-java_toolchain,-java_package_configuration,-@com_google_protobuf,-@protobuf,+@rules_shell,-@rules_android
-common --noincompatible_disallow_empty_glob
diff --git a/gbl/bazel.py b/gbl/bazel.py
deleted file mode 100644
index ce63130..0000000
--- a/gbl/bazel.py
+++ /dev/null
@@ -1,202 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import argparse
-import os
-import pathlib
-import sys
-from datetime import date
-from typing import Tuple, Optional
-
-_BAZEL_REL_PATH = "prebuilts/kernel-build-tools/bazel/linux-x86_64/bazel"
-
-
-def _partition(lst: list[str], index: Optional[int]) \
-        -> Tuple[list[str], Optional[str], list[str]]:
-    """Returns the triple split by index.
-
-    That is, return a tuple:
-    (everything before index, the element at index, everything after index)
-
-    If index is None, return (the list, None, empty list)
-    """
-    if index is None:
-        return lst[:], None, []
-    return lst[:index], lst[index], lst[index + 1:]
-
-
-class BazelWrapper(object):
-    def __init__(self, workspace_dir: pathlib.Path, bazel_args: list[str]):
-        """Splits arguments to the bazel binary based on the functionality.
-
-        bazel [startup_options] command         [command_args] --               [target_patterns]
-                                 ^- command_idx                ^- dash_dash_idx
-
-        See https://bazel.build/reference/command-line-reference
-
-        Args:
-            workspace_dir: root of workspace.
-            bazel_args: The list of arguments the user provides through command line
-            env: existing environment
-        """
-
-        self.workspace_dir = workspace_dir
-
-        self.bazel_path = self.workspace_dir / _BAZEL_REL_PATH
-
-        command_idx = None
-        for idx, arg in enumerate(bazel_args):
-            if not arg.startswith("-"):
-                command_idx = idx
-                break
-
-        self.startup_options, self.command, remaining_args = _partition(bazel_args,
-                                                                        command_idx)
-
-        # Split command_args into `command_args -- target_patterns`
-        dash_dash_idx = None
-        try:
-            dash_dash_idx = remaining_args.index("--")
-        except ValueError:
-            # If -- is not found, put everything in command_args. These arguments
-            # are not provided to the Bazel executable target.
-            pass
-
-        self.command_args, self.dash_dash, self.target_patterns = _partition(remaining_args,
-                                                                             dash_dash_idx)
-
-        self._parse_startup_options()
-        self._parse_command_args()
-        self._add_extra_startup_options()
-        self._add_build_number_command_args()
-
-    def add_startup_option_to_parser(self, parser):
-        parser.add_argument(
-            "-h", "--help", action="store_true",
-            help="show this help message and exit"
-        )
-
-    def _parse_startup_options(self):
-        """Parses the given list of startup_options.
-
-        After calling this function, the following attributes are set:
-        - absolute_user_root: A path holding bazel build output location
-        - transformed_startup_options: The transformed list of startup_options to replace
-          existing startup_options to be fed to the Bazel binary
-        """
-
-        parser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)
-        self.add_startup_option_to_parser(parser)
-
-        self.known_startup_options, self.user_startup_options = \
-            parser.parse_known_args(self.startup_options)
-
-        self.absolute_out_dir = self.workspace_dir / "out"
-        self.absolute_user_root = \
-            self.absolute_out_dir / "bazel/output_user_root"
-
-        if self.known_startup_options.help:
-            self.transformed_startup_options = [
-                "--help"
-            ]
-
-        if not self.known_startup_options.help:
-            javatmp = self.absolute_out_dir / "bazel/javatmp"
-            self.transformed_startup_options = [
-                f"--host_jvm_args=-Djava.io.tmpdir={javatmp}",
-            ]
-
-        # See _add_extra_startup_options for extra startup options
-
-    def _parse_command_args(self):
-        """Parses the given list of command_args.
-
-        After calling this function, the following attributes are set:
-        - known_args: A namespace holding options known by this Bazel wrapper script
-        - transformed_command_args: The transformed list of command_args to replace
-          existing command_args to be fed to the Bazel binary
-        - env: A dictionary containing the new environment variables for the subprocess.
-        """
-
-        parser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)
-
-        # TODO: Delete these args once build bots no longer specify them
-        parser.add_argument(
-            "--make_jobs", metavar="JOBS", type=int, default=None,
-            help="unused")
-        parser.add_argument(
-            "--make_keep_going", action="store_true", default=False,
-            help="unused")
-        parser.add_argument(
-            "--repo_manifest", metavar="<repo_root>:<manifest.xml>",
-            help="unused")
-
-        # Skip startup options (before command) and target_patterns (after --)
-        _, self.transformed_command_args = parser.parse_known_args(
-            self.command_args)
-
-    def _add_build_number_command_args(self):
-        """Adds options for BUILD_NUMBER."""
-        build_number = os.environ.get("BUILD_NUMBER")
-        if build_number is None:
-            # Changing the commandline causes rebuild. In order to *not* cause
-            # superfluous rebuilds, append a low-precision timestamp.
-            build_number = f"eng.{os.environ.get('USER')}.{date.today()}"
-        self.transformed_command_args += ["--action_env", f"BUILD_NUMBER={build_number}"]
-
-    def _add_extra_startup_options(self):
-        """Adds extra startup options after command args are parsed."""
-
-        self.transformed_startup_options += self.user_startup_options
-
-        if not self.known_startup_options.help:
-            self.transformed_startup_options.append(
-                f"--output_user_root={self.absolute_user_root}")
-
-    def _build_final_args(self) -> list[str]:
-        """Builds the final arguments for the subprocess."""
-        # final_args:
-        # bazel [startup_options] [additional_startup_options] command [transformed_command_args] -- [target_patterns]
-
-        final_args = [self.bazel_path] + self.transformed_startup_options
-
-        if self.command is not None:
-            final_args.append(self.command)
-        final_args += self.transformed_command_args
-        if self.dash_dash is not None:
-            final_args.append(self.dash_dash)
-        final_args += self.target_patterns
-
-        return final_args
-
-    def run(self) -> int:
-        """Runs the wrapper.
-
-        Returns:
-            doesn't return"""
-        final_args = self._build_final_args()
-
-        os.execve(path=self.bazel_path, argv=final_args, env=os.environ)
-
-
-def _bazel_wrapper_main():
-    # <workspace_dir>/bootable/libbootloader/gbl/bazel.py
-    workspace_dir = (
-        pathlib.Path(__file__).resolve().parent.parent.parent.parent)
-    return BazelWrapper(workspace_dir=workspace_dir,
-                        bazel_args=sys.argv[1:]).run()
-
-
-if __name__ == "__main__":
-    sys.exit(_bazel_wrapper_main())
diff --git a/gbl/bazel.sh b/gbl/bazel.sh
deleted file mode 100755
index 59975bd..0000000
--- a/gbl/bazel.sh
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/bin/bash -e
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Use host readlink. b/348003050
-MYPATH=$(readlink -f "$0")
-MYDIR=${MYPATH%/*}
-WORKSPACE_DIR=${MYDIR%bootable/libbootloader/gbl}
-WORKSPACE_DIR=${WORKSPACE_DIR%/}
-
-exec "$WORKSPACE_DIR"/prebuilts/build-tools/path/linux-x86/python3 "$MYDIR"/bazel.py "$@"
diff --git a/gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md b/gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md
deleted file mode 100644
index dfa2efa..0000000
--- a/gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md
+++ /dev/null
@@ -1,283 +0,0 @@
-# GBL EFI Fastboot USB Protocol
-
-This document describes the GBL Fastboot USB protocol. The protocol defines
-interfaces that can be used by EFI applications to implement Fastboot over USB.
-
-|||
-| ----------- | ----------- |
-| **Status** | Work in progress |
-| **Created** | 2024-3-21 |
-
-
-## GBL_EFI_FASTBOOT_USB_PROTOCOL
-
-### Summary
-
-This protocol provides interfaces for platform-specific AVB operations, such as
-reading/writing antirollback indices, persistant values, and performing AVB
-public key validation etc. It also defines interfaces that abstract platform
-USB controller for interfacing with the Android Fastboot tooling. These include
-starting/stopping a Fastboot USB interface and sending/receiving USB packets.
-
-### GUID
-
-```c
-// {6281a893-ac23-4ca7-b281-340ef8168955}
-#define GBL_EFI_FASTBOOT_USB_PROTOCOL_GUID           \
-  {                                                  \
-    0x6281a893, 0xac23, 0x4ca7, {                    \
-      0xb2, 0x81, 0x34, 0x0e, 0xf8, 0x16, 0x89, 0x55 \
-    }                                                \
-  }
-```
-
-### Revision Number
-
-```c
-#define GBL_EFI_FASTBOOT_USB_PROTOCOL_REVISION 0x00000000
-```
-
-### Protocol Interface Structure
-
-```c
-typedef struct _GBL_EFI_FASTBOOT_USB_PROTOCOL {
-  UINT64                                              Revision;
-  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_START   FastbootUsbInterfaceStart;
-  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_STOP    FastbootUsbInterfaceStop;
-  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_RECEIVE           FastbootUsbReceive;
-  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_SEND              FastbootUsbSend;
-  EFI_EVENT                                           WaitForSendCompletion;
-} GBL_EFI_FASTBOOT_USB_PROTOCOL;
-```
-
-### Parameters
-
-**Revision**  
-The revision to which the GBL_EFI_FASTBOOT_USB_PROTOCOL adheres. All future
-revisions must be backwards compatible. If a future version is not backwards
-compatible, a different GUID must be used.
-
-**FastbootUsbInterfaceStart**  
-Starts a USB interface for Fastboot traffic. See
-[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStart()`](#gbl_efi_fastboot_usb_protocolfastbootusbinterfacestart).
-
-**FastbootUsbInterfaceStop**  
-Stops the USB interface started by `FastbootUsbInterfaceStart()`. See
-[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStop()`](#gbl_efi_fastboot_usb_protocolfastbootusbinterfacestop).
-
-**FastbootUsbReceive**  
-Polls and receives the next USB packet if available. See
-[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbReceive()`](#gbl_efi_fastboot_usb_protocolfastbootusbreceive).
-
-**FastbootUsbSend**  
-Sends a USB packet. See
-[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbSend()`](#gbl_efi_fastboot_usb_protocolfastbootusbsend).
-
-**WaitForSendCompletion**  
-Event used with `EFI_BOOT_SERVICES.WaitForEvent()` to wait for the previous
-packet sent by `FastbootUsbSend()` to complete.
-
-
-## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStart()
-
-### Summary
-
-Starts a USB interface for Fastboot.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_START)(
-  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This,
-  OUT UINTN                         *MaxPacketSize,
-  );
-```
-
-### Parameters
-
-*This*  
-A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
-instance.
-
-*MaxPacketSize*  
-On exit, set to the maximum packet size in bytes allowed by the USB interface.
-
-### Description
-
-`FastbootUsbInterfaceStart()` shoud start and expose a device mode USB inteface
-that can be used by `FastbootUsbReceive()` and `FastbootUsbSend()` to exchange
-USB packets. In order for the interface to be compatible with the Android
-Fastboot tool, the interface setup should meet the following requirement:
-
-* The USB interface should contain two bulk endpoints (in, out).
-* Max packet size must be 64 bytes for full-speed, 512 bytes for high-speed and
-1024 bytes for Super Speed USB.
-* The class, subclass and protocol code in the USB interface descriptor should be
-set to the values specified by the upstream Fastboot USB protocol:
-  * Interface class: 0xff (Vendor specific)
-  * Interface subclass: 0x42 (ADB)
-  * Interface protocol: 0x03 (Fastboot)
-* The USB device descriptor should provide a valid serial number string
-descriptor.
-
-**Note**: EFI_USBFN_IO_PROTOCOL is not used because: 1) it lacks support for
-specifying serial number and USB3.0 at the time this protocol is drafted. 2)
-Other than the requirement above, the rest of USB configuration required by
-EFI_USBFN_IO_PROTOCOL is not concerned by the Fastboot USB protocol. The
-abstracted interfaces allow EFI Fastboot applications to avoid having to know
-how to configure a full USB.
-
-**Note**: This protocol is not applicable to platforms that only operate in USB
-host mode. However, platforms that support xHCI debug capability (DbC) can
-present as a USB device and thus communicate with a host. Future revision of
-this protocol and Android Fastboot tool may support this usecase.
-
-### Status Codes Returned
-
-|||
-| ----------- | ----------- |
-| EFI_SUCCESS | USB interface is started successfully. |
-| EFI_INVALID_PARAMETER | A parameter is invalid. |
-| EFI_ALREADY_STARTED | USB interface is already started. |
-| EFI_NO_RESPONSE | USB is not connected |
-| EFI_UNSUPPORTED | USB is not supported by the platform |
-| EFI_DEVICE_ERROR | The physical device reported an error. |
-
-## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStop()
-
-### Summary
-
-Stops the USB interface started by `FastbootUsbInterfaceStart()`.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_STOP)(
-  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This
-  );
-```
-
-### Parameters
-
-*This*  
-A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
-instance.
-
-### Description
-
-`FastbootUsbInterfaceStop()` should abort any pending transfer and remove the
-USB interface started by `FastbootUsbInterfaceStart()` from the USB descriptors.
-Upon successful return, the device should no longer be visible as a Fastboot
-device from the host.
-
-### Status Codes Returned
-
-|||
-| ----------- | ----------- |
-| EFI_SUCCESS | USB interface is stopped successfully.|
-| EFI_INVALID_PARAMETER | A parameter is invalid.|
-| EFI_NOT_STARTED | The USB interface is not started.|
-| EFI_DEVICE_ERROR | The physical device reported an error.|
-
-## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbReceive()
-
-### Summary
-
-Receives a USB packet from the interface started by
-`FastbootUsbInterfaceStart()`.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_RECEIVE)(
-  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This,
-  IN OUT UINTN                      *BufferSize,
-  OUT VOID                          *Buffer,
-  );
-```
-
-### Parameters
-
-*This*  
-A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
-instance.
-
-*BufferSize*  
-On entry, the size in bytes of `Buffer`. On exit, the size in bytes of the
-packet that was received.
-
-*Buffer*  
-A pointer to the data buffer to receive the USB packet.
-
-### Description
-
-`FastbootUsbReceive()` should poll and, if available, receive the next USB
-packet from the Fastboot USB interface into the provided buffer.
-
-### Status Codes Returned
-
-|||
-| ----------- | ----------- |
-| EFI_SUCCESS | A new USB packet is received successfully. |
-| EFI_INVALID_PARAMETER | A parameter is invalid.|
-| EFI_NOT_STARTED | The USB interface is not started.|
-| EFI_NOT_READY | No packet has been received from the interface.|
-| EFI_BUFFER_TOO_SMALL | Buffer is too small for the next packet. `BufferSize` should be updated to the required size in this case. |
-| EFI_DEVICE_ERROR | The physical device reported an error.|
-
-## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbSend()
-
-### Summary
-
-Sends a USB packet from the USB interface started by
-`FastbootUsbInterfaceStart()`.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_SEND)(
-  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This,
-  IN OUT UINTN                      *BufferSize,
-  IN CONST VOID                     *Buffer,
-  );
-```
-
-### Parameters
-
-*This*  
-A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
-instance.
-
-*BufferSize*  
-On entry, the size in bytes of `Buffer` to be sent. If the size is greater than
-the maximum packet size of the USB interface, it should be set to the maximum
-packet size and EFI_BAD_BUFFER_SIZE should be returned.
-
-*Buffer*  
-A pointer to the data buffer to be sent.
-
-### Description
-
-`FastbootUsbSend()` should copy the provided packet into an internal Tx buffer
-owned by the protocol driver and initiate the send. The interface is
-non-blocking and should return immediately. It should not accept any new packet
-if the previous one hasn't complete.
-
-### Status Codes Returned
-
-|||
-| ----------- | ----------- |
-| EFI_SUCCESS | The USB packet is sent successfully. |
-| EFI_INVALID_PARAMETER | A parameter is invalid.|
-| EFI_NOT_STARTED | The USB interface is not started.|
-| EFI_NOT_READY | The previous packet is still pending. |
-| EFI_BAD_BUFFER_SIZE | `BufferSize` is greater than the maximum packet size of the USB interface. `BufferSize` should be updated to the maximum packet size in this case. |
-| EFI_DEVICE_ERROR | The physical device reported an error.|
diff --git a/gbl/docs/GBL_EFI_IMAGE_LOADING_PROTOCOL.md b/gbl/docs/GBL_EFI_IMAGE_LOADING_PROTOCOL.md
deleted file mode 100644
index cc3e42b..0000000
--- a/gbl/docs/GBL_EFI_IMAGE_LOADING_PROTOCOL.md
+++ /dev/null
@@ -1,248 +0,0 @@
-# GBL EFI Image Loading Protocol
-
-This document describes the GBL Image Loading protocol. This optional protocol
-defines interfaces that can be used by EFI applications to specify implement
-customised buffer location in memory. And additional images for verification.
-
-|||
-| :--- | :--- |
-| **Status** | Work in progress |
-| **Created** | 2024-12-11 |
-
-
-## GBL_EFI_IMAGE_LOADING_PROTOCOL
-
-### Summary
-
-This protocol allows firmware to provide platform reserved memory spaces to
-applications for a specific usage or feature, or alternatively, specify the
-amount of memory the application should allocate dynamically for it.
-
-It also provides interface to communicate additional images to be verified by
-GBL.
-
-### GUID
-
-```c
-// {db84b4fa-53bd-4436-98a7-4e0271428ba8}
-#define GBL_EFI_IMAGE_LOADING_PROTOCOL_GUID          \
-  {                                                  \
-    0xdb84b4fa, 0x53bd, 0x4436, {                    \
-      0x98, 0xa7, 0x4e, 0x02, 0x71, 0x42, 0x8b, 0xa8 \
-    }                                                \
-  }
-```
-
-### Revision Number
-
-```c
-#define GBL_EFI_IMAGE_PROTOCOL_PROTOCOL_REVISION 0x00010000
-```
-
-### Protocol Interface Structure
-
-```c
-typedef struct _GBL_EFI_IMAGE_LOADING_PROTOCOL {
-  UINT64                        Revision;
-  GBL_EFI_GET_IMAGE_BUFFER      GetBuffer;
-  GBL_EFI_GET_VERIFY_PARTITIONS GetVerifyPartitions;
-} GBL_EFI_IMAGE_LOADING_PROTOCOL;
-```
-
-### Parameters
-
-**Revision** \
-The revision to which the GBL_EFI_IMAGE_BUFFER_PROTOCOL adheres. All future
-revisions must be backwards compatible. If a future version is not backwards
-compatible, a different GUID must be used.
-
-**GetBuffer** \
-Query custom buffer for the image. See
-[`GBL_EFI_IMAGE_LOADING_PROTOCOL.GetBuffer()`](#gbl_efi_image_loading_protocolgetbuffer).
-
-**GetVerifyPartitions** \
-Query for list of partitions to be verified by GBL. See
-[`GBL_EFI_IMAGE_LOADING_PROTOCOL.GetVerifyPartitions()`](#gbl_efi_image_loading_protocolgetverifypartitions).
-
-
-## GBL_EFI_IMAGE_LOADING_PROTOCOL.GetBuffer()
-
-### Summary
-
-`GetBuffer()` is used by GBL to get buffers for loading different images into
-RAM.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI *GBL_EFI_GET_IMAGE_BUFFER) (
-  IN GBL_EFI_IMAGE_LOADING_PROTOCOL *This,
-  IN GBL_EFI_IMAGE_INFO             *ImageInfo,
-  OUT GBL_EFI_IMAGE_BUFFER          *Buffer,
-)
-```
-
-### Parameters
-
-**This** \
-A pointer to the
-[`GBL_EFI_IMAGE_LOADING_PROTOCOL`](#gbl_efi_image_loading_protocol) instance.
-
-**ImageInfo** \
-Information for the requested buffer. See
-[`GBL_EFI_IMAGE_INFO`](#gbl_efi_image_info) for details.
-
-**Buffer** \
-Output pointer for `GBL_EFI_IMAGE_BUFFER`. See
-[`GBL_EFI_IMAGE_BUFFER`](#gbl_efi_image_buffer) for details.
-
-### Description
-
-The interface is for the firmware to provide platform reserved memory spaces
-to, or instruct caller to allocate specific amount of memory for the usage
-context described in `GBL_EFI_IMAGE_INFO.StrUtf16`. The usage context is
-application specific and may represent usages such as buffers for loading
-specific partitions, sharing data with secure world, and downloading in
-fastboot etc.
-
-If platform has a reserved memory space for the usage context,
-`GBL_EFI_IMAGE_BUFFER.Memory` and `GBL_EFI_IMAGE_BUFFER.SizeBytes` should be
-set to the address and size of the memory. Ownership of the provided memory
-must be passed exclusively to GBL, and must not be retained for any other
-purpose by firmware.
-
-If the caller should allocate memory dynamically by itself for the usage
-context, `GBL_EFI_IMAGE_BUFFER.Memory` should be set to NULL and
-`GBL_EFI_IMAGE_BUFFER.SizeBytes` should be set to the amount of memory caller
-should allocate.
-
-Caller may pass a suggested size via `GBL_EFI_IMAGE_INFO.SizeBytes` based on
-its run time knowledge. Implementation should eventually determine the size.
-
-### Status Codes Returned
-
-|||
-| --- | --- |
-| EFI_SUCCESS | Buffer provided successfully |
-| EFI_OUT_OF_RESOURCES | Failed to allocate buffers due to lack of free memory |
-
-### Related Definitions
-
-#### GBL_EFI_IMAGE_BUFFER
-
-```c
-typedef
-struct GBL_EFI_IMAGE_BUFFER {
-  VOID  *Memory;
-  UINTN SizeBytes;
-} GBL_EFI_IMAGE_BUFFER;
-```
-
-**Memory** \
-Start address of the reserved buffer or NULL if caller should allocate.
-
-**SizeBytes** \
-Size of the reserved buffer or amount of memory caller should allocate.
-
-## GBL_EFI_IMAGE_LOADING_PROTOCOL.GetVerifyPartitions()
-
-### Summary
-
-Query for list of partitions to be verified by GBL.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI *GBL_EFI_GET_VERIFY_PARTITIONS) (
-  IN GBL_EFI_IMAGE_LOADING_PROTOCOL *This,
-  IN OUT UINTN                      *NumberOfPartitions,
-  IN OUT GBL_EFI_PARTITION_NAME     *Partitions,
-);
-```
-
-### Parameters
-
-**This** \
-A pointer to the
-[`GBL_EFI_IMAGE_LOADING_PROTOCOL`](#gbl_efi_image_loading_protocol) instance.
-
-**NumberOfPartitions** \
-Number of elements in `Partitions[]`. Should be updated to
-number of partitions returned. If there are no partitions to be verified,
-`NumberOfPartitions` should be set to 0.
-
-**Partitions** \
-Array of partitions' names that should be verified. Should be update on return.
-And contain `NumberOfPartitions` valid elements.
-
-### Description
-
-This function is used to override list of partitions to be verified by GBL.
-
-If this function is not implemented or returns `EFI_UNSUPPORTED` GBL will verify
-default list of partitions.
-
-[`GBL_EFI_PARTITION_NAME`](#gbl_efi_partition_name) is struct representing
-partition name. Partition name is UCS-2 string of at most
-`PARTITION_NAME_LEN_U16` elements with terminating `NULL` element.
-
-### Status Codes Returned
-
-|||
-| --- | --- |
-| EFI_SUCCESS | Successfully provided additional partitions to verify |
-| EFI_INVALID_PARAMETER | If `Partitions[]` is `NULL`, where `NumberOfPartitions != 0` |
-
-### Related Definitions
-
-#### GBL_EFI_PARTITION_NAME
-
-```c
-const size_t PARTITION_NAME_LEN_U16 = 36;
-
-typedef
-struct GBL_EFI_PARTITION_NAME {
-  CHAR16 StrUtf16[PARTITION_NAME_LEN_U16];
-} GBL_EFI_PARTITION_NAME;
-```
-
-**StrUtf16** \
-UCS-2 C-String. This string contains partition name, that identifies what
-partition to use for additional validation. The string is at most
-`PARTITION_NAME_LEN_U16` of char16_t elements. E.g. `u"boot"`, `u"fdt"`
-
-#### GBL_EFI_IMAGE_INFO
-
-```c
-const size_t PARTITION_NAME_LEN_U16 = 36;
-
-typedef
-struct GBL_EFI_IMAGE_INFO {
-  CHAR16 ImageType[PARTITION_NAME_LEN_U16];
-  UINTN  SizeBytes;
-} GBL_EFI_IMAGE_INFO;
-```
-
-**ImageType** \
-UCS-2 C-String. This string describes the usage context for the buffer being
-queried. It should be at most `PARTITION_NAME_LEN_U16` of char16_t elements
-including terminating `u'\0'`. E.g. `u"dtb"`
-
-Below are usage strings reserved by GBL.
-
-```c
-//******************************************************
-// GBL reserved image types
-//******************************************************
-// Buffer for loading, verifying and fixing up OS images.
-#define GBL_IMAGE_TYPE_OS_LOAD L"os_load"
-// Buffer for use as fastboot download buffer.
-#define GBL_IMAGE_TYPE_FASTBOOT L"fastboot"
-```
-
-**SizeBytes** \
-Size of the buffer or allocation suggested by the caller.
diff --git a/gbl/docs/efi_protocols.md b/gbl/docs/efi_protocols.md
deleted file mode 100644
index 36fb493..0000000
--- a/gbl/docs/efi_protocols.md
+++ /dev/null
@@ -1,225 +0,0 @@
-# GBL UEFI Protocols
-
-This document lists every UEFI protocol that GBL may potentially use, and
-describes the use case with any requirements.
-
-## Upstream Protocols
-
-These protocols are taken from an external source, typically the UEFI spec.
-
-### BlockIoProtocol
-
-* [`EFI_BLOCK_IO_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access.html#efi-block-io-protocol)
-* required
-
-Used to read the GPT, load images from disk, and write data back to disk in
-e.g. in fastboot.
-
-This is required even if the Block I/O 2 Protocol is provided, as some use cases
-might want to use this simpler API.
-
-### BlockIo2Protocol
-
-* [`EFI_BLOCK_IO2_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access.html#block-i-o-2-protocol)
-* optional: enables performance optimizations
-
-If provided, GBL may use this protocol instead of the Block I/O Protocol as a
-performance optimization; for example during fastboot flashing it may flash to
-disk while concurrently receiving the next image over USB.
-
-### DevicePathProtocol
-
-* [`EFI_DEVICE_PATH_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html#efi-device-path-protocol)
-* optional: enables logging the image path on GBL start
-
-Used for logging the GBL image path to the console on load. This can be useful
-as a "Hello world" proof-of-concept that GBL is running and can interact with
-the UEFI protocols.
-
-This logging requires all three of:
-* Device Path Protocol
-* Device Path to Text Protocol
-* Loaded Image Protocol
-
-### DevicePathToTextProtocol
-
-* [`EFI_DEVICE_PATH_TO_TEXT_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html#device-path-to-text-protocol)
-* optional: enables logging the image path on GBL start
-
-Used for logging the GBL image path to the console on load. This can be useful
-as a "Hello world" proof-of-concept that GBL is running and can interact with
-the UEFI protocols.
-
-This logging requires all three of:
-* Device Path Protocol
-* Device Path to Text Protocol
-* Loaded Image Protocol
-
-### LoadedImageProtocol
-
-* [`EFI_LOADED_IMAGE_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/09_Protocols_EFI_Loaded_Image.html#efi-loaded-image-protocol)
-* optional: enables logging the image path on GBL start
-
-Used for logging the GBL image path to the console on load. This can be useful
-as a "Hello world" proof-of-concept that GBL is running and can interact with
-the UEFI protocols.
-
-This logging requires all three of:
-* Device Path Protocol
-* Device Path to Text Protocol
-* Loaded Image Protocol
-
-### Memory Allocation Services
-
-* [Memory allocation services](https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-allocation-services)
-* all required
-
-Used by libavb for image verification.
-
-Dynamic memory allocation can be minimized, but not completely eliminated, by
-providing preallocated image buffers via the GBL Image Loading Protocol.
-
-### RiscvBootProtocol
-
-* [`RISCV_EFI_BOOT_PROTOCOL`](https://github.com/riscv-non-isa/riscv-uefi/blob/main/boot_protocol.adoc)
-* required for RISC-V targets
-
-Used to query the boot hart ID which is required to pass to the kernel.
-
-### SimpleNetworkProtocol
-
-* [`EFI_SIMPLE_NETWORK_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/24_Network_Protocols_SNP_PXE_BIS.html#simple-network-protocol)
-* optional: enables fastboot over TCP
-
-Used to provide fastboot over TCP. This can be enabled by itself, or in
-addition to fastboot over USB.
-
-Currently if this protocol is available GBL will always start fastboot over TCP,
-but in the future this functionality will be restricted to dev builds only.
-Production devices should not expose fastboot over TCP.
-
-GBL only uses the Simple Network Protocol, and will not use higher-level
-protocols such as the TCP4/6 Protocols even if they are available.
-
-### SimpleTextInputProtocol
-
-* [`EFI_SIMPLE_TEXT_INPUT_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/12_Protocols_Console_Support.html#simple-text-input-protocol)
-* optional: enables the 'f' key to enter fastboot
-
-This is currently used to look for the 'f' key on the serial line during boot,
-which will trigger GBL to enter fastboot mode. If not provided, GBL will skip
-this check.
-
-We plan to remove this and instead use a more general protocol to allow devices
-to specify their own custom fastboot triggers.
-
-### SimpleTextOutputProtocol
-
-* [`EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/12_Protocols_Console_Support.html#simple-text-output-protocol)
-* required, but can be no-op
-
-Used for logging and debugging. Implementations must provide this protocol, but
-the functions may be no-ops.
-
-## Community Protocols
-
-Protocols defined by a community and used across the ecosystem, but not officially
-part of the UEFI specification. None of these protocols are required.
-
-### DtFixupProtocol
-
-* original [proposal](https://github.com/U-Boot-EFI/EFI_DT_FIXUP_PROTOCOL)
-* [upstream](https://github.com/u-boot/u-boot/blob/master/include/efi_dt_fixup.h)
-* optional: allows FW to modify the final device tree
-
-This protocol allows the firmware (FW) to inspect the final device tree and apply
-necessary fixups.
-
-GBL will validate the applied changes and prevent booting if any of the security
-limitations (listed below) are violated. Any errors will be reported through the
-UEFI log.
-
-TODO (b/353272981): Add limitations
-
-This protocol was proposed by U-Boot and is currently used by the Kernel UEFI stub.
-
-## GBL Custom Protocols
-
-These protocols are defined by GBL to provide specific functionality that is
-not available elsewhere.
-
-Majority of these custom protocols aren't required, with the intention that dev
-boards that support a typical set of UEFI protocols should be able to use GBL
-with a minimal firmware modifications and still get some basic booting functionality.
-
-However, without these protocols GBL will be missing key features such as
-USB fastboot and verified boot, so production targets and more full-featured dev
-boards will need to implement them.
-
-### GblFastbootProtocol
-
-* [`GBL_EFI_FASTBOOT_PROTOCOL`](./gbl_efi_fastboot_protocol.md)
-* optional: enables custom fastboot functionality.
-
-Used to provide an interface for
-* Custom variables
-* OEM commands
-* Device lock/unlock controls
-* Lock-contingent partition permission information
-* User data erasure
-
-### GblFastbootUsbProtocol
-
-* [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](./GBL_EFI_FASTBOOT_USB_PROTOCOL.md)
-* optional: enables fastboot over USB
-
-Used to provide fastboot over USB. This can be enabled by itself, or in
-addition to fastboot over TCP.
-
-### GblOsConfigurationProtocol
-
-* [`GBL_EFI_OS_CONFIGURATION_PROTOCOL`](./gbl_os_configuration_protocol.md)
-* optional: enables runtime fixups of OS data
-
-Used for runtime fixups of data provided to the OS such as command line and
-device tree. If not provided, the data in the OS images loaded from disk will
-be used without modification.
-
-### GblSlotProtocol
-
-* TODO(b/359946695): link documentation
-* optional: enables A/B slotted booting
-
-Used to read and write A/B slot metadata. If not provided, GBL will
-load from either the `_a` slot or a slotless boot partition.
-
-All components that interact with A/B slot metadata must use the same format.
-Typically these components are:
-
-1. The UEFI firmware selecting which GBL slot to load
-2. GBL selecting which OS slot to load
-3. The OS update engine updating the metadata when a new version is downloaded
-
-This protocol allows the device to implement its own A/B metadata format while
-still allowing GBL to implement the boot flow logic.
-
-### GblImageLoadingProtocol
-
-* TODO(b/359946775): link documentation
-* optional: enables loading images to predefined memory locations
-
-Used to provide buffers to load the images for verification and boot process.
-
-In addition this protocol provides a list of additional custom partitions to be
-verified before booting, for boards that want to verify data in addition to the
-standard boot partitions.
-
-### GblAvbProtocol
-
-* [`GBL_EFI_AVB_PROTOCOL`](./gbl_avb_protocol.md)
-* required for production devices: enables AVB-related firmware callbacks.
-
-This protocol delegates some of AVB-related logic to the firmware, including
-tasks such as verifying public keys, handling verification results, and
-managing the devices secure state (e.g., ROT, lock state, rollback indexes,
-etc.).
diff --git a/gbl/docs/gbl_ab_boot_flow.md b/gbl/docs/gbl_ab_boot_flow.md
deleted file mode 100644
index d4cc402..0000000
--- a/gbl/docs/gbl_ab_boot_flow.md
+++ /dev/null
@@ -1,83 +0,0 @@
-# A/B Boot Flow in GBL
-
-This document explains the A/B boot flows implemented by GBL and its
-interaction with EFI protocol
-[GBL_EFI_AB_SLOT_PROTOCOL](./gbl_efi_ab_slot_protocol.md).
-
-| **Status**  | Work in progress |
-|:------------|-----------------:|
-| **Created** |        2024-12-3 |
-
-## Android
-
-For Android, GBL supports the following two configurations of A/B boot:
-
-1. Slotless bootloader + A/B Android.
-1. A/B bootloader + A/B Android.
-
-At run time, GBL detects the configuration by checking the return value of
-[GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()](./gbl_efi_ab_slot_protocol.md#gbl_efi_ab_slot_protocolgetcurrentslot).
-If the return is error `EFI_UNSUPPORTED`, GBL considers bootloader to be
-slotless and proceeds with the
-[Slotless bootloader + A/B Android](#slotless-bootloader--ab-android) boot
-flow. Otherwise it proceeds with the
-[A/B/ bootloader + A/B Android](#ab-bootloader--ab-android) boot flow.
-
-Note: The boot flow supports >2 slots. We use A/B simply as an example for
-illustration.
-
-### Slotless Bootloader + A/B Android
-
-#### Platform Setup
-
-This configuration corresponds to the following platform setup.
-
-![slotless-bootloader-ab-android](./resources/slotless-bl-ab-android.png)
-
-Device has a single slot GBL bootloader and A/B slot Android OS. Vendor
-firmware hands off to the single GBL slot which then make A/B decision for
-Android OS.
-
-#### Boot Flow
-
-The boot flow is summarized in the following diagram
-
-![slotless-bootloader-ab-android](./resources/slotless-bl-ab-android-flow.png)
-
-GBL will make exactly one call to
-[GBL_EFI_AB_SLOT_PROTOCOL.GetNextSlot()](./gbl_efi_ab_slot_protocol.md)
-with boolean argument `mark_boot_attempt` set to true for getting the target
-slot to boot. When Vendor UEFI firmware sees `mark_boot_attempt=true`, it
-should update slot metadata such as derementing retry counter. If the slot is
-loaded and verified successfully, GBL proceeds to boot the slot. Otherwise it
-triggers a reboot.
-
-### A/B Bootloader + A/B Android
-
-#### Platform Setup
-
-This configuration corresponds to the following platform setup.
-
-![slotless-bootloader-ab-android](./resources/ab-bl-ab-android.png)
-
-Device has A/B GBL bootloader and A/B Android OS. Vendor firmware makes A/B
-slot decision and boots to the correponding GBL slot. GBL simply continues to
-boot the same Android OS slot.
-
-#### Boot Flow
-
-The boot flow is summarized in the following diagram.
-
-![slotless-bootloader-ab-android](./resources/ab-bl-ab-android-flow.png)
-
-GBL queries the current bootloader slot by calling
-[GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()](./gbl_efi_ab_slot_protocol.md#gbl_efi_ab_slot_protocolgetcurrentslot).
-It also tracks whether
-[GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()](./gbl_efi_ab_slot_protocol.md#gbl_efi_ab_slot_protocolsetactiveslot)
-has been called to change the next active slot to a different slot, i.e. by
-`fastboot set_active`. If it has, GBL considers that the user intends to boot
-to a different slot than the current one and will trigger a reboot. If not, GBL
-proceeds to load and verify the same slot Android OS. If all operations are
-successful, GBL boots from it. Otherwise it triggers a reboot. Note that in
-this flow, vendor firmware is responsible for updating slot metadata such as
-decrementing retry counters before booting GBL.
diff --git a/gbl/docs/gbl_buffer_usage.md b/gbl/docs/gbl_buffer_usage.md
deleted file mode 100644
index b50f718..0000000
--- a/gbl/docs/gbl_buffer_usage.md
+++ /dev/null
@@ -1,64 +0,0 @@
-# Buffer Usage in GBL
-
-This doc discusses how GBL (EFI bootloader) gets and uses buffers for various
-functionalities.
-
-## OS Load Buffer
-
-GBL needs a sufficiently large and contiguous buffer for loading, fixing up and
-assembling various OS images such as boot, init_boot, vendor_boot, dtb, dtbo,
-misc etc. This buffer can either be from EFI memory allocation or memory space
-reserved by the platform. At run time, GBL performs the following for
-requesting an OS load buffer.
-
-1. Via
-[GBL_EFI_IMAGE_LOADING_PROTOCOL.GetBuffer()](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md#gbl_efi_image_loading_protocolgetbuffer)
-
-   If [GBL_EFI_IMAGE_LOADING_PROTOCOL](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md) is
-   implemented, GBL will make a call to
-   `GBL_EFI_IMAGE_LOADING_PROTOCOL.GetBuffer()` with input image type set to
-   [GBL_IMAGE_TYPE_OS_LOAD](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md#related-definitions-1)
-   and input size set to 0 (size determined by vendor). Vendor returns the size
-   and address of the reserved memory if available or instructs GBL to
-   allocates a specific amount of memory via EFI memory allocation.
-
-2. Via EFI Memory Allocation
-
-   If [GBL_EFI_IMAGE_LOADING_PROTOCOL](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md) is
-   not implemented GBL allocates a 256MB size buffer via EFI memory allocation.
-
-## Fastboot Download Buffer
-
-When booting to fastboot mode, GBL requires a buffer for download. The buffer
-is requested following the same process as the case of
-[OS Load Buffer](#os-load-buffer):
-
-1. Via
-[GBL_EFI_IMAGE_LOADING_PROTOCOL.GetBuffer()](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md#gbl_efi_image_loading_protocolgetbuffer)
-
-   If [GBL_EFI_IMAGE_LOADING_PROTOCOL](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md) is
-   implemented, GBL will make a call to
-   `GBL_EFI_IMAGE_LOADING_PROTOCOL.GetBuffer()` with input image type set to
-   [GBL_IMAGE_TYPE_FASTBOOT](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md#related-definitions-1)
-   and input size set to 0 (size determined by vendor). Vendor returns the size
-   and address of the reserved memory if available or instructs GBL to
-   allocates a specific amount of memory via EFI memory allocation.
-
-2. Via EFI Memory Allocation
-
-   If [GBL_EFI_IMAGE_LOADING_PROTOCOL](./GBL_EFI_IMAGE_LOADING_PROTOCOL.md) is
-   not implemented GBL allocates a 512MB size buffer via EFI memory allocation.
-
-## AARCH64 Kernel Decopmression
-
-GBL can detect and handle compressed kernel for aarch64. However, current
-implementation requires allocating a separate piece of memory for storing
-decompressed kernel temporarily. This buffer is allocated via EFI memory
-allocation.
-
-## AVB
-
-The AVB (Android Verified Boot) implementation in GBL requires allocating
-additional memory for constructing commandline argument strings and loading
-vbmeta images from disk and any other vendor required partitions for
-verification. The memory is allocated via EFI memory allocation.
diff --git a/gbl/docs/gbl_efi_ab_slot_protocol.md b/gbl/docs/gbl_efi_ab_slot_protocol.md
deleted file mode 100644
index 72bdb1f..0000000
--- a/gbl/docs/gbl_efi_ab_slot_protocol.md
+++ /dev/null
@@ -1,747 +0,0 @@
-# GBL EFI AB Slot Protocol
-
-This document describes the GBL AB Slot protocol.
-The protocol defines interfaces that can be used by EFI applications
-to query and manipulate boot slots.
-
-See this [document](./gbl_ab_boot_flow.md) For details on how GBL uses this
-protocol to implement A/B flows.
-
-| **Status**  | Work in progress |
-|:------------|-----------------:|
-| **Created** |        2024-9-17 |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL`
-
-### Summary
-
-This protocol provides interfaces for platform specific boot slot operations,
-such as determining the number of slots and the current target slot,
-changing the current target boot slot, marking boot attempts, and more.
-
-### GUID
-
-```c
-// {9a7a7db4-614b-4a08-3df9-006f49b0d80c}
-#define GBL_EFI_AB_SLOT_PROTOCOL_GUID                \
-  {                                                  \
-    0x9a7a7db4, 0x614b, 0x4a08, {                    \
-      0x3d, 0xf9, 0x00, 0x6f, 0x49, 0xb0, 0xd8, 0x0c \
-    }                                                \
-  }
-```
-
-### Protocol Version
-```c
-#define GBL_EFI_AB_SLOT_PROTOCOL_VERSION 0x00010000
-```
-
-### Protocol Interface Structure
-
-```c
-typedef struct GBL_EFI_AB_SLOT_PROTOCOL {
-  // Currently must contain 0x00010000
-  UINT32                              Version;
-  GBL_EFI_AB_SLOT_LOAD_BOOT_DATA      LoadBootData;
-  GBL_EFI_AB_SLOT_GET_SLOT_INFO       GetSlotInfo;
-  GBL_EFI_AB_SLOT_GET_CURRENT_SLOT    GetCurrentSlot;
-  GBL_EFI_AB_SLOT_GET_ACTIVE_SLOT     GetActiveSlot;
-  GBL_EFI_AB_SLOT_SET_ACTIVE_SLOT     SetActiveSlot;
-  GBL_EFI_AB_SLOT_SET_SLOT_UNBOOTABLE SetSlotUnbootable;
-  GBL_EFI_AB_SLOT_MARK_BOOT_ATTEMPT   MarkBootAttempt;
-  GBL_EFI_AB_SLOT_REINITIALIZE        Reinitialize;
-  GBL_EFI_AB_SLOT_GET_BOOT_REASON     GetBootReason;
-  GBL_EFI_AB_SLOT_SET_BOOT_REASON     SetBootReason;
-  GBL_EFI_AB_SLOT_FLUSH               Flush;
-} GBL_EFI_AB_SLOT_PROTOCOL;
-```
-
-### Parameters
-
-**Version**
-
-The revision to which the `GBL_EFI_AB_SLOT_PROTOCOL` adheres.
-All future version must be backwards compatible.
-If a future version is not backwards compatible, a different GUID must be used.
-
-**LoadBootData**
-
-Loads slot metadata from persistent storage. Other slot operations may call
-this method internally.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.LoadBootData()`](#gbl_efi_ab_slot_protocolloadbootdata).
-
-**GetSlotInfo**
-
-Returns information about a slot by index.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.GetSlotInfo()`](#gbl_efi_ab_slot_protocolgetslotinfo).
-
-**GetCurrentSlot**
-
-Returns the slot information of the currently booted bootloader.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot).
-
-**GetNextSlot**
-
-Returns the slot information of the next slot decision.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.GetNextSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot).
-
-**SetActiveSlot**
-
-Marks the specified slot as the active boot target.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()`](#gbl_efi_ab_slot_protocolsetactiveslot).
-
-**SetSlotUnbootable**
-
-Marks the specified slot as unbootable.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.SetSlotUnbootable()`](#gbl_efi_ab_slot_protocolsetslotunbootable).
-
-**Reinitialize**
-
-Resets slot metadata to a default, initial state.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.Reinitialize()`](#gbl_efi_ab_slot_protocolreinitialize).
-
-**GetBootReason**
-
-Gets the boot reason.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.GetBootReason()`](#gbl_efi_ab_slot_protocolgetbootreason).
-
-**SetBootReason**
-
-Sets the boot reason.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.SetBootReason()`](#gbl_efi_ab_slot_protocolsetbootreason).
-
-**Flush**
-
-Synchronizes slot metadata with persistent storage. May re-establish data
-structure invariants, e.g. recalculate checksums.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.Flush()`](#gbl_efi_ab_slot_protocolflush).
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.LoadBootData()`
-
-### Summary
-
-Loads metadata about system boot slots.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_LOAD_BOOT_DATA)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL*     This,
-    OUT GBL_EFI_SLOT_METADATA_BLOCK* Metadata,
-);
-```
-
-### Related Definitions
-
-```c
-typedef enum _GBL_EFI_SLOT_MERGE_STATUS {
-  GBL_EFI_SLOT_MERGE_STATUS_NONE = 0,
-  GBL_EFI_SLOT_MERGE_STATUS_UNKNOWN,
-  GBL_EFI_SLOT_MERGE_STATUS_SNAPSHOTTED,
-  GBL_EFI_SLOT_MERGE_STATUS_MERGING,
-  GBL_EFI_SLOT_MERGE_STATUS_CANCELLED,
-} GBL_EFI_SLOT_MERGE_STATUS;
-
-typedef struct _GBL_EFI_SLOT_METADATA_BLOCK {
-  // Value of 1 if persistent metadata tracks slot unbootable reasons.
-  UINT8 UnbootableMetadata;
-  UINT8 MaxRetries;
-  UINT8 SlotCount;
-  // See the definition of GBL_EFI_SLOT_MERGE_STATUS.
-  UINT8  MergeStatus;
-} GBL_EFI_SLOT_METADATA_BLOCK;
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Metadata*
-
-On return contains device-specific immutable information about the AB slot
-implementation. See [`Related Definitions`](#related-definitions) for the layout
-of the metadata structure and its fields.
-
-### Description
-
-In addition to information about individual slots, EFI applications need
-overarching metadata about AB boot slot implementations.
-In particular, implementations might not store persistent metadata detailing why
-specific slots are not bootable (i.e. unbootable metadata). Developers may want
-to know whether a device supports unbootable metadata to ease in debugging.
-
-Certain operations may be prohibited due to the device's A/B merge status.
-For more information about the *MergeStatus* field and Android Virtual A/B, see
-the documentation
-[here](https://source.android.com/docs/core/ota/virtual_ab/implement).
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                     |
-|:------------------------|:--------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | Slot metadata was successfully read from persistent storage.                                                  |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Metadata* is `NULL` or improperly aligned.                                                  |
-| `EFI_DEVICE_ERROR`      | There was an error while performing the read operation.                                                       |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.GetSlotInfo()`
-
-### Summary
-
-Queries info about a boot slot by index.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_GET_SLOT_INFO)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    IN UINT8                     Idx,
-    OUT GBL_EFI_SLOT_INFO*       Info,
-)
-```
-
-### Related Definitions
-
-```c
-typedef enum _GBL_EFI_SLOT_UNBOOTABLE_REASON {
-  UNKNOWN_REASON = 0,
-  NO_MORE_TRIES,
-  SYSTEM_UPDATE,
-  USER_REQUESTED,
-  VERIFICATION_FAILURE,
-} GBL_EFI_SLOT_UNBOOTABLE_REASON;
-
-typedef struct _GBL_EFI_SLOT_INFO {
-    // One UTF-8 encoded single character
-    UINT32 Suffix;
-    // Any value other than those explicitly enumerated in
-    // GBL_EFI_SLOT_UNBOOTABLE_REASON
-    // will be interpreted as UNKNOWN_REASON.
-    UINT32 UnbootableReason;
-    UINT8  Priority;
-    UINT8  Tries;
-    // Value of 1 if slot has successfully booted
-    UINT8  Successful;
-} GBL_EFI_SLOT_INFO;
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Idx*
-
-The index of the slot to query.
-
-*Info*
-
-On exit contains the metadata for the specified slot.
-See [Related Definitions](#related-definitions-1)
-for the layout and fields of the metadata structure.
-
-### Description
-
-Developers and EFI applications may wish to query metadata of arbitrary boot
-slots as part of debugging or logging.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                     |
-|:------------------------|:--------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned, or the value of *Idx* invalid.                       |
-| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()`
-
-### Summary
-
-Returns the slot information of the currently booted bootloader.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_GET_CURRENT_SLOT)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    OUT GBL_EFI_SLOT_INFO*       Info,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Info*
-
-On exit contains the metadata for the current slot.
-See the definition for [`GBL_EFI_SLOT_INFO`](#related-definitions-1)
-for the structure definition.
-
-### Description
-
-Returns the slot of the currently booted bootloader. If bootloader is not
-slotted, i.e. the device only has a single slot bootloader instead of A/B, the
-function returns `EFI_UNSUPPORTED`.
-
-This is identical to knowing the index of the current slot and calling
-`GetSlotInfo()` with that index.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                          |
-|:------------------------|:---------------------------------- |
-| `EFI_SUCCESS`           | The call completed successfully.   |
-| `EFI_UNSUPPORTED`       | Bootloader is not slotted.         |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL`. |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.GetNextSlot()`
-
-### Summary
-
-Returns the slot information of the next slot decision.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_GET_NEXT_SLOT)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    IN BOOL                      MarkBootAttempt,
-    OUT GBL_EFI_SLOT_INFO*       Info,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*MarkBootAttempt*
-
-The parameter is set to true if caller attempts to load, verify and boot the
-returned slot. If the caller only wants to query the next slot decision and
-does not intend to cause any state change, it is set to false.
-
-*Info*
-
-On exit contains the metadata for the next slot.
-See the definition for [`GBL_EFI_SLOT_INFO`](#related-definitions-1)
-for the structure definition.
-
-### Description
-
-The function returns the highest priority bootable slot according to current
-slot state.
-
-If parameter `MarkBootAttempt` is true, implementation should updates internal
-metadata for the slot such as decrementing retry counters if slot has not been
-successful.
-
-If there are no bootable slots, the function **MUST** returns `EFI_NOT_FOUND`.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                     |
-|:------------------------|:--------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
-| `EFI_NOT_FOUND`         | There are no bootable slots for the next decision.                                                            |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned.                                                      |
-| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()`
-
-### Summary
-
-Sets the active slot by index. Makes it the highest priority bootable slot.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_SET_ACTIVE_SLOT)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    IN UINT8                     Idx,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Idx*
-
-The index of the new active slot.
-
-### Description
-
-Explicitly sets the target boot slot to the one defined by `Idx`.
-This clears any unbootable reason metadata the slot may have, resets its tries
-remaining to a device specific default, resets its priority to a device specific
-default, sets the priority of all other slots to be lower than that of the
-target, and clears the slot's *Successful* flag.
-All these changes **MUST** be visible in subsequent calls to `GetSlotInfo()`.
-Depending on device policy, e.g. lock state, changing the target boot slot
-explicitly may be prohibited.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                     |
-|:------------------------|:--------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned, or the value of *Idx* was invalid.                   |
-| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
-| `EFI_ACCESS_DENIED`     | Device policy prohibited the boot slot target change.                                                         |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.SetSlotUnbootable()`
-
-### Summary
-
-Marks a slot as unbootable for the provided reason.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_SET_SLOT_UNBOOTABLE)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    IN UINT8                     Idx,
-    IN UINT32                    UnbootableReason,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Idx*
-
-The index of the slot to mark unbootable.
-
-*UnbootableReason*
-
-The reason the slot is being marked unable to be booted.
-See the definition for [`GBL_EFI_SLOT_UNBOOTABLE_REASON`](#related-definitions-1)
-for valid values of *UnbootableReason*.
-
-**Note:** Unbootable reason codes are a best-effort debug and RMA helper.
-The device's persistent metadata structures may not track unbootable reasons,
-and other software that interacts with boot slots may not set unbootable reason
-codes accurately.
-
-### Description
-
-Marks a slot as not a valid boot target.
-The slot's *Priority*, *TriesRemaining*, and *Successful* fields are all set to
-`0`.
-Subsequent calls to `GetSlotInfo()` **MUST** reflect these changes to slot info.
-If the slot was the current slot, the current boot target will have changed.
-This change **MUST** be reflected in subsequent calls to `GetCurrentSlot()`.
-
-If the protocol driver supports tracking slot unbootable reasons, then
-subsequent calls to `GetSlotInfo()` **MUST** have the same *UnbootableReason* in
-the info structure.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                             |
-|:------------------------|:----------------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                                      |
-| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned, the value of *Idx* is invalid, or the value of *UnbootableReason* is invalid. |
-| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                          |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions.         |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.MarkBootAttempt()`
-
-### Summary
-
-Marks a boot attempt on the current slot.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_MARK_BOOT_ATTEMPT)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-);
-```
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-### Description
-
-Updates internal metadata for the current boot target slot.
-If the current slot has registered a successful boot, its tries remaining field
-is left unchanged.
-If there are no slots with non-zero *Successful* or *Tries* fields, the call to
-`MarkBootAttempt()` **MUST** return `EFI_ACCESS_DENIED`. The bootloader then
-must decide on the next action to take.
-
-Subsequent calls to `GetSlotInfo()` and `GetCurrentSlot()` **MUST** reflect
-the decremented tries.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                     |
-|:------------------------|:--------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
-| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.                                                                       |
-| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
-| `EFI_ACCESS_DENIED`     | The current slot has no more tries remaining.                                                                 |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.Reinitialize()`
-
-### Summary
-
-Reinitializes all boot slot metadata to a known initial state.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_REINITIALIZE)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-### Description
-
-In particular, all slots should have the following fields cleared and set to
-device-specific defaults:
-* *Priority*
-* *Tries*
-
-and have the following fields set to `0`:
-* *UnbootableReason*
-* *Successful*
-
-This may change the next target boot slot.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                              |
-|:------------------------|:-------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                       |
-| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.                |
-| `EFI_ACCESS_DENIED`     | Device policy prohibited resetting boot slot metadata. |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.GetBootReason()`
-
-### Summary
-
-Gets the current boot reason and subreason.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_GET_BOOT_REASON)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    OUT UINT32*                  Reason,
-    IN OUT UINTN*                SubreasonLength;
-    OUT UINT8*                   Subreason;
-);
-```
-
-### Related Definitions
-
-```c
-typedef enum _GBL_EFI_AB_SLOT_BOOT_REASON {
-    EMPTY = 0,
-    UNKNOWN = 1,
-    WATCHDOG = 14,
-    KERNEL_PANIC = 15,
-    RECOVERY = 3,
-    BOOTLOADER = 55,
-    COLD = 56,
-    HARD = 57,
-    WARM = 58,
-    SHUTDOWN = 59,
-    REBOOT = 18,
-    FASTBOOTD = 196,
-} GBL_EFI_AB_SLOT_BOOT_REASON;
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Reason*
-
-On exit, the boot reason code. See [Related Definitions](#related-definitions-2)
-for the list of valid codes.
-
-*SubreasonLength*
-
-On entry, the length of *Subreason* in bytes.
-On exit, the length of the UTF-8 encoded string pointed to by *Subreason*,
-ignoring any Null-terminator.
-
-*Subreason*
-
-On exit, the boot subreason as a UTF-8 encoded, Null-terminated string.
-
-### Description
-
-The boot reason is an Android mechanism for communicating between the running
-system and the bootloader. For example, if the boot reason is 'recovery', the
-bootloader should load the recovery RAM disk and command line. This information
-is stored in a device specific location and format.
-
-**Note:** The boot reason should ONLY be determined by checking persistent storage.
-In particular, if a device supports [`GBL_EFI_FASTBOOT_PROTOCOL`](./gbl_efi_fastboot_protocol.md),
-the return value of `GBL_EFI_FASTBOOT_PROTOCOL.ShouldStopInFastboot()` should NOT
-affect whether the boot reason returned by `GetBootReason()` is `BOOTLOADER`.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                                                                   |
-|:------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                                                                            |
-| `EFI_INVALID_PARAMETER` | One of *This*, *Reason*, *SubreasonLength*, or *Subreason* is `NULL` or improperly aligned.                                                                 |
-| `EFI_BUFFER_TOO_SMALL`  | *Subreason* is too small to store the serialized subreason string. The value of *SubreasonLength* is modified to contain the minimum necessary buffer size. |
-| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions.                                               |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.SetBootReason()`
-
-### Summary
-
-Sets the current boot reason.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_SET_BOOT_REASON)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-    IN UINT32                    Reason,
-    IN UINTN                     SubreasonLength,
-    IN UINT8                     Subreason,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-*Reason*
-
-The desired boot reason to set. See [here](#related-definitions-2) for the list
-of valid boot reasons.
-
-*SubreasonLength*
-
-The length of the *Subreason* string.
-
-*Subreason*
-
-The desired boot subreason as a UTF-8 encoded, Null-terminated string.
-
-### Description
-
-Sets the Android boot reason and subreason.
-This is usually used by the bootloader to clear the boot reason.
-See [`GetBootReason()`](#gbl_efi_ab_slot_protocolgetbootreason) for more
-information about boot reasons.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                               |
-|:------------------------|:----------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                        |
-| `EFI_INVALID_PARAMETER` | One of *This*, *Reason*, or *Subreason* is `NULL` or improperly aligned.                |
-| `EFI_INVALID_PARAMETER` | *Reason* is not a valid reason code or *Subreason* is not a valid UTF-8 encoded string. |
-| `EFI_UNSUPPORTED`       | The platform does not support setting the boot reason.                                  |
-| `EFI_BAD_BUFFER_SIZE`   | *Subreason* is too large  to be written to persistent storage.                          |
-
-## `GBL_EFI_AB_SLOT_PROTOCOL.Flush()`
-
-### Summary
-
-Writes any slot metadata modifications to persistent storage.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_AB_SLOT_FLUSH)(
-    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
-instance.
-
-### Description
-
-Protocol driver implementations may store modifications to boot slot metadata in
-memory before committing changes to storage in a single write operation.
-Protocol consumers need a mechanism to instruct the driver that they are
-finished operating on boot slots and that changes should be committed.
-The implementation should conduct any necessary ancillary tasks, e.g.
-recalculating checksums, before writing to storage.
-This is an optimization for performance and flash lifetime; implementations are
-free to write all modifications to storage as they occur and to define `Flash()`
-as a no-op.
-
-### Status Codes Returned
-
-| Return Code        | Semantics                                                 |
-|:-------------------|:----------------------------------------------------------|
-| `EFI_SUCCESS`      | The call completed successfully.                          |
-| `EFI_DEVICE_ERROR` | The device reported a write error during synchronization. |
diff --git a/gbl/docs/gbl_efi_avb_protocol.md b/gbl/docs/gbl_efi_avb_protocol.md
deleted file mode 100644
index 9dd6946..0000000
--- a/gbl/docs/gbl_efi_avb_protocol.md
+++ /dev/null
@@ -1,211 +0,0 @@
-# GBL AVB EFI Protocol
-
-## GBL_EFI_AVB_PROTOCOL
-
-### Summary
-
-This protocol allows to delegate device-specific Android verified booot (AVB)
-logic to the firmware.
-
-`GBL_EFI_AVB_PROTOCOL` protocol isn't required for dev GBL flavour with
-intention to support basic Android boot functionality on dev boards. On the
-production devices this protocol must be provided by the FW to ensure HLOS
-integrity.
-
-### GUID
-```c
-// {6bc66b9a-d5c9-4c02-9da9-50af198d912c}
-#define GBL_EFI_AVB_PROTOCOL_UUID                    \
-  {                                                  \
-    0x6bc66b9a, 0xd5c9, 0x4c02, {                    \
-      0x9d, 0xa9, 0x50, 0xaf, 0x19, 0x8d, 0x91, 0x2c \
-    }                                                \
-  }
-```
-
-### Revision Number
-
-Note: revision 0 means the protocol is not yet stable and may change in
-backwards-incompatible ways.
-
-```c
-#define GBL_EFI_AVB_PROTOCOL_REVISION 0x00010000
-```
-
-### Protocol Interface Structure
-
-```c
-typedef struct _GBL_EFI_AVB_PROTOCOL {
-  UINT64 Revision;
-  GBL_EFI_AVB_VALIDATE_VBMETA_PUBLIC_KEY ValidateVbmetaPublicKey;
-  GBL_EFI_AVB_READ_IS_DEVICE_UNLOCKED ReadIsDeviceUnlocked;
-  GBL_EFI_AVB_READ_ROLLBACK_INDEX ReadRollbackIndex;
-  GBL_EFI_AVB_WRITE_ROLLBACK_INDEX WriteRollbackIndex;
-  GBL_EFI_AVB_READ_PERSISTENT_VALUE ReadPersistentValue;
-  GBL_EFI_AVB_WRITE_PERSISTENT_VALUE WritePersistentValue;
-  GBL_EFI_AVB_HANDLE_VERIFICATION_RESULT HandleVerificationResult;
-} GBL_EFI_AVB_PROTOCOL;
-```
-
-### Parameters
-
-#### Revision
-The revision to which the `GBL_EFI_AVB_PROTOCOL` adheres. All
-future revisions must be backwards compatible. If a future version is not
-backwards compatible, a different GUID must be used.
-
-#### ValidateVbmetaPublicKey
-Validate proper public key is used to sign HLOS artifacts.
-[`ValidateVbmetaPublicKey()`](#ValidateVbmetaPublicKey).
-
-#### ReadIsDeviceUnlocked
-Gets whether the device is unlocked.
-[`ReadIsDeviceUnlocked()`](#ReadIsDeviceUnlocked).
-
-#### ReadRollbackIndex
-Gets the rollback index corresponding to the location given by `index_location`.
-[`ReadRollbackIndex()`](#ReadRollbackIndex).
-
-#### WriteRollbackIndex
-Sets the rollback index corresponding to the location given by `index_location` to `rollback_index`.
-[`WriteRollbackIndex()`](#WriteRollbackIndex).
-
-#### ReadPersistentValue
-Gets the persistent value for the corresponding `name`.
-[`ReadPersistentValue()`](#ReadPersistentValue).
-
-#### WritePersistentValue
-Sets or erases the persistent value for the corresponding `name`.
-[`WritePersistentValue()`](#WritePersistentValue).
-
-#### HandleVerificationResult
-Handle AVB verification result (i.e update ROT, set device state, display UI
-warnings/errors, handle anti-tampering, etc).
-[`HandleVerificationResult()`](#HandleVerificationResult).
-
-## GBL_EFI_AVB_PROTOCOL.ValidateVbmetaPublicKey() {#ValidateVbmetaPublicKey}
-
-### Summary
-
-Allows the firmware to check whether the public key used to sign the `vbmeta`
-partition is trusted by verifying it against the hardware-trusted key shipped
-with the device.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI *GBL_EFI_AVB_VALIDATE_VBMETA_PUBLIC_KEY) (
-  IN GBL_EFI_AVB_PROTOCOL *This,
-  IN CONST UINT8 *PublicKeyData,
-  IN UINTN PublicKeyLength,
-  IN CONST UINT8 *PublicKeyMetadata,
-  IN UINTN PublicKeyMetadataLength,
-  /* GBL_EFI_AVB_KEY_VALIDATION_STATUS */ OUT UINT32 *ValidationStatus);
-```
-
-### Parameters
-
-#### This
-A pointer to the `GBL_EFI_AVB_PROTOCOL` instance.
-
-#### PublicKeyData
-A pointer to the public key extracted from `vbmeta`. Guaranteed to contain valid
-data of length `PublicKeyLength`.
-
-#### PublicKeyLength
-Specifies the length of the public key provided by `PublicKeyData`.
-
-#### PublicKeyMetadata
-A pointer to public key metadata generated using the `avbtool` `--public_key_metadata`
-flag. May be `NULL` if no public key metadata is provided.
-
-#### PublicKeyMetadataLength
-Specifies the length of the public key metadata provided by `PublicKeyMetadata`.
-Guaranteed to be 0 in case of `NULL` `PublicKeyMetadata`.
-
-#### ValidationStatus
-An output parameter that communicates the verification status to the GBL. `VALID`
-and `VALID_CUSTOM_KEY` are interpreted as successful validation statuses.
-
-### Related Definition
-
-```c
-// Vbmeta key validation status.
-//
-// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
-typedef enum {
-  VALID,
-  VALID_CUSTOM_KEY,
-  INVALID,
-} GBL_EFI_AVB_KEY_VALIDATION_STATUS;
-```
-
-### Description
-
-`ValidateVbmetaPublicKey` must set `ValidationStatus` and return `EFI_SUCCESS`.
-Any non `EFI_SUCCESS` return value from this method is treated as a fatal verification
-error, so `red` state is reported and GBL fails to boot even if device is unlocked.
-
-**`ValidationStatus` and GBL boot flow**:
-
-* `VALID`: The public key is valid and trusted, so the device can continue the boot
-  process for both locked and unlocked states.
-
-* `VALID_CUSTOM_KEY`: The public key is valid but not fully trusted. GBL continues
-  booting a locked device with a `yellow` state and an unlocked device with an `orange` state.
-
-* `INVALID`: The public key is not valid. The device cannot continue the boot process
-  for locked devices; GBL reports a `red` status and resets. Unlocked devices can still
-  boot with an `orange` state.
-
-GBL calls this function once per AVB verification session.
-
-## GBL_EFI_AVB_PROTOCOL.ReadIsDeviceUnlocked() {#ReadIsDeviceUnlocked}
-
-### Summary
-
-Allows the firmware to provide the device's locking state to the GBL in a
-firmware-specific way.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI *GBL_EFI_AVB_READ_IS_DEVICE_UNLOCKED) (
-  IN GBL_EFI_AVB_PROTOCOL *This,
-  OUT BOOLEAN *IsUnlocked);
-```
-
-### Parameters
-
-#### This
-A pointer to the `GBL_EFI_AVB_PROTOCOL` instance.
-
-#### IsUnlocked
-An output parameter that communicates the device locking state to the GBL.
-
-### Description
-
-An unlocked device state allows GBL not to force AVB and to boot the device with
-an `orange` boot state. GBL rejects continuing the boot process if this method
-returns any error. GBL may call this method multiple times per boot session.
-
-## Status Codes Returned
-
-The following EFI error types are used to communicate result to GBL and libavb in particular:
-
-|                                |                                                                                                                                                         |
-| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| `EFI_SUCCESS`                  | Requested operation was successful `libavb::AvbIOResult::AVB_IO_RESULT_OK`                                                                              |
-| `EFI_STATUS_OUT_OF_RESOURCES`  | Unable to allocate memory `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_OOM`                                                                                |
-| `EFI_STATUS_DEVICE_ERROR`      | Underlying hardware (disk or other subsystem) encountered an I/O error `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_IO`                                    |
-| `EFI_STATUS_NOT_FOUND`         | Named persistent value does not exist `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_NO_SUCH_VALUE`                                                          |
-| `EFI_STATUS_END_OF_FILE`       | Range of bytes requested to be read or written is outside the range of the partition `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION` |
-| `EFI_STATUS_INVALID_PARAMETER` | Named persistent value size is not supported or does not match the expected size `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_INVALID_VALUE_SIZE`          |
-| `EFI_STATUS_BUFFER_TOO_SMALL`  | Buffer is too small for the requested operation `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_INSUFFICIENT_SPACE`                                           |
-| `EFI_STATUS_UNSUPPORTED`       | Operation isn't implemented / supported                                                                                                                 |
-
-TODO(b/337846185): Provide docs for all methods.
\ No newline at end of file
diff --git a/gbl/docs/gbl_efi_fastboot_protocol.md b/gbl/docs/gbl_efi_fastboot_protocol.md
deleted file mode 100644
index 02af175..0000000
--- a/gbl/docs/gbl_efi_fastboot_protocol.md
+++ /dev/null
@@ -1,651 +0,0 @@
-# GBL EFI Fastboot Protocol
-
-This document describes the GBL Fastboot protocol. The protocol defines
-interfaces that can be used by EFI applications to query and modify vendor-specific
-information on a device that may be desired in the context of a fastboot environment.
-
-|             |                    |
-|:------------|-------------------:|
-| **Status**  | *Work in progress* |
-| **Created** |          2024-9-11 |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL`
-
-### Summary
-
-This protocol provides interfaces for platform-specific operations during Fastboot.
-This can include support for vendor defined variables or variables whose query
-requires cooperation with vendor firmware, OEM commands,
-
-### GUID
-```c
-// {c67e48a0-5eb8-4127-be89-df2ed93d8a9a}
-#define GBL_EFI_FASTBOOT_PROTOCOL_GUID               \
-  {                                                  \
-    0xc67e48a0, 0x5eb8, 0x4127, {                    \
-      0xbe, 0x89, 0xdf, 0x2e, 0xd9, 0x3d, 0x8a, 0x9a \
-    }                                                \
-  }
-```
-
-### Revision Number
-
-```c
-#define GBL_EFI_FASTBOOT_PROTOCOL_REVISION 0x00000000
-```
-
-### Protocol Interface Structure
-
-```c
-#define GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8 32
-
-typedef struct _GBL_EFI_FASTBOOT_PROTOCOL {
-  UINT32                                        Revision
-  CHAR8                                         SerialNumber[GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8];
-  GBL_EFI_FASTBOOT_GET_VAR                      GetVar;
-  GBL_EFI_FASTBOOT_GET_VAR_ALL                  GetVarAll;
-  GBL_EFI_FASTBOOT_RUN_OEM_FUNCTION             RunOemFunction;
-  GBL_EFI_FASTBOOT_GET_POLICY                   GetPolicy;
-  GBL_EFI_FASTBOOT_SET_LOCK                     SetLock;
-  GBL_EFI_FASTBOOT_CLEAR_LOCK                   ClearLock;
-  GBL_EFI_FASTBOOT_GET_PARTITION_PERMISSIONS    GetPartitionPermissions;
-  GBL_EFI_FASTBOOT_WIPE_USER_DATA               WipeUserData;
-  GBL_EFI_FASTBOOT_SHOULD_STOP_IN_FASTBOOT      ShouldStopInFastboot;
-} GBL_EFI_FASTBOOT_PROTOCOL;
-```
-
-### Parameters
-
-**Revision**
-
-The revision to which the `GBL_EFI_FASTBOOT_PROTOCOL` adheres.
-All future revisions must be backwards compatible.
-If a future version is not backwards compatible, a different GUID must be used.
-
-**SerialNumber**
-
-The device serial number expressed as a Null-terminated UTF-8 encoded string.
-If the device serial number is 32 bytes long, the Null terminator must be excluded.
-If the device serial number is longer than 32 bytes, it must be truncated.
-
-**GetVar**
-
-Gets the value for the given fastboot variable.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`](#gbl_efi_fastboot_protocolgetvar).
-
-**GetVarAll**
-
-Iterates all combinations of arguments and values for all fastboot variables.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.GetVarAll()`](#gbl_efi_fastboot_protocolgetvarall).
-
-**RunOemFunction**
-
-Runs an OEM-defined command on the device.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.RunOemFunction()`](#gbl_efi_fastboot_protocolrunoemfunction).
-
-**GetPolicy**
-
-Querys device policy including device lock state, whether the device firmware
-supports a 'critical' lock, and whether the device is capable of booting from
-an image loaded directly into RAM.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.GetPolicy()`](#gbl_efi_fastboot_protocolgetpolicy).
-
-**SetLock**
-
-Enables device locks according to the provided ORed lock definitions.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.SetLock()`](#gbl_efi_fastboot_protocolsetlock).
-
-**ClearLock**
-
-Removes devices locks according to the provided ORed lock definitions.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.ClearLock()`](#gbl_efi_fastboot_protocolclearlock).
-
-**GetPartitionPermissions**
-
-Queries permissions information about the provided partition.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.GetPartitionPermissions()`](#gbl_efi_fastboot_protocolgetpartitionpermissions).
-
-**WipeUserData**
-
-Erases all partitions containing user data.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.WipeUserData()`](#gbl_efi_fastboot_protocolwipeuserdata).
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`
-
-### Summary
-
-Gets the value for a fastboot variable.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_GET_VAR)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL*         This,
-    IN CONST CHAR8* CONST*                Args,
-    IN UINTN                              NumArgs,
-    OUT CHAR8*                            Buf,
-    IN OUT UINTN*                         BufSize,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure)
-instance.
-
-*Args*
-
-A pointer to an array of NULL-terminated strings that contains the name of the
-variable followed by additional arguments.
-
-*NumArgs*
-
-The number of elements in the *Args* array.
-
-*Buf*
-
-A pointer to the data buffer to store the value of the variable as a UTF-8
-encoded string.
-
-*BufSize*
-
-On entry, the size in bytes of *Buf*.
-On exit, the size in bytes of the UTF-8 encoded string describing the value,
-excluding any Null-terminator.
-
-### Description
-
-`GetVar()` queries internal data structures and drivers to determine the value
-of the given variable. Variables may have zero or more additional arguments.
-These arguments are parsed by the caller and passed to `GetVar()` as an array
-of NULL-terminated UTF-8 encoded string.
-
-An example client interaction:
-```bash
-# A variable with no argument.
-$ fastboot getvar max-download-size
-OKAY0x20000000
-
-# A variable with two arguments.
-$ fastboot getvar block-device:0:total-blocks
-OKAY0x800000000000
-```
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                                                                                |
-|:------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The variable was found and its value successfully serialized.                                                                                                            |
-| `EFI_INVALID_PARAMETER` | One of *This*, *Args*, *Buf*, or *BufSize* is `NULL`                                                                                                                     |
-| `EFI_NOT_FOUND`         | The first element of *Args* does not contain a known variable.                                                                                                           |
-| `EFI_UNSUPPORTED`       | The contents of *Args* do not contain a known variable with valid aruments. Any of the subarguments may be unknown, or too many or too few subarguments may be provided. |
-| `EFI_BUFFER_TOO_SMALL`  | *Buf* is too small to store the serialized variable string. The value of *BufSize* is modified to contain the minimum necessary buffer size.                             |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.GetVarAll()`
-
-### Summary
-
-Iterates all combinations of variables and values.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_GET_VAR_ALL)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL*         This,
-    IN VOID*                              Context
-    IN GBL_EFI_GET_VAR_ALL_CALLBACK       GetVarAllCallback,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure)
-instance.
-
-*Context*
-
-A pointer to the context data for `GetVarAllCallback`.
-
-*GetVarAllCallback*
-
-A pointer to a function of type `GBL_EFI_GET_VAR_ALL_CALLBACK`. It receives as
-parameter the `Context` pointer passed to this function, an array of
-NULL-terminated UTF8 strings containing variable name and additional arguments,
-the array length, and a NULL-terminated string representing the value.
-
-### Related Definitions
-
-```c
-typedef
-VOID (*GBL_EFI_GET_VAR_ALL_CALLBACK) (
-    IN VOID*                              Context
-    IN CONST CHAR8* CONST*                Args,
-    IN UINTN                              NumArgs,
-    IN CONST CHAR8*                       Value,
-);
-```
-*Context*
-
-The pointer to the context passed to `GetVarAll()`.
-
-*Args*
-
-A pointer to an array of NULL-terminated strings that contains the name of the
-variable followed by additional arguments.
-
-*NumArgs*
-
-The number of elements in the *Args* array.
-
-*Value*
-
-A NULL-terminated string representing the value.
-
-### Description
-
-`GetVarAll()` iterates all combinations of arguments and values for all fastboot
-variables. For each combination, the function invokes the caller provided
-callback `GetVarAllCallback()` and passes the context, arguments and value.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                       |
-|:------------------------|:------------------------------------------------|
-| `EFI_SUCCESS`           | Operation is successful.                        |
-| `EFI_INVALID_PARAMETER` | One of *This* or *GetVarAllCallback* is `NULL`. |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.RunOemFunction()`
-
-### Summary
-
-Runs a vendor defined function that requires firmware support.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_RUN_OEM_FUNCTION)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-    IN CHAR8*                     Command,
-    IN UINTN                      CommandLen,
-    OUT CHAR8*                    Buf,
-    IN OUT UINTN*                 BufSize,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-*Command*
-
-The command to run as a Null-terminated UTF-8 encoded string.
-
-*CommandLen*
-
-The length of the command in bytes, excluding any Null-terminator.
-
-*Buf*
-
-A pointer to the data buffer to store any output the command generates
-as a UTF-8 encoded, Null-terminated string.
-On success, this output will be sent to the connected client as an INFO message.
-On failure, this output will be sent to the connected client as a FAIL message.
-
-**Note:** GBL is the only expected caller for any method of
-`GBL_EFI_FASTBOOT_PROTOCOL`, including `RunOemFunction()`.
-For a non-zero `BufSize`, GBL and all other callers are required to set the
-first byte of `Buf` to `0`. GBL and all other callers are responsible for
-parsing `Buf` until the first Null-terminator or for `Buf + BufSize` bytes,
-whichever occurs first.
-
-*BufSize*
-
-On entry, the size in bytes of `Buf`.
-On exit, the size in bytes of the UTF-8 encoded string describing the value,
-excluding any Null-terminator.
-
-### Description
-
-`RunOemFunction()` runs a vendor defined Oem function. These functions can take
-arbitrary arguments or subcommands. The caller does no parsing or verification.
-All parsing and verification is the responsibility of the method
-implementation. Oem functions can display power or battery information, print
-or iterate over UEFI variables, or conduct arbitrary other operations.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                                                                                                                       |
-|:------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                                                                                                |
-| `EFI_INVALID_PARAMETER` | One of *This*, *Command*, *CommandLen*, *Buf*, or *BufSize* is `NULL` or improperly aligned.                                                                                    |
-| `EFI_BUFFER_TOO_SMALL`  | The provided buffer is too small to store the serialized representation of the command output. The value of `BufSize` is modified to contain the minimum necessary buffer size. |
-| `EFI_UNSUPPORTED`       | The command is not supported or is nonsensical.                                                                                                                                 |
-| `EFI_ACCESS_DENIED`     | The operation is not permitted in the current lock state.                                                                                                                       |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.GetPolicy()`
-
-### Summary
-
-Gets the device policy pertaining to locking and booting directly from RAM.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_GET_POLICY)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-    OUT GBL_EFI_FASTBOOT_POLICY*  Policy,
-);
-```
-
-### Related Definitions
-
-```c
-typedef struct _GBL_EFI_FASTBOOT_POLICY {
-  // Indicates whether device can be unlocked.
-  BOOL CanUnlock;
-  // Device firmware supports 'critical' partition locking.
-  BOOL HasCriticalLock;
-  // Indicates whether device allows booting
-  // from images loaded directly from RAM.
-  BOOL CanRamBoot;
-} GBL_EFI_FASTBOOT_POLICY;
-
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-*Policy*
-
-On exit contains the device policy.
-See [Related Definitions](#related-definitions-2) for the definition of `GBL_EFI_FASTBOOT_POLICY`.
-
-### Description
-
-Depending on various factors including whether the device
-is a development target or end-user device,
-certain operations may be prohibited.
-In particular, loading an image directly into RAM and then booting it
-is generally not permitted on anything except development hardware.
-Developer workflows and CI/CD infrastructure need to be able to query
-whether a device is able to be unlocked and whether RAM booting is permitted.
-
-See [`SetLock()`](#gbl_efi_fastboot_protocolsetlock) and [`ClearLock()`](#gbl_efi_fastboot_protocolclearlock)
-for methods that modify the device lock state. Querying lock state is handled by Android Verified Boot.
-
-### Status Codes
-
-| Return Code             | Semantics                                                  |
-|:------------------------|:-----------------------------------------------------------|
-| `EFI_SUCCESS`           | The device policy was successfuly retrieved.               |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Policy* is `NULL` or improperly aligned. |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.SetLock()`
-
-### Summary
-
-Sets device partition locks.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_SET_LOCK)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-    IN UINT64                     LockState,
-);
-```
-
-### Related Definitions
-
-```c
-typedef enum _GBL_EFI_FASTBOOT_LOCK_FLAGS {
-  // All device partitions are locked.
-  GBL_EFI_FASTBOOT_GBL_EFI_LOCKED = 0x1 << 0,
-  // All 'critical' device partitions are locked.
-  // The 'critical' lock is optional,
-  // and which partitions are locked by the critical lock
-  // is a vendor implementation detail.
-  GBL_EFI_FASTBOOT_GBL_EFI_CRITICAL_LOCKED = 0x1 << 1,
-} GBL_EFI_FASTBOOT_LOCK_FLAGS;
-
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-*LockState*
-
-The ORed value of all device partition locks to enable.
-When locked, partitions generally cannot be read, written, or erased via fastboot.
-See [Related Definitions](#related-definitions-3) for valid lock flags.
-
-### Description
-
-Device lock state determines what operations can be performed on device partitions.
-`SetLock()` enables the locks defined in *LockState*, some of which may already be set.
-No locks are cleared by any call to `SetLock()`.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                          |
-|:------------------------|:---------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                   |
-| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.            |
-| `EFI_INVALID_PARAMETER` | The lock flags in *LockState* are invalid.         |
-| `EFI_ACCESS_DENIED`     | Device policy prohibited the change in lock state. |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.ClearLock()`
-
-### Summary
-
-Clears device partition locks.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_CLEAR_LOCK)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-    IN UINT64                     LockState,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-*LockState*
-
-The ORed value of all device partition locks to disable.
-See the [Related Definitions](#related-definitions-3) for `SetLock()` for valid lock flags.
-
-### Description
-
-Device lock state determines what operations can be performed on device partitions.
-`ClearLock()` disables the locks defined in *LockState*, some of which may already be cleared.
-
-### Status Codes Returned
-
-| Return Code             | Semantics                                          |
-|:------------------------|:---------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                   |
-| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.            |
-| `EFI_INVALID_PARAMETER` | The lock flags in *LockState* are invalid.         |
-| `EFI_ACCESS_DENIED`     | Device policy prohibited the change in lock state. |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.GetPartitionPermissions()`
-
-### Summary
-
-Gets access permission information about the given partition.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_GET_PARTITION_PERMISSIONS)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-    IN CHAR8*                     PartName,
-    IN UINTN                      PartNameLen,
-    OUT UINT64                    Permissions,
-);
-```
-
-### Related Definitions
-
-```c
-typedef enum _GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS {
-  // Firmware can read the given partition and send its data to fastboot client.
-  GBL_EFI_FASTBOOT_PARTITION_READ = 0x1 << 0,
-  // Firmware can overwrite the given partition.
-  GBL_EFI_FASTBOOT_PARTITION_WRITE = 0x1 << 1,
-  // Firmware can erase the given partition.
-  GBL_EFI_FASTBOOT_PARTITION_ERASE = 0x1 << 2,
-} GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS;
-
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-*PartName*
-
-The name of the partition to query as a UTF-8 encoded, Null-terminated string.
-
-*PartNameLen*
-
-The length of *PartName* in bytes, excluding any Null-terminator.
-
-*Permissions*
-
-On exit contains the ORed flags detailing the current fastboot permissions for
-the given partition.
-See [Related Definitions](#related-definitions-4) for flag value semantics.
-
-### Description
-
-Depending on device lock state, Android Verified Boot policy, and other factors,
-various partitions may have restricted permissions within a fastboot environment.
-`GetPartitionPermissions()` retrieves the current permissions
-for the requested partition.
-
-By default, unless overridden by device policy, no operations are permitted on
-any partition when the device is locked, and all operations are permitted
-on all partitions when the device is unlocked.
-
-### Status Codes
-
-| Return Code             | Semantics                                                                          |
-|:------------------------|:-----------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The partition permision information was successfully queried.                      |
-| `EFI_INVALID_PARAMETER` | One of *This*, *PartName*, or *Permissions* is `NULL` or improperly aligned.       |
-| `EFI_NOT_FOUND`         | There is no partition named *PartName*.                                            |
-| `EFI_UNSUPPORTED`       | The device does not have a partition permission policy different from the default. |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.WipeUserData()`
-
-### Summary
-
-Erases all partitions containing user data.
-
-### Prototype
-
-```c
-typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_WIPE_USER_DATA)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-### Description
-
-Device user data is often stored on a dedicated partition
-apart from kernel images or other system data.
-This helps protect user data during system upgrades.
-`WipeUserData()` erases all user data partitions.
-This can be used to restore a device to its factory settings,
-as part of a refurbishment process, or for testing purposes.
-
-### Status Codes
-
-| Return Code             | Semantics                                                 |
-|:------------------------|:----------------------------------------------------------|
-| `EFI_SUCCESS`           | User data was successfully wiped.                         |
-| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.                   |
-| `EFI_ACCESS_DENIED`     | The operation is not permitted in the current lock state. |
-| `EFI_DEVICE_ERROR`      | There was a block device or storage error.                |
-
-## `GBL_EFI_FASTBOOT_PROTOCOL.ShouldStopInFastboot()`
-
-### Summary
-
-Checks custom inputs to determine whether the device should stop in fastboot on boot.
-
-### Prototype
-
-```c
-typedef
-BOOL
-(EFIAPI * GBL_EFI_FASTBOOT_SHOULD_STOP_IN_FASTBOOT)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
-);
-```
-
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-### Description
-
-Devices often define custom mechanisms for determining whether to enter fastboot mode
-on boot. A specific button press combination is common,
-e.g. pressing 'volume down' for three seconds while booting.
-
-`ShouldStopInFastboot()` returns whether the device should stop in fastboot mode
-due to device input.
-
-**Note:** `ShouldStopInFastboot()` should ONLY return `true` if the device specific
-button press is active. In particular, if the device supports
-[`GBL_EFI_AB_SLOT_PROTOCOL`](./gbl_efi_ab_slot_protocol.md),
-`ShouldStopInFastboot()` should NOT check the information provided by
-`GBL_EFI_AB_SLOT_PROTOCOL.GetBootReason()` or the underlying persistent boot reason.
-
-Any errors should cause a return value of `false`.
diff --git a/gbl/docs/gbl_fastboot.md b/gbl/docs/gbl_fastboot.md
deleted file mode 100644
index cfe4924..0000000
--- a/gbl/docs/gbl_fastboot.md
+++ /dev/null
@@ -1,176 +0,0 @@
-# Fastboot in GBL
-
-This document describes Fastboot in the [GBL UEFI bootloader](../efi/BUILD).
-
-## Transport
-
-The GBL UEFI bootloader supports both Fastboot over TCP and USB. To enable
-Fastboot over TCP, the UEFI loader needs to implement the
-`EFI_SIMPLE_NETWORK_PROTOCOL` protocol. To enable Fastboot over USB, the
-[GBL_EFI_FASTBOOT_USB_PROTOCOL](./GBL_EFI_FASTBOOT_USB_PROTOCOL.md) protocol is
-needed. GBL automatically establishes the corresponding transport channel if
-the needed protocol is available.
-
-## The Partition Argument
-
-Fastboot commands such as `fastboot flash`, `fastboot fetch` and
-`fastboot getvar partition-size` operate on partitions and requires a partition
-name argument. See this [doc](./partitions.md) for how GBL defines and handles
-partitions on storage devices. GBL fastboot additionaly supports accessing sub
-ranges of partitions and disambiguating betweeen same name partitions on
-multiple storage devices (i.e. in the presence of external or removable boot
-storage). The following summarizes the supported syntaxes for partition name
-argument in fastboot.
-
-* Partition
-  ```sh
-  <part>[/<storage_id>]
-  <part>/[<storage_id>][/<offset>]
-  <part>/[<storage_id>]/[<offset>][/<size>]
-  ```
-
-  This specifies range `[offset, offset+size)` in partition `part` on the
-  storage device with ID `storage_id`. `storage_id` is a hex string and
-  represents a unique integer ID assigned to each storage device detected
-  by GBL. The integer ID is for disambiguation purpose in case multiple storage
-  devices have same name partitions.  If `storage_id` is not given, GBL will
-  check if a default storage ID is set via
-  `fastboot oem gbl-set-default-block <storage_id>` and use the default ID if
-  set. If the default ID is not set, GBL will check that `part` can match to a
-  unique parition. Otherwise, it will be rejected. The default ID can be unset
-  via `fastboot oem gbl-unset-default-block`. `offset` and `size` must be a
-  64bit integer hex string. `offset` defaults to 0 if not given. `size`
-  defaults to the rest of the partition after `offset` if not given.
-
-  Examples:
-  * `fastboot flash boot_a` -- If there is only one storage or a default
-    storage ID is set via `fastboot oem gbl-set-default-block <default ID>`,
-    flashes in the entire range of the storage. If not, checks that `boot_a`
-    can match to a unique partition among all storage devices and flashes to
-    it.
-  * `fastboot flash boot_a/0x0` or `boot_a/0` -- Flashes in the entire range of
-    partition "boot_a" on storage device 0.
-  * `fastboot flash boot_a/0/200` -- Flashes only in range `[512, end)` of
-    partition "boot_a" on storage device 0.
-  * `fastboot flash boot_a/0/200/200` -- Flashes only in range `[512, 1024)` of
-    partition "boot_a" on storage device 0.
-  * `fastboot flash boot_a///` -- Same as `"fastboot flash boot_a"`.
-  * `fastboot flash boot_a//200/200` -- Same as `"fastboot flash boot_a///"`,
-    except that it only flashes in range `[512, 1024)`
-
-* Raw storage devices by ID
-  ```
-  /[<storage_id>]
-  /[<storage_id>][/<offset>]
-  /[<storage_id>][/<offset>][/<size>]
-  ```
-
-  This is similar to the case of partition except that `part` is an empty
-  string. It specifies range`[offset, offset+size)` of the raw data on the
-  storage device with ID `storage_id`.  If `storage_id` is not given, GBL will
-  check if a default storage ID is set via
-  `fastboot oem gbl-set-default-block <storage_id>` and use the default ID if
-  set. Otherwise it is rejected. `offset` defaults to 0 if not given. `size`
-  defaults to the rest of the block after `offset` if not given. This semantic
-  applies to all storage devcies that can detected by GBL, whether or not it is
-  a raw storage partition or GPT device.
-
-  Examples:
-  * `fastboot flash /` -- If there is only one storage or a default storage ID
-    is set via `fastboot oem gbl-set-default-block <default ID>`, flashes in
-    the entire range of the storage.
-  * `fastboot flash /0x0` or `/0` -- Flashes in the entire range of storage
-    device 0.
-  * `fastboot flash /0/200` -- Flashes only in range `[512, end)` of storage
-    device 0.
-  * `fastboot flash /0/200/200` -- Flashes only in range `[512, 1024)` of
-    storage device 0.
-  * `fastboot flash ///` -- Same as `"fastboot flash /"`.
-  * `fastboot flash //200/200` -- Same as `"fastboot flash ///"`, except that
-    it only flashes in range `[512, 1024)`
-
-Note: AOSP fastboot client tool introduces a special flash command syntax
-`fastboot flash vendor_boot_a:<part_size>` for performing vendor ramdisk
-repacking and flashing. This however, does not work with GBL's `'/'` syntax
-discussed above, i.e. `fastboot flash vendor_boot_a/0:<part_size>` will not
-trigger the repack and flash flow for the vendor_boot_a partition on storage 0
-as might be expected. Instead, in this case, user should run
-`fastboot oem gbl-set-default-block 0` to set the default block to 0 first and
-then use `fastboot flash vendor_boot_a:<part size>` normally.
-
-### Updating GPT Partition Table
-
-GBL supports the following syntaxes for updating GPT partition table on a
-storage device:
-
-```
-fastboot flash gpt <path to MBR+primary GPT blob file>
-fastboot flash gpt/<storage_id> <path to MBR+primary GPT blob file>
-fastboot flash gpt/[<storage_id>][/resize] <path to MBR+primary GPT blob file>
-```
-
-User must provide an image file that contains a MBR block and the primary GPT
-header and entries. The above command will verify the given GPT and update it
-to the specified storage device. If the `resize` option is given, GBL will
-adjust the ending block of the last partition entry to cover the rest of the
-storage. This is useful for sharing one single GPT blob file for different
-devices with varying size of storage.
-
-Examples:
-  * `fastboot flash gpt` -- If there is only one storage or a default storage
-    ID is set via `fastboot oem gbl-set-default-block <default ID>`, updates
-    the GPT of that storage.
-  * `fastboot flash gpt//resize` -- Same as `fastboot flash gpt` but also
-    performs resizing.
-  * `fastboot flash gpt/0` -- Update GPT to storage device 0.
-  * `fastboot flash gpt/0/resize` -- Same as `fastboot flash gpt/0` but also
-    performs resizing.
-
-To erase existing GPT partition table on a storage device, use:
-
-```
-fastboot erase gpt
-fastboot erase gpt/<storage_id>
-```
-
-Note: The above only erases GPT partition table. Partition content remains
-unchanged.
-
-Examples:
-  * `fastboot erase gpt` -- If there is only one storage or a default storage
-    ID is set via `fastboot oem gbl-set-default-block <default ID>`, erase
-    the GPT of that storage.
-  * `fastboot flash gpt/0` -- Erase GPT to storage device 0.
-
-## Non-blocking `fastboot flash`.
-
-If the UEFI firmware supports `EFI_BLOCK_IO2_PROTOCOL` for the storage devices,
-GBL Fastboot provides an option to make `fastboot flash` non-blocking.
-Specifically, after the image is downloaded, GBL Fastboot will launch a
-separate task in the background for writing the image to the device, while
-itself will continue to listen for the next Fastboot command from the host,
-including a new `fastboot flash` command. This provides some paralellism
-between downloading and flashing when the host is flashing multiple images.
-Example:
-
-```
-fastboot oem gbl-enable-async-task
-fastboot flash boot_a <image>
-fastboot flash boot_b <image>
-fastboot flash vendor_boot_a <image>
-...
-fastboot oem gbl-sync-blocks
-fastboot oem gbl-disable-async-task
-```
-
-If a storage device is busy processing a previous flash when a new image is
-downloaded and ready to be flashed, it will be blocked until the previous flash
-is completed. Different storage devices are independent to each other.
-
-Because IO is now non-blocking, the return status of a `fastboot flash` does
-not necessarily represents the status of the IO. If a storage device encounters
-errors while processing a non-blocking IO, all subsequent flash requests will
-be rejected and the host should reboot the device.
-`fastboot oem gbl-sync-blocks` can be used to wait until all currently pending
-flash are completed. The command returns error if any previous or current flash
-encounters errors.
diff --git a/gbl/docs/gbl_os_configuration_protocol.md b/gbl/docs/gbl_os_configuration_protocol.md
deleted file mode 100644
index 1eafde4..0000000
--- a/gbl/docs/gbl_os_configuration_protocol.md
+++ /dev/null
@@ -1,322 +0,0 @@
-# GBL OS Configuration EFI Protocol
-
-This document defines an EFI protocol for GBL which allows the device to
-apply runtime fixups to data passed into the OS.
-
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL
-
-### Summary
-
-This protocol provides a mechanism for the EFI firmware to build and update OS
-configuration data:
-
-* device tree (select components to build the final one)
-* kernel commandline (append fixups)
-* bootconfig (append fixups)
-
-GBL will load and verify the base data from disk, and then call these protocol
-functions to give the firmware a chance to construct and adjust the data as needed
-for the particular device. Device tree fixup is handled by `EFI_DT_FIXUP` protocol.
-
-If no runtime modifications are necessary, this protocol may be left
-unimplemented.
-
-### GUID
-
-```c
-// {dda0d135-aa5b-42ff-85ac-e3ad6efb4619}
-#define GBL_EFI_OS_CONFIGURATION_PROTOCOL_GUID       \
-  {                                                  \
-    0xdda0d135, 0xaa5b, 0x42ff, {                    \
-      0x85, 0xac, 0xe3, 0xad, 0x6e, 0xfb, 0x46, 0x19 \
-    }                                                \
-  }
-```
-
-### Revision Number
-
-Note: revision 0 means the protocol is not yet stable and may change in
-backwards-incompatible ways.
-
-```c
-#define GBL_EFI_OS_CONFIGURATION_PROTOCOL_REVISION 0x00000000
-```
-
-### Protocol Interface Structure
-
-```c
-typedef struct _GBL_EFI_OS_CONFIGURATION_PROTOCOL {
-  UINT64                            Revision;
-  GBL_EFI_FIXUP_KERNEL_COMMAND_LINE FixupKernelCommandline;
-  GBL_EFI_FIXUP_BOOTCONFIG          FixupBootConfig;
-  GBL_EFI_SELECT_DEVICE_TREES       SelectDeviceTrees;
-  GBL_EFI_FIXUP_ZBI                 FixupZbi;
-} GBL_EFI_OS_CONFIGURATION_PROTOCOL;
-```
-
-### Parameters
-
-#### Revision
-The revision to which the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` adheres. All
-future revisions must be backwards compatible. If a future version is not
-backwards compatible, a different GUID must be used.
-
-#### FixupKernelCommandline
-Applies kernel commandline fixups. See
-[`FixupKernelCommandline()`](#FixupKernelCommandline).
-
-#### FixupBootConfig
-Applies bootconfig fixups. See [`FixupBootConfig()`](#FixupBootConfig).
-
-#### SelectDeviceTrees
-Select components such as base device tree, overlays to build the final device tree.
-See [`SelectDeviceTrees()`](#SelectDeviceTrees).
-
-#### FixupZbi
-Applies ZBI fixups (Fuchsia kernels only). See [`FixupZbi()`](#FixupZbi).
-
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupKernelCommandline() {#FixupKernelCommandline}
-
-### Summary
-
-Provides runtime fixups to the kernel command line.
-
-### Prototype
-
-```c
-typedef EFI_STATUS (EFIAPI *GBL_EFI_FIXUP_KERNEL_COMMAND_LINE)(
-  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL *This,
-  IN CONST CHAR8                       *CommandLine,
-  OUT CHAR8                            *Fixup,
-  IN OUT UINTN                         *FixupBufferSize
-  );
-```
-
-### Parameters
-
-Ownership of all the parameters is loaned only for the duration of the function call, and
-must not be retained by the protocol after returning.
-
-#### This
-A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
-
-#### CommandLine [in]
-A pointer to the ASCII nul-terminated command line built by GBL.
-
-#### Fixup [out]
-Pointer to a pre-allocated buffer to store the generated command line fixup.
-GBL verifies and appends provided data into the final command line. FW may
-leave this unchanged if no fixup is required.
-
-The FW implementation can generate a fixup with the following restrictions:
-* on return, the data must be valid ASCII encoding with nul termination
-* the data and termination byte must never exceed the provided `FixupBufferSize`
-* no libavb arguments may be provided (see Security below)
-
-#### FixupBufferSize [in, out]
-On function call, this points to the fixup buffer size provided by `Fixup`. The
-implementation is free to provide fixup data up to this size, including the
-termination byte.
-
-If the buffer is not large enough to fit the fixups, the function should update
-`FixupBufferSize` with the required size and return `EFI_BUFFER_TOO_SMALL`;
-GBL will then allocate a larger buffer, discard all modifications and repeat
-the `FixupKernelCommandline` call.
-
-`FixupBufferSize` does not need to be updated on success, GBL will determine the
-fixup command line data size via the nul terminator.
-
-### Description
-
-GBL will call this function after loading and verifying the base kernel command
-line, to give the device an opportunity to supply some of the runtime fixups.
-
-Since the device tree selection affects the base kernel command line, GBL will
-call `SelectDeviceTrees` first before calling `FixupKernelCommandline`.
-
-#### Security
-
-To ensure the integrity of verified boot data, this protocol will not be
-allowed to append any command line parameters provided by
-[libavb](https://source.android.com/docs/security/features/verifiedboot/avb).
-If any of these parameters are provided, GBL will treat this as a failed boot
-attempt:
-* `androidboot.veritymode*`
-* `androidboot.vbmeta*`
-* `dm`
-* `root`
-
-Additionally, all data used to apply fixups to the command line must be trusted.
-In particular, if the protocol loads any data from non-secure storage, it should
-verify that data before use.
-
-#### Status Codes Returned
-
-|                         |                                                                                     |
-| ----------------------- | ----------------------------------------------------------------------------------- |
-| `EFI_SUCCESS`           | Command line fixup provided.                                                        |
-| `EFI_INVALID_PARAMETER` | A parameter is invalid.                                                             |
-| `EFI_BUFFER_TOO_SMALL`  | The buffer is too small; `FixupBufferSize` has been updated with the required size. |
-| `EFI_DEVICE_ERROR`      | Internal error while providing the command line fixup.                              |
-
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupBootConfig() {#FixupBootConfig}
-
-### Summary
-
-Provides runtime fixups to the bootconfig.
-
-### Prototype
-
-```c
-typedef EFI_STATUS (EFIAPI *GBL_EFI_FIXUP_BOOTCONFIG)(
-  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL *This,
-  IN CONST CHAR8                       *BootConfig,
-  IN UINTN                             BootConfigSize,
-  OUT CHAR8                            *Fixup,
-  IN OUT UINTN                         *FixupBufferSize
-  );
-```
-
-### Parameters
-
-Ownership of all the parameters is loaned only for the duration of the function call, and
-must not be retained by the protocol after returning.
-
-#### This
-A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
-
-#### BootConfig [in]
-Pointer to the bootconfig built by GBL. Trailing data isn't provided.
-
-#### BootConfigSize [in]
-Size of the bootconfig built by GBL.
-
-#### Fixup [out]
-Pointer to a pre-allocated buffer to store the generated bootconfig fixup.
-GBL verifies and appends provided data into the final bootconfig. FW may
-leave this unchanged if no fixup is required. `FixupBufferSize` must be
-updated to `0` in this case.
-
-The FW implementation can generate a fixup with the following restrictions:
-* on return, the data must be valid bootconfig (trailer is optional)
-* the data must never exceed the provided `FixupBufferSize`
-* no libavb arguments may be provided (see Security below)
-
-#### FixupBufferSize [in, out]
-On function call, this points to the fixup buffer size provided by `Fixup`. The
-implementation is free to provide fixup data up to this size.
-
-If the buffer is not large enough to fit the fixups, the function should update
-`FixupBufferSize` with the required size and return `EFI_BUFFER_TOO_SMALL`;
-GBL will then allocate a larger buffer, discard all modifications and repeat
-the `FixupBootConfig` call.
-
-`FixupBufferSize` must be updated on success to let GBL determine the bootconfig fixup size.
-
-### Description
-
-[Bootconfig](https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig)
-is very similar to the kernel command line, but the format is slightly
-different, and the contents are intended for user space consumption rather than
-kernel.
-
-This protocol only needs to provide the bootconfig parameters, GBL will automatically update
-the bootconfig trailer metadata afterwards.
-
-#### Security
-
-This function's security guidelines are exactly identical to
-[`FixupKernelCommandline`](#FixupKernelCommandline); see those docs for details.
-
-#### Status Codes Returned
-
-This function's status return codes are exactly identical to
-[`FixupKernelCommandline`](#FixupKernelCommandline); see those docs for details.
-
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL.SelectDeviceTrees() {#SelectDeviceTrees}
-
-### Summary
-
-Inspects device trees and overlays loaded by GBL to determine which ones to use.
-
-### Prototype
-
-```c
-typedef enum {
-  BOOT,
-  VENDOR_BOOT,
-  DTBO,
-  DTB
-} GBL_EFI_DEVICE_TREE_SOURCE;
-
-typedef struct {
-  // GBL_EFI_DEVICE_TREE_SOURCE
-  UINT32 Source;
-  // values are zeroed and must not be used in case of BOOT / VENDOR_BOOT source
-  UINT32 Id;
-  UINT32 Rev;
-  UINT32 Custom[4];
-  // make sure GblDeviceTreeMetadata size is 8-bytes aligned. Also reserved for
-  // the future cases
-  UINT32 Reserved;
-} GBL_EFI_DEVICE_TREE_METADATA;
-
-typedef struct {
-  GBL_EFI_DEVICE_TREE_METADATA Metadata;
-  // base device tree / overlay buffer (guaranteed to be 8-bytes aligned),
-  // cannot be NULL. Device tree size can be identified by the header totalsize field.
-  CONST VOID *DeviceTree;
-  // Indicates whether this device tree (or overlay) must be included in the
-  // final device tree. Set to true by a FW if this component must be used
-  BOOLEAN Selected;
-} GBL_EFI_VERIFIED_DEVICE_TREE;
-
-typedef EFI_STATUS (EFIAPI *GBL_EFI_SELECT_DEVICE_TREES)(
-  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL *This,
-  IN OUT GBL_EFI_VERIFIED_DEVICE_TREE  *DeviceTrees,
-  IN UINTN                             NumDeviceTrees
-  );
-```
-
-### Parameters
-
-Ownership of all the parameters is loaned only for the duration of the function call, and
-must not be retained by the protocol after returning.
-
-#### This
-A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
-
-#### DeviceTrees [in, out]
-
-Pointer to an array of base device trees and overlays for selection. Base device trees and
-overlays are differentiated by the `GBL_EFI_DEVICE_TREE_METADATA.Source` field (`BOOT`,
-`VENDOR_BOOT`, `DTB` for base device trees, and `DTBO` for overlays).
-
-Selection is made by setting `GBL_EFI_VERIFIED_DEVICE_TREE.Selected` to `TRUE`. Selecting
-multiple or zero base device trees will cause GBL to fail to boot. Selecting multiple or
-zero overlays are supported.
-
-#### NumDeviceTrees [in]
-
-The number of base device trees and overlays in the `DeviceTrees` array.
-
-### Description
-
-Android build artifacts provide multiple base device trees and overlays from the `boot`,
-`vendor_boot`, `dtb`, and `dtbo` partitions. These artifacts are reused across multiple SoCs,
-so the firmware typically selects a base device tree and overlays to construct the final tree.
-This method enables selection based on the loaded content.
-
-Only one base device tree and multiple overlays (no overlays is also allowed) can be selected.
-If more than one or no base device trees are selected, GBL will fail to boot.
-
-### Status Codes Returned
-
-|                         |                                                                         |
-| ----------------------- | ----------------------------------------------------------------------- |
-| `EFI_SUCCESS`           | Base device tree, overlays has been selected.                           |
-| `EFI_INVALID_PARAMETER` | A parameter is invalid. For example, incorrect device trees, alignment. |
-
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupZbi() {#FixupZbi}
-
-TODO(b/353272981)
diff --git a/gbl/docs/partitions.md b/gbl/docs/partitions.md
deleted file mode 100644
index fea722b..0000000
--- a/gbl/docs/partitions.md
+++ /dev/null
@@ -1,55 +0,0 @@
-# Partitions in GBL
-
-This document describes how GBL defines and handles partitions on mass storage
-devices.
-
-## Definition of Partition
-
-In GBL, all EFI devices that implement either the `EFI_BLOCK_IO_PROTOCOL` or
-`EFI_BLOCK_IO2_PROTOCOL` protocols are considered storage devices that may
-contain necessary data for GBL to access. For each of this device, GBL supports
-two schemes of partition:
-
-1. Entire raw storage as a partition.
-
-   This scheme treats the entire storage device as a single partition. For
-   storage devices intended to be used according to this scheme, the device
-   need to provide an instance of device path that ends with the GBL
-   "Vendor-Defined Media Device Path" defined as follows.
-
-   | Mnemonic | Bytes Offset | Bytes Length | Description |
-   | ----------- | ----------- | ----------- | ----------- |
-   | Type | 0 | 1 | Type 4-Media Device Path. |
-   | Sub-Type | 1 | 1 | Sub-Type 3 - Vendor. |
-   | Length | 2 | 2 | Length of this structure in bytes. Length is 92 bytes. |
-   | Vendor GUID | 4 | 16 | The `GBL_VENDOR_MEDIA_DEVICE_PATH_GUID` GUID defined below. |
-   | Vendor Defined Data | 20 | 72 | Null-terminated ASCII partition name. |
-
-   ```c
-   // {a09773e3-0xf027-0x4f33-adb3-bd8dcf4b3854}
-   #define GBL_VENDOR_MEDIA_DEVICE_PATH_GUID           \
-     {                                                  \
-       0xa09773e3, 0xf027, 0x4f33, {                    \
-         0xad, 0xb3, 0xbd, 0x8d, 0xcf, 0x4b, 0x38, 0x54 \
-       }                                                \
-     }
-   ```
-
-   The partition will be identified using the null-terminated ASCII name from
-   the device path in the context of booting and fastboot.
-
-
-2. UEFI GUID Partition Table (GPT)
-
-   For all other storage devices that doesn't have an instance of GBL
-   vendor-defined media device path, GBL considers them to be using the GPT
-   partition scheme defined in the UEFI spec. Each partition will be identified
-   using its corresponding GPT partition name in the context of booting and
-   fastboot.
-
-GBL fastboot implementation introduces a special syntax
-`<part>/<storage id>/<offset>/<size>` for specifying arbitrary subranges of a
-partition on one of the potentially multiple storage devices. Thus the
-partition name cannot contain character `'/'`. The name `gpt` is reserved for
-flashing GPT partition table and thus should not be used as partition name.
-See this [doc](./gbl_fastboot.md) for more details.
diff --git a/gbl/docs/resources/ab-bl-ab-android-flow.png b/gbl/docs/resources/ab-bl-ab-android-flow.png
deleted file mode 100644
index f69b0b6..0000000
Binary files a/gbl/docs/resources/ab-bl-ab-android-flow.png and /dev/null differ
diff --git a/gbl/docs/resources/ab-bl-ab-android.png b/gbl/docs/resources/ab-bl-ab-android.png
deleted file mode 100644
index e6aebd5..0000000
Binary files a/gbl/docs/resources/ab-bl-ab-android.png and /dev/null differ
diff --git a/gbl/docs/resources/slotless-bl-ab-android-flow.png b/gbl/docs/resources/slotless-bl-ab-android-flow.png
deleted file mode 100644
index f49d16d..0000000
Binary files a/gbl/docs/resources/slotless-bl-ab-android-flow.png and /dev/null differ
diff --git a/gbl/docs/resources/slotless-bl-ab-android.png b/gbl/docs/resources/slotless-bl-ab-android.png
deleted file mode 100644
index c150122..0000000
Binary files a/gbl/docs/resources/slotless-bl-ab-android.png and /dev/null differ
diff --git a/gbl/efi/BUILD b/gbl/efi/BUILD
deleted file mode 100644
index 64f9a04..0000000
--- a/gbl/efi/BUILD
+++ /dev/null
@@ -1,170 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_toolchain.bzl", "build_with_platform")
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@gbl_llvm_prebuilts//:info.bzl", "gbl_llvm_tool_path")
-load("@rules_rust//rust:defs.bzl", "rust_binary", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libgbl_efi",
-    srcs = glob(["src/**/*.rs"]),
-    crate_name = "gbl_efi",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@arrayvec",
-        "@avb",
-        "@gbl//libasync",
-        "@gbl//libasync:cyclic_executor",
-        "@gbl//libboot",
-        "@gbl//libefi",
-        "@gbl//libefi_types",
-        "@gbl//liberror",
-        "@gbl//libfastboot",
-        "@gbl//libfdt",
-        "@gbl//libgbl",
-        "@gbl//libsafemath",
-        "@gbl//libstorage",
-        "@smoltcp",
-        "@spin",
-        "@uuid",
-        "@zbi",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "test",
-    crate = ":libgbl_efi",
-    data = [
-        "@gbl//libfdt/test/data:all",
-    ],
-    # TODO(b/355436086): mock out the rest of the libefi APIs and
-    # remove dead-code; for now it would require a lot of invasive
-    # code changes to selectively disable things on tests so this
-    # is worth it to keep things more readable.
-    rustc_flags = ANDROID_RUST_LINTS + [
-        "-A",
-        "dead-code",
-    ],
-    deps = [
-        "@gbl//libefi:mocks",
-        "@mockall",
-    ],
-)
-
-# The UEFI application target.
-#
-# Almost all logic should be in the libgbl_efi target; this contains only the
-# things that would prevent unittesting such as global allocation hooks or
-# target-specific compiler dependencies.
-rust_binary(
-    name = "app",
-    srcs = glob(["app/**/*.rs"]),
-    linker_script = select(
-        {
-            "@gbl//toolchain:gbl_rust_elf_riscv64": "@gbl//efi/arch/riscv64:riscv64_efi.lds",
-            "//conditions:default": None,
-        },
-    ),
-    rustc_flags = ANDROID_RUST_LINTS + [
-        "-C",
-        "panic=abort",
-    ],
-    deps = [
-        ":libgbl_efi",
-        "@avb//:avb_crypto_ops_sha_impl_staticlib",
-        "@gbl//libavb:sysdeps",
-        "@gbl//libefi",
-        "@gbl//libefi_types",
-    ] + select(
-        {
-            "@gbl//toolchain:gbl_rust_elf_riscv64": [
-                "@gbl//efi/arch/riscv64:efi_arch_deps_riscv64",
-            ],
-            "//conditions:default": [],
-        },
-    ),
-)
-
-genrule(
-    name = "gbl_efi",
-    srcs = [":app"],
-    outs = ["gbl.efi"],
-    cmd = select(
-        {
-            # For RISCV target, existing toolchain can only generate ELF format image.
-            # The current solution is to manually add a PE/COFF header at image
-            # start and use objcopy to remove the ELF header to make it a PE/COFF image.
-            # Also use `elf_static_relocation_checker` to check that our relocation library
-            # can handle all the generated relocation types. The following expands to two commands:
-            #
-            # 1. `llvm-objcopy <elf image> -O binary <efi image>`
-            # 2. `elf_static_relocation_checker <elf image> <efi image>`
-            "@gbl//toolchain:gbl_rust_elf_riscv64": """
-            {} -O binary $(location @gbl//efi:app) $(OUTS) && \\
-            $(location @gbl//libelf:elf_static_relocation_checker) $(SRCS) $(OUTS)
-        """.format(
-                gbl_llvm_tool_path("llvm-objcopy"),
-            ),
-            "//conditions:default": "cp $(SRCS) $(OUTS)",
-        },
-    ),
-    tools = select(
-        {
-            "@gbl//toolchain:gbl_rust_elf_riscv64": [
-                "@gbl//libelf:elf_static_relocation_checker",
-            ],
-            "//conditions:default": [],
-        },
-    ),
-)
-
-build_with_platform(
-    name = "x86_64",
-    platform = "@gbl//toolchain:gbl_uefi_x86_64",
-    deps = [":gbl_efi"],
-)
-
-build_with_platform(
-    name = "x86_32",
-    platform = "@gbl//toolchain:gbl_uefi_x86_32",
-    deps = [":gbl_efi"],
-)
-
-build_with_platform(
-    name = "aarch64",
-    platform = "@gbl//toolchain:gbl_uefi_aarch64",
-    deps = [":gbl_efi"],
-)
-
-build_with_platform(
-    name = "riscv64",
-    platform = "@gbl//toolchain:gbl_elf_riscv64",
-    deps = [":gbl_efi"],
-)
-
-filegroup(
-    name = "all_platforms",
-    srcs = [
-        ":aarch64",
-        ":riscv64",
-        ":x86_32",
-        ":x86_64",
-    ],
-)
diff --git a/gbl/efi/app/main.rs b/gbl/efi/app/main.rs
deleted file mode 100644
index e607f5f..0000000
--- a/gbl/efi/app/main.rs
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! The GBL UEFI application.
-//!
-//! This just contains the minimal entry point and global hook declarations
-//! needed for a full application build; all the logic should go in the
-//! `gbl_efi` library instead.
-
-#![no_std]
-#![no_main]
-
-#[cfg(target_arch = "riscv64")]
-mod riscv64;
-
-use core::{ffi::c_void, panic::PanicInfo};
-use efi::{initialize, panic, EfiAllocator};
-use efi_types::EfiSystemTable;
-use gbl_efi::app_main;
-
-#[panic_handler]
-fn handle_panic(p_info: &PanicInfo) -> ! {
-    panic(p_info)
-}
-
-#[no_mangle]
-#[global_allocator]
-static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::new();
-
-/// Pull in the sysdeps required by libavb so the linker can find them.
-extern crate avb_sysdeps;
-
-/// EFI application entry point. Does not return.
-///
-/// # Safety
-/// `image_handle` and `systab_ptr` must be valid objects that adhere to the UEFI specification.
-#[no_mangle]
-pub unsafe extern "C" fn efi_main(image_handle: *mut c_void, systab_ptr: *mut EfiSystemTable) {
-    // SAFETY:
-    // * caller provides valid `image_handle` and `systab_ptr` objects
-    // * we only call `initialize()` once
-    let entry = unsafe { initialize(image_handle, systab_ptr) }.unwrap();
-    app_main(entry).unwrap();
-    loop {}
-}
diff --git a/gbl/efi/app/riscv64.rs b/gbl/efi/app/riscv64.rs
deleted file mode 100644
index 5077235..0000000
--- a/gbl/efi/app/riscv64.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// The compiler looks for this function. It is normally provided by libstd.
-// But for baremetal we don't use std and implementation doesn't matter
-// anyway. We put a empty place holder here to get compilation pass.
-#[no_mangle]
-pub extern "C" fn rust_eh_personality() {}
-
-// Provide a few dependencies such as memcpy, memset not provided by RISC-V toolchain
-// in the GBL setting
-#[link(name = "efi_arch_deps_riscv64", kind = "static")]
-extern "C" {
-    // Pointer to the EFI header.
-    static dos_header: *const core::ffi::c_void;
-}
-
-// LLVM doesn't yet have native PE/COFF support for RISC-V target. Thus we have to
-// manually add the PE/COFF header to the binary via arch/riscv64/riscv64_efi_header.S.
-// Since the source is compiled as a static library, we need to have a public rust
-// function that refers to some symbol from it so that the linker doesn't discard it
-// from the binary.
-#[no_mangle]
-pub extern "C" fn get_efi_header() -> *const core::ffi::c_void {
-    unsafe { dos_header }
-}
-
-// The function is related to stack unwinding and called by liballoc. However we don't expect
-// exception handling in UEFI application. If it ever reaches here, panics.
-#[no_mangle]
-pub extern "C" fn _Unwind_Resume(_: *mut core::ffi::c_void) {
-    panic!();
-}
diff --git a/gbl/efi/arch/riscv64/BUILD b/gbl/efi/arch/riscv64/BUILD
deleted file mode 100644
index fde113c..0000000
--- a/gbl/efi/arch/riscv64/BUILD
+++ /dev/null
@@ -1,25 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-cc_library(
-    name = "efi_arch_deps_riscv64",
-    srcs = [
-        "deps.cpp",
-        "riscv64_efi_header.S",
-    ],
-    visibility = ["//visibility:public"],
-    deps = ["@gbl//libelf:relocation"],
-)
-
-exports_files(["riscv64_efi.lds"])
diff --git a/gbl/efi/arch/riscv64/deps.cpp b/gbl/efi/arch/riscv64/deps.cpp
deleted file mode 100644
index 23b3317..0000000
--- a/gbl/efi/arch/riscv64/deps.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdint.h>
-
-#include "elf/relocation.h"
-
-extern "C" {
-
-void ApplyRelocationHangIfFail(uintptr_t program_base, uintptr_t dynamic_section) {
-  if (!ApplyRelocation(program_base, dynamic_section)) {
-    while (true) {
-    };
-  }
-}
-
-}
diff --git a/gbl/efi/arch/riscv64/riscv64_efi.lds b/gbl/efi/arch/riscv64/riscv64_efi.lds
deleted file mode 100644
index fa4db49..0000000
--- a/gbl/efi/arch/riscv64/riscv64_efi.lds
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-OUTPUT_FORMAT("elf64-littleriscv", "elf64-littleriscv", "elf64-littleriscv")
-OUTPUT_ARCH(riscv)
-SECTIONS
-{
-  .efi_header 0x0 : {
-    /* This is our PE/COFF header. Always keep it. */
-    KEEP(*(.efi_header))
-  }
-
-  .text : {
-    *(.text)
-    *(.text.*)
-    . = ALIGN(8);
-  }
-
-  .interp : { *(.interp) }
-
-  /* Dynamic sections which may involve in relocation */
-  .data.rel.ro : { *(.data.rel.ro*) }
-  .dynamic  : { *(.dynamic*) }
-  .got : { *(.got*) }
-  .dynsym  : { *(.dynsym) }
-  .dynstr  : { *(.dynstr) }
-  .gnu.hash  : { *(.gnu.hash) }
-
-  .eh_frame_hdr : { *(.eh_frame_hdr) }
-  .eh_frame : { *(.eh_frame) }
-
-  . = ALIGN(4096);
-  .data : {
-    *(.rodata*)
-    *(.data*)
-    *(.sdata)
-
-    /*
-    Tranditionally bss section are stuffed into .data section becase
-    some PE32+ loader doesn't support a separate bss section.
-    */
-    . = ALIGN(16);
-    *(.sbss)
-    *(.scommon)
-    *(.dynbss)
-    *(.bss)
-    *(.bss.*)
-    *(COMMON)
-  }
-
-  . = ALIGN(4096);
-  .note.gnu.build-id : { *(.note.gnu.build-id) }
-
-  /DISCARD/ : {
-    *(.debug*)
-    *(.comment)
-  }
-
-  _end = .;
-}
diff --git a/gbl/efi/arch/riscv64/riscv64_efi_header.S b/gbl/efi/arch/riscv64/riscv64_efi_header.S
deleted file mode 100644
index bdb7880..0000000
--- a/gbl/efi/arch/riscv64/riscv64_efi_header.S
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Refer to https://llvm.org/doxygen/Object_2COFF_8h_source.html and Microsoft Portable Executable
-// and Common Object File Format Specification for more detail.
-
-// See https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types
-#define IMAGE_FILE_MACHINE_RISCV64 0x5064
-
-// See https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics
-#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002
-
-// See https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-image-only
-#define PE32_PLUS_HEADER_MAGIC 0x020b
-
-// See https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#windows-subsystem
-#define IMAGE_SUBSYSTEM_EFI_APPLICATION 10
-
-.macro DATA_DIRECTORY name
-\name\()_data_directory:
-  .long 0  // support::ulittle32_t RelativeVirtualAddress;
-  .long 0  // support::ulittle32_t Size;
-.endm
-
-.section .efi_header,"a"
-.global dos_header
-
-// MS-DOS Stub
-dos_header:
-  .short 0x5a4d    // Magic 'MZ'
-  .short 0         // support::ulittle16_t UsedBytesInTheLastPage;
-  .short 0         // support::ulittle16_t FileSizeInPages;
-  .short 0         // support::ulittle16_t NumberOfRelocationItems;
-  .short 0         // support::ulittle16_t HeaderSizeInParagraphs;
-  .short 0         // support::ulittle16_t MinimumExtraParagraphs;
-  .short 0         // support::ulittle16_t MaximumExtraParagraphs;
-  .short 0         // support::ulittle16_t InitialRelativeSS;
-  .short 0         // support::ulittle16_t InitialSP;
-  .short 0         // support::ulittle16_t Checksum;
-  .short 0         // support::ulittle16_t InitialIP;
-  .short 0         // support::ulittle16_t InitialRelativeCS;
-  .short 0         // support::ulittle16_t AddressOfRelocationTable;
-  .short 0         // support::ulittle16_t OverlayNumber;
-  .skip 2*4        // support::ulittle16_t Reserved[4];
-  .short 0         // support::ulittle16_t OEMid;
-  .short 0         // support::ulittle16_t OEMinfo;
-  .skip 2*10       // support::ulittle16_t Reserved2[10];
-  // Even though we fixed `dos_header` at 0x00, we still need to subtract it to
-  // indicate this is relative offset. Otherwise linker complains about referencing
-  // an absolute address when linking with `-fPIE` (position independent executable)
-  .long signature - dos_header  // support::ulittle32_t AddressOfNewExeHeader;
-
-// Signature
-signature:
-  .long 0x00004550  // "PE\0\0"
-
-// COFF File Header
-coff_file_header:
-  .short IMAGE_FILE_MACHINE_RISCV64            // support::ulittle16_t Machine;
-   // ".reloc" and ".text"
-  .short 2                                     // support::ulittle16_t NumberOfSections;
-  .long 0                                      // support::ulittle32_t TimeDateStamp;
-  .long 0                                      // support::ulittle32_t PointerToSymbolTable;
-  .long 0                                      // support::ulittle32_t NumberOfSymbols;
-  .short section_table_start - pe32plus_header // support::ulittle16_t SizeOfOptionalHeader;
-  .short IMAGE_FILE_EXECUTABLE_IMAGE           // support::ulittle16_t Characteristics;
-
-// PE32+ Optional Header
-pe32plus_header:
-  .short PE32_PLUS_HEADER_MAGIC           // support::ulittle16_t Magic;
-  .byte 0                                 // uint8_t MajorLinkerVersion;
-  .byte 0                                 // uint8_t MinorLinkerVersion;
-  .long _end - dos_header                 // support::ulittle32_t SizeOfCode;
-  .long 0                                 // support::ulittle32_t SizeOfInitializedData;
-  .long 0                                 // support::ulittle32_t SizeOfUninitializedData;
-  .long _start - dos_header               // support::ulittle32_t AddressOfEntryPoint;
-  .long dos_header - dos_header           // support::ulittle32_t BaseOfCode;
-  .quad 0                                 // support::ulittle64_t ImageBase;
-  .long 512                               // support::ulittle32_t SectionAlignment;
-  .long 512                               // support::ulittle32_t FileAlignment;
-  .short 0                                // support::ulittle16_t MajorOperatingSystemVersion;
-  .short 0                                // support::ulittle16_t MinorOperatingSystemVersion;
-  .short 0                                // support::ulittle16_t MajorImageVersion;
-  .short 0                                // support::ulittle16_t MinorImageVersion;
-  .short 0                                // support::ulittle16_t MajorSubsystemVersion;
-  .short 0                                // support::ulittle16_t MinorSubsystemVersion;
-  .long 0                                 // support::ulittle32_t Win32VersionValue;
-  .long _end - dos_header                 // support::ulittle32_t SizeOfImage;
-  .long end_of_header - dos_header        // support::ulittle32_t SizeOfHeaders;
-  .long 0                                 // support::ulittle32_t CheckSum;
-  .short IMAGE_SUBSYSTEM_EFI_APPLICATION  // support::ulittle16_t Subsystem;
-  .short 0                                // support::ulittle16_t DLLCharacteristics;
-  .quad 0                                 // support::ulittle64_t SizeOfStackReserve;
-  .quad 0                                 // support::ulittle64_t SizeOfStackCommit;
-  .quad 0                                 // support::ulittle64_t SizeOfHeapReserve;
-  .quad 0                                 // support::ulittle64_t SizeOfHeapCommit;
-  .long 0                                 // support::ulittle32_t LoaderFlags;
-  // 16 data directories in total
-  .long 16                                // support::ulittle32_t NumberOfRvaAndSize;
-
-  // The following are data directories mostly for place holder purpose for now. Entries
-  // such as certification_table might be needed for secure boot in the future.
-  DATA_DIRECTORY export_table
-  DATA_DIRECTORY import_table
-  DATA_DIRECTORY resource_table
-  DATA_DIRECTORY exception_table
-  DATA_DIRECTORY certification_table
-  DATA_DIRECTORY base_relocation_table
-  DATA_DIRECTORY debug
-  DATA_DIRECTORY architecture_data
-  DATA_DIRECTORY global_ptr
-  DATA_DIRECTORY tls_table
-  DATA_DIRECTORY load_config_table
-  DATA_DIRECTORY bound_inport
-  DATA_DIRECTORY import_address_table
-  DATA_DIRECTORY delay_import_descriptor
-  DATA_DIRECTORY CLR_runtime_header
-  .quad 0
-
-// Section Table
-section_table_start:
-// .reloc. May be expected by some PE32+ loader
-reloc_section:
-  .ascii  ".reloc"
-  .byte 0
-  .byte 0           // 8 bytes of `char Name[COFF::NameSize];`
-  .long 0           // support::ulittle32_t VirtualSize;
-  .long 0           // support::ulittle32_t VirtualAddress;
-  .long 0           // support::ulittle32_t SizeOfRawData;
-  .long 0           // support::ulittle32_t PointerToRawData;
-  .long 0           // support::ulittle32_t PointerToRelocations;
-  .long 0           // support::ulittle32_t PointerToLinenumbers;
-  .short 0          // support::ulittle16_t NumberOfRelocations;
-  .short 0          // support::ulittle16_t NumberOfLinenumbers;
-  // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags
-  // We use the same value as Clang would generate with "-Wl,/subsystem:efi_application"
-  // IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE |
-  // IMAGE_SCN_MEM_READ
-  .long 0x42000040  // support::ulittle32_t Characteristics;
-
-// .text
-text_section:
-  .ascii  ".text"
-  .byte  0
-  .byte  0
-  .byte  0                          // 8 bytes of `char Name[COFF::NameSize];`
-  .long _end - end_of_header        // support::ulittle32_t VirtualSize;
-  .long end_of_header - dos_header  // support::ulittle32_t VirtualAddress;
-  .long _end - end_of_header        // support::ulittle32_t SizeOfRawData;
-  .long end_of_header - dos_header  // support::ulittle32_t PointerToRawData;
-  .long 0                           // support::ulittle32_t PointerToRelocations;
-  .long 0                           // support::ulittle32_t PointerToLinenumbers;
-  .short 0                          // support::ulittle16_t NumberOfRelocations;
-  .short 0                          // support::ulittle16_t NumberOfLinenumbers;
-  // IMAGE_SCN_CNT_CODE | IMAGE_SCN_CNT_INITIALIZED_DATA |
-  // IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
-  // We use the same value as Clang would generate with "-Wl,/subsystem:efi_application"
-  .long 0x60000020                  // support::ulittle32_t Characteristics;
-
-end_of_header:
-
-// Traditionally, PE/COFF header occupies the entire first page. We keep this pattern.
-.align 9
-
-_start:
-  // Behave like a function call.
-  addi sp, sp, -8*3
-  sd ra, 0(sp)
-  sd s0, 8(sp)
-  sd s1, 16(sp)
-
-  // Save the EFI image handle from a0
-  mv s0, a0
-  // Save the EFI system table from a1
-  mv s1, a1
-
-  // Get the program load address (same as dos_header), and .dynamic section address.
-  lla a0, dos_header
-  lla a1, _DYNAMIC
-  // Apply relocation fixup
-  call ApplyRelocationHangIfFail
-
-  // Now call efi_main.
-  mv a0, s0
-  mv a1, s1
-  call efi_main
-
-  // Prepare to return.
-  ld ra, 0(sp)
-  ld s0, 8(sp)
-  ld s1, 16(sp)
-  add sp, sp, 8*3
-  ret
diff --git a/gbl/efi/src/android_boot.rs b/gbl/efi/src/android_boot.rs
deleted file mode 100644
index 1f94325..0000000
--- a/gbl/efi/src/android_boot.rs
+++ /dev/null
@@ -1,151 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    fastboot::{with_fastboot_channels, VecPinFut},
-    ops::Ops,
-    utils::{get_platform_buffer_info, BufferInfo},
-};
-use alloc::{boxed::Box, vec::Vec};
-use core::{fmt::Write, str::from_utf8};
-use efi::{efi_print, efi_println, exit_boot_services, EfiEntry};
-use efi_types::{GBL_IMAGE_TYPE_FASTBOOT, GBL_IMAGE_TYPE_OS_LOAD};
-use gbl_async::poll;
-use libgbl::{android_boot::android_main, gbl_print, gbl_println, GblOps, Result};
-
-const SZ_MB: usize = 1024 * 1024;
-
-/// Android bootloader main entry (before booting).
-///
-/// On success, returns a tuple of slices (ramdisk, fdt, kernel, remains).
-pub fn efi_android_load(
-    ops: &mut Ops,
-) -> Result<(&'static mut [u8], &'static mut [u8], &'static mut [u8], &'static mut [u8])> {
-    let entry = ops.efi_entry;
-    // Prepares the OS load buffer.
-    let img_type_os_load = from_utf8(GBL_IMAGE_TYPE_OS_LOAD).unwrap();
-    let load_buffer = match get_platform_buffer_info(&entry, img_type_os_load, 256 * SZ_MB) {
-        BufferInfo::Static(v) => v,
-        BufferInfo::Alloc(sz) => {
-            let alloc = vec![0u8; sz];
-            gbl_println!(ops, "Allocated {:#x} bytes for OS load buffer.", alloc.len());
-            alloc.leak()
-        }
-    };
-
-    // Checks if we have a reserved buffer for fastboot
-    let img_type_fastboot = from_utf8(GBL_IMAGE_TYPE_FASTBOOT).unwrap();
-    let mut fastboot_buffer_info = None;
-
-    gbl_println!(ops, "Try booting as Android");
-
-    Ok(android_main(ops, load_buffer.as_mut(), |fb| {
-        // Note: `get_or_insert_with` lazily evaluates closure (only when insert is necessary).
-        let buffer = fastboot_buffer_info.get_or_insert_with(|| {
-            get_platform_buffer_info(&entry, img_type_fastboot, 512 * SZ_MB)
-        });
-        let mut alloc;
-        let buffer = match buffer {
-            BufferInfo::Static(v) => &mut v[..],
-            BufferInfo::Alloc(sz) => {
-                alloc = vec![0u8; *sz];
-                efi_println!(entry, "Allocated {:#x} bytes for fastboot buffer.", alloc.len());
-                &mut alloc
-            }
-        };
-        // TODO(b/383620444): Investigate letting GblOps return fastboot channels.
-        with_fastboot_channels(&entry, |local, usb, tcp| {
-            // We currently only consider 1 parallell flash + 1 parallel download.
-            // This can be made configurable if necessary.
-            const GBL_FB_N: usize = 2;
-            let mut bufs = Vec::from_iter(buffer.chunks_exact_mut(buffer.len() / GBL_FB_N));
-            let bufs = &(&mut bufs[..]).into();
-            let mut fut = Box::pin(fb.run(bufs, VecPinFut::default(), local, usb, tcp));
-            while poll(&mut fut).is_none() {}
-        })
-    })?)
-}
-
-/// Exits boot services and boots loaded android images.
-pub fn efi_android_boot(
-    entry: EfiEntry,
-    kernel: &[u8],
-    ramdisk: &[u8],
-    fdt: &[u8],
-    remains: &mut [u8],
-) -> Result<()> {
-    efi_println!(entry, "");
-    efi_println!(
-        entry,
-        "Booting kernel @ {:#x}, ramdisk @ {:#x}, fdt @ {:#x}",
-        kernel.as_ptr() as usize,
-        ramdisk.as_ptr() as usize,
-        fdt.as_ptr() as usize
-    );
-    efi_println!(entry, "");
-
-    #[cfg(target_arch = "aarch64")]
-    {
-        let _ = exit_boot_services(entry, remains)?;
-        // SAFETY: We currently targets at Cuttlefish emulator where images are provided valid.
-        unsafe { boot::aarch64::jump_linux_el2_or_lower(kernel, ramdisk, fdt) };
-    }
-
-    #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
-    {
-        use fdt::Fdt;
-        use liberror::Error;
-        use libgbl::android_boot::BOOTARGS_PROP;
-
-        let fdt = Fdt::new(&fdt[..])?;
-        let efi_mmap = exit_boot_services(entry, remains)?;
-        // SAFETY: We currently target at Cuttlefish emulator where images are provided valid.
-        unsafe {
-            boot::x86::boot_linux_bzimage(
-                kernel,
-                ramdisk,
-                fdt.get_property("chosen", BOOTARGS_PROP).unwrap(),
-                |e820_entries| {
-                    // Convert EFI memory type to e820 memory type.
-                    if efi_mmap.len() > e820_entries.len() {
-                        return Err(Error::MemoryMapCallbackError(-1));
-                    }
-                    for (idx, mem) in efi_mmap.into_iter().enumerate() {
-                        e820_entries[idx] = boot::x86::e820entry {
-                            addr: mem.physical_start,
-                            size: mem.number_of_pages * 4096,
-                            type_: crate::utils::efi_to_e820_mem_type(mem.memory_type),
-                        };
-                    }
-                    Ok(efi_mmap.len().try_into().unwrap())
-                },
-                0x9_0000,
-            )?;
-        }
-        unreachable!();
-    }
-
-    #[cfg(target_arch = "riscv64")]
-    {
-        let boot_hart_id = entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<efi::protocol::riscv::RiscvBootProtocol>()?
-            .get_boot_hartid()?;
-        efi_println!(entry, "riscv boot_hart_id: {}", boot_hart_id);
-        let _ = exit_boot_services(entry, remains)?;
-        // SAFETY: We currently target at Cuttlefish emulator where images are provided valid.
-        unsafe { boot::riscv64::jump_linux(kernel, boot_hart_id, fdt) };
-    }
-}
diff --git a/gbl/efi/src/efi_blocks.rs b/gbl/efi/src/efi_blocks.rs
deleted file mode 100644
index 4e2212f..0000000
--- a/gbl/efi/src/efi_blocks.rs
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use alloc::vec::Vec;
-use core::{cmp::max, fmt::Write};
-use efi::{
-    efi_print, efi_println,
-    protocol::{block_io::BlockIoProtocol, block_io2::BlockIo2Protocol, Protocol},
-    EfiEntry,
-};
-use efi_types::EfiBlockIoMedia;
-use gbl_async::block_on;
-use gbl_storage::{gpt_buffer_size, BlockInfo, BlockIo, Disk, Gpt, SliceMaybeUninit};
-use liberror::Error;
-use libgbl::partition::GblDisk;
-
-/// `EfiBlockDeviceIo` wraps a EFI `BlockIoProtocol` or `BlockIo2Protocol` and implements the
-/// `BlockIo` interface.
-pub enum EfiBlockDeviceIo<'a> {
-    Sync(Protocol<'a, BlockIoProtocol>),
-    Async(Protocol<'a, BlockIo2Protocol>),
-}
-
-impl<'a> EfiBlockDeviceIo<'a> {
-    fn media(&self) -> EfiBlockIoMedia {
-        match self {
-            EfiBlockDeviceIo::Sync(v) => v.media(),
-            EfiBlockDeviceIo::Async(v) => v.media(),
-        }
-        .unwrap()
-    }
-
-    fn info(&mut self) -> BlockInfo {
-        let media = self.media();
-        BlockInfo {
-            block_size: media.block_size as u64,
-            num_blocks: (media.last_block + 1) as u64,
-            alignment: max(1, media.io_align as u64),
-        }
-    }
-}
-
-// SAFETY:
-// `read_blocks()` usess EFI protocol that guarantees to read exact number of blocks that were
-// requested, or return error.
-// For async `read_blocks_ex()` blocking wait guarantees that read finishes.
-unsafe impl BlockIo for EfiBlockDeviceIo<'_> {
-    fn info(&mut self) -> BlockInfo {
-        (*self).info()
-    }
-
-    async fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<(), Error> {
-        match self {
-            EfiBlockDeviceIo::Sync(v) => v.read_blocks(blk_offset, out),
-            EfiBlockDeviceIo::Async(v) => v.read_blocks_ex(blk_offset, out).await,
-        }
-        .or(Err(Error::BlockIoError))
-    }
-
-    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), Error> {
-        match self {
-            EfiBlockDeviceIo::Sync(v) => v.write_blocks(blk_offset, data),
-            EfiBlockDeviceIo::Async(v) => v.write_blocks_ex(blk_offset, data).await,
-        }
-        .or(Err(Error::BlockIoError))
-    }
-}
-
-const MAX_GPT_ENTRIES: usize = 128;
-
-/// The [GblDisk] type in the GBL EFI context.
-pub type EfiGblDisk<'a> = GblDisk<Disk<EfiBlockDeviceIo<'a>, Vec<u8>>, Gpt<Vec<u8>>>;
-
-/// Finds and returns all EFI devices supporting either EFI_BLOCK_IO or EFI_BLOCK_IO2 protocol.
-pub fn find_block_devices(efi_entry: &EfiEntry) -> Result<Vec<EfiGblDisk<'_>>, Error> {
-    let bs = efi_entry.system_table().boot_services();
-    let block_dev_handles = bs.locate_handle_buffer_by_protocol::<BlockIoProtocol>()?;
-    let mut gbl_disks = vec![];
-    let gpt_buffer_size = gpt_buffer_size(MAX_GPT_ENTRIES)?;
-    for (idx, handle) in block_dev_handles.handles().iter().enumerate() {
-        // Prioritizes `BlockIo2Protocol`.
-        let blk_io = match bs.open_protocol::<BlockIo2Protocol>(*handle) {
-            Ok(v) => EfiBlockDeviceIo::Async(v),
-            _ => EfiBlockDeviceIo::Sync(bs.open_protocol::<BlockIoProtocol>(*handle)?),
-        };
-        if blk_io.media().logical_partition {
-            continue;
-        }
-        // TODO(b/357688291): Support raw partition based on device path info.
-        let disk = GblDisk::new_gpt(
-            Disk::new_alloc_scratch(blk_io).unwrap(),
-            Gpt::new(vec![0u8; gpt_buffer_size]).unwrap(),
-        );
-        match block_on(disk.sync_gpt()) {
-            Ok(Some(v)) => efi_println!(efi_entry, "Block #{idx} GPT sync result: {v}"),
-            Err(e) => efi_println!(efi_entry, "Block #{idx} error while syncing GPT: {e}"),
-            _ => {}
-        };
-        gbl_disks.push(disk);
-    }
-    Ok(gbl_disks)
-}
diff --git a/gbl/efi/src/error.rs b/gbl/efi/src/error.rs
deleted file mode 100644
index 38abde5..0000000
--- a/gbl/efi/src/error.rs
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use liberror::Error;
-use smoltcp::socket::tcp::{ListenError, RecvError, SendError};
-
-pub fn recv_to_unified(err: RecvError) -> Error {
-    match err {
-        RecvError::InvalidState => Error::InvalidState,
-        RecvError::Finished => Error::Finished,
-    }
-}
-
-pub fn send_to_unified(err: SendError) -> Error {
-    match err {
-        SendError::InvalidState => Error::InvalidState,
-    }
-}
-
-pub fn listen_to_unified(err: ListenError) -> Error {
-    match err {
-        ListenError::InvalidState => Error::InvalidState,
-        ListenError::Unaddressable => Error::Unaddressable,
-    }
-}
diff --git a/gbl/efi/src/fastboot.rs b/gbl/efi/src/fastboot.rs
deleted file mode 100644
index a777c7f..0000000
--- a/gbl/efi/src/fastboot.rs
+++ /dev/null
@@ -1,262 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// This EFI application implements a demo for booting Android/Fuchsia from disk. See
-// bootable/libbootloader/gbl/README.md for how to run the demo. See comments of
-// `android_boot:android_boot_demo()` and `fuchsia_boot:fuchsia_boot_demo()` for
-// supported/unsupported features at the moment.
-
-use crate::{
-    net::{EfiGblNetwork, EfiTcpSocket},
-    ops::Ops,
-};
-use alloc::{boxed::Box, vec::Vec};
-use core::{
-    cmp::min, fmt::Write, future::Future, mem::take, pin::Pin, sync::atomic::AtomicU64,
-    time::Duration,
-};
-use efi::{
-    efi_print, efi_println,
-    local_session::LocalFastbootSession,
-    protocol::{gbl_efi_fastboot_usb::GblFastbootUsbProtocol, Protocol},
-    EfiEntry,
-};
-use fastboot::{TcpStream, Transport};
-use gbl_async::{block_on, YieldCounter};
-use liberror::{Error, Result};
-use libgbl::fastboot::{
-    run_gbl_fastboot, GblFastbootResult, GblTcpStream, GblUsbTransport, PinFutContainer,
-};
-
-const DEFAULT_TIMEOUT: Duration = Duration::from_secs(5);
-const FASTBOOT_TCP_PORT: u16 = 5554;
-
-pub(crate) struct EfiFastbootTcpTransport<'a, 'b, 'c> {
-    socket: &'c mut EfiTcpSocket<'a, 'b>,
-}
-
-impl<'a, 'b, 'c> EfiFastbootTcpTransport<'a, 'b, 'c> {
-    fn new(socket: &'c mut EfiTcpSocket<'a, 'b>) -> Self {
-        Self { socket: socket }
-    }
-}
-
-impl TcpStream for EfiFastbootTcpTransport<'_, '_, '_> {
-    /// Reads to `out` for exactly `out.len()` number bytes from the TCP connection.
-    async fn read_exact(&mut self, out: &mut [u8]) -> Result<()> {
-        self.socket.receive_exact(out, DEFAULT_TIMEOUT).await
-    }
-
-    /// Sends exactly `data.len()` number bytes from `data` to the TCP connection.
-    async fn write_exact(&mut self, data: &[u8]) -> Result<()> {
-        self.socket.send_exact(data, DEFAULT_TIMEOUT).await
-    }
-}
-
-impl GblTcpStream for EfiFastbootTcpTransport<'_, '_, '_> {
-    fn accept_new(&mut self) -> bool {
-        let efi_entry = self.socket.efi_entry;
-        self.socket.poll();
-        // If not listenining, start listening.
-        // If not connected but it's been `DEFAULT_TIMEOUT`, restart listening in case the remote
-        // client disconnects in the middle of TCP handshake and leaves the socket in a half open
-        // state.
-        if !self.socket.is_listening_or_handshaking()
-            || (!self.socket.check_active()
-                && self.socket.time_since_last_listen() > DEFAULT_TIMEOUT)
-        {
-            let _ = self
-                .socket
-                .listen(FASTBOOT_TCP_PORT)
-                .inspect_err(|e| efi_println!(efi_entry, "TCP listen error: {:?}", e));
-
-            // TODO(b/368647237): Enable only in Fuchsia context.
-            self.socket.broadcast_fuchsia_fastboot_mdns();
-        } else if self.socket.check_active() {
-            self.socket.set_io_yield_threshold(1024 * 1024); // 1MB
-            let remote = self.socket.get_socket().remote_endpoint().unwrap();
-            efi_println!(efi_entry, "TCP connection from {}", remote);
-            return true;
-        }
-        false
-    }
-}
-
-/// `UsbTransport` implements the `fastboot::Transport` trait using USB interfaces from
-/// GBL_EFI_FASTBOOT_USB_PROTOCOL.
-pub struct UsbTransport<'a> {
-    max_packet_size: usize,
-    protocol: Protocol<'a, GblFastbootUsbProtocol>,
-    io_yield_counter: YieldCounter,
-    // Buffer for prefetching an incoming packet in `wait_for_packet()`.
-    // Alternatively we can also consider adding an EFI event for packet arrive. But UEFI firmware
-    // may be more complicated.
-    prefetched: (Vec<u8>, usize),
-}
-
-impl<'a> UsbTransport<'a> {
-    fn new(max_packet_size: usize, protocol: Protocol<'a, GblFastbootUsbProtocol>) -> Self {
-        Self {
-            max_packet_size,
-            protocol,
-            io_yield_counter: YieldCounter::new(1024 * 1024),
-            prefetched: (vec![0u8; max_packet_size], 0),
-        }
-    }
-
-    /// Polls and cache the next USB packet.
-    ///
-    /// Returns Ok(true) if there is a new packet. Ok(false) if there is no incoming packet. Err()
-    /// otherwise.
-    fn poll_next_packet(&mut self) -> Result<bool> {
-        match &mut self.prefetched {
-            (pkt, len) if *len == 0 => match self.protocol.fastboot_usb_receive(pkt) {
-                Ok(out_size) => {
-                    *len = out_size;
-                    return Ok(true);
-                }
-                Err(Error::NotReady) => return Ok(false),
-                Err(e) => return Err(e),
-            },
-            _ => Ok(true),
-        }
-    }
-}
-
-impl Transport for UsbTransport<'_> {
-    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
-        let len = match &mut self.prefetched {
-            (pkt, len) if *len > 0 => {
-                let out = out.get_mut(..*len).ok_or(Error::BufferTooSmall(Some(*len)))?;
-                let src = pkt.get(..*len).ok_or(Error::Other(Some("Invalid USB read size")))?;
-                out.clone_from_slice(src);
-                take(len)
-            }
-            _ => self.protocol.receive_packet(out).await?,
-        };
-        // Forces a yield to the executor if the data received/sent reaches a certain
-        // threshold. This is to prevent the async code from holding up the CPU for too long
-        // in case IO speed is high and the executor uses cooperative scheduling.
-        self.io_yield_counter.increment(len.try_into().unwrap()).await;
-        Ok(len)
-    }
-
-    async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
-        let mut curr = &packet[..];
-        while !curr.is_empty() {
-            let to_send = min(curr.len(), self.max_packet_size);
-            self.protocol.send_packet(&curr[..to_send], DEFAULT_TIMEOUT).await?;
-            // Forces a yield to the executor if the data received/sent reaches a certain
-            // threshold. This is to prevent the async code from holding up the CPU for too long
-            // in case IO speed is high and the executor uses cooperative scheduling.
-            self.io_yield_counter.increment(to_send.try_into().unwrap()).await;
-            curr = &curr[to_send..];
-        }
-        Ok(())
-    }
-}
-
-impl GblUsbTransport for UsbTransport<'_> {
-    fn has_packet(&mut self) -> bool {
-        let efi_entry = self.protocol.efi_entry();
-        self.poll_next_packet()
-            .inspect_err(|e| efi_println!(efi_entry, "Error while polling next packet: {:?}", e))
-            .unwrap_or(false)
-    }
-}
-
-/// Initializes the Fastboot USB interface and returns a `UsbTransport`.
-fn init_usb(efi_entry: &EfiEntry) -> Result<UsbTransport> {
-    let protocol =
-        efi_entry.system_table().boot_services().find_first_and_open::<GblFastbootUsbProtocol>()?;
-    match protocol.fastboot_usb_interface_stop() {
-        Err(e) if e != Error::NotStarted => Err(e),
-        _ => Ok(UsbTransport::new(protocol.fastboot_usb_interface_start()?, protocol)),
-    }
-}
-
-// Wrapper of vector of pinned futures.
-#[derive(Default)]
-pub(crate) struct VecPinFut<'a>(Vec<Pin<Box<dyn Future<Output = ()> + 'a>>>);
-
-impl<'a> PinFutContainer<'a> for VecPinFut<'a> {
-    fn add_with<F: Future<Output = ()> + 'a>(&mut self, f: impl FnOnce() -> F) {
-        self.0.push(Box::pin(f()));
-    }
-
-    fn for_each_remove_if(
-        &mut self,
-        mut cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
-    ) {
-        for idx in (0..self.0.len()).rev() {
-            cb(&mut self.0[idx].as_mut()).then(|| self.0.swap_remove(idx));
-        }
-    }
-}
-
-/// Initializes GBL EFI fastboot channels and runs a caller provided closure with them.
-pub(crate) fn with_fastboot_channels(
-    efi_entry: &EfiEntry,
-    f: impl FnOnce(Option<LocalFastbootSession>, Option<UsbTransport>, Option<EfiFastbootTcpTransport>),
-) {
-    let local_session = LocalFastbootSession::start(efi_entry, Duration::from_millis(1))
-        .inspect(|_| efi_println!(efi_entry, "Starting local bootmenu."))
-        .inspect_err(|e| efi_println!(efi_entry, "Failed to start local bootmenu: {:?}", e))
-        .ok();
-
-    let usb = init_usb(efi_entry)
-        .inspect(|_| efi_println!(efi_entry, "Started Fastboot over USB."))
-        .inspect_err(|e| efi_println!(efi_entry, "Failed to start Fastboot over USB. {:?}.", e))
-        .ok();
-
-    let ts = AtomicU64::new(0);
-    let mut net: EfiGblNetwork = Default::default();
-    let mut tcp = net
-        .init(efi_entry, &ts)
-        .inspect(|v| {
-            efi_println!(efi_entry, "Started Fastboot over TCP");
-            efi_println!(efi_entry, "IP address:");
-            v.interface().ip_addrs().iter().for_each(|v| {
-                efi_println!(efi_entry, "\t{}", v.address());
-            });
-        })
-        .inspect_err(|e| efi_println!(efi_entry, "Failed to start EFI network. {:?}.", e))
-        .ok();
-    let tcp = tcp.as_mut().map(|v| EfiFastbootTcpTransport::new(v));
-
-    f(local_session, usb, tcp)
-}
-
-pub fn fastboot(efi_gbl_ops: &mut Ops, bootimg_buf: &mut [u8]) -> Result<GblFastbootResult> {
-    let efi_entry = efi_gbl_ops.efi_entry;
-    efi_println!(efi_entry, "Entering fastboot mode...");
-
-    let mut res = Default::default();
-    with_fastboot_channels(efi_entry, |local, usb, tcp| {
-        let download_buffers = vec![vec![0u8; 512 * 1024 * 1024]; 2].into();
-        res = block_on(run_gbl_fastboot(
-            efi_gbl_ops,
-            &download_buffers,
-            VecPinFut::default(),
-            local,
-            usb,
-            tcp,
-            bootimg_buf,
-        ));
-    });
-
-    efi_println!(efi_entry, "Leaving fastboot mode...");
-
-    Ok(res)
-}
diff --git a/gbl/efi/src/fuchsia_boot.rs b/gbl/efi/src/fuchsia_boot.rs
deleted file mode 100644
index bf201b2..0000000
--- a/gbl/efi/src/fuchsia_boot.rs
+++ /dev/null
@@ -1,274 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::utils::efi_to_zbi_mem_range_type;
-#[allow(unused_imports)]
-use crate::{
-    efi_blocks::{find_block_devices, EfiGblDisk},
-    fastboot::fastboot,
-    ops::Ops,
-    utils::get_efi_mem_attr,
-};
-use efi::{EfiEntry, EfiMemoryAttributesTable, EfiMemoryMap};
-use efi_types::{
-    EfiMemoryAttributesTableHeader, EfiMemoryDescriptor, EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME,
-};
-use liberror::Error;
-use liberror::Error::BufferTooSmall;
-use libgbl::{
-    constants::PAGE_SIZE as PAGE_SIZE_USIZE,
-    fuchsia_boot::{zircon_check_enter_fastboot, zircon_load_verify_abr, zircon_part_name},
-    gbl_print, gbl_println,
-    ops::ImageBuffer,
-    partition::check_part_unique,
-    GblOps,
-    IntegrationError::UnificationError,
-    Result,
-};
-use safemath::SafeNum;
-use zbi::{zbi_format::zbi_mem_range_t, ZbiContainer, ZbiFlags, ZbiType};
-use zerocopy::{Ref, SplitByteSliceMut};
-
-const PAGE_SIZE: u64 = PAGE_SIZE_USIZE as u64;
-
-/// Check if the disk GPT layout is a Fuchsia device layout.
-pub fn is_fuchsia_gpt(disks: &[EfiGblDisk]) -> Result<()> {
-    let partitions: &[&[&str]] = &[
-        &["zircon_a", "zircon-a"],
-        &["zircon_b", "zircon-b"],
-        &["zircon_r", "zircon-r"],
-        &["vbmeta_a"],
-        &["vbmeta_b"],
-        &["vbmeta_r"],
-        &["misc", "durable_boot"],
-    ];
-    if !partitions
-        .iter()
-        .all(|&partition| partition.iter().any(|v| check_part_unique(&disks[..], *v).is_ok()))
-    {
-        return Err(Error::NotFound.into());
-    }
-
-    Ok(())
-}
-
-/// Loads and verifies Fuchsia according to A/B/R.
-///
-/// On success, returns the kernel and zbi_item buffer.
-pub fn efi_fuchsia_load(ops: &mut Ops) -> Result<(ImageBuffer<'static>, ImageBuffer<'static>)> {
-    gbl_println!(ops, "Try booting as Fuchsia/Zircon");
-    // Checks whether to enter fastboot mode.
-    if zircon_check_enter_fastboot(ops) {
-        fastboot(ops, &mut [])?;
-    }
-    let (zbi_items_buffer, kernel_buffer, slot) = zircon_load_verify_abr(ops)?;
-    gbl_println!(ops, "Booting from slot: {}", zircon_part_name(Some(slot)));
-    Ok((kernel_buffer, zbi_items_buffer))
-}
-
-/// Exits boot services and boots loaded fuchsia images.
-pub fn efi_fuchsia_boot(
-    _efi_entry: EfiEntry,
-    mut _kernel_buffer: ImageBuffer,
-    mut _zbi_items: ImageBuffer,
-) -> Result<()> {
-    let _zbi_items = _zbi_items.used_mut();
-    #[cfg(target_arch = "aarch64")]
-    {
-        // Uses the unused buffer for `exit_boot_services` to store output memory map.
-        // The map is not used for now. We currently rely on UEFI firmware to pass memory map via
-        // an raw zbi blob in device tree. Long term we want to support adding from EFI memory maps
-        // if none is provided.
-        let item_size = zbi::ZbiContainer::parse(&mut _zbi_items[..])?.container_size()?;
-        let (_, remains) = _zbi_items.split_at_mut(item_size);
-        let _ = efi::exit_boot_services(_efi_entry, remains).unwrap();
-        // SAFETY: The kernel has passed libavb verification or device is unlocked, in which case we
-        // assume the caller has addressed all safety and security concerns.
-        unsafe { boot::aarch64::jump_zircon_el2_or_lower(_kernel_buffer.used_mut(), _zbi_items) };
-    }
-
-    #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
-    {
-        const BUFFER_SIZE: usize = 32 * 1024 / 2;
-        let mut mem_map_buf = [0u8; BUFFER_SIZE];
-        let mut zbi_items = zbi::ZbiContainer::parse(&mut _zbi_items[..])?;
-        let efi_memory_attribute_table =
-            get_efi_mem_attr(&_efi_entry).ok_or(Error::InvalidInput)?;
-
-        // `exit_boot_service` returnes EFI memory map that is used to derive and append MEM_CONFIG
-        // items.
-        let efi_memory_map = efi::exit_boot_services(_efi_entry, &mut mem_map_buf).unwrap();
-
-        add_memory_items(&efi_memory_map, &efi_memory_attribute_table, &mut zbi_items)?;
-
-        // SAFETY: The kernel has passed libavb verification or device is unlocked, in which case we
-        // assume the caller has addressed all safety and security concerns.
-        unsafe { boot::x86::zbi_boot(_kernel_buffer.used_mut(), _zbi_items) };
-    }
-
-    #[cfg(target_arch = "riscv64")]
-    {
-        unimplemented!();
-    }
-}
-
-// This function must not use allocation
-#[allow(unused)]
-fn add_memory_items<B>(
-    efi_memory_map: &EfiMemoryMap,
-    efi_memory_attribute_table: &EfiMemoryAttributesTable,
-    zbi_items: &mut ZbiContainer<B>,
-) -> Result<()>
-where
-    B: SplitByteSliceMut + PartialEq,
-{
-    generate_efi_memory_attributes_table_item(
-        efi_memory_map,
-        efi_memory_attribute_table,
-        zbi_items,
-    )?;
-
-    generate_mem_config_item(efi_memory_map, zbi_items)?;
-
-    Ok(())
-}
-
-fn generate_efi_memory_attributes_table_item<'b, B>(
-    efi_memory_map: &EfiMemoryMap<'b>,
-    efi_memory_attribute_table: &EfiMemoryAttributesTable,
-    zbi_items: &mut ZbiContainer<B>,
-) -> Result<()>
-where
-    B: SplitByteSliceMut + PartialEq,
-{
-    let payload = zbi_items.get_next_payload()?;
-    let provided_payload_size = payload.len();
-    let (mut header, mut tail) =
-        Ref::<&mut [u8], EfiMemoryAttributesTableHeader>::new_from_prefix(payload)
-            .ok_or(Error::BadBufferSize)?;
-
-    for efi_memory_desc in efi_memory_map.into_iter() {
-        if efi_memory_desc.attributes & EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME == 0 {
-            continue;
-        }
-
-        let mut base = efi_memory_desc.physical_start;
-        let mut size: u64 = (SafeNum::from(efi_memory_desc.number_of_pages) * PAGE_SIZE)
-            .try_into()
-            .map_err(Error::from)?;
-
-        // This EMAT entry is either a sub-region or a full copy of the memory map region, per
-        // EFI 2.10 4.6.4: "Additionally, every memory region described by a Descriptor in
-        // EFI_MEMORY_ATTRIBUTES_TABLE must be a sub-region of, or equal to, a descriptor in the
-        // table produced by GetMemoryMap()."
-        //
-        // This means that we do not have to consider the case where the EMAT entry only overlaps
-        // the end of the memory map entry.
-        //
-        // EMAT items are ordered by physical address, so once we go past |base| we can quit the
-        // loop.
-        for emat_item in efi_memory_attribute_table
-            .into_iter()
-            .skip_while(move |item| item.physical_start < base)
-            .take_while(move |item| item.physical_start < base + size)
-        {
-            if emat_item.physical_start > base {
-                // Create a region for [base ... emat_item->PhysicalStart), because that region is
-                // not covered by the EMAT.
-                let mut generated_item;
-                (generated_item, tail) = Ref::<_, EfiMemoryDescriptor>::new_from_prefix(tail)
-                    .ok_or(UnificationError(BufferTooSmall(Some(
-                        size_of::<EfiMemoryDescriptor>(),
-                    ))))?;
-
-                generated_item.physical_start = base;
-                generated_item.number_of_pages = (emat_item.physical_start - base) / PAGE_SIZE;
-                generated_item.virtual_start = 0;
-                generated_item.attributes = EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME;
-                generated_item.memory_type = emat_item.memory_type;
-
-                // Adjust base and size forward.
-                size -= emat_item.physical_start - base;
-                base = emat_item.physical_start;
-            } else {
-                // emat_item.physical_start == base
-                // Create a region for [base ... emat_item->NumberOfPages * PAGE_SIZE)
-                let mut generated_item;
-                (generated_item, tail) = Ref::<_, EfiMemoryDescriptor>::new_from_prefix(tail)
-                    .ok_or(UnificationError(BufferTooSmall(Some(
-                        size_of::<EfiMemoryDescriptor>(),
-                    ))))?;
-                *generated_item = *emat_item;
-
-                // Adjust base and size forward.
-                base += emat_item.number_of_pages * PAGE_SIZE;
-                size -= emat_item.number_of_pages * PAGE_SIZE;
-            }
-        }
-
-        if size != 0 {
-            let mut generated_item;
-            (generated_item, tail) = Ref::<_, EfiMemoryDescriptor>::new_from_prefix(tail)
-                .ok_or(UnificationError(BufferTooSmall(Some(size_of::<EfiMemoryDescriptor>()))))?;
-
-            generated_item.physical_start = base;
-            generated_item.number_of_pages = size / PAGE_SIZE;
-            generated_item.virtual_start = 0;
-            generated_item.attributes = EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME;
-            generated_item.memory_type = efi_memory_desc.memory_type;
-        }
-    }
-
-    let used_payload = provided_payload_size - tail.len();
-    header.descriptor_size = size_of::<EfiMemoryDescriptor>().try_into().map_err(Error::from)?;
-    header.number_of_entries =
-        (used_payload / size_of::<EfiMemoryDescriptor>()).try_into().unwrap();
-    header.reserved = 0;
-    header.version = 1;
-
-    zbi_items.create_entry(
-        ZbiType::EfiMemoryAttributesTable,
-        0,
-        ZbiFlags::default(),
-        used_payload,
-    )?;
-
-    Ok(())
-}
-
-fn generate_mem_config_item<'b, B>(
-    efi_memory_map: &EfiMemoryMap<'b>,
-    zbi_items: &mut ZbiContainer<B>,
-) -> Result<()>
-where
-    B: SplitByteSliceMut + PartialEq,
-{
-    let mut tail = zbi_items.get_next_payload()?;
-    let provided_payload_size = tail.len();
-
-    for efi_desc in efi_memory_map.into_iter() {
-        let mut zbi_mem_range: Ref<&mut [u8], zbi_mem_range_t>;
-        (zbi_mem_range, tail) = Ref::new_from_prefix(tail)
-            .ok_or(UnificationError(BufferTooSmall(Some(size_of::<zbi_mem_range_t>()))))?;
-        zbi_mem_range.paddr = efi_desc.physical_start;
-        zbi_mem_range.length = efi_desc.number_of_pages * PAGE_SIZE;
-        zbi_mem_range.type_ = efi_to_zbi_mem_range_type(efi_desc.memory_type);
-        zbi_mem_range.reserved = 0;
-    }
-
-    let used_payload = provided_payload_size - tail.len();
-    zbi_items.create_entry(ZbiType::MemConfig, 0, ZbiFlags::default(), used_payload)?;
-
-    Ok(())
-}
diff --git a/gbl/efi/src/lib.rs b/gbl/efi/src/lib.rs
deleted file mode 100644
index 1ed4d22..0000000
--- a/gbl/efi/src/lib.rs
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This EFI application implements a demo for booting Android/Fuchsia from disk. See
-//! bootable/libbootloader/gbl/README.md for how to run the demo. See comments of
-//! `android_boot:android_boot_demo()` and `fuchsia_boot:fuchsia_boot_demo()` for
-//! supported/unsupported features at the moment.
-
-#![cfg_attr(not(test), no_std)]
-
-// For the `vec!` macro
-#[macro_use]
-extern crate alloc;
-
-mod efi_blocks;
-mod error;
-mod ops;
-#[macro_use]
-mod utils;
-
-// Currently un-testable modules.
-//
-// The libefi API surface is large and complex; rather than trying to mock it all out at once, we
-// will selectively enable modules for test as they become mockable.
-#[cfg(not(test))]
-mod android_boot;
-#[cfg(not(test))]
-mod fastboot;
-#[cfg(not(test))]
-mod fuchsia_boot;
-#[cfg(not(test))]
-mod net;
-
-// In tests, map the `efi_mocks` module as `efi`. This allows other modules to `use crate::efi`
-// and automatically pick up the correct one.
-#[cfg(not(test))]
-pub(crate) use efi;
-#[cfg(test)]
-pub(crate) use efi_mocks as efi;
-
-#[cfg(not(test))]
-use {
-    crate::{
-        efi_blocks::{find_block_devices, EfiGblDisk},
-        ops::Ops,
-    },
-    core::fmt::Write,
-    efi::{efi_print, efi_println, EfiEntry},
-    libgbl::{Os, Result},
-    utils::loaded_image_path,
-};
-
-#[cfg(not(test))]
-enum TargetOs {
-    Android,
-    Fuchsia,
-}
-
-#[cfg(not(test))]
-fn get_target_os(entry: &EfiEntry, disks: &[EfiGblDisk]) -> TargetOs {
-    let mut buf = [0u8; 1];
-    if entry
-        .system_table()
-        .runtime_services()
-        .get_variable(&efi::GBL_EFI_VENDOR_GUID, efi::GBL_EFI_OS_BOOT_TARGET_VARNAME, &mut buf)
-        .is_ok()
-    {
-        efi_println!(
-            entry,
-            "`{}` is set. Proceeding as Fuchsia.",
-            efi::GBL_EFI_OS_BOOT_TARGET_VARNAME
-        );
-        TargetOs::Fuchsia
-    } else if fuchsia_boot::is_fuchsia_gpt(disks).is_ok() {
-        efi_println!(entry, "Partition layout looks like Fuchsia. Proceeding as Fuchsia");
-        TargetOs::Fuchsia
-    } else {
-        efi_println!(entry, "Proceeding as Android");
-        TargetOs::Android
-    }
-}
-
-/// GBL EFI application logic entry point.
-#[cfg(not(test))]
-pub fn app_main(entry: EfiEntry) -> Result<()> {
-    efi_println!(entry, "****Generic Bootloader Application****");
-    if let Ok(v) = loaded_image_path(&entry) {
-        efi_println!(entry, "Image path: {}", v);
-    }
-
-    let disks = find_block_devices(&entry)?;
-    match get_target_os(&entry, &disks) {
-        TargetOs::Fuchsia => {
-            let mut ops = Ops::new(&entry, &disks[..], Some(Os::Fuchsia));
-            let (kernel, zbi_items) = fuchsia_boot::efi_fuchsia_load(&mut ops)?;
-            drop(disks);
-            fuchsia_boot::efi_fuchsia_boot(entry, kernel, zbi_items)?;
-        }
-        TargetOs::Android => {
-            let mut ops = Ops::new(&entry, &disks[..], Some(Os::Android));
-            let (ramdisk, fdt, kernel, remains) = android_boot::efi_android_load(&mut ops)?;
-            drop(disks);
-            android_boot::efi_android_boot(entry, kernel, ramdisk, fdt, remains)?;
-        }
-    }
-
-    Ok(())
-}
diff --git a/gbl/efi/src/net.rs b/gbl/efi/src/net.rs
deleted file mode 100644
index 2a3de28..0000000
--- a/gbl/efi/src/net.rs
+++ /dev/null
@@ -1,668 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    error::{listen_to_unified, recv_to_unified, send_to_unified},
-    utils::{get_device_path, loop_with_timeout},
-};
-use alloc::{boxed::Box, vec::Vec};
-use core::{
-    fmt::Write,
-    sync::atomic::{AtomicU64, Ordering},
-    time::Duration,
-};
-use efi::{
-    efi_print, efi_println,
-    protocol::{simple_network::SimpleNetworkProtocol, Protocol},
-    utils::Timeout,
-    DeviceHandle, EfiEntry, Event, EventNotify, EventType, Tpl,
-};
-use efi_types::{EfiEvent, EfiMacAddress, EFI_TIMER_DELAY_TIMER_PERIODIC};
-use gbl_async::{yield_now, YieldCounter};
-use liberror::{Error, Result};
-use libgbl::fastboot::fuchsia_fastboot_mdns_packet;
-use smoltcp::{
-    iface::{Config, Interface, SocketSet, SocketStorage},
-    phy,
-    phy::{Device, DeviceCapabilities, Medium},
-    socket::{
-        tcp::{Socket as TcpSocket, SocketBuffer, State},
-        udp::{PacketBuffer, Socket as UdpSocket, UdpMetadata},
-    },
-    storage::PacketMetadata,
-    time::Instant,
-    wire::{EthernetAddress, IpAddress, IpCidr, IpListenEndpoint, Ipv6Address},
-};
-
-/// Ethernet frame size for frame pool.
-const ETHERNET_FRAME_SIZE: usize = 1536;
-// Update period for `NETWORK_TIMESTAMP`.
-const NETWORK_TIMESTAMP_UPDATE_PERIOD: Duration = Duration::from_millis(50);
-// Size of the socket tx/rx application data buffer.
-const SOCKET_TX_RX_BUFFER: usize = 256 * 1024;
-
-/// Performs a shutdown and restart of the simple network protocol.
-fn reset_simple_network<'a>(snp: &Protocol<'a, SimpleNetworkProtocol>) -> Result<()> {
-    match snp.shutdown() {
-        Err(e) if e != Error::NotStarted => return Err(e),
-        _ => {}
-    };
-
-    match snp.start() {
-        Err(e) if e != Error::AlreadyStarted => return Err(e),
-        _ => {}
-    };
-    snp.initialize(0, 0)?;
-    Ok(snp.reset(true)?)
-}
-
-/// `EfiNetworkDevice` manages a frame pool and handles receiving/sending network frames.
-pub struct EfiNetworkDevice<'a> {
-    protocol: Protocol<'a, SimpleNetworkProtocol>,
-    rx_frame: Box<[u8; ETHERNET_FRAME_SIZE]>,
-    tx_frames: Vec<*mut [u8; ETHERNET_FRAME_SIZE]>,
-    tx_frame_curr: usize, // Circular next index into tx_frames.
-    efi_entry: &'a EfiEntry,
-}
-
-impl<'a> EfiNetworkDevice<'a> {
-    /// Creates an new instance. Allocates `extra_tx_frames+1` number of TX frames.
-    pub fn new(
-        protocol: Protocol<'a, SimpleNetworkProtocol>,
-        extra_tx_frames: usize,
-        efi_entry: &'a EfiEntry,
-    ) -> Self {
-        let mut ret = Self {
-            protocol: protocol,
-            rx_frame: Box::new([0u8; ETHERNET_FRAME_SIZE]),
-            tx_frames: vec![core::ptr::null_mut(); extra_tx_frames + 1],
-            tx_frame_curr: 0,
-            efi_entry: efi_entry,
-        };
-        ret.tx_frames
-            .iter_mut()
-            .for_each(|v| *v = Box::into_raw(Box::new([0u8; ETHERNET_FRAME_SIZE])));
-        ret
-    }
-}
-
-impl Drop for EfiNetworkDevice<'_> {
-    fn drop(&mut self) {
-        if let Err(e) = self.protocol.shutdown() {
-            if e != Error::NotStarted {
-                // If shutdown fails, the protocol might still be operating on transmit buffers,
-                // which can cause undefined behavior. Thus we need to panic.
-                panic!("Failed to shutdown EFI network. {:?}", e);
-            }
-        }
-
-        // Deallocate TX frames.
-        self.tx_frames.iter_mut().for_each(|v| {
-            // SAFETY:
-            // Each pointer is created by `Box::new()` in `EfiNetworkDevice::new()`. Thus the
-            // pointer is valid and layout matches.
-            drop(unsafe { Box::<[u8; ETHERNET_FRAME_SIZE]>::from_raw(*v) });
-        });
-    }
-}
-
-// Implements network device trait backend for the `smoltcp` crate.
-impl<'a> Device for EfiNetworkDevice<'a> {
-    type RxToken<'b>
-        = RxToken<'b>
-    where
-        Self: 'b;
-    type TxToken<'b>
-        = TxToken<'a, 'b>
-    where
-        Self: 'b;
-
-    fn capabilities(&self) -> DeviceCapabilities {
-        // Taken from upstream example.
-        let mut res: DeviceCapabilities = Default::default();
-        res.max_transmission_unit = 65535;
-        res.medium = Medium::Ethernet;
-        res
-    }
-
-    fn receive(&mut self, _: Instant) -> Option<(Self::RxToken<'_>, Self::TxToken<'_>)> {
-        let mut recv_size = self.rx_frame.len();
-        // Receive the next packet from the device.
-        self.protocol
-            .receive(None, Some(&mut recv_size), &mut self.rx_frame[..], None, None, None)
-            .ok()?;
-        match recv_size > 0 {
-            true => Some((
-                RxToken(&mut self.rx_frame[..recv_size]),
-                TxToken {
-                    protocol: &self.protocol,
-                    tx_frames: &mut self.tx_frames[..],
-                    curr: &mut self.tx_frame_curr,
-                    efi_entry: self.efi_entry,
-                },
-            )),
-            _ => None,
-        }
-    }
-
-    fn transmit(&mut self, _: Instant) -> Option<Self::TxToken<'_>> {
-        Some(TxToken {
-            protocol: &self.protocol,
-            tx_frames: &mut self.tx_frames[..],
-            curr: &mut self.tx_frame_curr,
-            efi_entry: self.efi_entry,
-        })
-    }
-}
-
-/// In smoltcp, a `RxToken` is used to receive/process a frame when consumed.
-pub struct RxToken<'a>(&'a mut [u8]);
-
-impl phy::RxToken for RxToken<'_> {
-    fn consume<R, F>(self, f: F) -> R
-    where
-        F: FnOnce(&mut [u8]) -> R,
-    {
-        f(self.0)
-    }
-}
-
-/// In smoltcp, a `TxToken` is used to transmit a frame when consumed.
-pub struct TxToken<'a: 'b, 'b> {
-    tx_frames: &'b mut [*mut [u8; ETHERNET_FRAME_SIZE]],
-    curr: &'b mut usize,
-    protocol: &'b Protocol<'a, SimpleNetworkProtocol>,
-    efi_entry: &'b EfiEntry,
-}
-
-impl TxToken<'_, '_> {
-    /// Tries to allocate a send buffer.
-    fn try_get_buffer(&mut self) -> Option<*mut [u8; ETHERNET_FRAME_SIZE]> {
-        let mut ptr: *mut core::ffi::c_void = core::ptr::null_mut();
-        let mut interrupt_status = 0u32;
-        // Recyle a buffer or take one from `tx_frames`.
-        match self.protocol.get_status(Some(&mut interrupt_status), Some(&mut ptr)) {
-            Ok(()) if self.tx_frames.contains(&(ptr as *mut _)) => Some(ptr as *mut _),
-            _ if *self.curr < self.tx_frames.len() => {
-                // If we can't recycle a buffer, see if we can take one from the pool.
-                let res = *self.curr;
-                *self.curr = *self.curr + 1;
-                Some(self.tx_frames[res])
-            }
-            _ => None,
-        }
-    }
-}
-
-impl phy::TxToken for TxToken<'_, '_> {
-    fn consume<R, F>(mut self, len: usize, f: F) -> R
-    where
-        F: FnOnce(&mut [u8]) -> R,
-    {
-        loop {
-            match loop_with_timeout(self.efi_entry, Duration::from_secs(5), || {
-                self.try_get_buffer().ok_or(false)
-            }) {
-                Ok(Some(send_buffer)) => {
-                    // SAFETY:
-                    // * The pointer is confirmed to come from one of `self.tx_frames`. It's
-                    //   created via `Box::new()` in `EfiNetworkDevice::new()`. Thus it is properly
-                    //   aligned, dereferenceable and initialized.
-                    // * The pointer is either recycled from `self.protocol.get_status` or newly
-                    //   allocated from `self.tx_frames`. Thus There's no other references to it.
-                    // * The reference is only used for passing to `f` and goes out of scope
-                    //   immediately after.
-                    let result = f(&mut unsafe { send_buffer.as_mut() }.unwrap()[..len]);
-
-                    // SAFETY:
-                    // * `send_buffer` comes from `EfiNetworkDevice::tx_frames`. It has a valid
-                    //   length at least `len`. `EfiNetworkDevice` shuts down network on drop. Thus
-                    //   the transmit buffer remains valid throughout the operation of the network
-                    //   protocol.
-                    // * `send_buffer` is either recycled from `self.protocol.get_status()` or newly
-                    //   allocated from `self.tx_frames`. There's no other references to it.
-                    // * `self.curr` stricly increases for each new allocation until
-                    //   `reset_simple_network()`. Thus there'll be no other references to the buffer
-                    //    until it is either recycled or `reset_simple_network()` is called.
-                    let _ = unsafe {
-                        self.protocol.transmit(
-                            0,
-                            send_buffer.as_mut().unwrap().get_mut(..len).unwrap(),
-                            Default::default(), // Src mac address don't care
-                            Default::default(), // Dest mac address don't care
-                            0,
-                        )
-                    };
-
-                    return result;
-                }
-                Ok(None) => {
-                    // Some UEFI firmware has internal network service that also recycle buffers,
-                    // in which case our buffer may be hijacked and will never be returned from our
-                    // call. If we run into this case, shutdown and restart the network and try
-                    // again. Shutting down network releases all pending send/receive buffers
-                    // internally retained.
-                    efi_println!(
-                        self.efi_entry,
-                        "Timeout recycling TX buffers. Resetting network."
-                    );
-                    // Panics if this fails, as we have effectively lost control over network's
-                    // used of buffers.
-                    reset_simple_network(self.protocol).unwrap();
-                    *self.curr = 0;
-                }
-                _ => {} // `loop_with_timeout` failure. Try again.
-            };
-        }
-    }
-}
-
-/// Find the first available network device.
-fn find_net_device(efi_entry: &EfiEntry) -> Result<DeviceHandle> {
-    // Find the device whose path is the "smallest" lexicographically, this ensures that it's not
-    // any child network device of some other node. e1000 tends to add a child network device for
-    // ipv4 and ipv6 configuration information.
-    efi_entry
-        .system_table()
-        .boot_services()
-        .locate_handle_buffer_by_protocol::<SimpleNetworkProtocol>()?
-        .handles()
-        .iter()
-        .map(|handle| (*handle, get_device_path(efi_entry, *handle)))
-        // Ignore devices that fail to get device path.
-        .filter_map(|(handle, path)| path.ok().map(|v| (handle, v)))
-        // Ignore devices that have NULL path.
-        .filter_map(|(handle, path)| path.text().is_some().then(|| (handle, path)))
-        // Finds the minimum path lexicographically.
-        .min_by(|lhs, rhs| Ord::cmp(lhs.1.text().unwrap(), rhs.1.text().unwrap()))
-        .map(|(h, _)| h)
-        .ok_or(Error::NotFound.into())
-}
-
-/// Derives a link local ethernet mac address and IPv6 address from `EfiMacAddress`.
-fn ll_mac_ip6_addr_from_efi_mac(mac: EfiMacAddress) -> (EthernetAddress, IpAddress) {
-    let ll_mac_bytes = &mac.addr[..6];
-    let mut ip6_bytes = [0u8; 16];
-    ip6_bytes[0] = 0xfe;
-    ip6_bytes[1] = 0x80;
-    ip6_bytes[8] = ll_mac_bytes[0] ^ 2;
-    ip6_bytes[9] = ll_mac_bytes[1];
-    ip6_bytes[10] = ll_mac_bytes[2];
-    ip6_bytes[11] = 0xff;
-    ip6_bytes[12] = 0xfe;
-    ip6_bytes[13] = ll_mac_bytes[3];
-    ip6_bytes[14] = ll_mac_bytes[4];
-    ip6_bytes[15] = ll_mac_bytes[5];
-
-    (
-        EthernetAddress::from_bytes(ll_mac_bytes),
-        IpAddress::Ipv6(Ipv6Address::from_bytes(&ip6_bytes[..])),
-    )
-}
-
-/// `EfiTcpSocket` groups together necessary components for performing TCP.
-pub struct EfiTcpSocket<'a, 'b> {
-    pub(crate) efi_entry: &'a EfiEntry,
-    efi_net_dev: &'b mut EfiNetworkDevice<'a>,
-    interface: Interface,
-    socket_set: SocketSet<'b>,
-    io_yield_counter: YieldCounter,
-    last_listen_timestamp: Option<u64>,
-    _time_update_event: Event<'a, 'b>,
-    timestamp: &'b AtomicU64,
-    fuchsia_fastboot_mdns_packet: Vec<u8>,
-}
-
-impl<'a, 'b> EfiTcpSocket<'a, 'b> {
-    /// Resets the socket and starts listening for new TCP connection.
-    pub fn listen(&mut self, port: u16) -> Result<()> {
-        self.get_socket().abort();
-        self.get_socket().listen(port).map_err(listen_to_unified)?;
-        self.last_listen_timestamp = Some(self.timestamp(0).as_millis() as u64);
-        Ok(())
-    }
-
-    // Checks if the socket is listening or performing handshake.
-    pub fn is_listening_or_handshaking(&mut self) -> bool {
-        matches!(self.get_socket().state(), State::Listen | State::SynReceived)
-    }
-
-    /// Returns the amount of time elapsed since last call to `Self::listen()`. If `listen()` has
-    /// never been called, `Duration::MAX` is returned.
-    pub fn time_since_last_listen(&mut self) -> Duration {
-        self.last_listen_timestamp.map(|v| self.timestamp(v)).unwrap_or(Duration::MAX)
-    }
-
-    /// Polls network device.
-    pub fn poll(&mut self) {
-        self.interface.poll(self.instant(), self.efi_net_dev, &mut self.socket_set);
-    }
-
-    /// Polls network and check if the socket is in an active state.
-    pub fn check_active(&mut self) -> bool {
-        self.poll();
-        self.get_socket().is_active()
-    }
-
-    /// Gets a reference to the smoltcp socket object.
-    pub fn get_socket(&mut self) -> &mut TcpSocket<'b> {
-        // We only consider single socket use case for now.
-        let handle = self.socket_set.iter().next().unwrap().0;
-        self.socket_set.get_mut::<TcpSocket>(handle)
-    }
-
-    /// Checks whether a socket is closed.
-    fn is_closed(&mut self) -> bool {
-        return !self.get_socket().is_open() || self.get_socket().state() == State::CloseWait;
-    }
-
-    /// Sets the maximum number of bytes to read or write before a force await.
-    pub fn set_io_yield_threshold(&mut self, threshold: u64) {
-        self.io_yield_counter = YieldCounter::new(threshold)
-    }
-
-    /// Receives exactly `out.len()` number of bytes to `out`.
-    pub async fn receive_exact(&mut self, out: &mut [u8], timeout: Duration) -> Result<()> {
-        let timer = Timeout::new(self.efi_entry, timeout)?;
-        let mut curr = &mut out[..];
-        while !curr.is_empty() {
-            self.poll();
-            let mut has_progress = false;
-
-            if self.is_closed() {
-                return Err(Error::Disconnected);
-            } else if timer.check()? {
-                return Err(Error::Timeout);
-            } else if self.get_socket().can_recv() {
-                let recv_size = self.get_socket().recv_slice(curr).map_err(recv_to_unified)?;
-                curr = curr.get_mut(recv_size..).ok_or(Error::BadIndex(recv_size))?;
-                has_progress = recv_size > 0;
-                // Forces a yield to the executor if the data received/sent reaches a certain
-                // threshold. This is to prevent the async code from holding up the CPU for too long
-                // in case IO speed is high and the executor uses cooperative scheduling.
-                self.io_yield_counter.increment(recv_size.try_into().unwrap()).await;
-            }
-
-            match has_progress {
-                true => timer.reset(timeout)?,
-                _ => yield_now().await,
-            }
-        }
-        Ok(())
-    }
-
-    /// Sends exactly `data.len()` number of bytes from `data`.
-    pub async fn send_exact(&mut self, data: &[u8], timeout: Duration) -> Result<()> {
-        let timer = Timeout::new(self.efi_entry, timeout)?;
-        let mut curr = &data[..];
-        let mut last_send_queue = self.get_socket().send_queue();
-        loop {
-            self.poll();
-            if curr.is_empty() && self.get_socket().send_queue() == 0 {
-                return Ok(());
-            } else if self.is_closed() {
-                return Err(Error::Disconnected.into());
-            } else if timer.check()? {
-                return Err(Error::Timeout.into());
-            }
-
-            let mut has_progress = false;
-            // Checks if any data in the queue is sent.
-            if self.get_socket().send_queue() != last_send_queue {
-                last_send_queue = self.get_socket().send_queue();
-                has_progress = true;
-            }
-            // Checks if there are more data to be queued.
-            if self.get_socket().can_send() && !curr.is_empty() {
-                let sent = self.get_socket().send_slice(curr).map_err(send_to_unified)?;
-                curr = curr.get(sent..).ok_or(Error::BadIndex(sent))?;
-                // Forces a yield to the executor if the data received/sent reaches a certain
-                // threshold. This is to prevent the async code from holding up the CPU for too long
-                // in case IO speed is high and the executor uses cooperative scheduling.
-                self.io_yield_counter.increment(sent.try_into().unwrap()).await;
-                has_progress |= sent > 0;
-            }
-
-            match has_progress {
-                true => timer.reset(timeout)?,
-                _ => yield_now().await,
-            }
-        }
-    }
-
-    /// Gets the smoltcp `Interface` for this socket.
-    pub fn interface(&self) -> &Interface {
-        &self.interface
-    }
-
-    /// Returns the duration elapsed since the `base` timestamp.
-    pub fn timestamp(&self, base_in_millis: u64) -> Duration {
-        let curr = self.timestamp.load(Ordering::Relaxed);
-        // Assume there can be at most one overflow.
-        Duration::from_millis(match curr < base_in_millis {
-            true => u64::MAX - (base_in_millis - curr),
-            false => curr - base_in_millis,
-        })
-    }
-
-    /// Returns a smoltcp time `Instant` value.
-    fn instant(&self) -> Instant {
-        to_smoltcp_instant(self.timestamp(0).as_millis() as u64)
-    }
-
-    /// Broadcasts Fuchsia Fastboot MDNS service once.
-    pub fn broadcast_fuchsia_fastboot_mdns(&mut self) {
-        const MDNS_PORT: u16 = 5353;
-        const IP6_BROADCAST_ADDR: &[u8] =
-            &[0xFF, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFB];
-        let ip6_broadcast = Ipv6Address::from_bytes(&IP6_BROADCAST_ADDR[..]);
-        let meta =
-            UdpMetadata { endpoint: (ip6_broadcast, MDNS_PORT).into(), meta: Default::default() };
-        let handle = self.socket_set.iter().nth(1).unwrap().0;
-        let socket = self.socket_set.get_mut::<UdpSocket>(handle);
-        if !socket.is_open() {
-            match socket.bind(IpListenEndpoint { addr: None, port: MDNS_PORT }) {
-                Err(e) => efi_println!(self.efi_entry, "bind error: {:?}", e),
-                _ => {}
-            }
-        }
-        if socket.can_send() {
-            match socket.send_slice(&self.fuchsia_fastboot_mdns_packet, meta) {
-                Err(e) => efi_println!(self.efi_entry, "UDP send error: {:?}", e),
-                _ => {}
-            }
-        }
-    }
-}
-
-/// Returns a smoltcp time `Instant` value from a u64 timestamp.
-fn to_smoltcp_instant(ts: u64) -> Instant {
-    Instant::from_millis(i64::try_from(ts).unwrap())
-}
-
-/// Internal type that contains net driver interfaces and buffers for creating GBL network and
-/// sockets.
-///
-/// # Lifetimes
-///
-/// * `'a`: Lifetime of [EfiEntry] borrowed.
-/// * `'b`: Lifetime of [SocketStorage<'b>], which eventually refers to Self.
-/// * `'c`: Lifetime of [AtomicU64] borrowed.
-struct EfiGblNetworkInternal<'a, 'b, 'c> {
-    efi_entry: &'a EfiEntry,
-    tcp_tx_buffer: Vec<u8>,
-    tcp_rx_buffer: Vec<u8>,
-    udp_tx_payload_buffer: Vec<u8>,
-    udp_rx_payload_buffer: Vec<u8>,
-    udp_tx_metadata_buffer: Vec<PacketMetadata<UdpMetadata>>,
-    udp_rx_metadata_buffer: Vec<PacketMetadata<UdpMetadata>>,
-    socket_storage: [SocketStorage<'b>; 2],
-    efi_net_dev: EfiNetworkDevice<'a>,
-    timestamp: &'c AtomicU64,
-    notify_fn: Option<Box<dyn FnMut(EfiEvent) + Sync + 'c>>,
-    notify: Option<EventNotify<'b>>,
-}
-
-impl<'a, 'b, 'c> EfiGblNetworkInternal<'a, 'b, 'c> {
-    /// Creates a new instance of [EfiGblNetworkInternal].
-    fn new(efi_entry: &'a EfiEntry, timestamp: &'c AtomicU64) -> Result<Self> {
-        // Creates and initializes simple network protocol.
-        let snp_dev = find_net_device(efi_entry)?;
-        let snp = efi_entry
-            .system_table()
-            .boot_services()
-            .open_protocol::<SimpleNetworkProtocol>(snp_dev)?;
-        reset_simple_network(&snp)?;
-
-        // The TCP stack requires ICMP6 solicitation for discovery. Enable promiscuous mode so that
-        // all uni/multicast packets can be captured.
-        match snp.set_promiscuous_mode() {
-            Err(e) => efi_println!(
-                efi_entry,
-                "Warning: Failed to set promiscuous mode {e:?}. Device may be undiscoverable",
-            ),
-            _ => {}
-        }
-
-        Ok(Self {
-            efi_entry,
-            tcp_tx_buffer: vec![0u8; SOCKET_TX_RX_BUFFER],
-            tcp_rx_buffer: vec![0u8; SOCKET_TX_RX_BUFFER],
-            udp_tx_payload_buffer: vec![0u8; ETHERNET_FRAME_SIZE],
-            udp_rx_payload_buffer: vec![0u8; ETHERNET_FRAME_SIZE],
-            udp_tx_metadata_buffer: vec![PacketMetadata::EMPTY; 1],
-            udp_rx_metadata_buffer: vec![PacketMetadata::EMPTY; 1],
-            socket_storage: Default::default(),
-            // Allocates 7(chosen randomly) extra TX frames. Revisits if it is not enough.
-            efi_net_dev: EfiNetworkDevice::new(snp, 7, &efi_entry),
-            timestamp,
-            notify_fn: None,
-            notify: None,
-        })
-    }
-
-    /// Creates an instance of [EfiTcpSocket].
-    fn create_socket(&'b mut self) -> Result<EfiTcpSocket<'a, 'b>> {
-        // Resets network timestamp to 0.
-        let _ = self.timestamp.swap(0, Ordering::Relaxed);
-
-        // Initializes notification functions.
-        if self.notify_fn.is_none() {
-            self.notify_fn = Some(Box::new(|_: EfiEvent| {
-                self.timestamp.fetch_add(
-                    NETWORK_TIMESTAMP_UPDATE_PERIOD.as_millis() as u64,
-                    Ordering::Relaxed,
-                );
-            }));
-            self.notify = Some(EventNotify::new(Tpl::Callback, self.notify_fn.as_mut().unwrap()));
-        }
-
-        // Creates a timer event for updating the global timestamp.
-        let bs = self.efi_entry.system_table().boot_services();
-        // SAFETY: the notification callback in `notify_fn` initialized above never allocates,
-        // deallocates, or panics.
-        let _time_update_event = unsafe {
-            bs.create_event_with_notification(
-                EventType::TimerNotifySignal,
-                self.notify.as_mut().unwrap(),
-            )
-        }?;
-        bs.set_timer(
-            &_time_update_event,
-            EFI_TIMER_DELAY_TIMER_PERIODIC,
-            NETWORK_TIMESTAMP_UPDATE_PERIOD,
-        )?;
-
-        // Gets our MAC address and IPv6 address.
-        // We can also consider getting this from vendor configuration.
-        let (ll_mac, ll_ip6_addr) =
-            ll_mac_ip6_addr_from_efi_mac(self.efi_net_dev.protocol.mode()?.current_address);
-        // Configures smoltcp network interface.
-        let mut interface = Interface::new(
-            Config::new(ll_mac.into()),
-            &mut self.efi_net_dev,
-            to_smoltcp_instant(0),
-        );
-        interface.update_ip_addrs(|ip_addrs| ip_addrs.push(IpCidr::new(ll_ip6_addr, 64)).unwrap());
-
-        // Generates Fuchsia Fastboot MDNS packet.
-        let eth_mac = ll_mac.as_bytes();
-        let fuchsia_node_name = format!(
-            "fuchsia-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}",
-            eth_mac[0], eth_mac[1], eth_mac[2], eth_mac[3], eth_mac[4], eth_mac[5]
-        );
-        let fuchsia_fastboot_mdns_packet =
-            fuchsia_fastboot_mdns_packet(fuchsia_node_name.as_str(), ll_ip6_addr.as_bytes())?
-                .into();
-
-        // Creates sockets.
-        let mut socket_set = SocketSet::new(&mut self.socket_storage[..]);
-        // Creates a TCP socket for fastboot over TCP.
-        let tx_socket_buffer = SocketBuffer::new(&mut self.tcp_tx_buffer[..]);
-        let rx_socket_buffer = SocketBuffer::new(&mut self.tcp_rx_buffer[..]);
-        let tcp_socket = TcpSocket::new(rx_socket_buffer, tx_socket_buffer);
-        let _ = socket_set.add(tcp_socket);
-        // Creates a UDP socket for MDNS broadcast.
-        let udp_tx_packet_buffer = PacketBuffer::new(
-            &mut self.udp_tx_metadata_buffer[..],
-            &mut self.udp_tx_payload_buffer[..],
-        );
-        let udp_rx_packet_buffer = PacketBuffer::new(
-            &mut self.udp_rx_metadata_buffer[..],
-            &mut self.udp_rx_payload_buffer[..],
-        );
-        let udp_socket = UdpSocket::new(udp_rx_packet_buffer, udp_tx_packet_buffer);
-        let _ = socket_set.add(udp_socket);
-        Ok(EfiTcpSocket {
-            efi_entry: self.efi_entry,
-            efi_net_dev: &mut self.efi_net_dev,
-            interface,
-            socket_set,
-            io_yield_counter: YieldCounter::new(u64::MAX),
-            last_listen_timestamp: None,
-            _time_update_event,
-            timestamp: self.timestamp,
-            fuchsia_fastboot_mdns_packet,
-        })
-    }
-}
-
-/// The GBL network stack.
-///
-/// # Lifetimes
-///
-/// * `'a`: Lifetime of `efi_entry` borrowed.
-/// * `'b`: Lifetime of Self.
-/// * `'c`: Lifetime of external timestamp borrowed.
-#[derive(Default)]
-pub struct EfiGblNetwork<'a, 'b, 'c>(Option<EfiGblNetworkInternal<'a, 'b, 'c>>);
-
-impl<'a, 'b, 'c: 'b> EfiGblNetwork<'a, 'b, 'c> {
-    /// Initializes GBL network and creates GBL sockets.
-    ///
-    /// # Args:
-    ///
-    /// * `efi_entry`: A [EfiEntry].
-    /// * `ts`: A reference to an [AtomicU64].
-    pub fn init(
-        &'b mut self,
-        efi_entry: &'a EfiEntry,
-        timestamp: &'c AtomicU64,
-    ) -> Result<EfiTcpSocket<'a, 'b>> {
-        // Drops any existing network first to release the global event notify function.
-        self.0 = None;
-        self.0 = Some(EfiGblNetworkInternal::new(efi_entry, timestamp)?);
-        self.0.as_mut().unwrap().create_socket()
-    }
-}
diff --git a/gbl/efi/src/ops.rs b/gbl/efi/src/ops.rs
deleted file mode 100644
index 636bbf2..0000000
--- a/gbl/efi/src/ops.rs
+++ /dev/null
@@ -1,1672 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Implements [Gbl::Ops] for the EFI environment.
-
-use crate::{
-    efi,
-    efi_blocks::EfiGblDisk,
-    utils::{get_efi_fdt, wait_key_stroke},
-};
-use alloc::{
-    alloc::{alloc, handle_alloc_error, Layout},
-    vec::Vec,
-};
-use arrayvec::ArrayVec;
-use core::{
-    ffi::CStr, fmt::Write, mem::MaybeUninit, num::NonZeroUsize, ops::DerefMut, ptr::null,
-    slice::from_raw_parts_mut, time::Duration,
-};
-use efi::{
-    efi_print, efi_println,
-    protocol::{
-        dt_fixup::DtFixupProtocol,
-        gbl_efi_ab_slot::GblSlotProtocol,
-        gbl_efi_avb::GblAvbProtocol,
-        gbl_efi_fastboot::GblFastbootProtocol,
-        gbl_efi_image_loading::{EfiImageBufferInfo, GblImageLoadingProtocol},
-        gbl_efi_os_configuration::GblOsConfigurationProtocol,
-    },
-    EfiEntry,
-};
-use efi_types::{
-    GblEfiAvbKeyValidationStatus, GblEfiAvbVerificationResult, GblEfiBootReason,
-    GblEfiDeviceTreeMetadata, GblEfiImageInfo, GblEfiVerifiedDeviceTree,
-    GBL_EFI_BOOT_REASON_BOOTLOADER, GBL_EFI_BOOT_REASON_COLD, GBL_EFI_BOOT_REASON_FASTBOOTD,
-    GBL_EFI_BOOT_REASON_RECOVERY, PARTITION_NAME_LEN_U16,
-};
-use fdt::Fdt;
-use gbl_storage::{BlockIo, Disk, Gpt};
-use liberror::{Error, Result};
-use libgbl::{
-    constants::{ImageName, BOOTCMD_SIZE},
-    device_tree::{
-        DeviceTreeComponent, DeviceTreeComponentSource, DeviceTreeComponentsRegistry,
-        MAXIMUM_DEVICE_TREE_COMPONENTS,
-    },
-    gbl_avb::state::{BootStateColor, KeyValidationStatus},
-    ops::{
-        AvbIoError, AvbIoResult, CertPermanentAttributes, ImageBuffer, RebootReason, Slot,
-        SlotsMetadata, SHA256_DIGEST_SIZE,
-    },
-    partition::GblDisk,
-    slots::{BootToken, Cursor},
-    GblOps, Os, Result as GblResult,
-};
-use safemath::SafeNum;
-use zbi::ZbiContainer;
-use zerocopy::IntoBytes;
-
-fn to_avb_validation_status_or_panic(status: GblEfiAvbKeyValidationStatus) -> KeyValidationStatus {
-    match status {
-        efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID => KeyValidationStatus::Valid,
-        efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID_CUSTOM_KEY => {
-            KeyValidationStatus::ValidCustomKey
-        }
-        efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_INVALID => KeyValidationStatus::Invalid,
-        _ => panic!("Unrecognized avb key validation status: {}", status),
-    }
-}
-
-fn avb_color_to_efi_color(color: BootStateColor) -> u32 {
-    match color {
-        BootStateColor::Green => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_GREEN,
-        BootStateColor::Yellow => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_YELLOW,
-        BootStateColor::Orange => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_ORANGE,
-        BootStateColor::RedEio => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_RED_EIO,
-        BootStateColor::Red => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_RED,
-    }
-}
-
-fn dt_component_to_efi_dt(component: &DeviceTreeComponent) -> GblEfiVerifiedDeviceTree {
-    let metadata = component.metadata.unwrap_or_default();
-
-    GblEfiVerifiedDeviceTree {
-        metadata: GblEfiDeviceTreeMetadata {
-            source: match component.source {
-                DeviceTreeComponentSource::Boot => efi_types::GBL_EFI_DEVICE_TREE_SOURCE_BOOT,
-                DeviceTreeComponentSource::VendorBoot => {
-                    efi_types::GBL_EFI_DEVICE_TREE_SOURCE_VENDOR_BOOT
-                }
-                DeviceTreeComponentSource::Dtb => efi_types::GBL_EFI_DEVICE_TREE_SOURCE_DTB,
-                DeviceTreeComponentSource::Dtbo => efi_types::GBL_EFI_DEVICE_TREE_SOURCE_DTBO,
-            },
-            id: metadata.id,
-            rev: metadata.rev,
-            custom: metadata.custom,
-            reserved: Default::default(),
-        },
-        device_tree: component.dt.as_ptr() as _,
-        selected: component.selected,
-    }
-}
-
-fn efi_error_to_avb_error(error: Error) -> AvbIoError {
-    match error {
-        // EFI_STATUS_OUT_OF_RESOURCES
-        Error::OutOfResources => AvbIoError::Oom,
-        // EFI_STATUS_DEVICE_ERROR
-        Error::DeviceError => AvbIoError::Io,
-        // EFI_STATUS_NOT_FOUND
-        Error::NotFound => AvbIoError::NoSuchValue,
-        // EFI_STATUS_END_OF_FILE
-        Error::EndOfFile => AvbIoError::RangeOutsidePartition,
-        // EFI_STATUS_INVALID_PARAMETER
-        Error::InvalidInput => AvbIoError::InvalidValueSize,
-        // EFI_STATUS_BUFFER_TOO_SMALL
-        Error::BufferTooSmall(required) => {
-            AvbIoError::InsufficientSpace(required.unwrap_or_default())
-        }
-        // EFI_STATUS_UNSUPPORTED
-        Error::Unsupported => AvbIoError::NotImplemented,
-        _ => AvbIoError::NotImplemented,
-    }
-}
-
-/// Helper for getting platform reserved buffer from EFI image loading prototol.
-pub(crate) fn get_buffer_from_protocol(
-    efi_entry: &EfiEntry,
-    image_name: &str,
-    size: usize,
-) -> Result<EfiImageBufferInfo> {
-    let mut image_type = [0u16; PARTITION_NAME_LEN_U16];
-    image_type.iter_mut().zip(image_name.encode_utf16()).for_each(|(dst, src)| {
-        *dst = src;
-    });
-    Ok(efi_entry
-        .system_table()
-        .boot_services()
-        .find_first_and_open::<GblImageLoadingProtocol>()?
-        .get_buffer(&GblEfiImageInfo { ImageType: image_type, SizeBytes: size })?)
-}
-
-pub struct Ops<'a, 'b> {
-    pub efi_entry: &'a EfiEntry,
-    pub disks: &'b [EfiGblDisk<'a>],
-    pub zbi_bootloader_files_buffer: Vec<u8>,
-    pub os: Option<Os>,
-}
-
-impl<'a, 'b> Ops<'a, 'b> {
-    /// Creates a new instance of [Ops]
-    pub fn new(efi_entry: &'a EfiEntry, disks: &'b [EfiGblDisk<'a>], os: Option<Os>) -> Self {
-        Self { efi_entry, disks, zbi_bootloader_files_buffer: Default::default(), os }
-    }
-
-    /// Gets the property of an FDT node from EFI FDT.
-    ///
-    /// Returns `None` if fail to get the node
-    fn get_efi_fdt_prop(&self, path: &str, prop: &CStr) -> Option<&'a [u8]> {
-        let (_, fdt_bytes) = get_efi_fdt(&self.efi_entry)?;
-        let fdt = Fdt::new(fdt_bytes).ok()?;
-        fdt.get_property(path, prop).ok()
-    }
-
-    /// Get buffer for partition loading and verification.
-    /// Uses GBL EFI ImageLoading protocol.
-    ///
-    /// # Arguments
-    /// * `image_name` - image name to differentiate the buffer properties. Processing is limited
-    /// to first [PARTITION_NAME_LEN_U16] symbols, and the remaining will be ignored.
-    /// * `size` - requested buffer size
-    ///
-    /// # Return
-    /// * Ok(ImageBuffer) - Return buffer for partition loading and verification.
-    /// * Err(_) - on error
-    pub(crate) fn get_buffer_image_loading(
-        &mut self,
-        image_name: &str,
-        size: NonZeroUsize,
-    ) -> GblResult<ImageBuffer<'static>> {
-        // EfiImageBuffer -> ImageBuffer
-        // Make sure not to drop efi_image_buffer since we transferred ownership to ImageBuffer
-        Ok(ImageBuffer::new(
-            get_buffer_from_protocol(self.efi_entry, image_name, size.get())?
-                .take()
-                .ok_or(Error::InvalidState)?,
-        ))
-    }
-
-    /// Get buffer for partition loading and verification.
-    /// Uses provided allocator.
-    ///
-    /// # Arguments
-    /// * `image_name` - image name to differentiate the buffer properties
-    /// * `size` - requested buffer size
-    ///
-    /// # Return
-    /// * Ok(ImageBuffer) - Return buffer for partition loading and verification.
-    /// * Err(_) - on error
-    // SAFETY:
-    // Allocated buffer is leaked intentionally. ImageBuffer is assumed to reference static memory.
-    // ImageBuffer is not expected to be released, and is allocated to hold data necessary for next
-    // boot stage (kernel boot). All allocated buffers are expected to be used by kernel.
-    fn allocate_image_buffer(image_name: &str, size: NonZeroUsize) -> Result<ImageBuffer<'static>> {
-        let size = match image_name {
-            "ramdisk" => (SafeNum::from(size.get()) + BOOTCMD_SIZE).try_into()?,
-            _ => size.get(),
-        };
-        // Check for `from_raw_parts_mut()` safety requirements.
-        assert!(size < isize::MAX.try_into().unwrap());
-        let align = ImageName::try_from(image_name).map(|i| i.alignment()).unwrap_or(1);
-
-        let layout = Layout::from_size_align(size, align).or(Err(Error::InvalidAlignment))?;
-        // SAFETY:
-        // `layout.size()` is checked to be not zero.
-        let ptr = unsafe { alloc(layout) } as *mut MaybeUninit<u8>;
-        if ptr.is_null() {
-            handle_alloc_error(layout);
-        }
-
-        // SAFETY:
-        // `ptr` is checked to be not Null.
-        // `ptr` is a valid pointer to start of a single memory region of `size`-bytes because it
-        // was just returned by alloc. Buffer alignment requirement for u8 is 1-byte which is
-        // always the case.
-        // `alloc()` makes sure there is no other allocation of the same memory region until
-        // current one is released.
-        // `size` is a valid size of the memory region since `alloc()` succeeded.
-        //
-        // Total size of buffer is not greater than `isize::MAX` since it is checked at the
-        // beginning of the function.
-        //
-        // `ptr + size` doesn't wrap since it is returned from alloc and it didn't fail.
-        let buf = unsafe { from_raw_parts_mut(ptr, size) };
-
-        Ok(ImageBuffer::new(buf))
-    }
-}
-
-impl Write for Ops<'_, '_> {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        efi_print!(self.efi_entry, "{}", s);
-        Ok(())
-    }
-}
-
-impl<'a, 'b, 'd> GblOps<'b, 'd> for Ops<'a, 'b> {
-    fn console_out(&mut self) -> Option<&mut dyn Write> {
-        Some(self)
-    }
-
-    /// UEFI console uses \r\n newline.
-    fn console_newline(&self) -> &'static str {
-        "\r\n"
-    }
-
-    fn should_stop_in_fastboot(&mut self) -> Result<bool> {
-        // TODO(b/349829690): also query GblSlotProtocol.get_boot_reason() for board-specific
-        // fastboot triggers.
-
-        // TODO(b/366520234): Switch to use GblSlotProtocol.should_stop_in_fastboot once available.
-        match self.get_efi_fdt_prop("gbl", c"stop-in-fastboot") {
-            Some(v) => return Ok(*v.get(0).unwrap_or(&0) == 1),
-            _ => {}
-        }
-
-        efi_println!(self.efi_entry, "Press Backspace to enter fastboot");
-        let found = wait_key_stroke(
-            self.efi_entry,
-            |key| key.unicode_char == 0x08 || (key.unicode_char == 0x0 && key.scan_code == 0x08),
-            Duration::from_secs(2),
-        );
-        if matches!(found, Ok(true)) {
-            efi_println!(self.efi_entry, "Backspace pressed, entering fastboot");
-        }
-        // TODO(b/358377120): pass the UEFI error when liberror::Error support lands.
-        found.or(Err(Error::Other(Some("wait for key stroke error"))))
-    }
-
-    /// Reboots the system into the last set boot mode.
-    fn reboot(&mut self) {
-        self.efi_entry.system_table().runtime_services().cold_reset();
-    }
-
-    fn disks(
-        &self,
-    ) -> &'b [GblDisk<
-        Disk<impl BlockIo + 'b, impl DerefMut<Target = [u8]> + 'b>,
-        Gpt<impl DerefMut<Target = [u8]> + 'b>,
-    >] {
-        self.disks
-    }
-
-    fn expected_os(&mut self) -> Result<Option<Os>> {
-        Ok(self.os)
-    }
-
-    fn zircon_add_device_zbi_items(
-        &mut self,
-        container: &mut ZbiContainer<&mut [u8]>,
-    ) -> Result<()> {
-        // TODO(b/353272981): Switch to use OS configuration protocol once it is implemented on
-        // existing platforms such as VIM3.
-        Ok(match self.get_efi_fdt_prop("zircon", c"zbi-blob") {
-            Some(blob) => container.extend_unaligned(blob).map_err(|_| "Failed to append ZBI")?,
-            _ => efi_println!(self.efi_entry, "No device ZBI items.\r\n"),
-        })
-    }
-
-    fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
-        // Switches to use get_image_buffer once available.
-        const DEFAULT_SIZE: usize = 4096;
-        if self.zbi_bootloader_files_buffer.is_empty() {
-            self.zbi_bootloader_files_buffer.resize(DEFAULT_SIZE, 0);
-        }
-        Some(self.zbi_bootloader_files_buffer.as_mut_slice())
-    }
-
-    fn load_slot_interface<'c>(
-        &'c mut self,
-        _: &'c mut dyn FnMut(&mut [u8]) -> Result<()>,
-        _: BootToken,
-    ) -> GblResult<Cursor<'c>> {
-        unimplemented!();
-    }
-
-    fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => protocol.read_is_device_unlocked().map_err(efi_error_to_avb_error),
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => protocol
-                .read_rollback_index(rollback_index_location)
-                .map_err(efi_error_to_avb_error),
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_write_rollback_index(
-        &mut self,
-        rollback_index_location: usize,
-        index: u64,
-    ) -> AvbIoResult<()> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => protocol
-                .write_rollback_index(rollback_index_location, index)
-                .map_err(efi_error_to_avb_error),
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => {
-                protocol.read_persistent_value(name, value).map_err(efi_error_to_avb_error)
-            }
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => {
-                protocol.write_persistent_value(name, Some(value)).map_err(efi_error_to_avb_error)
-            }
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => {
-                protocol.write_persistent_value(name, None).map_err(efi_error_to_avb_error)
-            }
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_validate_vbmeta_public_key(
-        &self,
-        public_key: &[u8],
-        public_key_metadata: Option<&[u8]>,
-    ) -> AvbIoResult<KeyValidationStatus> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => protocol
-                .validate_vbmeta_public_key(public_key, public_key_metadata)
-                .map(to_avb_validation_status_or_panic)
-                .map_err(efi_error_to_avb_error),
-            Err(_) => Err(AvbIoError::NotImplemented),
-        }
-    }
-
-    fn avb_cert_read_permanent_attributes(
-        &mut self,
-        attributes: &mut CertPermanentAttributes,
-    ) -> AvbIoResult<()> {
-        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
-        let perm_attr = self
-            .get_efi_fdt_prop("gbl", c"avb-cert-permanent-attributes")
-            .ok_or(AvbIoError::NotImplemented)?;
-        attributes.as_bytes_mut().clone_from_slice(perm_attr);
-        Ok(())
-    }
-
-    fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
-        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
-        let hash = self
-            .get_efi_fdt_prop("gbl", c"avb-cert-permanent-attributes-hash")
-            .ok_or(AvbIoError::NotImplemented)?;
-        Ok(hash.try_into().map_err(|_| AvbIoError::Io)?)
-    }
-
-    fn avb_handle_verification_result(
-        &mut self,
-        color: BootStateColor,
-        digest: Option<&CStr>,
-        boot_os_version: Option<&[u8]>,
-        boot_security_patch: Option<&[u8]>,
-        system_os_version: Option<&[u8]>,
-        system_security_patch: Option<&[u8]>,
-        vendor_os_version: Option<&[u8]>,
-        vendor_security_patch: Option<&[u8]>,
-    ) -> AvbIoResult<()> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
-        {
-            Ok(protocol) => protocol
-                .handle_verification_result(&GblEfiAvbVerificationResult {
-                    color: avb_color_to_efi_color(color),
-                    digest: digest.map_or(null(), |p| p.as_ptr() as _),
-                    boot_version: boot_os_version.map_or(null(), |p| p.as_ptr()),
-                    boot_security_patch: boot_security_patch.map_or(null(), |p| p.as_ptr()),
-                    system_version: system_os_version.map_or(null(), |p| p.as_ptr()),
-                    system_security_patch: system_security_patch.map_or(null(), |p| p.as_ptr()),
-                    vendor_version: vendor_os_version.map_or(null(), |p| p.as_ptr()),
-                    vendor_security_patch: vendor_security_patch.map_or(null(), |p| p.as_ptr()),
-                })
-                .map_err(efi_error_to_avb_error),
-            _ => Ok(()),
-        }
-    }
-
-    fn get_image_buffer(
-        &mut self,
-        image_name: &str,
-        size: NonZeroUsize,
-    ) -> GblResult<ImageBuffer<'d>> {
-        self.get_buffer_image_loading(image_name, size)
-            .or(Self::allocate_image_buffer(image_name, size)
-                .map_err(|e| libgbl::IntegrationError::UnificationError(e)))
-    }
-
-    fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
-        // On Cuttlefish, the device tree comes from the UEFI config tables.
-        // TODO(b/353272981): once we've settled on the device tree UEFI protocol, use that
-        // instead to provide a Cuttlefish-specific backend.
-        Some(get_efi_fdt(&self.efi_entry)?.1)
-    }
-
-    fn fixup_os_commandline<'c>(
-        &mut self,
-        commandline: &CStr,
-        fixup_buffer: &'c mut [u8],
-    ) -> Result<Option<&'c str>> {
-        match self
-            .efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblOsConfigurationProtocol>()
-        {
-            Ok(protocol) => {
-                protocol.fixup_kernel_commandline(commandline, fixup_buffer)?;
-                Ok(Some(CStr::from_bytes_until_nul(&fixup_buffer[..])?.to_str()?))
-            }
-            // Protocol is optional.
-            Err(Error::NotFound) => Ok(None),
-            Err(e) => Err(e),
-        }
-    }
-
-    fn fixup_bootconfig<'c>(
-        &mut self,
-        bootconfig: &[u8],
-        fixup_buffer: &'c mut [u8],
-    ) -> Result<Option<&'c [u8]>> {
-        match self
-            .efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblOsConfigurationProtocol>()
-        {
-            Ok(protocol) => {
-                let fixup_size = protocol.fixup_bootconfig(bootconfig, fixup_buffer)?;
-                Ok(Some(&fixup_buffer[..fixup_size]))
-            }
-            // Protocol is optional.
-            Err(Error::NotFound) => Ok(None),
-            Err(e) => Err(e),
-        }
-    }
-
-    fn fixup_device_tree(&mut self, device_tree: &mut [u8]) -> Result<()> {
-        match self.efi_entry.system_table().boot_services().find_first_and_open::<DtFixupProtocol>()
-        {
-            Ok(protocol) => protocol.fixup(device_tree),
-            // Protocol is optional.
-            Err(Error::NotFound) => Ok(()),
-            Err(e) => Err(e),
-        }
-    }
-
-    fn select_device_trees(
-        &mut self,
-        components_registry: &mut DeviceTreeComponentsRegistry,
-    ) -> Result<()> {
-        match self
-            .efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblOsConfigurationProtocol>()
-        {
-            Ok(protocol) => {
-                // Protocol detected, convert to UEFI types.
-                let mut uefi_components: ArrayVec<_, MAXIMUM_DEVICE_TREE_COMPONENTS> =
-                    components_registry
-                        .components()
-                        .map(|component| dt_component_to_efi_dt(component))
-                        .collect();
-
-                protocol.select_device_trees(&mut uefi_components[..])?;
-
-                // Propagate selections to the components_registry.
-                components_registry
-                    .components_mut()
-                    .zip(uefi_components.iter_mut())
-                    .enumerate()
-                    .for_each(|(index, (component, uefi_component))| {
-                        if uefi_component.selected {
-                            efi_println!(
-                                self.efi_entry,
-                                "Device tree component at index {} got selected by UEFI call. \
-                                Source: {}",
-                                index,
-                                component.source
-                            );
-                        }
-                        component.selected = uefi_component.selected;
-                    });
-
-                Ok(())
-            }
-            // Protocol is optional.
-            Err(Error::NotFound) => components_registry.autoselect(),
-            Err(e) => Err(e),
-        }
-    }
-
-    fn fastboot_variable<'arg>(
-        &mut self,
-        name: &CStr,
-        args: impl Iterator<Item = &'arg CStr> + Clone,
-        out: &mut [u8],
-    ) -> Result<usize> {
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblFastbootProtocol>()?
-            .get_var(name, args, out)
-    }
-
-    fn fastboot_visit_all_variables(&mut self, cb: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
-        match self
-            .efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblFastbootProtocol>()
-        {
-            Ok(v) => v.get_var_all(cb),
-            Err(Error::NotFound) => Ok(()),
-            Err(e) => Err(e),
-        }
-    }
-
-    fn slots_metadata(&mut self) -> Result<SlotsMetadata> {
-        Ok(SlotsMetadata {
-            slot_count: self
-                .efi_entry
-                .system_table()
-                .boot_services()
-                .find_first_and_open::<GblSlotProtocol>()?
-                .load_boot_data()?
-                .slot_count
-                .try_into()
-                .unwrap(),
-        })
-    }
-
-    #[cfg(not(test))]
-    fn get_current_slot(&mut self) -> Result<Slot> {
-        // TODO(b/383620444): GBL EFI slot protocol is currently implemented on a few platforms such
-        // as Cuttlefish but is out of sync. Wait until protocol is more stable and all platforms
-        // pick up the latest before enabling.
-        Err(Error::Unsupported)
-    }
-
-    #[cfg(not(test))]
-    fn get_next_slot(&mut self, _: bool) -> Result<Slot> {
-        // TODO(b/383620444): See `get_current_slot()`.
-        Err(Error::Unsupported)
-    }
-
-    #[cfg(not(test))]
-    fn set_active_slot(&mut self, _: u8) -> Result<()> {
-        // TODO(b/383620444): See `get_current_slot()`.
-        Err(Error::Unsupported)
-    }
-
-    #[cfg(not(test))]
-    fn set_reboot_reason(&mut self, _: RebootReason) -> Result<()> {
-        // TODO(b/383620444): See `get_current_slot()`.
-        Err(Error::Unsupported)
-    }
-
-    #[cfg(not(test))]
-    fn get_reboot_reason(&mut self) -> Result<RebootReason> {
-        // TODO(b/383620444): See `get_current_slot()`.
-        Err(Error::Unsupported)
-    }
-
-    #[cfg(test)]
-    fn get_current_slot(&mut self) -> Result<Slot> {
-        // TODO(b/363075013): Refactors the opening of slot protocol into a common helper once
-        // `MockBootServices::find_first_and_open` is updated to return Protocol<'_, T>.
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblSlotProtocol>()?
-            .get_current_slot()?
-            .try_into()
-    }
-
-    #[cfg(test)]
-    fn get_next_slot(&mut self, mark_boot_attempt: bool) -> Result<Slot> {
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblSlotProtocol>()?
-            .get_next_slot(mark_boot_attempt)?
-            .try_into()
-    }
-
-    #[cfg(test)]
-    fn set_active_slot(&mut self, slot: u8) -> Result<()> {
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblSlotProtocol>()?
-            .set_active_slot(slot)
-    }
-
-    #[cfg(test)]
-    fn set_reboot_reason(&mut self, reason: RebootReason) -> Result<()> {
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblSlotProtocol>()?
-            .set_boot_reason(gbl_to_efi_boot_reason(reason), b"")
-    }
-
-    #[cfg(test)]
-    fn get_reboot_reason(&mut self) -> Result<RebootReason> {
-        let mut subreason = [0u8; 128];
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblSlotProtocol>()?
-            .get_boot_reason(&mut subreason[..])
-            .map(|(v, _)| efi_to_gbl_boot_reason(v))
-    }
-}
-
-/// Converts a [GblEfiBootReason] to [RebootReason].
-// TODO(b/383620444): Remove the attribute once all boards picks up the stable Slot protocol.
-#[allow(dead_code)]
-fn efi_to_gbl_boot_reason(reason: GblEfiBootReason) -> RebootReason {
-    match reason {
-        GBL_EFI_BOOT_REASON_RECOVERY => RebootReason::Recovery,
-        GBL_EFI_BOOT_REASON_BOOTLOADER => RebootReason::Bootloader,
-        GBL_EFI_BOOT_REASON_FASTBOOTD => RebootReason::FastbootD,
-        _ => RebootReason::Normal,
-    }
-}
-
-/// Converts a [RebootReason] to [GblEfiBootReason].
-// TODO(b/383620444): Remove the attribute once all boards picks up the stable Slot protocol.
-#[allow(dead_code)]
-fn gbl_to_efi_boot_reason(reason: RebootReason) -> GblEfiBootReason {
-    match reason {
-        RebootReason::Recovery => GBL_EFI_BOOT_REASON_RECOVERY,
-        RebootReason::Bootloader => GBL_EFI_BOOT_REASON_BOOTLOADER,
-        RebootReason::FastbootD => GBL_EFI_BOOT_REASON_FASTBOOTD,
-        RebootReason::Normal => GBL_EFI_BOOT_REASON_COLD,
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use efi_mocks::{
-        protocol::{gbl_efi_ab_slot::GblSlotProtocol, gbl_efi_avb::GblAvbProtocol},
-        MockEfi,
-    };
-    use efi_types::GBL_EFI_BOOT_REASON;
-    use mockall::predicate::eq;
-    use std::slice;
-
-    #[test]
-    fn ops_write_trait() {
-        let mut mock_efi = MockEfi::new();
-
-        mock_efi.con_out.expect_write_str().with(eq("foo bar")).return_const(Ok(()));
-        let installed = mock_efi.install();
-
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert!(write!(&mut ops, "{} {}", "foo", "bar").is_ok());
-    }
-
-    #[test]
-    fn ops_avb_validate_vbmeta_public_key_returns_valid() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.validate_vbmeta_public_key_result =
-            Some(Ok(efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Ok(KeyValidationStatus::Valid));
-    }
-
-    #[test]
-    fn ops_avb_validate_vbmeta_public_key_returns_valid_custom_key() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.validate_vbmeta_public_key_result =
-            Some(Ok(efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID_CUSTOM_KEY));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(
-            ops.avb_validate_vbmeta_public_key(&[], None),
-            Ok(KeyValidationStatus::ValidCustomKey)
-        );
-    }
-
-    #[test]
-    fn ops_avb_validate_vbmeta_public_key_returns_invalid() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.validate_vbmeta_public_key_result =
-            Some(Ok(efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_INVALID));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Ok(KeyValidationStatus::Invalid));
-    }
-
-    #[test]
-    fn ops_avb_validate_vbmeta_public_key_failed_error_mapped() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.validate_vbmeta_public_key_result = Some(Err(Error::OutOfResources));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Err(AvbIoError::Oom));
-    }
-
-    #[test]
-    fn ops_avb_validate_vbmeta_public_key_protocol_not_found_mapped_to_not_implemented() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Err(AvbIoError::NotImplemented));
-    }
-
-    #[test]
-    fn ops_avb_read_is_device_unlocked_returns_true() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.read_is_device_unlocked_result = Some(Ok(true));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_read_is_device_unlocked(), Ok(true));
-    }
-
-    #[test]
-    fn ops_avb_read_is_device_unlocked_returns_false() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.read_is_device_unlocked_result = Some(Ok(false));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_read_is_device_unlocked(), Ok(false));
-    }
-
-    #[test]
-    fn ops_avb_read_is_device_unlocked_protocol_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_read_is_device_unlocked(), Err(AvbIoError::NotImplemented));
-    }
-
-    #[test]
-    fn ops_avb_read_rollback_index_success() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.read_rollback_index_result = Some(Ok(12345));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_read_rollback_index(0), Ok(12345));
-    }
-
-    #[test]
-    fn ops_avb_read_rollback_index_error() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.read_rollback_index_result = Some(Err(Error::OutOfResources));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_read_rollback_index(0), Err(AvbIoError::Oom));
-    }
-
-    #[test]
-    fn ops_avb_read_rollback_index_protocol_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_read_rollback_index(0), Err(AvbIoError::NotImplemented));
-    }
-
-    #[test]
-    fn ops_avb_write_rollback_index_success() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.write_rollback_index_result = Some(Ok(()));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert!(ops.avb_write_rollback_index(0, 12345).is_ok());
-    }
-
-    #[test]
-    fn ops_avb_write_rollback_index_error() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.write_rollback_index_result = Some(Err(Error::InvalidInput));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_write_rollback_index(0, 12345), Err(AvbIoError::InvalidValueSize));
-    }
-
-    #[test]
-    fn ops_avb_write_rollback_index_protocol_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_write_rollback_index(0, 12345), Err(AvbIoError::NotImplemented));
-    }
-
-    #[test]
-    fn ops_avb_read_persistent_value_success() {
-        const EXPECTED_LEN: usize = 4;
-
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.read_persistent_value_result = Some(Ok(EXPECTED_LEN));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        let mut buffer = [0u8; EXPECTED_LEN];
-        assert_eq!(ops.avb_read_persistent_value(c"test", &mut buffer), Ok(EXPECTED_LEN));
-    }
-
-    #[test]
-    fn ops_avb_read_persistent_value_error() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.read_persistent_value_result = Some(Err(Error::OutOfResources));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        let mut buffer = [0u8; 0];
-        assert_eq!(ops.avb_read_persistent_value(c"test", &mut buffer), Err(AvbIoError::Oom));
-    }
-
-    #[test]
-    fn ops_avb_read_persistent_value_protocol_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        let mut buffer = [0u8; 0];
-        assert_eq!(
-            ops.avb_read_persistent_value(c"test", &mut buffer),
-            Err(AvbIoError::NotImplemented)
-        );
-    }
-
-    #[test]
-    fn ops_avb_write_persistent_value_success() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.write_persistent_value_result = Some(Ok(()));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_write_persistent_value(c"test", b""), Ok(()));
-    }
-
-    #[test]
-    fn ops_avb_write_persistent_value_error() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.write_persistent_value_result = Some(Err(Error::InvalidInput));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_write_persistent_value(c"test", b""), Err(AvbIoError::InvalidValueSize));
-    }
-
-    #[test]
-    fn ops_avb_write_persistent_value_protocol_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_write_persistent_value(c"test", b""), Err(AvbIoError::NotImplemented));
-    }
-
-    #[test]
-    fn ops_avb_erase_persistent_value_success() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.write_persistent_value_result = Some(Ok(()));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_erase_persistent_value(c"test"), Ok(()));
-    }
-
-    #[test]
-    fn ops_avb_erase_persistent_value_error() {
-        let mut mock_efi = MockEfi::new();
-        let mut avb = GblAvbProtocol::default();
-        avb.write_persistent_value_result = Some(Err(Error::DeviceError));
-        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_erase_persistent_value(c"test"), Err(AvbIoError::Io));
-    }
-
-    #[test]
-    fn ops_avb_erase_persistent_value_protocol_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblAvbProtocol>()
-            .return_const(Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        assert_eq!(ops.avb_erase_persistent_value(c"test"), Err(AvbIoError::NotImplemented));
-    }
-
-    /// Helper for testing `set_boot_reason`
-    fn test_set_reboot_reason(input: RebootReason, expect: GBL_EFI_BOOT_REASON) {
-        let mut mock_efi = MockEfi::new();
-        mock_efi.boot_services.expect_find_first_and_open::<GblSlotProtocol>().return_once(
-            move || {
-                let mut slot = GblSlotProtocol::default();
-                slot.expect_set_boot_reason().return_once(move |reason, _| {
-                    assert_eq!(reason, expect);
-                    Ok(())
-                });
-                Ok(slot)
-            },
-        );
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-        assert_eq!(ops.set_reboot_reason(input), Ok(()));
-    }
-
-    #[test]
-    fn test_set_reboot_reason_normal() {
-        test_set_reboot_reason(RebootReason::Normal, GBL_EFI_BOOT_REASON_COLD);
-    }
-
-    #[test]
-    fn test_set_reboot_reason_recovery() {
-        test_set_reboot_reason(RebootReason::Recovery, GBL_EFI_BOOT_REASON_RECOVERY);
-    }
-
-    #[test]
-    fn test_set_reboot_reason_bootloader() {
-        test_set_reboot_reason(RebootReason::Bootloader, GBL_EFI_BOOT_REASON_BOOTLOADER);
-    }
-
-    #[test]
-    fn test_set_reboot_reason_fastbootd() {
-        test_set_reboot_reason(RebootReason::FastbootD, GBL_EFI_BOOT_REASON_FASTBOOTD);
-    }
-
-    /// Helper for testing `get_boot_reason`
-    fn test_get_reboot_reason(input: GBL_EFI_BOOT_REASON, expect: RebootReason) {
-        let mut mock_efi = MockEfi::new();
-        mock_efi.boot_services.expect_find_first_and_open::<GblSlotProtocol>().return_once(
-            move || {
-                let mut slot = GblSlotProtocol::default();
-                slot.expect_get_boot_reason().return_once(move |_| Ok((input, 0)));
-                Ok(slot)
-            },
-        );
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-        assert_eq!(ops.get_reboot_reason().unwrap(), expect)
-    }
-
-    #[test]
-    fn test_get_reboot_reason_normal() {
-        test_get_reboot_reason(GBL_EFI_BOOT_REASON_COLD, RebootReason::Normal);
-    }
-
-    #[test]
-    fn test_get_reboot_reason_recovery() {
-        test_get_reboot_reason(GBL_EFI_BOOT_REASON_RECOVERY, RebootReason::Recovery);
-    }
-
-    #[test]
-    fn test_get_reboot_reason_bootloader() {
-        test_get_reboot_reason(GBL_EFI_BOOT_REASON_BOOTLOADER, RebootReason::Bootloader);
-    }
-
-    #[test]
-    fn test_get_reboot_reason_fastbootd() {
-        test_get_reboot_reason(GBL_EFI_BOOT_REASON_FASTBOOTD, RebootReason::FastbootD);
-    }
-
-    #[test]
-    fn test_get_var_all_not_found() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblFastbootProtocol>()
-            .return_once(|| Err(Error::NotFound));
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-        ops.fastboot_visit_all_variables(|_, _| {}).unwrap();
-    }
-
-    #[test]
-    fn test_get_var_all_other_errors() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblFastbootProtocol>()
-            .return_once(|| Err(Error::InvalidInput));
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-        assert!(ops.fastboot_visit_all_variables(|_, _| {}).is_err());
-    }
-
-    /// Helper for testing `GblOsConfigurationProtocol.fixup_os_commandline`
-    fn test_fixup_os_commandline<'a>(
-        expected_base: &'static CStr,
-        fixup_buffer: &'a mut [u8],
-        fixup_to_apply: &'static [u8],
-        protocol_lookup_error: Option<Error>,
-        protocol_result: Result<()>,
-    ) -> Result<Option<&'a str>> {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblOsConfigurationProtocol>()
-            .return_once(move || {
-                if let Some(error) = protocol_lookup_error {
-                    return Err(error);
-                }
-
-                let mut os_configuration = GblOsConfigurationProtocol::default();
-
-                os_configuration.expect_fixup_kernel_commandline().return_once(
-                    move |base, buffer| {
-                        assert_eq!(base, expected_base);
-                        buffer[..fixup_to_apply.len()].copy_from_slice(fixup_to_apply);
-                        protocol_result
-                    },
-                );
-
-                Ok(os_configuration)
-            });
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        ops.fixup_os_commandline(expected_base, fixup_buffer)
-    }
-
-    #[test]
-    fn test_fixup_os_commandline_success() {
-        const BASE: &CStr = c"key1=value1 key2=value2";
-        const FIXUP: &CStr = c"fixup1=value1 fixup2=value2";
-
-        let mut fixup_buffer = [0x0; FIXUP.to_bytes_with_nul().len()];
-        assert_eq!(
-            test_fixup_os_commandline(
-                BASE,
-                &mut fixup_buffer,
-                FIXUP.to_bytes_with_nul(),
-                // No protocol lookup error.
-                None,
-                // No protocol call error.
-                Ok(()),
-            ),
-            // Expects fixup applied.
-            Ok(Some(FIXUP.to_str().unwrap()))
-        );
-    }
-
-    #[test]
-    fn test_fixup_os_commandline_success_empty_result() {
-        const BASE: &CStr = c"key1=value1 key2=value2";
-
-        let mut fixup_buffer = [0x0; 1];
-        assert_eq!(
-            test_fixup_os_commandline(
-                BASE,
-                &mut fixup_buffer,
-                // Passes empty fixup to apply.
-                &[],
-                // No protocol lookup error.
-                None,
-                // No protocol call error.
-                Ok(()),
-            ),
-            // Expected empty fixup.
-            Ok(Some("")),
-        );
-    }
-
-    #[test]
-    fn test_fixup_os_commandline_wrong_fixup() {
-        const BASE: &CStr = c"key1=value1 key2=value2";
-
-        // Have no space for null terminator.
-        let mut fixup_buffer = [0x0; BASE.to_bytes().len()];
-        assert_eq!(
-            test_fixup_os_commandline(
-                BASE,
-                &mut fixup_buffer,
-                BASE.to_bytes(),
-                // No protocol lookup error.
-                None,
-                // No protocol call error.
-                Ok(()),
-            ),
-            // Expected error, cannot build c string.
-            Err(Error::InvalidInput),
-        );
-    }
-
-    #[test]
-    fn test_fixup_os_commandline_protocol_error() {
-        const BASE: &CStr = c"key1=value1 key2=value2";
-
-        let mut fixup_buffer = [0x0; 0];
-        assert_eq!(
-            test_fixup_os_commandline(
-                BASE,
-                &mut fixup_buffer,
-                &[],
-                // No protocol lookup error.
-                None,
-                // Protocol returns error.
-                Err(Error::BufferTooSmall(Some(100))),
-            ),
-            // Expected to be catched.
-            Err(Error::BufferTooSmall(Some(100))),
-        );
-    }
-
-    #[test]
-    fn test_fixup_os_commandline_protocol_not_found() {
-        const BASE: &CStr = c"key1=value1 key2=value2";
-
-        let mut fixup_buffer = [0x0; 0];
-        assert_eq!(
-            test_fixup_os_commandline(
-                BASE,
-                &mut fixup_buffer,
-                &[],
-                // Protocol not found.
-                Some(Error::NotFound),
-                // No protocol call error.
-                Ok(()),
-            ),
-            // No fixup in case protocol not found.
-            Ok(None),
-        );
-    }
-
-    #[test]
-    fn test_fixup_os_commandline_protocol_lookup_failed() {
-        const BASE: &CStr = c"key1=value1 key2=value2";
-
-        let mut fixup_buffer = [0x0; 0];
-        assert_eq!(
-            test_fixup_os_commandline(
-                BASE,
-                &mut fixup_buffer,
-                &[],
-                // Protocol lookup failed.
-                Some(Error::AccessDenied),
-                // No protocol call error.
-                Ok(()),
-            ),
-            // Error catched.
-            Err(Error::AccessDenied),
-        );
-    }
-
-    /// Helper for testing `GblOsConfigurationProtocol.fixup_bootconfig`
-    fn test_fixup_bootconfig<'a>(
-        expected_base: &'static [u8],
-        fixup_buffer: &'a mut [u8],
-        fixup_to_apply: &'static [u8],
-        protocol_lookup_error: Option<Error>,
-        protocol_result_error: Option<Error>,
-    ) -> Result<Option<&'a [u8]>> {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblOsConfigurationProtocol>()
-            .return_once(move || {
-                if let Some(error) = protocol_lookup_error {
-                    return Err(error);
-                }
-
-                let mut os_configuration = GblOsConfigurationProtocol::default();
-
-                os_configuration.expect_fixup_bootconfig().return_once(move |base, buffer| {
-                    assert_eq!(base, expected_base);
-                    buffer[..fixup_to_apply.len()].copy_from_slice(fixup_to_apply);
-
-                    if let Some(protocol_result_error) = protocol_result_error {
-                        return Err(protocol_result_error);
-                    }
-
-                    Ok(fixup_to_apply.len())
-                });
-
-                Ok(os_configuration)
-            });
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        ops.fixup_bootconfig(expected_base, fixup_buffer)
-    }
-
-    #[test]
-    fn test_fixup_bootconfig_success() {
-        const BASE: &[u8] = b"key1=value1\nkey2=value2";
-        const FIXUP: &[u8] = b"fixup1=value1\nfixup2=value2";
-
-        let mut fixup_buffer = [0x0; FIXUP.len()];
-        assert_eq!(
-            test_fixup_bootconfig(
-                BASE,
-                &mut fixup_buffer,
-                FIXUP,
-                // No protocol lookup error.
-                None,
-                // No protocol call error.
-                None,
-            ),
-            // Expects fixup applied.
-            Ok(Some(FIXUP)),
-        );
-    }
-
-    #[test]
-    fn test_fixup_bootconfig_protocol_error() {
-        const BASE: &[u8] = b"key1=value1\nkey2=value2";
-        const FIXUP: &[u8] = b"fixup1=value1\nfixup2=value2";
-
-        let mut fixup_buffer = [0x0; FIXUP.len()];
-        assert_eq!(
-            test_fixup_bootconfig(
-                BASE,
-                &mut fixup_buffer,
-                FIXUP,
-                // No protocol lookup error.
-                None,
-                // Protocol returns error.
-                Some(Error::BufferTooSmall(Some(100))),
-            ),
-            // Expected to be catched.
-            Err(Error::BufferTooSmall(Some(100))),
-        );
-    }
-
-    #[test]
-    fn test_fixup_bootconfig_protocol_not_found() {
-        const BASE: &[u8] = b"key1=value1\nkey2=value2";
-        const FIXUP: &[u8] = b"fixup1=value1\nfixup2=value2";
-
-        let mut fixup_buffer = [0x0; FIXUP.len()];
-        assert_eq!(
-            test_fixup_bootconfig(
-                BASE,
-                &mut fixup_buffer,
-                FIXUP,
-                // Protocol not found.
-                Some(Error::NotFound),
-                // No protocol call error.
-                None,
-            ),
-            // No fixup in case protocol not found.
-            Ok(None),
-        );
-    }
-
-    #[test]
-    fn test_fixup_bootconfig_protocol_lookup_failed() {
-        const BASE: &[u8] = b"key1=value1\nkey2=value2";
-        const FIXUP: &[u8] = b"fixup1=value1\nfixup2=value2";
-
-        let mut fixup_buffer = [0x0; FIXUP.len()];
-        assert_eq!(
-            test_fixup_bootconfig(
-                BASE,
-                &mut fixup_buffer,
-                FIXUP,
-                // Protocol lookup failed.
-                Some(Error::AccessDenied),
-                // No protocol call error.
-                None,
-            ),
-            // Error catched.
-            Err(Error::AccessDenied),
-        );
-    }
-
-    #[test]
-    fn test_select_device_tree_components_select_base_and_overlay() {
-        let base = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let overlay = include_bytes!("../../libfdt/test/data/overlay_by_path.dtbo").to_vec();
-        let overlay2 = include_bytes!("../../libfdt/test/data/overlay_by_reference.dtbo").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-
-        let base_scoped = base.clone();
-        let overlay_scoped = overlay.clone();
-        let overlay2_scoped = overlay2.clone();
-        let mut mock_efi = MockEfi::new();
-        mock_efi.con_out.expect_write_str().return_const(Ok(()));
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblOsConfigurationProtocol>()
-            .return_once(|| {
-                let mut os_configuration = GblOsConfigurationProtocol::default();
-
-                os_configuration.expect_select_device_trees().return_once(move |components| {
-                    assert_eq!(components.len(), 3);
-
-                    // SAFETY:
-                    // `components[*].device_trees` are pointing to corresponding base device
-                    // tree and overlays buffers.
-                    let (base_passed, overlay_passed, overlay2_passed) = unsafe {
-                        (
-                            slice::from_raw_parts(
-                                components[0].device_tree as *const u8,
-                                base_scoped.len(),
-                            ),
-                            slice::from_raw_parts(
-                                components[1].device_tree as *const u8,
-                                overlay_scoped.len(),
-                            ),
-                            slice::from_raw_parts(
-                                components[2].device_tree as *const u8,
-                                overlay2_scoped.len(),
-                            ),
-                        )
-                    };
-
-                    assert_eq!(base_passed, &base_scoped);
-                    assert_eq!(overlay_passed, &overlay_scoped[..]);
-                    assert_eq!(overlay2_passed, &overlay2_scoped[..]);
-
-                    // Select the base device and the second overlay. The first overlay is not
-                    // being selected.
-                    components[0].selected = true;
-                    components[2].selected = true;
-                    Ok(())
-                });
-
-                Ok(os_configuration)
-            });
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        let mut registry = DeviceTreeComponentsRegistry::new();
-        let mut current_buffer = &mut buffer[..];
-        current_buffer = registry
-            .append(&mut ops, DeviceTreeComponentSource::VendorBoot, &base, current_buffer)
-            .unwrap();
-        current_buffer = registry
-            .append(&mut ops, DeviceTreeComponentSource::Dtbo, &overlay, current_buffer)
-            .unwrap();
-        registry
-            .append(&mut ops, DeviceTreeComponentSource::Dtbo, &overlay2, current_buffer)
-            .unwrap();
-
-        assert_eq!(ops.select_device_trees(&mut registry), Ok(()));
-        assert_eq!(registry.selected(), Ok((&base[..], &[&overlay2[..]][..])));
-    }
-
-    #[test]
-    fn test_select_device_tree_protocol_error() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblOsConfigurationProtocol>()
-            .return_once(move || {
-                let mut os_configuration = GblOsConfigurationProtocol::default();
-
-                os_configuration
-                    .expect_select_device_trees()
-                    .return_once(move |_components| Err(Error::InvalidInput));
-
-                Ok(os_configuration)
-            });
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        assert_eq!(ops.select_device_trees(&mut registry), Err(Error::InvalidInput));
-    }
-
-    #[test]
-    fn test_select_device_tree_protocol_not_found() {
-        let base = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-
-        let mut mock_efi = MockEfi::new();
-        mock_efi
-            .boot_services
-            .expect_find_first_and_open::<GblOsConfigurationProtocol>()
-            .return_once(move || Err(Error::NotFound));
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        // Appends some data to ensure autoselect is passed.
-        let mut registry = DeviceTreeComponentsRegistry::new();
-        let current_buffer = &mut buffer[..];
-        registry
-            .append(&mut ops, DeviceTreeComponentSource::VendorBoot, &base, current_buffer)
-            .unwrap();
-
-        assert_eq!(ops.select_device_trees(&mut registry), Ok(()));
-    }
-
-    /// Helper for testing `DtFixupProtocol.fixup`
-    fn test_fixup_device_tree(
-        base: &mut [u8],
-        base_after_fixup: &'static [u8],
-        protocol_lookup_error: Option<Error>,
-        protocol_result: Result<()>,
-    ) -> Result<()> {
-        let mut mock_efi = MockEfi::new();
-        mock_efi.boot_services.expect_find_first_and_open::<DtFixupProtocol>().return_once(
-            move || {
-                if let Some(error) = protocol_lookup_error {
-                    return Err(error);
-                }
-
-                let mut dt_fixup = DtFixupProtocol::default();
-
-                dt_fixup.expect_fixup().return_once(move |buffer| {
-                    buffer.copy_from_slice(base_after_fixup);
-                    protocol_result
-                });
-
-                Ok(dt_fixup)
-            },
-        );
-
-        let installed = mock_efi.install();
-        let mut ops = Ops::new(installed.entry(), &[], None);
-
-        let r = ops.fixup_device_tree(base);
-        assert_eq!(base, base_after_fixup);
-        r
-    }
-
-    #[test]
-    fn test_fixup_device_tree_success() {
-        const WITH_FIXUP: &[u8] = b"device tree after overlay applied";
-
-        let mut device_tree_buffer = [0x0; WITH_FIXUP.len()];
-        assert_eq!(
-            test_fixup_device_tree(
-                &mut device_tree_buffer,
-                WITH_FIXUP,
-                // No protocol lookup error.
-                None,
-                // No protocol call error.
-                Ok(()),
-            ),
-            Ok(()),
-        );
-    }
-
-    #[test]
-    fn test_fixup_device_tree_protocol_error() {
-        const WITH_FIXUP: &[u8] = b"device tree after overlay applied";
-
-        let mut device_tree_buffer = [0x0; WITH_FIXUP.len()];
-        assert_eq!(
-            test_fixup_device_tree(
-                &mut device_tree_buffer,
-                WITH_FIXUP,
-                // No protocol lookup error.
-                None,
-                // Protocol returns error.
-                Err(Error::BufferTooSmall(Some(100))),
-            ),
-            // Expected to be catched.
-            Err(Error::BufferTooSmall(Some(100))),
-        );
-    }
-
-    #[test]
-    fn test_fixup_device_tree_protocol_not_found() {
-        assert_eq!(
-            test_fixup_device_tree(
-                &mut [],
-                &[],
-                // Protocol not found.
-                Some(Error::NotFound),
-                // No protocol call error.
-                Ok(()),
-            ),
-            // Protocol is optional, so passed.
-            Ok(()),
-        );
-    }
-
-    #[test]
-    fn test_fixup_device_tree_protocol_lookup_failed() {
-        assert_eq!(
-            test_fixup_device_tree(
-                &mut [],
-                &[],
-                // Protocol lookup failed.
-                Some(Error::AccessDenied),
-                // No protocol call error.
-                Ok(()),
-            ),
-            // Error catched.
-            Err(Error::AccessDenied),
-        );
-    }
-}
diff --git a/gbl/efi/src/utils.rs b/gbl/efi/src/utils.rs
deleted file mode 100644
index 1595014..0000000
--- a/gbl/efi/src/utils.rs
+++ /dev/null
@@ -1,206 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{efi, ops::get_buffer_from_protocol};
-use ::efi::{efi_print, efi_println, EfiMemoryAttributesTable};
-use core::{fmt::Write, slice::from_raw_parts_mut, time::Duration};
-use efi::{
-    protocol::{
-        device_path::{DevicePathProtocol, DevicePathText, DevicePathToTextProtocol},
-        gbl_efi_image_loading::EfiImageBufferInfo,
-        loaded_image::LoadedImageProtocol,
-        simple_text_input::SimpleTextInputProtocol,
-    },
-    utils::Timeout,
-    DeviceHandle, EfiEntry,
-};
-use efi_types::{EfiGuid, EfiInputKey};
-use fdt::FdtHeader;
-use liberror::Error;
-use libgbl::Result;
-
-pub const EFI_DTB_TABLE_GUID: EfiGuid =
-    EfiGuid::new(0xb1b621d5, 0xf19c, 0x41a5, [0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0]);
-
-/// Helper function to get the `DevicePathText` from a `DeviceHandle`.
-pub fn get_device_path<'a>(
-    entry: &'a EfiEntry,
-    handle: DeviceHandle,
-) -> Result<DevicePathText<'a>> {
-    let bs = entry.system_table().boot_services();
-    let path = bs.open_protocol::<DevicePathProtocol>(handle)?;
-    let path_to_text = bs.find_first_and_open::<DevicePathToTextProtocol>()?;
-    Ok(path_to_text.convert_device_path_to_text(&path, false, false)?)
-}
-
-/// Helper function to get the loaded image path.
-pub fn loaded_image_path(entry: &EfiEntry) -> Result<DevicePathText> {
-    get_device_path(
-        entry,
-        entry
-            .system_table()
-            .boot_services()
-            .open_protocol::<LoadedImageProtocol>(entry.image_handle())?
-            .device_handle()?,
-    )
-}
-
-/// Find FDT from EFI configuration table.
-pub fn get_efi_fdt(entry: &EfiEntry) -> Option<(&FdtHeader, &[u8])> {
-    if let Some(config_tables) = entry.system_table().configuration_table() {
-        for table in config_tables {
-            if table.vendor_guid == EFI_DTB_TABLE_GUID {
-                // SAFETY: Buffer provided by EFI configuration table.
-                return unsafe { FdtHeader::from_raw(table.vendor_table as *const _).ok() };
-            }
-        }
-    }
-    None
-}
-
-#[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
-pub fn efi_to_e820_mem_type(efi_mem_type: u32) -> u32 {
-    match efi_mem_type {
-        efi_types::EFI_MEMORY_TYPE_LOADER_CODE
-        | efi_types::EFI_MEMORY_TYPE_LOADER_DATA
-        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_CODE
-        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_DATA
-        | efi_types::EFI_MEMORY_TYPE_CONVENTIONAL_MEMORY => boot::x86::E820_ADDRESS_TYPE_RAM,
-        efi_types::EFI_MEMORY_TYPE_RUNTIME_SERVICES_CODE
-        | efi_types::EFI_MEMORY_TYPE_RUNTIME_SERVICES_DATA
-        | efi_types::EFI_MEMORY_TYPE_MEMORY_MAPPED_IO
-        | efi_types::EFI_MEMORY_TYPE_MEMORY_MAPPED_IOPORT_SPACE
-        | efi_types::EFI_MEMORY_TYPE_PAL_CODE
-        | efi_types::EFI_MEMORY_TYPE_RESERVED_MEMORY_TYPE => boot::x86::E820_ADDRESS_TYPE_RESERVED,
-        efi_types::EFI_MEMORY_TYPE_UNUSABLE_MEMORY => boot::x86::E820_ADDRESS_TYPE_UNUSABLE,
-        efi_types::EFI_MEMORY_TYPE_ACPIRECLAIM_MEMORY => boot::x86::E820_ADDRESS_TYPE_ACPI,
-        efi_types::EFI_MEMORY_TYPE_ACPIMEMORY_NVS => boot::x86::E820_ADDRESS_TYPE_NVS,
-        efi_types::EFI_MEMORY_TYPE_PERSISTENT_MEMORY => boot::x86::E820_ADDRESS_TYPE_PMEM,
-        v => panic!("Unmapped EFI memory type {v}"),
-    }
-}
-
-/// Repetitively runs a closure until it signals completion or timeout.
-///
-/// * If `f` returns `Ok(R)`, an `Ok(Some(R))` is returned immediately.
-/// * If `f` has been repetitively called and returning `Err(false)` for `timeout_duration`,  an
-///   `Ok(None)` is returned. This is the time out case.
-/// * If `f` returns `Err(true)` the timeout is reset.
-pub fn loop_with_timeout<F, R>(
-    efi_entry: &EfiEntry,
-    timeout_duration: Duration,
-    mut f: F,
-) -> Result<Option<R>>
-where
-    F: FnMut() -> core::result::Result<R, bool>,
-{
-    let timeout = Timeout::new(efi_entry, timeout_duration)?;
-    while !timeout.check()? {
-        match f() {
-            Ok(v) => return Ok(Some(v)),
-            Err(true) => timeout.reset(timeout_duration)?,
-            _ => {}
-        }
-    }
-    Ok(None)
-}
-
-/// Waits for a key stroke value from simple text input.
-///
-/// Returns `Ok(true)` if the expected key stroke is read, `Ok(false)` if timeout, `Err` otherwise.
-pub fn wait_key_stroke(
-    efi_entry: &EfiEntry,
-    pred: impl Fn(EfiInputKey) -> bool,
-    timeout: Duration,
-) -> Result<bool> {
-    let input = efi_entry
-        .system_table()
-        .boot_services()
-        .find_first_and_open::<SimpleTextInputProtocol>()?;
-    loop_with_timeout(efi_entry, timeout, || -> core::result::Result<Result<bool>, bool> {
-        match input.read_key_stroke() {
-            Ok(Some(key)) if pred(key) => Ok(Ok(true)),
-            Err(e) => Ok(Err(e.into())),
-            _ => Err(false),
-        }
-    })?
-    .unwrap_or(Ok(false))
-}
-
-// Converts an EFI memory type to a zbi_mem_range_t type.
-pub fn efi_to_zbi_mem_range_type(efi_mem_type: u32) -> u32 {
-    match efi_mem_type {
-        efi_types::EFI_MEMORY_TYPE_LOADER_CODE
-        | efi_types::EFI_MEMORY_TYPE_LOADER_DATA
-        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_CODE
-        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_DATA
-        | efi_types::EFI_MEMORY_TYPE_CONVENTIONAL_MEMORY => zbi::zbi_format::ZBI_MEM_TYPE_RAM,
-        _ => zbi::zbi_format::ZBI_MEM_TYPE_RESERVED,
-    }
-}
-
-/// Find Memory attributes from EFI configuration_table
-#[allow(unused)]
-pub fn get_efi_mem_attr<'a>(entry: &'a EfiEntry) -> Option<EfiMemoryAttributesTable<'static>> {
-    entry.system_table().configuration_table().and_then(|config_tables| {
-        config_tables
-            .iter()
-            .find_map(|&table| {
-                // SAFETY:
-                // `table` is valid EFI Configuration table provided by EFI
-                match unsafe { EfiMemoryAttributesTable::new(table) } {
-                    Err(Error::NotFound) => None,
-                    other => Some(other.ok()),
-                }
-            })
-            .flatten()
-    })
-}
-
-/// Represents either an initialized static memory space or memory to be allocated by the given
-/// size.
-pub(crate) enum BufferInfo {
-    // A static memory space, i.e. memory space reserved by platform
-    Static(&'static mut [u8]),
-    Alloc(usize),
-}
-
-/// A helper for getting platform buffer info from EFI image loading protocol.
-pub(crate) fn get_platform_buffer_info(
-    efi_entry: &EfiEntry,
-    image_type: &str,
-    default_aloc_size: usize,
-) -> BufferInfo {
-    match get_buffer_from_protocol(efi_entry, image_type, 0) {
-        Ok(EfiImageBufferInfo::Buffer(mut buffer)) => {
-            let buffer = buffer.take();
-            buffer.fill(core::mem::MaybeUninit::zeroed());
-            efi_println!(
-                efi_entry,
-                "Found \"{image_type}\" buffer from EFI protocol: addr {:#x}, sz: {:#x}.",
-                buffer.as_mut_ptr() as usize,
-                buffer.len()
-            );
-            // SAFETY:
-            // * `buffer` is a &'static [MaybeUninit<u8>] and fully initialized by the previous
-            //   line.
-            // * MaybeUninit::zeroed() is a valid initialized value for u8.
-            BufferInfo::Static(unsafe {
-                from_raw_parts_mut(buffer.as_mut_ptr() as _, buffer.len())
-            })
-        }
-        Ok(EfiImageBufferInfo::AllocSize(sz)) if sz != 0 => BufferInfo::Alloc(sz),
-        _ => BufferInfo::Alloc(default_aloc_size),
-    }
-}
diff --git a/gbl/fake_modules/protobuf/MODULE.bazel b/gbl/fake_modules/protobuf/MODULE.bazel
deleted file mode 100644
index cc8f9cf..0000000
--- a/gbl/fake_modules/protobuf/MODULE.bazel
+++ /dev/null
@@ -1 +0,0 @@
-module(name = "protobuf")
diff --git a/gbl/fake_modules/protobuf/bazel/BUILD.bazel b/gbl/fake_modules/protobuf/bazel/BUILD.bazel
deleted file mode 100644
index 65c9c6c..0000000
--- a/gbl/fake_modules/protobuf/bazel/BUILD.bazel
+++ /dev/null
@@ -1,5 +0,0 @@
-bzl_library(
-    name = "cc_proto_library_bzl",
-    srcs = ["cc_proto_library.bzl"],
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/fake_modules/protobuf/bazel/cc_proto_library.bzl b/gbl/fake_modules/protobuf/bazel/cc_proto_library.bzl
deleted file mode 100644
index 7723d12..0000000
--- a/gbl/fake_modules/protobuf/bazel/cc_proto_library.bzl
+++ /dev/null
@@ -1,2 +0,0 @@
-"""Fake cc_proto_library."""
-cc_proto_library = None
diff --git a/gbl/fake_modules/rules_java/MODULE.bazel b/gbl/fake_modules/rules_java/MODULE.bazel
deleted file mode 100644
index 622763c..0000000
--- a/gbl/fake_modules/rules_java/MODULE.bazel
+++ /dev/null
@@ -1 +0,0 @@
-module(name = "rules_java")
diff --git a/gbl/fake_modules/rules_kotlin/MODULE.bazel b/gbl/fake_modules/rules_kotlin/MODULE.bazel
deleted file mode 100644
index 9c55bb6..0000000
--- a/gbl/fake_modules/rules_kotlin/MODULE.bazel
+++ /dev/null
@@ -1 +0,0 @@
-module(name = "rules_kotlin")
diff --git a/gbl/integration/aosp_uefi-gbl-mainline/BUILD b/gbl/integration/aosp_uefi-gbl-mainline/BUILD
deleted file mode 100644
index e69de29..0000000
diff --git a/gbl/integration/aosp_uefi-gbl-mainline/workspace.bzl b/gbl/integration/aosp_uefi-gbl-mainline/workspace.bzl
deleted file mode 100644
index 3229325..0000000
--- a/gbl/integration/aosp_uefi-gbl-mainline/workspace.bzl
+++ /dev/null
@@ -1,514 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""
-This file contains rules and logic for setting up GBL workspace dependencies in the AOSP
-u-boot-mainline branch.
-"""
-
-load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
-load("@gbl//toolchain:gbl_workspace_util.bzl", "android_rust_prebuilts", "gbl_llvm_prebuilts")
-
-_CLANG_VERSION = "r547379"
-
-def rust_crate_build_file(
-        name,
-        rule = "rust_library",
-        crate_name = "",
-        deps = [],
-        proc_macro_deps = [],
-        features = [],
-        edition = "2021",
-        rustc_flags = []):
-    """Generate BUILD file content for a rust crate
-
-    This helper is suitable for crates that have straightforward build rules. Specifically, the
-    crate contains a single Rust target that includes all source files under the repo.
-    There is not any need of preprocessing, patching or source generation.
-
-    Args:
-        name (String): name of the rust_library target.
-        rule (String): Bazel Rust rule to build, defaults to `rust_library`.
-        crate_name (String): name of the rust_library crate, same as name by default.
-        deps (List of strings): The `deps` field.
-        proc_macro_deps (List of strings): The `proc_macro_deps` field.
-        features (List of strings): The `features` field.
-        edition (String): Rust edition.
-        rustc_flags (List of strings): The `rustc_flags` field.
-
-    Returns:
-        A string for the BUILD file content.
-    """
-    crate_name = name if len(crate_name) == 0 else crate_name
-    deps = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in deps]))
-    proc_macro_deps = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in proc_macro_deps]))
-    features = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in features]))
-    rustc_flags = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in rustc_flags]))
-    return """
-load("@rules_rust//rust:defs.bzl", \"{rule}\")
-
-{rule}(
-    name = \"{}\",
-    crate_name = \"{}\",
-    srcs = glob(["**/*.rs"]),
-    crate_features = {},
-    edition = \"{edition}\",
-    rustc_flags = {},
-    visibility = ["//visibility:public"],
-    deps = {},
-    proc_macro_deps = {}
-)
-""".format(name, crate_name, features, rustc_flags, deps, proc_macro_deps, edition = edition, rule = rule)
-
-def define_gbl_workspace(name = None):
-    """Set up worksapce dependencies for GBL
-
-    Dependencies are checked out during "repo init". The rule simply maps them to the correct repo
-    names.
-
-    Args:
-        name (String): Placeholder for buildifier check.
-    """
-    maybe(
-        repo_rule = native.local_repository,
-        name = "rules_rust",
-        path = "external/bazelbuild-rules_rust",
-    )
-
-    maybe(
-        repo_rule = native.local_repository,
-        name = "rules_shell",
-        path = "external/bazelbuild-rules_shell",
-    )
-
-    maybe(
-        repo_rule = native.local_repository,
-        name = "rules_license",
-        path = "external/bazelbuild-rules_license",
-    )
-
-    native.local_repository(
-        name = "googletest",
-        path = "external/googletest",
-    )
-
-    native.new_local_repository(
-        name = "rules_rust_tinyjson",
-        path = "external/rust/android-crates-io/crates/tinyjson",
-        build_file = "@rules_rust//util/process_wrapper:BUILD.tinyjson.bazel",
-    )
-
-    native.new_local_repository(
-        name = "llvm_linux_x86_64_prebuilts",
-        path = "prebuilts/clang/host/linux-x86/clang-{}".format(_CLANG_VERSION),
-        build_file_content = "",
-    )
-
-    native.new_local_repository(
-        name = "linux_x86_64_sysroot",
-        path = "prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.17-4.8",
-        build_file_content = """exports_files(glob(["**/*"]))
-cc_library(
-    name = "linux_x86_64_sysroot_include",
-    hdrs = glob(["sysroot/usr/include/**/*.h"]),
-    includes = [ "sysroot/usr/include" ],
-    visibility = ["//visibility:public"],
-)
-""",
-    )
-
-    android_rust_prebuilts(
-        name = "rust_prebuilts",
-        path = "prebuilts/rust/",
-        build_file = "@gbl//toolchain:BUILD.android_rust_prebuilts.bazel",
-    )
-
-    native.new_local_repository(
-        name = "bindgen",
-        path = "prebuilts/clang-tools/linux-x86/bin",
-        build_file_content = """exports_files(["bindgen"])""",
-    )
-
-    native.new_local_repository(
-        name = "elfutils",
-        path = "external/elfutils",
-        build_file_content = """
-cc_library(
-    name = "elf_type_header",
-    hdrs = ["libelf/elf.h"],
-    visibility = ["//visibility:public"],
-)
-""",
-    )
-
-    native.new_local_repository(
-        name = "mkbootimg",
-        path = "tools/mkbootimg",
-        build_file_content = """exports_files(glob(["**/*"]))""",
-    )
-
-    native.new_local_repository(
-        name = "libfdt_c",
-        path = "external/dtc/libfdt",
-        build_file = "@gbl//libfdt:BUILD.libfdt_c.bazel",
-    )
-
-    native.new_local_repository(
-        name = "libufdt_c",
-        path = "external/libufdt",
-        build_file = "@gbl//libfdt:BUILD.libufdt_c.bazel",
-    )
-
-    native.new_local_repository(
-        name = "libdttable_c",
-        path = "external/libufdt/utils/src",
-        build_file = "@gbl//libdttable:BUILD.libdttable_c.bazel",
-    )
-
-    native.new_local_repository(
-        name = "arm_trusted_firmware",
-        path = "external/arm-trusted-firmware",
-        build_file = "@gbl//libboot/aarch64_cache_helper:BUILD.arm_trusted_firmware.bazel",
-    )
-
-    native.new_local_repository(
-        name = "avb",
-        path = "external/avb",
-        build_file = "@gbl//libavb:BUILD.avb.bazel",
-    )
-
-    native.new_local_repository(
-        name = "uuid",
-        path = "external/rust/android-crates-io/crates/uuid",
-        build_file_content = rust_crate_build_file("uuid"),
-    )
-
-    native.new_local_repository(
-        name = "spin",
-        path = "external/rust/android-crates-io/crates/spin",
-        build_file_content = rust_crate_build_file(
-            "spin",
-            features = [
-                "mutex",
-                "spin_mutex",
-            ],
-            rustc_flags = [
-                "-A",
-                "unused_imports",
-            ],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "static_assertions",
-        path = "external/rust/android-crates-io/crates/static_assertions",
-        build_file_content = rust_crate_build_file("static_assertions"),
-    )
-
-    native.new_local_repository(
-        name = "managed",
-        path = "external/rust/android-crates-io/crates/managed",
-        build_file_content = rust_crate_build_file(
-            "managed",
-            features = ["map"],
-            rustc_flags = [
-                "-A",
-                "unused_macros",
-                "-A",
-                "redundant_semicolons",
-            ],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "itertools",
-        path = "external/rust/android-crates-io/crates/itertools",
-        build_file_content = rust_crate_build_file(
-            "itertools",
-            deps = ["@either"],
-            features = ["default", "use_std", "use_alloc"],
-            rustc_flags = ["-A", "dead_code"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "itertools_noalloc",
-        path = "external/rust/android-crates-io/crates/itertools",
-        build_file_content = rust_crate_build_file(
-            "itertools_noalloc",
-            crate_name = "itertools",
-            features = [],
-            deps = ["@either_noalloc"],
-            rustc_flags = ["-A", "dead_code"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "either",
-        path = "external/rust/android-crates-io/crates/either",
-        build_file_content = rust_crate_build_file(
-            "either",
-            features = ["default", "use_std"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "either_noalloc",
-        path = "external/rust/android-crates-io/crates/either",
-        build_file_content = rust_crate_build_file(
-            "either_noalloc",
-            crate_name = "either",
-            features = [],
-        ),
-    )
-
-    # TODO(b/383783832): migrate to android-crates-io
-    native.new_local_repository(
-        name = "smoltcp",
-        path = "external/rust/crates/smoltcp",
-        build_file = "@gbl//smoltcp:BUILD.smoltcp.bazel",
-    )
-
-    native.new_local_repository(
-        name = "arrayvec",
-        path = "external/rust/android-crates-io/crates/arrayvec",
-        build_file_content = rust_crate_build_file(
-            "arrayvec",
-            rustc_flags = ["-A", "dead_code"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "downcast",
-        path = "external/rust/android-crates-io/crates/downcast",
-        build_file_content = rust_crate_build_file(
-            "downcast",
-            features = ["default", "std"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "fragile",
-        path = "external/rust/android-crates-io/crates/fragile",
-        build_file_content = rust_crate_build_file("fragile"),
-    )
-
-    native.new_local_repository(
-        name = "lazy_static",
-        path = "external/rust/android-crates-io/crates/lazy_static",
-        build_file_content = rust_crate_build_file("lazy_static"),
-    )
-
-    native.new_local_repository(
-        name = "mockall",
-        path = "external/rust/android-crates-io/crates/mockall",
-        build_file_content = rust_crate_build_file(
-            "mockall",
-            deps = [
-                "@cfg_if",
-                "@downcast",
-                "@fragile",
-                "@lazy_static",
-                "@predicates",
-                "@predicates_tree",
-            ],
-            proc_macro_deps = ["@mockall_derive"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "mockall_derive",
-        path = "external/rust/android-crates-io/crates/mockall_derive",
-        build_file_content = rust_crate_build_file(
-            "mockall_derive",
-            rule = "rust_proc_macro",
-            deps = ["@cfg_if", "@proc_macro2", "@quote", "@syn"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "predicates",
-        path = "external/rust/android-crates-io/crates/predicates",
-        build_file_content = rust_crate_build_file(
-            "predicates",
-            deps = ["@itertools", "@predicates_core", "@termcolor"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "predicates_core",
-        path = "external/rust/android-crates-io/crates/predicates-core",
-        build_file_content = rust_crate_build_file("predicates_core"),
-    )
-
-    native.new_local_repository(
-        name = "predicates_tree",
-        path = "external/rust/android-crates-io/crates/predicates-tree",
-        build_file_content = rust_crate_build_file(
-            "predicates_tree",
-            deps = ["@predicates_core", "@termtree"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "termcolor",
-        path = "external/rust/android-crates-io/crates/termcolor",
-        build_file_content = rust_crate_build_file("termcolor"),
-    )
-
-    native.new_local_repository(
-        name = "termtree",
-        path = "external/rust/android-crates-io/crates/termtree",
-        build_file_content = rust_crate_build_file("termtree"),
-    )
-
-    # TODO(b/383783832): migrate to android-crates-io
-    native.new_local_repository(
-        name = "zune_inflate",
-        path = "external/rust/crates/zune-inflate",
-        build_file_content = rust_crate_build_file(
-            "zune_inflate",
-            features = ["gzip"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "lz4_flex",
-        path = "external/rust/android-crates-io/crates/lz4_flex",
-        build_file_content = rust_crate_build_file(
-            "lz4_flex",
-            features = ["safe-decode"],
-            rustc_flags = ["-A", "dead_code"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "zbi",
-        path = "prebuilts/fuchsia_sdk/",
-        build_file = "//prebuilts/fuchsia_sdk:BUILD.zbi.bazel",
-    )
-
-    native.new_local_repository(
-        name = "zerocopy",
-        path = "external/rust/android-crates-io/crates/zerocopy",
-        build_file_content = rust_crate_build_file(
-            "zerocopy",
-            features = ["derive", "simd", "zerocopy-derive"],
-            proc_macro_deps = ["@zerocopy_derive"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "zerocopy_derive",
-        path = "external/rust/android-crates-io/crates/zerocopy-derive",
-        build_file_content = rust_crate_build_file(
-            "zerocopy_derive",
-            rule = "rust_proc_macro",
-            deps = ["@proc_macro2", "@quote", "@syn"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "bitflags",
-        path = "external/rust/android-crates-io/crates/bitflags",
-        build_file_content = rust_crate_build_file("bitflags"),
-    )
-
-    native.new_local_repository(
-        name = "byteorder",
-        path = "external/rust/android-crates-io/crates/byteorder",
-        build_file_content = rust_crate_build_file("byteorder"),
-    )
-
-    native.new_local_repository(
-        name = "cfg_if",
-        path = "external/rust/android-crates-io/crates/cfg-if",
-        build_file_content = rust_crate_build_file("cfg_if"),
-    )
-
-    native.new_local_repository(
-        name = "crc32fast",
-        path = "external/rust/android-crates-io/crates/crc32fast",
-        build_file_content = rust_crate_build_file(
-            "crc32fast",
-            deps = ["@cfg_if"],
-            # Current version of the crate doesn't compile with newer editions.
-            edition = "2015",
-        ),
-    )
-
-    native.new_local_repository(
-        name = "hex",
-        path = "external/rust/android-crates-io/crates/hex",
-        build_file_content = rust_crate_build_file(
-            "hex",
-            features = ["alloc", "default", "std"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "quote",
-        path = "external/rust/android-crates-io/crates/quote",
-        build_file_content = rust_crate_build_file(
-            "quote",
-            features = ["default", "proc-macro"],
-            deps = ["@proc_macro2"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "unicode_ident",
-        path = "external/rust/android-crates-io/crates/unicode-ident",
-        build_file_content = rust_crate_build_file("unicode_ident"),
-    )
-
-    native.new_local_repository(
-        name = "syn",
-        path = "external/rust/android-crates-io/crates/syn",
-        build_file_content = rust_crate_build_file(
-            "syn",
-            features = [
-                "clone-impls",
-                "default",
-                "derive",
-                "extra-traits",
-                "full",
-                "parsing",
-                "printing",
-                "proc-macro",
-                "quote",
-                "visit",
-                "visit-mut",
-            ],
-            deps = ["@proc_macro2", "@quote", "@unicode_ident"],
-        ),
-    )
-
-    native.new_local_repository(
-        name = "proc_macro2",
-        path = "external/rust/android-crates-io/crates/proc-macro2",
-        build_file_content = rust_crate_build_file(
-            "proc_macro2",
-            deps = ["@unicode_ident"],
-            features = ["default", "proc-macro", "span-locations"],
-        ),
-    )
-
-    # Set up a repo to export LLVM tool/library/header/sysroot paths
-    gbl_llvm_prebuilts(name = "gbl_llvm_prebuilts")
-
-    # We don't register GBL toolchains here because they will be masked by toolchains from
-    # `build/kleaf//:` as they are registered earlier. Instead, we will pass GBL toolchains via
-    # bazel commandline argument "--extra_toolchains=@gbl//toolchain:all" when building GBL
-    # targets, which allows them to be evaluated first during toolchain resolution.
diff --git a/gbl/libabr/BUILD b/gbl/libabr/BUILD
deleted file mode 100644
index ef1c491..0000000
--- a/gbl/libabr/BUILD
+++ /dev/null
@@ -1,68 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_static_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libabr",
-    srcs = ["src/lib.rs"],
-    crate_name = "abr",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//liberror",
-    ],
-)
-
-rust_test(
-    name = "libabr_test",
-    crate = ":libabr",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-)
-
-rust_static_library(
-    name = "libabr_c",
-    srcs = [
-        "src/c_staticlib.rs",
-        "src/utils.rs",
-    ],
-    crate_name = "abr_c",
-    crate_root = "src/c_staticlib.rs",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":libabr",
-        "@gbl//liberror",
-    ],
-)
-
-rust_test(
-    name = "libabr_c_test",
-    crate = ":libabr_c",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
-
-test_suite(
-    name = "libabr_tests",
-    tests = [
-        ":libabr_c_test",
-        ":libabr_test",
-    ],
-)
diff --git a/gbl/libabr/build/fuchsia/BUILD.gn b/gbl/libabr/build/fuchsia/BUILD.gn
deleted file mode 100644
index 78cbe61..0000000
--- a/gbl/libabr/build/fuchsia/BUILD.gn
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import("//build/rust/rustc_library.gni")
-import("//build/rust/rustc_staticlib.gni")
-
-rustc_library("libabr") {
-  edition = "2021"
-  name = "abr"
-  source_root = "../../src/lib.rs"
-  sources = [ "../../src/lib.rs" ]
-}
-
-config("panic_as_abort") {
-  rustflags = [ "-Cpanic=abort" ]
-}
-
-rustc_staticlib("libabr_c") {
-  edition = "2021"
-  name = "abr"
-  source_root = "../../src/c_staticlib.rs"
-  sources = [
-    "../../src/c_staticlib.rs",
-    "../../src/utils.rs",
-  ]
-  deps = [ ":libabr" ]
-  configs += [":panic_as_abort"]
-}
diff --git a/gbl/libabr/src/c_staticlib.rs b/gbl/libabr/src/c_staticlib.rs
deleted file mode 100644
index 0c9299c..0000000
--- a/gbl/libabr/src/c_staticlib.rs
+++ /dev/null
@@ -1,515 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides C interface wrappers of libabr APIs.
-
-#![cfg_attr(not(test), no_std)]
-
-use abr::{
-    get_and_clear_one_shot_flag, get_boot_slot, get_slot_info, get_slot_last_marked_active,
-    mark_slot_active, mark_slot_successful, mark_slot_unbootable, set_one_shot_bootloader,
-    set_one_shot_recovery, AbrData, AbrSlotData, Ops, SlotIndex, SlotInfo as AbrSlotInfo,
-    SlotState, ABR_DATA_SIZE,
-};
-use core::{
-    ffi::{c_char, c_uint, c_void},
-    fmt::Write,
-};
-use liberror::{Error, Result};
-
-pub mod utils;
-
-pub const ABR_RESULT_OK: c_uint = 0;
-pub const ABR_RESULT_ERR_IO: c_uint = 1;
-pub const ABR_RESULT_ERR_INVALID_DATA: c_uint = 2;
-pub const ABR_RESULT_ERR_UNSUPPORTED_VERSION: c_uint = 3;
-
-// ABR system dependencies.
-//
-// These correspond to the definitions in Fuchsia upstream header
-// "src/firmware/lib/abr/include/lib/abr/sysdeps.h", which will eventually migrate over.
-extern "C" {
-    /// Prints out a NULL-terminated string.
-    pub fn AbrPrint(message: *const c_char);
-
-    /// Aborts the program or reboots the device if |abort| is not implemented.
-    pub fn AbrAbort();
-}
-
-/// A helper to print an ASCII character via `AbrPrint()`.
-fn abr_print_ascii_char(ch: u8) {
-    let s = [ch, 0];
-    // SAFETY:
-    // * `s` is a valid buffer
-    // * `s` is for input only and will not be retained by the function.
-    unsafe { AbrPrint(s.as_ptr() as _) }
-}
-
-/// A helper structure that implements formatted write using `AbrPrint()`.
-struct AbrPrintSysdeps {}
-
-impl Write for AbrPrintSysdeps {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        if s.is_ascii() {
-            s.as_bytes().iter().for_each(|v| abr_print_ascii_char(*v));
-        }
-        Ok(())
-    }
-}
-
-/// A panic handler is needed when building as a static library. We simply call into
-/// the AbrAbort() system dependency.
-#[cfg(not(test))]
-#[panic_handler]
-fn panic(panic: &core::panic::PanicInfo<'_>) -> ! {
-    write!(AbrPrintSysdeps {}, "libabr panics! {}", panic).unwrap();
-    // SAFETY: Call to external C function. The function simply aborts/reboots the system.
-    unsafe { AbrAbort() };
-    unreachable!()
-}
-
-/// This corresponds to the `AbrOps` C definition in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/ops.h", which will eventually migrate over.
-///
-/// typedef struct AbrOps {
-///     void* context;
-///     bool (*read_abr_metadata)(void* context, size_t size, uint8_t* buffer);
-///     bool (*write_abr_metadata)(void* context, const uint8_t* buffer, size_t size);
-///     bool (*read_abr_metadata_custom)(void* context, AbrSlotData* a_slot_data,
-///                                      AbrSlotData* b_slot_data, uint8_t* one_shot_flags);
-///     bool (*write_abr_metadata_custom)(void* context, const AbrSlotData* a_slot_data,
-///                                       const AbrSlotData* b_slot_data, uint8_t one_shot_flags);
-/// } AbrOps;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct AbrOps {
-    pub context: *mut c_void,
-    pub read_abr_metadata:
-        Option<unsafe extern "C" fn(context: *mut c_void, size: usize, buffer: *mut u8) -> bool>,
-    pub write_abr_metadata:
-        Option<unsafe extern "C" fn(context: *mut c_void, buffer: *const u8, size: usize) -> bool>,
-    pub read_abr_metadata_custom: Option<
-        unsafe extern "C" fn(
-            context: *mut c_void,
-            a_slot_data: *mut AbrSlotData,
-            b_slot_data: *mut AbrSlotData,
-            one_shot_flags: *mut u8,
-        ) -> bool,
-    >,
-    pub write_abr_metadata_custom: Option<
-        unsafe extern "C" fn(
-            context: *mut c_void,
-            a_slot_data: *const AbrSlotData,
-            b_slot_data: *const AbrSlotData,
-            one_shot_flags: u8,
-        ) -> bool,
-    >,
-}
-
-/// `AbrOpsSafe` wraps a reference to `AbrOps` and is created by an unsafe constructor that
-/// establishes necessary safety invariants on `AbrOps`.
-struct AbrOpsSafe<'a> {
-    ops: &'a AbrOps,
-    log: AbrPrintSysdeps,
-}
-
-impl<'a> AbrOpsSafe<'a> {
-    /// Creates a new instance from a reference to `AbrOps`.
-    ///
-    /// # Safety
-    ///
-    /// * Caller must make sure that `ops.context` is either not used, or points to a valid and
-    ///   correct type of value needed by `ops.read_abr_metadata`, `ops.write_abr_metadata`,
-    ///   `ops.read_abr_metadata_custom` and `ops.write_abr_metadata_custom`.
-    unsafe fn new(ops: &'a AbrOps) -> Self {
-        Self { ops, log: AbrPrintSysdeps {} }
-    }
-}
-
-type AbrSlotIndex = c_uint;
-
-impl Ops for AbrOpsSafe<'_> {
-    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
-        if let Some(f) = self.ops.read_abr_metadata.as_ref() {
-            // SAFETY:
-            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
-            //   or a valid pointer to a correct type of object used by
-            //   `self.ops.write_abr_metadata`.
-            // * `out` is a valid buffer
-            // * `out` is for reading data only and will not be retained by the function.
-            match unsafe { f(self.ops.context, out.len(), out.as_mut_ptr() as _) } {
-                false => Err(Error::Other(Some("read_abr_metadata() failed"))),
-                _ => Ok(()),
-            }
-        } else if let Some(f) = self.ops.read_abr_metadata_custom.as_ref() {
-            let mut data: AbrData = Default::default();
-            // SAFETY:
-            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
-            //   or a valid pointer to a correct type of object used by
-            //   `self.ops.read_abr_metadata_custom`.
-            // * Pointers to `slot_a`, `slot_b` and `one_shot_flags` are a valid memory locations.
-            // * `slot_a`, `slot_b` and `one_shot_flags` are for output and will not be retained by
-            //   the function.
-            match unsafe {
-                f(
-                    self.ops.context,
-                    &mut data.slot_data[SlotIndex::A as usize],
-                    &mut data.slot_data[SlotIndex::B as usize],
-                    &mut data.one_shot_flags,
-                )
-            } {
-                false => Err(Error::Other(Some("read_abr_metadata_custom() failed"))),
-                _ => Ok(out[..ABR_DATA_SIZE].clone_from_slice(&data.serialize())),
-            }
-        } else {
-            Err(Error::NotImplemented)
-        }
-    }
-
-    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
-        if let Some(f) = self.ops.write_abr_metadata.as_ref() {
-            // SAFETY:
-            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
-            //   or a valid pointer to a correct type of object used by
-            //   `self.ops.write_abr_metadata`.
-            // * `data` is a valid buffer.
-            // * `data` is for input only and will not be retained by the function.
-            match unsafe { f(self.ops.context, data.as_ptr() as _, data.len()) } {
-                false => Err(Error::Other(Some("write_abr_metadata() failed"))),
-                _ => Ok(()),
-            }
-        } else if let Some(f) = self.ops.write_abr_metadata_custom.as_ref() {
-            let mut abr_data = [0u8; ABR_DATA_SIZE];
-            abr_data.clone_from_slice(
-                data.get(..ABR_DATA_SIZE).ok_or(Error::BufferTooSmall(Some(ABR_DATA_SIZE)))?,
-            );
-            let abr_data = AbrData::deserialize(&mut abr_data).unwrap();
-            // SAFETY:
-            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
-            //   or a valid pointer to a correct type of object used by
-            //   `self.ops.write_abr_metadata_custom`.
-            // * Pointers to `slot_a` and `slot_b` are a valid memory locations.
-            // * `slot_a` and `slot_b` are for input and will not be retained by the function.
-            match unsafe {
-                f(
-                    self.ops.context,
-                    &abr_data.slot_data[SlotIndex::A as usize],
-                    &abr_data.slot_data[SlotIndex::B as usize],
-                    abr_data.one_shot_flags,
-                )
-            } {
-                false => Err(Error::Other(Some("read_abr_metadata_custom() failed"))),
-                _ => Ok(()),
-            }
-        } else {
-            Err(Error::NotImplemented)
-        }
-    }
-
-    fn console(&mut self) -> Option<&mut dyn core::fmt::Write> {
-        Some(&mut self.log)
-    }
-}
-
-/// A helper that extracts the return value and maps the result to an integer A/B/R result code.
-fn unpack_result<T: Into<O>, O>(res: Result<T>, val: &mut O) -> c_uint {
-    match res {
-        Err(e) => match e {
-            Error::BadMagic | Error::BadChecksum | Error::InvalidInput => {
-                ABR_RESULT_ERR_INVALID_DATA
-            }
-            Error::UnsupportedVersion => ABR_RESULT_ERR_UNSUPPORTED_VERSION,
-            _ => ABR_RESULT_ERR_IO,
-        },
-        Ok(v) => {
-            *val = v.into();
-            ABR_RESULT_OK
-        }
-    }
-}
-
-/// C interface wrapper of `abr::get_boot_slot()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-/// * Caller must make sure to pass either a NULL or valid pointer for `is_slot_marked_successful`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrGetBootSlot(
-    abr_ops: *const AbrOps,
-    update_metadata: bool,
-    is_slot_marked_successful: *mut bool,
-) -> AbrSlotIndex {
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-
-    let (slot_index, successful) = get_boot_slot(&mut abr_ops, update_metadata);
-    // SAFETY: function safety requires `out_slot` to be a valid pointer or `NULL`.
-    match unsafe { is_slot_marked_successful.as_mut() } {
-        Some(v) => *v = successful,
-        _ => {}
-    };
-    slot_index.into()
-}
-
-// NULL terminated strings for slot suffixes.
-const SLOT_A_SUFFIX: &[u8] = b"_a\0";
-const SLOT_B_SUFFIX: &[u8] = b"_b\0";
-const SLOT_R_SUFFIX: &[u8] = b"_r\0";
-const SLOT_SUFFIX_INVALID: &[u8] = b"\0";
-
-/// C interface for getting slot suffix.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub extern "C" fn AbrGetSlotSuffix(slot_index: AbrSlotIndex) -> *const c_char {
-    match slot_index.try_into() {
-        Ok(SlotIndex::A) => &SLOT_A_SUFFIX,
-        Ok(SlotIndex::B) => &SLOT_B_SUFFIX,
-        Ok(SlotIndex::R) => &SLOT_R_SUFFIX,
-        Err(_) => &SLOT_SUFFIX_INVALID,
-    }
-    .as_ptr() as _
-}
-
-/// C interface wrapper of `abr::mark_slot_active()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrMarkSlotActive(
-    abr_ops: *const AbrOps,
-    slot_index: AbrSlotIndex,
-) -> c_uint {
-    let slot_index = match slot_index.try_into() {
-        Ok(v) => v,
-        Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
-    };
-
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-
-    unpack_result(mark_slot_active(&mut abr_ops, slot_index), &mut ())
-}
-
-/// C interface wrapper of `abr::get_slot_last_marked_active()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops` and `out_slot`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrGetSlotLastMarkedActive(
-    abr_ops: *const AbrOps,
-    out_slot: *mut AbrSlotIndex,
-) -> c_uint {
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-    // SAFETY: function safety requires `out_slot` to be a valid pointer.
-    let out_slot = unsafe { out_slot.as_mut() }.unwrap();
-
-    unpack_result(get_slot_last_marked_active(&mut abr_ops), out_slot)
-}
-
-/// C interface wrapper of `abr::mark_slot_unbootable()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrMarkSlotUnbootable(
-    abr_ops: *const AbrOps,
-    slot_index: AbrSlotIndex,
-) -> c_uint {
-    let slot_index = match slot_index.try_into() {
-        Ok(v) => v,
-        Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
-    };
-
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-
-    unpack_result(mark_slot_unbootable(&mut abr_ops, slot_index), &mut ())
-}
-
-/// C interface wrapper of `abr::mark_slot_successful()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrMarkSlotSuccessful(
-    abr_ops: *const AbrOps,
-    slot_index: AbrSlotIndex,
-) -> c_uint {
-    let slot_index = match slot_index.try_into() {
-        Ok(v) => v,
-        Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
-    };
-
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-
-    unpack_result(mark_slot_successful(&mut abr_ops, slot_index), &mut ())
-}
-
-/// `SlotInfo` contains the current state of a A/B/R slot.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct SlotInfo {
-    /// Whether the slot is expected to be bootable.
-    pub is_bootable: bool,
-    /// Whether the slot is the highest priority A/B slot.
-    pub is_active: bool,
-    /// Whether the slot is currently marked successful.
-    pub is_marked_successful: bool,
-    /// If not marked successful, this represents the number of attempts left for booting this slot.
-    pub num_tries_remaining: u8,
-}
-
-impl From<AbrSlotInfo> for SlotInfo {
-    fn from(val: abr::SlotInfo) -> Self {
-        let is_marked_successful = matches!(val.state, SlotState::Successful);
-        let num_tries_remaining = match val.state {
-            SlotState::Bootable(v) => v,
-            _ => 0,
-        };
-        Self {
-            is_bootable: is_marked_successful || num_tries_remaining > 0,
-            is_active: val.is_active,
-            is_marked_successful,
-            num_tries_remaining,
-        }
-    }
-}
-
-/// C interface wrapper of `abr::get_slot_info()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops` and 'info'.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrGetSlotInfo(
-    abr_ops: *const AbrOps,
-    slot_index: AbrSlotIndex,
-    info: *mut SlotInfo,
-) -> c_uint {
-    let slot_index = match slot_index.try_into() {
-        Ok(v) => v,
-        Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
-    };
-
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-    // SAFETY: function safety requires `info` to be a valid pointer.
-    let info = unsafe { info.as_mut() }.unwrap();
-
-    unpack_result(get_slot_info(&mut abr_ops, slot_index).map(|v| SlotInfo::from(v)), info)
-}
-
-/// C interface wrapper of `abr::set_one_shot_recovery()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrSetOneShotRecovery(abr_ops: *const AbrOps, enable: bool) -> c_uint {
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-
-    unpack_result(set_one_shot_recovery(&mut abr_ops, enable), &mut ())
-}
-
-/// C interface wrapper of `abr::set_one_shot_bootloader()`
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrSetOneShotBootloader(abr_ops: *const AbrOps, enable: bool) -> c_uint {
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-
-    unpack_result(set_one_shot_bootloader(&mut abr_ops, enable), &mut ())
-}
-
-/// Gets and clears the one shot flag.
-///
-/// # Safety
-///
-/// * Caller must make sure to pass a valid pointer for `abr_ops` and `flags`.
-/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
-///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrGetAndClearOneShotFlags(
-    abr_ops: *const AbrOps,
-    flags: *mut c_uint,
-) -> c_uint {
-    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
-    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
-    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
-    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
-    // SAFETY: function safety requires `flags` to be a valid pointer.
-    let flags = unsafe { flags.as_mut() }.unwrap();
-
-    unpack_result(get_and_clear_one_shot_flag(&mut abr_ops), flags)
-}
-
-// Needed because of no-std environment in static lib build.
-#[cfg(not(test))]
-#[no_mangle]
-pub extern "C" fn rust_eh_personality() {}
diff --git a/gbl/libabr/src/lib.rs b/gbl/libabr/src/lib.rs
deleted file mode 100644
index d836ad9..0000000
--- a/gbl/libabr/src/lib.rs
+++ /dev/null
@@ -1,743 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Fuchsia A/B/R boot slot library.
-
-#![cfg_attr(not(test), no_std)]
-
-use core::{cmp::min, ffi::c_uint, ffi::CStr, fmt::Write, mem::size_of};
-use liberror::{Error, Result};
-
-const ABR_MAGIC: &[u8; 4] = b"\0AB0";
-const ABR_MAJOR_VERSION: u8 = 2;
-const ABR_MINOR_VERSION: u8 = 2;
-
-// The following flags are harcoded as u8 instead of using the bitflag crate to avoid additional
-// crate dependency and improve portability.
-
-/// One-shot recovery boot bit for the flag returned by `get_and_clear_one_shot_flag()`.
-pub const ONE_SHOT_RECOVERY: u8 = 1 << 0;
-/// One-shot bootloader boot bit for the flag returned by `get_and_clear_one_shot_flag()`.
-pub const ONE_SHOT_BOOTLOADER: u8 = 1 << 1;
-
-const ABR_MAX_PRIORITY: u8 = 15;
-/// Maximum number of retries.
-pub const ABR_MAX_TRIES_REMAINING: u8 = 7;
-
-/// `Ops` provides the backend interfaces needed by A/B/R APIs.
-pub trait Ops {
-    /// Reads exactly `out.len()` bytes into `out` from the persistent storage hosting the A/B/R
-    /// metadata.
-    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()>;
-
-    /// Writes exactly `data.len()` bytes from `data` to the persistent storage hosting the A/B/R
-    /// metadata.
-    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()>;
-
-    /// Returns an optional console writer for logging error messages.
-    fn console(&mut self) -> Option<&mut dyn Write>;
-}
-
-impl Ops for [u8; ABR_DATA_SIZE] {
-    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
-        Ok(out
-            .clone_from_slice(self.get(..out.len()).ok_or(Error::BufferTooSmall(Some(out.len())))?))
-    }
-
-    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
-        Ok(self
-            .get_mut(..data.len())
-            .ok_or(Error::BufferTooSmall(Some(data.len())))?
-            .clone_from_slice(data))
-    }
-
-    fn console(&mut self) -> Option<&mut dyn Write> {
-        None
-    }
-}
-
-/// Helper macro for printing ABR log messages.
-macro_rules! avb_print {
-    ( $abr_ops:expr, $( $x:expr ),* $(,)? ) => {
-            match $abr_ops.console() {
-                Some(f) => write!(f, $($x,)*).unwrap(),
-                _ => {}
-            }
-    };
-}
-
-/// `SlotIndex` represents the A/B/R slot index.
-#[derive(Copy, Clone, Eq, PartialEq, Debug)]
-pub enum SlotIndex {
-    /// A slot; normal boot.
-    A,
-    /// B slot; normal boot.
-    B,
-    /// R slot; recovery boot. Doesn't have any associated metadata (e.g. cannot be active, no
-    /// retries), but is unconditionally used as a fallback if both A and B are unbootable.
-    R,
-}
-
-impl SlotIndex {
-    // Get the other counterpart of a A/B slot.
-    fn other(&self) -> Self {
-        match self {
-            SlotIndex::A => SlotIndex::B,
-            SlotIndex::B => SlotIndex::A,
-            _ => panic!("Invalid slot index for `fn other()`"),
-        }
-    }
-}
-
-// Implement conversion to c_uint for C interfaces
-impl From<SlotIndex> for c_uint {
-    fn from(val: SlotIndex) -> Self {
-        match val {
-            SlotIndex::A => 0,
-            SlotIndex::B => 1,
-            SlotIndex::R => 2,
-        }
-    }
-}
-
-// Implement conversion to char
-impl From<SlotIndex> for char {
-    fn from(val: SlotIndex) -> Self {
-        match val {
-            SlotIndex::A => 'a',
-            SlotIndex::B => 'b',
-            SlotIndex::R => 'r',
-        }
-    }
-}
-
-// Implement conversion to c string suffix.
-impl From<SlotIndex> for &CStr {
-    fn from(s: SlotIndex) -> Self {
-        match s {
-            SlotIndex::A => c"_a",
-            SlotIndex::B => c"_b",
-            SlotIndex::R => c"_r",
-        }
-    }
-}
-
-// Implement conversion from char.
-impl TryFrom<char> for SlotIndex {
-    type Error = Error;
-
-    fn try_from(val: char) -> Result<Self> {
-        match val {
-            'a' => Ok(SlotIndex::A),
-            'b' => Ok(SlotIndex::B),
-            'r' => Ok(SlotIndex::R),
-            _ => Err(Error::InvalidInput),
-        }
-    }
-}
-
-// Implement conversion from c_uint for C interfaces.
-impl TryFrom<c_uint> for SlotIndex {
-    type Error = Error;
-
-    fn try_from(val: c_uint) -> Result<SlotIndex> {
-        match val {
-            v if v == (SlotIndex::A).into() => Ok(SlotIndex::A),
-            v if v == (SlotIndex::B).into() => Ok(SlotIndex::B),
-            v if v == (SlotIndex::R).into() => Ok(SlotIndex::R),
-            _ => Err(Error::InvalidInput),
-        }
-    }
-}
-
-/// `SlotInfo` represents the current state of a A/B/R slot.
-pub enum SlotState {
-    /// Slot has successfully booted.
-    Successful,
-    /// Slot can be attempted but is not known to be successful. Contained value is the number
-    /// of boot attempts remaining before being marked as `Unbootable`.
-    Bootable(u8),
-    /// Slot is unbootable.
-    Unbootable,
-}
-
-/// `SlotInfo` contains the current state and active status of a A/B/R slot.
-pub struct SlotInfo {
-    /// The [SlotState] describing the bootability.
-    pub state: SlotState,
-    /// Whether this is currently the active slot.
-    pub is_active: bool,
-}
-
-/// `AbrSlotData` is the wire format metadata for A/B slot.
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)]
-pub struct AbrSlotData {
-    /// Slot priority. Unbootable slots should always have priority 0.
-    pub priority: u8,
-    /// Boot attempts remaining.
-    pub tries_remaining: u8,
-    /// Whether this slot is known successful.
-    pub successful_boot: u8,
-    /// Reserved for future use; must be set to 0.
-    pub reserved: u8,
-}
-
-const ABR_SLOT_DATA_SIZE: usize = size_of::<AbrSlotData>();
-
-impl AbrSlotData {
-    /// Parses from bytes.
-    pub fn deserialize(bytes: &[u8; ABR_SLOT_DATA_SIZE]) -> Self {
-        Self {
-            priority: bytes[0],
-            tries_remaining: bytes[1],
-            successful_boot: bytes[2],
-            reserved: bytes[3],
-        }
-    }
-
-    /// Serializes to bytes.
-    pub fn serialize(&self) -> [u8; ABR_SLOT_DATA_SIZE] {
-        [self.priority, self.tries_remaining, self.successful_boot, self.reserved]
-    }
-
-    /// Returns if slot is bootable
-    fn is_slot_bootable(&self) -> bool {
-        self.priority > 0 && (self.successful_boot == 1 || self.tries_remaining > 0)
-    }
-
-    fn set_slot_unbootable(&mut self) {
-        self.tries_remaining = 0;
-        self.successful_boot = 0;
-    }
-
-    /// Gets normalized priority.
-    fn get_normalized_priority(&self) -> u8 {
-        match self.is_slot_bootable() {
-            true => self.priority,
-            _ => 0,
-        }
-    }
-
-    /// Ensures all unbootable or invalid states are marked as the canonical `unbootable` state.
-    /// That is priority=0, tries_remaining=0, and successful_boot=0.
-    fn slot_normalize(&mut self) {
-        if self.priority > 0 {
-            if self.tries_remaining == 0 && self.successful_boot == 0 {
-                // All tries exhausted
-                self.set_slot_unbootable();
-            }
-            if self.tries_remaining > 0 && self.successful_boot == 1 {
-                // Illegal state. Reset to not successful state
-                self.tries_remaining = ABR_MAX_TRIES_REMAINING;
-                self.successful_boot = 0;
-            }
-            self.priority = min(self.priority, ABR_MAX_PRIORITY);
-            self.tries_remaining = min(self.tries_remaining, ABR_MAX_TRIES_REMAINING);
-        } else {
-            self.set_slot_unbootable();
-        }
-    }
-}
-
-/// `AbrData` is the wire format of A/B/R metadata.
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, Eq, PartialEq)]
-pub struct AbrData {
-    /// Magic value; must be [ABR_MAGIC].
-    pub magic: [u8; 4],
-    /// Metadata major version, incremented when changes may break backwards compatibility.
-    pub version_major: u8,
-    /// Metadata minor version, incremented when changes do not break backwards compatibility.
-    pub version_minor: u8,
-    /// Reserved for future use; must be 0.
-    pub reserved: [u8; 2],
-    /// A/B slot data.
-    pub slot_data: [AbrSlotData; 2],
-    /// One-shot to bootloader/recovery.
-    pub one_shot_flags: u8,
-    /// Reserved for future use; must be 0.
-    pub reserved2: [u8; 11],
-    /// CRC32 checksum of this struct.
-    pub crc32: u32,
-}
-
-/// Size of `AbrData`
-pub const ABR_DATA_SIZE: usize = size_of::<AbrData>();
-
-impl AbrData {
-    /// Returns the numeric index value for a `SlotIndex`. This is for indexing into
-    /// `Self::slot_data`.
-    fn slot_num_index(slot_index: SlotIndex) -> usize {
-        match slot_index {
-            SlotIndex::A => 0,
-            SlotIndex::B => 1,
-            _ => panic!("Invalid slot index"),
-        }
-    }
-
-    /// Returns a const reference to `Self::slot_data['slot_index']`
-    fn slot_data(&self, slot_index: SlotIndex) -> &AbrSlotData {
-        &self.slot_data[Self::slot_num_index(slot_index)]
-    }
-
-    /// Returns a mutable reference to `Self::slot_data[`slot_index`]`
-    fn slot_data_mut(&mut self, slot_index: SlotIndex) -> &mut AbrSlotData {
-        &mut self.slot_data[Self::slot_num_index(slot_index)]
-    }
-
-    /// Reads, parses and checks metadata from persistent storage.
-    pub fn deserialize(abr_ops: &mut dyn Ops) -> Result<Self> {
-        let mut bytes = [0u8; ABR_DATA_SIZE];
-        abr_ops.read_abr_metadata(&mut bytes[..])?;
-        // Usually, the parsing below should be done using the zerocopy crate. However, the Fuchsia
-        // source tree uses the unreleased alpha/beta version of zerocopy which can have
-        // drastically different usage and bound requirements. In order to minimize maintenance
-        // burden for Android and Fuchsia build, we manually copy and parse from the bytes directly
-        // to avoid zerocopy crate dependency.
-        let res = Self {
-            magic: bytes[..4].try_into().unwrap(),
-            version_major: bytes[4],
-            version_minor: bytes[5],
-            reserved: bytes[6..8].try_into().unwrap(),
-            slot_data: [
-                AbrSlotData::deserialize(&bytes[8..12].try_into().unwrap()),
-                AbrSlotData::deserialize(&bytes[12..16].try_into().unwrap()),
-            ],
-            one_shot_flags: bytes[16],
-            reserved2: bytes[17..28].try_into().unwrap(),
-            crc32: u32::from_be_bytes(bytes[28..ABR_DATA_SIZE].try_into().unwrap()),
-        };
-
-        if res.magic != *ABR_MAGIC {
-            avb_print!(abr_ops, "Magic is incorrect.\n");
-            return Err(Error::BadMagic);
-        }
-        if res.crc32 != crc32(&bytes[..28]) {
-            avb_print!(abr_ops, "CRC32 does not match.\n");
-            return Err(Error::BadChecksum);
-        }
-        if res.version_major > ABR_MAJOR_VERSION {
-            avb_print!(abr_ops, "No support for given major version.\n");
-            return Err(Error::UnsupportedVersion);
-        }
-
-        Ok(res)
-    }
-
-    /// Updates CRC32 and writes metadata to persistent storage.
-    pub fn serialize(&mut self) -> [u8; ABR_DATA_SIZE] {
-        let mut res = [0u8; ABR_DATA_SIZE];
-        res[..4].clone_from_slice(&self.magic);
-        res[4] = self.version_major;
-        res[5] = self.version_minor;
-        res[6..8].clone_from_slice(&self.reserved);
-        res[8..12].clone_from_slice(&self.slot_data(SlotIndex::A).serialize());
-        res[12..16].clone_from_slice(&self.slot_data(SlotIndex::B).serialize());
-        res[16] = self.one_shot_flags;
-        res[17..28].clone_from_slice(&self.reserved2[..]);
-        self.crc32 = crc32(&res[..28]);
-        res[28..ABR_DATA_SIZE].clone_from_slice(&self.crc32.to_be_bytes());
-        res
-    }
-
-    /// Returns an invalid instance.
-    fn null() -> Self {
-        Self { magic: [0u8; 4], ..Default::default() }
-    }
-
-    /// Gets the active slot
-    fn get_active_slot(&self) -> SlotIndex {
-        let priority_a = self.slot_data(SlotIndex::A).get_normalized_priority();
-        let priority_b = self.slot_data(SlotIndex::B).get_normalized_priority();
-        if priority_b > priority_a {
-            return SlotIndex::B;
-        } else if priority_a > 0 {
-            return SlotIndex::A;
-        }
-        return SlotIndex::R;
-    }
-
-    /// Is the given slot active.
-    fn is_slot_active(&self, slot_index: SlotIndex) -> bool {
-        self.get_active_slot() == slot_index
-    }
-
-    /// Returns if one-shot recovery is set.
-    fn is_one_shot_recovery(&self) -> bool {
-        (self.one_shot_flags & ONE_SHOT_RECOVERY) != 0
-    }
-
-    /// Sets one-shot recovery.
-    pub fn set_one_shot_recovery(&mut self, enable: bool) {
-        match enable {
-            true => self.one_shot_flags |= ONE_SHOT_RECOVERY,
-            _ => self.one_shot_flags &= !ONE_SHOT_RECOVERY,
-        }
-    }
-
-    /// Sets one-shot bootloader
-    pub fn set_one_shot_bootloader(&mut self, enable: bool) {
-        match enable {
-            true => self.one_shot_flags |= ONE_SHOT_BOOTLOADER,
-            _ => self.one_shot_flags &= !ONE_SHOT_BOOTLOADER,
-        }
-    }
-}
-
-impl Default for AbrData {
-    fn default() -> Self {
-        Self {
-            magic: *ABR_MAGIC,
-            version_major: ABR_MAJOR_VERSION,
-            version_minor: ABR_MINOR_VERSION,
-            reserved: Default::default(),
-            slot_data: [
-                AbrSlotData {
-                    priority: ABR_MAX_PRIORITY,
-                    tries_remaining: ABR_MAX_TRIES_REMAINING,
-                    successful_boot: 0,
-                    reserved: 0,
-                },
-                AbrSlotData {
-                    priority: ABR_MAX_PRIORITY - 1,
-                    tries_remaining: ABR_MAX_TRIES_REMAINING,
-                    successful_boot: 0,
-                    reserved: 0,
-                },
-            ],
-            one_shot_flags: 0,
-            reserved2: Default::default(),
-            crc32: 0,
-        }
-    }
-}
-
-/// Loads |abr_data| from persistent storage and normalizes it, initializing new data if necessary.
-/// Changes as a result of normalization are not written back to persistent storage but a copy of
-/// the exact original data from persistent storage is provided in |abr_data_orig| for future use
-/// with save_metadata_if_changed().
-///
-/// On success returns Ok((abr_data, abr_data_orig)). On failure an Error is returned.
-fn load_metadata(abr_ops: &mut dyn Ops) -> Result<(AbrData, AbrData)> {
-    let mut abr_data_orig = AbrData::null();
-    let mut abr_data = match AbrData::deserialize(abr_ops) {
-        Ok(v) => {
-            abr_data_orig = v;
-            v
-        }
-        Err(Error::Other(e)) => {
-            avb_print!(abr_ops, "read_abr_metadata error: {:?}\n", e);
-            return Err(e.into());
-        }
-        Err(Error::UnsupportedVersion) => {
-            // We don't want to clobber valid data in persistent storage, but we can't use this
-            // data, so bail out.
-            return Err(Error::UnsupportedVersion);
-        }
-        _ => Default::default(),
-    };
-    abr_data.slot_data_mut(SlotIndex::A).slot_normalize();
-    abr_data.slot_data_mut(SlotIndex::B).slot_normalize();
-
-    Ok((abr_data, abr_data_orig))
-}
-
-/// Serializes and saves metadata to persistent storage.
-fn save_metadata(abr_ops: &mut dyn Ops, abr_data: &mut AbrData) -> Result<()> {
-    let mut bytes = abr_data.serialize();
-    abr_ops.write_abr_metadata(&mut bytes)?;
-    Ok(())
-}
-
-/// Writes metadata to disk only if it has changed. `abr_data_orig` should be from load_metadata().
-fn save_metadata_if_changed(
-    abr_ops: &mut dyn Ops,
-    abr_data: &mut AbrData,
-    abr_data_orig: &AbrData,
-) -> Result<()> {
-    match abr_data == abr_data_orig {
-        true => Ok(()),
-        _ => save_metadata(abr_ops, abr_data),
-    }
-}
-
-/// Equivalent to C API `AbrGetBootSlot()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_boot_slot(abr_ops: &mut dyn Ops, update_metadata: bool) -> (SlotIndex, bool) {
-    let mut is_slot_marked_successful = false;
-    let (mut abr_data, abr_data_orig) = match load_metadata(abr_ops) {
-        Ok(v) => v,
-        Err(e) => {
-            avb_print!(
-                abr_ops,
-                "Failed to load metadata {:?}, falling back to recovery mode.\n",
-                e
-            );
-            return (SlotIndex::R, is_slot_marked_successful);
-        }
-    };
-
-    if abr_data.is_one_shot_recovery() && update_metadata {
-        abr_data.set_one_shot_recovery(false);
-        match save_metadata(abr_ops, &mut abr_data) {
-            Ok(()) => return (SlotIndex::R, is_slot_marked_successful),
-            Err(e) => {
-                avb_print!(
-                    abr_ops,
-                    "Failed to update one-shot state {:?}. Ignoring one-shot request.\n",
-                    e
-                );
-                abr_data.set_one_shot_recovery(true);
-            }
-        }
-    }
-
-    // Chooses the highest priority and bootable slot. Otherwise R slot.
-    let slot_to_boot = abr_data.get_active_slot();
-    match slot_to_boot {
-        SlotIndex::R => {}
-        v => {
-            is_slot_marked_successful = abr_data.slot_data(v).successful_boot == 1;
-        }
-    };
-
-    if update_metadata {
-        // In addition to any changes that resulted from normalization, there are a couple changes
-        // to be made here. First is to decrement the tries remaining for a slot not yet marked as
-        // successful.
-        if slot_to_boot != SlotIndex::R && !is_slot_marked_successful {
-            let slot_data = abr_data.slot_data_mut(slot_to_boot);
-            slot_data.tries_remaining = slot_data.tries_remaining.checked_sub(1).unwrap();
-        }
-        // Second is to clear the successful_boot bit from any successfully-marked slots that
-        // aren't the slot we're booting. It's possible that booting from one slot will render the
-        // other slot unbootable (say, by migrating a config file format in a shared partiton).
-        // Clearing these bits minimizes the risk we'll have an unhealthy slot marked
-        // "successful_boot", which would prevent the system from automatically booting into
-        // recovery.
-        for slot in [SlotIndex::A, SlotIndex::B] {
-            if slot != slot_to_boot && abr_data.slot_data(slot).successful_boot == 1 {
-                abr_data.slot_data_mut(slot).tries_remaining = ABR_MAX_TRIES_REMAINING;
-                abr_data.slot_data_mut(slot).successful_boot = 0;
-            }
-        }
-        if let Err(e) = save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig) {
-            // We have no choice but to proceed without updating metadata.
-            avb_print!(abr_ops, "Failed to update metadata {:?}, proceeding anyways.\n", e);
-        }
-    }
-    (slot_to_boot, is_slot_marked_successful)
-}
-
-/// Equivalent to C API `AbrMarkSlotActive()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn mark_slot_active(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<()> {
-    if slot_index == SlotIndex::R {
-        avb_print!(abr_ops, "Invalid argument: Cannot mark slot R as active.\n");
-        return Err(Error::InvalidInput);
-    }
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-    // Make requested slot top priority, unsuccessful, and with max tries.
-    abr_data.slot_data_mut(slot_index).priority = ABR_MAX_PRIORITY;
-    abr_data.slot_data_mut(slot_index).tries_remaining = ABR_MAX_TRIES_REMAINING;
-    abr_data.slot_data_mut(slot_index).successful_boot = 0;
-
-    // Ensure other slot doesn't have as high a priority
-    let other = slot_index.other();
-    abr_data.slot_data_mut(other).priority =
-        min(abr_data.slot_data_mut(other).priority, ABR_MAX_PRIORITY - 1);
-
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
-}
-
-/// Equivalent to C API `AbrGetSlotLastMarkedActive()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_slot_last_marked_active(abr_ops: &mut dyn Ops) -> Result<SlotIndex> {
-    let (abr_data, _) = load_metadata(abr_ops)?;
-    Ok(
-        match abr_data.slot_data(SlotIndex::B).priority > abr_data.slot_data(SlotIndex::A).priority
-        {
-            true => SlotIndex::B,
-            false => SlotIndex::A,
-        },
-    )
-}
-
-/// Equivalent to C API `AbrMarkSlotUnbootable()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn mark_slot_unbootable(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<()> {
-    if slot_index == SlotIndex::R {
-        avb_print!(abr_ops, "Invalid argument: Cannot mark slot R as unbootable.\n");
-        return Err(Error::InvalidInput);
-    }
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-    abr_data.slot_data_mut(slot_index).set_slot_unbootable();
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
-}
-
-/// Equivalent to C API `AbrMarkSlotSuccessful()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn mark_slot_successful(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<()> {
-    if slot_index == SlotIndex::R {
-        avb_print!(abr_ops, "Invalid argument: Cannot mark slot R as successful.\n");
-        return Err(Error::InvalidInput);
-    }
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-
-    if !abr_data.slot_data(slot_index).is_slot_bootable() {
-        avb_print!(abr_ops, "Invalid argument: Cannot mark unbootable slot as successful.\n");
-        return Err(Error::InvalidInput);
-    }
-
-    abr_data.slot_data_mut(slot_index).tries_remaining = 0;
-    abr_data.slot_data_mut(slot_index).successful_boot = 1;
-
-    // Proactively remove any success mark on the other slot
-    //
-    // This can theoretically be removed since get_boot_slot() clear successful bit on non-boot
-    // slots. However, legacy devices might still be using old versions of ABR implementation that
-    // don't clear it. Therefore, we keep this logic to be safe.
-    //
-    // Context: https://fxbug.dev/42142842, https://crbug.com/fuchsia/64057.
-    let other = slot_index.other();
-    if abr_data.slot_data(other).is_slot_bootable() {
-        abr_data.slot_data_mut(other).tries_remaining = ABR_MAX_TRIES_REMAINING;
-        abr_data.slot_data_mut(other).successful_boot = 0;
-    }
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
-}
-
-/// Equivalent to C API `AbrGetSlotInfo()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_slot_info(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<SlotInfo> {
-    let (abr_data, _) = load_metadata(abr_ops)?;
-    Ok(match slot_index {
-        // Assume that R slot is always OK.
-        SlotIndex::R => SlotInfo {
-            state: SlotState::Successful,
-            is_active: abr_data.is_slot_active(SlotIndex::R),
-        },
-        _ => {
-            let slot_data = abr_data.slot_data(slot_index);
-            let state = match slot_data.successful_boot == 1 {
-                true => SlotState::Successful,
-                _ if slot_data.is_slot_bootable() => SlotState::Bootable(slot_data.tries_remaining),
-                _ => SlotState::Unbootable,
-            };
-            SlotInfo { state, is_active: abr_data.is_slot_active(slot_index) }
-        }
-    })
-}
-
-/// Equivalent to C API `AbrSetOneShotRecovery()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn set_one_shot_recovery(abr_ops: &mut dyn Ops, enable: bool) -> Result<()> {
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-    abr_data.set_one_shot_recovery(enable);
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
-}
-
-/// Equivalent to C API `AbrSetOneShotBootloader()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn set_one_shot_bootloader(abr_ops: &mut dyn Ops, enable: bool) -> Result<()> {
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-    abr_data.set_one_shot_bootloader(enable);
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
-}
-
-/// Equivalent to C API `AbrGetAndClearOneShotFlags()`.
-///
-/// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
-/// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_and_clear_one_shot_flag(abr_ops: &mut dyn Ops) -> Result<u8> {
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-    let res = abr_data.one_shot_flags;
-    abr_data.one_shot_flags = 0;
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)?;
-    Ok(res)
-}
-
-/// Gets and clears one shot bootloader flag only.
-pub fn get_and_clear_one_shot_bootloader(abr_ops: &mut dyn Ops) -> Result<bool> {
-    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
-    let res = abr_data.one_shot_flags;
-    abr_data.one_shot_flags &= !ONE_SHOT_BOOTLOADER;
-    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)?;
-    Ok((res & ONE_SHOT_BOOTLOADER) != 0)
-}
-
-/// Reverses the bit of a byte.
-fn reverse_byte(b: u8) -> u8 {
-    const LOOKUP_TABLE_4BIT_REVERSE: &[u8] =
-        &[0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF];
-    LOOKUP_TABLE_4BIT_REVERSE[(b >> 4) as usize]
-        | (LOOKUP_TABLE_4BIT_REVERSE[(b & 0xf) as usize] << 4)
-}
-
-// Reverses the bits of a u32;
-fn reverse_u32(val: u32) -> u32 {
-    let mut bytes = val.to_le_bytes();
-    bytes.iter_mut().for_each(|v| *v = reverse_byte(*v));
-    u32::from_be_bytes(bytes)
-}
-
-// Calculates the crc32 of the given bytes.
-fn crc32(data: &[u8]) -> u32 {
-    let mut res: u32 = 0xffffffff;
-    for b in data {
-        res ^= (reverse_byte(*b) as u32) << 24;
-        for _ in 0..8 {
-            if (res & 0x80000000) != 0 {
-                res = (res << 1) ^ 0x04C11DB7;
-            } else {
-                res <<= 1;
-            }
-        }
-    }
-    reverse_u32(!res)
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    // Testing is currently done against the C interface tests in upstream Fuchsia:
-    // https://fuchsia.googlesource.com/fuchsia/+/96f7268b497f998ffcbeef73425b031bd7f4db65/src/firmware/lib/abr/test/libabr_test.cc
-    // These tests will be ported to here as rust tests in the future.
-
-    #[test]
-    fn test_get_and_clear_one_shot_bootloader() {
-        let mut meta = [0u8; ABR_DATA_SIZE];
-        set_one_shot_bootloader(&mut meta, true).unwrap();
-        set_one_shot_recovery(&mut meta, true).unwrap();
-        assert!(get_and_clear_one_shot_bootloader(&mut meta).unwrap());
-        assert_eq!(get_and_clear_one_shot_flag(&mut meta).unwrap(), ONE_SHOT_RECOVERY);
-    }
-}
diff --git a/gbl/libabr/src/utils.rs b/gbl/libabr/src/utils.rs
deleted file mode 100644
index 81dd36d..0000000
--- a/gbl/libabr/src/utils.rs
+++ /dev/null
@@ -1,91 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use abr::{AbrData, ONE_SHOT_BOOTLOADER, ONE_SHOT_RECOVERY};
-
-/// Converts big endian order to host order.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub extern "C" fn AbrBigEndianToHost(val: u32) -> u32 {
-    u32::from_be(val)
-}
-
-/// Converts host order to big endian.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub extern "C" fn AbrHostToBigEndian(val: u32) -> u32 {
-    val.to_be()
-}
-
-/// Checks if one-shot recovery boot is set in the given one-shot flags
-#[no_mangle]
-#[allow(non_snake_case)]
-pub extern "C" fn AbrIsOneShotRecoveryBootSet(flags: u8) -> bool {
-    (flags & ONE_SHOT_RECOVERY) != 0
-}
-
-/// Checks if one-shot recovery boot is set in the given AbrData
-///
-/// # Safety
-///
-/// Caller must make sure to pass a valid pointer for `abr_data`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrIsOneShotRecoveryBoot(abr_data: *const AbrData) -> bool {
-    // SAFETY: function safety requires `abr_data` to be a valid pointer.
-    AbrIsOneShotRecoveryBootSet(unsafe { abr_data.as_ref() }.unwrap().one_shot_flags)
-}
-
-/// Checks if one-shot bootloader boot is set in the given one-shot flags
-#[no_mangle]
-#[allow(non_snake_case)]
-pub extern "C" fn AbrIsOneShotBootloaderBootSet(flags: u8) -> bool {
-    (flags & ONE_SHOT_BOOTLOADER) != 0
-}
-
-/// Checks if one-shot bootloader boot is set in the given AbrData
-///
-/// # Safety
-///
-/// Caller must make sure to pass a valid pointer for `abr_data`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrIsOneShotBootloaderBoot(abr_data: *const AbrData) -> bool {
-    // SAFETY: function safety requires `abr_data` to be a valid pointer.
-    AbrIsOneShotBootloaderBootSet(unsafe { abr_data.as_ref() }.unwrap().one_shot_flags)
-}
-
-/// Sets the one-shot recovery flag in the given AbrData.
-///
-/// # Safety
-///
-/// Caller must make sure to pass a valid pointer for `abr_data`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrSetOneShotRecoveryBoot(abr_data: *mut AbrData, enable: bool) {
-    // SAFETY: function safety requires `abr_data` to be a valid pointer.
-    unsafe { abr_data.as_mut() }.unwrap().set_one_shot_recovery(enable);
-}
-
-/// Sets the one-shot bootloader flag in the given AbrData.
-///
-/// # Safety
-///
-/// Caller must make sure to pass a valid pointer for `abr_data`.
-#[no_mangle]
-#[allow(non_snake_case)]
-pub unsafe extern "C" fn AbrSetOneShotBootloaderBoot(abr_data: *mut AbrData, enable: bool) {
-    // SAFETY: function safety requires `abr_data` to be a valid pointer.
-    unsafe { abr_data.as_mut() }.unwrap().set_one_shot_bootloader(enable);
-}
diff --git a/gbl/libasync/BUILD b/gbl/libasync/BUILD
deleted file mode 100644
index 49d114f..0000000
--- a/gbl/libasync/BUILD
+++ /dev/null
@@ -1,50 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libasync",
-    srcs = ["src/lib.rs"],
-    crate_name = "gbl_async",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
-
-rust_test(
-    name = "libasync_test",
-    crate = ":libasync",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
-
-rust_library(
-    name = "cyclic_executor",
-    srcs = ["src/cyclic_executor.rs"],
-    crate_name = "gbl_cyclic_executor",
-    crate_root = "src/cyclic_executor.rs",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [":libasync"],
-)
-
-rust_test(
-    name = "cyclic_executor_test",
-    crate = ":cyclic_executor",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libasync/src/cyclic_executor.rs b/gbl/libasync/src/cyclic_executor.rs
deleted file mode 100644
index 5365354..0000000
--- a/gbl/libasync/src/cyclic_executor.rs
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library implements a simple executor using cyclic scheduling.
-
-#![cfg_attr(not(test), no_std)]
-
-extern crate alloc;
-use alloc::{boxed::Box, vec::Vec};
-use core::{future::Future, pin::Pin};
-use gbl_async::poll;
-
-/// `CyclicExecutor` is a simple single thread executor that simply cyclically polls all Futures.
-#[derive(Default)]
-pub struct CyclicExecutor<'a> {
-    tasks: Vec<Pin<Box<dyn Future<Output = ()> + 'a>>>,
-}
-
-impl<'a> CyclicExecutor<'a> {
-    /// Adds a new task.
-    pub fn spawn_task(&mut self, task: impl Future<Output = ()> + 'a) {
-        let mut task = Box::pin(task);
-        // Schedule the task once.
-        match poll(&mut task.as_mut()) {
-            Some(_) => {}
-            _ => self.tasks.push(task),
-        }
-    }
-
-    /// Polls all `Future`s once.
-    pub fn poll(&mut self) {
-        let mut idx = 0;
-        while let Some(task) = self.tasks.get_mut(idx) {
-            if poll(&mut task.as_mut()).is_some() {
-                let _ = self.tasks.swap_remove(idx);
-            } else {
-                idx += 1;
-            }
-        }
-    }
-
-    /// Runs all `Future`s until completion.
-    pub fn run(&mut self) {
-        while !self.tasks.is_empty() {
-            self.poll();
-        }
-    }
-
-    /// Returns the current number of tasks.
-    pub fn num_tasks(&self) -> usize {
-        self.tasks.len()
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use gbl_async::yield_now;
-    use std::sync::Mutex;
-
-    #[test]
-    fn test_spawn_and_poll_task() {
-        let val1 = Mutex::new(0);
-        let val2 = Mutex::new(1);
-
-        let mut executor: CyclicExecutor = Default::default();
-        // Spawns 2 tasks.
-        executor.spawn_task(async {
-            *val1.try_lock().unwrap() += 1;
-            yield_now().await;
-            *val1.try_lock().unwrap() += 1;
-            yield_now().await;
-            *val1.try_lock().unwrap() += 1;
-            yield_now().await;
-        });
-        executor.spawn_task(async {
-            *val2.try_lock().unwrap() += 1;
-            yield_now().await;
-            *val2.try_lock().unwrap() += 1;
-            yield_now().await;
-            *val2.try_lock().unwrap() += 1;
-            yield_now().await;
-        });
-
-        // Test that spawning a task schedules it immediately.
-        assert_eq!(*val1.try_lock().unwrap(), 1);
-        assert_eq!(*val2.try_lock().unwrap(), 2);
-
-        // Polls all Futures once.
-        executor.poll();
-        assert_eq!(*val1.try_lock().unwrap(), 2);
-        assert_eq!(*val2.try_lock().unwrap(), 3);
-
-        // Runs to completion.
-        executor.run();
-        assert_eq!(*val1.try_lock().unwrap(), 3);
-        assert_eq!(*val2.try_lock().unwrap(), 4);
-    }
-
-    #[test]
-    fn test_complete_on_spawn_not_added() {
-        let mut executor: CyclicExecutor = Default::default();
-        executor.spawn_task(async {});
-        assert_eq!(executor.num_tasks(), 0);
-    }
-}
diff --git a/gbl/libasync/src/lib.rs b/gbl/libasync/src/lib.rs
deleted file mode 100644
index d84d4ec..0000000
--- a/gbl/libasync/src/lib.rs
+++ /dev/null
@@ -1,286 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides async utility APIs used by GBL.
-//!
-//! They are mainly barebone APIs for busy waiting and polling Futures. There is no support for
-//! sleep/wake or threading.
-
-#![cfg_attr(not(test), no_std)]
-
-use core::{
-    future::Future,
-    ops::DerefMut,
-    pin::{pin, Pin},
-    ptr::null,
-    task::{Context, Poll, RawWaker, RawWakerVTable, Waker},
-};
-
-/// Clone method for `NOOP_VTABLE`.
-fn noop_clone(_: *const ()) -> RawWaker {
-    noop_raw_waker()
-}
-
-/// Noop method for `wake`, `wake_by_ref` and `drop` in `RawWakerVTable`.
-fn noop_wake_method(_: *const ()) {}
-
-/// A noop `RawWakerVTable`
-const NOOP_VTABLE: RawWakerVTable =
-    RawWakerVTable::new(noop_clone, noop_wake_method, noop_wake_method, noop_wake_method);
-
-/// Creates a noop instance that does nothing.
-fn noop_raw_waker() -> RawWaker {
-    RawWaker::new(null(), &NOOP_VTABLE)
-}
-
-/// Repetitively polls and blocks until a future completes.
-pub fn block_on<O>(fut: impl Future<Output = O>) -> O {
-    let mut fut = pin!(fut);
-    loop {
-        match poll(&mut fut) {
-            Some(res) => return res,
-            _ => {}
-        }
-    }
-}
-
-/// Polls a Future.
-///
-/// Returns Some(_) if ready, None otherwise.
-pub fn poll<O, F: Future<Output = O> + ?Sized>(
-    fut: &mut Pin<impl DerefMut<Target = F>>,
-) -> Option<O> {
-    // SAFETY:
-    // * All methods for noop_raw_waker() are either noop or have no shared state. Thus they are
-    //   thread-safe.
-    let waker = unsafe { Waker::from_raw(noop_raw_waker()) };
-    let mut context = Context::from_waker(&waker);
-    match fut.as_mut().poll(&mut context) {
-        Poll::Pending => None,
-        Poll::Ready(res) => Some(res),
-    }
-}
-
-/// Polls the given future for up to `n` times.
-pub fn poll_n_times<O, F: Future<Output = O> + ?Sized>(
-    fut: &mut Pin<impl DerefMut<Target = F>>,
-    n: usize,
-) -> Option<O> {
-    (0..n).find_map(|_| poll(fut))
-}
-
-/// `Yield` implements a simple API for yielding control once to the executor.
-struct Yield(bool);
-
-impl Future for Yield {
-    type Output = ();
-
-    fn poll(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {
-        self.0 = !self.0;
-        match self.0 {
-            true => Poll::Pending,
-            _ => Poll::Ready(()),
-        }
-    }
-}
-
-/// Yield the execution once.
-pub async fn yield_now() {
-    Yield(false).await
-}
-
-/// `YieldCounter` maintains a counter and yield control to executor once it overflows a given
-/// threshold. When overflow occurs, the counter value is reset and the carry over is discarded.
-pub struct YieldCounter {
-    threshold: u64,
-    current: u64,
-}
-
-impl YieldCounter {
-    /// Creates an instance with a given threshold.
-    pub fn new(threshold: u64) -> Self {
-        Self { threshold, current: 0 }
-    }
-
-    /// Increments the current counter and yield execution if the value overflows the threshold.
-    pub async fn increment(&mut self, inc: u64) {
-        self.current = self.current.saturating_sub(inc);
-        if self.current == 0 {
-            self.current = self.threshold;
-            yield_now().await;
-        }
-    }
-}
-
-/// Repetitively polls two futures until both of them finish.
-pub async fn join<L, LO, R, RO>(fut_lhs: L, fut_rhs: R) -> (LO, RO)
-where
-    L: Future<Output = LO>,
-    R: Future<Output = RO>,
-{
-    let fut_lhs = &mut pin!(fut_lhs);
-    let fut_rhs = &mut pin!(fut_rhs);
-    let mut out_lhs = poll(fut_lhs);
-    let mut out_rhs = poll(fut_rhs);
-    while out_lhs.is_none() || out_rhs.is_none() {
-        yield_now().await;
-        if out_lhs.is_none() {
-            out_lhs = poll(fut_lhs);
-        }
-
-        if out_rhs.is_none() {
-            out_rhs = poll(fut_rhs);
-        }
-    }
-    (out_lhs.unwrap(), out_rhs.unwrap())
-}
-
-/// Waits until either of the given two futures completes.
-pub async fn select<L, LO, R, RO>(fut_lhs: L, fut_rhs: R) -> (Option<LO>, Option<RO>)
-where
-    L: Future<Output = LO>,
-    R: Future<Output = RO>,
-{
-    let fut_lhs = &mut pin!(fut_lhs);
-    let fut_rhs = &mut pin!(fut_rhs);
-    let mut out_lhs = poll(fut_lhs);
-    let mut out_rhs = poll(fut_rhs);
-    while out_lhs.is_none() && out_rhs.is_none() {
-        yield_now().await;
-        out_lhs = poll(fut_lhs);
-        out_rhs = poll(fut_rhs);
-    }
-    (out_lhs, out_rhs)
-}
-
-/// Runs a [Future] and checks and asserts that it returns eventually.
-pub async fn assert_return<O>(fut: impl Future<Output = O>) -> O {
-    struct Returned(bool);
-
-    impl Drop for Returned {
-        fn drop(&mut self) {
-            assert!(self.0)
-        }
-    }
-
-    let mut flag = Returned(false);
-    let res = fut.await;
-    flag.0 = true;
-    res
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use std::sync::Mutex;
-
-    #[test]
-    fn test() {
-        let mut counter = YieldCounter::new(1);
-        let mut fut = pin!(async move {
-            counter.increment(2).await;
-            counter.increment(2).await;
-        });
-
-        assert!(poll(&mut fut).is_none());
-        assert!(poll(&mut fut).is_none());
-        assert!(poll(&mut fut).is_some());
-    }
-
-    #[test]
-    fn test_join() {
-        let val1 = Mutex::new(0);
-        let val2 = Mutex::new(1);
-
-        let mut join_fut = pin!(join(
-            async {
-                *val1.try_lock().unwrap() += 1;
-                yield_now().await;
-                *val1.try_lock().unwrap() += 1;
-                yield_now().await;
-            },
-            async {
-                *val2.try_lock().unwrap() += 1;
-                yield_now().await;
-                *val2.try_lock().unwrap() += 1;
-                yield_now().await;
-                *val2.try_lock().unwrap() += 1;
-                yield_now().await;
-            }
-        ));
-
-        assert!(poll(&mut join_fut).is_none());
-        assert_eq!(*val1.try_lock().unwrap(), 1);
-        assert_eq!(*val2.try_lock().unwrap(), 2);
-
-        assert!(poll(&mut join_fut).is_none());
-        assert_eq!(*val1.try_lock().unwrap(), 2);
-        assert_eq!(*val2.try_lock().unwrap(), 3);
-
-        assert!(poll(&mut join_fut).is_none());
-        assert_eq!(*val1.try_lock().unwrap(), 2);
-        assert_eq!(*val2.try_lock().unwrap(), 4);
-
-        assert!(poll(&mut join_fut).is_some());
-    }
-
-    #[test]
-    fn test_select() {
-        let val1 = Mutex::new(0);
-        let val2 = Mutex::new(1);
-
-        let mut select_fut = pin!(select(
-            async {
-                *val1.try_lock().unwrap() += 1;
-                yield_now().await;
-                *val1.try_lock().unwrap() += 1;
-                yield_now().await;
-            },
-            async {
-                *val2.try_lock().unwrap() += 1;
-                yield_now().await;
-                *val2.try_lock().unwrap() += 1;
-                yield_now().await;
-                *val2.try_lock().unwrap() += 1;
-                yield_now().await;
-            }
-        ));
-
-        assert!(poll(&mut select_fut).is_none());
-        assert_eq!(*val1.try_lock().unwrap(), 1);
-        assert_eq!(*val2.try_lock().unwrap(), 2);
-
-        assert!(poll(&mut select_fut).is_none());
-        assert_eq!(*val1.try_lock().unwrap(), 2);
-        assert_eq!(*val2.try_lock().unwrap(), 3);
-
-        let (lhs, rhs) = poll(&mut select_fut).unwrap();
-        assert!(lhs.is_some());
-        assert!(rhs.is_none());
-    }
-
-    #[test]
-    fn test_assert_return() {
-        // Finishes. No assert.
-        block_on(assert_return(async { yield_now().await }));
-    }
-
-    #[test]
-    #[should_panic]
-    fn test_assert_return_panics() {
-        let mut fut = pin!(assert_return(async { yield_now().await }));
-        // Need one more poll to finish. Thus it should panic when going out of scope.
-        assert!(poll(&mut fut).is_none());
-    }
-}
diff --git a/gbl/libavb/BUILD b/gbl/libavb/BUILD
deleted file mode 100644
index 772e93f..0000000
--- a/gbl/libavb/BUILD
+++ /dev/null
@@ -1,34 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-rust_library(
-    name = "sysdeps",
-    srcs = glob(["**/*.rs"]),
-    crate_name = "avb_sysdeps",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@avb//:avb_bindgen",
-        "@gbl//libc",
-    ],
-)
diff --git a/gbl/libavb/BUILD.avb.bazel b/gbl/libavb/BUILD.avb.bazel
deleted file mode 100644
index 4c9d134..0000000
--- a/gbl/libavb/BUILD.avb.bazel
+++ /dev/null
@@ -1,203 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
-load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
-load("@rules_cc//cc:defs.bzl", "cc_library")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
-# library and instead of only headers. Thus we generate a placeholder source file to meet the
-# requirement.
-genrule(
-    name = "bindgen_noop_cc",
-    outs = ["bindgen_noop_cc.cc"],
-    cmd = "touch $(OUTS)",
-)
-
-cc_library(
-    name = "headers",
-    srcs = [":bindgen_noop_cc"],
-    hdrs = [
-        "libavb/avb_chain_partition_descriptor.h",
-        "libavb/avb_cmdline.h",
-        "libavb/avb_crypto.h",
-        "libavb/avb_descriptor.h",
-        "libavb/avb_footer.h",
-        "libavb/avb_hash_descriptor.h",
-        "libavb/avb_hashtree_descriptor.h",
-        "libavb/avb_kernel_cmdline_descriptor.h",
-        "libavb/avb_ops.h",
-        "libavb/avb_property_descriptor.h",
-        "libavb/avb_rsa.h",
-        "libavb/avb_sha.h",
-        "libavb/avb_slot_verify.h",
-        "libavb/avb_sysdeps.h",
-        "libavb/avb_util.h",
-        "libavb/avb_vbmeta_image.h",
-        "libavb/avb_version.h",
-        "libavb/libavb.h",
-        "libavb/sha/avb_crypto_ops_impl.h",
-        "libavb_cert/avb_cert_ops.h",
-        "libavb_cert/avb_cert_types.h",
-        "libavb_cert/avb_cert_validate.h",
-        "libavb_cert/libavb_cert.h",
-    ],
-    includes = [
-        ".",
-        "libavb/sha/",
-    ],
-    deps = ["@gbl//libc:headers"],
-)
-
-cc_library(
-    name = "libavb_c",
-    srcs = [
-        "libavb/avb_chain_partition_descriptor.c",
-        "libavb/avb_cmdline.c",
-        "libavb/avb_crc32.c",
-        "libavb/avb_crypto.c",
-        "libavb/avb_descriptor.c",
-        "libavb/avb_footer.c",
-        "libavb/avb_hash_descriptor.c",
-        "libavb/avb_hashtree_descriptor.c",
-        "libavb/avb_kernel_cmdline_descriptor.c",
-        "libavb/avb_property_descriptor.c",
-        "libavb/avb_rsa.c",
-        "libavb/avb_slot_verify.c",
-        "libavb/avb_util.c",
-        "libavb/avb_vbmeta_image.c",
-        "libavb/avb_version.c",
-        "libavb_cert/avb_cert_validate.c",
-        # C implementations for sysdeps which cannot be implemented using Rust
-        "@gbl//libavb:deps.c",
-    ],
-    copts = [
-        "-D_FILE_OFFSET_BITS=64",
-        "-D_POSIX_C_SOURCE=199309L",
-        "-Wa,--noexecstack",
-        "-Werror",
-        "-Wall",
-        "-Wextra",
-        "-Wformat=2",
-        "-Wmissing-prototypes",
-        "-Wno-unused-parameter",
-        "-ffunction-sections",
-        "-g",
-        "-DAVB_USE_PRINTF_LOGS",
-        "-DAVB_COMPILATION",
-        # libavb uses more than 4K of stack space. This prevents the compiler from inserting
-        # _chkstk().
-        "-mstack-probe-size=8192",
-    ],
-    deps = [
-        ":headers",
-    ],
-)
-
-link_static_cc_library(
-    name = "libavb_c_staticlib",
-    cc_library = ":libavb_c",
-)
-
-cc_library(
-    name = "avb_crypto_ops_sha_impl",
-    srcs = [
-        "libavb/sha/sha256_impl.c",
-        "libavb/sha/sha512_impl.c",
-    ],
-    copts = ["-DAVB_COMPILATION"],
-    deps = [
-        ":headers",
-    ],
-)
-
-link_static_cc_library(
-    name = "avb_crypto_ops_sha_impl_staticlib",
-    cc_library = ":avb_crypto_ops_sha_impl",
-)
-
-rust_bindgen(
-    name = "libavb_c_bindgen",
-    # Flags should match Soong definition in external/avb/rust/Android.bp.
-    bindgen_flags = [
-        "--constified-enum-module=AvbDescriptorTag",
-        "--bitfield-enum=Avb.*Flags",
-        "--default-enum-style=rust",
-        "--with-derive-default",
-        "--with-derive-custom=Avb.*Descriptor=FromBytes,Immutable,KnownLayout",
-        "--with-derive-custom=AvbCertPermanentAttributes=FromBytes,IntoBytes",
-        "--with-derive-custom=AvbCertCertificate.*=FromBytes,IntoBytes",
-        "--with-derive-custom=AvbCertUnlock.*=FromBytes,IntoBytes",
-        "--allowlist-type=AvbDescriptorTag",
-        "--allowlist-type=Avb.*Flags",
-        "--allowlist-function=.*",
-        "--allowlist-var=AVB.*",
-        "--use-core",
-        "--raw-line=#![no_std]",
-        "--raw-line=use zerocopy::{Immutable, IntoBytes, FromBytes, KnownLayout};",
-        "--ctypes-prefix=core::ffi",
-    ],
-    cc_lib = "headers",
-    # For x86_32, we need to explicitly specify 32bit architecture.
-    clang_flags = select({
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-        "//conditions:default": ["-m64"],
-    }) + [
-        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
-        "-nostdinc",
-    ],
-    header = "libavb_cert/libavb_cert.h",
-)
-
-rust_library(
-    name = "avb_bindgen",
-    srcs = [":libavb_c_bindgen"],
-    rustc_flags = [
-        "--allow=non_snake_case",
-        "--allow=non_camel_case_types",
-    ],
-    deps = ["@zerocopy"],
-)
-
-rust_library(
-    name = "avb",
-    srcs = glob(["rust/src/**/*.rs"]),
-    crate_features = ["uuid"],
-    edition = "2021",
-    deps = [
-        ":avb_bindgen",
-        ":libavb_c_staticlib",
-        "@uuid",
-        "@zerocopy",
-    ],
-)
-
-rust_library(
-    name = "avb_test",
-    srcs = ["rust/tests/test_ops.rs"],
-    crate_features = ["uuid"],
-    edition = "2021",
-    deps = [
-        ":avb",
-        "@uuid",
-    ],
-)
diff --git a/gbl/libavb/deps.c b/gbl/libavb/deps.c
deleted file mode 100644
index 2bf4c7b..0000000
--- a/gbl/libavb/deps.c
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gbl/print.h>
-#include <libavb/avb_sysdeps.h>
-#include <stdarg.h>
-
-void avb_printf(const char* fmt, ...) {
-  va_list args;
-  va_start(args, fmt);
-  gbl_printf(fmt, args);
-  va_end(args);
-}
-
-void avb_printv(const char* message, ...) {}
diff --git a/gbl/libavb/src/lib.rs b/gbl/libavb/src/lib.rs
deleted file mode 100644
index f617b5d..0000000
--- a/gbl/libavb/src/lib.rs
+++ /dev/null
@@ -1,89 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides one possible implementation of the sysdeps functions for libavb.
-//! Global allocator is required.
-
-#![cfg_attr(not(test), no_std)]
-// These are implementations of required C functions, see libavb sysdeps for docs.
-#![allow(missing_docs)]
-
-use core::ffi::{c_char, c_int, c_void};
-use libc::{gbl_free, gbl_malloc, memcmp, memcpy, memset, strcmp, strlen, strncmp};
-
-const AVB_MALLOC_ALIGNMENT: usize = avb_bindgen::AVB_ALIGNMENT_SIZE as usize;
-
-#[no_mangle]
-pub extern "C" fn avb_abort() -> ! {
-    panic!("avb_abort");
-}
-
-#[no_mangle]
-pub extern "C" fn avb_malloc_(size: usize) -> *mut c_void {
-    // SAFETY: libavb calls are compatible with libc counterparts, alignment the same as
-    // avb_free
-    unsafe { gbl_malloc(size, AVB_MALLOC_ALIGNMENT) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_free(ptr: *mut c_void) {
-    // SAFETY: libavb calls are compatible with libc counterparts, alignment the same as
-    // avb_malloc_
-    unsafe { gbl_free(ptr, AVB_MALLOC_ALIGNMENT) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_strlen(s: *const c_char) -> usize {
-    // SAFETY: libavb calls are compatible with libc counterparts
-    unsafe { strlen(s) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_div_by_10(dividend: *mut u64) -> u32 {
-    // SAFETY: libavb guarantees to pass valid pointer to u64 integer here
-    let val = unsafe { &mut *dividend };
-    let rem = *val % 10;
-    *val /= 10;
-    rem.try_into().unwrap()
-}
-
-#[no_mangle]
-pub extern "C" fn avb_memcpy(dest: *mut c_void, src: *const c_void, n: usize) -> *mut c_void {
-    // SAFETY: libavb calls are compatible with libc counterparts
-    unsafe { memcpy(dest, src, n) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_memcmp(src1: *const c_void, src2: *const c_void, n: usize) -> c_int {
-    // SAFETY: libavb calls are compatible with libc counterparts
-    unsafe { memcmp(src1, src2, n) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_memset(dest: *mut c_void, c: c_int, n: usize) -> *mut c_void {
-    // SAFETY: libavb calls are compatible with libc counterparts
-    unsafe { memset(dest, c, n) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_strcmp(s1: *const c_char, s2: *const c_char) -> c_int {
-    // SAFETY: libavb calls are compatible with libc counterparts
-    unsafe { strcmp(s1, s2) }
-}
-
-#[no_mangle]
-pub extern "C" fn avb_strncmp(s1: *const c_char, s2: *const c_char, n: usize) -> c_int {
-    // SAFETY: libavb calls are compatible with libc counterparts
-    unsafe { strncmp(s1, s2, n) }
-}
diff --git a/gbl/libboot/BUILD b/gbl/libboot/BUILD
deleted file mode 100644
index 47634d4..0000000
--- a/gbl/libboot/BUILD
+++ /dev/null
@@ -1,89 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
-# library and instead of only headers. Thus we generate a placeholder source file to meet the
-# requirement.
-genrule(
-    name = "bindgen_noop_cc",
-    outs = ["bindgen_noop_cc.cc"],
-    cmd = "touch $(OUTS)",
-)
-
-cc_library(
-    name = "bindgen_cc_lib",
-    srcs = [":bindgen_noop_cc"],
-    deps = ["@linux_x86_64_sysroot//:linux_x86_64_sysroot_include"],
-)
-
-CUSTOM_DERIVES = "Immutable,IntoBytes,FromBytes"
-
-rust_bindgen(
-    name = "x86_bootparam_bindgen",
-    bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
-        "--allowlist-type",
-        "boot_params",
-        "--with-derive-default",
-        "--with-derive-custom-struct=.*={}".format(CUSTOM_DERIVES),
-        "--with-derive-custom-union=.*={}".format(CUSTOM_DERIVES),
-        "--raw-line",
-        """
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![cfg_attr(not(test), no_std)]
-use zerocopy::{Immutable, IntoBytes, FromBytes};""",
-    ],
-    cc_lib = ":bindgen_cc_lib",
-    header = "@linux_x86_64_sysroot//:sysroot/usr/include/x86_64-linux-gnu/asm/bootparam.h",
-)
-
-rust_library(
-    name = "x86_bootparam_defs",
-    srcs = [":x86_bootparam_bindgen"],
-    crate_root = ":x86_bootparam_bindgen",
-    data = [":x86_bootparam_bindgen"],
-    rustc_flags = ["--cfg=zerocopy_derive_union_into_bytes"],
-    deps = ["@zerocopy"],
-)
-
-rust_library(
-    name = "libboot",
-    srcs = glob(["**/*.rs"]),
-    crate_name = "boot",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":x86_bootparam_defs",
-        "@gbl//liberror",
-        "@gbl//libsafemath",
-        "@zbi",
-        "@zerocopy",
-    ] + select({
-        "@gbl//toolchain:gbl_rust_uefi_aarch64": [
-            "@gbl//libboot/aarch64_cache_helper:aarch64_cache_helper_staticlib",
-        ],
-        "//conditions:default": [],
-    }),
-)
diff --git a/gbl/libboot/aarch64_cache_helper/BUILD b/gbl/libboot/aarch64_cache_helper/BUILD
deleted file mode 100644
index 2da5b0c..0000000
--- a/gbl/libboot/aarch64_cache_helper/BUILD
+++ /dev/null
@@ -1,46 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-cc_library(
-    name = "asm_macros_common",
-    hdrs = ["include/common/asm_macros_common.S"],
-    includes = ["include"],
-)
-
-cc_library(
-    name = "aarch64_cache_helper",
-    srcs = [
-        "disable_cache_mmu.S",
-        "@arm_trusted_firmware//:lib/aarch64/cache_helpers.S",
-    ],
-    hdrs = ["@arm_trusted_firmware//:include/arch/aarch64/asm_macros.S"],
-    defines = ["__ASSEMBLER__"],
-    deps = [
-        ":asm_macros_common",
-        "@arm_trusted_firmware//:headers_aarch64",
-    ],
-)
-
-link_static_cc_library(
-    name = "aarch64_cache_helper_staticlib",
-    cc_library = ":aarch64_cache_helper",
-)
diff --git a/gbl/libboot/aarch64_cache_helper/BUILD.arm_trusted_firmware.bazel b/gbl/libboot/aarch64_cache_helper/BUILD.arm_trusted_firmware.bazel
deleted file mode 100644
index 1854244..0000000
--- a/gbl/libboot/aarch64_cache_helper/BUILD.arm_trusted_firmware.bazel
+++ /dev/null
@@ -1,33 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-filegroup(
-    name = "header_files",
-    srcs = glob(["include/**/*.h"]),
-)
-
-cc_library(
-    name = "headers_aarch64",
-    hdrs = glob(["include/**/*.h"]),
-    includes = [
-        "include",
-        "include/arch/aarch64",
-    ],
-)
diff --git a/gbl/libboot/aarch64_cache_helper/disable_cache_mmu.S b/gbl/libboot/aarch64_cache_helper/disable_cache_mmu.S
deleted file mode 100644
index da4ce8d..0000000
--- a/gbl/libboot/aarch64_cache_helper/disable_cache_mmu.S
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
- #include <arch.h>
-
-.global disable_cache_mmu_and_jump
-
-/* ---------------------------------------------------------------
- * Disable cache, MMU and jump to the given address with arguments
- *
- * x0 - x3: Arguments for the target jump address.
- * x4: The jump address.
- * ---------------------------------------------------------------
- */
-disable_cache_mmu_and_jump:
-    // Query current EL
-    mrs     x5, CurrentEL
-    cmp     x5, #(1 << 3)
-    beq     asm_disable_cache_mmu_el2
-
-    /*
-     * Invalidate instruction cache before disabling it.
-     */
-    ic  iallu
-    isb
-
-asm_disable_cache_mmu_el1:
-    mrs x5, sctlr_el1
-    bic x5, x5, #SCTLR_M_BIT
-    bic x5, x5, #SCTLR_C_BIT
-    bic x5, x5, #SCTLR_I_BIT
-    msr sctlr_el1, x5
-    b asm_finish
-
-asm_disable_cache_mmu_el2:
-    mrs x5, sctlr_el2
-    bic x5, x5, #SCTLR_M_BIT
-    bic x5, x5, #SCTLR_C_BIT
-    bic x5, x5, #SCTLR_I_BIT
-    msr sctlr_el2, x5
-
-asm_finish:
-    ic  iallu
-    isb
-    /*
-     * Invalidate TLB.
-     */
-    tlbi vmalle1
-
-    br x4
-    /*
-     * Prevent speculative execution.
-     */
-    dsb nsh
-    isb
diff --git a/gbl/libboot/aarch64_cache_helper/include/common/asm_macros_common.S b/gbl/libboot/aarch64_cache_helper/include/common/asm_macros_common.S
deleted file mode 100644
index 1bc4bfa..0000000
--- a/gbl/libboot/aarch64_cache_helper/include/common/asm_macros_common.S
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * This file replaces "external/arm-trusted-firmware/include/common/asm_macros_common.S" for
- * building "external/arm-trusted-firmware/lib/aarch64/cache_helper.S". It defines the "func"
- * macro for declaring assembly function. However the original file uses assembly directives
- * such as ".size" for debug information which are not recogized by LLVM when building for
- * windows/msvc target. Thus we use our custom definition to workaround.
- */
-
-/*
- * This macro marks the begin of a function. It simply creates a label.
- */
-.macro func _name
-\_name:
-.endm
-
-/*
- * This macro is used to mark the end of a function. For our usage, it's simply a noop.
- */
-.macro endfunc _name
-.endm
diff --git a/gbl/libboot/src/aarch64.rs b/gbl/libboot/src/aarch64.rs
deleted file mode 100644
index 3dd1a6f..0000000
--- a/gbl/libboot/src/aarch64.rs
+++ /dev/null
@@ -1,135 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Docs for booting on AArch64 is at:
-//!
-//!   https://www.kernel.org/doc/html/v5.11/arm64/booting.html
-
-use core::arch::asm;
-use zbi::ZbiContainer;
-
-/// ARM exception levels.
-#[allow(missing_docs)]
-#[derive(Debug, PartialEq)]
-pub enum ExceptionLevel {
-    EL0,
-    EL1,
-    EL2,
-    EL3,
-}
-
-/// Gets the current EL;
-pub fn current_el() -> ExceptionLevel {
-    let mut el: u64;
-    // SAFETY: The assembly code only read current exception level.
-    unsafe {
-        asm!(
-            "mrs {el}, CurrentEL",
-            el = out(reg) el,
-        );
-    }
-    el = (el >> 2) & 3;
-    match el {
-        0 => ExceptionLevel::EL0,
-        1 => ExceptionLevel::EL1,
-        2 => ExceptionLevel::EL2,
-        3 => ExceptionLevel::EL3,
-        v => panic!("Unknown EL {v}"),
-    }
-}
-
-extern "C" {
-    /// Clean and invalidate data cache by address range. The function is from ATF library.
-    fn flush_dcache_range(addr: usize, len: usize);
-}
-
-/// Flush all data cache for the given buffer.
-fn flush_dcache_buffer(buf: &[u8]) {
-    unsafe { flush_dcache_range(buf.as_ptr() as usize, buf.len()) }
-    // SAFETY: Assembly code for instruction synchronization.
-    unsafe { asm!("isb") };
-}
-
-/// Disable cache, MMU and jump to the given kernel address with arguments.
-///
-/// # Args
-///
-/// * `addr`: Address to jump.
-/// * `arg[0-3]`: Arguments for the target jump address.
-///
-/// # Safety
-///
-/// * Caller must ensure that `addr` contains valid execution code.
-/// * Caller must ensure to flush any data cache for memory regions that contain data to be accessed
-///   by the destination code, including the execution code itself at address `addr`
-unsafe fn jump_kernel(addr: usize, arg0: usize, arg1: usize, arg2: usize, arg3: usize) -> ! {
-    // TODO(b/334962949): Disable other stuffs such as interrupt, async abort, branch prediction etc.
-
-    // After disabling MMU and cache, memory regions that have unflushed cache are stale and cannot
-    // be trusted, including stack memory. Therefore all needed data including local variables must
-    // be ensured to be loaded to registers first. `disable_cache_mmu_and_jump` only operates on
-    // registers and does not access stack or any other memory.
-    //
-    // SAFETY: By safety requirement of this function, `addr` contains valid execution code.
-    unsafe {
-        asm!(
-            "b disable_cache_mmu_and_jump",
-            in("x0") arg0,
-            in("x1") arg1,
-            in("x2") arg2,
-            in("x3") arg3,
-            in("x4") addr,
-        )
-    };
-    unreachable!();
-}
-
-/// Boots a Linux kernel in mode EL2 or lower with the given FDT blob.
-///
-/// # Safety
-///
-/// Caller must ensure that `kernel` contains a valid Linux kernel.
-pub unsafe fn jump_linux_el2_or_lower(kernel: &[u8], ramdisk: &[u8], fdt: &[u8]) -> ! {
-    assert_ne!(current_el(), ExceptionLevel::EL3);
-    // The following is sufficient to work for existing use cases such as Cuttlefish. But there are
-    // additional initializations listed
-    // https://www.kernel.org/doc/html/v5.11/arm64/booting.html that may need to be performed
-    // explicitly for other platforms.
-
-    flush_dcache_buffer(kernel);
-    flush_dcache_buffer(ramdisk);
-    flush_dcache_buffer(fdt);
-    // SAFETY:
-    // * `kernel`, `ramdisk` and `fdt` have been flushed.
-    // * By requirement of this function, `kernel` is a valid kernel entry point.
-    unsafe { jump_kernel(kernel.as_ptr() as _, fdt.as_ptr() as _, 0, 0, 0) };
-}
-
-/// Boots a ZBI kernel in mode EL2 or lower with the given ZBI blob.
-///
-/// # Safety
-///
-/// Caller must ensure that `zbi_kernel` contains a valid zircon kernel ZBI item.
-pub unsafe fn jump_zircon_el2_or_lower(kernel: &[u8], zbi_item: &[u8]) -> ! {
-    assert_ne!(current_el(), ExceptionLevel::EL3);
-    let (entry, _) =
-        ZbiContainer::parse(kernel).unwrap().get_kernel_entry_and_reserved_memory_size().unwrap();
-    flush_dcache_buffer(kernel);
-    flush_dcache_buffer(zbi_item);
-    let addr = (kernel.as_ptr() as usize).checked_add(usize::try_from(entry).unwrap()).unwrap();
-    // SAFETY:
-    // * `zbi_kernel` and `zbi_item` have been flushed.
-    // * By requirement of this function, the computed `addr` is a valid kernel entry point.
-    unsafe { jump_kernel(addr, zbi_item.as_ptr() as _, 0, 0, 0) };
-}
diff --git a/gbl/libboot/src/lib.rs b/gbl/libboot/src/lib.rs
deleted file mode 100644
index 58ece34..0000000
--- a/gbl/libboot/src/lib.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Functionality to boot kernels on X86, ARM, and RISC-V boards.
-
-#![cfg_attr(not(test), no_std)]
-
-#[cfg(target_arch = "aarch64")]
-pub mod aarch64;
-#[cfg(target_arch = "riscv64")]
-pub mod riscv64;
-#[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
-pub mod x86;
diff --git a/gbl/libboot/src/riscv64.rs b/gbl/libboot/src/riscv64.rs
deleted file mode 100644
index a68100b..0000000
--- a/gbl/libboot/src/riscv64.rs
+++ /dev/null
@@ -1,39 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Boot logic for RISC-V.
-
-use core::arch::asm;
-
-/// Boots a Linux kernel with the given boot hart ID and FDT blob.
-///
-/// # Safety
-///
-/// Caller must ensure that `kernel` contains a valid Linux kernel.
-pub unsafe fn jump_linux(kernel: &[u8], boot_hart_id: usize, fdt: &[u8]) -> ! {
-    // No official documentation exists yet. This is equivalent to a C function call taking
-    // the hart ID and FDT address as parameters.
-    // SAFETY: By safety requirement of this function, `kernel` contains a valid linux kernel.
-    unsafe {
-        asm!(
-            "csrw satp, zero",
-            "jr {ep}",
-            in("a0") boot_hart_id,
-            in("a1") fdt.as_ptr() as usize,
-            ep = in(reg) kernel.as_ptr() as usize,
-        );
-    }
-
-    unreachable!();
-}
diff --git a/gbl/libboot/src/x86.rs b/gbl/libboot/src/x86.rs
deleted file mode 100644
index e2fb128..0000000
--- a/gbl/libboot/src/x86.rs
+++ /dev/null
@@ -1,332 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Boot protocol implementation for x86 platforms.
-//!
-//! For linux, the library currently only supports bzimage and protocol version 2.06+.
-//! Specifically, modern memory layout is used, protected kernel is loaded to high address at
-//! 0x100000 and command line size can be greater than 255 characters.
-//!
-//!                     ~                        ~
-//!                     |  Protected-mode kernel |
-//!             100000  +------------------------+
-//!                     |  I/O memory hole       |
-//!             0A0000  +------------------------+
-//!                     |  Reserved for BIOS     |      Leave as much as possible unused
-//!                     ~                        ~
-//!                     |  Command line          |      (Can also be below the X+10000 mark)
-//!                     +------------------------+
-//!                     |  Stack/heap            |      For use by the kernel real-mode code.
-//!  low_mem_addr+08000 +------------------------+
-//!                     |  Kernel setup          |      The kernel real-mode code.
-//!                     |  Kernel boot sector    |      The kernel legacy boot sector.
-//!        low_mem_addr +------------------------+
-//!                     |  Boot loader           |      <- Boot sector entry point 0000:7C00
-//!             001000  +------------------------+
-//!                     |  Reserved for MBR/BIOS |
-//!             000800  +------------------------+
-//!                     |  Typically used by MBR |
-//!             000600  +------------------------+
-//!                     |  BIOS use only         |
-//!             000000  +------------------------+
-//!
-//! See https://www.kernel.org/doc/html/v5.11/x86/boot.html#the-linux-x86-boot-protocol for more
-//! detail.
-
-use core::arch::asm;
-use core::mem::size_of;
-use core::slice::from_raw_parts_mut;
-use liberror::{Error, Result};
-use zbi::ZbiContainer;
-
-pub use x86_bootparam_defs::{boot_params, e820entry, setup_header};
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref};
-
-// Sector size is fixed to 512
-const SECTOR_SIZE: usize = 512;
-/// Boot sector and setup code section is 32K at most.
-const BOOT_SETUP_LOAD_SIZE: usize = 0x8000;
-/// Address for loading the protected mode kernel
-const LOAD_ADDR_HIGH: usize = 0x10_0000;
-// Flag value to use high address for protected mode kernel.
-const LOAD_FLAG_LOADED_HIGH: u8 = 0x1;
-
-/// In 64-bit boot protocol, the kernel is started by jumping to the
-/// 64-bit kernel entry point, which is the start address of loaded
-/// 64-bit kernel plus 0x200.
-#[cfg(target_arch = "x86_64")]
-const ENTRY_POINT_OFFSET: usize = 0x200;
-
-/// E820 RAM address range type.
-pub const E820_ADDRESS_TYPE_RAM: u32 = 1;
-/// E820 reserved address range type.
-pub const E820_ADDRESS_TYPE_RESERVED: u32 = 2;
-/// E820 ACPI address range type.
-pub const E820_ADDRESS_TYPE_ACPI: u32 = 3;
-/// E820 NVS address range type.
-pub const E820_ADDRESS_TYPE_NVS: u32 = 4;
-/// E820 unusable address range type.
-pub const E820_ADDRESS_TYPE_UNUSABLE: u32 = 5;
-/// E820 PMEM address range type.
-pub const E820_ADDRESS_TYPE_PMEM: u32 = 7;
-
-/// Wrapper for `struct boot_params {}` C structure
-#[repr(transparent)]
-#[derive(Copy, Clone, Immutable, IntoBytes, FromBytes, KnownLayout)]
-pub struct BootParams(boot_params);
-
-impl BootParams {
-    /// Cast a bytes into a reference of BootParams header
-    pub fn from_bytes_ref(buffer: &[u8]) -> Result<&BootParams> {
-        Ok(Ref::into_ref(
-            Ref::<_, BootParams>::new_from_prefix(buffer)
-                .ok_or(Error::BufferTooSmall(Some(size_of::<BootParams>())))?
-                .0,
-        ))
-    }
-
-    /// Cast a bytes into a mutable reference of BootParams header.
-    pub fn from_bytes_mut(buffer: &mut [u8]) -> Result<&mut BootParams> {
-        Ok(Ref::into_mut(
-            Ref::<_, BootParams>::new_from_prefix(buffer)
-                .ok_or(Error::BufferTooSmall(Some(size_of::<BootParams>())))?
-                .0,
-        ))
-    }
-
-    /// Return a mutable reference of the `setup_header` struct field in `boot_params`
-    pub fn setup_header_mut(&mut self) -> &mut setup_header {
-        &mut self.0.hdr
-    }
-
-    /// Return a const reference of the `setup_header` struct field in `boot_params`
-    pub fn setup_header_ref(&self) -> &setup_header {
-        &self.0.hdr
-    }
-
-    /// Checks whether image is valid and version is supported.
-    pub fn check(&self) -> Result<()> {
-        // Check magic.
-        if !(self.setup_header_ref().boot_flag == 0xAA55
-            && self.setup_header_ref().header.to_le_bytes() == *b"HdrS")
-        {
-            return Err(Error::BadMagic);
-        }
-
-        // Check if it is bzimage and version is supported.
-        if !(self.0.hdr.version >= 0x0206
-            && ((self.setup_header_ref().loadflags & LOAD_FLAG_LOADED_HIGH) != 0))
-        {
-            return Err(Error::UnsupportedVersion);
-        }
-
-        Ok(())
-    }
-
-    /// Gets the number of sectors in the setup code section.
-    pub fn setup_sects(&self) -> usize {
-        match self.setup_header_ref().setup_sects {
-            0 => 4,
-            v => v as usize,
-        }
-    }
-
-    /// Gets the offset to the protected mode kernel in the image.
-    ///
-    /// The value is also the same as the sum of legacy boot sector plus setup code size.
-    pub fn kernel_off(&self) -> usize {
-        // one boot sector + setup sectors
-        (1 + self.setup_sects()) * SECTOR_SIZE
-    }
-
-    /// Gets e820 map entries.
-    pub fn e820_map(&mut self) -> &mut [e820entry] {
-        &mut self.0.e820_map[..]
-    }
-}
-
-/// Boots a Linux bzimage.
-///
-/// # Args
-///
-/// * `kernel`: Buffer holding the loaded bzimage.
-///
-/// * `ramdisk`: Buffer holding the loaded ramdisk.
-///
-/// * `cmdline`: Command line argument blob.
-///
-/// * `mmap_cb`: A caller provided callback for setting the e820 memory map. The callback takes in
-///     a mutable reference of e820 map entries (&mut [e820entry]). On success, it should return
-///     the number of used entries. On error, it can return a
-///     `Error::MemoryMapCallbackError(<code>)` to propagate a custom error code.
-///
-/// * `low_mem_addr`: The lowest memory touched by the bootloader section. This is where boot param
-///      starts.
-///
-/// * The API is not expected to return on success.
-///
-/// # Safety
-///
-/// * Caller must ensure that `kernel` contains a valid Linux kernel and `low_mem_addr` is valid
-///
-/// * Caller must ensure that there is enough memory at address 0x10_0000 for relocating `kernel`.
-pub unsafe fn boot_linux_bzimage<F>(
-    kernel: &[u8],
-    ramdisk: &[u8],
-    cmdline: &[u8],
-    mmap_cb: F,
-    low_mem_addr: usize,
-) -> Result<()>
-where
-    F: FnOnce(&mut [e820entry]) -> Result<u8>,
-{
-    let bootparam = BootParams::from_bytes_ref(&kernel[..])?;
-    bootparam.check()?;
-
-    // low memory address greater than 0x9_0000 is bogus.
-    assert!(low_mem_addr <= 0x9_0000);
-    // SAFETY: By safety requirement of this function, `low_mem_addr` points to sufficiently large
-    // memory.
-    let boot_param_buffer =
-        unsafe { from_raw_parts_mut(low_mem_addr as *mut _, BOOT_SETUP_LOAD_SIZE) };
-    // Note: We currently boot directly from protected mode kernel and bypass real-mode kernel.
-    // Thus we omit the heap section. Revisit this if we encounter platforms that have to boot from
-    // real-mode kernel.
-    let cmdline_start = low_mem_addr + BOOT_SETUP_LOAD_SIZE;
-    // Should not reach into I/O memory hole section.
-    assert!(cmdline_start + cmdline.len() <= 0x0A0000);
-    // SAFETY: By safety requirement of this function, `low_mem_addr` points to sufficiently large
-    // memory.
-    let cmdline_buffer = unsafe { from_raw_parts_mut(cmdline_start as *mut _, cmdline.len()) };
-
-    let boot_sector_size = bootparam.kernel_off();
-    // Copy protected mode kernel to load address
-    // SAFETY: By safety requirement of this function, `LOAD_ADDR_HIGH` points to sufficiently
-    // large memory.
-    unsafe {
-        from_raw_parts_mut(LOAD_ADDR_HIGH as *mut u8, kernel[boot_sector_size..].len())
-            .clone_from_slice(&kernel[boot_sector_size..]);
-    }
-
-    // Zeroizes the entire boot sector.
-    boot_param_buffer.fill(0);
-    let bootparam_fixup = BootParams::from_bytes_mut(boot_param_buffer)?;
-    // Only copies over the header. Leaves the rest zeroes.
-    *bootparam_fixup.setup_header_mut() =
-        *BootParams::from_bytes_ref(&kernel[..])?.setup_header_ref();
-
-    let bootparam_fixup = BootParams::from_bytes_mut(boot_param_buffer)?;
-
-    // Sets commandline.
-    cmdline_buffer.clone_from_slice(cmdline);
-    bootparam_fixup.setup_header_mut().cmd_line_ptr = cmdline_start.try_into().unwrap();
-    bootparam_fixup.setup_header_mut().cmdline_size = cmdline.len().try_into().unwrap();
-
-    // Sets ramdisk address.
-    bootparam_fixup.setup_header_mut().ramdisk_image = (ramdisk.as_ptr() as usize).try_into()?;
-    bootparam_fixup.setup_header_mut().ramdisk_size = ramdisk.len().try_into()?;
-
-    // Sets to loader type "special loader". (Anything other than 0, otherwise linux kernel ignores
-    // ramdisk.)
-    bootparam_fixup.setup_header_mut().type_of_loader = 0xff;
-
-    // Fix up e820 memory map.
-    let num_entries = mmap_cb(bootparam_fixup.e820_map())?;
-    bootparam_fixup.0.e820_entries = num_entries;
-
-    // Clears stack pointers, interrupt and jumps to protected mode kernel.
-    // SAFETY: By safety requirement of this function, input contains a valid linux kernel.
-    #[cfg(target_arch = "x86_64")]
-    unsafe {
-        asm!(
-            "xor ebp, ebp",
-            "xor esp, esp",
-            "cld",
-            "cli",
-            "jmp {ep}",
-            ep = in(reg) LOAD_ADDR_HIGH + ENTRY_POINT_OFFSET,
-            in("rsi") low_mem_addr,
-        );
-    }
-    // SAFETY: By safety requirement of this function, input contains a valid linux kernel.
-    #[cfg(target_arch = "x86")]
-    unsafe {
-        asm!(
-            "xor ebp, ebp",
-            "xor esp, esp",
-            "mov esi, eax",
-            "cld",
-            "cli",
-            "jmp {ep}",
-            ep = in(reg) LOAD_ADDR_HIGH,
-            in("eax") low_mem_addr,
-        );
-    }
-
-    Ok(())
-}
-
-/// Jump to prepared ZBI Fuchsia entry
-///
-/// SAFETY:
-/// Caller must ensure `entry` is valid entry point for kernel.
-/// Caller must ensure `data` is valid ZBI data and is 4K aligned.
-pub unsafe fn zbi_boot_raw(entry: usize, data: &[u8]) -> ! {
-    // Clears stack pointers, interrupt and jumps to protected mode kernel.
-    // SAFETY: By safety requirement of this function, input contains a valid ZBI kernel.
-    #[cfg(target_arch = "x86_64")]
-    unsafe {
-        asm!(
-            "xor ebp, ebp",
-            "xor esp, esp",
-            "cld",
-            "cli",
-            "jmp {ep}",
-            ep = in(reg) entry,
-            in("rsi") data.as_ptr(),
-        );
-    }
-    // SAFETY: By safety requirement of this function, input contains a valid ZBI kernel.
-    #[cfg(target_arch = "x86")]
-    unsafe {
-        asm!(
-            "xor ebp, ebp",
-            "xor esp, esp",
-            "mov esi, eax",
-            "cld",
-            "cli",
-            "jmp {ep}",
-            ep = in(reg) entry,
-            in("eax") data.as_ptr(),
-        );
-    }
-
-    unreachable!();
-}
-
-/// Boot ZBI kernel from provided ZBI containers
-///
-/// SAFETY:
-/// Caller must ensure `kernel` is valid ZBI kernel and is 4K aligned.
-/// Caller must ensure `data` is valid ZBI data and is 4K aligned.
-pub unsafe fn zbi_boot(kernel: &[u8], data: &[u8]) -> ! {
-    let (entry, _) =
-        ZbiContainer::parse(kernel).unwrap().get_kernel_entry_and_reserved_memory_size().unwrap();
-    let addr = (kernel.as_ptr() as usize).checked_add(usize::try_from(entry).unwrap()).unwrap();
-    // SAFETY:
-    // `addr` is calculated from kernel ZBI, which is valid according to safety requirements for
-    // `zbi_boot()` function.
-    // `data` is required to be valid ZBI data as per safety requirements for `zbi_boot()`
-    unsafe { zbi_boot_raw(addr, data) };
-}
diff --git a/gbl/libbootimg/BUILD b/gbl/libbootimg/BUILD
deleted file mode 100644
index 72e9f38..0000000
--- a/gbl/libbootimg/BUILD
+++ /dev/null
@@ -1,135 +0,0 @@
-# Copyright (C) 2023-2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
-# library and instead of only headers. Thus we generate a placeholder source file to meet the
-# requirement.
-genrule(
-    name = "bindgen_noop_cc",
-    outs = ["bindgen_noop_cc.cc"],
-    cmd = "touch $(OUTS)",
-)
-
-cc_library(
-    name = "bootimg_cc_header",
-    srcs = [":bindgen_noop_cc"],
-    hdrs = ["@mkbootimg//:include/bootimg/bootimg.h"],
-)
-
-# The following genernates rust binding for C definitions in `bootimg.h`. It uses the same
-# parameters in script platform/system/tools/mkbootimg/rust/bindgen.sh used for generating the
-# checked-in version platform/system/tools/mkbootimg/rust/bootimg_priv.rs.
-
-BLOCKED_TYPES_RE = "__.+|.?int.+"
-
-BLOCKED_ITEMS_RE = "_.+|.?INT.+|PTR.+|ATOMIC.+|.+SOURCE|.+_H|SIG_.+|SIZE_.+|.?CHAR.+"
-
-CUSTOM_STRUCT_RE = "(vendor_)?(boot_img_hdr|ramdisk_table_entry)_v\\d+"
-
-CUSTOM_STRUCT_DERIVES = "Immutable,IntoBytes,FromBytes,KnownLayout,PartialEq,Copy,Clone,Debug"
-
-rust_bindgen(
-    name = "bootimg_defs_bindgen",
-    bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
-        "--with-derive-default",
-        "--blocklist-type={}".format(BLOCKED_TYPES_RE),
-        "--blocklist-item={}".format(BLOCKED_ITEMS_RE),
-        "--with-derive-custom-struct={}={}".format(
-            CUSTOM_STRUCT_RE,
-            CUSTOM_STRUCT_DERIVES,
-        ),
-        "--raw-line",
-        """
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![cfg_attr(not(test), no_std)]
-use zerocopy::{Immutable, IntoBytes, FromBytes, KnownLayout};""",
-    ],
-    cc_lib = ":bootimg_cc_header",
-    clang_flags = select(
-        {
-            # For x86_32, we need to explicitly specify 32bit architecture.
-            "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-            "//conditions:default": ["-m64"],
-        },
-    ) + [
-        "-x",
-        "c++",
-        "-nostdinc",
-    ],
-    header = "@mkbootimg//:include/bootimg/bootimg.h",
-)
-
-# The source files do not specify "no_std" and thus can't be used as library crate root in our EFI
-# environment. For now, the workaround is to copy over and wrap them under a top level crate that
-# enforces no_std.
-genrule(
-    name = "bootimg_sources_gen",
-    srcs = [
-        "@mkbootimg//:rust/bootimg.rs",
-        ":bootimg_defs_bindgen",
-    ],
-    outs = [
-        "src/bootimg.rs",
-        "src/defs.rs",
-    ],
-    # Copy each src[i] to outs[i]
-    cmd = """
-        IFS=" " read -a srcs <<< "$(SRCS)" && \
-        IFS=" " read -a outs <<< "$(OUTS)" && \
-        for index in $${!srcs[@]}; do cp $${srcs[$$index]} $${outs[$$index]}; done
-""",
-)
-
-rust_library(
-    # The naming is expected by "@mkbootimg//:rust/bootimg.rs".
-    name = "bootimg_bindgen",
-    srcs = ["src/defs.rs"],
-    crate_root = "src/defs.rs",
-    data = [":bootimg_sources_gen"],
-    deps = ["@zerocopy"],
-)
-
-rust_library(
-    name = "libbootimg",
-    srcs = [
-        "src/bootimg.rs",
-        "src/lib.rs",
-    ],
-    crate_name = "bootimg",
-    data = [":bootimg_sources_gen"],
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":bootimg_bindgen",
-        "@gbl//liberror",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libbootimg_test",
-    crate = ":libbootimg",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libbootimg/src/lib.rs b/gbl/libbootimg/src/lib.rs
deleted file mode 100644
index 2469658..0000000
--- a/gbl/libbootimg/src/lib.rs
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! GBL build wrapper for the Android boot image library:
-//! https://cs.android.com/android/platform/superproject/main/+/main:system/tools/mkbootimg/rust/.
-
-#![cfg_attr(not(test), no_std)]
-
-#[rustfmt::skip]
-mod bootimg;
-pub use bootimg::*;
-pub use bootimg_bindgen as defs;
-
-use liberror::Error;
-
-impl From<ImageError> for Error {
-    fn from(err: ImageError) -> Error {
-        match err {
-            ImageError::BufferTooSmall => Error::BufferTooSmall(None),
-            ImageError::BadMagic => Error::BadMagic,
-            ImageError::UnexpectedVersion => Error::UnsupportedVersion,
-            _ => Error::Other(None),
-        }
-    }
-}
diff --git a/gbl/libbootparams/BUILD b/gbl/libbootparams/BUILD
deleted file mode 100644
index 57c4212..0000000
--- a/gbl/libbootparams/BUILD
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libbootparams",
-    srcs = glob(["src/**/*.rs"]),
-    crate_name = "bootparams",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//liberror",
-    ],
-)
-
-rust_test(
-    name = "test",
-    crate = ":libbootparams",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libbootparams/src/bootconfig.rs b/gbl/libbootparams/src/bootconfig.rs
deleted file mode 100644
index 335b357..0000000
--- a/gbl/libbootparams/src/bootconfig.rs
+++ /dev/null
@@ -1,290 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Module for constructing bootconfig. See the following for more details:
-//!
-//! https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig#bootloader-changes
-
-use liberror::{Error, Result};
-
-/// A class for constructing bootconfig section.
-pub struct BootConfigBuilder<'a> {
-    current_size: usize,
-    buffer: &'a mut [u8],
-}
-
-const BOOTCONFIG_MAGIC: &str = "#BOOTCONFIG\n";
-// Trailer structure:
-// struct {
-//     config_size: u32,
-//     checksum: u32,
-//     bootconfig_magic: [u8]
-// }
-/// Size of the bootconfig trailer.
-pub const BOOTCONFIG_TRAILER_SIZE: usize = 4 + 4 + BOOTCONFIG_MAGIC.len();
-
-impl<'a> BootConfigBuilder<'a> {
-    /// Initialize with a given buffer.
-    pub fn new(buffer: &'a mut [u8]) -> Result<Self> {
-        if buffer.len() < BOOTCONFIG_TRAILER_SIZE {
-            return Err(Error::BufferTooSmall(Some(BOOTCONFIG_TRAILER_SIZE)));
-        }
-        let mut ret = Self { current_size: 0, buffer: buffer };
-        ret.update_trailer()?;
-        Ok(ret)
-    }
-
-    /// Get the remaining capacity for adding new bootconfig.
-    pub fn remaining_capacity(&self) -> usize {
-        self.buffer
-            .len()
-            .checked_sub(self.current_size)
-            .unwrap()
-            .checked_sub(BOOTCONFIG_TRAILER_SIZE)
-            .unwrap()
-    }
-
-    /// Get the whole config bytes including trailer.
-    pub fn config_bytes(&self) -> &[u8] {
-        // Arithmetic not expected to fail.
-        &self.buffer[..self.current_size.checked_add(BOOTCONFIG_TRAILER_SIZE).unwrap()]
-    }
-
-    /// Append a new config via a reader callback.
-    ///
-    /// A `&mut [u8]` that covers the remaining space is passed to the callback for reading the
-    /// config bytes. It should return the total size read if operation is successful or
-    /// `Error::BufferTooSmall(Some(<minimum_buffer_size>))`. Attempting to return a size
-    /// greater than the input will cause it to panic. Empty read is allowed. It's up to the caller
-    /// to make sure the read content will eventually form a valid boot config. The API is for
-    /// situations where configs are read from sources such as disk and separate buffer allocation
-    /// is not possible or desired.
-    pub fn add_with<F>(&mut self, reader: F) -> Result<()>
-    where
-        F: FnOnce(&[u8], &mut [u8]) -> Result<usize>,
-    {
-        let remains = self.remaining_capacity();
-        let (current_buffer, remains_buffer) = self.buffer.split_at_mut(self.current_size);
-        let size = reader(&current_buffer[..], &mut remains_buffer[..remains])?;
-        assert!(size <= remains);
-        self.current_size += size;
-        // Content may have been modified. Re-compute trailer.
-        self.update_trailer()
-    }
-
-    /// Append a new config from string.
-    pub fn add(&mut self, config: &str) -> Result<()> {
-        if self.remaining_capacity() < config.len() {
-            return Err(Error::BufferTooSmall(Some(config.len())));
-        }
-        self.add_with(|_, out| {
-            out[..config.len()].clone_from_slice(config.as_bytes());
-            Ok(config.len())
-        })
-    }
-
-    /// Update the boot config trailer at the end of parameter list.
-    /// See specification at:
-    /// https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig#bootloader-changes
-    fn update_trailer(&mut self) -> Result<()> {
-        // Config size
-        let size: u32 = self.current_size.try_into().or(Err(Error::Other(None)))?;
-        // Check sum.
-        let checksum = self.checksum();
-        let trailer = &mut self.buffer[self.current_size..];
-        trailer[..4].clone_from_slice(&size.to_le_bytes());
-        trailer[4..8].clone_from_slice(&checksum.to_le_bytes());
-        trailer[8..][..BOOTCONFIG_MAGIC.len()].clone_from_slice(BOOTCONFIG_MAGIC.as_bytes());
-        Ok(())
-    }
-
-    /// Compute the checksum value.
-    fn checksum(&self) -> u32 {
-        self.buffer[..self.current_size]
-            .iter()
-            .map(|v| *v as u32)
-            .reduce(|acc, v| acc.overflowing_add(v).0)
-            .unwrap_or(0)
-    }
-}
-
-impl core::fmt::Display for BootConfigBuilder<'_> {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        let bytes = self.config_bytes();
-        for val in &bytes[..bytes.len().checked_sub(BOOTCONFIG_TRAILER_SIZE).unwrap()] {
-            write!(f, "{}", core::ascii::escape_default(*val))?;
-        }
-        Ok(())
-    }
-}
-
-impl core::fmt::Write for BootConfigBuilder<'_> {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        self.add_with(|_, out| {
-            out.get_mut(..s.len())
-                .ok_or(Error::BufferTooSmall(Some(s.len())))?
-                .clone_from_slice(s.as_bytes());
-            Ok(s.len())
-        })
-        .map_err(|_| core::fmt::Error)?;
-        Ok(())
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use core::fmt::Write;
-
-    // Taken from Cuttlefish on QEMU aarch64.
-    const TEST_CONFIG: &str = "androidboot.hardware=cutf_cvm
-kernel.mac80211_hwsim.radios=0
-kernel.vmw_vsock_virtio_transport_common.virtio_transport_max_vsock_pkt_buf_size=16384
-androidboot.vendor.apex.com.google.emulated.camera.provider.hal=com.google.emulated.camera.provider.hal
-androidboot.slot_suffix=_a
-androidboot.force_normal_boot=1
-androidboot.hw_timeout_multiplier=50
-androidboot.fstab_suffix=cf.f2fs.hctr2
-androidboot.hypervisor.protected_vm.supported=0
-androidboot.modem_simulator_ports=9600
-androidboot.vsock_lights_port=6900
-androidboot.lcd_density=320
-androidboot.vendor.audiocontrol.server.port=9410
-androidboot.vendor.audiocontrol.server.cid=3
-androidboot.cuttlefish_config_server_port=6800
-androidboot.hardware.gralloc=minigbm
-androidboot.vsock_lights_cid=3
-androidboot.enable_confirmationui=0
-androidboot.hypervisor.vm.supported=0
-androidboot.setupwizard_mode=DISABLED
-androidboot.serialno=CUTTLEFISHCVD011
-androidboot.enable_bootanimation=1
-androidboot.hardware.hwcomposer.display_finder_mode=drm
-androidboot.hardware.angle_feature_overrides_enabled=preferLinearFilterForYUV:mapUnspecifiedColorSpaceToPassThrough
-androidboot.hardware.egl=mesa
-androidboot.boot_devices=4010000000.pcie
-androidboot.opengles.version=196608
-androidboot.wifi_mac_prefix=5554
-androidboot.vsock_tombstone_port=6600
-androidboot.hardware.hwcomposer=ranchu
-androidboot.hardware.hwcomposer.mode=client
-androidboot.console=ttyAMA0
-androidboot.ddr_size=4915MB
-androidboot.cpuvulkan.version=0
-androidboot.serialconsole=1
-androidboot.vbmeta.device=PARTUUID=2b7e273a-42a1-654b-bbad-8cb6ab2b6911
-androidboot.vbmeta.avb_version=1.1
-androidboot.vbmeta.device_state=unlocked
-androidboot.vbmeta.hash_alg=sha256
-androidboot.vbmeta.size=23040
-androidboot.vbmeta.digest=6d6cdbad779475dd945ed79e6bd79c0574541d34ff488fa5aeeb024d739dd0d2
-androidboot.vbmeta.invalidate_on_error=yes
-androidboot.veritymode=enforcing
-androidboot.verifiedbootstate=orange
-";
-
-    const TEST_CONFIG_TRAILER: &[u8; BOOTCONFIG_TRAILER_SIZE] =
-        b"i\x07\x00\x00\xf9\xc4\x02\x00#BOOTCONFIG\n";
-
-    #[test]
-    fn test_add() {
-        let mut buffer = [0u8; TEST_CONFIG.len() + TEST_CONFIG_TRAILER.len()];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        builder.add(TEST_CONFIG).unwrap();
-        assert_eq!(
-            builder.config_bytes().to_vec(),
-            [TEST_CONFIG.as_bytes(), TEST_CONFIG_TRAILER].concat().to_vec()
-        );
-    }
-
-    #[test]
-    fn test_add_incremental() {
-        let mut buffer = [0u8; TEST_CONFIG.len() + TEST_CONFIG_TRAILER.len()];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        for ele in TEST_CONFIG.strip_suffix('\n').unwrap().split('\n') {
-            let config = std::string::String::from(ele) + "\n";
-            builder.add(config.as_str()).unwrap();
-        }
-        assert_eq!(
-            builder.config_bytes().to_vec(),
-            [TEST_CONFIG.as_bytes(), TEST_CONFIG_TRAILER].concat().to_vec()
-        );
-    }
-
-    #[test]
-    fn test_add_with_incremental() {
-        let mut buffer = [0u8; TEST_CONFIG.len() + TEST_CONFIG_TRAILER.len()];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-
-        let mut offset = 0;
-        for ele in TEST_CONFIG.strip_suffix('\n').unwrap().split('\n') {
-            let config = std::string::String::from(ele) + "\n";
-
-            builder
-                .add_with(|current, out| {
-                    assert_eq!(current, &TEST_CONFIG.as_bytes()[..offset]);
-
-                    out[..config.len()].copy_from_slice(config.as_bytes());
-                    Ok(config.len())
-                })
-                .unwrap();
-
-            offset += config.len();
-        }
-        assert_eq!(
-            builder.config_bytes().to_vec(),
-            [TEST_CONFIG.as_bytes(), TEST_CONFIG_TRAILER].concat().to_vec()
-        );
-    }
-
-    #[test]
-    fn test_add_incremental_via_fmt_write() {
-        let mut buffer = [0u8; TEST_CONFIG.len() + TEST_CONFIG_TRAILER.len()];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        for ele in TEST_CONFIG.strip_suffix('\n').unwrap().split('\n') {
-            write!(builder, "{}\n", ele).unwrap();
-        }
-        assert_eq!(
-            builder.config_bytes().to_vec(),
-            [TEST_CONFIG.as_bytes(), TEST_CONFIG_TRAILER].concat().to_vec()
-        );
-    }
-
-    #[test]
-    fn test_new_buffer_too_small() {
-        let mut buffer = [0u8; BOOTCONFIG_TRAILER_SIZE - 1];
-        assert!(BootConfigBuilder::new(&mut buffer[..]).is_err());
-    }
-
-    #[test]
-    fn test_add_buffer_too_small() {
-        let mut buffer = [0u8; BOOTCONFIG_TRAILER_SIZE + 1];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        assert!(builder.add("a\n").is_err());
-    }
-
-    #[test]
-    fn test_add_empty_string() {
-        let mut buffer = [0u8; BOOTCONFIG_TRAILER_SIZE + 1];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        builder.add("").unwrap();
-    }
-
-    #[test]
-    fn test_add_with_error() {
-        let mut buffer = [0u8; BOOTCONFIG_TRAILER_SIZE + 1];
-        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        assert!(builder.add_with(|_, _| Err(Error::Other(None))).is_err());
-    }
-}
diff --git a/gbl/libbootparams/src/commandline.rs b/gbl/libbootparams/src/commandline.rs
deleted file mode 100644
index 02034bb..0000000
--- a/gbl/libbootparams/src/commandline.rs
+++ /dev/null
@@ -1,354 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Module for constructing kernel commandline.
-//!
-//! https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html
-
-use crate::entry::{CommandlineParser, Entry};
-use core::ffi::CStr;
-use liberror::{Error, Error::BufferTooSmall, Error::InvalidInput, Result};
-
-/// A class for constructing commandline section.
-pub struct CommandlineBuilder<'a> {
-    current_size: usize,
-    buffer: &'a mut [u8],
-}
-
-/// Null terminator.
-const COMMANDLINE_TRAILING_SIZE: usize = 1;
-
-impl<'a> CommandlineBuilder<'a> {
-    /// Initialize with a given buffer.
-    pub fn new(buffer: &'a mut [u8]) -> Result<Self> {
-        if buffer.len() < COMMANDLINE_TRAILING_SIZE {
-            return Err(BufferTooSmall(Some(COMMANDLINE_TRAILING_SIZE)));
-        }
-        let mut ret = Self { current_size: 0, buffer: buffer };
-        ret.update_null_terminator();
-        Ok(ret)
-    }
-
-    /// Initialize with a provided buffer that already contains a command line.
-    pub fn new_from_prefix(buffer: &'a mut [u8]) -> Result<Self> {
-        let prefix = CStr::from_bytes_until_nul(buffer).map_err(Error::from)?;
-        Ok(Self { current_size: prefix.to_bytes().len(), buffer: buffer })
-    }
-
-    /// Get the remaining capacity.
-    pub fn remaining_capacity(&self) -> usize {
-        self.buffer.len() - self.current_size - COMMANDLINE_TRAILING_SIZE
-    }
-
-    /// Get the current command line.
-    pub fn as_str(&self) -> &str {
-        // Maintain data null-terminated so not expecting to fail.
-        CStr::from_bytes_with_nul(&self.buffer[..self.current_size + 1])
-            .unwrap()
-            .to_str()
-            .unwrap()
-            .trim()
-    }
-
-    /// Append a new command line segment via a reader callback.
-    ///
-    /// Callback arguments:
-    /// * `&CStr`     - Current null terminated command line data.
-    /// * `&mut [u8]` - Remaining buffer for reading the data into. May be an empty buffer.
-    ///
-    /// Callback return value:
-    /// It must return the total size written or error. Null terminator must not be included in
-    /// the written buffer. Attempting to return a size greater than the input buffer will cause
-    /// it to panic. Empty read is allowed.
-    ///
-    /// It's up to the caller to make sure the read content will eventually form a valid
-    /// command line (space separation is handled by the call). The API is for situations where
-    /// command line is read from sources such as disk and separate buffer allocation is not
-    /// possible or desired.
-    pub fn add_with<F>(&mut self, reader: F) -> Result<()>
-    where
-        F: FnOnce(&CStr, &mut [u8]) -> Result<usize>,
-    {
-        let (current_buffer, mut remains_buffer) =
-            self.buffer.split_at_mut(self.current_size + COMMANDLINE_TRAILING_SIZE);
-
-        let remains_len = remains_buffer.len();
-        // Don't need to reserve space for null terminator since buffer is already empty.
-        // Not expecting callback to append any data in this case.
-        if remains_len != 0 {
-            // Existing null terminator is gonna be replaced with separator, so need
-            // a space for another null terminator to append.
-            remains_buffer = &mut remains_buffer[..remains_len - 1];
-        }
-
-        let current_commandline = CStr::from_bytes_with_nul(current_buffer).unwrap();
-        let size = match reader(current_commandline, &mut remains_buffer[..]) {
-            // Handle buffer too small to make sure we request additional space for null
-            // terminator.
-            Err(BufferTooSmall(Some(requested))) => Err(BufferTooSmall(Some(requested + 1))),
-            other => other,
-        }?;
-        // Empty write, do nothing.
-        if size == 0 {
-            return Ok(());
-        }
-        // Appended command line data cannot have null terminator.
-        if remains_buffer[..size].contains(&0u8) {
-            return Err(InvalidInput);
-        }
-
-        assert!(size <= remains_buffer.len());
-
-        // Replace current null terminator with space separator. This logic adding a redundant
-        // leading space in case build is currently empty. Keep it as is for the simplicity.
-        self.buffer[self.current_size] = b' ';
-        // +1 for space separator
-        self.current_size += size + 1;
-        self.update_null_terminator();
-
-        Ok(())
-    }
-
-    /// Append a new command line.
-    /// Wrapper over `add_with`, so refer to its documentation for details.
-    pub fn add(&mut self, commandline: &str) -> Result<()> {
-        if commandline.is_empty() {
-            return Ok(());
-        }
-
-        // +1 for space separator
-        let required_capacity = commandline.len() + 1;
-        if self.remaining_capacity() < required_capacity {
-            return Err(Error::BufferTooSmall(Some(required_capacity)));
-        }
-
-        self.add_with(|_, out| {
-            out[..commandline.len()].clone_from_slice(commandline.as_bytes());
-            Ok(commandline.len())
-        })
-    }
-
-    /// Get the parsed kernel command line entries.
-    pub fn entries(&'a self) -> impl Iterator<Item = Result<Entry<'a>>> {
-        CommandlineParser::new(self.as_str())
-    }
-
-    /// Update the command line null terminator at the end of the current buffer.
-    fn update_null_terminator(&mut self) {
-        self.buffer[self.current_size] = 0;
-    }
-}
-
-impl core::fmt::Display for CommandlineBuilder<'_> {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        write!(f, "{}", self.as_str())
-    }
-}
-
-impl core::fmt::Write for CommandlineBuilder<'_> {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        self.add(s).map_err(|_| core::fmt::Error)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use core::fmt::Write;
-
-    const TEST_COMMANDLINE: &[u8] =
-        b"video=vfb:640x400,bpp=32,memsize=3072000 console=ttyMSM0,115200n8 earlycon bootconfig\0";
-    const NODE_TO_ADD: &str = "bootconfig";
-
-    #[test]
-    fn test_new_from_prefix() {
-        let mut test_commandline = TEST_COMMANDLINE.to_vec();
-
-        let builder = CommandlineBuilder::new_from_prefix(&mut test_commandline[..]).unwrap();
-        assert_eq!(
-            builder.as_str(),
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
-        );
-    }
-
-    #[test]
-    fn test_new_from_prefix_without_null_terminator() {
-        let mut test_commandline = TEST_COMMANDLINE.to_vec();
-
-        assert!(CommandlineBuilder::new_from_prefix(&mut test_commandline[..1]).is_err());
-    }
-
-    #[test]
-    fn test_empty_initial_buffer() {
-        let mut empty = [0u8; 0];
-
-        assert!(CommandlineBuilder::new(&mut empty[..]).is_err());
-    }
-
-    #[test]
-    fn test_add_incremental() {
-        // 1 extra byte for leading space
-        let mut buffer = [0u8; TEST_COMMANDLINE.len() + 1];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-        for element in
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap().split(' ')
-        {
-            builder.add(element).unwrap();
-        }
-
-        assert_eq!(
-            builder.as_str(),
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
-        );
-    }
-
-    #[test]
-    fn test_add_incremental_via_fmt_write() {
-        // 1 extra byte for leading space
-        let mut buffer = [0u8; TEST_COMMANDLINE.len() + 1];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-        for element in
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap().split(' ')
-        {
-            write!(builder, "{}", element).unwrap();
-        }
-
-        assert_eq!(
-            builder.as_str(),
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
-        );
-    }
-
-    #[test]
-    fn test_add_with_incremental() {
-        // 1 extra byte for leading space
-        let mut buffer = [0u8; TEST_COMMANDLINE.len() + 1];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        let mut offset = 0;
-        for element in
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap().split(' ')
-        {
-            builder
-                .add_with(|current, out| {
-                    let current = core::str::from_utf8(current.to_bytes()).unwrap().trim();
-                    let expected =
-                        core::str::from_utf8(&TEST_COMMANDLINE[..offset]).unwrap().trim();
-                    assert_eq!(current, expected);
-
-                    out[..element.len()].copy_from_slice(element.as_bytes());
-                    Ok(element.len())
-                })
-                .unwrap();
-
-            // +1 for space separator
-            offset += element.len() + 1;
-        }
-
-        assert_eq!(
-            builder.as_str(),
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
-        );
-    }
-
-    #[test]
-    fn test_add_single_node_to_full_buffer() {
-        // 1 extra byte for leading space
-        let mut buffer = [0u8; NODE_TO_ADD.len() + COMMANDLINE_TRAILING_SIZE + 1];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        builder.add(NODE_TO_ADD).unwrap();
-        assert_eq!(builder.as_str(), NODE_TO_ADD);
-        assert_eq!(builder.remaining_capacity(), 0);
-    }
-
-    #[test]
-    fn test_add_with_single_node_to_full_buffer() {
-        // 1 extra byte for leading space
-        let mut buffer = [0u8; NODE_TO_ADD.len() + COMMANDLINE_TRAILING_SIZE + 1];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        assert!(builder
-            .add_with(|current, out| {
-                assert_eq!(current.to_bytes().len(), 0);
-                out[..NODE_TO_ADD.len()].copy_from_slice(NODE_TO_ADD.as_bytes());
-                Ok(NODE_TO_ADD.len())
-            })
-            .is_ok());
-        assert_eq!(builder.remaining_capacity(), 0);
-    }
-
-    #[test]
-    fn test_get_entries() {
-        let mut test_commandline = TEST_COMMANDLINE.to_vec();
-        let builder = CommandlineBuilder::new_from_prefix(&mut test_commandline[..]).unwrap();
-
-        let data_from_builder = builder
-            .entries()
-            .map(|entry| entry.unwrap().to_string())
-            .collect::<Vec<String>>()
-            .join(" ");
-
-        assert_eq!(
-            data_from_builder,
-            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
-        );
-    }
-
-    #[test]
-    fn test_add_to_empty_not_enough_space() {
-        let mut buffer = [0u8; COMMANDLINE_TRAILING_SIZE];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        // + 1 requested for space separator
-        assert_eq!(
-            builder.add(NODE_TO_ADD),
-            Err(Error::BufferTooSmall(Some(NODE_TO_ADD.len() + 1)))
-        );
-    }
-
-    #[test]
-    fn test_add_with_to_empty_not_enough_space_requested_space_for_separator() {
-        let mut buffer = [0u8; COMMANDLINE_TRAILING_SIZE];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        assert_eq!(
-            builder.add_with(|_, _| { Err(Error::BufferTooSmall(Some(NODE_TO_ADD.len()))) }),
-            Err(Error::BufferTooSmall(Some(NODE_TO_ADD.len() + 1)))
-        );
-    }
-
-    #[test]
-    fn test_empty_add_with_to_empty_succeed() {
-        let mut buffer = [0u8; COMMANDLINE_TRAILING_SIZE];
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        assert!(builder.add_with(|_, _| { Ok(0) }).is_ok());
-    }
-
-    #[test]
-    fn test_add_with_null_terminator_invalid_input() {
-        let mut buffer = TEST_COMMANDLINE.to_vec();
-        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
-
-        assert_eq!(
-            builder.add_with(|_, out| {
-                let with_null_terminator = b"null\0terminator";
-                out[..with_null_terminator.len()].copy_from_slice(&with_null_terminator[..]);
-                Ok(with_null_terminator.len())
-            }),
-            Err(Error::InvalidInput)
-        );
-    }
-}
diff --git a/gbl/libbootparams/src/entry.rs b/gbl/libbootparams/src/entry.rs
deleted file mode 100644
index 557abe4..0000000
--- a/gbl/libbootparams/src/entry.rs
+++ /dev/null
@@ -1,242 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Entities to parse and iterate over both kernel command line and bootconfig.
-
-use core::fmt::{Display, Formatter};
-use liberror::{Error, Result};
-
-/// A struct representing a key-value entry inside kernel command line or bootconfig.
-#[derive(Debug, PartialEq, Eq)]
-pub struct Entry<'a> {
-    /// Boot parameters entry key.
-    pub key: &'a str,
-    /// Boot parameters entry value (may be not presented).
-    pub value: Option<&'a str>,
-}
-
-/// Convert Entry into kernel command line / bootconfig compatible string.
-impl<'a> Display for Entry<'a> {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        match self.value {
-            Some(value) => write!(f, "{}={}", self.key, value),
-            None => write!(f, "{}", self.key),
-        }
-    }
-}
-
-/// To iterate over kernel command line entries.
-pub struct CommandlineParser<'a> {
-    data: &'a str,
-    pos: usize,
-}
-
-impl<'a> CommandlineParser<'a> {
-    /// Creates a new iterator from raw command line.
-    pub fn new(data: &'a str) -> Self {
-        CommandlineParser { data, pos: 0 }
-    }
-
-    fn remains(&self) -> &'a str {
-        &self.data.get(self.pos..).unwrap_or("")
-    }
-
-    fn peek(&self) -> Option<char> {
-        self.remains().chars().next()
-    }
-
-    fn skip(&mut self, n: usize) {
-        self.pos += n;
-    }
-
-    fn take_while<F>(&mut self, predicate: F) -> &'a str
-    where
-        F: Fn(char) -> bool,
-    {
-        let remains = self.remains();
-        let n = match remains.find(|c: char| !predicate(c)) {
-            Some(end) => end,
-            // Take everything if we cannot find.
-            None => remains.len(),
-        };
-
-        self.pos += n;
-        &remains[..n]
-    }
-
-    fn skip_whitespaces(&mut self) {
-        self.pos += self.remains().len() - self.remains().trim_start().len();
-    }
-
-    fn parse_key(&mut self) -> Option<&'a str> {
-        self.skip_whitespaces();
-
-        let key = self.take_while(|c| !c.is_whitespace() && c != '=');
-
-        match key.is_empty() {
-            true => None,
-            false => Some(key),
-        }
-    }
-
-    fn parse_value(&mut self) -> Result<Option<&'a str>> {
-        match self.peek() {
-            // Skip the '=' character.
-            Some('=') => self.skip(1),
-            // No value.
-            Some(c) if c.is_whitespace() => return Ok(None),
-            // End of input.
-            None => return Ok(None),
-            // Invalid input
-            _ => {
-                self.skip(self.remains().len());
-                return Err(Error::InvalidInput);
-            }
-        }
-
-        let value = match self.peek() {
-            // Check for the open quote.
-            Some('"') => {
-                // Skip it.
-                self.skip(1);
-                let value = self.take_while(|c| c != '"');
-
-                // Check for the close quote.
-                match self.peek() {
-                    Some('"') => {
-                        // Skip it.
-                        self.skip(1);
-                        value
-                    }
-                    _ => {
-                        self.skip(self.remains().len());
-                        return Err(Error::InvalidInput);
-                    }
-                }
-            }
-            _ => self.take_while(|c| !c.is_whitespace()),
-        };
-
-        Ok(Some(value))
-    }
-}
-
-/// Parse kernel command line format, so we can iterate over key-value entries.
-/// https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html
-impl<'a> Iterator for CommandlineParser<'a> {
-    type Item = Result<Entry<'a>>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        match self.parse_key() {
-            Some(key) => match self.parse_value() {
-                Ok(value) => Some(Ok(Entry { key, value })),
-                Err(e) => Some(Err(e)),
-            },
-            None => None,
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_kernel_command_line_valid_key_value() {
-        let mut iterator = CommandlineParser::new(
-            "video=vfb:640x400,bpp=32,memsize=3072000 console=ttyMSM0,115200n8 earlycon bootconfig",
-        );
-
-        assert_eq!(
-            iterator.next(),
-            Some(Ok(Entry { key: "video", value: Some("vfb:640x400,bpp=32,memsize=3072000") }))
-        );
-        assert_eq!(
-            iterator.next(),
-            Some(Ok(Entry { key: "console", value: Some("ttyMSM0,115200n8") }))
-        );
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "earlycon", value: None })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "bootconfig", value: None })));
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_multiple_spaces_between_entries() {
-        let mut iterator = CommandlineParser::new("key1=val1   key2    key3=val3   key4=val4   ");
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key1", value: Some("val1") })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key2", value: None })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key3", value: Some("val3") })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key4", value: Some("val4") })));
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_no_values() {
-        let mut iterator = CommandlineParser::new("key1 key2 key3");
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key1", value: None })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key2", value: None })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key3", value: None })));
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_empty_values() {
-        let mut iterator = CommandlineParser::new(r#"key1="" key2="" key3="""#);
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key1", value: Some("") })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key2", value: Some("") })));
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key3", value: Some("") })));
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_quoted_values() {
-        let mut iterator = CommandlineParser::new(r#"key1="value with spaces" key2="value""#);
-        assert_eq!(
-            iterator.next(),
-            Some(Ok(Entry { key: "key1", value: Some("value with spaces") }))
-        );
-        assert_eq!(iterator.next(), Some(Ok(Entry { key: "key2", value: Some("value") })));
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_value_with_new_line() {
-        let mut iterator = CommandlineParser::new("key1=\"value with \n new line\"");
-        assert_eq!(
-            iterator.next(),
-            Some(Ok(Entry { key: "key1", value: Some("value with \n new line") }))
-        );
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_invalid_missing_closing_quote() {
-        let mut iterator = CommandlineParser::new(r#"key="value without closing quote key2=val2"#);
-        assert_eq!(iterator.next(), Some(Err(Error::InvalidInput)));
-        // After encountering invalid input, the iterator may not produce more entries.
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_empty() {
-        let mut iterator = CommandlineParser::new("");
-        assert_eq!(iterator.next(), None);
-    }
-
-    #[test]
-    fn test_kernel_command_line_whitespace_only() {
-        let mut iterator = CommandlineParser::new("    \t   \n    ");
-        assert_eq!(iterator.next(), None);
-    }
-}
diff --git a/gbl/libbootparams/src/lib.rs b/gbl/libbootparams/src/lib.rs
deleted file mode 100644
index 54beea1..0000000
--- a/gbl/libbootparams/src/lib.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Library for building kernel command line and bootconfig. Refer to modules tests on how to
-//! use it.
-
-#![cfg_attr(not(test), no_std)]
-
-pub mod bootconfig;
-pub mod commandline;
-pub mod entry;
-
-pub use self::entry::Entry;
diff --git a/gbl/libc/BUILD b/gbl/libc/BUILD
deleted file mode 100644
index 32b305a..0000000
--- a/gbl/libc/BUILD
+++ /dev/null
@@ -1,88 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_cc//cc:defs.bzl", "cc_library", "cc_test")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libc",
-    srcs = glob(["src/*.rs"]),
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":libc_c_staticlib",
-        "@gbl//libsafemath",
-    ],
-)
-
-rust_test(
-    name = "libc_test",
-    crate = ":libc",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
-
-rust_library(
-    name = "libc_deps_posix",
-    srcs = ["deps/posix.rs"],
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
-
-cc_library(
-    name = "headers",
-    hdrs = [
-        "include/debug.h",
-        "include/gbl/print.h",
-        "include/inttypes.h",
-        "include/limits.h",
-        "include/stdio.h",
-        "include/stdlib.h",
-        "include/string.h",
-        "include/sys/types.h",
-    ],
-    includes = ["include"],
-)
-
-cc_library(
-    name = "libc_c",
-    srcs = [
-        "src/format.c",
-    ],
-    deps = [
-        ":headers",
-    ],
-)
-
-cc_test(
-    name = "libc_c_test",
-    srcs = ["src/format_test.cpp"],
-    target_compatible_with = [
-        "@platforms//os:linux",
-    ],
-    deps = [
-        ":libc_c",
-        "@googletest//:gtest_main",
-    ],
-)
-
-link_static_cc_library(
-    name = "libc_c_staticlib",
-    cc_library = ":libc_c",
-)
diff --git a/gbl/libc/deps/posix.rs b/gbl/libc/deps/posix.rs
deleted file mode 100644
index 1424b07..0000000
--- a/gbl/libc/deps/posix.rs
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright 2025, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides platform-specific implementations required by GBL libc.
-//! See `libc/src/lib.rs` for more details.
-//!
-//! This implementation relies on the Rust standard library and can only be used
-//! where it is available (mainly tests in case of GBL).
-
-/// Rust standard library-based print implementation required by GBL `libc`.
-#[no_mangle]
-pub extern "Rust" fn gbl_print(s: &dyn core::fmt::Display) {
-    print!("{}", s);
-}
diff --git a/gbl/libc/include/debug.h b/gbl/libc/include/debug.h
deleted file mode 100644
index 59c1bc3..0000000
--- a/gbl/libc/include/debug.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// Placeholder only.
diff --git a/gbl/libc/include/gbl/print.h b/gbl/libc/include/gbl/print.h
deleted file mode 100644
index 749dad7..0000000
--- a/gbl/libc/include/gbl/print.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __GBL_PRINT_H__
-#define __GBL_PRINT_H__
-
-#include <stdarg.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// GBL-speicifc function to expose print implementation to 3d party C code.
-// Implementation: libc/src/print.c
-void gbl_printf(const char* fmt, va_list args);
-
-// Printing back-end functions to be used by `gbl_printf`.
-// Implementation: libc/src/print.rs
-void gbl_print_string(const char* s);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/gbl/libc/include/inttypes.h b/gbl/libc/include/inttypes.h
deleted file mode 100644
index 59c1bc3..0000000
--- a/gbl/libc/include/inttypes.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// Placeholder only.
diff --git a/gbl/libc/include/limits.h b/gbl/libc/include/limits.h
deleted file mode 100644
index fda0a0f..0000000
--- a/gbl/libc/include/limits.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __STDLIB_LIMITS_H__
-#define __STDLIB_LIMITS_H__
-
-#define LLONG_MAX ((long long)(~0ULL >> 1))
-#define LLONG_MIN (-LLONG_MAX - 1)
-#define ULLONG_MAX (~0ULL)
-
-#endif
diff --git a/gbl/libc/include/stdio.h b/gbl/libc/include/stdio.h
deleted file mode 100644
index 59c1bc3..0000000
--- a/gbl/libc/include/stdio.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// Placeholder only.
diff --git a/gbl/libc/include/stdlib.h b/gbl/libc/include/stdlib.h
deleted file mode 100644
index ad5dad4..0000000
--- a/gbl/libc/include/stdlib.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __STDLIB_H__
-#define __STDLIB_H__
-
-#include <string.h>
-
-void* malloc(size_t size);
-void free(void* ptr);
-int memcmp(const void* ptr1, const void* ptr2, size_t num);
-void* memset(void* destination, int c, size_t num);
-void* memcpy(void* destination, const void* source, size_t num);
-void* memmove(void* destination, const void* source, size_t num);
-
-#endif
diff --git a/gbl/libc/include/string.h b/gbl/libc/include/string.h
deleted file mode 100644
index d73187e..0000000
--- a/gbl/libc/include/string.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __STDLIB_STRING_H__
-#define __STDLIB_STRING_H__
-
-#include <stddef.h>
-
-size_t strlen(const char *str);
-void *memchr(const void *ptr, int ch, size_t count);
-char *strrchr(const char *str, int c);
-char *strchr(const char *str, int c);
-size_t strnlen(const char *s, size_t maxlen);
-int strcmp(const char *s1, const char *s2);
-int strncmp(const char *s1, const char *s2, size_t n);
-unsigned long int strtoul(const char *s, char **endptr, int base);
-
-#endif
diff --git a/gbl/libc/include/sys/types.h b/gbl/libc/include/sys/types.h
deleted file mode 100644
index 46fc049..0000000
--- a/gbl/libc/include/sys/types.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// Placeholder only.
\ No newline at end of file
diff --git a/gbl/libc/src/format.c b/gbl/libc/src/format.c
deleted file mode 100644
index c62e351..0000000
--- a/gbl/libc/src/format.c
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Minimal format string implementation used by GBL to provide printing
-// functionality to third-party C code. Currently used by:
-//
-//   1. `external/libufdt` via `dto_print()`
-//   2. `external/avb/libavb` via `avb_printf()`
-//
-// Because this implementation is used by a limited set of consumers, it
-// provides a simplified format parser that meets the current requirements. The
-// integrator must ensure it remains sufficient for any new use cases.
-//
-// Current functionality is based on the format string specification:
-// (https://cplusplus.com/reference/cstdio/printf/)
-//
-//   %[flags][width][precision][length modifier][conversion specifier]
-//
-//   - flags: not supported (skipped by `skip_flags`)
-//   - width: not supported (skipped by `skip_width`)
-//   - precision: not supported (skipped by `skip_precision`)
-//   - length modifier: all are supported (l, ll, h, hh, z, etc.)
-//   - conversion specifier:
-//       * signed numeric values (i, d)
-//       * unsigned numeric values (u, o, x)
-//       * characters (c)
-//       * nul-terminated strings (s)
-//     Others are not supported (undefined behaviour).
-//
-// TODO(b/394149272): Support floating pointers formatting.
-//
-// The maximum supported output length is 2048 bytes (see `PRINT_BUFFER_SIZE`).
-// Any additional content is silently truncated.
-
-#include <limits.h>
-#include <stddef.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "gbl/print.h"
-
-// Maximum amount of characters can be printed at once. The rest of symbols
-// are getting silently cut.
-#define PRINT_BUFFER_SIZE 2048
-
-#define NUMBER_ALPHABET "0123456789abcdef"
-
-#define BASE_DEC 10U
-#define BASE_OCT 8U
-#define BASE_HEX 16U
-
-#define FLAGS_LONG (1U << 0U)
-#define FLAGS_LONG_LONG (1U << 1U)
-#define FLAGS_CHAR (1U << 2U)
-#define FLAGS_SHORT (1U << 3U)
-
-#define ULL_MAX_DIGITS 20
-
-// Formats unsigned `value` in base `base` into `buffer`.
-//
-// Returns number of characters written to the result buffer.
-static size_t format_number_unsigned(unsigned long long value, char *buffer,
-                                     size_t buffer_len, unsigned int base) {
-  if (buffer_len == 0) return 0;
-
-  if (value == 0) {
-    buffer[0] = '0';
-    return 1;
-  }
-
-  char tmp[ULL_MAX_DIGITS];
-  int tmp_pos = 0;
-
-  // Convert number to reversed string
-  while (value > 0) {
-    tmp[tmp_pos++] = NUMBER_ALPHABET[value % base];
-    value /= base;
-  }
-
-  // Copy reversed number to buffer
-  size_t used = 0;
-  for (int i = tmp_pos - 1; i >= 0 && used < buffer_len; i--) {
-    buffer[used++] = tmp[i];
-  }
-
-  return used;
-}
-
-// Formats signed `value` in base `base` into `buffer`.
-//
-// Returns number of characters written to the result buffer.
-static size_t format_number_signed(long long value, char *buffer,
-                                   size_t buffer_len, unsigned int base) {
-  size_t used = 0;
-  unsigned long long abs = 0;
-
-  if (value < 0) {
-    if (used < buffer_len) {
-      buffer[used++] = '-';
-    }
-    abs = value == LLONG_MIN ? (unsigned long long)(-(value + 1)) + 1 : -value;
-  } else {
-    abs = value;
-  }
-
-  return used +
-         format_number_unsigned(abs, buffer + used, buffer_len - used, base);
-}
-
-// Formats nul-terminated string `s` into `buffer`.
-//
-// Returns number of characters written to the result buffer.
-static size_t format_string(const char *s, char *buffer, size_t buffer_len) {
-  size_t used = 0;
-  while (*s && used < buffer_len) {
-    buffer[used++] = *s++;
-  }
-  return used;
-}
-
-// Formats a single character `c` into `buffer`.
-//
-// Returns number of characters written to the result buffer.
-static size_t format_character(char c, char *buffer, size_t buffer_len) {
-  size_t used = 0;
-  if (buffer_len) {
-    buffer[used++] = c;
-  }
-  return used;
-}
-
-// Noop implementation of the number format used in both width and precision
-// segments to represent the number. Can be asterisk symbol or dec number.
-//
-// Returns number of processed symbols in the format string.
-static size_t skip_format_number(const char *fmt) {
-  if (*fmt == '*') return 1;
-
-  size_t used = 0;
-  while (*fmt >= '0' && *fmt <= '9') {
-    fmt++;
-    used++;
-  }
-  return used;
-}
-
-// Width segment isn't supported by this implementation. It's getting parsed,
-// but ignored.
-//
-// Returns number of processed symbols in the format string.
-static size_t skip_width(const char *fmt) { return skip_format_number(fmt); }
-
-// Precision segment isn't supported by this implementation. It's getting
-// parsed, but ignored.
-//
-// Returns number of processed symbols in the format string.
-static size_t skip_precision(const char *fmt) {
-  if (*fmt == '.') {
-    return 1 + skip_format_number(fmt + 1);
-  }
-  return 0;
-}
-
-// Format flags aren't supported by this implementation. They are getting
-// parsed, but ignored. Skipped symbols: '-', '+', ' ', '#', '0'.
-//
-// Returns number of processed symbols in the format string.
-static size_t skip_flags(const char *fmt) {
-  size_t used = 0;
-  while (strchr("-+ #0", *fmt) != NULL) {
-    fmt++;
-    used++;
-  }
-  return used;
-}
-
-// Parse length modifiers flags.
-//
-// Returns number of processed symbols in the format string.
-static size_t parse_length_modifiers(const char *fmt, unsigned int *out_flags) {
-  size_t used = 0;
-  switch (*fmt) {
-    case 'l':
-      *out_flags = FLAGS_LONG;
-      used++;
-      fmt++;
-      if (*fmt == 'l') {
-        *out_flags = FLAGS_LONG_LONG;
-        used++;
-      }
-      break;
-    case 'h':
-      *out_flags = FLAGS_SHORT;
-      used++;
-      fmt++;
-      if (*fmt == 'h') {
-        *out_flags = FLAGS_CHAR;
-        used++;
-      }
-      break;
-    case 'z':
-      *out_flags =
-          sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG;
-      used++;
-      break;
-    case 'j':
-      *out_flags |=
-          sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG;
-      used++;
-      break;
-    case 't':
-      *out_flags |=
-          sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG;
-      used++;
-      break;
-  }
-  return used;
-}
-
-// Appends an error message into `buffer` to handle unsupported format string
-// symbol error.
-//
-// Returns number of processed symbols in the error message.
-static size_t append_cannot_handle_error(char *buffer, size_t buffer_len,
-                                         char current) {
-  size_t used = 0;
-  used += format_string(
-      "GBL print implementation cannot handle format string at symbol: ",
-      buffer, buffer_len);
-  used += format_character(current, buffer + used, buffer_len - used);
-  return used;
-}
-
-// Format `fmt` into `buffer` using provided `args`.
-//
-// Only `buffer_len` bytes will be formatted. The rest of `fmt` string and
-// provided `args` will be ignored.
-static void gbl_printf_buffer(const char *fmt, va_list args, char *buffer,
-                              size_t buffer_len) {
-  // Ensure can nul terminate.
-  const size_t buffer_available = buffer_len - 1;
-
-  size_t i = 0;
-  while (*fmt && i < buffer_available) {
-    if (*fmt == '%') {
-      // %% case
-      if (*(fmt + 1) == '%') {
-        // Skip one % to print another.
-        fmt++;
-      } else {
-        unsigned int base = BASE_DEC;
-        unsigned int flags = 0;
-        fmt++;
-
-        fmt += skip_flags(fmt);
-        fmt += skip_width(fmt);
-        fmt += skip_precision(fmt);
-        fmt += parse_length_modifiers(fmt, &flags);
-
-        switch (*fmt) {
-          case 's':
-            i += format_string(va_arg(args, char *), buffer + i,
-                               buffer_available - i);
-            fmt++;
-            continue;
-          case 'o':
-          case 'x':
-          case 'u':
-            switch (*fmt) {
-              case 'o':
-                base = BASE_OCT;
-                break;
-              case 'x':
-                base = BASE_HEX;
-                break;
-            }
-            if (flags & FLAGS_LONG_LONG) {
-              i += format_number_unsigned(va_arg(args, unsigned long long),
-                                          buffer + i, buffer_available - i,
-                                          base);
-            } else if (flags & FLAGS_LONG) {
-              i += format_number_unsigned(va_arg(args, unsigned long),
-                                          buffer + i, buffer_available - i,
-                                          base);
-            } else {
-              i +=
-                  format_number_unsigned(va_arg(args, unsigned int), buffer + i,
-                                         buffer_available - i, base);
-            }
-            fmt++;
-            continue;
-          case 'd':
-          case 'i':
-            if (flags & FLAGS_LONG_LONG) {
-              i += format_number_signed(va_arg(args, long long), buffer + i,
-                                        buffer_available - i, base);
-            } else if (flags & FLAGS_LONG) {
-              i += format_number_signed(va_arg(args, long), buffer + i,
-                                        buffer_available - i, base);
-            } else {
-              i += format_number_signed(va_arg(args, int), buffer + i,
-                                        buffer_available - i, base);
-            }
-            fmt++;
-            continue;
-          case 'c':
-            i += format_character(va_arg(args, int), buffer + i,
-                                  buffer_available - i);
-            fmt++;
-            break;
-          default:
-            i += append_cannot_handle_error(buffer + i, buffer_available - i,
-                                            *fmt);
-            goto out;
-        }
-      }
-    }
-    buffer[i++] = *fmt++;
-  }
-
-out:
-  buffer[i] = 0;
-}
-
-// Generic output format implementation to be exposed to 3d party C code.
-void gbl_printf(const char *fmt, va_list args) {
-  char output_buffer[PRINT_BUFFER_SIZE];
-  gbl_printf_buffer(fmt, args, output_buffer, sizeof(output_buffer));
-  gbl_print_string(output_buffer);
-}
diff --git a/gbl/libc/src/format_test.cpp b/gbl/libc/src/format_test.cpp
deleted file mode 100644
index 4d0119b..0000000
--- a/gbl/libc/src/format_test.cpp
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-
-#include "gbl/print.h"
-
-// Must be the same value as `PRINT_BUFFER_SIZE` from format.c
-#define MOCK_PRINT_BUFFER_SIZE 2048
-static char print_buffer[MOCK_PRINT_BUFFER_SIZE];
-
-void gbl_print_string(const char* s) {
-  strncpy(print_buffer, s, MOCK_PRINT_BUFFER_SIZE);
-}
-
-void test_gbl_printf(const char* fmt, ...) {
-  va_list args;
-  va_start(args, fmt);
-  gbl_printf(fmt, args);
-  va_end(args);
-}
-
-TEST(PrintfTest, FormatString) {
-  test_gbl_printf("before %s after", "text");
-  ASSERT_STREQ("before text after", print_buffer);
-}
-
-TEST(PrintfTest, FormatInt) {
-  test_gbl_printf("before %d after", 100);
-  ASSERT_STREQ("before 100 after", print_buffer);
-}
-
-TEST(PrintfTest, FormatChar) {
-  test_gbl_printf("char value: %c", 'a');
-  ASSERT_STREQ("char value: a", print_buffer);
-}
-
-TEST(PrintfTest, FormatCharAsciiCode) {
-  test_gbl_printf("char value: %hhd", 'a');
-  ASSERT_STREQ("char value: 97", print_buffer);
-}
-
-TEST(PrintfTest, FormatUnsigned) {
-  test_gbl_printf("Unsigned value: %u", 123456789U);
-  ASSERT_STREQ("Unsigned value: 123456789", print_buffer);
-}
-
-TEST(PrintfTest, FormatOctal) {
-  test_gbl_printf("Octal value: %o", 0777);
-  ASSERT_STREQ("Octal value: 777", print_buffer);
-}
-
-TEST(PrintfTest, FormatHex) {
-  test_gbl_printf("Hex value: %x", 0xabcdef);
-  ASSERT_STREQ("Hex value: abcdef", print_buffer);
-}
-
-TEST(PrintfTest, FormatEmptyString) {
-  test_gbl_printf("String: '%s'", "");
-  ASSERT_STREQ("String: ''", print_buffer);
-}
-
-TEST(PrintfTest, FormatMultiple) {
-  test_gbl_printf("Values: %d %u %x %s", -42, 42U, 0x42, "forty-two");
-  ASSERT_STREQ("Values: -42 42 42 forty-two", print_buffer);
-}
-
-TEST(PrintfTest, FormatLongLong) {
-  long long val = 1234567890123LL;
-  test_gbl_printf("Long long: %lld", val);
-  ASSERT_STREQ("Long long: 1234567890123", print_buffer);
-}
-
-TEST(PrintfTest, FormatLLongMin) {
-  long long val = LLONG_MIN;
-  char expected[64];
-  snprintf(expected, sizeof(expected), "LLONG_MIN: %lld", val);
-  test_gbl_printf("LLONG_MIN: %lld", val);
-  ASSERT_STREQ(expected, print_buffer);
-}
-
-TEST(PrintfTest, FormatULLongMax) {
-  unsigned long long val = ULLONG_MAX;
-  char expected[64];
-  snprintf(expected, sizeof(expected), "ULLONG_MAX: %llu", val);
-  test_gbl_printf("ULLONG_MAX: %llu", val);
-  ASSERT_STREQ(expected, print_buffer);
-}
-
-TEST(PrintfTest, FormatUnknownSpecifierErrorAppended) {
-  test_gbl_printf("Unknown specifier: %q");
-  ASSERT_STREQ(
-      "Unknown specifier: GBL print implementation cannot handle format string "
-      "at symbol: q",
-      print_buffer);
-}
-
-TEST(PrintfTest, FormatPercent) {
-  test_gbl_printf("percent: %%");
-  ASSERT_STREQ("percent: %", print_buffer);
-}
-
-TEST(PrintfTest, FormatIntNegative) {
-  test_gbl_printf("before %d after", -100);
-  ASSERT_STREQ("before -100 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipWidthZeroFlag) {
-  test_gbl_printf("before %08d after", 42);
-  ASSERT_STREQ("before 42 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipPrecisionInt) {
-  test_gbl_printf("before %.5d after", 2025);
-  ASSERT_STREQ("before 2025 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipComplexFlagsInt) {
-  test_gbl_printf("before %-015.6d after", -999);
-  ASSERT_STREQ("before -999 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipDynamicWidth) {
-  test_gbl_printf("before %*d after", 77);
-  ASSERT_STREQ("before 77 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipDynamicPrecision) {
-  test_gbl_printf("before %.*d after", 123);
-  ASSERT_STREQ("before 123 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipFlagsString) {
-  test_gbl_printf("before %-+#5.8s after", "TestMe!");
-  ASSERT_STREQ("before TestMe! after", print_buffer);
-}
-
-TEST(PrintfTest, SkipPlusFlag) {
-  test_gbl_printf("before %+d after", 100);
-  ASSERT_STREQ("before 100 after", print_buffer);
-}
-
-TEST(PrintfTest, SkipSpaceFlag) {
-  test_gbl_printf("before % d after", 500);
-  ASSERT_STREQ("before 500 after", print_buffer);
-}
-
-TEST(PrintfTest, LongStringIsTruncated) {
-  char long_string[MOCK_PRINT_BUFFER_SIZE + 100];
-  memset(long_string, 'A', sizeof(long_string) - 1);
-  long_string[sizeof(long_string) - 1] = '\0';
-
-  test_gbl_printf("%s", long_string);
-
-  ASSERT_EQ(strlen(print_buffer), MOCK_PRINT_BUFFER_SIZE - 1);
-  for (int i = 0; i < MOCK_PRINT_BUFFER_SIZE - 1; ++i) {
-    ASSERT_EQ(print_buffer[i], 'A') << "Expected character 'A' at index " << i
-                                    << ", but got '" << print_buffer[i] << "'";
-  }
-}
-
-TEST(PrintfTest, MultipleMessages) {
-  test_gbl_printf("First message: %s", "first");
-  ASSERT_STREQ("First message: first", print_buffer);
-  test_gbl_printf("Second message: %s", "second");
-  ASSERT_STREQ("Second message: second", print_buffer);
-}
diff --git a/gbl/libc/src/lib.rs b/gbl/libc/src/lib.rs
deleted file mode 100644
index ad039cd..0000000
--- a/gbl/libc/src/lib.rs
+++ /dev/null
@@ -1,213 +0,0 @@
-// Copyright 2023-2025, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides implementation for a few libc functions for building third party C
-//! libraries.
-
-#![cfg_attr(not(test), no_std)]
-
-extern crate alloc;
-
-use alloc::alloc::{alloc, dealloc};
-use core::{
-    alloc::Layout,
-    ffi::{c_char, c_int, c_ulong, c_void},
-    mem::size_of_val,
-    ptr::{null_mut, NonNull},
-};
-use safemath::SafeNum;
-
-pub use strcmp::{strcmp, strncmp};
-
-pub mod print;
-pub mod strchr;
-pub mod strcmp;
-pub mod strtoul;
-
-// Linking compiler built-in intrinsics to expose libc compatible implementations
-// https://cs.android.com/android/platform/superproject/main/+/2e15fc2eadcb7db07bf6656086c50153bbafe7b6:prebuilts/rust/linux-x86/1.78.0/lib/rustlib/src/rust/vendor/compiler_builtins/src/mem/mod.rs;l=22
-extern "C" {
-    /// int memcmp(const void *src1, const void *src2, size_t n)
-    pub fn memcmp(src1: *const c_void, src2: *const c_void, n: usize) -> c_int;
-    /// void *memset(void *dest, int c, size_t n)
-    pub fn memset(dest: *mut c_void, c: c_int, n: usize) -> *mut c_void;
-    /// void *memcpy(void *dest, const void *src, size_t n)
-    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: usize) -> *mut c_void;
-    /// size_t strlen(const char *s)
-    pub fn strlen(s: *const c_char) -> usize;
-}
-
-// Linking the platform-specific functionality expected to be provided by the
-// library/app, which includes the GBL `libc`.
-extern "Rust" {
-    /// GBL `libc` expects user to provide platform-specific text output implementation
-    /// to allow libc to expose it for external C libraries.
-    ///
-    /// A default POSIX-based implementation is available at `libc/deps/posix.rs`.
-    /// An EFI-specific implementation is provided by `libefi/src/libc.rs`.
-    fn gbl_print(d: &dyn core::fmt::Display);
-}
-
-/// Extended version of void *malloc(size_t size) with ptr alignment configuration support.
-/// Libraries may have a different alignment requirements.
-///
-/// # Safety
-///
-/// * Returns a valid pointer to a memory block of `size` bytes, aligned to `alignment`, or null
-///   on failure.
-#[no_mangle]
-pub unsafe extern "C" fn gbl_malloc(request_size: usize, alignment: usize) -> *mut c_void {
-    (|| {
-        // Prefix data:
-        let mut size = 0usize;
-        let mut offset = 0usize;
-
-        // Determine prefix size necessary to store data required for [gbl_free]: size, offset
-        let prefix_size: usize = size_of_val(&size) + size_of_val(&offset);
-
-        // Determine padding necessary to guarantee alignment. Padding includes prefix data.
-        let pad: usize = (SafeNum::from(alignment) + prefix_size).try_into().ok()?;
-
-        // Actual size to allocate. It includes padding to guarantee alignment.
-        size = (SafeNum::from(request_size) + pad).try_into().ok()?;
-
-        // SAFETY:
-        // *  On success, `alloc` guarantees to allocate enough memory.
-        let ptr = unsafe {
-            // Due to manual aligning, there is no need for specific layout alignment.
-            NonNull::new(alloc(Layout::from_size_align(size, 1).ok()?))?.as_ptr()
-        };
-
-        // Calculate the aligned address to return the caller.
-        let ret_address = (SafeNum::from(ptr as usize) + prefix_size).round_up(alignment);
-
-        // Calculate the offsets from the allocation start.
-        let ret_offset = ret_address - (ptr as usize);
-        let align_offset: usize = (ret_offset - size_of_val(&size)).try_into().ok()?;
-        let size_offset: usize = (align_offset - size_of_val(&offset)).try_into().ok()?;
-        offset = usize::try_from(ret_offset).ok()?;
-
-        // SAFETY:
-        // 'ptr' is guarantied to be valid:
-        // - not NULL; Checked with `NonNull`
-        // - it points to single block of memory big enough to hold size+offset (allocated this
-        // way)
-        // - memory is 1-byte aligned for [u8] slice
-        // - ptr+offset is guarantied to point to the buffer of size 'size' as per allocation that
-        // takes into account padding and prefix.
-        unsafe {
-            // Write metadata and return the caller's pointer.
-            core::slice::from_raw_parts_mut(ptr.add(size_offset), size_of_val(&size))
-                .copy_from_slice(&size.to_ne_bytes());
-            core::slice::from_raw_parts_mut(ptr.add(align_offset), size_of_val(&offset))
-                .copy_from_slice(&offset.to_ne_bytes());
-
-            Some(ptr.add(offset))
-        }
-    })()
-    .unwrap_or(null_mut()) as _
-}
-
-/// Extended version of void free(void *ptr) with ptr alignment configuration support.
-///
-/// # Safety
-///
-/// * `ptr` must be allocated by `gbl_malloc` and guarantee enough memory for a preceding
-///   `usize` value and payload or null.
-/// * `gbl_free` must be called with the same `alignment` as the corresponding `gbl_malloc` call.
-#[no_mangle]
-pub unsafe extern "C" fn gbl_free(ptr: *mut c_void, alignment: usize) {
-    if ptr.is_null() {
-        // follow libc free behavior
-        return;
-    }
-    let mut ptr = ptr as *mut u8;
-
-    let mut offset = 0usize;
-    let mut size = 0usize;
-
-    // Calculate offsets for size of align data
-    let align_offset: usize = size_of_val(&size);
-    let size_offset: usize = align_offset + size_of_val(&size);
-
-    // Read size used in allocation from prefix data.
-    offset = usize::from_ne_bytes(
-        // SAFETY:
-        // * `ptr` is allocated by `gbl_malloc` and has enough padding before `ptr` to hold
-        // prefix data. Which consists of align and size values.
-        // * Alignment is 1 for &[u8]
-        unsafe { core::slice::from_raw_parts(ptr.sub(align_offset), size_of_val(&offset)) }
-            .try_into()
-            .unwrap(),
-    );
-
-    // Read offset for unaligned pointer from prefix data.
-    size = usize::from_ne_bytes(
-        // SAFETY:
-        // * `ptr` is allocated by `gbl_malloc` and has enough padding before `ptr` to hold
-        // prefix data. Which consists of align and size values.
-        // * Alignment is 1 for &[u8]
-        unsafe { core::slice::from_raw_parts(ptr.sub(size_offset), size_of_val(&size)) }
-            .try_into()
-            .unwrap(),
-    );
-
-    // SAFETY:
-    // * `ptr` is allocated by `gbl_malloc` and has enough padding before `ptr` to hold
-    // prefix data. ptr - offset must point to unaligned pointer to buffer, which was returned by
-    // `alloc`, and must be passed to `dealloc`
-    unsafe {
-        // Calculate unaligned pointer returned by [alloc], which must be used in [dealloc]
-        ptr = ptr.sub(offset);
-
-        // Call to global allocator.
-        dealloc(ptr, Layout::from_size_align(size, alignment).unwrap());
-    };
-}
-
-/// void *memchr(const void *ptr, int ch, size_t count);
-///
-/// # Safety
-///
-/// * `ptr` needs to be a buffer with at least `count` bytes.
-/// * Returns the pointer within `ptr` buffer, or null if not found.
-#[no_mangle]
-pub unsafe extern "C" fn memchr(ptr: *const c_void, ch: c_int, count: c_ulong) -> *mut c_void {
-    assert!(!ptr.is_null());
-    let start = ptr as *const u8;
-    let target = (ch & 0xff) as u8;
-    for i in 0..count {
-        // SAFETY: `ptr` buffer is assumed valid and bounded by count.
-        let curr = unsafe { start.add(i.try_into().unwrap()) };
-        // SAFETY: `ptr` buffer is assumed valid and bounded by count.
-        if *unsafe { curr.as_ref().unwrap() } == target {
-            return curr as *mut _;
-        }
-    }
-    null_mut()
-}
-
-/// size_t strnlen(const char *s, size_t maxlen);
-///
-/// # Safety
-///
-/// * `s` must be a valid pointer to a null terminated C string.
-#[no_mangle]
-pub unsafe extern "C" fn strnlen(s: *const c_char, maxlen: usize) -> usize {
-    // SAFETY: `s` is a valid pointer to a null terminated string.
-    match unsafe { memchr(s as *const _, 0, maxlen.try_into().unwrap()) } {
-        p if p.is_null() => maxlen,
-        p => (p as usize) - (s as usize),
-    }
-}
diff --git a/gbl/libc/src/print.rs b/gbl/libc/src/print.rs
deleted file mode 100644
index 32c5850..0000000
--- a/gbl/libc/src/print.rs
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright 2025, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides printing back-end functions to be used by GBL format
-//! printing implementation: libc/src/print.c
-
-use crate::gbl_print;
-use core::ffi::{c_char, CStr};
-
-/// Back-end function to print a nul-terminated string.
-///
-/// # Safety:
-///
-/// * `s` must be a valid null-terminated C string.
-#[no_mangle]
-pub unsafe extern "C" fn gbl_print_string(s: *const c_char) {
-    if s.is_null() {
-        return;
-    }
-    // SAFETY: `s` must be a valid nul-terminated C string.
-    let cstr = unsafe { CStr::from_ptr(s) };
-
-    // Safety:
-    // * `gbl_print` is expected to be statically linked and expected
-    // core::fmt::Display compatible types.
-    unsafe {
-        gbl_print(&cstr.to_string_lossy());
-    }
-}
diff --git a/gbl/libc/src/strchr.rs b/gbl/libc/src/strchr.rs
deleted file mode 100644
index 857eab1..0000000
--- a/gbl/libc/src/strchr.rs
+++ /dev/null
@@ -1,207 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides implementation for strchr libc functions family.
-//! https://en.cppreference.com/w/c/string/byte/strchr
-
-use core::ffi::{c_char, c_int, CStr};
-use core::ptr::null_mut;
-
-/// char *strchr(const char *str, int c);
-///
-/// # Safety
-///
-/// * `str` must be a valid null-terminated C string.
-#[no_mangle]
-pub unsafe extern "C" fn strchr(ptr: *const c_char, ch: c_int) -> *mut c_char {
-    assert!(!ptr.is_null());
-    // SAFETY: `str` is a valid null terminated string.
-    let bytes = unsafe { CStr::from_ptr(ptr) }.to_bytes_with_nul();
-    let target = (ch & 0xff) as u8;
-    for c in bytes.iter() {
-        if *c == target {
-            return c as *const _ as *mut _;
-        }
-    }
-    null_mut()
-}
-
-/// char *strrchr(const char *str, int c);
-///
-/// # Safety
-///
-/// * `str` must be a valid null-terminated C string.
-#[no_mangle]
-pub unsafe extern "C" fn strrchr(ptr: *const c_char, ch: c_int) -> *mut c_char {
-    assert!(!ptr.is_null());
-    // SAFETY: `str` is a null terminated string.
-    let bytes = unsafe { CStr::from_ptr(ptr) }.to_bytes_with_nul();
-    let target = (ch & 0xff) as u8;
-    for c in bytes.iter().rev() {
-        if *c == target {
-            return c as *const _ as *mut _;
-        }
-    }
-    null_mut()
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use std::ffi::CString;
-
-    fn to_cstr(s: &str) -> CString {
-        CString::new(s).unwrap()
-    }
-
-    fn do_strchr(input: &str, c: char) -> Option<usize> {
-        let input_cstr = to_cstr(input);
-        // SAFETY: `input_cstr` is a null terminated string.
-        let result = unsafe { strchr(input_cstr.as_ptr(), c as c_int) };
-
-        if result.is_null() {
-            None
-        } else {
-            let start_ptr = input_cstr.as_ptr();
-            // SAFETY: `result` is a pointer within the string that `start_ptr` points to.
-            Some(unsafe { result.offset_from(start_ptr) as usize })
-        }
-    }
-
-    fn do_strrchr(input: &str, c: char) -> Option<usize> {
-        let input_cstr = to_cstr(input);
-        // SAFETY: `input_cstr` is a null terminated string.
-        let result = unsafe { strrchr(input_cstr.as_ptr(), c as c_int) };
-
-        if result.is_null() {
-            None
-        } else {
-            let start_ptr = input_cstr.as_ptr();
-            // SAFETY: `result` is a pointer within the string that `start_ptr` points to.
-            Some(unsafe { result.offset_from(start_ptr) as usize })
-        }
-    }
-
-    // strchr tests
-
-    #[test]
-    fn strchr_find_first_occurrence() {
-        let offset = do_strchr("hello", 'e');
-        assert_eq!(offset, Some(1));
-    }
-
-    #[test]
-    fn strchr_find_first_occurrence_special_character() {
-        let offset = do_strchr("he!lo", '!');
-        assert_eq!(offset, Some(2));
-    }
-
-    #[test]
-    fn strchr_character_not_present() {
-        let offset = do_strchr("hello", 'z');
-        assert_eq!(offset, None);
-    }
-
-    #[test]
-    fn strchr_find_first_occurrence_at_start() {
-        let offset = do_strchr("hello", 'h');
-        assert_eq!(offset, Some(0));
-    }
-
-    #[test]
-    fn strchr_find_first_occurrence_at_end() {
-        let offset = do_strchr("hello", 'o');
-        assert_eq!(offset, Some(4));
-    }
-
-    #[test]
-    fn strchr_empty_string() {
-        let offset = do_strchr("", 'a');
-        assert_eq!(offset, None);
-    }
-
-    #[test]
-    fn strchr_find_first_occurrence_multiple() {
-        let offset = do_strchr("hellohello", 'l');
-        assert_eq!(offset, Some(2));
-    }
-
-    #[test]
-    fn strchr_case_sensitivity() {
-        let offset = do_strchr("Hello", 'h');
-        assert_eq!(offset, None);
-    }
-
-    #[test]
-    fn strchr_find_null_character() {
-        let offset = do_strchr("Hello", '\0');
-        assert_eq!(offset, Some(5));
-    }
-
-    // strrchr tests
-
-    #[test]
-    fn strrchr_find_last_occurrence() {
-        let offset = do_strrchr("hello", 'l');
-        assert_eq!(offset, Some(3));
-    }
-
-    #[test]
-    fn strrchr_find_last_occurrence_special_character() {
-        let offset = do_strrchr("he!lo!lo", '!');
-        assert_eq!(offset, Some(5));
-    }
-
-    #[test]
-    fn strrchr_character_not_present() {
-        let offset = do_strrchr("hello", 'z');
-        assert_eq!(offset, None);
-    }
-
-    #[test]
-    fn strrchr_find_last_occurrence_at_start() {
-        let offset = do_strrchr("hello", 'h');
-        assert_eq!(offset, Some(0));
-    }
-
-    #[test]
-    fn strrchr_find_last_occurrence_at_end() {
-        let offset = do_strrchr("hello", 'o');
-        assert_eq!(offset, Some(4));
-    }
-
-    #[test]
-    fn strrchr_empty_string() {
-        let offset = do_strrchr("", 'a');
-        assert_eq!(offset, None);
-    }
-
-    #[test]
-    fn strrchr_find_last_occurrence_multiple() {
-        let offset = do_strrchr("hellohello", 'l');
-        assert_eq!(offset, Some(8));
-    }
-
-    #[test]
-    fn strrchr_case_sensitivity() {
-        let offset = do_strrchr("Hello", 'h');
-        assert_eq!(offset, None);
-    }
-
-    #[test]
-    fn strrchr_find_null_character() {
-        let offset = do_strchr("Hello", '\0');
-        assert_eq!(offset, Some(5));
-    }
-}
diff --git a/gbl/libc/src/strcmp.rs b/gbl/libc/src/strcmp.rs
deleted file mode 100644
index 987773c..0000000
--- a/gbl/libc/src/strcmp.rs
+++ /dev/null
@@ -1,206 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides implementation for strcmp libc functions family.
-//! https://en.cppreference.com/w/c/string/byte/strncmp
-
-use core::cmp::Ordering;
-use core::ffi::{c_char, c_int, CStr};
-
-/// int strcmp(const char *s1, const char *s2);
-///
-/// # Safety
-///
-/// * `s1` and `s2` must be valid pointers to null terminated C strings.
-#[no_mangle]
-pub unsafe extern "C" fn strcmp(s1: *const c_char, s2: *const c_char) -> c_int {
-    // SAFETY: `s1` and `s2` are valid null-terminated strings. References are only used
-    // within function.
-    let (lhs, rhs) = unsafe { (CStr::from_ptr(s1.cast()), CStr::from_ptr(s2.cast())) };
-    Ord::cmp(lhs, rhs) as _
-}
-
-/// int strncmp(const char *s1, const char *s2, size_t n);
-///
-/// # Safety
-///
-/// * `s1` and `s2` must be at least nth sized or null terminated arrays.
-#[no_mangle]
-pub unsafe extern "C" fn strncmp(s1: *const c_char, s2: *const c_char, n: usize) -> c_int {
-    for i in 0..n {
-        // SAFETY: `i` is always within the bounds of `s1` and `s2` because it is limited by `n`,
-        // and this statement is unreachable if a null character is already encountered in `s1`
-        // or `s2`.
-        let (l, r) = unsafe { (*s1.add(i), *s2.add(i)) };
-
-        let cmp = l.cmp(&r);
-        if cmp != Ordering::Equal || l == 0 {
-            return cmp as _;
-        }
-    }
-    Ordering::Equal as _
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use std::ffi::CString;
-
-    fn to_cstr(s: &str) -> CString {
-        CString::new(s).unwrap()
-    }
-
-    fn do_strcmp(left: &str, right: &str) -> c_int {
-        let left_cstr = to_cstr(left);
-        let right_cstr = to_cstr(right);
-        // SAFETY: `left_cstr` and `right_cstr` are null terminated strings.
-        unsafe { strcmp(left_cstr.as_ptr(), right_cstr.as_ptr()) }
-    }
-
-    fn do_strncmp(left: &str, right: &str, n: usize) -> c_int {
-        let left_cstr = to_cstr(left);
-        let right_cstr = to_cstr(right);
-        // SAFETY: `left_cstr` and `right_cstr` are null terminated strings.
-        unsafe { strncmp(left_cstr.as_ptr(), right_cstr.as_ptr(), n) }
-    }
-
-    fn do_strncmp_bytes(left: &[u8], right: &[u8], n: usize) -> c_int {
-        // SAFETY: `left` and `right` are not null.
-        unsafe { strncmp(left.as_ptr().cast(), right.as_ptr().cast(), n) }
-    }
-
-    // strcmp tests
-
-    #[test]
-    fn strcmp_same() {
-        assert_eq!(do_strcmp("first", "first"), 0);
-    }
-
-    #[test]
-    fn strcmp_same_special_characters() {
-        assert_eq!(do_strcmp("!@#", "!@#"), 0);
-    }
-
-    #[test]
-    fn strcmp_left_smaller() {
-        assert_eq!(do_strcmp("first", "second"), -1);
-    }
-
-    #[test]
-    fn strcmp_left_is_prefix_of_right() {
-        assert_eq!(do_strcmp("first", "firstly"), -1);
-    }
-
-    #[test]
-    fn strcmp_right_is_prefix_of_left() {
-        assert_eq!(do_strcmp("firstly", "first"), 1);
-    }
-
-    #[test]
-    fn strcmp_empty() {
-        assert_eq!(do_strcmp("", ""), 0);
-    }
-
-    #[test]
-    fn strcmp_empty_vs_non_empty() {
-        assert_eq!(do_strcmp("", "nonempty"), -1);
-    }
-
-    #[test]
-    fn strcmp_non_empty_vs_empty() {
-        assert_eq!(do_strcmp("nonempty", ""), 1);
-    }
-
-    #[test]
-    fn strcmp_case_sensitivity() {
-        assert_eq!(do_strcmp("First", "first"), -1);
-    }
-
-    // strncmp tests
-
-    #[test]
-    fn strncmp_same_exact_length() {
-        assert_eq!(do_strncmp("hello", "hello", 5), 0);
-    }
-
-    #[test]
-    fn strncmp_same_partial_length() {
-        assert_eq!(do_strncmp("hello", "hello", 3), 0);
-    }
-
-    #[test]
-    fn strncmp_same_overflow() {
-        assert_eq!(do_strncmp("hello", "hello", 100), 0);
-    }
-
-    #[test]
-    fn strncmp_same_special_characters() {
-        assert_eq!(do_strncmp("!@#", "!@#", 3), 0);
-    }
-
-    #[test]
-    fn strncmp_different_exact_length() {
-        assert_eq!(do_strncmp("hello", "world", 5), -1);
-    }
-
-    #[test]
-    fn strncmp_different_partial_length() {
-        assert_eq!(do_strncmp("hello", "world", 3), -1);
-    }
-
-    #[test]
-    fn strncmp_left_is_prefix_of_right() {
-        assert_eq!(do_strncmp("abc", "abcdef", 6), -1);
-    }
-
-    #[test]
-    fn strncmp_right_is_prefix_of_left() {
-        assert_eq!(do_strncmp("abcdef", "abc", 6), 1);
-    }
-
-    #[test]
-    fn strncmp_empty_strings() {
-        assert_eq!(do_strncmp("", "", 5), 0);
-    }
-
-    #[test]
-    fn strncmp_empty_vs_non_empty() {
-        assert_eq!(do_strncmp("", "hello", 5), -1);
-    }
-
-    #[test]
-    fn strncmp_non_empty_vs_empty() {
-        assert_eq!(do_strncmp("hello", "", 5), 1);
-    }
-
-    #[test]
-    fn strncmp_case_sensitivity() {
-        assert_eq!(do_strncmp("Hello", "hello", 5), -1);
-    }
-
-    #[test]
-    fn strncmp_bytes_array_same_exact_length() {
-        assert_eq!(do_strncmp_bytes(b"hello", b"hello", 5), 0);
-    }
-
-    #[test]
-    fn strncmp_bytes_array_right_terminated() {
-        assert_eq!(do_strncmp_bytes(b"hello", b"hel\0", 5), 1);
-    }
-
-    #[test]
-    fn strncmp_bytes_array_left_terminated() {
-        assert_eq!(do_strncmp_bytes(b"hel\0", b"hello", 5), -1);
-    }
-}
diff --git a/gbl/libc/src/strtoul.rs b/gbl/libc/src/strtoul.rs
deleted file mode 100644
index 091bf46..0000000
--- a/gbl/libc/src/strtoul.rs
+++ /dev/null
@@ -1,349 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides implementation for strtoul libc functions family.
-//! https://en.cppreference.com/w/cpp/string/byte/strtoul
-
-use core::ffi::{c_char, c_int, c_ulong, CStr};
-use safemath::SafeNum;
-
-/// unsigned long int strtoul(const char *s, char **endptr, int base);
-///
-/// # Safety
-///
-/// * `s` must be valid pointer to null terminated C string
-/// * `endptr` must be a valid pointer that is available for writing or null
-#[no_mangle]
-pub unsafe extern "C" fn strtoul(
-    s: *const c_char,
-    endptr: *mut *const c_char,
-    base: c_int,
-) -> c_ulong {
-    assert!(!s.is_null());
-    assert!(base == 0 || base == 8 || base == 10 || base == 16);
-
-    let mut pos = 0;
-    let mut base = base;
-    let mut negative = false;
-
-    // SAFETY: `s` is a valid null terminated string
-    let bytes = unsafe { CStr::from_ptr(s) }.to_bytes();
-
-    // Skip leading whitespace
-    while pos < bytes.len() && bytes[pos].is_ascii_whitespace() {
-        pos += 1;
-    }
-
-    // Handle sign
-    if pos < bytes.len() {
-        match bytes[pos] {
-            b'+' => pos += 1,
-            b'-' => {
-                pos += 1;
-                negative = true;
-            }
-            _ => {}
-        }
-    }
-
-    // Handle base prefixes
-    if (base == 16 || base == 0)
-        && pos < bytes.len() - 1
-        && bytes[pos] == b'0'
-        && (bytes[pos + 1] == b'x' || bytes[pos + 1] == b'X')
-    {
-        pos += 2;
-        base = 16;
-    }
-    if (base == 8 || base == 0) && pos < bytes.len() && bytes[pos] == b'0' {
-        pos += 1;
-        base = 8;
-    }
-    if base == 0 {
-        base = 10;
-    }
-
-    let mut result: SafeNum = 0.into();
-    while pos < bytes.len() {
-        let symbol = bytes[pos];
-        let value = match symbol {
-            b'0'..=b'7' if base == 8 => symbol - b'0',
-            b'0'..=b'9' if base == 10 || base == 16 => symbol - b'0',
-            b'a'..=b'f' if base == 16 => symbol - b'a' + 10,
-            b'A'..=b'F' if base == 16 => symbol - b'A' + 10,
-            _ => break,
-        };
-        result = result * base + value;
-        pos += 1;
-    }
-
-    if !endptr.is_null() {
-        // SAFETY: `endptr` is a non-null pointer which is available for writing, `s` is a valid
-        // non-null pointer, `pos` is guaranteed to be within `s` by `pos < bytes.len()` checks.
-        unsafe { *endptr = s.add(pos) };
-    }
-
-    match c_ulong::try_from(result) {
-        Ok(result) if negative => result.overflowing_neg().0,
-        Ok(result) => result,
-        _ => c_ulong::MAX,
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use std::ffi::CString;
-    use std::ptr::null_mut;
-
-    fn to_cstr(s: &str) -> CString {
-        CString::new(s).unwrap()
-    }
-
-    fn do_strtoul(input: &str, base: i32) -> (c_ulong, Option<usize>) {
-        let input_cstr = to_cstr(input);
-        let mut end_ptr: *const c_char = null_mut();
-        // SAFETY: `input_cstr` is a null terminated string, `end_ptr` is initialized null pointer
-        let result = unsafe { strtoul(input_cstr.as_ptr(), &mut end_ptr, base) };
-
-        let end_position = if end_ptr.is_null() {
-            None
-        } else {
-            let start_ptr = input_cstr.as_ptr();
-            // SAFETY: `end_ptr` is a pointer within the string that `start_ptr` points to
-            Some(unsafe { end_ptr.offset_from(start_ptr) } as usize)
-        };
-
-        (result, end_position)
-    }
-
-    fn do_strtoul_no_endptr(input: &str, base: i32) -> c_ulong {
-        let input_cstr = to_cstr(input);
-        // SAFETY: `input_cstr` is a null terminated string
-        unsafe { strtoul(input_cstr.as_ptr(), null_mut(), base) }
-    }
-
-    // strtoul tests
-
-    #[test]
-    fn strtoul_decimal() {
-        let (r, end) = do_strtoul("12345", 10);
-        assert_eq!(r, 12345);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_no_endptr() {
-        let r = do_strtoul_no_endptr("12345", 10);
-        assert_eq!(r, 12345);
-    }
-
-    #[test]
-    fn strtoul_zero() {
-        let (r, end) = do_strtoul("0", 10);
-        assert_eq!(r, 0);
-        assert_eq!(end, Some(1));
-    }
-
-    #[test]
-    fn strtoul_empty() {
-        let (r, end) = do_strtoul("", 10);
-        assert_eq!(r, 0);
-        // Empty input, end_ptr should point to the start
-        assert_eq!(end, Some(0));
-    }
-
-    #[test]
-    fn strtoul_empty_no_endptr() {
-        let r = do_strtoul_no_endptr("", 10);
-        assert_eq!(r, 0);
-    }
-
-    #[test]
-    fn strtoul_invalid_characters() {
-        let (r, end) = do_strtoul("123abc", 10);
-        assert_eq!(r, 123);
-        // Parsing stops at 'a', so end_ptr should point to index 3
-        assert_eq!(end, Some(3));
-    }
-
-    #[test]
-    fn strtoul_positive_sign() {
-        let (r, end) = do_strtoul("+456", 10);
-        assert_eq!(r, 456);
-        assert_eq!(end, Some(4));
-    }
-
-    #[test]
-    fn strtoul_negative_sign() {
-        let (r, end) = do_strtoul("-1000", 10);
-        assert_eq!(r, 18446744073709550616);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_negative_zero_sign() {
-        let (r, end) = do_strtoul("-0", 10);
-        assert_eq!(r, 0);
-        assert_eq!(end, Some(2));
-    }
-
-    #[test]
-    fn strtoul_prefix_spaces() {
-        let (r, end) = do_strtoul("   456", 10);
-        assert_eq!(r, 456);
-        assert_eq!(end, Some(6));
-    }
-
-    #[test]
-    fn strtoul_leading_zeroes() {
-        let (r, end) = do_strtoul("0000456", 10);
-        assert_eq!(r, 456);
-        assert_eq!(end, Some(7));
-    }
-
-    #[test]
-    fn strtoul_overflow() {
-        let (r, end) = do_strtoul("999999999999999999999999999999", 10);
-        assert_eq!(r, c_ulong::MAX);
-        // Whole input string got processed, so end_ptr should point to the end
-        assert_eq!(end, Some(30));
-    }
-
-    #[test]
-    fn strtoul_octal() {
-        let (r, end) = do_strtoul("12345", 8);
-        assert_eq!(r, 0o12345);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_octal_prefix() {
-        let (r, end) = do_strtoul("01234", 8);
-        assert_eq!(r, 0o1234);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_octal_invalid_characters() {
-        let (r, end) = do_strtoul("1289", 8);
-        assert_eq!(r, 0o12);
-        assert_eq!(end, Some(2));
-    }
-
-    #[test]
-    fn strtoul_octal_prefix_spaces() {
-        let (r, end) = do_strtoul("   0755", 8);
-        assert_eq!(r, 0o755);
-        assert_eq!(end, Some(7));
-    }
-
-    #[test]
-    fn strtoul_octal_leading_zeroes() {
-        let (r, end) = do_strtoul("0000456", 8);
-        assert_eq!(r, 0o456);
-        assert_eq!(end, Some(7));
-    }
-
-    #[test]
-    fn strtoul_octal_overflow() {
-        let (r, end) = do_strtoul("7777777777777777777777", 8);
-        assert_eq!(r, c_ulong::MAX);
-        assert_eq!(end, Some(22));
-    }
-
-    #[test]
-    fn strtoul_hex() {
-        let (r, end) = do_strtoul("12345", 16);
-        assert_eq!(r, 0x12345);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_hex_prefix() {
-        let (r, end) = do_strtoul("0x1234", 16);
-        assert_eq!(r, 0x1234);
-        assert_eq!(end, Some(6));
-    }
-
-    #[test]
-    fn strtoul_hex_invalid_characters() {
-        let (r, end) = do_strtoul("12g89", 16);
-        assert_eq!(r, 0x12);
-        assert_eq!(end, Some(2));
-    }
-
-    #[test]
-    fn strtoul_hex_prefix_spaces() {
-        let (r, end) = do_strtoul("   0x7F5", 16);
-        assert_eq!(r, 0x7F5);
-        assert_eq!(end, Some(8));
-    }
-
-    #[test]
-    fn strtoul_hex_leading_zeroes() {
-        let (r, end) = do_strtoul("0000456", 16);
-        assert_eq!(r, 0x456);
-        assert_eq!(end, Some(7));
-    }
-
-    #[test]
-    fn strtoul_hex_overflow() {
-        let (r, end) = do_strtoul("FFFFFFFFFFFFFFFFFFFF", 16);
-        assert_eq!(r, c_ulong::MAX);
-        assert_eq!(end, Some(20));
-    }
-
-    #[test]
-    fn strtoul_autodetect_decimal() {
-        let (r, end) = do_strtoul("12345", 0);
-        assert_eq!(r, 12345);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_autodetect_octal() {
-        let (r, end) = do_strtoul("01234", 0);
-        assert_eq!(r, 0o1234);
-        assert_eq!(end, Some(5));
-    }
-
-    #[test]
-    fn strtoul_autodetect_hex() {
-        let (r, end) = do_strtoul("0x1234", 0);
-        assert_eq!(r, 0x1234);
-        assert_eq!(end, Some(6));
-    }
-
-    #[test]
-    fn strtoul_autodetect_hex_invalid() {
-        let (r, end) = do_strtoul("0x12G34", 0);
-        assert_eq!(r, 0x12);
-        assert_eq!(end, Some(4));
-    }
-
-    #[test]
-    fn strtoul_autodetect_hex_leading_spaces() {
-        let (r, end) = do_strtoul("   0x7F5", 0);
-        assert_eq!(r, 0x7F5);
-        assert_eq!(end, Some(8));
-    }
-
-    #[test]
-    fn strtoul_autodetect_hex_overflow() {
-        let (r, end) = do_strtoul("0xFFFFFFFFFFFFFFFFFFFF", 0);
-        assert_eq!(r, c_ulong::MAX);
-        assert_eq!(end, Some(22));
-    }
-}
diff --git a/gbl/libdttable/BUILD b/gbl/libdttable/BUILD
deleted file mode 100644
index 6330bb2..0000000
--- a/gbl/libdttable/BUILD
+++ /dev/null
@@ -1,89 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-link_static_cc_library(
-    name = "libdttable_c_static",
-    cc_library = "@libdttable_c",
-)
-
-rust_bindgen(
-    name = "libdttable_c_bindgen",
-    bindgen_flags = [
-        "--use-core",
-        "--with-derive-custom-struct=dt_table.*=IntoBytes,FromBytes,Immutable,KnownLayout,PartialEq",
-        "--allowlist-type",
-        "(dt_table.*)",
-        "--allowlist-var",
-        "(DT_TABLE.*)",
-        "--raw-line",
-        """
-# ![cfg_attr(not(test), no_std)]
-
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
-""",
-    ],
-    cc_lib = "@libdttable_c",
-    # For x86_32, we need to explicitly specify 32bit architecture.
-    clang_flags = select({
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-        "//conditions:default": ["-m64"],
-    }) + [
-        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
-        "-nostdinc",
-    ],
-    header = "@libdttable_c//:dt_table.h",
-)
-
-rust_library(
-    name = "libdttable_bindgen",
-    srcs = [":libdttable_c_bindgen"],
-    deps = ["@zerocopy"],
-)
-
-rust_library(
-    name = "libdttable",
-    srcs = ["src/lib.rs"],
-    crate_name = "dttable",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":libdttable_bindgen",
-        ":libdttable_c_static",
-        "@gbl//liberror",
-        "@gbl//libsafemath",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libdttable_test",
-    compile_data = [
-        "@gbl//libdttable/test/data:all",
-    ],
-    crate = ":libdttable",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libfdt",
-    ],
-)
diff --git a/gbl/libdttable/BUILD.libdttable_c.bazel b/gbl/libdttable/BUILD.libdttable_c.bazel
deleted file mode 100644
index f4d937f..0000000
--- a/gbl/libdttable/BUILD.libdttable_c.bazel
+++ /dev/null
@@ -1,33 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
-# library and instead of only headers. Thus we generate a placeholder source file to meet the
-# requirement.
-genrule(
-    name = "bindgen_noop_cc",
-    outs = ["bindgen_noop_cc.cc"],
-    cmd = "touch $(OUTS)",
-)
-
-cc_library(
-    name = "libdttable_c",
-    srcs = [":bindgen_noop_cc"],
-    hdrs = ["dt_table.h"],
-    includes = ["."],
-)
diff --git a/gbl/libdttable/src/lib.rs b/gbl/libdttable/src/lib.rs
deleted file mode 100644
index 3cd32a4..0000000
--- a/gbl/libdttable/src/lib.rs
+++ /dev/null
@@ -1,254 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides a wrapper APIs for libdttable_c
-//! https://source.android.com/docs/core/architecture/dto/partitions
-
-#![cfg_attr(not(test), no_std)]
-
-use core::mem::size_of;
-use libdttable_bindgen::{dt_table_entry, dt_table_header, DT_TABLE_MAGIC};
-use liberror::{Error, Result};
-use safemath::SafeNum;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref};
-
-/// Rust wrapper for the dt table header
-#[repr(transparent)]
-#[derive(Debug, Copy, Clone, IntoBytes, FromBytes, Immutable, KnownLayout, PartialEq)]
-struct DtTableHeader(dt_table_header);
-
-impl DtTableHeader {
-    /// Get magic handling the bytes order
-    fn magic(self) -> u32 {
-        u32::from_be(self.0.magic)
-    }
-
-    /// Get dt_entry_count handling the bytes order
-    fn dt_entry_count(self) -> u32 {
-        u32::from_be(self.0.dt_entry_count)
-    }
-
-    /// Get dt_entry_size handling the bytes order
-    fn dt_entry_size(self) -> u32 {
-        u32::from_be(self.0.dt_entry_size)
-    }
-
-    /// Get dt_entries_offset handling the bytes order
-    fn dt_entries_offset(self) -> u32 {
-        u32::from_be(self.0.dt_entries_offset)
-    }
-}
-
-/// Rust wrapper for the dt table entry
-#[repr(transparent)]
-#[derive(Debug, Copy, Clone, Immutable, IntoBytes, KnownLayout, FromBytes, PartialEq)]
-struct DtTableHeaderEntry(dt_table_entry);
-
-impl DtTableHeaderEntry {
-    /// Get id handling the bytes order
-    fn id(self) -> u32 {
-        u32::from_be(self.0.id)
-    }
-
-    /// Get rev handling the bytes order
-    fn rev(self) -> u32 {
-        u32::from_be(self.0.rev)
-    }
-
-    /// Get dt_size handling the bytes order
-    fn dt_size(self) -> u32 {
-        u32::from_be(self.0.dt_size)
-    }
-
-    /// Get dt_offset handling the bytes order
-    fn dt_offset(self) -> u32 {
-        u32::from_be(self.0.dt_offset)
-    }
-}
-
-/// Metadata provided by entry header
-#[derive(Copy, Default, Clone, Eq, PartialEq, Debug)]
-pub struct DtTableMetadata {
-    /// id field from corresponding entry header
-    pub id: u32,
-    /// rev field from corresponding entry header
-    pub rev: u32,
-    /// custom field from corresponding entry header
-    pub custom: [u32; 4],
-}
-
-/// Device tree blob obtained from multidt table image
-#[derive(Copy, Clone, Eq, PartialEq, Debug)]
-pub struct DtTableEntry<'a> {
-    /// dtb payload extracted from image
-    pub dtb: &'a [u8],
-    /// Metadata provided by corresponding entry header
-    pub metadata: DtTableMetadata,
-}
-
-/// Represents entier multidt table image
-pub struct DtTableImage<'a> {
-    buffer: &'a [u8],
-    header: Ref<&'a [u8], DtTableHeader>,
-    entries: Ref<&'a [u8], [DtTableHeaderEntry]>,
-}
-
-/// To iterate over entries.
-pub struct DtTableImageIterator<'a> {
-    table_image: &'a DtTableImage<'a>,
-    current_index: usize,
-}
-
-impl<'a> Iterator for DtTableImageIterator<'a> {
-    type Item = DtTableEntry<'a>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.current_index < self.table_image.entries_count() {
-            let result = self.table_image.nth_entry(self.current_index).unwrap();
-            self.current_index += 1;
-            Some(result)
-        } else {
-            None
-        }
-    }
-}
-
-impl<'a> DtTableImage<'a> {
-    /// Verify and parse passed buffer following multidt table structure
-    pub fn from_bytes(buffer: &'a [u8]) -> Result<DtTableImage<'a>> {
-        let (header_layout, _) = Ref::new_from_prefix(buffer)
-            .ok_or(Error::BufferTooSmall(Some(size_of::<DtTableHeader>())))?;
-
-        let header: &DtTableHeader = &header_layout;
-        if header.magic() != DT_TABLE_MAGIC {
-            return Err(Error::BadMagic);
-        }
-
-        let entries_offset: SafeNum = header.dt_entries_offset().into();
-        let entry_size: SafeNum = header.dt_entry_size().into();
-        let entries_count: SafeNum = header.dt_entry_count().into();
-
-        let entries_start = entries_offset.try_into()?;
-        let entries_end = (entries_offset + entry_size * entries_count).try_into()?;
-
-        let entries_buffer = buffer
-            .get(entries_start..entries_end)
-            .ok_or(Error::BufferTooSmall(Some(entries_end)))?;
-        let entries_layout = Ref::new_slice(entries_buffer).ok_or(Error::InvalidInput)?;
-
-        Ok(DtTableImage { buffer: buffer, header: header_layout, entries: entries_layout })
-    }
-
-    /// Get amount of presented dt entries in the multidt table image
-    pub fn entries_count(&self) -> usize {
-        self.header.dt_entry_count().try_into().unwrap()
-    }
-
-    /// Returns an iterator over the entries in the DT table image
-    pub fn entries(&'a self) -> DtTableImageIterator<'a> {
-        DtTableImageIterator { table_image: self, current_index: 0 }
-    }
-
-    /// Get nth dtb buffer with multidt table structure metadata
-    pub fn nth_entry(&self, n: usize) -> Result<DtTableEntry<'a>> {
-        let entry = self.entries.get(n).ok_or(Error::BadIndex(n))?;
-
-        let dtb_offset: SafeNum = entry.dt_offset().into();
-        let dtb_size: SafeNum = entry.dt_size().into();
-
-        let dtb_start: usize = dtb_offset.try_into()?;
-        let dtb_end: usize = (dtb_offset + dtb_size).try_into()?;
-
-        let dtb_buffer =
-            self.buffer.get(dtb_start..dtb_end).ok_or(Error::BufferTooSmall(Some(dtb_end)))?;
-
-        Ok(DtTableEntry {
-            dtb: dtb_buffer,
-            metadata: DtTableMetadata { id: entry.id(), rev: entry.rev(), custom: entry.0.custom },
-        })
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use fdt::Fdt;
-
-    #[test]
-    fn test_dt_table_is_parsed() {
-        let dttable = include_bytes!("../test/data/dttable.img").to_vec();
-        let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
-
-        assert_eq!(table.entries_count(), 2, "Test data dttable image must have 2 dtb entries");
-
-        let first_entry = table.nth_entry(0).unwrap();
-        let second_entry = table.nth_entry(1).unwrap();
-
-        assert_eq!(
-            first_entry.metadata,
-            DtTableMetadata { id: 1, rev: 0, custom: Default::default() },
-            "First dttable entry is incorrect"
-        );
-        assert_eq!(
-            second_entry.metadata,
-            DtTableMetadata { id: 2, rev: 0, custom: Default::default() },
-            "Second dttable entry is incorrect"
-        );
-
-        // verify fdt headers are properly parsed
-        let _ = Fdt::new(first_entry.dtb).unwrap();
-        let _ = Fdt::new(second_entry.dtb).unwrap();
-    }
-
-    #[test]
-    fn test_dt_table_is_parsed_iterator() {
-        let dttable = include_bytes!("../test/data/dttable.img").to_vec();
-        let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
-
-        // Collect entries from the iterator
-        let entries: Vec<_> = table.entries().collect();
-
-        // Verify that the iterator yields the correct number of entries
-        assert_eq!(entries.len(), 2, "Iterator should yield 2 entries");
-
-        // Unwrap the entries from Result
-        let first_entry = &entries[0];
-        let second_entry = &entries[1];
-
-        assert_eq!(
-            first_entry.metadata,
-            DtTableMetadata { id: 1, rev: 0, custom: Default::default() },
-            "First dttable entry metadata is incorrect"
-        );
-        assert_eq!(
-            second_entry.metadata,
-            DtTableMetadata { id: 2, rev: 0, custom: Default::default() },
-            "Second dttable entry metadata is incorrect"
-        );
-
-        // Verify FDT headers are properly parsed
-        let _ = Fdt::new(first_entry.dtb).unwrap();
-        let _ = Fdt::new(second_entry.dtb).unwrap();
-    }
-
-    #[test]
-    fn test_failed_to_parse_corrupted_dt_table() {
-        let dttable = include_bytes!("../test/data/corrupted_dttable.img").to_vec();
-
-        assert!(
-            DtTableImage::from_bytes(&dttable[..]).is_err(),
-            "Must fail when trying to parse corrupted dt table image"
-        );
-    }
-}
diff --git a/gbl/libdttable/test/a.dts b/gbl/libdttable/test/a.dts
deleted file mode 100644
index f84523d..0000000
--- a/gbl/libdttable/test/a.dts
+++ /dev/null
@@ -1,8 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dttable.sh after change in this file
-&deviceA {
-  value = <0x2>;
-  status = "okay";
-};
diff --git a/gbl/libdttable/test/b.dts b/gbl/libdttable/test/b.dts
deleted file mode 100644
index ca47391..0000000
--- a/gbl/libdttable/test/b.dts
+++ /dev/null
@@ -1,8 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dttable.sh after change in this file
-&deviceB {
-  value = <0x1>;
-  status = "okay";
-};
diff --git a/gbl/libdttable/test/data/BUILD b/gbl/libdttable/test/data/BUILD
deleted file mode 100644
index 8012128..0000000
--- a/gbl/libdttable/test/data/BUILD
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-filegroup(
-    name = "all",
-    srcs = glob(["**/*"]),
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/libdttable/test/data/corrupted_dttable.img b/gbl/libdttable/test/data/corrupted_dttable.img
deleted file mode 100644
index 18f4e2a..0000000
--- a/gbl/libdttable/test/data/corrupted_dttable.img
+++ /dev/null
@@ -1 +0,0 @@
-corrupted dttable
diff --git a/gbl/libdttable/test/data/dttable.img b/gbl/libdttable/test/data/dttable.img
deleted file mode 100644
index bd0044b..0000000
Binary files a/gbl/libdttable/test/data/dttable.img and /dev/null differ
diff --git a/gbl/libdttable/test/gen_test_dttable.sh b/gbl/libdttable/test/gen_test_dttable.sh
deleted file mode 100755
index 0632395..0000000
--- a/gbl/libdttable/test/gen_test_dttable.sh
+++ /dev/null
@@ -1,31 +0,0 @@
-#!/bin/bash
-#
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-set -e
-
-readonly SCRIPT_DIR=`cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd`
-readonly DATA_DIR="${SCRIPT_DIR}/data/"
-readonly TMP_DIR=`mktemp -d`
-
-dtc -I dts -O dtb -o ${TMP_DIR}/a.dtb ${SCRIPT_DIR}/a.dts
-dtc -I dts -O dtb -o ${TMP_DIR}/b.dtb ${SCRIPT_DIR}/b.dts
-
-echo "corrupted dttable" > ${DATA_DIR}/corrupted_dttable.img
-
-# mkdtboimg is built by cd aosp/system/libufdt/utils && mm
-mkdtboimg create ${DATA_DIR}/dttable.img \
-        --id=0x2 --rev=0x0 ${TMP_DIR}/b.dtb \
-        --id=0x1 --rev=0x0 ${TMP_DIR}/a.dtb
diff --git a/gbl/libefi/BUILD b/gbl/libefi/BUILD
deleted file mode 100644
index 21d33c9..0000000
--- a/gbl/libefi/BUILD
+++ /dev/null
@@ -1,69 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libefi",
-    srcs = glob(["src/**/*.rs"]),
-    crate_name = "efi",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@arrayvec",
-        "@gbl//libasync",
-        "@gbl//libefi_types",
-        "@gbl//liberror",
-        "@gbl//libfastboot",
-        "@gbl//libgbl",
-        "@gbl//libsafemath",
-        "@gbl//libstorage",
-        "@gbl//libutils",
-        "@spin",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libefi_test",
-    crate = ":libefi",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libavb:sysdeps",
-        "@zbi",
-    ],
-)
-
-rust_library(
-    name = "mocks",
-    srcs = glob(["mocks/**/*.rs"]),
-    crate_name = "efi_mocks",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libefi",
-        "@gbl//libefi_types",
-        "@gbl//liberror",
-        "@mockall",
-    ],
-)
-
-rust_test(
-    name = "mocks_test",
-    crate = ":mocks",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libefi/mocks/lib.rs b/gbl/libefi/mocks/lib.rs
deleted file mode 100644
index 7c83859..0000000
--- a/gbl/libefi/mocks/lib.rs
+++ /dev/null
@@ -1,375 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! UEFI object mocks to support unit tests.
-//!
-//! This module aliases mock objects to their standard names, so that code can just unconditionally
-//! use e.g. `EfiEntry` and in test code it will switch to `MockEfiEntry`.
-
-#![feature(negative_impls)]
-
-pub mod protocol;
-pub mod utils;
-
-use efi_types::{EfiConfigurationTable, EfiGuid, EfiTimerDelay};
-use liberror::Result;
-use mockall::mock;
-use protocol::{
-    dt_fixup::DtFixupProtocol,
-    gbl_efi_ab_slot::GblSlotProtocol,
-    gbl_efi_avb::GblAvbProtocol,
-    gbl_efi_fastboot::GblFastbootProtocol,
-    gbl_efi_os_configuration::GblOsConfigurationProtocol,
-    simple_text_output::{passthrough_con_out, MockSimpleTextOutputProtocol},
-};
-use std::cell::RefCell;
-
-/// libefi types that can be used in tests as-is.
-pub use efi::{efi_print, efi_println, DeviceHandle, EventNotify, EventType};
-
-/// Holds state to set up a mock UEFI environment.
-///
-/// Parts of the libefi API surface doesn't translate super well to mocks, so this struct helps
-/// cover over some of the awkwardness. In particular, APIs that return "views" over what is
-/// really a singleton object are difficult to mock properly.
-///
-/// For example, the [efi::EfiEntry::system_table()] function returns a full [efi::SystemTable]
-/// object, not a reference. This means that our mocks have to do the same, and return a new
-/// [MockSystemTable] object - but this sort of defeats the purpose of mocks, which is to have
-/// a mock that you can set up expectations ahead of time.
-///
-/// You can get around this in a limited fashion if the code under test only needs to grab the
-/// system table once; in this case you can use the `return_once()` expectation to move the mock
-/// around. But this will cause a runtime error if the code under test tries to grab the system
-/// table more than once, since the mock will have been moved out already. And since grabbing the
-/// system table is very common, this really restricts what you can do in a test.
-///
-/// [MockEfi] works around this by stashing objects like this in `thread_local` state, and the
-/// mocks created at runtime just forward all their calls to this shared state. This allows
-/// expectations to be placed at the EFI system level, and ignore any intermediate "view" mocks
-/// that get created and destroyed over the course of the test.
-pub struct MockEfi {
-    /// The global [MockEfiEntry] to set expectations on.
-    pub entry: MockEfiEntry,
-    /// The global [MockSystemTable] to set expectations on.
-    pub system_table: MockSystemTable,
-    /// The global [MockBootServices] to set expectations on.
-    pub boot_services: MockBootServices,
-    /// The global [MockSimpleTextOutputProtocol] to set expectations on.
-    pub con_out: MockSimpleTextOutputProtocol,
-}
-
-thread_local! {
-    pub(crate) static MOCK_EFI: RefCell<Option<MockEfi>> = RefCell::new(None);
-}
-
-impl MockEfi {
-    /// Creates a new [MockEfi].
-    ///
-    /// The following expectations will be set by this function, and should generally not be
-    /// adjusted by the caller:
-    /// * `entry.system_table()` will automatically forward to `system_table`
-    /// * `system_table.con_out()` will automatically forward to `con_out`
-    ///
-    /// Other than that, callers may set the other expectations as needed on these mocks.
-    ///
-    /// Once the mocks are ready, call [install] to install the thread-local state.
-    pub fn new() -> Self {
-        let mut entry = MockEfiEntry::default();
-        entry.expect_system_table().returning(|| passthrough_system_table());
-
-        let mut system_table = MockSystemTable::default();
-        system_table.expect_boot_services().returning(|| passthrough_boot_services());
-        system_table.expect_con_out().returning(|| Ok(passthrough_con_out()));
-
-        let boot_services = MockBootServices::default();
-        let con_out = MockSimpleTextOutputProtocol::default();
-
-        Self { entry, system_table, boot_services, con_out }
-    }
-
-    /// Installs the [MockEfi] in thread-local state.
-    ///
-    /// Only one [MockEfi] can be installed at a time (per thread). Attempting to install a
-    /// second will panic.
-    ///
-    /// Returns an [InstalledMockEfi] which automatically unregisters the state on drop.
-    pub fn install(self) -> InstalledMockEfi {
-        MOCK_EFI.with_borrow_mut(|efi| {
-            // If this error message changes the unittest will need to change as well.
-            assert!(efi.is_none(), "Only one MockEfi can be installed at a time (per-thread)");
-            *efi = Some(self)
-        });
-        InstalledMockEfi { entry: passthrough_efi_entry() }
-    }
-}
-
-/// Scoped wrapper to automatically unregister the global [MockEfi] on drop.
-pub struct InstalledMockEfi {
-    entry: MockEfiEntry,
-}
-
-impl InstalledMockEfi {
-    /// The user-facing [MockEfiEntry] to use in the code under test.
-    ///
-    /// This is a const ref so you cannot place expectations here, all calls will be forwarded to
-    /// the installed [MockEfi] mocks.
-    pub fn entry(&self) -> &MockEfiEntry {
-        &self.entry
-    }
-}
-
-/// [InstalledMockEfi] uses thread-local state so cannot be sent to another thread.
-impl !Send for InstalledMockEfi {}
-
-impl Drop for InstalledMockEfi {
-    fn drop(&mut self) {
-        MOCK_EFI.with_borrow_mut(|efi| *efi = None);
-    }
-}
-
-mock! {
-    /// Mock [efi::EfiEntry].
-    pub EfiEntry {
-        /// Returns a [MockSystemTable].
-        pub fn system_table(&self) -> MockSystemTable;
-
-        /// Returns a real [efi::DeviceHandle], which is data-only so isn't mocked.
-        pub fn image_handle(&self) -> DeviceHandle;
-    }
-}
-/// Map to the libefi name so code under test can just use one name.
-pub type EfiEntry = MockEfiEntry;
-
-/// While this mock itself isn't necessarily thread-local, passing through to the thread-local state
-/// is our primary use case, so we just disallow [Send] entirely.
-impl !Send for MockEfiEntry {}
-
-/// Returns a [MockEfiEntry] that forwards all calls to `MOCK_EFI`.
-fn passthrough_efi_entry() -> MockEfiEntry {
-    let mut entry = MockEfiEntry::default();
-    entry
-        .expect_system_table()
-        .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().entry.system_table()));
-    entry
-        .expect_image_handle()
-        .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().entry.image_handle()));
-    entry
-}
-
-mock! {
-    /// Mock [efi::SystemTable].
-    pub SystemTable {
-        /// Returns a [MockBootServices].
-        pub fn boot_services(&self) -> MockBootServices;
-
-        /// Returns a [MockRuntimeServices].
-        pub fn runtime_services(&self) -> MockRuntimeServices;
-
-        /// Returns a [MockSimpleTextOutputProtocol]. This is a singleton protocol which is
-        /// always-open, as opposed to most protocols which need to be opened explicitly.
-        pub fn con_out(&self) -> Result<MockSimpleTextOutputProtocol>;
-
-        /// Returns a real [efi::EfiConfigurationTable], which is data-only so isn't mocked.
-        pub fn configuration_table(&self) -> Option<&'static [EfiConfigurationTable]>;
-    }
-}
-/// Map to the libefi name so code under test can just use one name.
-pub type SystemTable = MockSystemTable;
-
-/// While this mock itself isn't necessarily thread-local, passing through to the thread-local state
-/// is our primary use case, so we just disallow [Send] entirely.
-impl !Send for MockSystemTable {}
-
-/// Returns a [MockSystemTable] that forwards all calls to `MOCK_EFI`.
-fn passthrough_system_table() -> MockSystemTable {
-    let mut table = MockSystemTable::default();
-    table.expect_boot_services().returning(|| {
-        MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().system_table.boot_services())
-    });
-    table
-        .expect_con_out()
-        .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().system_table.con_out()));
-    table
-}
-
-mock! {
-    /// Mock [efi::BootServices].
-    pub BootServices {
-        /// Returns an instance of the requested type `T`.
-        ///
-        /// This is slightly different than the original API because it's difficult to mock an
-        /// [efi::Protocol] wrapping [efi::ProtocolInfo]. To simplify, we just return a mock
-        /// that looks like the protocol object.
-        pub fn open_protocol<T: 'static>(&self, handle: DeviceHandle) -> Result<T>;
-
-        /// Similar to [open_protocol], returns the type `T`.
-        pub fn find_first_and_open<T: 'static>(&self) -> Result<T>;
-
-        /// Returns a [MockEvent].
-        pub fn create_event(
-            &self,
-            event_type: EventType,
-            mut cb: Option<&'static mut EventNotify<'static>>,
-        ) -> Result<MockEvent>;
-
-        /// Sets a [MockEvent] timer.
-        pub fn set_timer(
-            &self,
-            event: &MockEvent,
-            delay_type: EfiTimerDelay,
-            trigger_time: u64,
-        ) -> Result<()>;
-    }
-}
-/// Map to the libefi name so code under test can just use one name.
-pub type BootServices = MockBootServices;
-
-/// Returns a [MockBootServices] that forwards all calls to `MOCK_EFI`.
-fn passthrough_boot_services() -> MockBootServices {
-    let mut services = MockBootServices::default();
-    services.expect_find_first_and_open::<GblAvbProtocol>().returning(|| {
-        MOCK_EFI.with_borrow_mut(|efi| {
-            efi.as_mut().unwrap().boot_services.find_first_and_open::<GblAvbProtocol>()
-        })
-    });
-    services.expect_find_first_and_open::<GblSlotProtocol>().returning(|| {
-        MOCK_EFI.with_borrow_mut(|efi| {
-            efi.as_mut().unwrap().boot_services.find_first_and_open::<GblSlotProtocol>()
-        })
-    });
-    services.expect_find_first_and_open::<GblFastbootProtocol>().returning(|| {
-        MOCK_EFI.with_borrow_mut(|efi| {
-            efi.as_mut().unwrap().boot_services.find_first_and_open::<GblFastbootProtocol>()
-        })
-    });
-    services.expect_find_first_and_open::<GblOsConfigurationProtocol>().returning(|| {
-        MOCK_EFI.with_borrow_mut(|efi| {
-            efi.as_mut().unwrap().boot_services.find_first_and_open::<GblOsConfigurationProtocol>()
-        })
-    });
-    services.expect_find_first_and_open::<DtFixupProtocol>().returning(|| {
-        MOCK_EFI.with_borrow_mut(|efi| {
-            efi.as_mut().unwrap().boot_services.find_first_and_open::<DtFixupProtocol>()
-        })
-    });
-
-    services
-}
-
-mock! {
-    /// Mock [efi::LocatedHandles].
-    pub LocatedHandles {}
-}
-/// Map to the libefi name so code under test can just use one name.
-pub type LocatedHandles = MockLocatedHandles;
-
-mock! {
-    /// Mock [efi::Event].
-    pub Event {}
-}
-/// Map to the libefi name so code under test can just use one name.
-pub type Event = MockEvent;
-
-mock! {
-    /// Mock [efi::RuntimeServices].
-    pub RuntimeServices {
-        /// Performs a cold reset.
-        pub fn cold_reset(&self);
-
-        /// Gets EFI variable.
-        pub fn get_variable(&self, guid: &EfiGuid, name: &str, out: &mut [u8]) -> Result<usize>;
-    }
-}
-
-/// Map to the libefi name so code under test can just use one name.
-pub type RuntimeServices = MockRuntimeServices;
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use mockall::predicate::eq;
-    use std::fmt::Write;
-
-    #[test]
-    fn efi_state_install() {
-        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_none()));
-
-        // Global should still be `None` until we call `install()`.
-        let mock_efi = MockEfi::new();
-        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_none()));
-
-        let installed = mock_efi.install();
-        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_some()));
-
-        // Global goes back to `None` once the install goes out of scope.
-        drop(installed);
-        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_none()));
-    }
-
-    #[test]
-    #[should_panic(expected = "Only one MockEfi can be installed at a time (per-thread)")]
-    fn efi_state_double_install_fails() {
-        let mock_efi = MockEfi::new();
-        let mock_efi_2 = MockEfi::new();
-
-        let installed = mock_efi.install();
-        mock_efi_2.install();
-
-        // Explicit drop to keep it in scope until here.
-        drop(installed);
-    }
-
-    #[test]
-    fn efi_state_con_out_write_once() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi.con_out.expect_write_str().once().with(eq("foo 123")).return_const(Ok(()));
-
-        let installed = mock_efi.install();
-        let efi_entry = installed.entry();
-
-        assert!(write!(efi_entry.system_table().con_out().unwrap(), "{} {}", "foo", 123).is_ok());
-    }
-
-    #[test]
-    fn efi_state_con_out_write_twice_same_mock() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi.con_out.expect_write_str().once().with(eq("foo 123")).return_const(Ok(()));
-        mock_efi.con_out.expect_write_str().once().with(eq("bar 456")).return_const(Ok(()));
-
-        let installed = mock_efi.install();
-        let efi_entry = installed.entry();
-
-        let mut con_out = efi_entry.system_table().con_out().unwrap();
-        assert!(write!(con_out, "{} {}", "foo", 123).is_ok());
-        assert!(write!(con_out, "{} {}", "bar", 456).is_ok());
-    }
-
-    #[test]
-    fn efi_state_con_out_write_twice_different_mock() {
-        let mut mock_efi = MockEfi::new();
-        mock_efi.con_out.expect_write_str().once().with(eq("foo 123")).return_const(Ok(()));
-        mock_efi.con_out.expect_write_str().once().with(eq("bar 456")).return_const(Ok(()));
-
-        let installed = mock_efi.install();
-        let efi_entry = installed.entry();
-
-        // Call `write!` on two separate passthrough mocks, both should forward the calls to
-        // the "real" global mock.
-        //
-        // A common instance of this is `efi_print!` which fetches a new `con_out` on every call.
-        assert!(write!(efi_entry.system_table().con_out().unwrap(), "{} {}", "foo", 123).is_ok());
-        assert!(write!(efi_entry.system_table().con_out().unwrap(), "{} {}", "bar", 456).is_ok());
-    }
-}
diff --git a/gbl/libefi/mocks/protocol.rs b/gbl/libefi/mocks/protocol.rs
deleted file mode 100644
index e32231a..0000000
--- a/gbl/libefi/mocks/protocol.rs
+++ /dev/null
@@ -1,349 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Mock protocols.
-//!
-//! The structure of these sub-modules must match the libefi structure so that the code can refer
-//! to either one using the same path.
-
-use crate::{DeviceHandle, MOCK_EFI};
-use core::ffi::CStr;
-use core::fmt::Write;
-pub use efi::protocol::gbl_efi_image_loading::EfiImageBufferInfo;
-use efi_types::{
-    EfiInputKey, GblEfiAvbKeyValidationStatus, GblEfiAvbVerificationResult, GblEfiImageInfo,
-    GblEfiPartitionName, GblEfiVerifiedDeviceTree,
-};
-use liberror::Result;
-use mockall::mock;
-
-/// Mock device_path module.
-pub mod device_path {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::DevicePathProtocol].
-        pub DevicePathProtocol {}
-    }
-    /// Map to the libefi name so code under test can just use one name.
-    pub type DevicePathProtocol = MockDevicePathProtocol;
-
-    mock! {
-        /// Mock [efi::DevicePathToTextProtocol].
-        pub DevicePathToTextProtocol {
-            /// Returns a [MockDevicePathText].
-            ///
-            /// Lifetimes are a little difficult to mock perfectly, so here we can only allow a
-            /// `'static` return value.
-            pub fn convert_device_path_to_text(
-                &self,
-                device_path: &MockDevicePathProtocol,
-                display_only: bool,
-                allow_shortcuts: bool,
-            ) -> Result<MockDevicePathText<'static>>;
-        }
-    }
-    /// Map to the libefi name so code under test can just use one name.
-    pub type DevicePathToTextProtocol = MockDevicePathToTextProtocol;
-
-    mock! {
-        /// Mock [efi::DevicePathText].
-        pub DevicePathText<'a> {
-            /// Returns the text, which is data-only so isn't mocked.
-            pub fn text(&self) -> Option<&'a [u16]>;
-        }
-    }
-    /// Map to the libefi name so code under test can just use one name.
-    pub type DevicePathText<'a> = MockDevicePathText<'a>;
-}
-
-/// Mock loaded_image protocol.
-pub mod loaded_image {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::LoadedImageProtocol].
-        pub LoadedImageProtocol {
-            /// Returns a real [efi::DeviceHandle], which is data-only so isn't mocked.
-            pub fn device_handle(&self) -> Result<DeviceHandle>;
-        }
-    }
-    /// Map to the libefi name so code under test can just use one name.
-    pub type LoadedImageProtocol = MockLoadedImageProtocol;
-}
-
-/// Mock simple_text_input module.
-pub mod simple_text_input {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::SimpleTextInputProtocol].
-        pub SimpleTextInputProtocol {
-            /// Returns an [EfiInputKey], which is data-only so isn't mocked.
-            pub fn read_key_stroke(&self) -> Result<Option<EfiInputKey>>;
-        }
-    }
-    /// Map to the libefi name so code under test can just use one name.
-    pub type SimpleTextInputProtocol = MockSimpleTextInputProtocol;
-}
-
-/// Mock simple_text_output module.
-pub mod simple_text_output {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::SimpleTextOutputProtocol].
-        pub SimpleTextOutputProtocol {}
-
-        impl Write for SimpleTextOutputProtocol {
-            fn write_str(&mut self, s: &str) -> core::fmt::Result;
-        }
-    }
-    /// Map to the libefi name so code under test can just use one name.
-    pub type SimpleTextOutputProtocol = MockSimpleTextOutputProtocol;
-
-    /// Returns a [MockSimpleTextOutputProtocol] that forwards all calls to `MOCK_EFI`.
-    pub fn passthrough_con_out() -> MockSimpleTextOutputProtocol {
-        let mut con_out = MockSimpleTextOutputProtocol::default();
-        con_out.expect_write_str().returning(|s| {
-            MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().con_out.write_str(s))
-        });
-        con_out
-    }
-
-    /// While this mock itself isn't necessarily thread-local, passing through to the thread-local
-    /// state is our primary use case, so we just disallow [Send] entirely.
-    impl !Send for MockSimpleTextOutputProtocol {}
-}
-
-/// Mock image_loading protocol.
-pub mod gbl_efi_image_loading {
-    use super::*;
-
-    pub use efi::protocol::gbl_efi_image_loading::EfiImageBufferInfo;
-
-    mock! {
-        /// Mock [efi::ImageLoadingProtocol].
-        pub GblImageLoadingProtocol {
-            /// Returns [EfiImageBuffer] matching `gbl_image_info`
-            pub fn get_buffer(&self, gbl_image_info: &GblEfiImageInfo) -> Result<EfiImageBufferInfo>;
-
-            /// Returns number of partitions to be provided via `get_verify_partitions()`, and thus
-            /// expected size of `partition_name` slice.
-            pub fn get_verify_partitions_count(&self) -> Result<usize>;
-
-            /// Returns number of partition names written to `partition_name` slice.
-            pub fn get_verify_partitions(
-                &self,
-                partition_names: &mut [GblEfiPartitionName]
-            ) -> Result<usize>;
-        }
-    }
-
-    /// Map to the libefi name so code under test can just use one name.
-    pub type GblImageLoadingProtocol = MockGblImageLoadingProtocol;
-}
-
-/// Mock os_configuration protocol.
-pub mod gbl_efi_os_configuration {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::OsConfigurationProtocol].
-        pub GblOsConfigurationProtocol {
-            /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_kernel_commandline()`
-            pub fn fixup_kernel_commandline(
-                &self,
-                commandline: &CStr,
-                fixup: &mut [u8],
-            ) -> Result<()>;
-
-            /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_bootconfig()`
-            pub fn fixup_bootconfig(
-                &self,
-                bootconfig: &[u8],
-                fixup: &mut [u8],
-            ) -> Result<usize>;
-
-            /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.select_device_trees()`
-            pub fn select_device_trees(
-                &self,
-                components: &mut [GblEfiVerifiedDeviceTree],
-            ) -> Result<()>;
-        }
-    }
-
-    /// Map to the libefi name so code under test can just use one name.
-    pub type GblOsConfigurationProtocol = MockGblOsConfigurationProtocol;
-}
-
-/// Mock dt_fixup protocol.
-pub mod dt_fixup {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::DtFixupProtocol].
-        pub DtFixupProtocol {
-            /// Wraps `EFI_DT_FIXUP_PROTOCOL.fixup()`
-            pub fn fixup(&self, device_tree: &mut [u8]) -> Result<()>;
-        }
-    }
-
-    /// Map to the libefi name so code under test can just use one name.
-    pub type DtFixupProtocol = MockDtFixupProtocol;
-}
-
-/// Mock avb protocol.
-pub mod gbl_efi_avb {
-    use super::*;
-
-    /// Mock implementation of `GBL_EFI_AVB_PROTOCOL`.
-    /// We use a custom mock implementation instead of relying on `mockall` due to its limitations
-    /// regarding argument lifetimes. Specifically, in this case, `mockall` requires the
-    /// `validate_vbmeta_public_key.public_key_metadata` argument to have a `'static` lifetime,
-    /// which is not practical for our use case.
-    #[derive(Clone, Default)]
-    pub struct GblAvbProtocol {
-        /// Expected return value from `validate_vbmeta_public_key`.
-        pub validate_vbmeta_public_key_result: Option<Result<GblEfiAvbKeyValidationStatus>>,
-        /// Expected return value from `read_is_device_unlocked`.
-        pub read_is_device_unlocked_result: Option<Result<bool>>,
-        /// Expected return value from `read_rollback_index`.
-        pub read_rollback_index_result: Option<Result<u64>>,
-        /// Expected return value from `write_rollback_index`.
-        pub write_rollback_index_result: Option<Result<()>>,
-        /// Expected return value from `read_persistent_value`.
-        pub read_persistent_value_result: Option<Result<usize>>,
-        /// Expected return value from `write_persistent_value`.
-        pub write_persistent_value_result: Option<Result<()>>,
-    }
-
-    impl GblAvbProtocol {
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.validate_vbmeta_public_key()`.
-        pub fn validate_vbmeta_public_key(
-            &self,
-            _public_key: &[u8],
-            _public_key_metadata: Option<&[u8]>,
-        ) -> Result<GblEfiAvbKeyValidationStatus> {
-            self.validate_vbmeta_public_key_result.unwrap()
-        }
-
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.read_is_device_unlocked()`.
-        pub fn read_is_device_unlocked(&self) -> Result<bool> {
-            self.read_is_device_unlocked_result.unwrap()
-        }
-
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.read_rollback_index()`.
-        pub fn read_rollback_index(&self, _index_location: usize) -> Result<u64> {
-            self.read_rollback_index_result.unwrap()
-        }
-
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.write_rollback_index()`.
-        pub fn write_rollback_index(
-            &self,
-            _index_location: usize,
-            _rollback_index: u64,
-        ) -> Result<()> {
-            self.write_rollback_index_result.unwrap()
-        }
-
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.read_persistent_value()`.
-        pub fn read_persistent_value(&self, _name: &CStr, _value: &mut [u8]) -> Result<usize> {
-            self.read_persistent_value_result.unwrap()
-        }
-
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.write_persistent_value()`.
-        pub fn write_persistent_value(&self, _name: &CStr, _value: Option<&[u8]>) -> Result<()> {
-            self.write_persistent_value_result.unwrap()
-        }
-
-        /// Wraps `GBL_EFI_AVB_PROTOCOL.handle_verification_result()`.
-        pub fn handle_verification_result(
-            &self,
-            _verification_result: &GblEfiAvbVerificationResult,
-        ) -> Result<()> {
-            unimplemented!();
-        }
-    }
-}
-
-/// Mock gbl_efi_fastboot protocol.
-pub mod gbl_efi_fastboot {
-    use super::*;
-
-    mock! {
-        /// Mock [efi::protocol::gbl_efi_fastboot::Var].
-        pub Var {
-            /// Get name, arguments and corresponding value.
-            pub fn get<'s>(&self, out: &mut [u8])
-                -> Result<(&'static str, [&'static str; 1], &'static str)>;
-        }
-    }
-
-    /// Mock [efi::GblFastbootProtocol].
-    pub struct GblFastbootProtocol {}
-
-    impl GblFastbootProtocol {
-        /// Protocol<'_, GblFastbootProtocol>::get_var.
-        pub fn get_var<'a>(
-            &self,
-            _: &CStr,
-            _: impl Iterator<Item = &'a CStr> + Clone,
-            _: &mut [u8],
-        ) -> Result<usize> {
-            unimplemented!()
-        }
-
-        /// Protocol<'_, GblFastbootProtocol>::get_var_all.
-        pub fn get_var_all(&self, _: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
-            unimplemented!()
-        }
-    }
-
-    /// Map to the libefi name so code under test can just use one name.
-    pub type Var = MockVar;
-}
-
-/// Mock gbl_efi_ab_slot
-pub mod gbl_efi_ab_slot {
-    use super::*;
-    use efi::protocol::gbl_efi_ab_slot::GblSlot;
-    use efi_types::{GblEfiBootReason, GblEfiSlotMetadataBlock};
-
-    mock! {
-        /// Mock of [GblSlotProtocol]
-        pub GblSlotProtocol {
-            /// Mock of GblSlotProtocol::get_current_slot.
-            pub fn get_current_slot(&self) -> Result<GblSlot>;
-
-            /// Mock of GblSlotProtocol::get_next_slot.
-            pub fn get_next_slot(&self, mark_boot_attempt: bool) -> Result<GblSlot>;
-
-            /// Mock of GblSlotProtocol::load_boot_data.
-            pub fn load_boot_data(&self) -> Result<GblEfiSlotMetadataBlock>;
-
-            /// Mock of GblSlotProtocol::set_active_slot.
-            pub fn set_active_slot(&self, idx: u8) -> Result<()>;
-
-            /// Mock of GblSlotProtocol::set_boot_reason.
-            pub fn set_boot_reason(&self, reason: GblEfiBootReason, subreason: &[u8]) -> Result<()>;
-
-            /// Mock of GblSlotProtocol::get_boot_reason.
-            pub fn get_boot_reason(&self, subreason: &mut [u8]) -> Result<(GblEfiBootReason, usize)>;
-        }
-    }
-
-    /// Map to the libefi name so code under test can just use one name.
-    pub type GblSlotProtocol = MockGblSlotProtocol;
-}
diff --git a/gbl/libefi/mocks/utils.rs b/gbl/libefi/mocks/utils.rs
deleted file mode 100644
index 96049cd..0000000
--- a/gbl/libefi/mocks/utils.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Mock utils.
-
-use crate::MockEfiEntry;
-use core::time::Duration;
-use liberror::Result;
-use mockall::mock;
-
-mock! {
-    /// Mock [efi::utils::Timeout].
-    pub Timeout {
-        /// Creates a new [MockTimeout].
-        pub fn new(efi_entry: &MockEfiEntry, timeout: Duration) -> Result<Self>;
-        /// Checks the timeout.
-        pub fn check(&self) -> Result<bool>;
-        /// Resets the timeout.
-        pub fn reset(&self, timeout: Duration) -> Result<()>;
-    }
-}
-/// Map to the libefi name so code under test can just use one name.
-pub type Timeout = MockTimeout;
diff --git a/gbl/libefi/src/ab_slots.rs b/gbl/libefi/src/ab_slots.rs
deleted file mode 100644
index c5603f1..0000000
--- a/gbl/libefi/src/ab_slots.rs
+++ /dev/null
@@ -1,776 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-extern crate gbl_storage;
-extern crate libgbl as gbl;
-
-use core::convert::TryInto;
-use gbl::slots::{
-    BootTarget, BootToken, Manager, OneShot, RecoveryTarget, Slot, SlotIterator, Suffix, Tries,
-    UnbootableReason,
-};
-use liberror::{Error, Result};
-
-use efi_types::{
-    GBL_EFI_BOOT_REASON_BOOTLOADER as REASON_BOOTLOADER,
-    GBL_EFI_BOOT_REASON_EMPTY_BOOT_REASON as REASON_EMPTY,
-    GBL_EFI_BOOT_REASON_RECOVERY as REASON_RECOVERY,
-};
-
-use crate::protocol::{gbl_efi_ab_slot as ab_slot, Protocol};
-
-const SUBREASON_BUF_LEN: usize = 64;
-
-/// Implementation for A/B slot manager based on custom EFI protocol.
-pub struct ABManager<'a> {
-    protocol: Protocol<'a, ab_slot::GblSlotProtocol>,
-    boot_token: Option<BootToken>,
-    last_set_active_idx: Option<u8>,
-}
-
-impl<'a> ABManager<'a> {
-    #[cfg(test)]
-    fn new_without_token(protocol: Protocol<'a, ab_slot::GblSlotProtocol>) -> Self {
-        Self { protocol, boot_token: None, last_set_active_idx: None }
-    }
-}
-
-impl gbl::slots::private::SlotGet for ABManager<'_> {
-    fn get_slot_by_number(&self, number: usize) -> Result<Slot> {
-        let idx = u8::try_from(number).or(Err(Error::BadIndex(number)))?;
-        let info = self.protocol.get_slot_info(idx).or(Err(Error::BadIndex(number)))?;
-        info.try_into()
-    }
-}
-
-impl Manager for ABManager<'_> {
-    fn get_boot_target(&self) -> Result<BootTarget> {
-        let slot = self.get_slot_last_set_active()?;
-        let mut subreason = [0u8; SUBREASON_BUF_LEN];
-        let (reason, _) = self.protocol.get_boot_reason(subreason.as_mut_slice())?;
-        // Don't currently care about the subreason
-        // CStr::from_bytes_until_nul(&subreason[..strlen])?
-        let target = match reason {
-            REASON_RECOVERY => BootTarget::Recovery(RecoveryTarget::Slotted(slot)),
-            _ => BootTarget::NormalBoot(slot),
-        };
-        Ok(target)
-    }
-
-    fn slots_iter(&self) -> SlotIterator {
-        SlotIterator::new(self)
-    }
-
-    fn get_slot_last_set_active(&self) -> Result<Slot> {
-        use gbl::slots::private::SlotGet;
-
-        if let Some(idx) = self.last_set_active_idx {
-            self.get_slot_by_number(idx.into())
-        } else {
-            self.protocol.get_current_slot()?.try_into()
-        }
-    }
-
-    fn mark_boot_attempt(&mut self) -> Result<BootToken> {
-        self.boot_token.take().ok_or(Error::OperationProhibited)
-    }
-
-    fn set_active_slot(&mut self, slot_suffix: Suffix) -> Result<()> {
-        let idx: u8 = self
-            .slots_iter()
-            .position(|s| s.suffix == slot_suffix)
-            .ok_or(Error::InvalidInput)?
-            .try_into()
-            // This 'or' is technically unreachable because the protocol
-            // can't give us an index larger than a u8.
-            .or(Err(Error::Other(None)))?;
-        self.protocol.set_active_slot(idx).or(Err(Error::Other(None))).and_then(|_| {
-            self.last_set_active_idx = Some(idx);
-            Ok(())
-        })
-    }
-
-    fn set_slot_unbootable(&mut self, slot_suffix: Suffix, reason: UnbootableReason) -> Result<()> {
-        let idx: u8 = self
-            .slots_iter()
-            .position(|s| s.suffix == slot_suffix)
-            .ok_or(Error::InvalidInput)?
-            .try_into()
-            // This 'or' is technically unreachable because the protocol
-            // can't give us an index larger than a u8.
-            .or(Err(Error::Other(None)))?;
-        self.protocol.set_slot_unbootable(idx, u8::from(reason).into())
-    }
-
-    fn get_max_retries(&self) -> Result<Tries> {
-        Ok(self.protocol.load_boot_data()?.max_retries.into())
-    }
-
-    fn get_oneshot_status(&self) -> Option<OneShot> {
-        let mut subreason = [0u8; SUBREASON_BUF_LEN];
-        let (reason, _) = self.protocol.get_boot_reason(subreason.as_mut_slice()).ok()?;
-        // Currently we only care if the primary boot reason is BOOTLOADER.
-        // CStr::from_bytes_until_nul(&subreason[..strlen]).ok()?
-        match reason {
-            REASON_BOOTLOADER => Some(OneShot::Bootloader),
-            _ => None,
-        }
-    }
-
-    fn set_oneshot_status(&mut self, os: OneShot) -> Result<()> {
-        // Android doesn't have a concept of OneShot to recovery,
-        // and the subreason shouldn't matter.
-        match os {
-            OneShot::Bootloader => {
-                self.protocol.set_boot_reason(REASON_BOOTLOADER, &[]).or(Err(Error::Other(None)))
-            }
-            _ => Err(Error::OperationProhibited),
-        }
-    }
-
-    fn clear_oneshot_status(&mut self) {
-        let mut subreason = [0u8; SUBREASON_BUF_LEN];
-        // Only clear if the boot reason is the one we care about.
-        // CStr::from_bytes_until_nul(&subreason[..strlen]).or(Err(Error::Other))?
-        if let Ok((REASON_BOOTLOADER, _)) = self.protocol.get_boot_reason(subreason.as_mut_slice())
-        {
-            let _ = self.protocol.set_boot_reason(REASON_EMPTY, &[]);
-        }
-    }
-
-    fn write_back(&mut self, _: &mut dyn FnMut(&mut [u8]) -> Result<()>) {
-        // Note: `expect` instead of swallowing the error.
-        // It is important that changes are not silently dropped.
-        self.protocol.flush().expect("could not write back modifications to slot metadata");
-    }
-}
-
-#[cfg(test)]
-mod test {
-    extern crate avb_sysdeps;
-
-    use super::*;
-    use crate::protocol::Protocol;
-    use crate::test::*;
-    use crate::EfiEntry;
-    use efi_types::{
-        EfiStatus, GblEfiABSlotProtocol, GblEfiSlotInfo, GblEfiSlotMetadataBlock,
-        EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
-        GBL_EFI_BOOT_REASON_EMPTY_BOOT_REASON as REASON_EMPTY,
-        GBL_EFI_BOOT_REASON_RECOVERY as REASON_RECOVERY,
-        GBL_EFI_BOOT_REASON_WATCHDOG as REASON_WATCHDOG,
-    };
-    use gbl::{
-        ops::{
-            AvbIoResult, CertPermanentAttributes, RebootReason, SlotsMetadata, SHA256_DIGEST_SIZE,
-        },
-        partition::GblDisk,
-        slots::{Bootability, Cursor, RecoveryTarget, UnbootableReason},
-        Gbl, GblOps, Os, Result as GblResult,
-    };
-    use gbl_storage::{BlockIo, BlockIoNull, Disk, Gpt};
-    use libgbl::{
-        device_tree::DeviceTreeComponentsRegistry,
-        gbl_avb::state::{BootStateColor, KeyValidationStatus},
-        ops::ImageBuffer,
-    };
-    // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
-    use core::ops::DerefMut;
-    use std::{
-        ffi::CStr,
-        fmt::Write,
-        mem::align_of,
-        num::NonZeroUsize,
-        sync::atomic::{AtomicBool, AtomicU32, Ordering},
-    };
-    use zbi::ZbiContainer;
-
-    // The thread-local atomics are an ugly, ugly hack to pass state between
-    // the protocol method functions and the rest of the test body.
-    // Because the variables are thread-local, it is safe to run tests concurrently
-    // so long as they establish correct initial values.
-    // Also, because no atomic is being read or written to by more than one thread,
-    // Ordering::Relaxed is perfectly fine.
-    thread_local! {
-        static ATOMIC: AtomicBool = AtomicBool::new(false);
-    }
-
-    thread_local! {
-        static BOOT_REASON: AtomicU32 = AtomicU32::new(REASON_EMPTY);
-    }
-
-    // This provides reasonable defaults for all tests that need to get slot info.
-    //
-    // SAFETY: checks that `info` is properly aligned and not null.
-    // Caller must make sure `info` points to a valid GblEfiSlotInfo struct.
-    unsafe extern "C" fn get_info(
-        _: *mut GblEfiABSlotProtocol,
-        idx: u8,
-        info: *mut GblEfiSlotInfo,
-    ) -> EfiStatus {
-        // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
-        if !info.is_null() && (info as usize) % align_of::<GblEfiSlotInfo>() == 0 && idx < 3 {
-            let slot_info = GblEfiSlotInfo {
-                suffix: ('a' as u8 + idx).into(),
-                unbootable_reason: 0,
-                priority: idx + 1,
-                tries: idx,
-                successful: 2 & idx,
-            };
-            unsafe { *info = slot_info };
-            EFI_STATUS_SUCCESS
-        } else {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-    }
-
-    extern "C" fn flush(_: *mut GblEfiABSlotProtocol) -> EfiStatus {
-        ATOMIC.with(|a| a.store(true, Ordering::Relaxed));
-        EFI_STATUS_SUCCESS
-    }
-
-    struct TestGblOps<'a> {
-        manager: ABManager<'a>,
-    }
-
-    impl<'a> TestGblOps<'a> {
-        fn new(protocol: Protocol<'a, ab_slot::GblSlotProtocol>) -> Self {
-            Self { manager: ABManager::new_without_token(protocol) }
-        }
-    }
-
-    impl<'a, 'd> GblOps<'a, 'd> for TestGblOps<'_> {
-        fn console_out(&mut self) -> Option<&mut dyn Write> {
-            unimplemented!();
-        }
-
-        fn should_stop_in_fastboot(&mut self) -> Result<bool> {
-            unimplemented!();
-        }
-
-        fn reboot(&mut self) {
-            unimplemented!();
-        }
-
-        fn disks(
-            &self,
-        ) -> &'a [GblDisk<
-            Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
-            Gpt<impl DerefMut<Target = [u8]> + 'a>,
-        >] {
-            &[] as &[GblDisk<Disk<BlockIoNull, &mut [u8]>, Gpt<&mut [u8]>>]
-        }
-
-        fn expected_os(&mut self) -> Result<Option<Os>> {
-            Ok(None)
-        }
-
-        fn zircon_add_device_zbi_items(&mut self, _: &mut ZbiContainer<&mut [u8]>) -> Result<()> {
-            unimplemented!();
-        }
-
-        fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
-            None
-        }
-
-        fn load_slot_interface<'b>(
-            &'b mut self,
-            persist: &'b mut dyn FnMut(&mut [u8]) -> Result<()>,
-            boot_token: BootToken,
-        ) -> GblResult<Cursor<'b>> {
-            self.manager.boot_token = Some(boot_token);
-            Ok(Cursor { ctx: &mut self.manager, persist })
-        }
-
-        fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-            unimplemented!();
-        }
-
-        fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64> {
-            unimplemented!();
-        }
-
-        fn avb_write_rollback_index(
-            &mut self,
-            _rollback_index_location: usize,
-            _index: u64,
-        ) -> AvbIoResult<()> {
-            unimplemented!();
-        }
-
-        fn avb_validate_vbmeta_public_key(
-            &self,
-            _public_key: &[u8],
-            _public_key_metadata: Option<&[u8]>,
-        ) -> AvbIoResult<KeyValidationStatus> {
-            unimplemented!();
-        }
-
-        fn avb_cert_read_permanent_attributes(
-            &mut self,
-            _attributes: &mut CertPermanentAttributes,
-        ) -> AvbIoResult<()> {
-            unimplemented!();
-        }
-
-        fn avb_cert_read_permanent_attributes_hash(
-            &mut self,
-        ) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
-            unimplemented!();
-        }
-
-        fn avb_read_persistent_value(
-            &mut self,
-            _name: &CStr,
-            _value: &mut [u8],
-        ) -> AvbIoResult<usize> {
-            unimplemented!();
-        }
-
-        fn avb_write_persistent_value(&mut self, _name: &CStr, _value: &[u8]) -> AvbIoResult<()> {
-            unimplemented!();
-        }
-
-        fn avb_erase_persistent_value(&mut self, _name: &CStr) -> AvbIoResult<()> {
-            unimplemented!();
-        }
-
-        fn avb_handle_verification_result(
-            &mut self,
-            _color: BootStateColor,
-            _digest: Option<&CStr>,
-            _boot_os_version: Option<&[u8]>,
-            _boot_security_patch: Option<&[u8]>,
-            _system_os_version: Option<&[u8]>,
-            _system_security_patch: Option<&[u8]>,
-            _vendor_os_version: Option<&[u8]>,
-            _vendor_security_patch: Option<&[u8]>,
-        ) -> AvbIoResult<()> {
-            unimplemented!();
-        }
-
-        fn get_image_buffer(
-            &mut self,
-            _image_name: &str,
-            _size: NonZeroUsize,
-        ) -> GblResult<ImageBuffer<'d>> {
-            unimplemented!();
-        }
-
-        fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
-            unimplemented!();
-        }
-
-        fn fixup_os_commandline<'c>(
-            &mut self,
-            _commandline: &CStr,
-            _fixup_buffer: &'c mut [u8],
-        ) -> Result<Option<&'c str>> {
-            unimplemented!();
-        }
-
-        fn fixup_bootconfig<'c>(
-            &mut self,
-            _bootconfig: &[u8],
-            _fixup_buffer: &'c mut [u8],
-        ) -> Result<Option<&'c [u8]>> {
-            unimplemented!();
-        }
-
-        fn fixup_device_tree(&mut self, _device_tree: &mut [u8]) -> Result<()> {
-            unimplemented!();
-        }
-
-        fn select_device_trees(
-            &mut self,
-            _components: &mut DeviceTreeComponentsRegistry,
-        ) -> Result<()> {
-            unimplemented!();
-        }
-
-        fn fastboot_variable<'arg>(
-            &mut self,
-            _: &CStr,
-            _: impl Iterator<Item = &'arg CStr> + Clone,
-            _: &mut [u8],
-        ) -> Result<usize> {
-            unimplemented!()
-        }
-
-        fn fastboot_visit_all_variables(&mut self, _: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
-            unimplemented!()
-        }
-
-        fn slots_metadata(&mut self) -> Result<SlotsMetadata> {
-            unimplemented!();
-        }
-
-        fn get_current_slot(&mut self) -> Result<Slot> {
-            unimplemented!()
-        }
-
-        fn get_next_slot(&mut self, _: bool) -> Result<Slot> {
-            unimplemented!()
-        }
-
-        fn set_active_slot(&mut self, _: u8) -> Result<()> {
-            unimplemented!()
-        }
-
-        fn set_reboot_reason(&mut self, _: RebootReason) -> Result<()> {
-            unimplemented!()
-        }
-
-        fn get_reboot_reason(&mut self) -> Result<RebootReason> {
-            unimplemented!()
-        }
-    }
-
-    #[test]
-    fn test_manager_flush_on_close() {
-        ATOMIC.with(|a| a.store(false, Ordering::Relaxed));
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol { flush: Some(flush), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-
-            {
-                let mut persist = |_: &mut [u8]| Ok(());
-                let mut test_ops = TestGblOps::new(protocol);
-                let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-                let _ = gbl.load_slot_interface(&mut persist).unwrap();
-            }
-        });
-        assert!(ATOMIC.with(|a| a.load(Ordering::Relaxed)));
-    }
-
-    #[test]
-    fn test_iterator() {
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                get_slot_info: Some(get_info),
-                flush: Some(flush),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-
-            let slots: Vec<Slot> = cursor.ctx.slots_iter().collect();
-            assert_eq!(
-                slots,
-                vec![
-                    Slot {
-                        suffix: 'a'.into(),
-                        priority: 1usize.into(),
-                        bootability: Bootability::Unbootable(UnbootableReason::Unknown),
-                    },
-                    Slot {
-                        suffix: 'b'.into(),
-                        priority: 2usize.into(),
-                        bootability: Bootability::Retriable(1usize.into()),
-                    },
-                    Slot {
-                        suffix: 'c'.into(),
-                        priority: 3usize.into(),
-                        bootability: Bootability::Successful,
-                    }
-                ]
-            )
-        });
-    }
-
-    #[test]
-    fn test_active_slot() {
-        // SAFETY: verfies that `info` properly aligned and not null.
-        // It is the callers responsibility to make sure
-        // that `info` points to a valid GblEfiSlotInfo.
-        unsafe extern "C" fn get_current_slot(
-            _: *mut GblEfiABSlotProtocol,
-            info: *mut GblEfiSlotInfo,
-        ) -> EfiStatus {
-            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
-            if info.is_null() || (info as usize) % align_of::<GblEfiSlotInfo>() != 0 {
-                return EFI_STATUS_INVALID_PARAMETER;
-            }
-            let slot_info = GblEfiSlotInfo {
-                suffix: 'a' as u32,
-                unbootable_reason: 0,
-                priority: 7,
-                tries: 15,
-                successful: 1,
-            };
-
-            unsafe { *info = slot_info };
-            EFI_STATUS_SUCCESS
-        }
-
-        // SAFETY: verifies that `reason` and `subreason_size` are aligned and not null.
-        // It is the caller's responsibility to make sure that `reason`
-        // and `subreason_size` point to valid output parameters.
-        unsafe extern "C" fn get_boot_reason(
-            _: *mut GblEfiABSlotProtocol,
-            reason: *mut u32,
-            subreason_size: *mut usize,
-            _subreason: *mut u8,
-        ) -> EfiStatus {
-            if reason.is_null()
-                || subreason_size.is_null()
-            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
-                || (reason as usize) % align_of::<u32>() != 0
-                || (subreason_size as usize) % align_of::<usize>() != 0
-            {
-                return EFI_STATUS_INVALID_PARAMETER;
-            }
-
-            unsafe {
-                *reason = BOOT_REASON.with(|r| r.load(Ordering::Relaxed));
-                *subreason_size = 0;
-            }
-            EFI_STATUS_SUCCESS
-        }
-
-        BOOT_REASON.with(|r| r.store(REASON_EMPTY, Ordering::Relaxed));
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                get_current_slot: Some(get_current_slot),
-                get_boot_reason: Some(get_boot_reason),
-                flush: Some(flush),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-
-            let slot = Slot {
-                suffix: 'a'.into(),
-                priority: 7usize.into(),
-                bootability: Bootability::Successful,
-            };
-            assert_eq!(cursor.ctx.get_boot_target().unwrap(), BootTarget::NormalBoot(slot));
-            assert_eq!(cursor.ctx.get_slot_last_set_active().unwrap(), slot);
-
-            BOOT_REASON.with(|r| r.store(REASON_RECOVERY, Ordering::Relaxed));
-
-            assert_eq!(
-                cursor.ctx.get_boot_target().unwrap(),
-                BootTarget::Recovery(RecoveryTarget::Slotted(slot))
-            );
-        });
-    }
-
-    #[test]
-    fn test_mark_boot_attempt() {
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol { flush: Some(flush), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-            assert!(cursor.ctx.mark_boot_attempt().is_ok());
-
-            assert_eq!(cursor.ctx.mark_boot_attempt(), Err(Error::OperationProhibited));
-        });
-    }
-
-    #[test]
-    fn test_get_max_retries() {
-        // SAFETY: verifies that `meta` is properly aligned and not null.
-        // It is the caller's responsibility to make sure that `meta` points to
-        // a valid GblEfiSlotMetadataBlock.
-        unsafe extern "C" fn load_boot_data(
-            _: *mut GblEfiABSlotProtocol,
-            meta: *mut GblEfiSlotMetadataBlock,
-        ) -> EfiStatus {
-            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
-            if meta.is_null() || (meta as usize) % align_of::<GblEfiSlotMetadataBlock>() != 0 {
-                return EFI_STATUS_INVALID_PARAMETER;
-            }
-
-            let meta_block = GblEfiSlotMetadataBlock {
-                unbootable_metadata: 1,
-                max_retries: 66,
-                slot_count: 32, // why not?
-                merge_status: 0,
-            };
-
-            unsafe { *meta = meta_block };
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                load_boot_data: Some(load_boot_data),
-                flush: Some(flush),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-            assert_eq!(cursor.ctx.get_max_retries().unwrap(), 66usize.into());
-        });
-    }
-
-    #[test]
-    fn test_set_active_slot() {
-        extern "C" fn set_active_slot(_: *mut GblEfiABSlotProtocol, idx: u8) -> EfiStatus {
-            // This is deliberate: we want to make sure that other logic catches
-            // 'no such slot' first but we also want to verify that errors propagate.
-            if idx != 2 {
-                EFI_STATUS_SUCCESS
-            } else {
-                EFI_STATUS_INVALID_PARAMETER
-            }
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                get_slot_info: Some(get_info),
-                set_active_slot: Some(set_active_slot),
-                flush: Some(flush),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-
-            assert_eq!(cursor.ctx.set_active_slot('b'.into()), Ok(()));
-            assert_eq!(cursor.ctx.set_active_slot('c'.into()), Err(Error::Other(None)));
-
-            let bad_suffix = '$'.into();
-            assert_eq!(cursor.ctx.set_active_slot(bad_suffix), Err(Error::InvalidInput));
-        });
-    }
-
-    #[test]
-    fn test_set_slot_unbootable() {
-        extern "C" fn set_slot_unbootable(
-            _: *mut GblEfiABSlotProtocol,
-            idx: u8,
-            _: u32,
-        ) -> EfiStatus {
-            // Same thing here as with set_active_slot.
-            // We want to make sure that iteration over the slots
-            // catches invalid suffixes, but we also want to make sure
-            // that errors from the protocol percolate up.
-            if idx == 0 {
-                EFI_STATUS_SUCCESS
-            } else {
-                EFI_STATUS_INVALID_PARAMETER
-            }
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                get_slot_info: Some(get_info),
-                set_slot_unbootable: Some(set_slot_unbootable),
-                flush: Some(flush),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-
-            assert_eq!(
-                cursor.ctx.set_slot_unbootable('a'.into(), UnbootableReason::SystemUpdate),
-                Ok(())
-            );
-
-            assert_eq!(
-                cursor.ctx.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested),
-                Err(Error::InvalidInput)
-            );
-        });
-    }
-
-    #[test]
-    fn test_oneshot() {
-        // SAFETY: checks that `reason` is not null and is properly aligned.
-        // Caller must make sure reason points to a valid u32.
-        unsafe extern "C" fn get_boot_reason(
-            _: *mut GblEfiABSlotProtocol,
-            reason: *mut u32,
-            _: *mut usize,
-            _: *mut u8,
-        ) -> EfiStatus {
-            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
-            if reason.is_null() || (reason as usize) % align_of::<u32>() != 0 {
-                return EFI_STATUS_INVALID_PARAMETER;
-            }
-
-            unsafe { *reason = BOOT_REASON.with(|r| r.load(Ordering::Relaxed)) };
-
-            EFI_STATUS_SUCCESS
-        }
-
-        extern "C" fn set_boot_reason(
-            _: *mut GblEfiABSlotProtocol,
-            reason: u32,
-            _: usize,
-            _: *const u8,
-        ) -> EfiStatus {
-            BOOT_REASON.with(|r| r.store(reason, Ordering::Relaxed));
-            EFI_STATUS_SUCCESS
-        }
-
-        BOOT_REASON.with(|r| r.store(REASON_EMPTY, Ordering::Relaxed));
-        run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                get_boot_reason: Some(get_boot_reason),
-                set_boot_reason: Some(set_boot_reason),
-                flush: Some(flush),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut persist = |_: &mut [u8]| Ok(());
-            let mut test_ops = TestGblOps::new(protocol);
-            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
-
-            assert_eq!(cursor.ctx.get_oneshot_status(), None);
-            assert_eq!(
-                cursor.ctx.set_oneshot_status(OneShot::Continue(RecoveryTarget::Dedicated)),
-                Err(Error::OperationProhibited)
-            );
-            assert_eq!(cursor.ctx.set_oneshot_status(OneShot::Bootloader), Ok(()));
-            assert_eq!(cursor.ctx.get_oneshot_status(), Some(OneShot::Bootloader));
-
-            cursor.ctx.clear_oneshot_status();
-            assert_eq!(cursor.ctx.get_oneshot_status(), None);
-
-            BOOT_REASON.with(|r| r.store(REASON_WATCHDOG, Ordering::Relaxed));
-            assert_eq!(cursor.ctx.get_oneshot_status(), None);
-            cursor.ctx.clear_oneshot_status();
-            assert_eq!(BOOT_REASON.with(|r| r.load(Ordering::Relaxed)), REASON_WATCHDOG);
-        });
-    }
-}
diff --git a/gbl/libefi/src/allocation.rs b/gbl/libefi/src/allocation.rs
deleted file mode 100644
index 80324ca..0000000
--- a/gbl/libefi/src/allocation.rs
+++ /dev/null
@@ -1,252 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{EfiEntry, RuntimeServices};
-use efi_types::EFI_MEMORY_TYPE_LOADER_DATA;
-
-use core::mem::size_of_val;
-use core::ptr::null_mut;
-use core::{
-    alloc::{GlobalAlloc, Layout},
-    fmt::Write,
-};
-use liberror::{Error, Result};
-use safemath::SafeNum;
-
-/// Implements a global allocator using `EFI_BOOT_SERVICES.AllocatePool()/FreePool()`
-///
-/// To use, add this exact declaration to the application code:
-///
-/// ```
-/// #[no_mangle]
-/// #[global_allocator]
-/// static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiState::new();
-/// ```
-///
-/// This is only useful for real UEFI applications; attempting to install the `EFI_GLOBAL_ALLOCATOR`
-/// for host-side unit tests will cause the test to panic immediately.
-pub struct EfiAllocator {
-    state: EfiState,
-    runtime_services: Option<RuntimeServices>,
-}
-
-/// Represents the global EFI state.
-enum EfiState {
-    /// Initial state, no UEFI entry point has been set, global hooks will not work.
-    Uninitialized,
-    /// [EfiEntry] is registered, global hooks are active.
-    Initialized(EfiEntry),
-    /// ExitBootServices has been called, global hooks will not work.
-    Exited,
-}
-
-impl EfiState {
-    /// Returns a reference to the EfiEntry.
-    fn efi_entry(&self) -> Option<&EfiEntry> {
-        match self {
-            EfiState::Initialized(ref entry) => Some(entry),
-            _ => None,
-        }
-    }
-}
-
-// This is a bit ugly, but we only expect this library to be used by our EFI application so it
-// doesn't need to be super clean or scalable. The user has to declare the global variable
-// exactly as written in the [EfiAllocator] docs for this to link properly.
-//
-// TODO(b/396460116): Investigate using Mutex for the variable.
-extern "Rust" {
-    static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator;
-}
-
-/// An internal API to obtain library internal global EfiEntry and RuntimeServices.
-pub(crate) fn internal_efi_entry_and_rt(
-) -> (Option<&'static EfiEntry>, Option<&'static RuntimeServices>) {
-    // SAFETY:
-    // EFI_GLOBAL_ALLOCATOR is only read by `internal_efi_entry_and_rt()` and modified by
-    // `init_efi_global_alloc()` and `exit_efi_global_alloc()`. The safety requirements of
-    // `init_efi_global_alloc()` and `exit_efi_global_alloc()` mandate that there can be no EFI
-    // event/notification/interrupt that can be triggered when they are called. This suggests that
-    // there cannot be concurrent read and modification on `EFI_GLOBAL_ALLOCATOR` possible. Thus its
-    // access is safe from race condition.
-    #[allow(static_mut_refs)]
-    unsafe {
-        EFI_GLOBAL_ALLOCATOR.get_efi_entry_and_rt()
-    }
-}
-
-/// Try to print via `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL` in `EFI_SYSTEM_TABLE.ConOut`.
-///
-/// Errors are ignored.
-#[macro_export]
-macro_rules! efi_try_print {
-    ($( $x:expr ),* $(,)? ) => {
-        {
-            let _ = (|| -> Result<()> {
-                if let Some(entry) = crate::allocation::internal_efi_entry_and_rt().0 {
-                    write!(entry.system_table_checked()?.con_out()?, $($x,)*)?;
-                }
-                Ok(())
-            })();
-        }
-    };
-}
-
-/// Initializes global allocator.
-///
-/// # Safety
-///
-/// This function modifies global variable `EFI_GLOBAL_ALLOCATOR`. It should only be called when
-/// there is no event/notification function that can be triggered or modify it. Otherwise there
-/// is a risk of race condition.
-pub(crate) unsafe fn init_efi_global_alloc(efi_entry: EfiEntry) -> Result<()> {
-    // SAFETY: See SAFETY of `internal_efi_entry_and_rt()`
-    unsafe {
-        EFI_GLOBAL_ALLOCATOR.runtime_services =
-            efi_entry.system_table_checked().and_then(|v| v.runtime_services_checked()).ok();
-        match EFI_GLOBAL_ALLOCATOR.state {
-            EfiState::Uninitialized => {
-                EFI_GLOBAL_ALLOCATOR.state = EfiState::Initialized(efi_entry);
-                Ok(())
-            }
-            _ => Err(Error::AlreadyStarted),
-        }
-    }
-}
-
-/// Internal API to invalidate global allocator after ExitBootService().
-///
-/// # Safety
-///
-/// This function modifies global variable `EFI_GLOBAL_ALLOCATOR`. It should only be called when
-/// there is no event/notification function that can be triggered or modify it. Otherwise there
-/// is a risk of race condition.
-pub(crate) unsafe fn exit_efi_global_alloc() {
-    // SAFETY: See SAFETY of `internal_efi_entry_and_rt()`
-    unsafe {
-        EFI_GLOBAL_ALLOCATOR.state = EfiState::Exited;
-    }
-}
-
-impl EfiAllocator {
-    /// Creates a new instance.
-    pub const fn new() -> Self {
-        Self { state: EfiState::Uninitialized, runtime_services: None }
-    }
-
-    /// Gets EfiEntry and RuntimeServices
-    fn get_efi_entry_and_rt(&self) -> (Option<&EfiEntry>, Option<&RuntimeServices>) {
-        (self.state.efi_entry(), self.runtime_services.as_ref())
-    }
-
-    /// Allocate memory via EFI_BOOT_SERVICES.
-    fn allocate(&self, size: usize) -> *mut u8 {
-        self.state
-            .efi_entry()
-            .ok_or(Error::InvalidState)
-            .and_then(|v| v.system_table_checked())
-            .and_then(|v| v.boot_services_checked())
-            .and_then(|v| v.allocate_pool(EFI_MEMORY_TYPE_LOADER_DATA, size))
-            .inspect_err(|e| efi_try_print!("failed to allocate: {e}"))
-            .unwrap_or(null_mut()) as _
-    }
-
-    /// Deallocate memory previously allocated by `Self::allocate()`.
-    ///
-    /// Errors are logged but ignored.
-    fn deallocate(&self, ptr: *mut u8) {
-        match self.state.efi_entry() {
-            Some(ref entry) => {
-                let _ = entry
-                    .system_table_checked()
-                    .and_then(|v| v.boot_services_checked())
-                    .and_then(|v| v.free_pool(ptr as *mut _))
-                    .inspect_err(|e| efi_try_print!("failed to deallocate: {e}"));
-            }
-            // After EFI_BOOT_SERVICES.ExitBootServices(), all allocated memory is considered
-            // leaked and under full ownership of subsequent OS loader code.
-            _ => {}
-        }
-    }
-}
-
-// Alignment guaranteed by EFI AllocatePoll()
-const EFI_ALLOCATE_POOL_ALIGNMENT: usize = 8;
-
-unsafe impl GlobalAlloc for EfiAllocator {
-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
-        (|| -> Result<*mut u8> {
-            let align = layout.align();
-
-            // EFI AllocatePoll() must be at 8-bytes aligned so we can just use returned pointer.
-            if align <= EFI_ALLOCATE_POOL_ALIGNMENT {
-                let ptr = self.allocate(layout.size());
-                assert_eq!(ptr as usize % EFI_ALLOCATE_POOL_ALIGNMENT, 0);
-                return Ok(ptr);
-            }
-
-            // If requested alignment is > EFI_ALLOCATE_POOL_ALIGNMENT then make sure to allocate
-            // bigger buffer and adjust ptr to be aligned.
-            let mut offset: usize = 0usize;
-            let extra_size = SafeNum::from(align) + size_of_val(&offset);
-            let size = SafeNum::from(layout.size()) + extra_size;
-
-            // TODO(300168989):
-            // `AllocatePool()` can be slow for allocating large buffers. In this case,
-            // `AllocatePages()` is recommended.
-            let unaligned_ptr = self.allocate(size.try_into()?);
-            if unaligned_ptr.is_null() {
-                return Err(Error::Other(Some("Allocation failed")));
-            }
-            offset = align - (unaligned_ptr as usize % align);
-
-            // SAFETY:
-            // - `unaligned_ptr` is guaranteed to point to buffer big enough to contain offset+size
-            // bytes since this is the size passed to `allocate`
-            // - ptr+layout.size() is also pointing to valid buffer since actual allocate size takes
-            // into account additional suffix for usize variable
-            unsafe {
-                let ptr = unaligned_ptr.add(offset);
-                core::slice::from_raw_parts_mut(ptr.add(layout.size()), size_of_val(&offset))
-                    .copy_from_slice(&offset.to_ne_bytes());
-                Ok(ptr)
-            }
-        })()
-        .unwrap_or(null_mut()) as _
-    }
-
-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
-        // If alignment is EFI_ALLOCATE_POOL_ALIGNMENT or less, then we can just used ptr directly
-        if layout.align() <= EFI_ALLOCATE_POOL_ALIGNMENT {
-            self.deallocate(ptr);
-            return;
-        }
-
-        let mut offset: usize = 0usize;
-        offset = usize::from_ne_bytes(
-            // SAFETY:
-            // * `ptr` is allocated by `alloc` and has enough padding after `ptr`+size to hold
-            // suffix `offset: usize`.
-            // * Alignment of `ptr` is 1 for &[u8]
-            unsafe { core::slice::from_raw_parts(ptr.add(layout.size()), size_of_val(&offset)) }
-                .try_into()
-                .unwrap(),
-        );
-
-        // SAFETY:
-        // (`ptr` - `offset`) must be valid unaligned pointer to buffer allocated by `alloc`
-        let real_start_ptr = unsafe { ptr.sub(offset) };
-        self.deallocate(real_start_ptr);
-    }
-}
diff --git a/gbl/libefi/src/lib.rs b/gbl/libefi/src/lib.rs
deleted file mode 100644
index 5438913..0000000
--- a/gbl/libefi/src/lib.rs
+++ /dev/null
@@ -1,1713 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! The library implements Rust wrappers for a set of UEFI interfaces needed by GBL. It also
-//! provides a global allocator and supports auto release of dynamic UEFI resource such as
-//! protocols and UEFI allocated buffers.
-//!
-//! # Examples
-//!
-//! The following example covers the basic use pattern of the library. It scans all block devices
-//! and prints out the device path, block size and io alignment info for each of them.
-//!
-//! ```
-//! fn main(image: EfiHandle, systab_ptr: *mut EfiSystemTable) -> liberror::Result<()> {
-//!     let efi_entry = initialize(image, systab_ptr)?;
-//!     let mut con_out = efi_entry.system_table().con_out()?;
-//!     let boot_services = efi_entry.system_table().boot_services();
-//!     let path_to_text = boot_services.find_first_and_open::<DevicePathToTextProtocol>()?;
-//!
-//!     write!(con_out, "Scanning block devices...\n")?;
-//!
-//!     let block_handles = boot_services.locate_handle_buffer_by_protocol::<BlockIoProtocol>()?;
-//!
-//!     for (i, handle) in block_handles.handles().iter().enumerate() {
-//!         let path = boot_services.open_protocol::<DevicePathProtocol>(*handle)?;
-//!         write!(con_out, "Block Device #{}: ", i)?;
-//!         path_to_text.convert_device_path_to_text(&path, false, false)?.print()?;
-//!         write!(con_out, "\n")?;
-//!
-//!         let block_io_protocol = boot_services.open_protocol::<BlockIoProtocol>(*handle)?;
-//!         let media = block_io_protocol.media()?;
-//!         write!(con_out, "  block size = {}\n", media.block_size)?;
-//!         write!(con_out, "  io alignment = {}\n", media.io_align)?;
-//!     }
-//!
-//!     Ok(())
-//! }
-//! ```
-
-#![cfg_attr(not(test), no_std)]
-
-extern crate alloc;
-use alloc::vec::Vec;
-
-#[cfg(not(test))]
-mod allocation;
-
-#[cfg(not(test))]
-pub mod libc;
-
-#[cfg(not(test))]
-pub use allocation::EfiAllocator;
-
-/// The Android EFI protocol implementation of an A/B slot manager.
-pub mod ab_slots;
-/// Local fastboot/bootmenu support.
-pub mod local_session;
-/// Idiomatic wrappers around EFI protocols.
-pub mod protocol;
-pub mod utils;
-
-#[cfg(not(test))]
-use core::{fmt::Write, panic::PanicInfo};
-
-use core::{marker::PhantomData, ptr::null_mut, slice::from_raw_parts, time::Duration};
-use efi_types::{
-    EfiBootService, EfiConfigurationTable, EfiEvent, EfiGuid, EfiHandle,
-    EfiMemoryAttributesTableHeader, EfiMemoryDescriptor, EfiMemoryType, EfiRuntimeService,
-    EfiSystemTable, EfiTimerDelay, EFI_EVENT_TYPE_NOTIFY_SIGNAL, EFI_EVENT_TYPE_NOTIFY_WAIT,
-    EFI_EVENT_TYPE_RUNTIME, EFI_EVENT_TYPE_SIGNAL_EXIT_BOOT_SERVICES,
-    EFI_EVENT_TYPE_SIGNAL_VIRTUAL_ADDRESS_CHANGE, EFI_EVENT_TYPE_TIMER,
-    EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL, EFI_OPEN_PROTOCOL_ATTRIBUTE_BY_HANDLE_PROTOCOL,
-    EFI_RESET_TYPE, EFI_RESET_TYPE_EFI_RESET_COLD, EFI_STATUS, EFI_STATUS_SUCCESS,
-};
-use liberror::{Error, Result};
-use libutils::aligned_subslice;
-use protocol::{
-    simple_text_output::SimpleTextOutputProtocol,
-    {Protocol, ProtocolInfo},
-};
-use zerocopy::{FromBytes, Ref};
-
-/// `EfiEntry` stores the EFI system table pointer and image handle passed from the entry point.
-/// It's the root data structure that derives all other wrapper APIs and structures.
-pub struct EfiEntry {
-    image_handle: EfiHandle,
-    systab_ptr: *const EfiSystemTable,
-}
-
-impl EfiEntry {
-    /// Gets an instance of `SystemTable`.
-    ///
-    /// Panics if the pointer is NULL.
-    pub fn system_table(&self) -> SystemTable {
-        self.system_table_checked().unwrap()
-    }
-
-    /// Gets an instance of `SystemTable` if pointer is valid.
-    pub fn system_table_checked(&self) -> Result<SystemTable> {
-        // SAFETY: Pointers to UEFI data strucutres.
-        Ok(SystemTable {
-            efi_entry: self,
-            table: unsafe { self.systab_ptr.as_ref() }.ok_or(Error::Unsupported)?,
-        })
-    }
-
-    /// Gets the image handle.
-    pub fn image_handle(&self) -> DeviceHandle {
-        DeviceHandle(self.image_handle)
-    }
-}
-
-/// The vendor GUID for UEFI variables defined by GBL.
-pub const GBL_EFI_VENDOR_GUID: EfiGuid =
-    EfiGuid::new(0x5a6d92f3, 0xa2d0, 0x4083, [0x91, 0xa1, 0xa5, 0x0f, 0x6c, 0x3d, 0x98, 0x30]);
-
-/// GUID for UEFI Memory Attributes Table
-pub const EFI_MEMORY_ATTRIBUTES_GUID: EfiGuid =
-    EfiGuid::new(0xdcfa911d, 0x26eb, 0x469f, [0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20]);
-
-/// The name of the UEFI variable that GBL defines to determine whether to boot Fuchsia.
-/// The value of the variable is ignored: if the variable is present,
-/// it indicates that the bootloader should attempt to boot a Fuchsia target.
-/// This may include reinitializing GPT partitions and partition contents.
-pub const GBL_EFI_OS_BOOT_TARGET_VARNAME: &str = "gbl_os_boot_fuchsia";
-
-/// Creates an `EfiEntry` and initialize EFI global allocator.
-///
-/// # Safety
-///
-/// The API modifies internal global state. It should only be called once upon EFI entry to obtain
-/// an instance of `EfiEntry` for accessing other APIs. Calling it again when EFI APIs are already
-/// being used can introduce a risk of race.
-#[cfg(not(test))]
-pub unsafe fn initialize(
-    image_handle: EfiHandle,
-    systab_ptr: *const EfiSystemTable,
-) -> Result<EfiEntry> {
-    // SAFETY: By safety requirement of this function, `initialize` is only called once upon
-    // entering EFI application, where there should be no event notify function that can be
-    // triggered.
-    unsafe {
-        // Create one for internal global allocator.
-        allocation::init_efi_global_alloc(EfiEntry { image_handle, systab_ptr })?;
-    }
-    Ok(EfiEntry { image_handle, systab_ptr })
-}
-
-/// Exits boot service and returns the memory map in the given buffer.
-///
-/// The API takes ownership of the given `entry` and causes it to go out of scope.
-/// This enforces strict compile time check that any reference/borrow in effect will cause compile
-/// errors.
-///
-/// Existing heap allocated memories will maintain their states. All system memory including them
-/// will be under onwership of the subsequent OS or OS loader code.
-pub fn exit_boot_services(entry: EfiEntry, mmap_buffer: &mut [u8]) -> Result<EfiMemoryMap> {
-    let aligned = aligned_subslice(mmap_buffer, core::mem::align_of::<EfiMemoryDescriptor>())?;
-
-    let res = entry.system_table().boot_services().get_memory_map(aligned)?;
-    entry.system_table().boot_services().exit_boot_services(&res)?;
-    // SAFETY:
-    // At this point, UEFI has successfully exited boot services and no event/notification can be
-    // triggered.
-    #[cfg(not(test))]
-    unsafe {
-        allocation::exit_efi_global_alloc();
-    }
-    Ok(res)
-}
-
-/// `SystemTable` provides methods for accessing fields in `EFI_SYSTEM_TABLE`.
-#[derive(Clone, Copy)]
-pub struct SystemTable<'a> {
-    efi_entry: &'a EfiEntry,
-    table: &'a EfiSystemTable,
-}
-
-impl<'a> SystemTable<'a> {
-    /// Creates an instance of `BootServices`
-    ///
-    /// Panics if not implemented by UEFI.
-    pub fn boot_services(&self) -> BootServices<'a> {
-        self.boot_services_checked().unwrap()
-    }
-
-    /// Creates an instance of `BootServices`
-    ///
-    /// Returns Err(()) if not implemented by UEFI.
-    pub fn boot_services_checked(&self) -> Result<BootServices<'a>> {
-        Ok(BootServices {
-            efi_entry: self.efi_entry,
-            // SAFETY: Pointers to UEFI data strucutres.
-            boot_services: unsafe { self.table.boot_services.as_ref() }
-                .ok_or(Error::Unsupported)?,
-        })
-    }
-
-    /// Creates an instance of `RuntimeServices`
-    ///
-    /// Panics if run time services is not implemented.
-    pub fn runtime_services(&self) -> RuntimeServices {
-        self.runtime_services_checked().unwrap()
-    }
-
-    /// Creates an instance of `RuntimeServices` if available from system table.
-    pub fn runtime_services_checked(&self) -> Result<RuntimeServices> {
-        Ok(RuntimeServices {
-            // SAFETY: Pointers to UEFI data strucutres.
-            runtime_services: *unsafe { self.table.runtime_services.as_ref() }
-                .ok_or(Error::Unsupported)?,
-        })
-    }
-
-    /// Gets the `EFI_SYSTEM_TABLE.ConOut` field.
-    pub fn con_out(&self) -> Result<Protocol<'a, SimpleTextOutputProtocol>> {
-        // SAFETY: `EFI_SYSTEM_TABLE.ConOut` is a pointer to EfiSimpleTextOutputProtocol structure
-        // by definition. It lives until ExitBootService and thus as long as `self.efi_entry` or,
-        // 'a
-        Ok(unsafe {
-            Protocol::<SimpleTextOutputProtocol>::new(
-                // No device handle. This protocol is a permanent reference.
-                DeviceHandle(null_mut()),
-                self.table.con_out,
-                self.efi_entry,
-            )
-        })
-    }
-
-    /// Gets the `EFI_SYSTEM_TABLE.ConfigurationTable` array.
-    pub fn configuration_table(&self) -> Option<&[EfiConfigurationTable]> {
-        match self.table.configuration_table.is_null() {
-            true => None,
-            // SAFETY: Non-null pointer to EFI configuration table.
-            false => unsafe {
-                Some(from_raw_parts(
-                    self.table.configuration_table,
-                    self.table.number_of_table_entries,
-                ))
-            },
-        }
-    }
-}
-
-/// `BootServices` provides methods for accessing various EFI_BOOT_SERVICES interfaces.
-#[derive(Clone, Copy)]
-pub struct BootServices<'a> {
-    efi_entry: &'a EfiEntry,
-    boot_services: &'a EfiBootService,
-}
-
-impl<'a> BootServices<'a> {
-    /// Wrapper of `EFI_BOOT_SERVICES.AllocatePool()`.
-    #[allow(dead_code)]
-    fn allocate_pool(
-        &self,
-        pool_type: EfiMemoryType,
-        size: usize,
-    ) -> Result<*mut core::ffi::c_void> {
-        let mut out: *mut core::ffi::c_void = null_mut();
-        // SAFETY: `EFI_BOOT_SERVICES` method call.
-        unsafe {
-            efi_call!(self.boot_services.allocate_pool, pool_type, size, &mut out)?;
-        }
-        Ok(out)
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICES.FreePool()`.
-    fn free_pool(&self, buf: *mut core::ffi::c_void) -> Result<()> {
-        // SAFETY: `EFI_BOOT_SERVICES` method call.
-        unsafe { efi_call!(self.boot_services.free_pool, buf) }
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICES.OpenProtocol()`.
-    pub fn open_protocol<T: ProtocolInfo>(&self, handle: DeviceHandle) -> Result<Protocol<'a, T>> {
-        let mut out_handle: EfiHandle = null_mut();
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe {
-            efi_call!(
-                self.boot_services.open_protocol,
-                handle.0,
-                &T::GUID,
-                &mut out_handle as *mut _,
-                self.efi_entry.image_handle().0,
-                null_mut(),
-                EFI_OPEN_PROTOCOL_ATTRIBUTE_BY_HANDLE_PROTOCOL
-            )?;
-        }
-        // SAFETY: `EFI_SYSTEM_TABLE.OpenProtocol` returns a valid pointer to `T::InterfaceType`
-        // on success. The pointer remains valid until closed by
-        // `EFI_BOOT_SERVICES.CloseProtocol()` when Protocol goes out of scope.
-        Ok(unsafe { Protocol::<T>::new(handle, out_handle as *mut _, self.efi_entry) })
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICES.CloseProtocol()`.
-    #[allow(dead_code)]
-    fn close_protocol<T: ProtocolInfo>(&self, handle: DeviceHandle) -> Result<()> {
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe {
-            efi_call!(
-                self.boot_services.close_protocol,
-                handle.0,
-                &T::GUID,
-                self.efi_entry.image_handle().0,
-                null_mut()
-            )
-        }
-    }
-
-    /// Call `EFI_BOOT_SERVICES.LocateHandleBuffer()` with fixed
-    /// `EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL` and without search key.
-    pub fn locate_handle_buffer_by_protocol<T: ProtocolInfo>(&self) -> Result<LocatedHandles<'a>> {
-        let mut num_handles: usize = 0;
-        let mut handles: *mut EfiHandle = null_mut();
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe {
-            efi_call!(
-                self.boot_services.locate_handle_buffer,
-                EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL,
-                &T::GUID,
-                null_mut(),
-                &mut num_handles as *mut usize as *mut _,
-                &mut handles as *mut *mut EfiHandle
-            )?
-        };
-        // `handles` should be a valid pointer if the above succeeds. But just double check
-        // to be safe. If assert fails, then there's a bug in the UEFI firmware.
-        assert!(!handles.is_null());
-        Ok(LocatedHandles::new(handles, num_handles, self.efi_entry))
-    }
-
-    /// Search and open the first found target EFI protocol.
-    pub fn find_first_and_open<T: ProtocolInfo>(&self) -> Result<Protocol<'a, T>> {
-        // We don't use EFI_BOOT_SERVICES.LocateProtocol() because it doesn't give device handle
-        // which is required to close the protocol.
-        let handle = *self
-            .locate_handle_buffer_by_protocol::<T>()?
-            .handles()
-            .first()
-            .ok_or(Error::NotFound)?;
-        self.open_protocol::<T>(handle)
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICE.GetMemoryMap()`.
-    pub fn get_memory_map<'b>(&self, mmap_buffer: &'b mut [u8]) -> Result<EfiMemoryMap<'b>> {
-        let mut mmap_size = mmap_buffer.len();
-        let mut map_key: usize = 0;
-        let mut descriptor_size: usize = 0;
-        let mut descriptor_version: u32 = 0;
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe {
-            efi_call!(
-                self.boot_services.get_memory_map,
-                &mut mmap_size,
-                mmap_buffer.as_mut_ptr() as *mut _,
-                &mut map_key,
-                &mut descriptor_size,
-                &mut descriptor_version
-            )
-        }?;
-        Ok(EfiMemoryMap::new(
-            &mut mmap_buffer[..mmap_size],
-            map_key,
-            descriptor_size,
-            descriptor_version,
-        ))
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICE.ExitBootServices()`.
-    fn exit_boot_services<'b>(&self, mmap: &'b EfiMemoryMap<'b>) -> Result<()> {
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe {
-            efi_call!(
-                self.boot_services.exit_boot_services,
-                self.efi_entry.image_handle().0,
-                mmap.map_key()
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICE.Stall()`.
-    pub fn stall(&self, micro: usize) -> Result<()> {
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe { efi_call!(self.boot_services.stall, micro) }
-    }
-
-    /// Wraps `EFI_BOOT_SERVICE.CreateEvent()`.
-    ///
-    /// This function creates an event without a notification callback function; to create an event
-    /// with a notification, see [create_event_with_notification].
-    ///
-    /// # Arguments
-    /// * `event_type`: The EFI event type.
-    pub fn create_event(&self, event_type: EventType) -> Result<Event<'a, 'static>> {
-        let mut efi_event: EfiEvent = null_mut();
-        // SAFETY:
-        // * all parameters obey the `CreateEvent()` spec
-        // * on success we take ownership of the provided `efi_event`
-        unsafe {
-            efi_call!(
-                self.boot_services.create_event,
-                event_type as u32,
-                0,
-                None,
-                null_mut(),
-                &mut efi_event
-            )?;
-        }
-        Ok(Event::new(self.efi_entry, efi_event, None))
-    }
-
-    /// Wraps `EFI_BOOT_SERVICE.CreateEvent()`.
-    ///
-    /// This function creates an event with a notification callback function.
-    ///
-    /// Unlike [create_event], this function is unsafe because the callback will be executed
-    /// concurrently with the main application code at a higher interrupt level, and there are
-    /// a few cases where this can lead to races.
-    ///
-    /// # Arguments
-    /// * `event_type`: The EFI event type.
-    /// * `cb`: An [EventNotify] which implements the event notification function and provides the
-    ///         task level priority setting.
-    ///
-    /// # Safety
-    /// Most of the safety conditions are enforced at compile-time by the [Sync] requirement on
-    /// [EventNotifyCallback] - this ensures that e.g. callers cannot capture their raw [EfiEntry]
-    /// in a callback, but will need to wrap it in a [Sync] type which will ensure safe sharing
-    /// between the main application and the callback.
-    ///
-    /// The exception is the global allocation and panic hooks, which use a separate global
-    /// [EfiEntry] that is not synchronized outside the main application. The caller must ensure
-    /// that the main application code is not using its [EfiEntry] while a notification callback
-    /// is trying to concurrently use the global [EfiEntry].
-    ///
-    /// The easiest way to accomplish this is to write notifications callbacks that:
-    /// * do not allocate or deallocate heap memory
-    /// * do not panic
-    /// Callbacks following these guidelines are safe as they do not use the global [EfiEntry].
-    ///
-    /// If that is not possible, then the caller must ensure that nothing else makes any calls into
-    /// UEFI while the returned [Event] is alive; the callback function must have exclusive access
-    /// to the UEFI APIs so it can use the globals without triggering UEFI reentry.
-    ///
-    /// In unittests there is no global [EfiEntry] so this is always safe.
-    pub unsafe fn create_event_with_notification<'e>(
-        &self,
-        event_type: EventType,
-        notify: &'e mut EventNotify,
-    ) -> Result<Event<'a, 'e>> {
-        let mut efi_event: EfiEvent = null_mut();
-        // SAFETY:
-        // Pointers passed are output/callback context pointers which will not be retained by the
-        // callback (`fn efi_event_cb()`).
-        // The returned `Event` enforces a borrow to `cb` for 'e. It closes the event when it
-        // goes out of scope. This ensures that `cb` lives at least as long as the event is in
-        // effect and there can be no other borrows to `cb`.
-        unsafe {
-            efi_call!(
-                self.boot_services.create_event,
-                event_type as u32,
-                notify.tpl as usize,
-                Some(efi_event_cb),
-                notify as *mut _ as *mut _,
-                &mut efi_event
-            )?;
-        }
-        Ok(Event::new(self.efi_entry, efi_event, Some(notify.cb)))
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICE.CloseEvent()`.
-    fn close_event(&self, event: &Event) -> Result<()> {
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe { efi_call!(self.boot_services.close_event, event.efi_event) }
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICE.CheckEvent()`.
-    ///
-    /// On success, returns true if the event is signaled, false if not.
-    pub fn check_event(&self, event: &Event) -> Result<bool> {
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        match unsafe { efi_call!(self.boot_services.check_event, event.efi_event) } {
-            Err(e) if e != Error::NotReady => Err(e),
-            Ok(()) => Ok(true),
-            _ => Ok(false),
-        }
-    }
-
-    /// Wrapper of `EFI_BOOT_SERVICE.SetTimer()`.
-    pub fn set_timer(
-        &self,
-        event: &Event,
-        delay_type: EfiTimerDelay,
-        trigger_time: Duration,
-    ) -> Result<()> {
-        // SAFETY: EFI_BOOT_SERVICES method call.
-        unsafe {
-            efi_call!(
-                self.boot_services.set_timer,
-                event.efi_event,
-                delay_type,
-                (trigger_time.as_nanos() / 100).try_into()?
-            )
-        }
-    }
-}
-
-/// `RuntimeServices` provides methods for accessing various EFI_RUNTIME_SERVICES interfaces.
-#[derive(Clone, Copy)]
-pub struct RuntimeServices {
-    runtime_services: EfiRuntimeService,
-}
-
-impl RuntimeServices {
-    /// Wrapper of `EFI_RUNTIME_SERVICES.GetVariable()`.
-    pub fn get_variable(&self, guid: &EfiGuid, name: &str, out: &mut [u8]) -> Result<usize> {
-        let mut size = out.len();
-
-        let mut name_utf16: Vec<u16> = name.encode_utf16().collect();
-        name_utf16.push(0); // null-terminator
-
-        // SAFETY:
-        // * `&mut size` and `&mut out` are input/output params only and will not be retained
-        // * `&mut size` and `&mut out` are valid pointers and outlive the call
-        unsafe {
-            efi_call!(
-                @bufsize size,
-                self.runtime_services.get_variable,
-                name_utf16.as_ptr(),
-                guid,
-                null_mut(),
-                &mut size,
-                out.as_mut_ptr() as *mut core::ffi::c_void
-            )?;
-        }
-        Ok(size)
-    }
-
-    /// Wrapper of `EFI_RUNTIME_SERVICES.SetVariable()`.
-    pub fn set_variable(&self, guid: &EfiGuid, name: &str, data: &[u8]) -> Result<()> {
-        let mut name_utf16: Vec<u16> = name.encode_utf16().collect();
-        name_utf16.push(0); // null-terminator
-
-        // SAFETY:
-        // * `data.as_mut_ptr()` and `name_utf16.as_ptr()` are valid pointers,
-        // * outlive the call, and are not retained.
-        unsafe {
-            efi_call!(
-                self.runtime_services.set_variable,
-                name_utf16.as_ptr(),
-                guid,
-                0,
-                data.len(),
-                data.as_ptr() as *const core::ffi::c_void
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_RUNTIME_SERVICES.reset_system`.
-    pub fn reset_system(
-        &self,
-        reset_type: EFI_RESET_TYPE,
-        reset_status: EFI_STATUS,
-        reset_data: Option<&mut [u8]>,
-    ) -> ! {
-        let (reset_data_len, reset_data_ptr) = match reset_data {
-            Some(v) => (v.len(), v.as_mut_ptr() as _),
-            _ => (0, null_mut()),
-        };
-        // SAFETY:
-        // * `reset_data_ptr` is either a valid pointer or NULL which by UEFI spec is allowed.
-        // * The call reboots the device and thus is not expected to return.
-        unsafe {
-            self.runtime_services.reset_system.unwrap()(
-                reset_type,
-                reset_status,
-                reset_data_len,
-                reset_data_ptr,
-            );
-        }
-
-        unreachable!();
-    }
-
-    /// Performs a cold reset without status code or data.
-    pub fn cold_reset(&self) -> ! {
-        self.reset_system(EFI_RESET_TYPE_EFI_RESET_COLD, EFI_STATUS_SUCCESS, None)
-    }
-}
-
-/// EFI Event type to pass to BootServicess::create_event.
-/// See UEFI documentation for details.
-#[allow(missing_docs)]
-#[repr(u32)]
-pub enum EventType {
-    Timer = EFI_EVENT_TYPE_TIMER,
-    RunTime = EFI_EVENT_TYPE_RUNTIME,
-    NotifyWait = EFI_EVENT_TYPE_NOTIFY_WAIT,
-    NotifySignal = EFI_EVENT_TYPE_NOTIFY_SIGNAL,
-    SignalExitBootServices = EFI_EVENT_TYPE_SIGNAL_EXIT_BOOT_SERVICES,
-    SignalVirtualAddressChange = EFI_EVENT_TYPE_SIGNAL_VIRTUAL_ADDRESS_CHANGE,
-
-    // Valid combinations:
-    TimerNotifySignal = EFI_EVENT_TYPE_TIMER | EFI_EVENT_TYPE_NOTIFY_SIGNAL,
-}
-
-/// EFI task level priority setting for event notify function.
-/// See UEFI documentation for details.
-#[allow(missing_docs)]
-#[repr(usize)]
-#[derive(Copy, Clone)]
-pub enum Tpl {
-    Application = 4,
-    Callback = 8,
-    Notify = 16,
-    HighLevel = 31,
-}
-
-/// Event notification callback function.
-///
-/// The callback function itself takes the [EfiEvent] as an argument and has no return value.
-/// This type is a mutable borrow of a closure to ensure that it will outlive the [EfiEvent] and
-/// that the callback has exclusive access to it.
-///
-/// Additionally, the function must be [Sync] because it will be run concurrently to the main app
-/// code at a higher interrupt level. One consequence of this is that we cannot capture an
-/// [EfiEntry] or any related object in the closure, as they are not [Sync]. This is intentional;
-/// in general UEFI APIs are not reentrant except in very limited ways, and we could trigger
-/// undefined behavior if we try to call into UEFI while the main application code is also in the
-/// middle of a UEFI call. Instead, the notification should signal the main app code to make any
-/// necessary UEFI calls once it regains control.
-pub type EventNotifyCallback<'a> = &'a mut (dyn FnMut(EfiEvent) + Sync);
-
-/// `EventNotify` contains the task level priority setting and a mutable reference to a
-/// closure for the callback. It is passed as the context pointer to low level EFI event
-/// notification function entry (`unsafe extern "C" fn efi_event_cb(...)`).
-pub struct EventNotify<'e> {
-    tpl: Tpl,
-    cb: EventNotifyCallback<'e>,
-}
-
-impl<'e> EventNotify<'e> {
-    /// Creates a new [EventNotify].
-    pub fn new(tpl: Tpl, cb: EventNotifyCallback<'e>) -> Self {
-        Self { tpl, cb }
-    }
-}
-
-/// `Event` wraps the raw `EfiEvent` handle and internally enforces a borrow of the registered
-/// callback for the given life time `'n`. The event is automatically closed when going out of
-/// scope.
-pub struct Event<'a, 'n> {
-    // If `efi_entry` is None, it represents an unowned Event and won't get closed on drop.
-    efi_entry: Option<&'a EfiEntry>,
-    efi_event: EfiEvent,
-    // The actual callback has been passed into UEFI via raw pointer in [create_event], so we
-    // use [PhantomData] to ensure the callback will outlive the event.
-    cb: PhantomData<Option<EventNotifyCallback<'n>>>,
-}
-
-impl<'a, 'n> Event<'a, 'n> {
-    /// Creates an instance of owned `Event`. The `Event` is closed when going out of scope.
-    fn new(
-        efi_entry: &'a EfiEntry,
-        efi_event: EfiEvent,
-        _cb: Option<EventNotifyCallback<'n>>,
-    ) -> Self {
-        Self { efi_entry: Some(efi_entry), efi_event, cb: PhantomData }
-    }
-
-    /// Creates an  unowned `Event`. The `Event` is not closed when going out of scope.
-    // TODO allow unused?
-    #[allow(dead_code)]
-    fn new_unowned(efi_event: EfiEvent) -> Self {
-        Self { efi_entry: None, efi_event: efi_event, cb: PhantomData }
-    }
-}
-
-impl Drop for Event<'_, '_> {
-    fn drop(&mut self) {
-        if let Some(efi_entry) = self.efi_entry {
-            efi_entry.system_table().boot_services().close_event(self).unwrap();
-        }
-    }
-}
-
-/// Event notify function entry for EFI events.
-///
-/// Safety:
-///
-///   `ctx` must point to a `EventNotify` type object.
-///   `ctx` must live longer than the event.
-///   There should be no other references to `ctx`.
-unsafe extern "C" fn efi_event_cb(event: EfiEvent, ctx: *mut core::ffi::c_void) {
-    // SAFETY: By safety requirement of this function, ctx points to a valid `EventNotify` object,
-    // outlives the event/the function call, and there is no other borrows.
-    let event_cb = unsafe { (ctx as *mut EventNotify).as_mut() }.unwrap();
-    (event_cb.cb)(event);
-}
-
-/// A type for accessing memory map.
-#[derive(Debug)]
-pub struct EfiMemoryMap<'a> {
-    buffer: &'a mut [u8],
-    map_key: usize,
-    descriptor_size: usize,
-    descriptor_version: u32,
-}
-
-/// Iterator for traversing `EfiMemoryDescriptor` items in `EfiMemoryMap::buffer`.
-pub struct EfiMemoryMapIter<'a: 'b, 'b> {
-    memory_map: &'b EfiMemoryMap<'a>,
-    offset: usize,
-}
-
-impl<'a, 'b> Iterator for EfiMemoryMapIter<'a, 'b> {
-    type Item = &'b EfiMemoryDescriptor;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.offset >= self.memory_map.buffer.len() {
-            return None;
-        }
-        let bytes = &self.memory_map.buffer[self.offset..][..self.memory_map.descriptor_size];
-        self.offset += self.memory_map.descriptor_size;
-        Some(Ref::into_ref(Ref::<_, EfiMemoryDescriptor>::new_from_prefix(bytes).unwrap().0))
-    }
-}
-
-impl<'a> EfiMemoryMap<'a> {
-    /// Creates a new instance with the given parameters obtained from `get_memory_map()`.
-    fn new(
-        buffer: &'a mut [u8],
-        map_key: usize,
-        descriptor_size: usize,
-        descriptor_version: u32,
-    ) -> Self {
-        Self { buffer, map_key, descriptor_size, descriptor_version }
-    }
-
-    /// Returns the buffer.
-    pub fn buffer(&self) -> &[u8] {
-        self.buffer
-    }
-
-    /// Returns the value of `map_key`.
-    pub fn map_key(&self) -> usize {
-        self.map_key
-    }
-
-    /// Returns the value of `descriptor_version`.
-    pub fn descriptor_version(&self) -> u32 {
-        self.descriptor_version
-    }
-
-    /// Returns the number of descriptors.
-    pub fn len(&self) -> usize {
-        self.buffer.len() / self.descriptor_size
-    }
-}
-
-impl<'a: 'b, 'b> IntoIterator for &'b EfiMemoryMap<'a> {
-    type Item = &'b EfiMemoryDescriptor;
-    type IntoIter = EfiMemoryMapIter<'a, 'b>;
-
-    fn into_iter(self) -> Self::IntoIter {
-        EfiMemoryMapIter { memory_map: self, offset: 0 }
-    }
-}
-
-/// A type for accessing Memory attributes table
-pub struct EfiMemoryAttributesTable<'a> {
-    /// EfiMemoryAttributesTable header
-    pub header: &'a EfiMemoryAttributesTableHeader,
-    tail: &'a [u8],
-}
-
-/// Iterator for traversing `EfiMemoryAttributesTable` descriptors.
-pub struct EfiMemoryAttributesTableIter<'a> {
-    descriptor_size: usize,
-    tail: &'a [u8],
-}
-
-impl<'a> Iterator for EfiMemoryAttributesTableIter<'a> {
-    type Item = &'a EfiMemoryDescriptor;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        // Descriptor size can be greater than `EfiMemoryDescriptor`, so we potentially slice off
-        // pieces greater than struct size. Thus can't just convert buffer to slice of
-        // corresponding type.
-        if let Some((desc_bytes, tail_new)) = self.tail.split_at_checked(self.descriptor_size) {
-            let desc = Ref::into_ref(
-                Ref::<_, EfiMemoryDescriptor>::new_from_prefix(desc_bytes).unwrap().0,
-            );
-            self.tail = tail_new;
-            Some(desc)
-        } else {
-            None
-        }
-    }
-}
-
-impl<'a> EfiMemoryAttributesTable<'a> {
-    /// Creates a new instance with the given parameters obtained from `get_memory_map()`.
-    ///
-    /// # Returns
-    /// Ok(EfiMemoryAttributesTable) - on success
-    /// Err(Error::NotFound) - if table type is incorrect
-    /// Err(e) - if error `e` occurred parsing table buffer
-    //
-    // SAFETY:
-    // `configuration_table` must be valid EFI Configuration Table object.
-    pub unsafe fn new(
-        configuration_table: EfiConfigurationTable,
-    ) -> Result<EfiMemoryAttributesTable<'a>> {
-        if configuration_table.vendor_guid != EFI_MEMORY_ATTRIBUTES_GUID {
-            return Err(Error::NotFound);
-        }
-        let buf = configuration_table.vendor_table;
-
-        // SAFETY: Buffer provided by EFI configuration table.
-        let header = unsafe {
-            let header_bytes =
-                from_raw_parts(buf as *const u8, size_of::<EfiMemoryAttributesTableHeader>());
-            EfiMemoryAttributesTableHeader::ref_from(header_bytes).ok_or(Error::InvalidInput)?
-        };
-
-        // Note: `descriptor_size` may be bigger than `EfiMemoryDescriptor`.
-        let descriptor_size: usize = header.descriptor_size.try_into().unwrap();
-        let descriptors_count: usize = header.number_of_entries.try_into().unwrap();
-
-        // SAFETY: Buffer provided by EFI configuration table.
-        let tail = unsafe {
-            from_raw_parts(
-                (buf as *const u8).add(core::mem::size_of_val(header)),
-                descriptors_count * descriptor_size,
-            )
-        };
-
-        Ok(Self { header, tail })
-    }
-}
-
-impl<'a> IntoIterator for &EfiMemoryAttributesTable<'a> {
-    type Item = &'a EfiMemoryDescriptor;
-    type IntoIter = EfiMemoryAttributesTableIter<'a>;
-
-    fn into_iter(self) -> Self::IntoIter {
-        let descriptor_size = usize::try_from(self.header.descriptor_size).unwrap();
-        let tail = &self.tail[..];
-        EfiMemoryAttributesTableIter { descriptor_size, tail }
-    }
-}
-
-/// A type representing a UEFI handle to a UEFI device.
-#[derive(Debug, Copy, Clone, PartialEq)]
-pub struct DeviceHandle(EfiHandle);
-
-impl DeviceHandle {
-    /// Public constructor
-    pub fn new(handle: EfiHandle) -> Self {
-        Self(handle)
-    }
-}
-
-/// `LocatedHandles` holds the array of handles return by
-/// `BootServices::locate_handle_buffer_by_protocol()`.
-pub struct LocatedHandles<'a> {
-    handles: &'a [DeviceHandle],
-    efi_entry: &'a EfiEntry,
-}
-
-impl<'a> LocatedHandles<'a> {
-    pub(crate) fn new(handles: *mut EfiHandle, len: usize, efi_entry: &'a EfiEntry) -> Self {
-        // Implementation is not suppose to call this with a NULL pointer.
-        debug_assert!(!handles.is_null());
-        Self {
-            // SAFETY: Given correct UEFI firmware, non-null pointer points to valid memory.
-            // The memory is owned by the objects.
-            handles: unsafe { from_raw_parts(handles as *mut DeviceHandle, len) },
-            efi_entry: efi_entry,
-        }
-    }
-    /// Get the list of handles as a slice.
-    pub fn handles(&self) -> &[DeviceHandle] {
-        self.handles
-    }
-}
-
-impl Drop for LocatedHandles<'_> {
-    fn drop(&mut self) {
-        self.efi_entry
-            .system_table()
-            .boot_services()
-            .free_pool(self.handles.as_ptr() as *mut _)
-            .unwrap();
-    }
-}
-
-/// Helper macro for printing message via `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL` in
-/// `EFI_SYSTEM_TABLE.ConOut`.
-#[macro_export]
-macro_rules! efi_print {
-    ( $efi_entry:expr, $( $x:expr ),* $(,)? ) => {
-            write!($efi_entry.system_table().con_out().unwrap(), $($x,)*).unwrap()
-    };
-}
-
-/// Similar to [efi_print!], but automatically adds the UEFI newline sequence (`\r\n`).
-#[macro_export]
-macro_rules! efi_println {
-    ( $efi_entry:expr, $( $x:expr ),* $(,)? ) => {
-        {
-            efi_print!($efi_entry, $($x,)*);
-            efi_print!($efi_entry, "\r\n");
-        }
-    };
-}
-
-/// Resets system. Hangs if not supported.
-#[cfg(not(test))]
-pub fn reset() -> ! {
-    efi_try_print!("Resetting...\r\n");
-    match allocation::internal_efi_entry_and_rt().1 {
-        Some(rt) => rt.cold_reset(),
-        _ => efi_try_print!("Runtime services not supported. Hangs...\r\n"),
-    }
-    loop {}
-}
-
-/// Provides a builtin panic handler.
-/// In the long term, to improve flexibility, consider allowing application to install a custom
-/// handler into `EfiEntry` to be called here.
-/// Don't set this as the panic handler so that other crates' tests can depend on libefi.
-#[cfg(not(test))]
-pub fn panic(panic: &PanicInfo) -> ! {
-    efi_try_print!("Panics! {}\r\n", panic);
-    reset();
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::protocol::block_io::BlockIoProtocol;
-    use efi_types::{
-        EfiBlockIoProtocol, EfiEventNotify, EfiLocateHandleSearchType, EfiStatus, EfiTpl,
-        EFI_MEMORY_TYPE_LOADER_CODE, EFI_MEMORY_TYPE_LOADER_DATA, EFI_STATUS_NOT_FOUND,
-        EFI_STATUS_NOT_READY, EFI_STATUS_SUCCESS, EFI_STATUS_UNSUPPORTED,
-        EFI_TIMER_DELAY_TIMER_PERIODIC,
-    };
-    use std::{cell::RefCell, collections::VecDeque, mem::size_of, slice::from_raw_parts_mut};
-    use utils::RecurringTimer;
-    use zerocopy::IntoBytes;
-
-    /// Helper function to generate a Protocol from an interface type.
-    pub fn generate_protocol<'a, P: ProtocolInfo>(
-        efi_entry: &'a EfiEntry,
-        proto: &'a mut P::InterfaceType,
-    ) -> Protocol<'a, P> {
-        // SAFETY: proto is a valid pointer and lasts at least as long as efi_entry.
-        unsafe { Protocol::<'a, P>::new(DeviceHandle::new(null_mut()), proto, efi_entry) }
-    }
-
-    /// A structure to store the traces of arguments/outputs for EFI methods.
-    #[derive(Default)]
-    pub struct EfiCallTraces {
-        pub free_pool_trace: FreePoolTrace,
-        pub open_protocol_trace: OpenProtocolTrace,
-        pub close_protocol_trace: CloseProtocolTrace,
-        pub locate_handle_buffer_trace: LocateHandleBufferTrace,
-        pub get_memory_map_trace: GetMemoryMapTrace,
-        pub exit_boot_services_trace: ExitBootServicespTrace,
-        pub create_event_trace: CreateEventTrace,
-        pub close_event_trace: CloseEventTrace,
-        pub check_event_trace: CheckEventTrace,
-        pub set_timer_trace: SetTimerTrace,
-    }
-
-    // Declares a global instance of EfiCallTraces.
-    // Need to use thread local storage because rust unit test is multi-threaded.
-    thread_local! {
-        static EFI_CALL_TRACES: RefCell<EfiCallTraces> = RefCell::new(Default::default());
-    }
-
-    /// Exports for unit-test in submodules.
-    pub fn efi_call_traces() -> &'static std::thread::LocalKey<RefCell<EfiCallTraces>> {
-        &EFI_CALL_TRACES
-    }
-
-    /// EFI_BOOT_SERVICE.FreePool() test implementation.
-    #[derive(Default)]
-    pub struct FreePoolTrace {
-        // Capture `buf`
-        pub inputs: VecDeque<*mut core::ffi::c_void>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.FreePool` C API in test environment.
-    extern "C" fn free_pool(buf: *mut core::ffi::c_void) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            traces.borrow_mut().free_pool_trace.inputs.push_back(buf);
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.OpenProtocol() test implementation.
-    #[derive(Default)]
-    pub struct OpenProtocolTrace {
-        // Capture `handle`, `protocol_guid`, `agent_handle`.
-        pub inputs: VecDeque<(DeviceHandle, EfiGuid, EfiHandle)>,
-        // Return `intf`, EfiStatus.
-        pub outputs: VecDeque<(EfiHandle, EfiStatus)>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.OpenProtocol` C API in test environment.
-    ///
-    /// # Safety
-    ///
-    ///   Caller should guarantee that `intf` and `protocol_guid` point to valid memory locations.
-    unsafe extern "C" fn open_protocol(
-        handle: EfiHandle,
-        protocol_guid: *const EfiGuid,
-        intf: *mut *mut core::ffi::c_void,
-        agent_handle: EfiHandle,
-        _: EfiHandle,
-        attr: u32,
-    ) -> EfiStatus {
-        assert_eq!(attr, EFI_OPEN_PROTOCOL_ATTRIBUTE_BY_HANDLE_PROTOCOL);
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().open_protocol_trace;
-            trace.inputs.push_back((
-                DeviceHandle(handle),
-                // SAFETY: function safety docs require valid `protocol_guid`.
-                unsafe { *protocol_guid },
-                agent_handle,
-            ));
-
-            let (intf_handle, status) = trace.outputs.pop_front().unwrap();
-            // SAFETY: function safety docs require valid `intf`.
-            unsafe { *intf = intf_handle };
-
-            status
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.CloseProtocol() test implementation.
-    #[derive(Default)]
-    pub struct CloseProtocolTrace {
-        // Capture `handle`, `protocol_guid`, `agent_handle`
-        pub inputs: VecDeque<(DeviceHandle, EfiGuid, EfiHandle)>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.CloseProtocol` C API in test environment.
-    ///
-    /// # Safety
-    ///
-    ///   Caller should guarantee that `protocol_guid` points to valid memory location.
-    unsafe extern "C" fn close_protocol(
-        handle: EfiHandle,
-        protocol_guid: *const EfiGuid,
-        agent_handle: EfiHandle,
-        _: EfiHandle,
-    ) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            traces.borrow_mut().close_protocol_trace.inputs.push_back((
-                DeviceHandle(handle),
-                // SAFETY: function safety docs require valid `protocol_guid`.
-                unsafe { *protocol_guid },
-                agent_handle,
-            ));
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.LocateHandleBuffer.
-    #[derive(Default)]
-    pub struct LocateHandleBufferTrace {
-        // Capture `protocol`.
-        pub inputs: VecDeque<EfiGuid>,
-        // For returning in `num_handles` and `buf`.
-        pub outputs: VecDeque<(usize, *mut DeviceHandle)>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.LocateHandleBuffer` C API in test environment.
-    ///
-    /// # Safety
-    /// Caller should guarantee that `protocol`, `num_handles`, and `buf` point to valid memory
-    /// locations.
-    unsafe extern "C" fn locate_handle_buffer(
-        search_type: EfiLocateHandleSearchType,
-        protocol: *const EfiGuid,
-        search_key: *mut core::ffi::c_void,
-        num_handles: *mut usize,
-        buf: *mut *mut EfiHandle,
-    ) -> EfiStatus {
-        assert_eq!(search_type, EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL);
-        assert_eq!(search_key, null_mut());
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().locate_handle_buffer_trace;
-            // SAFETY: function safety docs require valid `protocol`.
-            unsafe { trace.inputs.push_back(*protocol) };
-
-            let (num, handles) = trace.outputs.pop_front().unwrap();
-            // SAFETY: function safety docs require valid `num_handles`.
-            unsafe { *num_handles = num as usize };
-            // SAFETY: function safety docs require valid `buf`.
-            unsafe { *buf = handles as *mut EfiHandle };
-
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.GetMemoryMap.
-    #[derive(Default)]
-    pub struct GetMemoryMapTrace {
-        // Capture `memory_map_size` and `memory_map` argument.
-        pub inputs: VecDeque<(usize, *mut EfiMemoryDescriptor)>,
-        // Output value `map_key`, `memory_map_size`.
-        pub outputs: VecDeque<(usize, usize)>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.GetMemoryMap` C API in test environment.
-    ///
-    /// # Safety
-    ///
-    ///   Caller should guarantee that `memory_map_size`, `map_key` and `desc_size` point to valid
-    ///   memory locations.
-    unsafe extern "C" fn get_memory_map(
-        memory_map_size: *mut usize,
-        memory_map: *mut EfiMemoryDescriptor,
-        map_key: *mut usize,
-        desc_size: *mut usize,
-        _: *mut u32,
-    ) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().get_memory_map_trace;
-            trace.inputs.push_back((unsafe { *memory_map_size }, memory_map));
-            // SAFETY: function safety docs require valid `memory_map_size`and `map_key`.
-            unsafe { (*map_key, *memory_map_size) = trace.outputs.pop_front().unwrap() };
-            // SAFETY: function safety docs require valid `desc_size`.
-            unsafe { *desc_size = size_of::<EfiMemoryDescriptor>() };
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.ExitBootServices.
-    #[derive(Default)]
-    pub struct ExitBootServicespTrace {
-        // Capture `image_handle`, `map_key`
-        pub inputs: VecDeque<(EfiHandle, usize)>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.ExitBootServices` C API in test environment.
-    extern "C" fn exit_boot_services(image_handle: EfiHandle, map_key: usize) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().exit_boot_services_trace;
-            trace.inputs.push_back((image_handle, map_key));
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.CreateEvent.
-    #[derive(Default)]
-    pub struct CreateEventTrace {
-        // Capture `type_`, `notify_tpl`, `notify_fn`, `notify_ctx`
-        pub inputs: VecDeque<(u32, EfiTpl, EfiEventNotify, *mut core::ffi::c_void)>,
-        // Output a EfiEvent.
-        pub outputs: VecDeque<EfiEvent>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.CreateEvent` C API in test environment.
-    ///
-    /// # Safety
-    ///
-    ///   Caller should guarantee that `event` points to valid memory location.
-    unsafe extern "C" fn create_event(
-        type_: u32,
-        notify_tpl: EfiTpl,
-        notify_fn: EfiEventNotify,
-        notify_ctx: *mut core::ffi::c_void,
-        event: *mut EfiEvent,
-    ) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().create_event_trace;
-            trace.inputs.push_back((type_, notify_tpl, notify_fn, notify_ctx));
-            // SAFETY: function safety docs require valid `event`.
-            unsafe { *event = trace.outputs.pop_front().unwrap() };
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.CloseEvent.
-    #[derive(Default)]
-    pub struct CloseEventTrace {
-        // Capture `event`
-        pub inputs: VecDeque<EfiEvent>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.CloseEvent` C API in test environment.
-    extern "C" fn close_event(event: EfiEvent) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().close_event_trace;
-            trace.inputs.push_back(event);
-            EFI_STATUS_SUCCESS
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.CheckEvent.
-    #[derive(Default)]
-    pub struct CheckEventTrace {
-        // EfiStatus for return.
-        pub outputs: VecDeque<EfiStatus>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.CheckEvent` C API in test environment.
-    extern "C" fn check_event(_: EfiEvent) -> EfiStatus {
-        EFI_CALL_TRACES.with(|traces| {
-            let trace = &mut traces.borrow_mut().check_event_trace;
-            trace.outputs.pop_front().unwrap()
-        })
-    }
-
-    /// EFI_BOOT_SERVICE.SetTimer.
-    #[derive(Default)]
-    pub struct SetTimerTrace {
-        // Capture call params
-        pub inputs: VecDeque<(EfiEvent, EfiTimerDelay, u64)>,
-        // EfiStatus for return
-        pub outputs: VecDeque<EfiStatus>,
-    }
-
-    /// Mock of the `EFI_BOOT_SERVICE.SetTimer` C API in test environment.
-    extern "C" fn set_timer(
-        event: EfiEvent,
-        delay_type: EfiTimerDelay,
-        duration: u64,
-    ) -> EfiStatus {
-        EFI_CALL_TRACES.with(|trace| {
-            let trace = &mut trace.borrow_mut().set_timer_trace;
-            trace.inputs.push_back((event, delay_type, duration));
-            trace.outputs.pop_front().unwrap()
-        })
-    }
-
-    /// A test wrapper that sets up a system table, image handle and runs a test function like it
-    /// is an EFI application.
-    /// TODO(300168989): Investigate using procedural macro to generate test that auto calls this.
-    pub fn run_test(func: impl FnOnce(EfiHandle, *mut EfiSystemTable) -> ()) {
-        // Reset all traces
-        EFI_CALL_TRACES.with(|trace| {
-            *trace.borrow_mut() = Default::default();
-        });
-
-        let mut systab: EfiSystemTable = Default::default();
-        let mut boot_services: EfiBootService = Default::default();
-
-        boot_services.free_pool = Some(free_pool);
-        boot_services.open_protocol = Some(open_protocol);
-        boot_services.close_protocol = Some(close_protocol);
-        boot_services.locate_handle_buffer = Some(locate_handle_buffer);
-        boot_services.get_memory_map = Some(get_memory_map);
-        boot_services.exit_boot_services = Some(exit_boot_services);
-        boot_services.create_event = Some(create_event);
-        boot_services.close_event = Some(close_event);
-        boot_services.check_event = Some(check_event);
-        boot_services.set_timer = Some(set_timer);
-        systab.boot_services = &mut boot_services as *mut _;
-        let image_handle: usize = 1234; // Don't care.
-
-        func(image_handle as EfiHandle, &mut systab as *mut _);
-
-        // Reset all traces
-        EFI_CALL_TRACES.with(|trace| {
-            *trace.borrow_mut() = Default::default();
-        });
-    }
-
-    /// Constructs a mock protocol `P` and run the given callback on it.
-    ///
-    /// This is similar to `run_test()`, but also provides the construction of a single mock
-    /// protocol to reduce boilerplate for tests to check the interface between a C EFI protocol
-    /// struct and our Rust wrappers.
-    ///
-    /// # Arguments
-    /// * `c_interface`: the raw C struct interface implementing the desired protocol.
-    /// * `f`: the callback function to run, given the resulting protocol as an argument.
-    pub fn run_test_with_mock_protocol<P: ProtocolInfo>(
-        mut c_interface: P::InterfaceType,
-        f: impl FnOnce(&Protocol<P>),
-    ) {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            // SAFETY:
-            // * `c_interface` is a valid C interface for proto `P`
-            // * `c_interface` outlives the created `protocol`
-            let protocol = unsafe {
-                Protocol::new(DeviceHandle::new(null_mut()), &mut c_interface, &efi_entry)
-            };
-            f(&protocol);
-        });
-    }
-
-    /// Get the pointer to an object as an EfiHandle type.
-    pub fn as_efi_handle<T>(val: &mut T) -> EfiHandle {
-        val as *mut T as *mut _
-    }
-
-    #[test]
-    fn test_open_close_protocol() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            // Set up open_protocol trace
-            let mut block_io: EfiBlockIoProtocol = Default::default();
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().open_protocol_trace.outputs =
-                    VecDeque::from([(as_efi_handle(&mut block_io), EFI_STATUS_SUCCESS)]);
-            });
-
-            let mut device_handle: usize = 0; // Don't care
-            {
-                // Open a protocol
-                let protocol = efi_entry
-                    .system_table()
-                    .boot_services()
-                    .open_protocol::<BlockIoProtocol>(DeviceHandle(as_efi_handle(
-                        &mut device_handle,
-                    )))
-                    .unwrap();
-
-                // Validate call args
-                EFI_CALL_TRACES.with(|trace| {
-                    assert_eq!(
-                        trace.borrow_mut().open_protocol_trace.inputs,
-                        [(
-                            DeviceHandle(as_efi_handle(&mut device_handle)),
-                            BlockIoProtocol::GUID,
-                            image_handle
-                        ),]
-                    );
-
-                    // close_protocol not called yet.
-                    assert_eq!(trace.borrow_mut().close_protocol_trace.inputs, []);
-                });
-
-                // The protocol gets the correct EfiBlockIoProtocol structure we pass in.
-                assert_eq!(protocol.interface_ptr(), &mut block_io as *mut _);
-            }
-
-            // Close protocol is called as `protocol` goes out of scope.
-            EFI_CALL_TRACES
-                .with(|trace| assert_eq!(trace.borrow_mut().close_protocol_trace.inputs, []));
-        })
-    }
-
-    #[test]
-    fn test_null_efi_method() {
-        // Test that wrapper call fails if efi method is None.
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            // Set up open_protocol trace
-            let mut block_io: EfiBlockIoProtocol = Default::default();
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().open_protocol_trace.outputs =
-                    VecDeque::from([(as_efi_handle(&mut block_io), EFI_STATUS_SUCCESS)]);
-            });
-
-            // Set the method to None.
-            // SAFETY:
-            // run_test() guarantees `boot_services` pointer points to valid object.
-            unsafe { (*(*systab_ptr).boot_services).open_protocol = None };
-
-            let mut device_handle: usize = 0; // Don't care
-            assert!(efi_entry
-                .system_table()
-                .boot_services()
-                .open_protocol::<BlockIoProtocol>(DeviceHandle(as_efi_handle(&mut device_handle)))
-                .is_err());
-        })
-    }
-
-    #[test]
-    fn test_error_efi_method() {
-        // Test that wrapper call fails if efi method returns error.
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            // Set up open_protocol trace.
-            let mut block_io: EfiBlockIoProtocol = Default::default();
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().open_protocol_trace.outputs =
-                    VecDeque::from([(as_efi_handle(&mut block_io), EFI_STATUS_NOT_FOUND)]);
-            });
-
-            let mut device_handle: usize = 0; // Don't care
-            assert!(efi_entry
-                .system_table()
-                .boot_services()
-                .open_protocol::<BlockIoProtocol>(DeviceHandle(as_efi_handle(&mut device_handle)))
-                .is_err());
-        })
-    }
-
-    #[test]
-    fn test_locate_handle_buffer_by_protocol() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            // Set up locate_handle_buffer_trace trace.
-            let mut located_handles: [DeviceHandle; 3] =
-                [DeviceHandle(1 as *mut _), DeviceHandle(2 as *mut _), DeviceHandle(3 as *mut _)];
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().locate_handle_buffer_trace.outputs =
-                    VecDeque::from([(located_handles.len(), located_handles.as_mut_ptr())]);
-            });
-
-            {
-                let handles = efi_entry
-                    .system_table()
-                    .boot_services()
-                    .locate_handle_buffer_by_protocol::<BlockIoProtocol>()
-                    .unwrap();
-
-                // Returned handles are expected.
-                assert_eq!(handles.handles().to_vec(), located_handles);
-            }
-
-            EFI_CALL_TRACES.with(|traces| {
-                let traces = traces.borrow_mut();
-                // Arguments are passed correctly.
-                assert_eq!(traces.locate_handle_buffer_trace.inputs, [BlockIoProtocol::GUID]);
-                // Free pool is called with the correct address.
-                assert_eq!(traces.free_pool_trace.inputs, [located_handles.as_mut_ptr() as *mut _]);
-            });
-        })
-    }
-
-    #[test]
-    fn test_find_first_and_open() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            // Set up locate_handle_buffer_trace trace.
-            let mut located_handles: [DeviceHandle; 3] =
-                [DeviceHandle(1 as *mut _), DeviceHandle(2 as *mut _), DeviceHandle(3 as *mut _)];
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().locate_handle_buffer_trace.outputs =
-                    VecDeque::from([(located_handles.len(), located_handles.as_mut_ptr())]);
-            });
-
-            // Set up open_protocol trace.
-            let mut block_io: EfiBlockIoProtocol = Default::default();
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().open_protocol_trace.outputs =
-                    VecDeque::from([(as_efi_handle(&mut block_io), EFI_STATUS_SUCCESS)]);
-            });
-
-            efi_entry
-                .system_table()
-                .boot_services()
-                .find_first_and_open::<BlockIoProtocol>()
-                .unwrap();
-
-            // Check open_protocol is called on the first handle.
-            EFI_CALL_TRACES.with(|traces| {
-                assert_eq!(
-                    traces.borrow_mut().open_protocol_trace.inputs,
-                    [(DeviceHandle(1 as *mut _), BlockIoProtocol::GUID, image_handle),]
-                );
-            });
-        })
-    }
-
-    #[test]
-    fn test_exit_boot_services() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            // Create a buffer large enough to hold two EfiMemoryDescriptor.
-            let mut descriptors: [EfiMemoryDescriptor; 2] = [
-                EfiMemoryDescriptor {
-                    memory_type: EFI_MEMORY_TYPE_LOADER_DATA,
-                    padding: 0,
-                    physical_start: 0,
-                    virtual_start: 0,
-                    number_of_pages: 0,
-                    attributes: 0,
-                },
-                EfiMemoryDescriptor {
-                    memory_type: EFI_MEMORY_TYPE_LOADER_CODE,
-                    padding: 0,
-                    physical_start: 0,
-                    virtual_start: 0,
-                    number_of_pages: 0,
-                    attributes: 0,
-                },
-            ];
-            let map_key: usize = 12345;
-            // Set up get_memory_map trace.
-            EFI_CALL_TRACES.with(|traces| {
-                // Output only the first EfiMemoryDescriptor.
-                traces.borrow_mut().get_memory_map_trace.outputs =
-                    VecDeque::from([(map_key, 1 * size_of::<EfiMemoryDescriptor>())]);
-            });
-
-            // SAFETY: Buffer is guaranteed valid.
-            let buffer = unsafe {
-                from_raw_parts_mut(
-                    descriptors.as_mut_ptr() as *mut u8,
-                    descriptors.len() * size_of::<EfiMemoryDescriptor>(),
-                )
-            };
-
-            // Test `exit_boot_services`
-            let desc = super::exit_boot_services(efi_entry, buffer).unwrap();
-
-            // Validate that UEFI APIs are correctly called.
-            EFI_CALL_TRACES.with(|traces| {
-                assert_eq!(
-                    traces.borrow_mut().get_memory_map_trace.inputs,
-                    [(
-                        descriptors.len() * size_of::<EfiMemoryDescriptor>(),
-                        descriptors.as_mut_ptr()
-                    )]
-                );
-
-                assert_eq!(
-                    traces.borrow_mut().exit_boot_services_trace.inputs,
-                    [(image_handle, map_key)],
-                );
-            });
-
-            // Validate that the returned `EfiMemoryMap` contains only 1 EfiMemoryDescriptor.
-            assert_eq!(desc.into_iter().map(|v| *v).collect::<Vec<_>>(), descriptors[..1].to_vec());
-            // Validate that the returned `EfiMemoryMap` has the correct map_key.
-            assert_eq!(desc.map_key(), map_key);
-        })
-    }
-
-    #[test]
-    fn test_exit_boot_services_unaligned_buffer() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            // Create a buffer for 2 EfiMemoryDescriptor.
-            let descriptors: [EfiMemoryDescriptor; 2] = [
-                EfiMemoryDescriptor {
-                    memory_type: EFI_MEMORY_TYPE_LOADER_DATA,
-                    padding: 0,
-                    physical_start: 0,
-                    virtual_start: 0,
-                    number_of_pages: 0,
-                    attributes: 0,
-                },
-                EfiMemoryDescriptor {
-                    memory_type: EFI_MEMORY_TYPE_LOADER_CODE,
-                    padding: 0,
-                    physical_start: 0,
-                    virtual_start: 0,
-                    number_of_pages: 0,
-                    attributes: 0,
-                },
-            ];
-
-            let map_key: usize = 12345;
-            // Set up get_memory_map trace.
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().get_memory_map_trace.outputs =
-                    VecDeque::from([(map_key, 2 * size_of::<EfiMemoryDescriptor>())]);
-            });
-
-            // Construct the destination buffer.
-            let mut buffer = [0u8; 256];
-            let alignment = core::mem::align_of::<EfiMemoryDescriptor>();
-            let size = core::mem::size_of::<EfiMemoryDescriptor>();
-            let aligned = aligned_subslice(&mut buffer[..], alignment).unwrap();
-            // Offset by 1 element so that we can make an unaligned buffer starting somewhere in
-            // between.
-            let start = aligned.get_mut(size..).unwrap();
-            start[..size].clone_from_slice(descriptors[0].as_bytes());
-            start[size..][..size].clone_from_slice(descriptors[1].as_bytes());
-            // Pass an unaligned address.
-            let desc = super::exit_boot_services(efi_entry, &mut aligned[size - 1..]).unwrap();
-            // Validate that the returned `EfiMemoryMap` contains the correct EfiMemoryDescriptor.
-            assert_eq!(desc.into_iter().map(|v| *v).collect::<Vec<_>>(), descriptors[..2].to_vec());
-            // Validate that the returned `EfiMemoryMap` has the correct map_key.
-            assert_eq!(desc.map_key(), map_key);
-        });
-    }
-
-    #[test]
-    fn test_create_event_with_notify_fn() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let mut cb_impl = |_: EfiEvent| {};
-            let mut cb = EventNotify::new(Tpl::Callback, &mut cb_impl);
-            let event: EfiEvent = 1234usize as _;
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().create_event_trace.outputs.push_back(event);
-            });
-            {
-                // SAFETY: event notifications are always safe in unittests.
-                let _ = unsafe {
-                    efi_entry
-                        .system_table()
-                        .boot_services()
-                        .create_event_with_notification(EventType::Timer, &mut cb)
-                }
-                .unwrap();
-            }
-            let efi_cb: EfiEventNotify = Some(efi_event_cb);
-            EFI_CALL_TRACES.with(|traces| {
-                assert_eq!(
-                    traces.borrow_mut().create_event_trace.inputs,
-                    [(
-                        EventType::Timer as _,
-                        Tpl::Callback as _,
-                        efi_cb,
-                        &mut cb as *mut _ as *mut _
-                    )]
-                )
-            });
-            // Verify close_event is called.
-            EFI_CALL_TRACES
-                .with(|traces| assert_eq!(traces.borrow_mut().close_event_trace.inputs, [event]));
-        });
-    }
-
-    #[test]
-    fn test_create_event_wo_notify_fn() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let event: EfiEvent = 1234usize as _;
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().create_event_trace.outputs.push_back(event);
-            });
-            {
-                let _ = efi_entry
-                    .system_table()
-                    .boot_services()
-                    .create_event(EventType::Timer)
-                    .unwrap();
-            }
-            EFI_CALL_TRACES.with(|traces| {
-                assert_eq!(
-                    traces.borrow_mut().create_event_trace.inputs,
-                    [(EventType::Timer as _, 0, None, null_mut())]
-                )
-            });
-        });
-    }
-
-    #[test]
-    fn test_check_event() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let event: EfiEvent = 1234usize as _;
-            EFI_CALL_TRACES.with(|traces| {
-                traces.borrow_mut().create_event_trace.outputs.push_back(event);
-                traces.borrow_mut().check_event_trace.outputs.push_back(EFI_STATUS_SUCCESS);
-                traces.borrow_mut().check_event_trace.outputs.push_back(EFI_STATUS_NOT_READY);
-                traces.borrow_mut().check_event_trace.outputs.push_back(EFI_STATUS_UNSUPPORTED);
-            });
-            let res =
-                efi_entry.system_table().boot_services().create_event(EventType::Timer).unwrap();
-            assert_eq!(efi_entry.system_table().boot_services().check_event(&res), Ok(true));
-            assert_eq!(efi_entry.system_table().boot_services().check_event(&res), Ok(false));
-            assert!(efi_entry.system_table().boot_services().check_event(&res).is_err());
-        });
-    }
-
-    #[test]
-    fn test_check_recurring_timer() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let event: EfiEvent = 666usize as _;
-
-            EFI_CALL_TRACES.with(|traces| {
-                let mut t = traces.borrow_mut();
-                t.create_event_trace.outputs.push_back(event);
-                t.set_timer_trace.outputs.push_back(EFI_STATUS_SUCCESS);
-                t.check_event_trace.outputs.push_back(EFI_STATUS_SUCCESS);
-            });
-
-            let recurring_timer =
-                RecurringTimer::new(&efi_entry, Duration::from_nanos(2112)).unwrap();
-
-            EFI_CALL_TRACES.with(|traces| {
-                let traces = traces.borrow();
-                assert_eq!(
-                    traces.create_event_trace.inputs,
-                    [(EventType::Timer as _, 0, None, null_mut())]
-                );
-                assert_eq!(
-                    traces.set_timer_trace.inputs,
-                    [(event, EFI_TIMER_DELAY_TIMER_PERIODIC, 21u64)]
-                );
-                // Make sure timer doesn't check itself automatically during construction.
-                assert_eq!(traces.check_event_trace.outputs, [EFI_STATUS_SUCCESS]);
-            });
-
-            assert_eq!(recurring_timer.check(), Ok(true));
-        });
-    }
-}
diff --git a/gbl/libefi/src/libc.rs b/gbl/libefi/src/libc.rs
deleted file mode 100644
index a75f64b..0000000
--- a/gbl/libefi/src/libc.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2025, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides platform-specific implementations required by GBL libc.
-//! See `libc/src/lib.rs` for more details.
-//!
-//! This implementation relies on the EFI framework, so can be only used where
-//! it's available.
-
-use crate::efi_try_print;
-use core::fmt::Write;
-use liberror::Result;
-
-/// EFI framework-based print implementation required by GBL `libc`.
-#[no_mangle]
-pub extern "Rust" fn gbl_print(s: &dyn core::fmt::Display) {
-    efi_try_print!("{}", s);
-}
diff --git a/gbl/libefi/src/local_session.rs b/gbl/libefi/src/local_session.rs
deleted file mode 100644
index b2d6638..0000000
--- a/gbl/libefi/src/local_session.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2025, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    protocol::{
-        gbl_efi_fastboot::{GblFastbootProtocol, LocalSessionContext},
-        Protocol,
-    },
-    utils::RecurringTimer,
-    EfiEntry,
-};
-use core::time::Duration;
-use fastboot::local_session::LocalSession;
-use liberror::Result;
-
-/// Represents a local, usually graphically driven fastboot/bootmenu session.
-pub struct LocalFastbootSession<'a> {
-    timer: RecurringTimer<'a>,
-    protocol: Protocol<'a, GblFastbootProtocol>,
-    context: LocalSessionContext,
-}
-
-impl<'a> LocalFastbootSession<'a> {
-    /// Starts a local fastboot session.
-    pub fn start(efi_entry: &'a EfiEntry, timeout: Duration) -> Result<Self> {
-        let timer = RecurringTimer::new(efi_entry, timeout)?;
-        let protocol = efi_entry
-            .system_table()
-            .boot_services()
-            .find_first_and_open::<GblFastbootProtocol>()?;
-        let context = protocol.start_local_session()?;
-        Ok(Self { timer, protocol, context })
-    }
-}
-
-impl LocalSession for LocalFastbootSession<'_> {
-    async fn update(&mut self, buf: &mut [u8]) -> Result<usize> {
-        self.timer.wait().await?;
-        let bufsize = self.protocol.update_local_session(&self.context, buf)?;
-        Ok(bufsize)
-    }
-}
-
-impl Drop for LocalFastbootSession<'_> {
-    fn drop(&mut self) {
-        let _ = self.protocol.close_local_session(&self.context);
-    }
-}
diff --git a/gbl/libefi/src/protocol.rs b/gbl/libefi/src/protocol.rs
deleted file mode 100644
index 8b212e2..0000000
--- a/gbl/libefi/src/protocol.rs
+++ /dev/null
@@ -1,207 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! EFI protocol wrappers to provide Rust-safe APIs for usage.
-
-use core::ptr::null_mut;
-
-use crate::{DeviceHandle, EfiEntry};
-use efi_types::*;
-
-pub mod block_io;
-pub mod block_io2;
-pub mod device_path;
-pub mod dt_fixup;
-pub mod gbl_efi_ab_slot;
-pub mod gbl_efi_avb;
-pub mod gbl_efi_fastboot;
-pub mod gbl_efi_fastboot_usb;
-pub mod gbl_efi_image_loading;
-pub mod gbl_efi_os_configuration;
-pub mod loaded_image;
-pub mod riscv;
-pub mod simple_network;
-pub mod simple_text_input;
-pub mod simple_text_output;
-
-use liberror::{Error, Result};
-
-/// ProtocolInfo provides GUID info and the EFI data structure type for a protocol.
-pub trait ProtocolInfo {
-    /// Data structure type of the interface.
-    type InterfaceType;
-    /// GUID of the protocol.
-    const GUID: EfiGuid;
-}
-
-/// A generic type for representing an EFI protcol.
-pub struct Protocol<'a, T: ProtocolInfo> {
-    // The handle to the device offering the protocol. It's needed for closing the protocol.
-    device: DeviceHandle,
-    // The interface protocol itself.
-    interface: *mut T::InterfaceType,
-    // The `EfiEntry` data
-    efi_entry: &'a EfiEntry,
-}
-
-/// A base implementation for Protocol<T>.
-/// Protocol<T> will have additional implementation based on type `T`.
-impl<'a, T: ProtocolInfo> Protocol<'a, T> {
-    /// Create a new instance with the given device handle, interface pointer and `EfiEntry` data.
-    ///
-    /// # Safety
-    ///
-    /// Caller needs to ensure that
-    ///
-    /// * `interface` points to a valid object of type T::InterfaceType.
-    ///
-    /// * Object pointed to by `interface` must live as long as the create `Protocol` or 'a.
-    pub(crate) unsafe fn new(
-        device: DeviceHandle,
-        interface: *mut T::InterfaceType,
-        efi_entry: &'a EfiEntry,
-    ) -> Self {
-        Self { device, interface, efi_entry }
-    }
-
-    /// Returns the EFI data structure for the protocol interface.
-    pub fn interface(&self) -> Result<&T::InterfaceType> {
-        // SAFETY: EFI protocol interface data structure.
-        unsafe { self.interface.as_ref() }.ok_or(Error::InvalidInput)
-    }
-
-    /// Returns the reference to EFI entry.
-    pub fn efi_entry(&self) -> &'a EfiEntry {
-        self.efi_entry
-    }
-
-    /// Returns the mutable pointer of the interface. Invisible from outside. Application should
-    /// not have any need to alter the content of interface data.
-    pub(crate) fn interface_ptr(&self) -> *mut T::InterfaceType {
-        self.interface
-    }
-}
-
-impl<T: ProtocolInfo> Drop for Protocol<'_, T> {
-    fn drop(&mut self) {
-        // If the device handle is not specified when creating the Protocol<T>, treat the
-        // handle as a static permanent reference and don't close it. An example is
-        // `EFI_SYSTEM_TABLE.ConOut`.
-        if self.device.0 != null_mut() {
-            // Currently we open all protocols using flags BY_HANDLE_PROTOCOL. The flag allows a
-            // protocol to be opened for multiple copies, which is needed if a UEFI protocol
-            // implementation also require access for other protocols. But if any one of them is
-            // closed, all other opened copies will be affected. Therefore for now we don't close
-            // the protocol on drop. In the future when we start using other flags such as
-            // EXCLUSIVE, we should perform protocol close based on the open flags.
-
-            // self.efi_entry.system_table().boot_services().close_protocol::<T>(self.device).unwrap();
-        }
-    }
-}
-
-/// Macro to perform an EFI protocol function call.
-///
-/// In the first variant, the first argument is the function pointer,
-/// and the following arguments are passed through as protocol args.
-///
-/// With our [Protocol] struct, usage generally looks something like:
-///
-/// ```
-/// efi_call!(
-///   self.interface()?.protocol_function_name,
-///   self.interface,
-///   arg1,
-///   arg2,
-///   ...
-/// )
-/// ```
-/// Most efi_call! invocations should use the first variant.
-///
-/// With the second variant, the first argument is an expression that references
-/// a buffer in-out size parameter.
-/// This is part of a pattern used by some protocol methods
-/// that take an output buffer and an in-out buffer size:
-/// if the method returns EFI_STATUS_BUFFER_TOO_SMALL,
-/// the size is mutated to contain the minimum required buffer size.
-/// The caller can then allocate a larger buffer and reattempt the method call.
-///
-/// Usage generally looks something like:
-/// ```
-/// efi_call!(
-///   @bufsize arg2,
-///   self.interface()?.protocol_function_name,
-///   self.interface,
-///   arg1,
-///   &mut arg2,
-///   ...
-/// )
-/// ```
-#[macro_export]
-macro_rules! efi_call {
-    ( $method:expr, $($x:expr),*$(,)? ) => {
-        {
-            use liberror::{Error, Result, efi_status_to_result};
-            let res: Result<()> = match $method {
-                None => Err(Error::NotFound),
-                Some(f) => efi_status_to_result(f($($x,)*)),
-            };
-            res
-        }
-    };
-    ( @bufsize $size:expr, $method:expr, $($x:expr),*$(,)? ) => {
-        {
-            use liberror::{Error, Result, efi_status_to_result};
-            use efi_types::EFI_STATUS_BUFFER_TOO_SMALL;
-            let res: Result<()> = match $method {
-                None => Err(Error::NotFound),
-                Some(f) => {
-                    match f($($x,)*) {
-                        EFI_STATUS_BUFFER_TOO_SMALL => Err(Error::BufferTooSmall(Some($size))),
-                        r => efi_status_to_result(r),
-                    }
-                },
-            };
-            res
-        }
-    };
-}
-
-// Following are protocol specific implementations for Protocol<T>.
-// TODO(300168989): Consdier splitting each protocol into separate file as we add more protocols.
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::test::*;
-
-    #[test]
-    fn test_dont_close_protocol_without_device_handle() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let mut block_io: EfiBlockIoProtocol = Default::default();
-            // SAFETY: `block_io` is a EfiBlockIoProtocol and out lives the created Protocol.
-            unsafe {
-                Protocol::<block_io::BlockIoProtocol>::new(
-                    DeviceHandle(null_mut()),
-                    &mut block_io as *mut _,
-                    &efi_entry,
-                );
-            }
-            efi_call_traces().with(|traces| {
-                assert_eq!(traces.borrow_mut().close_protocol_trace.inputs.len(), 0);
-            });
-        })
-    }
-}
diff --git a/gbl/libefi/src/protocol/block_io.rs b/gbl/libefi/src/protocol/block_io.rs
deleted file mode 100644
index 6df78c5..0000000
--- a/gbl/libefi/src/protocol/block_io.rs
+++ /dev/null
@@ -1,101 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_BLOCK_IO_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use efi_types::{EfiBlockIoMedia, EfiBlockIoProtocol, EfiGuid};
-use gbl_storage::SliceMaybeUninit;
-use liberror::{Error, Result};
-
-/// EFI_BLOCK_IO_PROTOCOL
-pub struct BlockIoProtocol;
-
-impl ProtocolInfo for BlockIoProtocol {
-    type InterfaceType = EfiBlockIoProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x964e5b21, 0x6459, 0x11d2, [0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b]);
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, BlockIoProtocol> {
-    /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.read_blocks()`
-    pub fn read_blocks(
-        &self,
-        lba: u64,
-        buffer: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        // `buffer` remains valid during the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.read_blocks,
-                self.interface,
-                self.media()?.media_id,
-                lba,
-                buffer.len(),
-                buffer.as_mut().as_mut_ptr() as *mut _
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.write_blocks()`
-    pub fn write_blocks(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        // `buffer` remains valid during the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.write_blocks,
-                self.interface,
-                self.media()?.media_id,
-                lba,
-                buffer.len(),
-                buffer.as_mut_ptr() as _
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.flush_blocks()`
-    pub fn flush_blocks(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.flush_blocks, self.interface) }
-    }
-
-    /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.reset()`
-    pub fn reset(&self, extended_verification: bool) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.reset, self.interface, extended_verification) }
-    }
-
-    /// Get a copy to the EFI_BLOCK_IO_PROTOCOL.Media structure.
-    pub fn media(&self) -> Result<EfiBlockIoMedia> {
-        let ptr = self.interface()?.media;
-        // SFETY: Pointers to EFI data structure.
-        Ok(*unsafe { ptr.as_ref() }.ok_or(Error::InvalidInput)?)
-    }
-}
diff --git a/gbl/libefi/src/protocol/block_io2.rs b/gbl/libefi/src/protocol/block_io2.rs
deleted file mode 100644
index 86962c9..0000000
--- a/gbl/libefi/src/protocol/block_io2.rs
+++ /dev/null
@@ -1,154 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_BLOCK_IO2_PROTOCOL`.
-
-use crate::{
-    efi_call,
-    protocol::{Protocol, ProtocolInfo},
-    Event, EventNotify, EventType, Tpl,
-};
-use efi_types::{
-    EfiBlockIo2Protocol, EfiBlockIo2Token, EfiBlockIoMedia, EfiGuid, EFI_STATUS_NOT_READY,
-};
-use gbl_async::{assert_return, yield_now};
-use gbl_storage::SliceMaybeUninit;
-use liberror::{efi_status_to_result, Error, Result};
-
-/// EFI_BLOCK_IO2_PROTOCOL
-pub struct BlockIo2Protocol;
-
-impl ProtocolInfo for BlockIo2Protocol {
-    type InterfaceType = EfiBlockIo2Protocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xa77b2472, 0xe282, 0x4e9f, [0xa2, 0x45, 0xc2, 0xc0, 0xe2, 0x7b, 0xbc, 0xc1]);
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, BlockIo2Protocol> {
-    /// Syncs a non-blocking operation by waiting for the corresponding EFI event to be signaled.
-    async fn wait_io_completion(&self, event: &Event<'_, '_>) -> Result<()> {
-        let bs = self.efi_entry().system_table().boot_services();
-        loop {
-            match bs.check_event(&event) {
-                Err(e) => {
-                    // If we fail to check event/status, force reset the device to release any
-                    // retained user buffer. The reset cannot fail.
-                    self.reset(true).unwrap();
-                    return Err(e);
-                }
-                Ok(true) => return Ok(()),
-                _ => yield_now().await,
-            }
-        }
-    }
-
-    /// Wraps `EfiBlockIo2Protocol.read_blocks_ex`.
-    pub async fn read_blocks_ex(
-        &self,
-        lba: u64,
-        buffer: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()> {
-        let bs = self.efi_entry().system_table().boot_services();
-        // UEFI spec requires that NOTIFY_WAIT event be always created with a callback.
-        let mut notify_fn = &mut |_| ();
-        let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
-        // SAFETY: the notification callback never allocates, deallocates, or panics.
-        let event =
-            unsafe { bs.create_event_with_notification(EventType::NotifyWait, &mut notify) }?;
-        let mut token =
-            EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //    established by `Protocol::new()`.
-        // * `self.interface` is input parameter and will not be retained. It outlives the call.
-        // * `Self::wait_io_completion()` is called immediately after. It makes sure the IO is
-        //   either completed successfully or is reset if `check_event` fails. Thus it's
-        //   guaranteed that after `Self::wait_io_completion()` returns, `buffer` and `token` are
-        //   not being retained by the UEFI firmware anymore.
-        // * `assert_return` asserts that `wait_io_completion` returns eventually. Otherwise it
-        //   panics if the top level Future gets dropped before it returns.
-        unsafe {
-            efi_call!(
-                self.interface()?.read_blocks_ex,
-                self.interface,
-                self.media()?.media_id,
-                lba,
-                &mut token,
-                buffer.len(),
-                buffer.as_mut().as_mut_ptr() as _
-            )?;
-        }
-        assert_return(self.wait_io_completion(&event)).await?;
-        efi_status_to_result(token.transaction_status)
-    }
-
-    /// Wraps `EfiBlockIo2Protocol.write_blocks_ex`.
-    pub async fn write_blocks_ex(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
-        let bs = self.efi_entry().system_table().boot_services();
-        let mut notify_fn = &mut |_| ();
-        let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
-        // SAFETY: the notification callback never allocates, deallocates, or panics.
-        let event =
-            unsafe { bs.create_event_with_notification(EventType::NotifyWait, &mut notify) }?;
-        let mut token =
-            EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
-        // SAFETY: See safety comment for `Self::read_blocks_ex()`.
-        unsafe {
-            efi_call!(
-                self.interface()?.write_blocks_ex,
-                self.interface,
-                self.media()?.media_id,
-                lba,
-                &mut token,
-                buffer.len(),
-                buffer.as_mut_ptr() as _
-            )?;
-        }
-        assert_return(self.wait_io_completion(&event)).await?;
-        efi_status_to_result(token.transaction_status)
-    }
-
-    /// Wraps `EFI_BLOCK_IO2_PROTOCOL.flush_blocks_ex()`
-    pub async fn flush_blocks_ex(&self) -> Result<()> {
-        let bs = self.efi_entry().system_table().boot_services();
-        let mut notify_fn = &mut |_| ();
-        let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
-        // SAFETY: the notification callback never allocates, deallocates, or panics.
-        let event =
-            unsafe { bs.create_event_with_notification(EventType::NotifyWait, &mut notify) }?;
-        let mut token =
-            EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
-        // SAFETY: See safety comment for `Self::read_blocks_ex()`.
-        unsafe { efi_call!(self.interface()?.flush_blocks_ex, self.interface, &mut token) }?;
-        assert_return(self.wait_io_completion(&event)).await?;
-        efi_status_to_result(token.transaction_status)
-    }
-
-    /// Wraps `EFI_BLOCK_IO2_PROTOCOL.reset()`
-    pub fn reset(&self, extended_verification: bool) -> Result<()> {
-        // SAFETY:
-        // * See safety comment for `Self::read_blocks_ex()`.
-        // * The operation is synchronous, no need to call wait_io_completion().
-        unsafe { efi_call!(self.interface()?.reset, self.interface, extended_verification) }
-    }
-
-    /// Gets a copy of the `EFI_BLOCK_IO2_PROTOCOL.Media` structure.
-    pub fn media(&self) -> Result<EfiBlockIoMedia> {
-        let ptr = self.interface()?.media;
-        // SAFETY: Pointers to EFI data structure.
-        Ok(*unsafe { ptr.as_ref() }.ok_or(Error::InvalidInput)?)
-    }
-}
diff --git a/gbl/libefi/src/protocol/device_path.rs b/gbl/libefi/src/protocol/device_path.rs
deleted file mode 100644
index 6ca5560..0000000
--- a/gbl/libefi/src/protocol/device_path.rs
+++ /dev/null
@@ -1,154 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_DEVICE_PATH_PROTOCOL`.
-
-use crate::protocol::{Protocol, ProtocolInfo};
-use crate::EfiEntry;
-use core::fmt::Display;
-use efi_types::{EfiDevicePathProtocol, EfiDevicePathToTextProtocol, EfiGuid};
-use liberror::{Error, Result};
-
-/// `EFI_DEVICE_PATH_PROTOCOL`
-pub struct DevicePathProtocol;
-
-impl ProtocolInfo for DevicePathProtocol {
-    type InterfaceType = EfiDevicePathProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x09576e91, 0x6d3f, 0x11d2, [0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b]);
-}
-
-/// `EFI_DEVICE_PATH_TO_TEXT_PROTOCOL`
-pub struct DevicePathToTextProtocol;
-
-impl ProtocolInfo for DevicePathToTextProtocol {
-    type InterfaceType = EfiDevicePathToTextProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x8b843e20, 0x8132, 0x4852, [0x90, 0xcc, 0x55, 0x1a, 0x4e, 0x4a, 0x7f, 0x1c]);
-}
-
-impl<'a> Protocol<'a, DevicePathToTextProtocol> {
-    /// Wrapper of `EFI_DEVICE_PATH_TO_TEXT_PROTOCOL.ConvertDevicePathToText()`
-    pub fn convert_device_path_to_text(
-        &self,
-        device_path: &Protocol<DevicePathProtocol>,
-        display_only: bool,
-        allow_shortcuts: bool,
-    ) -> Result<DevicePathText<'a>> {
-        let f = self.interface()?.convert_device_path_to_text.as_ref().ok_or(Error::NotFound)?;
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        let res = unsafe { f(device_path.interface_ptr(), display_only, allow_shortcuts) };
-        Ok(DevicePathText::new(res, self.efi_entry))
-    }
-}
-
-/// `DevicePathText` is a wrapper for the return type of
-/// EFI_DEVICE_PATH_TO_TEXT_PROTOCOL.ConvertDevicePathToText().
-pub struct DevicePathText<'a> {
-    text: Option<&'a [u16]>,
-    efi_entry: &'a EfiEntry,
-}
-
-impl<'a> DevicePathText<'a> {
-    pub(crate) fn new(text: *mut u16, efi_entry: &'a EfiEntry) -> Self {
-        if text.is_null() {
-            return Self { text: None, efi_entry: efi_entry };
-        }
-
-        let mut len: usize = 0;
-        // SAFETY: UEFI text is NULL terminated.
-        while unsafe { *text.add(len) } != 0 {
-            len += 1;
-        }
-        Self {
-            // SAFETY: Pointer is confirmed non-null with known length at this point.
-            text: Some(unsafe { core::slice::from_raw_parts(text, len) }),
-            efi_entry: efi_entry,
-        }
-    }
-
-    /// Get the text as a u16 slice.
-    pub fn text(&self) -> Option<&[u16]> {
-        self.text
-    }
-}
-
-impl Display for DevicePathText<'_> {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        if let Some(text) = self.text {
-            for c in char::decode_utf16(text.into_iter().map(|v| *v)) {
-                match c.unwrap_or(char::REPLACEMENT_CHARACTER) {
-                    '\0' => break,
-                    ch => write!(f, "{}", ch)?,
-                };
-            }
-        }
-        Ok(())
-    }
-}
-
-impl Drop for DevicePathText<'_> {
-    fn drop(&mut self) {
-        if let Some(text) = self.text {
-            self.efi_entry
-                .system_table()
-                .boot_services()
-                .free_pool(text.as_ptr() as *mut _)
-                .unwrap();
-        }
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::test::*;
-    use core::ptr::null_mut;
-
-    #[test]
-    fn test_device_path_text_drop() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let mut data: [u16; 4] = [1, 2, 3, 0];
-            {
-                let path = DevicePathText::new(data.as_mut_ptr(), &efi_entry);
-                assert_eq!(path.text().unwrap().to_vec(), vec![1, 2, 3]);
-            }
-            efi_call_traces().with(|traces| {
-                assert_eq!(
-                    traces.borrow_mut().free_pool_trace.inputs,
-                    [data.as_mut_ptr() as *mut _]
-                );
-            });
-        })
-    }
-
-    #[test]
-    fn test_device_path_text_null() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            {
-                assert_eq!(DevicePathText::new(null_mut(), &efi_entry).text(), None);
-            }
-            efi_call_traces().with(|traces| {
-                assert_eq!(traces.borrow_mut().free_pool_trace.inputs.len(), 0);
-            });
-        })
-    }
-}
diff --git a/gbl/libefi/src/protocol/dt_fixup.rs b/gbl/libefi/src/protocol/dt_fixup.rs
deleted file mode 100644
index f205643..0000000
--- a/gbl/libefi/src/protocol/dt_fixup.rs
+++ /dev/null
@@ -1,133 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_DT_FIXUP_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use efi_types::{EfiDtFixupProtocol, EfiGuid, EFI_DT_APPLY_FIXUPS};
-use liberror::Result;
-
-/// `EFI_DT_FIXUP_PROTOCOL` implementation.
-pub struct DtFixupProtocol;
-
-impl ProtocolInfo for DtFixupProtocol {
-    type InterfaceType = EfiDtFixupProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xe617d64c, 0xfe08, 0x46da, [0xf4, 0xdc, 0xbb, 0xd5, 0x87, 0x0c, 0x73, 0x00]);
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, DtFixupProtocol> {
-    /// Wraps `EFI_DT_FIXUP_PROTOCOL.fixup()`.
-    pub fn fixup(&self, device_tree: &mut [u8]) -> Result<()> {
-        let mut buffer_size = device_tree.len();
-
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`.
-        // * `device_tree` is non-null buffer available for write, used only within the call.
-        // * `buffer_size` is non-null usize buffer available for write, used only within the call.
-        unsafe {
-            efi_call!(
-                @bufsize buffer_size,
-                self.interface()?.fixup,
-                self.interface,
-                device_tree.as_mut_ptr() as _,
-                &mut buffer_size,
-                EFI_DT_APPLY_FIXUPS
-            )?;
-        }
-
-        Ok(())
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    use crate::test::run_test_with_mock_protocol;
-    use efi_types::{EfiStatus, EFI_STATUS_BUFFER_TOO_SMALL, EFI_STATUS_SUCCESS};
-    use liberror::Error;
-    use std::{ffi::c_void, slice};
-
-    #[test]
-    fn fixup_device_tree_updated() {
-        // Don't check actual FDT content for simplicity.
-        const DEVICE_TREE_BUFFER: &[u8] = b"this_is_device_tree";
-        const UPDATED_DEVICE_TREE_BUFFER: &[u8] = b"this_is_device_trie";
-
-        // C callback implementation to modify provided FDT to UPDATED_DEVICE_TREE_BUFFER.
-        unsafe extern "C" fn c_modify(
-            _: *mut EfiDtFixupProtocol,
-            device_tree: *mut c_void,
-            buffer_size: *mut usize,
-            flags: u32,
-        ) -> EfiStatus {
-            assert_eq!(flags, EFI_DT_APPLY_FIXUPS);
-            // SAFETY:
-            // * `device_tree` is a valid pointer to the writtable buffer at least `buffer_size`
-            // size.
-            // * `buffer_size` is a valid pointer to usize.
-            let fdt_buffer =
-                unsafe { slice::from_raw_parts_mut(device_tree as *mut u8, *buffer_size) };
-            assert_eq!(fdt_buffer, DEVICE_TREE_BUFFER);
-
-            fdt_buffer.copy_from_slice(UPDATED_DEVICE_TREE_BUFFER);
-
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = EfiDtFixupProtocol { fixup: Some(c_modify), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |dt_fixup_protocol| {
-            let mut fdt_buffer: Vec<u8> = DEVICE_TREE_BUFFER.to_vec();
-
-            assert!(dt_fixup_protocol.fixup(&mut fdt_buffer[..]).is_ok());
-            assert_eq!(&fdt_buffer[..], UPDATED_DEVICE_TREE_BUFFER);
-        });
-    }
-
-    #[test]
-    fn fixup_device_tree_fixup_buffer_too_small() {
-        const EXPECTED_REQUESTED_FIXUP_SIZE: usize = 256;
-        // C callback implementation to return an error.
-        unsafe extern "C" fn c_error(
-            _: *mut EfiDtFixupProtocol,
-            _: *mut c_void,
-            buffer_size: *mut usize,
-            _: u32,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `buffer_size` is a valid pointer to writtable usize buffer.
-            unsafe {
-                *buffer_size = EXPECTED_REQUESTED_FIXUP_SIZE;
-            }
-            EFI_STATUS_BUFFER_TOO_SMALL
-        }
-
-        let c_interface = EfiDtFixupProtocol { fixup: Some(c_error), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |dt_fixup_protocol| {
-            let mut fdt_buffer = [0u8; 128];
-
-            assert_eq!(
-                dt_fixup_protocol.fixup(&mut fdt_buffer[..]),
-                Err(Error::BufferTooSmall(Some(EXPECTED_REQUESTED_FIXUP_SIZE))),
-            );
-        });
-    }
-}
diff --git a/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs b/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
deleted file mode 100644
index e24c4de..0000000
--- a/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
+++ /dev/null
@@ -1,217 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `GBL_EFI_SLOT_PROTOCOL`.
-extern crate libgbl;
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use efi_types::{
-    EfiGuid, GblEfiABSlotProtocol, GblEfiBootReason, GblEfiSlotInfo, GblEfiSlotMetadataBlock,
-    GblEfiUnbootableReason, GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_NO_MORE_TRIES as NO_MORE_TRIES,
-    GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_SYSTEM_UPDATE as SYSTEM_UPDATE,
-    GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_USER_REQUESTED as USER_REQUESTED,
-    GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_VERIFICATION_FAILURE as VERIFICATION_FAILURE,
-};
-use liberror::{Error, Result};
-
-use libgbl::slots::{Bootability, Slot, UnbootableReason};
-
-/// Wraps `GBL_EFI_SLOT_PROTOCOL`.
-pub struct GblSlotProtocol;
-
-impl ProtocolInfo for GblSlotProtocol {
-    type InterfaceType = GblEfiABSlotProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x9a7a7db4, 0x614b, 0x4a08, [0x3d, 0xf9, 0x00, 0x6f, 0x49, 0xb0, 0xd8, 0x0c]);
-}
-
-fn from_efi_unbootable_reason(reason: GblEfiUnbootableReason) -> UnbootableReason {
-    match reason {
-        NO_MORE_TRIES => UnbootableReason::NoMoreTries,
-        SYSTEM_UPDATE => UnbootableReason::SystemUpdate,
-        USER_REQUESTED => UnbootableReason::UserRequested,
-        VERIFICATION_FAILURE => UnbootableReason::VerificationFailure,
-        _ => UnbootableReason::Unknown,
-    }
-}
-
-/// Newtype around GblEfiSlotInfo to bypass orphan rule.
-pub struct GblSlot(pub(crate) GblEfiSlotInfo);
-
-impl From<GblEfiSlotInfo> for GblSlot {
-    fn from(slot: GblEfiSlotInfo) -> Self {
-        Self(slot)
-    }
-}
-
-impl TryFrom<GblSlot> for libgbl::slots::Slot {
-    type Error = liberror::Error;
-    fn try_from(info: GblSlot) -> Result<Self> {
-        let info = info.0;
-        Ok(Slot {
-            suffix: info.suffix.try_into()?,
-            priority: info.priority.into(),
-            bootability: match (info.successful, info.tries) {
-                (s, _) if s != 0 => Bootability::Successful,
-                (0, t) if t > 0 => Bootability::Retriable(info.tries.into()),
-                _ => Bootability::Unbootable(from_efi_unbootable_reason(info.unbootable_reason)),
-            },
-        })
-    }
-}
-
-impl<'a> Protocol<'a, GblSlotProtocol> {
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.load_boot_data()`
-    pub fn load_boot_data(&self) -> Result<GblEfiSlotMetadataBlock> {
-        let mut block: GblEfiSlotMetadataBlock = Default::default();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `block` is an output parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.load_boot_data, self.interface, &mut block)? }
-        Ok(block)
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.get_slot_info()`
-    pub fn get_slot_info(&self, idx: u8) -> Result<GblSlot> {
-        let mut info: GblEfiSlotInfo = Default::default();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `info` is an output parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.get_slot_info, self.interface, idx, &mut info,)? }
-        Ok(info.into())
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.get_current_slot()`
-    pub fn get_current_slot(&self) -> Result<GblSlot> {
-        let mut info: GblEfiSlotInfo = Default::default();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `info` is an output parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.get_current_slot, self.interface, &mut info)? };
-        Ok(info.into())
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.GetNextSlot()`
-    pub fn get_next_slot(&self, mark_boot_attempt: bool) -> Result<GblSlot> {
-        let mut info = GblEfiSlotInfo::default();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface`, `info` are input/output parameter and will not be retained. It
-        // outlives the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.get_next_slot,
-                self.interface,
-                mark_boot_attempt,
-                &mut info as _
-            )?;
-        }
-        Ok(GblSlot::from(info))
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_active_slot()`
-    pub fn set_active_slot(&self, idx: u8) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.set_active_slot, self.interface, idx) }
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_slot_unbootable()`
-    pub fn set_slot_unbootable(&self, idx: u8, reason: GblEfiUnbootableReason) -> Result<()> {
-        let reason: u32 = reason.try_into().or(Err(Error::InvalidInput))?;
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.set_slot_unbootable, self.interface, idx, reason) }
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.reinitialize()`
-    pub fn reinitialize(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.reinitialize, self.interface) }
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.get_boot_reason()`
-    pub fn get_boot_reason(&self, subreason: &mut [u8]) -> Result<(GblEfiBootReason, usize)> {
-        let mut reason: u32 = 0;
-        let mut subreason_size = subreason.len();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `reason` is an output parameter. It is not retained, and it outlives the call.
-        // `subreason_size` is an in-out parameter. It is not retained, and it outlives the call.
-        // `subreason` remains valid during the call.
-        unsafe {
-            efi_call!(
-                @bufsize subreason_size,
-                self.interface()?.get_boot_reason,
-                self.interface,
-                &mut reason,
-                &mut subreason_size,
-                subreason.as_mut_ptr(),
-            )?
-        }
-
-        let reason: GblEfiBootReason = reason.try_into().or(Err(Error::InvalidInput))?;
-        Ok((reason, subreason_size))
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_boot_reason()`
-    pub fn set_boot_reason(&self, reason: GblEfiBootReason, subreason: &[u8]) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `subreason` is not modified or retained. It outlives the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.set_boot_reason,
-                self.interface,
-                reason.try_into().or(Err(Error::InvalidInput))?,
-                subreason.len(),
-                subreason.as_ptr(),
-            )
-        }
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.flush()`
-    pub fn flush(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.flush, self.interface) }
-    }
-
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.version`
-    pub fn version(&self) -> Result<u32> {
-        Ok(self.interface()?.version)
-    }
-}
diff --git a/gbl/libefi/src/protocol/gbl_efi_avb.rs b/gbl/libefi/src/protocol/gbl_efi_avb.rs
deleted file mode 100644
index fda9028..0000000
--- a/gbl/libefi/src/protocol/gbl_efi_avb.rs
+++ /dev/null
@@ -1,700 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `GBL_EFI_AVB_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use core::ffi::CStr;
-use core::ptr::null;
-use efi_types::{
-    EfiGuid, GblEfiAvbKeyValidationStatus, GblEfiAvbProtocol, GblEfiAvbVerificationResult,
-};
-use liberror::Result;
-
-/// `GBL_EFI_AVB_PROTOCOL` implementation.
-pub struct GblAvbProtocol;
-
-impl ProtocolInfo for GblAvbProtocol {
-    type InterfaceType = GblEfiAvbProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x6bc66b9a, 0xd5c9, 0x4c02, [0x9d, 0xa9, 0x50, 0xaf, 0x19, 0x8d, 0x91, 0x2c]);
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, GblAvbProtocol> {
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.validate_vbmeta_public_key()`.
-    pub fn validate_vbmeta_public_key(
-        &self,
-        public_key: &[u8],
-        public_key_metadata: Option<&[u8]>,
-    ) -> Result<GblEfiAvbKeyValidationStatus> {
-        let mut validation_status: GblEfiAvbKeyValidationStatus =
-            efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_INVALID;
-
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`
-        // * `public_key` pointer is not-null and used only within the call
-        // * `public_key_metadata` pointer (can be null), used only within the call
-        // * `validation_status` non-null pointer available to write
-        unsafe {
-            efi_call!(
-                self.interface()?.validate_vbmeta_public_key,
-                self.interface,
-                public_key.as_ptr() as *const _,
-                public_key.len(),
-                public_key_metadata.map_or(null(), |m| m.as_ptr() as *const _),
-                public_key_metadata.map_or(0, |m| m.len()),
-                &mut validation_status,
-            )?
-        }
-
-        Ok(validation_status)
-    }
-
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.read_is_device_unlocked()`.
-    pub fn read_is_device_unlocked(&self) -> Result<bool> {
-        let mut is_unlocked: bool = false;
-
-        // SAFETY:
-        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
-        // object established by `Protocol::new()`.
-        // * `is_unlocked` is a non-null pointer to a `bool` available for write.
-        unsafe {
-            efi_call!(self.interface()?.read_is_device_unlocked, self.interface, &mut is_unlocked)?
-        }
-
-        Ok(is_unlocked)
-    }
-
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.read_rollback_index()`.
-    pub fn read_rollback_index(&self, index_location: usize) -> Result<u64> {
-        let mut rollback_index: u64 = 0;
-
-        // SAFETY:
-        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
-        //   object established by `Protocol::new()`.
-        // * `rollback_index` is a valid pointer to a `u64` available for write.
-        unsafe {
-            efi_call!(
-                self.interface()?.read_rollback_index,
-                self.interface,
-                index_location,
-                &mut rollback_index,
-            )?
-        }
-
-        Ok(rollback_index)
-    }
-
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.write_rollback_index()`.
-    pub fn write_rollback_index(&self, index_location: usize, rollback_index: u64) -> Result<()> {
-        // SAFETY:
-        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
-        //   object established by `Protocol::new()`.
-        unsafe {
-            efi_call!(
-                self.interface()?.write_rollback_index,
-                self.interface,
-                index_location,
-                rollback_index,
-            )?
-        }
-
-        Ok(())
-    }
-
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.read_persistent_value()`.
-    pub fn read_persistent_value(&self, name: &CStr, value: &mut [u8]) -> Result<usize> {
-        let mut value_buffer_size = value.len();
-
-        let value_ptr = match value.is_empty() {
-            true => core::ptr::null_mut(),
-            false => value.as_mut_ptr(),
-        };
-
-        // SAFETY:
-        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
-        //   object established by `Protocol::new()`.
-        // * `name` is a valid pointer to a null-terminated string used only within the call.
-        // * `value_ptr` is either a valid pointer to a writable buffer or a null pointer, used only
-        //   within the call
-        // * `value_buffer_size` holds a mutable reference to `usize`, used only within the call.
-        unsafe {
-            efi_call!(
-                @bufsize value_buffer_size,
-                self.interface()?.read_persistent_value,
-                self.interface,
-                name.as_ptr(),
-                value_ptr,
-                &mut value_buffer_size,
-            )?
-        }
-
-        Ok(value_buffer_size)
-    }
-
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.write_persistent_value()`.
-    pub fn write_persistent_value(&self, name: &CStr, value: Option<&[u8]>) -> Result<()> {
-        let (value_ptr, value_len) = match value {
-            Some(v) => (v.as_ptr(), v.len()),
-            None => (core::ptr::null(), 0),
-        };
-
-        // SAFETY:
-        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
-        //   object established by `Protocol::new()`.
-        // * `name` is a valid pointer to a null-terminated string used only within the call.
-        // * `value_ptr` is a valid pointer to `value_len` sized buffer or null, used only within
-        //   the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.write_persistent_value,
-                self.interface,
-                name.as_ptr(),
-                value_ptr,
-                value_len,
-            )?
-        }
-
-        Ok(())
-    }
-
-    /// Wraps `GBL_EFI_AVB_PROTOCOL.handle_verification_result()`.
-    pub fn handle_verification_result(
-        &self,
-        verification_result: &GblEfiAvbVerificationResult,
-    ) -> Result<()> {
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`.
-        // * `verification_result` pointer is not-null and used only within the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.handle_verification_result,
-                self.interface,
-                verification_result as *const _
-            )
-        }
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::{protocol::EFI_STATUS_BUFFER_TOO_SMALL, test::run_test_with_mock_protocol, Error};
-    use efi_types::{EfiStatus, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS};
-    use std::{ffi::c_char, ptr, slice};
-
-    #[test]
-    fn validate_vbmeta_public_key_status_provided() {
-        const EXPECTED_PUBLIC_KEY: &[u8] = b"test_key";
-        const EXPECTED_STATUS: GblEfiAvbKeyValidationStatus =
-            efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID_CUSTOM_KEY;
-
-        // C callback implementation that returns an error
-        unsafe extern "C" fn c_return_error(
-            _: *mut GblEfiAvbProtocol,
-            public_key_ptr: *const u8,
-            public_key_len: usize,
-            _metadata_ptr: *const u8,
-            _metadata_len: usize,
-            validation_status_ptr: *mut GblEfiAvbKeyValidationStatus,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `public_key_ptr` is a non-null pointer to the buffer at least `public_key_len`
-            // size.
-            let public_key_buffer =
-                unsafe { slice::from_raw_parts(public_key_ptr, public_key_len) };
-
-            assert_eq!(public_key_buffer, EXPECTED_PUBLIC_KEY);
-
-            // SAFETY:
-            // * `validation_status_ptr` is a non-null pointer to GblEfiAvbKeyValidationStatus
-            // available to write.
-            unsafe { *validation_status_ptr = EXPECTED_STATUS };
-
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            validate_vbmeta_public_key: Some(c_return_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(
-                avb_protocol.validate_vbmeta_public_key(EXPECTED_PUBLIC_KEY, None),
-                Ok(EXPECTED_STATUS)
-            );
-        });
-    }
-
-    #[test]
-    fn validate_vbmeta_public_key_error_handled() {
-        // C callback implementation that returns an error
-        unsafe extern "C" fn c_return_error(
-            _: *mut GblEfiAvbProtocol,
-            _public_key_ptr: *const u8,
-            _public_key_len: usize,
-            _metadata_ptr: *const u8,
-            _metadata_len: usize,
-            _validation_status_ptr: *mut GblEfiAvbKeyValidationStatus,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            validate_vbmeta_public_key: Some(c_return_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert!(avb_protocol.validate_vbmeta_public_key(b"test_key", None).is_err());
-        });
-    }
-
-    #[test]
-    fn handle_verification_result_data_provided() {
-        const COLOR: u32 = efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_RED;
-
-        // C callback implementation that returns success.
-        unsafe extern "C" fn c_return_success(
-            _: *mut GblEfiAvbProtocol,
-            result: *const GblEfiAvbVerificationResult,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `result` is non-null.
-            assert_eq!(unsafe { (*result).color }, COLOR);
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            handle_verification_result: Some(c_return_success),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            let verification_result =
-                GblEfiAvbVerificationResult { color: COLOR, ..Default::default() };
-
-            assert!(avb_protocol.handle_verification_result(&verification_result).is_ok());
-        });
-    }
-
-    #[test]
-    fn handle_verification_result_error() {
-        // C callback implementation that returns an error.
-        unsafe extern "C" fn c_return_error(
-            _: *mut GblEfiAvbProtocol,
-            _: *const GblEfiAvbVerificationResult,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            handle_verification_result: Some(c_return_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            let verification_result = GblEfiAvbVerificationResult::default();
-
-            assert!(avb_protocol.handle_verification_result(&verification_result).is_err());
-        });
-    }
-
-    #[test]
-    fn read_is_device_unlocked_returns_true() {
-        /// C callback implementation that sets is_unlocked to true.
-        ///
-        /// # Safety:
-        /// Caller must guaranteed that `is_unlocked_ptr` points to a valid bool variable available
-        /// for write.
-        unsafe extern "C" fn c_return_true(
-            _: *mut GblEfiAvbProtocol,
-            is_unlocked_ptr: *mut bool,
-        ) -> EfiStatus {
-            // SAFETY: By safety requirement of this function, is_unlocked_ptr is a valid pointer.
-            unsafe { *is_unlocked_ptr = true };
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            read_is_device_unlocked: Some(c_return_true),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(avb_protocol.read_is_device_unlocked(), Ok(true));
-        });
-    }
-
-    #[test]
-    fn read_is_device_unlocked_returns_false() {
-        /// C callback implementation that sets is_unlocked to false.
-        ///
-        /// # Safety:
-        /// Caller must guaranteed that `is_unlocked_ptr` points to a valid bool variable available
-        /// for write.
-        unsafe extern "C" fn c_return_false(
-            _: *mut GblEfiAvbProtocol,
-            is_unlocked_ptr: *mut bool,
-        ) -> EfiStatus {
-            // SAFETY: By safety requirement of this function, is_unlocked_ptr is a valid pointer.
-            unsafe { *is_unlocked_ptr = false };
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            read_is_device_unlocked: Some(c_return_false),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(avb_protocol.read_is_device_unlocked(), Ok(false));
-        });
-    }
-
-    #[test]
-    fn read_is_device_unlocked_error_handled() {
-        /// C callback implementation that returns an error.
-        unsafe extern "C" fn c_return_error(_: *mut GblEfiAvbProtocol, _: *mut bool) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            read_is_device_unlocked: Some(c_return_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert!(avb_protocol.read_is_device_unlocked().is_err());
-        });
-    }
-
-    #[test]
-    fn read_rollback_index_returns_value() {
-        const EXPECTED_INDEX_LOCATION: usize = 1;
-        const EXPECTED_ROLLBACK_INDEX: u64 = 42;
-
-        /// C callback implementation that sets rollback_index to EXPECTED_ROLLBACK_INDEX.
-        ///
-        /// # Safety:
-        /// Caller must guaranteed that `rollback_index_ptr` points to a valid u64 variable
-        /// available for write.
-        unsafe extern "C" fn c_return_value(
-            _: *mut GblEfiAvbProtocol,
-            index_location: usize,
-            rollback_index_ptr: *mut u64,
-        ) -> EfiStatus {
-            assert_eq!(index_location, EXPECTED_INDEX_LOCATION);
-
-            // SAFETY: By safety requirement of this function, `rollback_index_ptr` is a valid
-            // pointer.
-            unsafe { *rollback_index_ptr = EXPECTED_ROLLBACK_INDEX };
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface =
-            GblEfiAvbProtocol { read_rollback_index: Some(c_return_value), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(
-                avb_protocol.read_rollback_index(EXPECTED_INDEX_LOCATION),
-                Ok(EXPECTED_ROLLBACK_INDEX)
-            );
-        });
-    }
-
-    #[test]
-    fn read_rollback_index_error_handled() {
-        /// C callback implementation that returns an error.
-        unsafe extern "C" fn c_return_error(
-            _: *mut GblEfiAvbProtocol,
-            _: usize,
-            _: *mut u64,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface =
-            GblEfiAvbProtocol { read_rollback_index: Some(c_return_error), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert!(avb_protocol.read_rollback_index(0).is_err());
-        });
-    }
-
-    #[test]
-    fn write_rollback_index_success() {
-        const EXPECTED_INDEX_LOCATION: usize = 1;
-        const EXPECTED_ROLLBACK_INDEX: u64 = 42;
-
-        /// C callback implementation that checks the passed parameters and returns success.
-        unsafe extern "C" fn c_return_success(
-            _: *mut GblEfiAvbProtocol,
-            index_location: usize,
-            rollback_index: u64,
-        ) -> EfiStatus {
-            assert_eq!(index_location, EXPECTED_INDEX_LOCATION);
-            assert_eq!(rollback_index, EXPECTED_ROLLBACK_INDEX);
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            write_rollback_index: Some(c_return_success),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert!(avb_protocol
-                .write_rollback_index(EXPECTED_INDEX_LOCATION, EXPECTED_ROLLBACK_INDEX)
-                .is_ok());
-        });
-    }
-
-    #[test]
-    fn write_rollback_index_error_handled() {
-        /// C callback implementation that returns an error.
-        unsafe extern "C" fn c_return_error(
-            _: *mut GblEfiAvbProtocol,
-            _: usize,
-            _: u64,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface =
-            GblEfiAvbProtocol { write_rollback_index: Some(c_return_error), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert!(avb_protocol.write_rollback_index(0, 0).is_err());
-        });
-    }
-
-    #[test]
-    fn read_persistent_value_success() {
-        const EXPECTED_NAME: &CStr = c"test_key";
-        const EXPECTED_VALUE: &[u8] = b"test_value";
-
-        /// C callback implementation.
-        ///
-        /// # Safety:
-        /// * Caller must guaranteed that `name` points to a valid null-terminated string.
-        /// * Caller must guaranteed that `value` points to non-null `value_size` sized bytes
-        ///   buffer.
-        /// * Caller must guaranteed that `value_size` points to a valid usize available to write
-        ///   value buffer.
-        unsafe extern "C" fn c_read_persistent_value_success(
-            _: *mut GblEfiAvbProtocol,
-            name: *const c_char,
-            value: *mut u8,
-            value_size: *mut usize,
-        ) -> EfiStatus {
-            assert_eq!(
-                // SAFETY:
-                // * `name` is a valid pointer to null-terminated string.
-                unsafe { CStr::from_ptr(name) },
-                EXPECTED_NAME
-            );
-            assert_eq!(
-                // SAFETY:
-                // * `value_size` is a valid non-null pointer to `usize` value.
-                unsafe { ptr::read(value_size) },
-                EXPECTED_VALUE.len()
-            );
-
-            // SAFETY:
-            // * `value` is non-null pointer available for write.
-            let value_buffer = unsafe { slice::from_raw_parts_mut(value, EXPECTED_VALUE.len()) };
-            value_buffer.copy_from_slice(EXPECTED_VALUE);
-
-            return EFI_STATUS_SUCCESS;
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            read_persistent_value: Some(c_read_persistent_value_success),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            let mut buffer = [0u8; EXPECTED_VALUE.len()];
-
-            assert_eq!(
-                avb_protocol.read_persistent_value(EXPECTED_NAME, &mut buffer),
-                Ok(EXPECTED_VALUE.len())
-            );
-            assert_eq!(&buffer, EXPECTED_VALUE);
-        });
-    }
-
-    #[test]
-    fn read_persistent_value_buffer_too_small() {
-        const EXPECTED_BUFFER_SIZE: usize = 12;
-
-        /// C callback implementation.
-        ///
-        /// # Safety:
-        /// * Caller must guaranteed that `value_size` points to a valid usize available to write
-        ///   value buffer.
-        unsafe extern "C" fn c_read_persistent_value_buffer_too_small(
-            _: *mut GblEfiAvbProtocol,
-            _: *const c_char,
-            _: *mut u8,
-            value_size: *mut usize,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `value_size` is a valid non-null pointer to `usize` value.
-            unsafe { ptr::write(value_size, EXPECTED_BUFFER_SIZE) };
-
-            return EFI_STATUS_BUFFER_TOO_SMALL;
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            read_persistent_value: Some(c_read_persistent_value_buffer_too_small),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            let mut buffer = [0u8; 0];
-
-            assert_eq!(
-                avb_protocol.read_persistent_value(c"name", &mut buffer),
-                Err(Error::BufferTooSmall(Some(EXPECTED_BUFFER_SIZE)))
-            );
-        });
-    }
-
-    #[test]
-    fn write_persistent_value_success() {
-        const EXPECTED_NAME: &CStr = c"test_key";
-        const EXPECTED_VALUE: &[u8] = b"test_value";
-
-        /// C callback implementation.
-        ///
-        /// # Safety:
-        /// * Caller must guarantee that `name` points to a valid null-terminated string.
-        /// * Caller must guarantee that `value` points to a valid `value_size` sized bytes buffer.
-        unsafe extern "C" fn c_write_persistent_value_success(
-            _: *mut GblEfiAvbProtocol,
-            name: *const c_char,
-            value: *const u8,
-            value_size: usize,
-        ) -> EfiStatus {
-            assert_eq!(
-                // SAFETY:
-                // * `name` is a valid pointer to null-terminated string.
-                unsafe { CStr::from_ptr(name) },
-                EXPECTED_NAME
-            );
-            assert_eq!(value_size, EXPECTED_VALUE.len());
-
-            // SAFETY:
-            // * `value` is a valid pointer to `value_size` bytes.
-            let value_buffer = unsafe { slice::from_raw_parts(value, value_size) };
-            assert_eq!(value_buffer, EXPECTED_VALUE);
-
-            return EFI_STATUS_SUCCESS;
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            write_persistent_value: Some(c_write_persistent_value_success),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(
-                avb_protocol.write_persistent_value(EXPECTED_NAME, Some(EXPECTED_VALUE)),
-                Ok(())
-            );
-        });
-    }
-
-    #[test]
-    fn write_persistent_value_delete() {
-        const EXPECTED_NAME: &CStr = c"test_key";
-
-        /// C callback implementation for deleting a persistent value.
-        ///
-        /// # Safety:
-        /// * Caller must guarantee that `name` points to a valid null-terminated string.
-        unsafe extern "C" fn c_write_persistent_value_delete(
-            _: *mut GblEfiAvbProtocol,
-            name: *const c_char,
-            value: *const u8,
-            value_size: usize,
-        ) -> EfiStatus {
-            assert_eq!(
-                // SAFETY:
-                // * `name` is a valid pointer to null-terminated string.
-                unsafe { CStr::from_ptr(name) },
-                EXPECTED_NAME
-            );
-            assert!(value.is_null());
-            assert_eq!(value_size, 0);
-
-            return EFI_STATUS_SUCCESS;
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            write_persistent_value: Some(c_write_persistent_value_delete),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(avb_protocol.write_persistent_value(EXPECTED_NAME, None), Ok(()));
-        });
-    }
-
-    #[test]
-    fn write_persistent_value_error_handled() {
-        const EXPECTED_NAME: &CStr = c"test_key";
-        const EXPECTED_VALUE: &[u8] = b"test_value";
-
-        /// C callback implementation that returns an error.
-        ///
-        /// # Safety:
-        /// * Caller must guarantee that `name` points to a valid null-terminated string.
-        unsafe extern "C" fn c_write_persistent_value_error(
-            _: *mut GblEfiAvbProtocol,
-            name: *const c_char,
-            _: *const u8,
-            _: usize,
-        ) -> EfiStatus {
-            assert_eq!(
-                // SAFETY:
-                // * `name` is a valid pointer to null-terminated string.
-                unsafe { CStr::from_ptr(name) },
-                EXPECTED_NAME
-            );
-
-            return EFI_STATUS_INVALID_PARAMETER;
-        }
-
-        let c_interface = GblEfiAvbProtocol {
-            write_persistent_value: Some(c_write_persistent_value_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |avb_protocol| {
-            assert_eq!(
-                avb_protocol.write_persistent_value(EXPECTED_NAME, Some(EXPECTED_VALUE)),
-                Err(Error::InvalidInput),
-            );
-        });
-    }
-}
diff --git a/gbl/libefi/src/protocol/gbl_efi_fastboot.rs b/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
deleted file mode 100644
index 47c4e18..0000000
--- a/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
+++ /dev/null
@@ -1,512 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `GBL_EFI_FASTBOOT_PROTOCOL`
-
-use crate::{
-    efi_call,
-    protocol::{Protocol, ProtocolInfo},
-};
-use core::{
-    ffi::{c_char, c_void, CStr},
-    ptr::{null, null_mut},
-    slice::from_raw_parts,
-    str::from_utf8,
-};
-use efi_types::{EfiGuid, GblEfiFastbootPolicy, GblEfiFastbootProtocol};
-use liberror::{Error, Result};
-
-/// GBL_EFI_FASTBOOT_PROTOCOL
-pub struct GblFastbootProtocol;
-
-// Note: this is an internal limitation due to the need to allocate
-// fixed sized buffers for storing args in the iterator
-// and in the wrapper for `GblEfiFastbootProtocol.get_var`.
-const MAX_ARGS: usize = 16;
-
-impl ProtocolInfo for GblFastbootProtocol {
-    type InterfaceType = GblEfiFastbootProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xc67e48a0, 0x5eb8, 0x4127, [0xbe, 0x89, 0xdf, 0x2e, 0xd9, 0x3d, 0x8a, 0x9a]);
-}
-
-/// Wrapper type for context parameter used in a fastboot local session.
-pub struct LocalSessionContext(*mut c_void);
-
-impl Protocol<'_, GblFastbootProtocol> {
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var`
-    pub fn get_var<'a>(
-        &self,
-        var: &CStr,
-        args: impl Iterator<Item = &'a CStr> + Clone,
-        out: &mut [u8],
-    ) -> Result<usize> {
-        let mut args_arr = [null(); MAX_ARGS];
-        let num_args = safemath::SafeNum::from(1) + args.clone().count();
-        let args_arr = args_arr.get_mut(..num_args.try_into()?).ok_or(Error::InvalidInput)?;
-        args_arr[0] = var.as_ptr();
-        args_arr[1..].iter_mut().zip(args).for_each(|(l, r)| *l = r.as_ptr());
-        let mut bufsize = out.len();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
-        unsafe {
-            efi_call!(
-                @bufsize bufsize,
-                self.interface()?.get_var,
-                self.interface,
-                args_arr.as_ptr(),
-                args_arr.len(),
-                out.as_mut_ptr(),
-                &mut bufsize
-            )?
-        };
-        Ok(bufsize)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var_all`
-    pub fn get_var_all(&self, mut cb: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
-        struct Callback<'a>(&'a mut dyn FnMut(&[&CStr], &CStr));
-
-        /// Callback C function to be passed to the `get_var_all` function.
-        ///
-        /// # Safety
-        ///
-        /// * Caller must guarantee that `ctx` points to a valid instance of `Callback`, outlives
-        ///   the call, and not being referenced elsewhere.
-        /// * Caller must guarantee that `args` points to an array of NULL-terminated strings with
-        ///   size `len` and outlives the call.
-        /// * Caller must guarantee that `val` points to valid NULL-terminated strings and outlives
-        ///   the call.
-        unsafe extern "C" fn get_var_all_cb(
-            ctx: *mut c_void,
-            args: *const *const c_char,
-            len: usize,
-            val: *const c_char,
-        ) {
-            // SAFETY: By safety requirement of this function, `args` points to an array of
-            // NULL-terminated strings of length `len`.
-            let args =
-                unsafe { from_raw_parts(args, len) }.iter().map(|v| unsafe { CStr::from_ptr(*v) });
-            // SAFETY: By requirement of this function, `ctx` points to a `Callback`.
-            let cb = unsafe { (ctx as *mut Callback).as_mut() }.unwrap();
-            // Checks number of arguments and stores them in an array.
-            let mut args_arr = [c""; MAX_ARGS];
-            match args_arr.get_mut(..len) {
-                Some(v) => {
-                    v.iter_mut().zip(args).for_each(|(l, r)| *l = r);
-                    // SAFETY: By safety requirement of this function `val` points to a
-                    // NULL-terminated string.
-                    (cb.0)(&v, unsafe { CStr::from_ptr(val) })
-                }
-                _ => (cb.0)(&[c"<Number of arguments exceeds limit>"], c""),
-            }
-        }
-
-        // SAFETY:
-        // *`self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // * established by `Protocol::new()`.
-        // * The `ctx` parameter is a valid `Callback` object, outlives the call and not being
-        //   referenced elsewhere(declared inline at the parameter site).
-        // * By UEFI interface requirement, vendor firmware passes array of C strings to
-        //   `get_var_all_cb` that remains valid for the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.get_var_all,
-                self.interface,
-                &mut Callback(&mut cb) as *mut _ as _,
-                Some(get_var_all_cb),
-            )?
-        };
-
-        Ok(())
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.run_oem_function()`
-    pub fn run_oem_function(&self, cmd: &str, buffer: &mut [u8]) -> Result<usize> {
-        let mut bufsize = buffer.len();
-        if !buffer.is_empty() {
-            buffer[0] = 0;
-        }
-
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameter is retained, all parameters outlive the call,
-        // and no pointers are Null.
-        unsafe {
-            efi_call!(
-                @bufsize bufsize,
-                self.interface()?.run_oem_function,
-                self.interface,
-                cmd.as_ptr(),
-                cmd.len(),
-                buffer.as_mut_ptr(),
-                &mut bufsize,
-            )?
-        };
-        Ok(core::cmp::min(bufsize, buffer.iter().position(|c| *c == 0).unwrap_or(buffer.len())))
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_policy()`
-    pub fn get_policy(&self) -> Result<GblEfiFastbootPolicy> {
-        let mut policy: GblEfiFastbootPolicy = Default::default();
-
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
-        unsafe { efi_call!(self.interface()?.get_policy, self.interface, &mut policy)? };
-
-        Ok(policy)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.set_lock()`
-    pub fn set_lock(&self, flags: u64) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.set_lock, self.interface, flags) }
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.clear_lock()`
-    pub fn clear_lock(&self, flags: u64) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.clear_lock, self.interface, flags) }
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_partition_permissions()`
-    pub fn get_partition_permissions(&self, part_name: &str) -> Result<u64> {
-        let mut permissions = 0u64;
-
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
-        unsafe {
-            efi_call!(
-                self.interface()?.get_partition_permissions,
-                self.interface,
-                part_name.as_ptr(),
-                part_name.len(),
-                &mut permissions
-            )?
-        };
-        Ok(permissions)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.start_local_session()`
-    pub fn start_local_session(&self) -> Result<LocalSessionContext> {
-        let mut ctx = null_mut();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
-        unsafe { efi_call!(self.interface()?.start_local_session, self.interface, &mut ctx)? };
-        Ok(LocalSessionContext(ctx))
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.update_local_session()`
-    pub fn update_local_session(&self, ctx: &LocalSessionContext, out: &mut [u8]) -> Result<usize> {
-        let mut bufsize = out.len();
-
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
-        unsafe {
-            efi_call!(
-                @bufsize bufsize,
-                self.interface()?.update_local_session,
-                self.interface,
-                ctx.0, out.as_mut_ptr(),
-                &mut bufsize)?
-        };
-        Ok(bufsize)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.close_local_session()`
-    pub fn close_local_session(&self, ctx: &LocalSessionContext) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
-        unsafe { efi_call!(self.interface()?.close_local_session, self.interface, ctx.0) }
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.wipe_user_data()`
-    pub fn wipe_user_data(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.wipe_user_data, self.interface) }
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.should_stop_in_fastboot()`
-    pub fn should_stop_in_fastboot(&self) -> bool {
-        let Ok(interface) = self.interface() else { return false };
-
-        let Some(should_stop_in_fastboot) = interface.should_stop_in_fastboot else { return false };
-        // SAFETY:
-        // `self.interface` is non-null due to check above.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `should_stop_in_fastboot` is non-null due to check above.
-        // `should_stop_in_fastboot` is responsible for validating its input.
-        unsafe { should_stop_in_fastboot(self.interface) }
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.serial_number`
-    pub fn serial_number(&self) -> Result<&str> {
-        let serial_number = &self.interface()?.serial_number;
-        let null_idx = serial_number.iter().position(|c| *c == 0).unwrap_or(serial_number.len());
-        Ok(from_utf8(&serial_number[..null_idx])?)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.version`
-    pub fn version(&self) -> Result<u32> {
-        Ok(self.interface()?.version)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::{
-        protocol::GetVarAllCallback,
-        test::{generate_protocol, run_test},
-        DeviceHandle, EfiEntry,
-    };
-    use core::{
-        ffi::{c_void, CStr},
-        ptr::null_mut,
-        slice::from_raw_parts_mut,
-    };
-    use efi_types::{EfiStatus, EFI_STATUS_SUCCESS};
-
-    #[test]
-    fn test_serial_number() {
-        run_test(|image_handle, systab_ptr| {
-            // Serial number is shorter than max length and contains non-ASCII unicode.
-            let austria = "sterreich";
-
-            let mut fb = GblEfiFastbootProtocol { ..Default::default() };
-            fb.serial_number.as_mut_slice()[..austria.len()].copy_from_slice(austria.as_bytes());
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-
-            // Don't include trailing Null terminators.
-            assert_eq!(protocol.serial_number().unwrap().len(), 11);
-            assert_eq!(protocol.serial_number().unwrap(), austria);
-        });
-    }
-
-    #[test]
-    fn test_serial_number_max_length() {
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol { serial_number: [71u8; 32], ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-
-            assert_eq!(protocol.serial_number().unwrap().len(), 32);
-            assert_eq!(protocol.serial_number().unwrap(), "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
-        });
-    }
-
-    #[test]
-    fn test_serial_number_invalid_utf8() {
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol { serial_number: [0xF8; 32], ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-
-            assert_eq!(protocol.serial_number(), Err(Error::InvalidInput));
-        });
-    }
-
-    #[test]
-    fn test_get_var() {
-        /// # Safety
-        ///
-        /// * Caller must guarantee that `args` points to an array of NULL-terminated strings with
-        ///   size `num_args`.
-        /// * Caller must guarantee that `out` points to a `[u8]`
-        /// * Caller must guarantee that `out_size` points to a `usize`
-        unsafe extern "C" fn get_var_test(
-            _: *mut GblEfiFastbootProtocol,
-            args: *const *const c_char,
-            num_args: usize,
-            out: *mut u8,
-            out_size: *mut usize,
-        ) -> EfiStatus {
-            // SAFETY: By safety requirement of this function, `args` points to an array of
-            // NULL-terminated strings with length `num_args`.
-            let args = unsafe { from_raw_parts(args, num_args) }
-                .iter()
-                .map(|v| unsafe { CStr::from_ptr(*v) })
-                .collect::<Vec<_>>();
-            assert_eq!(args, [c"var", c"arg1", c"arg2"]);
-            // SAFETY: By safety requirement of this function, `out_size` points to a `usize`;
-            let out_size = &mut unsafe { *out_size };
-            // SAFETY: By safety requirement of this function, `out` points to a `[u8]`;
-            let out = unsafe { from_raw_parts_mut(out, *out_size) };
-            out.clone_from_slice(c"val".to_bytes());
-            *out_size = c"val".to_bytes().len();
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut fb =
-                GblEfiFastbootProtocol { get_var: Some(get_var_test), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-            let mut out = [0u8; 3];
-            let args = [c"arg1", c"arg2"];
-            assert_eq!(protocol.get_var(c"var", args.iter().copied(), &mut out[..]), Ok(3));
-            assert_eq!(&out, b"val");
-        });
-    }
-
-    #[test]
-    fn test_get_var_all() {
-        /// # Safety
-        ///
-        /// * Caller must guarantee that `ctx` points to data needed by function pointer `cb`.
-        unsafe extern "C" fn test_get_var_all(
-            _: *mut GblEfiFastbootProtocol,
-            ctx: *mut c_void,
-            cb: GetVarAllCallback,
-        ) -> EfiStatus {
-            for (args, val) in [
-                ([c"foo", c"foo_arg1", c"foo_arg2"], c"foo_val"),
-                ([c"bar", c"bar_arg1", c"bar_arg2"], c"bar_val"),
-            ] {
-                let args = args.map(|v| v.as_ptr());
-                // SAFETY:
-                // * `args` is an array of NULL-terminated strings. `val` is a NULL-terminated
-                //   string.
-                // * By safety requirement of this function, `ctx` points to a valid type of data
-                //   needed by `cb`.
-                unsafe { (cb.unwrap())(ctx, args.as_ptr(), args.len(), val.as_ptr()) };
-            }
-            EFI_STATUS_SUCCESS
-        }
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol {
-                get_var_all: Some(test_get_var_all),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-            let mut out = vec![];
-            protocol
-                .get_var_all(|args, val| {
-                    let args_str =
-                        args.iter().map(|v| v.to_str().unwrap()).collect::<Vec<_>>().join(":");
-                    out.push(format!("{args_str}: {}", val.to_str().unwrap()))
-                })
-                .unwrap();
-            assert_eq!(out, ["foo:foo_arg1:foo_arg2: foo_val", "bar:bar_arg1:bar_arg2: bar_val",])
-        });
-    }
-
-    #[test]
-    fn test_get_var_all_exceeds_max_arguments() {
-        /// # Safety
-        ///
-        /// * Caller must guarantee that `ctx` points to data needed by function pointer `cb`.
-        unsafe extern "C" fn test_get_var_all(
-            _: *mut GblEfiFastbootProtocol,
-            ctx: *mut c_void,
-            cb: GetVarAllCallback,
-        ) -> EfiStatus {
-            let args = [c"".as_ptr(); MAX_ARGS + 1];
-            // SAFETY:
-            // * `args` is an array of NULL-terminated strings. `val` is a NULL-terminated
-            //   string.
-            // * By safety requirement of this function, `ctx` points to a valid type of data
-            //   needed by `cb`.
-            unsafe { (cb.unwrap())(ctx, args.as_ptr(), args.len(), c"".as_ptr()) };
-            EFI_STATUS_SUCCESS
-        }
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol {
-                get_var_all: Some(test_get_var_all),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-            let mut out = vec![];
-            protocol
-                .get_var_all(|args, val| {
-                    let args_str =
-                        args.iter().map(|v| v.to_str().unwrap()).collect::<Vec<_>>().join(":");
-                    out.push(format!("{args_str}: {}", val.to_str().unwrap()))
-                })
-                .unwrap();
-            assert_eq!(out, ["<Number of arguments exceeds limit>: "])
-        });
-    }
-
-    #[test]
-    fn test_should_stop_in_fastboot() {
-        unsafe extern "C" fn test_should_stop_in_fastboot(_: *mut GblEfiFastbootProtocol) -> bool {
-            true
-        }
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol {
-                should_stop_in_fastboot: Some(test_should_stop_in_fastboot),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-            assert!(protocol.should_stop_in_fastboot());
-        });
-    }
-
-    #[test]
-    fn test_should_stop_in_fastboot_no_interface() {
-        run_test(|image_handle, systab_ptr| {
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            // SAFETY: `protocol.interface` is explicitly null for testing.
-            let protocol = unsafe {
-                Protocol::<GblFastbootProtocol>::new(
-                    DeviceHandle::new(null_mut()),
-                    null_mut(),
-                    &efi_entry,
-                )
-            };
-            assert!(!protocol.should_stop_in_fastboot());
-        });
-    }
-
-    #[test]
-    fn test_should_stop_in_fastboot_no_method() {
-        run_test(|image_handle, systab_ptr| {
-            let mut fb: GblEfiFastbootProtocol = Default::default();
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-            assert!(!protocol.should_stop_in_fastboot());
-        });
-    }
-}
diff --git a/gbl/libefi/src/protocol/gbl_efi_fastboot_usb.rs b/gbl/libefi/src/protocol/gbl_efi_fastboot_usb.rs
deleted file mode 100644
index 7c3e385..0000000
--- a/gbl/libefi/src/protocol/gbl_efi_fastboot_usb.rs
+++ /dev/null
@@ -1,138 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `GBL_EFI_FASTBOOT_USB_PROTOCOL`.
-
-use crate::{
-    protocol::{Protocol, ProtocolInfo},
-    utils::with_timeout,
-    {efi_call, Event},
-};
-use core::time::Duration;
-use efi_types::{EfiGuid, GblEfiFastbootUsbProtocol};
-use gbl_async::yield_now;
-use liberror::{Error, Result};
-
-/// GBL_EFI_FASTBOOT_USB_PROTOCOL
-pub struct GblFastbootUsbProtocol;
-
-impl ProtocolInfo for GblFastbootUsbProtocol {
-    type InterfaceType = GblEfiFastbootUsbProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x6281a893, 0xac23, 0x4ca7, [0xb2, 0x81, 0x34, 0x0e, 0xf8, 0x16, 0x89, 0x55]);
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, GblFastbootUsbProtocol> {
-    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_interface_start()`
-    pub fn fastboot_usb_interface_start(&self) -> Result<usize> {
-        let mut max_packet_size = 0;
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` and `max_packet_size` are input/output parameters, outlive the call and
-        // will not be retained.
-        unsafe {
-            efi_call!(
-                self.interface()?.fastboot_usb_interface_start,
-                self.interface,
-                &mut max_packet_size,
-            )?;
-        }
-        Ok(max_packet_size)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_interface_stop()`
-    pub fn fastboot_usb_interface_stop(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter, outlives the call, and will not be retained.
-        unsafe { efi_call!(self.interface()?.fastboot_usb_interface_stop, self.interface,) }
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_receive()`
-    pub fn fastboot_usb_receive(&self, out: &mut [u8]) -> Result<usize> {
-        let mut out_size = out.len();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface`, `out_size` and `buffer` are input/output parameters, outlive the call
-        // and will not be retained.
-        unsafe {
-            efi_call!(
-                @bufsize out_size,
-                self.interface()?.fastboot_usb_receive,
-                self.interface,
-                &mut out_size,
-                out.as_mut_ptr() as _,
-            )?;
-        }
-
-        Ok(out_size)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_send()`
-    pub fn fastboot_usb_send(&self, data: &[u8]) -> Result<usize> {
-        let mut out_size = data.len();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface`, `out_size` and `buffer` are input/output parameters, outlive the call
-        // and will not be retained.
-        unsafe {
-            efi_call!(
-                @bufsize out_size,
-                self.interface()?.fastboot_usb_send,
-                self.interface,
-                &mut out_size,
-                data.as_ptr() as _,
-            )?;
-        }
-
-        Ok(out_size)
-    }
-
-    /// Returns the `GBL_EFI_FASTBOOT_USB_PROTOCOL.wait_for_send_completion` EFI event.
-    pub fn wait_for_send_completion(&self) -> Result<Event> {
-        Ok(Event::new_unowned(self.interface()?.wait_for_send_completion))
-    }
-
-    /// Receives the next packet from the USB.
-    pub async fn receive_packet(&self, out: &mut [u8]) -> Result<usize> {
-        loop {
-            match self.fastboot_usb_receive(out) {
-                Ok(out_size) => return Ok(out_size),
-                Err(Error::NotReady) => yield_now().await,
-                Err(e) => return Err(e),
-            }
-        }
-    }
-
-    /// A helper to wait for the send event to signal.
-    async fn wait_send(&self) -> Result<()> {
-        let bs = self.efi_entry().system_table().boot_services();
-        while !bs.check_event(&self.wait_for_send_completion()?)? {
-            yield_now().await;
-        }
-        Ok(())
-    }
-
-    /// Sends a packet over the USB.
-    pub async fn send_packet(&self, data: &[u8], timeout: Duration) -> Result<()> {
-        self.fastboot_usb_send(data)?;
-        with_timeout(self.efi_entry(), self.wait_send(), timeout).await?.ok_or(Error::Timeout)?
-    }
-}
diff --git a/gbl/libefi/src/protocol/gbl_efi_image_loading.rs b/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
deleted file mode 100644
index 15c5e93..0000000
--- a/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
+++ /dev/null
@@ -1,1235 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_IMAGE_LOADING_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use arrayvec::ArrayVec;
-use core::mem::{size_of, MaybeUninit};
-use efi_types::{
-    EfiGuid, GblEfiImageBuffer, GblEfiImageInfo, GblEfiImageLoadingProtocol, GblEfiPartitionName,
-    PARTITION_NAME_LEN_U16,
-};
-use liberror::{Error, Result};
-use spin::Mutex;
-
-/// GBL_IMAGE_LOADING_PROTOCOL
-pub struct GblImageLoadingProtocol;
-
-impl ProtocolInfo for GblImageLoadingProtocol {
-    type InterfaceType = GblEfiImageLoadingProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xdb84b4fa, 0x53bd, 0x4436, [0x98, 0xa7, 0x4e, 0x02, 0x71, 0x42, 0x8b, 0xa8]);
-}
-
-/// Max length of partition name in UTF8 in bytes.
-pub const PARTITION_NAME_LEN_U8: usize = size_of::<char>() * PARTITION_NAME_LEN_U16;
-
-const MAX_ARRAY_SIZE: usize = 100;
-static RETURNED_BUFFERS: Mutex<ArrayVec<usize, MAX_ARRAY_SIZE>> = Mutex::new(ArrayVec::new_const());
-
-/// Wrapper class for buffer received with [get_buffer] function.
-///
-/// Helps to keep track of allocated memory and avoid getting same buffer more than once.
-#[derive(Debug)]
-pub struct EfiImageBuffer {
-    buffer: Option<&'static mut [MaybeUninit<u8>]>,
-}
-
-/// Represents either static reserved memory space or memory to be allocated dynamically.
-#[derive(Debug)]
-pub enum EfiImageBufferInfo {
-    /// Static memory space returned from UEFI firmware.
-    Buffer(EfiImageBuffer),
-    /// Target buffer should be dynamically allocated by the given size.
-    AllocSize(usize),
-}
-
-impl EfiImageBufferInfo {
-    /// Gets as EfiImageBuffer::Buffer;
-    pub fn buffer(&mut self) -> Option<&mut [MaybeUninit<u8>]> {
-        match self {
-            Self::Buffer(EfiImageBuffer { buffer: Some(v) }) => Some(v),
-            _ => None,
-        }
-    }
-
-    /// Move buffer ownership out of EfiImageBuffer, and consume it.
-    pub fn take(self) -> Option<&'static mut [MaybeUninit<u8>]> {
-        match self {
-            Self::Buffer(mut v) => Some(v.take()),
-            _ => None,
-        }
-    }
-}
-
-impl EfiImageBuffer {
-    // # Safety
-    //
-    // `gbl_buffer` must represent valid buffer.
-    //
-    // # Return
-    //
-    // Err(EFI_STATUS_INVALID_PARAMETER) - If `gbl_buffer.Memory` == NULL
-    // Err(EFI_STATUS_ALREADY_STARTED) - Requested buffer was already returned and is still in use.
-    // Err(err) - on error
-    // Ok(_) - on success
-    unsafe fn new(gbl_buffer: GblEfiImageBuffer) -> Result<EfiImageBuffer> {
-        if gbl_buffer.Memory.is_null() {
-            return Err(Error::InvalidInput);
-        }
-
-        let addr = gbl_buffer.Memory as usize;
-        let mut returned_buffers = RETURNED_BUFFERS.lock();
-        if returned_buffers.contains(&addr) {
-            return Err(Error::AlreadyStarted);
-        }
-        returned_buffers.push(addr);
-
-        // SAFETY:
-        // `gbl_buffer.Memory` is guaranteed to be not null
-        // This code is relying on EFI protocol implementation to provide valid buffer pointer
-        // to memory region of size `gbl_buffer.SizeBytes`.
-        Ok(EfiImageBuffer {
-            buffer: Some(unsafe {
-                core::slice::from_raw_parts_mut(
-                    gbl_buffer.Memory as *mut MaybeUninit<u8>,
-                    gbl_buffer.SizeBytes,
-                )
-            }),
-        })
-    }
-
-    /// Move buffer ownership out of EfiImageBuffer, and consume it.
-    pub fn take(&mut self) -> &'static mut [MaybeUninit<u8>] {
-        self.buffer.take().unwrap()
-    }
-
-    // Removes address from `RETURNED_BUFFERS`.
-    //
-    // # Safety
-    //
-    // Caller must guarantee that address is not referenced anymore.
-    unsafe fn release(address: usize) {
-        let mut returned_buffers = RETURNED_BUFFERS.lock();
-        let res = returned_buffers.iter().position(|&val| val == address);
-        debug_assert!(
-            res.is_some(),
-            "EfiImageBuffer::release trying to release address ({address}) that is not tracked"
-        );
-        if let Some(pos) = res {
-            returned_buffers.swap_remove(pos);
-        }
-    }
-}
-
-impl Drop for EfiImageBuffer {
-    fn drop(&mut self) {
-        if self.buffer.is_none() {
-            return;
-        }
-
-        // SAFETY:
-        // EfiIMageBuffer is the only owner of the buffer. The only way to get address for it is to
-        // call `take()` which consumes `self.buffer`, which we check above.
-        unsafe { EfiImageBuffer::release((*self.buffer.as_ref().unwrap()).as_ptr() as usize) };
-    }
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, GblImageLoadingProtocol> {
-    /// Wrapper of `GBL_IMAGE_LOADING_PROTOCOL.get_buffer()`
-    ///
-    /// # Return
-    /// Ok(Some(EfiImageBuffer)) if buffer was successfully provided,
-    /// Ok(None) if buffer was not provided
-    /// Err(Error::EFI_STATUS_BUFFER_TOO_SMALL) if provided buffer is too small
-    /// Err(Error::EFI_STATUS_INVALID_PARAMETER) if received buffer is NULL
-    /// Err(Error::EFI_STATUS_ALREADY_STARTED) buffer was already returned and is still in use.
-    /// Err(err) if `err` occurred
-    pub fn get_buffer(&self, gbl_image_info: &GblEfiImageInfo) -> Result<EfiImageBufferInfo> {
-        let mut gbl_buffer: GblEfiImageBuffer = Default::default();
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` and `gbl_buffer` are input/output parameters, outlive the call and
-        // will not be retained.
-        // `gbl_buffer` returned by this call must not overlap, and will be checked by
-        // `EfiImageBuffer`
-        unsafe {
-            efi_call!(
-                @bufsize gbl_image_info.SizeBytes,
-                self.interface()?.get_buffer,
-                self.interface,
-                gbl_image_info,
-                &mut gbl_buffer
-            )?;
-        }
-
-        if gbl_buffer.SizeBytes < gbl_image_info.SizeBytes {
-            return Err(Error::BufferTooSmall(Some(gbl_image_info.SizeBytes)));
-        } else if gbl_buffer.Memory.is_null() {
-            return Ok(EfiImageBufferInfo::AllocSize(gbl_buffer.SizeBytes));
-        }
-
-        // SAFETY:
-        // `gbl_buffer.Memory` must be not null. This checked in `new()` call
-        // `gbl_buffer.Size` must be valid size of the buffer.
-        // This protocol is relying on EFI protocol implementation to provide valid buffer pointer
-        // to memory region of size `gbl_buffer.SizeBytes`.
-        let image_buffer = EfiImageBufferInfo::Buffer(unsafe { EfiImageBuffer::new(gbl_buffer)? });
-
-        Ok(image_buffer)
-    }
-
-    /// Wrapper of `GBL_IMAGE_LOADING_PROTOCOL.get_verify_partitions()`
-    ///
-    /// # Result
-    /// Err(BufferTooSmall(Some(size))) - when provided `partition_names` is less than expected
-    /// `size`
-    /// Err(err) - if error occurred.
-    /// Ok(len) - will return number of `GblEfiPartitionName`s copied to `partition_names` slice.
-    pub fn get_verify_partitions(
-        &self,
-        partition_names: &mut [GblEfiPartitionName],
-    ) -> Result<usize> {
-        let partition_count_in: usize = partition_names.len();
-        let mut partition_count: usize = partition_count_in;
-
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter, outlives the call, and will not be retained.
-        // `partition_count` must be set to valid length of `partition_names` array after the call.
-        // `partition_names` must be valid array of length `partition_count` after the call.
-        unsafe {
-            efi_call!(
-                @bufsize partition_count,
-                self.interface()?.get_verify_partitions,
-                self.interface,
-                &mut partition_count,
-                partition_names.as_mut_ptr(),
-            )?;
-        }
-
-        Ok(partition_count)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::{
-        protocol::gbl_efi_image_loading::GblImageLoadingProtocol, test::run_test, DeviceHandle,
-        EfiEntry,
-    };
-    use core::{ffi::c_void, iter::zip, ptr::null_mut};
-    use efi_types::{
-        EfiStatus, EFI_STATUS_BAD_BUFFER_SIZE, EFI_STATUS_BUFFER_TOO_SMALL,
-        EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
-    };
-    use spin::MutexGuard;
-    use std::cell::RefCell;
-    use std::collections::HashSet;
-
-    const UCS2_STR: [u16; 8] = [0x2603, 0x0073, 0x006e, 0x006f, 0x0077, 0x006d, 0x0061, 0x006e];
-    const UTF8_STR: &str = "snowman";
-    const PARTITIONS_MAX: usize = 128;
-
-    fn get_buffer_utf8() -> [[u8; PARTITION_NAME_LEN_U8]; PARTITIONS_MAX] {
-        [[0; PARTITION_NAME_LEN_U8]; PARTITIONS_MAX]
-    }
-
-    fn get_printable_utf16() -> Vec<u16> {
-        (0x0021..0x007e).collect::<Vec<u16>>()
-    }
-
-    fn get_printable_string() -> String {
-        String::from_utf8((0x21..0x7e).collect::<Vec<u8>>()).unwrap()
-    }
-
-    #[test]
-    fn test_partition_name_get_str() {
-        let mut buffer = [0u8; 100];
-        // empty string
-        assert_eq!(GblEfiPartitionName::from([0u16]).get_str(&mut buffer).unwrap(), "");
-        assert_eq!(GblEfiPartitionName::from([0u16]).get_str(&mut buffer).unwrap(), "");
-        assert_eq!(GblEfiPartitionName::from([0x0000]).get_str(&mut buffer[..0]).unwrap(), "");
-
-        // Special characters
-        assert_eq!(GblEfiPartitionName::from(UCS2_STR).get_str(&mut buffer).unwrap(), UTF8_STR);
-
-        // Null character in the middle
-        assert_eq!(
-            GblEfiPartitionName::from([0x006d, 0x0075, 0x0000, 0x0073, 0x0069, 0x0063])
-                .get_str(&mut buffer),
-            Ok("mu")
-        );
-
-        // Null character at the end
-        assert_eq!(
-            GblEfiPartitionName::from([0x006d, 0x0075, 0x0073, 0x0069, 0x0063, 0x0000])
-                .get_str(&mut buffer),
-            Ok("music")
-        );
-
-        // exact buffer size
-        assert_eq!(
-            GblEfiPartitionName::from([0x006d, 0x0075, 0x0073, 0x0069, 0x0063])
-                .get_str(&mut buffer[..5]),
-            Ok("music")
-        );
-        assert_eq!(
-            GblEfiPartitionName::from([0x006d, 0x0075, 0x0000, 0x0073, 0x0069, 0x0063])
-                .get_str(&mut buffer[..2]),
-            Ok("mu")
-        );
-    }
-
-    #[test]
-    fn test_partition_name_get_str_small_buffer() {
-        let mut buffer = [0u8; 8];
-        let partition_name: GblEfiPartitionName = UCS2_STR.into();
-        assert_eq!(partition_name.get_str(&mut buffer), Err(10usize));
-    }
-
-    fn generate_protocol<'a, P: ProtocolInfo>(
-        efi_entry: &'a EfiEntry,
-        proto: &'a mut P::InterfaceType,
-    ) -> Protocol<'a, P> {
-        // SAFETY:
-        // proto is a valid pointer and lasts at least as long as efi_entry.
-        unsafe { Protocol::<'a, P>::new(DeviceHandle::new(null_mut()), proto, efi_entry) }
-    }
-
-    #[test]
-    fn test_proto_get_partitions_count() {
-        const EXPECTED_PARTITIONS_NUM: usize = 2;
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            _: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            assert!(!number_of_partitions.is_null());
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-
-            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
-            EFI_STATUS_BUFFER_TOO_SMALL
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let mut partitions: [GblEfiPartitionName; 0] = Default::default();
-            assert_eq!(
-                protocol.get_verify_partitions(&mut partitions).unwrap_err(),
-                Error::BufferTooSmall(Some(EXPECTED_PARTITIONS_NUM))
-            );
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_count_error() {
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            _: *mut usize,
-            _: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let mut partitions: [GblEfiPartitionName; 0] = Default::default();
-            assert_eq!(
-                protocol.get_verify_partitions(&mut partitions).unwrap_err(),
-                Error::InvalidInput
-            );
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_len_and_value() {
-        const EXPECTED_PARTITIONS_NUM: usize = 1;
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            partitions: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-
-            match *number_of_partitions {
-                n if n < EXPECTED_PARTITIONS_NUM => {
-                    *number_of_partitions = EXPECTED_PARTITIONS_NUM;
-                    EFI_STATUS_BUFFER_TOO_SMALL
-                }
-                _ => {
-                    // SAFETY
-                    // `partitions` must be valid array of size `number_of_partitions`
-                    let partitions = unsafe {
-                        core::slice::from_raw_parts_mut(partitions, *number_of_partitions)
-                    };
-                    *number_of_partitions = 1;
-                    partitions[0].StrUtf16[..UCS2_STR.len()].copy_from_slice(&UCS2_STR);
-                    EFI_STATUS_SUCCESS
-                }
-            }
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut buffer_utf8 = get_buffer_utf8();
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions: [GblEfiPartitionName; 2] = Default::default();
-
-            assert_eq!(
-                protocol.get_verify_partitions(&mut partitions[..0]).unwrap_err(),
-                Error::BufferTooSmall(Some(EXPECTED_PARTITIONS_NUM))
-            );
-            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
-            assert_eq!(verify_partitions_len, 1);
-            assert_eq!(partitions[0].get_str(&mut buffer_utf8[0]), Ok(UTF8_STR));
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_zero_len() {
-        const EXPECTED_PARTITIONS_NUM: usize = 1;
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            _: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-            assert_eq!(*number_of_partitions, 0);
-            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
-            EFI_STATUS_BUFFER_TOO_SMALL
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions: [GblEfiPartitionName; 0] = Default::default();
-
-            let verify_partitions_res = protocol.get_verify_partitions(&mut partitions);
-            assert_eq!(
-                verify_partitions_res.unwrap_err(),
-                Error::BufferTooSmall(Some(EXPECTED_PARTITIONS_NUM))
-            );
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_less_than_buffer() {
-        const EXPECTED_PARTITIONS_NUM: usize = 1;
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            partitions: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-
-            assert!(!partitions.is_null());
-            assert!(*number_of_partitions > 0);
-
-            // SAFETY
-            // `partitions` must be valid array of size `number_of_partitions`
-            let partitions =
-                unsafe { core::slice::from_raw_parts_mut(partitions, *number_of_partitions) };
-            partitions[0].StrUtf16[..UCS2_STR.len()].copy_from_slice(&UCS2_STR);
-            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut buffer_utf8 = get_buffer_utf8();
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions: [GblEfiPartitionName; 2] = Default::default();
-
-            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
-            assert_eq!(verify_partitions_len, EXPECTED_PARTITIONS_NUM);
-            assert_eq!(partitions[0].get_str(&mut buffer_utf8[0]), Ok(UTF8_STR));
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_name_max() {
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            partitions: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            let printable_utf16 = get_printable_utf16();
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-
-            assert!(!partitions.is_null());
-            assert!(*number_of_partitions > 0);
-
-            // SAFETY
-            // `partitions` must be valid array of size `number_of_partitions`
-            let partitions =
-                unsafe { core::slice::from_raw_parts_mut(partitions, *number_of_partitions) };
-
-            let partition_names: [GblEfiPartitionName; PARTITIONS_MAX] = (0
-                ..PARTITION_NAME_LEN_U16)
-                .cycle()
-                .take(PARTITIONS_MAX)
-                .map(|i| printable_utf16[i..i + PARTITION_NAME_LEN_U16].into())
-                .collect::<Vec<_>>()
-                .try_into()
-                .unwrap();
-
-            *number_of_partitions = partition_names.len();
-
-            for (p_out, p_gen) in zip(partitions.iter_mut(), partition_names.iter()) {
-                *p_out = *p_gen;
-            }
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut buffer_utf8 = get_buffer_utf8();
-            let printable_str = get_printable_string();
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions = [GblEfiPartitionName::default(); PARTITIONS_MAX];
-            let expected_strs: Vec<&str> = (0..PARTITION_NAME_LEN_U16)
-                .cycle()
-                .take(PARTITIONS_MAX)
-                .map(|i| &printable_str[i..i + PARTITION_NAME_LEN_U16])
-                .collect();
-
-            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
-            assert_eq!(verify_partitions_len, PARTITIONS_MAX);
-
-            assert!(zip(partitions.iter(), expected_strs.iter())
-                .all(|(p, expected_str)| { p.get_str(&mut buffer_utf8[0]) == Ok(*expected_str) }));
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions() {
-        const EXPECTED_PARTITIONS_NUM: usize = 2;
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            partitions: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-
-            assert!(!partitions.is_null());
-            assert!(*number_of_partitions > 0);
-
-            // SAFETY
-            // `partitions` must be valid array of size `number_of_partitions`
-            let partitions =
-                unsafe { core::slice::from_raw_parts_mut(partitions, *number_of_partitions) };
-            partitions[0].StrUtf16[..UCS2_STR.len()].copy_from_slice(&UCS2_STR);
-            partitions[1].StrUtf16[..UCS2_STR.len() - 1].copy_from_slice(&UCS2_STR[1..]);
-            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut buffer_utf8 = get_buffer_utf8();
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions: [GblEfiPartitionName; EXPECTED_PARTITIONS_NUM] = Default::default();
-
-            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
-            assert_eq!(verify_partitions_len, EXPECTED_PARTITIONS_NUM);
-
-            let mut char_idx = UTF8_STR.char_indices();
-            char_idx.next();
-            let (next_char_pos, _) = char_idx.next().unwrap();
-
-            assert_eq!(partitions[0].get_str(&mut buffer_utf8[0]), Ok(UTF8_STR));
-            assert_eq!(partitions[1].get_str(&mut buffer_utf8[1]), Ok(&UTF8_STR[next_char_pos..]));
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_empty() {
-        const EXPECTED_PARTITIONS_NUM: usize = 0;
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            number_of_partitions: *mut usize,
-            partitions: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            // SAFETY
-            // `number_of_partitions` must be valid pointer to usize
-            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
-            assert!(!partitions.is_null());
-            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions: [GblEfiPartitionName; 2] = Default::default();
-
-            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
-            assert_eq!(verify_partitions_len, EXPECTED_PARTITIONS_NUM);
-        });
-    }
-
-    #[test]
-    fn test_proto_get_partitions_error() {
-        unsafe extern "C" fn get_verify_partitions(
-            _: *mut GblEfiImageLoadingProtocol,
-            _: *mut usize,
-            _: *mut GblEfiPartitionName,
-        ) -> EfiStatus {
-            EFI_STATUS_BAD_BUFFER_SIZE
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut image_loading = GblEfiImageLoadingProtocol {
-                get_verify_partitions: Some(get_verify_partitions),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let mut partitions: [GblEfiPartitionName; 1] = Default::default();
-
-            assert!(protocol.get_verify_partitions(&mut partitions).is_err());
-        });
-    }
-
-    // Mutex to make sure tests that use `static RETURNED_BUFFERS` do not run in parallel to avoid
-    // unexpected results since this is global static that would be shared between tests. And can
-    // overflow due to amount of tests.
-    //
-    // See MEMORY_TEST thread local variable that should be used for convenience.
-    static GET_BUFFER_MUTEX: Mutex<()> = Mutex::new(());
-
-    // Size of MEMORY_TEST buffers
-    const MEMORY_TEST_BUF_SIZE: usize = 100;
-
-    // Helper struct for safe acquisition of the memory and releasing it on exit
-    struct MemoryTest<'a> {
-        // Tracking if test guard was acquired with `start()`
-        init: bool,
-        // Keep track of all buffers returned
-        returned_buffers: HashSet<*mut [u8; MEMORY_TEST_BUF_SIZE]>,
-        // Store same buffer value for `get_memory_same()` calls.
-        same_buffer: Option<*mut c_void>,
-        // It is necessary to run 1 test at a time that uses UEFI `get_buffer()`.
-        // Because it is uses static size array to track returned values to prevent reusing same
-        // buffer. With current number of test if they run simultaneously there are situations when
-        // array limit is reached and unlucky test will fail. To prevent this flakiness this guard
-        // is used.
-        _get_buffer_guard: MutexGuard<'a, ()>,
-    }
-
-    thread_local! {
-        static MEMORY_TEST: RefCell<MemoryTest<'static>> = RefCell::new(MemoryTest::new());
-    }
-    struct MemoryTestInitGuard {}
-
-    impl Drop for MemoryTestInitGuard {
-        fn drop(&mut self) {
-            MEMORY_TEST.with_borrow_mut(|v| v.stop());
-        }
-    }
-
-    // Helper implementation for getting raw buffers for `get_buffer()` calls.
-    // And cleanly releasing buffers at the end of the test to prevent memory leaks.
-    //
-    // Use `thread_local` static MEMORY_TEST variable.
-    //
-    // ```
-    // let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-    // ...
-    // buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
-    // ...
-    // ```
-    // _memory_guard will make sure to cleanup all memory that was retrieved by `get_memory()` call
-    //
-    // Note:
-    // If using raw EfiImageBuffer, there is no need for this helper. Since the structure does
-    // cleaning on its own.
-    // Except when using `EfiImageBuffer::take()` then manual `EfiImageBuffer::release()` must be
-    // used.
-    impl MemoryTest<'_> {
-        fn new() -> Self {
-            MemoryTest {
-                init: false,
-                returned_buffers: HashSet::new(),
-                same_buffer: None,
-                _get_buffer_guard: GET_BUFFER_MUTEX.lock(),
-            }
-        }
-
-        fn start(&mut self) -> MemoryTestInitGuard {
-            assert!(!self.init);
-            self.init = true;
-            MemoryTestInitGuard {}
-        }
-
-        // Return heap allocated buffer, and keep track of its address
-        // To verify it was properly released
-        //
-        // # Safety
-        //
-        // Returned pointers must not be used after guard returned by `start()`
-        // is destroyed.
-        unsafe fn get_memory(&mut self) -> *mut c_void {
-            assert!(self.init);
-            let ptr = Box::into_raw(Box::new([0u8; MEMORY_TEST_BUF_SIZE]));
-            assert!(self.returned_buffers.insert(ptr));
-            ptr as *mut c_void
-        }
-
-        // Return same buffer for all calls, allocating and tracking it only for first call.
-        //
-        // # Safety
-        //
-        // Returned pointers must not be used after guard returned by `start()`
-        // is destroyed.
-        unsafe fn get_memory_same(&mut self) -> *mut c_void {
-            if self.same_buffer.is_none() {
-                // SAFETY:
-                // This function has same requirements as `get_memory()`
-                let address = unsafe { self.get_memory() };
-
-                self.same_buffer = Some(address);
-            }
-
-            *self.same_buffer.as_mut().unwrap()
-        }
-
-        // Clear address from buffers returned list
-        // Which allows to reuse it in other tests.
-        fn stop(&mut self) {
-            assert!(self.init);
-            self.init = false;
-            self.same_buffer = None;
-            for ptr in self.returned_buffers.drain() {
-                // SAFETY:
-                // `ptr` is valid since was created by `Box::into_raw()`.
-                // Double free is covered by safety requirements for this function. (`release_memory()`
-                // must be called only on buffer holding the only reference to buffer.)
-                // As well as tracking `returned_buffers` and asserting remove in the line above.
-                unsafe {
-                    let _restore_box = Box::from_raw(ptr);
-                }
-            }
-        }
-    }
-
-    #[test]
-    fn test_proto_get_buffer_error() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            _: *const GblEfiImageInfo,
-            _: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo = Default::default();
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            assert!(protocol.get_buffer(&gbl_image_info).is_err());
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer_return_alloc_size() {
-        // SAFETY:
-        // * Caler must guarantee that `buffer` points to a valid instance of `GblEfiImageBuffer`.
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            _: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            // SAFETY
-            // By safety requirement of this function, `buffer` points to a valid instance of
-            // `GblEfiImageBuffer`.
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-            buffer.Memory = null_mut();
-            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            assert!(matches!(
-                protocol.get_buffer(&gbl_image_info),
-                Ok(EfiImageBufferInfo::AllocSize(MEMORY_TEST_BUF_SIZE))
-            ));
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer_zero_size() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            // SAFETY:
-            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
-            }
-            buffer.SizeBytes = 0;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo = Default::default();
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            let mut res = protocol.get_buffer(&gbl_image_info).unwrap();
-            assert!(res.buffer().as_ref().unwrap().is_empty());
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer_small() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            // SAFETY
-            // `image_info` must be valid pointer to `GblEfiImageInfo`
-            let image_info = unsafe { image_info.as_ref() }.unwrap();
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            // SAFETY:
-            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
-            }
-            buffer.SizeBytes = image_info.SizeBytes - 1;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 10 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            let res = protocol.get_buffer(&gbl_image_info);
-            assert_eq!(res.unwrap_err(), Error::BufferTooSmall(Some(10)));
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            // SAFETY:
-            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
-            }
-            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            let mut buf = protocol.get_buffer(&gbl_image_info).unwrap();
-            assert_ne!(buf.buffer().as_ref().unwrap().as_ptr(), null_mut());
-            assert_eq!(buf.buffer().as_ref().unwrap().len(), 100);
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer_image_type() {
-        const IMAGE_TYPE_STR: &'static str = "test";
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            // SAFETY
-            // `image_info` must be valid pointer to `GblEfiImageInfo`
-            let image_info = unsafe { image_info.as_ref() }.unwrap();
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            let mut buffer_utf8 = [0u8; 100];
-            assert_eq!(
-                GblEfiPartitionName::from(image_info.ImageType).get_str(&mut buffer_utf8).unwrap(),
-                IMAGE_TYPE_STR
-            );
-
-            // SAFETY:
-            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
-            }
-            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let mut image_type = [0u16; PARTITION_NAME_LEN_U16];
-            image_type[..4].copy_from_slice(&IMAGE_TYPE_STR.encode_utf16().collect::<Vec<u16>>());
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: image_type, SizeBytes: 100 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            assert!(protocol.get_buffer(&gbl_image_info).is_ok());
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer_double_call() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            // SAFETY:
-            // `get_memory_same()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory_same());
-            }
-            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            let _buf = protocol.get_buffer(&gbl_image_info).unwrap();
-            assert_eq!(protocol.get_buffer(&gbl_image_info).unwrap_err(), Error::AlreadyStarted);
-        });
-    }
-
-    #[test]
-    fn test_proto_get_buffer_double_call_after_drop() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            // SAFETY:
-            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory_same());
-            }
-            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            protocol.get_buffer(&gbl_image_info).unwrap();
-            protocol.get_buffer(&gbl_image_info).unwrap();
-        });
-    }
-
-    #[test]
-    #[should_panic]
-    fn test_proto_get_buffer_too_many_times() {
-        unsafe extern "C" fn get_buffer(
-            _: *mut GblEfiImageLoadingProtocol,
-            image_info: *const GblEfiImageInfo,
-            buffer: *mut GblEfiImageBuffer,
-        ) -> EfiStatus {
-            assert!(!image_info.is_null());
-            assert!(!buffer.is_null());
-            // SAFETY
-            // `buffer` must be valid pointer to `GblEfiImageBuffer`
-            let buffer = unsafe { buffer.as_mut() }.unwrap();
-
-            // SAFETY:
-            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
-            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
-            // Same function where `start()` guard is acquired, so it will not outlive guard.
-            unsafe {
-                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
-            }
-            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
-
-            EFI_STATUS_SUCCESS
-        }
-
-        run_test(|image_handle, systab_ptr| {
-            let gbl_image_info: GblEfiImageInfo =
-                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
-            let mut image_loading =
-                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol =
-                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
-
-            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-            let mut keep_alive: Vec<EfiImageBufferInfo> = vec![];
-            for _ in 1..=MAX_ARRAY_SIZE + 1 {
-                keep_alive.push(protocol.get_buffer(&gbl_image_info).unwrap());
-            }
-        });
-    }
-
-    #[test]
-    fn test_efi_image_buffer() {
-        let mut v = vec![0u8; 1];
-        let gbl_buffer =
-            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
-
-        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let res = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        assert!(res.is_ok());
-    }
-
-    #[test]
-    fn test_efi_image_buffer_null() {
-        let gbl_buffer = GblEfiImageBuffer { Memory: null_mut(), SizeBytes: 1 };
-
-        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-        // SAFETY:
-        // 'gbl_buffer` contains Memory == NULL, which is valid input value. And we expect Error as
-        // a result
-        let res = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        assert_eq!(res.unwrap_err(), Error::InvalidInput);
-    }
-
-    #[test]
-    fn test_efi_image_buffer_same_buffer() {
-        let mut v = vec![0u8; 1];
-        let gbl_buffer =
-            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
-
-        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        assert!(res1.is_ok());
-
-        // Since we keep `res1`, second return of same buffer should fail
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        assert_eq!(res2.unwrap_err(), Error::AlreadyStarted);
-    }
-
-    #[test]
-    fn test_efi_image_buffer_same_buffer_after_drop() {
-        let mut v = vec![0u8; 1];
-        let gbl_buffer =
-            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
-
-        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        drop(res1);
-
-        // Since `res1` was dropped same buffer can be returned.
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        assert!(res2.is_ok());
-    }
-
-    #[test]
-    fn test_efi_image_buffer_take() {
-        let mut v = vec![0u8; 1];
-        let gbl_buffer =
-            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
-
-        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let mut res1 = unsafe { EfiImageBuffer::new(gbl_buffer) }.unwrap();
-        let buf_no_owner = res1.take();
-
-        // Since `res1` was taken, we can't reuse same buffer.
-        // SAFETY:
-        // 'gbl_buffer` represents valid buffer created by vector.
-        let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
-        assert_eq!(res2.unwrap_err(), Error::AlreadyStarted);
-
-        // Make sure to clean tracking
-        // SAFETY:
-        // `buf_no_owner` is the only reference to buffer
-        unsafe {
-            EfiImageBuffer::release(buf_no_owner.as_ptr() as usize);
-        }
-    }
-}
diff --git a/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs b/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
deleted file mode 100644
index 4426c67..0000000
--- a/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
+++ /dev/null
@@ -1,434 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `GBL_EFI_OS_CONFIGURATION_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use core::ffi::CStr;
-use efi_types::{EfiGuid, GblEfiOsConfigurationProtocol, GblEfiVerifiedDeviceTree};
-use liberror::{Error, Result};
-
-/// `GBL_EFI_OS_CONFIGURATION_PROTOCOL` implementation.
-pub struct GblOsConfigurationProtocol;
-
-impl ProtocolInfo for GblOsConfigurationProtocol {
-    type InterfaceType = GblEfiOsConfigurationProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xdda0d135, 0xaa5b, 0x42ff, [0x85, 0xac, 0xe3, 0xad, 0x6e, 0xfb, 0x46, 0x19]);
-}
-
-// Protocol interface wrappers.
-impl Protocol<'_, GblOsConfigurationProtocol> {
-    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_kernel_commandline()`.
-    pub fn fixup_kernel_commandline(&self, commandline: &CStr, fixup: &mut [u8]) -> Result<()> {
-        if fixup.is_empty() {
-            return Err(Error::InvalidInput);
-        }
-
-        let mut fixup_size = fixup.len();
-        fixup[0] = 0;
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`.
-        // * `commandline` is a valid pointer to null-terminated string used only within the call.
-        // * `fixup` is non-null buffer available for write, used only within the call.
-        // * `fixup_size` is non-null buffer available for write, used only within the call.
-        unsafe {
-            efi_call!(
-                @bufsize fixup_size,
-                self.interface()?.fixup_kernel_commandline,
-                self.interface,
-                commandline.as_ptr() as _,
-                fixup.as_mut_ptr(),
-                &mut fixup_size
-            )?;
-        }
-
-        Ok(())
-    }
-
-    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_bootconfig()`.
-    pub fn fixup_bootconfig(&self, bootconfig: &[u8], fixup: &mut [u8]) -> Result<usize> {
-        if fixup.is_empty() {
-            return Err(Error::InvalidInput);
-        }
-
-        let mut fixup_size = fixup.len();
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`.
-        // * `bootconfig` is non-null buffer used only within the call.
-        // * `fixup` is non-null buffer available for write, used only within the call.
-        // * `fixup_size` is non-null usize buffer available for write, used only within the call.
-        unsafe {
-            efi_call!(
-                @bufsize fixup_size,
-                self.interface()?.fixup_bootconfig,
-                self.interface,
-                bootconfig.as_ptr(),
-                bootconfig.len(),
-                fixup.as_mut_ptr(),
-                &mut fixup_size
-            )?;
-        }
-
-        Ok(fixup_size)
-    }
-
-    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.select_device_trees()`.
-    pub fn select_device_trees(&self, components: &mut [GblEfiVerifiedDeviceTree]) -> Result<()> {
-        // SAFETY:
-        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`.
-        // * `components` is non-null buffer available for write, used only within the call.
-        // * `components_len` is non-null usize buffer, used only within the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.select_device_trees,
-                self.interface,
-                components.as_mut_ptr() as _,
-                components.len(),
-            )?;
-        }
-
-        Ok(())
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    use crate::test::run_test_with_mock_protocol;
-    use efi_types::{
-        EfiStatus, EFI_STATUS_BUFFER_TOO_SMALL, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
-    };
-    use std::{ffi::CStr, slice};
-
-    #[test]
-    fn fixup_kernel_commandline_no_op() {
-        // No-op C callback implementation.
-        unsafe extern "C" fn c_return_success(
-            _: *mut GblEfiOsConfigurationProtocol,
-            _: *const u8,
-            _: *mut u8,
-            _: *mut usize,
-        ) -> EfiStatus {
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_kernel_commandline: Some(c_return_success),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-            let commandline = c"foo=bar baz";
-
-            assert!(os_config_protocol
-                .fixup_kernel_commandline(commandline, &mut fixup_buffer)
-                .is_ok());
-            assert_eq!(
-                CStr::from_bytes_until_nul(&fixup_buffer[..]).unwrap().to_str().unwrap(),
-                ""
-            );
-        });
-    }
-
-    #[test]
-    fn fixup_kernel_commandline_provided() {
-        const EXPECTED_COMMANDLINE: &CStr = c"a=b";
-        const EXPECTED_FIXUP: &[u8] = b"hello=world\0";
-        const EXPECTED_FIXUP_STR: &str = "hello=world";
-
-        // C callback implementation to add "hello=world" to the given command line.
-        unsafe extern "C" fn c_add_hello_world(
-            _: *mut GblEfiOsConfigurationProtocol,
-            command_line: *const u8,
-            fixup: *mut u8,
-            _: *mut usize,
-        ) -> EfiStatus {
-            assert_eq!(
-                // SAFETY:
-                // * `command_line` is valid pointer to null terminated string.
-                unsafe { CStr::from_ptr(command_line as _) },
-                EXPECTED_COMMANDLINE
-            );
-
-            // SAFETY:
-            // * `fixup` is valid writtable buffer with enough space for test data.
-            let fixup_buffer = unsafe { slice::from_raw_parts_mut(fixup, EXPECTED_FIXUP.len()) };
-            fixup_buffer.copy_from_slice(EXPECTED_FIXUP);
-
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_kernel_commandline: Some(c_add_hello_world),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-
-            assert!(os_config_protocol
-                .fixup_kernel_commandline(EXPECTED_COMMANDLINE, &mut fixup_buffer)
-                .is_ok());
-            assert_eq!(
-                CStr::from_bytes_until_nul(&fixup_buffer[..]).unwrap().to_str().unwrap(),
-                EXPECTED_FIXUP_STR,
-            );
-        });
-    }
-
-    #[test]
-    fn fixup_kernel_commandline_error() {
-        // C callback implementation to return an error.
-        unsafe extern "C" fn c_error(
-            _: *mut GblEfiOsConfigurationProtocol,
-            _: *const u8,
-            _: *mut u8,
-            _: *mut usize,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_kernel_commandline: Some(c_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-            let commandline = c"foo=bar baz";
-
-            assert_eq!(
-                os_config_protocol.fixup_kernel_commandline(commandline, &mut fixup_buffer),
-                Err(Error::InvalidInput),
-            );
-        });
-    }
-
-    #[test]
-    fn fixup_kernel_commandline_buffer_too_small() {
-        const EXPECTED_REQUESTED_FIXUP_SIZE: usize = 256;
-        // C callback implementation to return an error.
-        unsafe extern "C" fn c_error(
-            _: *mut GblEfiOsConfigurationProtocol,
-            _: *const u8,
-            _: *mut u8,
-            fixup_size: *mut usize,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `fixup_size` is a valid pointer to writtable usize buffer.
-            unsafe {
-                *fixup_size = EXPECTED_REQUESTED_FIXUP_SIZE;
-            }
-            EFI_STATUS_BUFFER_TOO_SMALL
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_kernel_commandline: Some(c_error),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-            let commandline = c"foo=bar baz";
-
-            assert_eq!(
-                os_config_protocol.fixup_kernel_commandline(commandline, &mut fixup_buffer),
-                Err(Error::BufferTooSmall(Some(EXPECTED_REQUESTED_FIXUP_SIZE))),
-            );
-        });
-    }
-
-    #[test]
-    fn fixup_bootconfig_no_op() {
-        // No-op C callback implementation.
-        unsafe extern "C" fn c_return_success(
-            _: *mut GblEfiOsConfigurationProtocol,
-            _: *const u8,
-            _: usize,
-            _: *mut u8,
-            fixup_size: *mut usize,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `fixup_size` is a valid pointer to writtable usize buffer.
-            unsafe {
-                *fixup_size = 0;
-            }
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_bootconfig: Some(c_return_success),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-            let bootconfig = c"foo=bar\nbaz".to_bytes_with_nul();
-
-            assert_eq!(
-                os_config_protocol.fixup_bootconfig(&bootconfig[..], &mut fixup_buffer),
-                Ok(0)
-            );
-        });
-    }
-
-    #[test]
-    fn fixup_bootconfig_provided() {
-        // no trailer for simplicity
-        const EXPECTED_BOOTCONFIG: &[u8] = b"a=b\nc=d\n";
-        const EXPECTED_LEN: usize = 4;
-        const EXPECTED_FIXUP: &[u8] = b"e=f\n";
-
-        // C callback implementation to add "e=f" to the given bootconfig.
-        unsafe extern "C" fn c_add_ef(
-            _: *mut GblEfiOsConfigurationProtocol,
-            bootconfig: *const u8,
-            bootconfig_size: usize,
-            fixup: *mut u8,
-            fixup_size: *mut usize,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `bootconfig` is a valid pointer to the buffer at least `bootconfig_size` size.
-            let bootconfig_buffer = unsafe { slice::from_raw_parts(bootconfig, bootconfig_size) };
-
-            assert_eq!(bootconfig_buffer, EXPECTED_BOOTCONFIG);
-
-            // SAFETY:
-            // * `fixup` is a valid writtable buffer with enough space for test data.
-            // * `fixup_size` is a valid pointer to writtable usize buffer.
-            let fixup_buffer = unsafe {
-                *fixup_size = EXPECTED_FIXUP.len();
-                slice::from_raw_parts_mut(fixup, *fixup_size)
-            };
-            fixup_buffer.copy_from_slice(EXPECTED_FIXUP);
-
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_bootconfig: Some(c_add_ef),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-
-            assert_eq!(
-                os_config_protocol.fixup_bootconfig(&EXPECTED_BOOTCONFIG[..], &mut fixup_buffer),
-                Ok(EXPECTED_LEN),
-            );
-            assert_eq!(&fixup_buffer[..EXPECTED_LEN], &EXPECTED_FIXUP[..],);
-        });
-    }
-
-    #[test]
-    fn fixup_bootconfig_error() {
-        // C callback implementation to return an error.
-        unsafe extern "C" fn c_error(
-            _: *mut GblEfiOsConfigurationProtocol,
-            _: *const u8,
-            _: usize,
-            _: *mut u8,
-            _: *mut usize,
-        ) -> EfiStatus {
-            EFI_STATUS_INVALID_PARAMETER
-        }
-
-        let c_interface =
-            GblEfiOsConfigurationProtocol { fixup_bootconfig: Some(c_error), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-            let bootconfig = c"foo=bar\nbaz".to_bytes_with_nul();
-
-            assert_eq!(
-                os_config_protocol.fixup_bootconfig(&bootconfig[..], &mut fixup_buffer),
-                Err(Error::InvalidInput)
-            );
-        });
-    }
-
-    #[test]
-    fn fixup_bootconfig_fixup_buffer_too_small() {
-        const EXPECTED_REQUESTED_FIXUP_SIZE: usize = 256;
-        // C callback implementation to return an error.
-        unsafe extern "C" fn c_error(
-            _: *mut GblEfiOsConfigurationProtocol,
-            _: *const u8,
-            _: usize,
-            _: *mut u8,
-            fixup_size: *mut usize,
-        ) -> EfiStatus {
-            // SAFETY:
-            // * `fixup_size` is a valid pointer to writtable usize buffer.
-            unsafe {
-                *fixup_size = EXPECTED_REQUESTED_FIXUP_SIZE;
-            }
-            EFI_STATUS_BUFFER_TOO_SMALL
-        }
-
-        let c_interface =
-            GblEfiOsConfigurationProtocol { fixup_bootconfig: Some(c_error), ..Default::default() };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut fixup_buffer = [0x0; 128];
-            let bootconfig = c"foo=bar\nbaz".to_bytes_with_nul();
-
-            assert_eq!(
-                os_config_protocol.fixup_bootconfig(&bootconfig[..], &mut fixup_buffer),
-                Err(Error::BufferTooSmall(Some(EXPECTED_REQUESTED_FIXUP_SIZE))),
-            );
-        });
-    }
-
-    #[test]
-    fn select_device_trees_selected() {
-        // C callback implementation to select first component.
-        unsafe extern "C" fn c_select_first(
-            _: *mut GblEfiOsConfigurationProtocol,
-            device_trees: *mut GblEfiVerifiedDeviceTree,
-            num: usize,
-        ) -> EfiStatus {
-            assert_eq!(num, 1);
-
-            // SAFETY:
-            // * device_trees is non-null buffer available for write.
-            unsafe {
-                (*device_trees).selected = true;
-            }
-
-            EFI_STATUS_SUCCESS
-        }
-
-        let c_interface = GblEfiOsConfigurationProtocol {
-            select_device_trees: Some(c_select_first),
-            ..Default::default()
-        };
-
-        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let device_trees = &mut [GblEfiVerifiedDeviceTree::default()];
-
-            assert!(os_config_protocol.select_device_trees(device_trees).is_ok());
-            assert!(device_trees[0].selected);
-        });
-    }
-}
diff --git a/gbl/libefi/src/protocol/loaded_image.rs b/gbl/libefi/src/protocol/loaded_image.rs
deleted file mode 100644
index 979c17b..0000000
--- a/gbl/libefi/src/protocol/loaded_image.rs
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_LOADED_IMAGE_PROTOCOL`.
-
-use crate::protocol::{Protocol, ProtocolInfo};
-use crate::DeviceHandle;
-use efi_types::{EfiGuid, EfiLoadedImageProtocol};
-use liberror::Result;
-
-/// EFI_LOADED_IMAGE_PROTOCOL
-pub struct LoadedImageProtocol;
-
-impl ProtocolInfo for LoadedImageProtocol {
-    type InterfaceType = EfiLoadedImageProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x5b1b31a1, 0x9562, 0x11d2, [0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b]);
-}
-
-impl<'a> Protocol<'a, LoadedImageProtocol> {
-    /// Wraps `EFI_LOADED_IMAGE_PROTOCOL.DeviceHandle`.
-    pub fn device_handle(&self) -> Result<DeviceHandle> {
-        Ok(DeviceHandle(self.interface()?.device_handle))
-    }
-}
diff --git a/gbl/libefi/src/protocol/riscv.rs b/gbl/libefi/src/protocol/riscv.rs
deleted file mode 100644
index dc01626..0000000
--- a/gbl/libefi/src/protocol/riscv.rs
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `RISCV_EFI_BOOT_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use efi_types::{EfiGuid, EfiRiscvBootProtocol};
-use liberror::Result;
-
-/// RISCV_EFI_BOOT_PROTOCOL
-pub struct RiscvBootProtocol;
-
-impl ProtocolInfo for RiscvBootProtocol {
-    type InterfaceType = EfiRiscvBootProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xccd15fec, 0x6f73, 0x4eec, [0x83, 0x95, 0x3e, 0x69, 0xe4, 0xb9, 0x40, 0xbf]);
-}
-
-impl<'a> Protocol<'a, RiscvBootProtocol> {
-    /// Wraps `RISCV_EFI_BOOT_PROTOCOL.GetBootHartId()`.
-    pub fn get_boot_hartid(&self) -> Result<usize> {
-        let mut boot_hart_id: usize = 0;
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        // `&mut boot_hart_id` is output parameter and will not be retained. It outlives the call.
-        unsafe {
-            efi_call!(self.interface()?.get_boot_hartid, self.interface, &mut boot_hart_id)?;
-        }
-        Ok(boot_hart_id)
-    }
-
-    /// Wraps `RISCV_EFI_BOOT_PROTOCOL.Revision`.
-    pub fn revision(&self) -> Result<u64> {
-        Ok(self.interface()?.revision)
-    }
-}
diff --git a/gbl/libefi/src/protocol/simple_network.rs b/gbl/libefi/src/protocol/simple_network.rs
deleted file mode 100644
index ad8b695..0000000
--- a/gbl/libefi/src/protocol/simple_network.rs
+++ /dev/null
@@ -1,213 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_SIMPLE_NETWORK_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use core::ffi::c_void;
-use core::ptr::null_mut;
-use efi_types::{
-    EfiGuid, EfiMacAddress, EfiSimpleNetworkMode, EfiSimpleNetworkProtocol,
-    EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS, EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST,
-    EFI_SIMPLE_NETWORK_RECEIVE_UNICAST,
-};
-use liberror::{Error, Result};
-
-/// EFI_SIMPLE_NETWORK_PROTOCOL
-pub struct SimpleNetworkProtocol;
-
-impl ProtocolInfo for SimpleNetworkProtocol {
-    type InterfaceType = EfiSimpleNetworkProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0xa19832b9, 0xac25, 0x11d3, [0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d]);
-}
-
-impl<'a> Protocol<'a, SimpleNetworkProtocol> {
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Start()`
-    pub fn start(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees to return a valid object pointer as established by
-        // `Protocol::new()`.
-        // `self.interface` outlives the call and will not be retained.
-        unsafe { efi_call!(self.interface()?.start, self.interface) }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Stop()`
-    pub fn stop(&self) -> Result<()> {
-        // SAFETY: See safety reasoning of `start()`.
-        unsafe { efi_call!(self.interface()?.stop, self.interface) }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Initialize()`
-    pub fn initialize(&self, extra_rx_buf_size: usize, extra_tx_buf_size: usize) -> Result<()> {
-        // SAFETY: See safety reasoning of `start()`.
-        unsafe {
-            efi_call!(
-                self.interface()?.initialize,
-                self.interface,
-                extra_rx_buf_size,
-                extra_tx_buf_size
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Reset()`
-    pub fn reset(&self, extended_verification: bool) -> Result<()> {
-        // SAFETY: See safety reasoning of `start()`.
-        unsafe { efi_call!(self.interface()?.reset, self.interface, extended_verification) }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Shutdown()`
-    pub fn shutdown(&self) -> Result<()> {
-        // SAFETY: See safety reasoning of `start()`.
-        unsafe { efi_call!(self.interface()?.shutdown, self.interface) }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.ReceiveFilters()`
-    pub fn receive_filters(
-        &self,
-        enable: u32,
-        disable: u32,
-        reset_mcast_filter: bool,
-        mcast_filter: &mut [EfiMacAddress],
-    ) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees to return a valid object pointer as established by
-        // `Protocol::new()`.
-        // `self.interface` outlives the call and will not be retained.
-        // `mcast_filter` is for input only. It outlives the call and will not be retained.
-        unsafe {
-            efi_call!(
-                self.interface()?.receive_filters,
-                self.interface,
-                enable,
-                disable,
-                reset_mcast_filter,
-                mcast_filter.len(),
-                mcast_filter.as_mut_ptr()
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.GetStatus()`
-    pub fn get_status(
-        &self,
-        interrupt_status: Option<&mut u32>,
-        recycle_buffer: Option<&mut *mut c_void>,
-    ) -> Result<()> {
-        // SAFETY:
-        // See safety reasoning of `start()`.
-        // Pointers to `interrupt_status`, `recycled_buffer` are valid during the call and for
-        // writing output values only.
-        unsafe {
-            efi_call!(
-                self.interface()?.get_status,
-                self.interface,
-                option_ref_mut_to_pointer(interrupt_status),
-                option_ref_mut_to_pointer(recycle_buffer)
-            )?;
-        }
-        Ok(())
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Transmit()`
-    ///
-    /// # Safety
-    ///
-    /// * `buf` needs to be a valid buffer.
-    /// * There should not be any existing references to memory pointed by `buf`.
-    /// * Because `buf` is internally retained by the network. `buf` should remain valid and not
-    ///   dereferenced until either 1) the buffer address re-appears in `recycled_buffer` from
-    ///   `Self::get_status()` or 2) Self::Shutdown() is called and returns either Ok(()) or
-    ///   EFI_STATUS_NOT_STARTED.
-    pub unsafe fn transmit(
-        &self,
-        header_size: usize,
-        buf: *mut [u8],
-        mut src: EfiMacAddress,
-        mut dest: EfiMacAddress,
-        mut protocol: u16,
-    ) -> Result<()> {
-        // SAFETY: function safety docs require valid `buf`.
-        let buf = unsafe { buf.as_mut() }.unwrap();
-        // SAFETY:
-        // See safety reasoning of `start()`.
-        // All pointers passed are valid, outlive the call and are not retained by the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.transmit,
-                self.interface,
-                header_size,
-                buf.len(),
-                buf.as_mut_ptr() as *mut _,
-                &mut src,
-                &mut dest,
-                &mut protocol
-            )
-        }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_NETWORK.Receive()`.
-    pub fn receive(
-        &self,
-        header_size: Option<&mut usize>,
-        buf_size: Option<&mut usize>,
-        buf: &mut [u8],
-        src: Option<&mut EfiMacAddress>,
-        dest: Option<&mut EfiMacAddress>,
-        protocol: Option<&mut u16>,
-    ) -> Result<()> {
-        // SAFETY:
-        // See safety reasoning of `start()`.
-        // All pointers passed are valid, outlive the call and are not retained by the call.
-        unsafe {
-            efi_call!(
-                self.interface()?.receive,
-                self.interface,
-                option_ref_mut_to_pointer(header_size),
-                option_ref_mut_to_pointer(buf_size),
-                buf.as_mut_ptr() as *mut _,
-                option_ref_mut_to_pointer(src),
-                option_ref_mut_to_pointer(dest),
-                option_ref_mut_to_pointer(protocol)
-            )?;
-        }
-        Ok(())
-    }
-
-    /// Returns `EFI_SIMPLE_NETWORK.Mode` structure
-    pub fn mode(&self) -> Result<EfiSimpleNetworkMode> {
-        // SAFETY: Non-null pointer from UEFI interface points to valid object.
-        unsafe { self.interface()?.mode.as_ref() }.ok_or(Error::NotFound).copied()
-    }
-
-    /// Sets to promiscuous mode to receive all packets over the network.
-    pub fn set_promiscuous_mode(&self) -> Result<()> {
-        self.receive_filters(
-            EFI_SIMPLE_NETWORK_RECEIVE_UNICAST
-                | EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS
-                | EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST,
-            0,
-            false,
-            &mut [],
-        )
-    }
-}
-
-/// A helper to convert an `Option<&mut T>` to `*mut T`. None maps to NULL.
-fn option_ref_mut_to_pointer<T>(option: Option<&mut T>) -> *mut T {
-    option.map(|t| t as *mut _).unwrap_or(null_mut())
-}
diff --git a/gbl/libefi/src/protocol/simple_text_input.rs b/gbl/libefi/src/protocol/simple_text_input.rs
deleted file mode 100644
index 4fbba23..0000000
--- a/gbl/libefi/src/protocol/simple_text_input.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_SIMPLE_TEXT_INPUT_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use efi_types::{EfiGuid, EfiInputKey, EfiSimpleTextInputProtocol};
-use liberror::{Error, Result};
-
-/// EFI_SIMPLE_TEXT_INPUT_PROTOCOL
-pub struct SimpleTextInputProtocol;
-
-impl ProtocolInfo for SimpleTextInputProtocol {
-    type InterfaceType = EfiSimpleTextInputProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x387477c1, 0x69c7, 0x11d2, [0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b]);
-}
-
-impl Protocol<'_, SimpleTextInputProtocol> {
-    /// Wrapper of `EFI_SIMPLE_TEXT_INPUT_PROTOCOL.reset()`
-    pub fn reset(&self, extendend_verification: bool) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.reset, self.interface, extendend_verification) }
-    }
-
-    /// Wrapper of `EFI_SIMPLE_TEXT_INPUT_PROTOCOL.read_key_stroke()`
-    ///
-    /// Returns `Ok(Some(EfiInputKey))` if there is a key stroke, Ok(None) if no key stroke is
-    /// pressed.
-    pub fn read_key_stroke(&self) -> Result<Option<EfiInputKey>> {
-        let mut key: EfiInputKey = Default::default();
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        // `key` is an output argument. It outlives the call and will not be taken.
-        match unsafe { efi_call!(self.interface()?.read_key_stroke, self.interface, &mut key) } {
-            Ok(()) => Ok(Some(key)),
-            Err(Error::NotReady) => Ok(None),
-            Err(e) => Err(e),
-        }
-    }
-}
diff --git a/gbl/libefi/src/protocol/simple_text_output.rs b/gbl/libefi/src/protocol/simple_text_output.rs
deleted file mode 100644
index 3e22847..0000000
--- a/gbl/libefi/src/protocol/simple_text_output.rs
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Rust wrapper for `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL`.
-
-use crate::efi_call;
-use crate::protocol::{Protocol, ProtocolInfo};
-use core::fmt::Write;
-use efi_types::{char16_t, EfiGuid, EfiSimpleTextOutputProtocol};
-use liberror::Result;
-
-/// EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL
-pub struct SimpleTextOutputProtocol;
-
-impl ProtocolInfo for SimpleTextOutputProtocol {
-    type InterfaceType = EfiSimpleTextOutputProtocol;
-
-    const GUID: EfiGuid =
-        EfiGuid::new(0x387477c2, 0x69c7, 0x11d2, [0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b]);
-}
-
-impl Protocol<'_, SimpleTextOutputProtocol> {
-    /// Wrapper of `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.OutputString()`
-    pub fn output_string(&self, msg: *mut char16_t) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.output_string, self.interface, msg) }
-    }
-}
-
-/// Implement formatted write for `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL`, so that we can print by
-/// writing to it. i.e.:
-///
-/// ```
-/// let protocol: Protocol<SimpleTextOutputProtocol> = ...;
-/// write!(protocol, "Value = {}\n", 1234);
-/// ```
-impl Write for Protocol<'_, SimpleTextOutputProtocol> {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        for ch in s.chars() {
-            // 2 is enough for encode_utf16(). Add an additional one as NULL.
-            let mut buffer = [0u16; 3];
-            let char16_msg = ch.encode_utf16(&mut buffer[..]);
-            self.output_string(char16_msg.as_mut_ptr()).map_err(|_| core::fmt::Error {})?;
-        }
-        Ok(())
-    }
-}
diff --git a/gbl/libefi/src/utils.rs b/gbl/libefi/src/utils.rs
deleted file mode 100644
index 30aa717..0000000
--- a/gbl/libefi/src/utils.rs
+++ /dev/null
@@ -1,107 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides some utilities built on EFI APIs.
-
-use crate::{EfiEntry, Event, EventType};
-use core::{future::Future, time::Duration};
-use efi_types::{EFI_TIMER_DELAY_TIMER_PERIODIC, EFI_TIMER_DELAY_TIMER_RELATIVE};
-use gbl_async::{select, yield_now};
-use liberror::Result;
-
-/// `Timeout` provide APIs for checking timeout.
-pub struct Timeout<'a> {
-    efi_entry: &'a EfiEntry,
-    timer: Event<'a, 'static>,
-}
-
-impl<'a> Timeout<'a> {
-    /// Creates a new instance and starts the timeout timer.
-    pub fn new(efi_entry: &'a EfiEntry, timeout: Duration) -> Result<Self> {
-        let bs = efi_entry.system_table().boot_services();
-        let timer = bs.create_event(EventType::Timer)?;
-        bs.set_timer(&timer, EFI_TIMER_DELAY_TIMER_RELATIVE, timeout)?;
-        Ok(Self { efi_entry, timer })
-    }
-
-    /// Checks if it has timeout.
-    pub fn check(&self) -> Result<bool> {
-        Ok(self.efi_entry.system_table().boot_services().check_event(&self.timer)?)
-    }
-
-    /// Resets the timeout.
-    pub fn reset(&self, timeout: Duration) -> Result<()> {
-        let bs = self.efi_entry.system_table().boot_services();
-        bs.set_timer(&self.timer, EFI_TIMER_DELAY_TIMER_RELATIVE, timeout)?;
-        Ok(())
-    }
-}
-
-/// Waits for a given amount of time.
-pub async fn wait(efi_entry: &EfiEntry, duration: Duration) -> Result<()> {
-    // EFI boot service has a `stall` API. But it's not async.
-    let timeout = Timeout::new(efi_entry, duration)?;
-    while !timeout.check()? {
-        yield_now().await;
-    }
-    Ok(())
-}
-
-/// Runs a future with timeout.
-///
-/// # Returns
-///
-/// * Returns Ok(Some(R)) if the future finishes before timeout.
-/// * Returns Ok(None) if the future didn't finish before timeout.
-/// * Returns Err if internal error occurs while handling EFI timer event.
-pub async fn with_timeout<F: Future<Output = R>, R>(
-    efi_entry: &EfiEntry,
-    fut: F,
-    timeout: Duration,
-) -> Result<Option<R>> {
-    let (timeout_res, res) = select(wait(efi_entry, timeout), fut).await;
-    match timeout_res {
-        Some(Err(e)) => return Err(e),
-        _ => Ok(res),
-    }
-}
-
-/// Wrapper helping for a periodic timer.
-pub struct RecurringTimer<'a> {
-    efi_entry: &'a EfiEntry,
-    timer: Event<'a, 'static>,
-}
-
-impl<'a> RecurringTimer<'a> {
-    /// Constructs and starts a new periodic timer.
-    pub fn new(efi_entry: &'a EfiEntry, timeout: Duration) -> Result<Self> {
-        let bs = efi_entry.system_table().boot_services();
-        let timer = bs.create_event(EventType::Timer)?;
-        bs.set_timer(&timer, EFI_TIMER_DELAY_TIMER_PERIODIC, timeout)?;
-        Ok(Self { efi_entry, timer })
-    }
-
-    /// Checks whether the timer has expried.
-    pub fn check(&self) -> Result<bool> {
-        Ok(self.efi_entry.system_table().boot_services().check_event(&self.timer)?)
-    }
-
-    /// Waits asynchronously until the next tick.
-    pub async fn wait(&self) -> Result<()> {
-        while !self.check()? {
-            yield_now().await;
-        }
-        Ok(())
-    }
-}
diff --git a/gbl/libefi_types/BUILD b/gbl/libefi_types/BUILD
deleted file mode 100644
index b5d7005..0000000
--- a/gbl/libefi_types/BUILD
+++ /dev/null
@@ -1,107 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
-load("@rules_cc//cc:cc_library.bzl", "cc_library")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
-# library and instead of only headers. Thus we generate a placeholder source file to meet the
-# requirement.
-genrule(
-    name = "bindgen_noop_cc",
-    outs = ["bindgen_noop_cc.cc"],
-    cmd = "touch $(OUTS)",
-)
-
-cc_library(
-    name = "efi_c_headers",
-    srcs = [":bindgen_noop_cc"],
-    hdrs = glob(["defs/**/*.h"]),
-    includes = ["defs"],
-)
-
-# Side note: function pointers for UEFI interfaces need to specify the "efiapi" ABI. i.e.
-# "unsafe extern "efiapi" fn(...)". bindgen uses "extern "C"" by default. We are currently fine
-# because for x86_64/x86_32/aarch64, we use dedicated rust UEFI compiler which uses EFIAPI ABI by
-# default. For riscv64 which we use ELF compiler, the efiapi calling convention is the same as C
-# calling convention according to the UEFI spec at the time of writing. If we do eventually run
-# into problems, we need to use a newer version of bindgen 0.65.0 or above, which offers
-# "--override-abi" with "efiapi" option.
-rust_bindgen(
-    name = "efi_defs_bindgen",
-    bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
-        "--with-derive-partialeq",
-        "--with-derive-default",
-        "--with-derive-custom-struct=EfiMemoryDescriptor=Immutable,IntoBytes,FromBytes,KnownLayout",
-        "--with-derive-custom-struct=EfiMemoryAttributesTableHeader=Immutable,IntoBytes,FromBytes,KnownLayout",
-        "--allowlist-type",
-        "(Efi.*)|(GblEfi.*)|(GBL_EFI_.*)",
-        "--allowlist-var",
-        "PARTITION_NAME_LEN_U16|EFI_.*|GBL_.*",
-        "--raw-line",
-        """
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![allow(missing_docs)]
-use zerocopy::{Immutable, IntoBytes, FromBytes, KnownLayout};""",
-    ],
-    cc_lib = ":efi_c_headers",
-    # For x86_32, we need to explicitly specify 32bit architecture.
-    clang_flags = select(
-        {
-            "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-            "//conditions:default": ["-m64"],
-        },
-    ) + [
-        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
-        "-nostdinc",
-    ],
-    header = "defs/efi.h",
-)
-
-# Copy the generated source to "src/defs.rs" in the output assembly, so that libefi can include it
-# as a source.
-genrule(
-    name = "efi_defs_genrule",
-    srcs = [":efi_defs_bindgen"],
-    outs = ["src/defs.rs"],
-    cmd = "cat $(location :efi_defs_bindgen) > $@",
-)
-
-rust_library(
-    name = "libefi_types",
-    srcs = glob(["**/*.rs"]) + ["src/defs.rs"],
-    crate_name = "efi_types",
-    data = [":efi_defs_genrule"],
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libefi_types_test",
-    crate = ":libefi_types",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libefi_types/defs/boot_service.h b/gbl/libefi_types/defs/boot_service.h
deleted file mode 100644
index 8c0a9b3..0000000
--- a/gbl/libefi_types/defs/boot_service.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __BOOT_SERVICE_TABLE_H__
-#define __BOOT_SERVICE_TABLE_H__
-
-#include "protocols/device_path_protocol.h"
-#include "types.h"
-
-typedef enum EFI_LOCATE_HANDLE_SEARCH_TYPE {
-  ALL_HANDLES = 0,
-  BY_REGITER_NOTIFY,
-  BY_PROTOCOL,
-} EFI_LOCATE_HANDLE_SEARCH_TYPE;
-
-typedef EFI_LOCATE_HANDLE_SEARCH_TYPE EfiLocateHandleSearchType;
-
-typedef enum { EFI_NATIVE_INTERFACE } EFI_INTERFACE_TYPE;
-
-typedef EFI_INTERFACE_TYPE EfiInterfaceType;
-
-typedef enum EFI_ALLOCATOR_TYPE {
-  ALLOCATE_ANY_PAGES,
-  ALLOCATE_MAX_ADDRESS,
-  ALLOCATE_ADDRESS,
-  MAX_ALLOCATE_TYPE
-} EfiAllocatorType;
-
-typedef enum EFI_OPEN_PROTOCOL_ATTRIBUTE : uint32_t {
-  BY_HANDLE_PROTOCOL = 0x00000001,
-  GET_PROTOCOL = 0x00000002,
-  TEST_PROTOCOL = 0x00000004,
-  BY_CHILD_CONTROLLER = 0x00000008,
-  BY_DRIVER = 0x00000010,
-  EXCLUSIVE = 0x00000020,
-} EfiOpenProtocolAttributes;
-
-typedef struct {
-  EfiHandle agent_handle;
-  EfiHandle controller_handle;
-  uint32_t attributes;
-  uint32_t open_count;
-} EfiOpenProtocolInformationEntry;
-
-typedef struct {
-  EfiTableHeader hdr;
-  EfiTpl (*raise_tpl)(EfiTpl new_tpl);
-  void (*restore_tpl)(EfiTpl old_tpl);
-  EfiStatus (*allocate_pages)(EfiAllocatorType type, EfiMemoryType memory_type, size_t pages,
-                              EfiPhysicalAddr* memory);
-  EfiStatus (*free_pages)(EfiPhysicalAddr memory, size_t pages);
-  EfiStatus (*get_memory_map)(size_t* memory_map_size, EfiMemoryDescriptor* memory_map,
-                              size_t* map_key, size_t* desc_size, uint32_t* desc_version);
-  EfiStatus (*allocate_pool)(EfiMemoryType pool_type, size_t size, void** buf);
-  EfiStatus (*free_pool)(void* buf);
-  EfiStatus (*create_event)(uint32_t type, EfiTpl notify_tpl, EfiEventNotify notify_fn,
-                            void* notify_ctx, EfiEvent* event);
-  EfiStatus (*set_timer)(EfiEvent event, EfiTimerDelay type, uint64_t trigger_time);
-  EfiStatus (*wait_for_event)(size_t num_events, EfiEvent* event, size_t* index);
-  EfiStatus (*signal_event)(EfiEvent event);
-  EfiStatus (*close_event)(EfiEvent event);
-  EfiStatus (*check_event)(EfiEvent event);
-  EfiStatus (*install_protocol_interface)(EfiHandle* handle, const EfiGuid* protocol,
-                                          EfiInterfaceType intf_type, void* intf);
-  EfiStatus (*reinstall_protocol_interface)(EfiHandle hadle, const EfiGuid* protocol,
-                                            void* old_intf, void* new_intf);
-  EfiStatus (*uninstall_protocol_interface)(EfiHandle handle, const EfiGuid* protocol, void* intf);
-  EfiStatus (*handle_protocol)(EfiHandle handle, const EfiGuid* protocol, void** intf);
-  void* reserved;
-  EfiStatus (*register_protocol_notify)(const EfiGuid* protocol, EfiEvent event,
-                                        void** registration);
-  EfiStatus (*locate_handle)(EfiLocateHandleSearchType search_type, const EfiGuid* protocol,
-                             void* search_key, size_t* buf_size, EfiHandle* buf);
-  EfiStatus (*locate_device_path)(const EfiGuid* protocol, EfiDevicePathProtocol** path,
-                                  EfiHandle* device);
-  EfiStatus (*install_configuration_table)(const EfiGuid* guid, void* table);
-  EfiStatus (*load_image)(bool boot_policy, EfiHandle parent_image_handle,
-                          EfiDevicePathProtocol* path, void* src, size_t src_size,
-                          EfiHandle* image_handle);
-  EfiStatus (*start_image)(EfiHandle image_handle, size_t* exit_data_size, char16_t** exit_data);
-  EfiStatus (*exit)(EfiHandle image_handle, EfiStatus exit_status, size_t exit_data_size,
-                    char16_t* exit_data);
-  EfiStatus (*unload_image)(EfiHandle image_handle);
-  EfiStatus (*exit_boot_services)(EfiHandle image_handle, size_t map_key);
-  EfiStatus (*get_next_monotonic_count)(uint64_t* count);
-  EfiStatus (*stall)(size_t microseconds);
-  EfiStatus (*set_watchdog_timer)(size_t timeout, uint64_t watchdog_code, size_t data_size,
-                                  char16_t* watchdog_data);
-  EfiStatus (*connect_controller)(EfiHandle controller_handle, EfiHandle* driver_image_handle,
-                                  EfiDevicePathProtocol* remaining_path, bool recursive);
-  EfiStatus (*disconnect_controller)(EfiHandle controller_handle, EfiHandle driver_image_handle,
-                                     EfiHandle child_handle);
-  EfiStatus (*open_protocol)(EfiHandle handle, const EfiGuid* protocol, void** intf,
-                             EfiHandle agent_handle, EfiHandle controller_handle,
-                             EfiOpenProtocolAttributes attr);
-  EfiStatus (*close_protocol)(EfiHandle handle, const EfiGuid* protocol, EfiHandle agent_handle,
-                              EfiHandle controller_handle);
-  EfiStatus (*open_protocol_information)(EfiHandle handle, const EfiGuid* protocol,
-                                         EfiOpenProtocolInformationEntry** entry_buf,
-                                         size_t* entry_count);
-  EfiStatus (*protocols_per_handle)(EfiHandle handle, EfiGuid*** protocol_buf,
-                                    size_t* protocol_buf_count);
-  EfiStatus (*locate_handle_buffer)(EfiLocateHandleSearchType search_type, const EfiGuid* protocol,
-                                    void* search_key, size_t* num_handles, EfiHandle** buf);
-  EfiStatus (*locate_protocol)(const EfiGuid* protocol, void* registration, void** intf);
-  EfiStatus (*install_multiple_protocol_interfaces)(EfiHandle* handle, ...);
-  EfiStatus (*uninstall_multiple_protocol_interfaces)(EfiHandle handle, ...);
-  EfiStatus (*calculate_crc32)(void* data, size_t len, uint32_t* crc32);
-  void (*copy_mem)(void* dest, const void* src, size_t len);
-  void (*set_mem)(void* buf, size_t len, uint8_t val);
-  EfiStatus (*create_event_ex)(EfiEventType type, EfiTpl notify_tpl, EfiEventNotify notify_fn,
-                               const void* notify_ctx, const EfiGuid* event_group, EfiEvent* event);
-} EfiBootService;
-
-#endif  // __BOOT_SERVICE_TABLE_H__
\ No newline at end of file
diff --git a/gbl/libefi_types/defs/efi.h b/gbl/libefi_types/defs/efi.h
deleted file mode 100644
index 9d01b80..0000000
--- a/gbl/libefi_types/defs/efi.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __EFI_H__
-#define __EFI_H__
-
-#include <stdbool.h>
-#include <stddef.h>
-#include <stdint.h>
-
-#include "boot_service.h"
-#include "gbl_efi_common.h"
-#include "protocols/block_io2_protocol.h"
-#include "protocols/block_io_protocol.h"
-#include "protocols/device_path_protocol.h"
-#include "protocols/dt_fixup_protocol.h"
-#include "protocols/gbl_efi_ab_slot_protocol.h"
-#include "protocols/gbl_efi_avb_protocol.h"
-#include "protocols/gbl_efi_fastboot_protocol.h"
-#include "protocols/gbl_efi_fastboot_usb.h"
-#include "protocols/gbl_efi_image_loading_protocol.h"
-#include "protocols/gbl_efi_os_configuration_protocol.h"
-#include "protocols/loaded_image_protocol.h"
-#include "protocols/riscv_efi_boot_protocol.h"
-#include "protocols/simple_network_protocol.h"
-#include "protocols/simple_text_input_protocol.h"
-#include "protocols/simple_text_output_protocol.h"
-#include "system_table.h"
-#include "types.h"
-
-#endif  // __EFI_H__
diff --git a/gbl/libefi_types/defs/gbl_efi_common.h b/gbl/libefi_types/defs/gbl_efi_common.h
deleted file mode 100644
index a4f36fc..0000000
--- a/gbl/libefi_types/defs/gbl_efi_common.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __GBL_EFI_COMMON_H__
-#define __GBL_EFI_COMMON_H__
-
-#include <types.h>
-
-#define GBL_EFI_VENDOR_GUID                                     \
-  EfiGuid {                                                     \
-    .data1=0x5a6d92f3,                                          \
-      .data2=0xa2d0,                                            \
-      .data3=0x4083,                                            \
-      .data4=[0x91, 0xa1, 0xa5, 0x0f, 0x6c, 0x3d, 0x98, 0x30]   \
-  }
-#define GBL_EFI_OS_BOOT_TARGET_VARNAME "gbl_os_boot_fuchsia"
-
-#endif  /* __GBL_EFI_COMMON_H__ */
diff --git a/gbl/libefi_types/defs/protocols/block_io2_protocol.h b/gbl/libefi_types/defs/protocols/block_io2_protocol.h
deleted file mode 100644
index d25ee67..0000000
--- a/gbl/libefi_types/defs/protocols/block_io2_protocol.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __BLOCK_IO2_PROTOCOL_H__
-#define __BLOCK_IO2_PROTOCOL_H__
-
-#include "protocols/block_io_protocol.h"
-#include "types.h"
-
-typedef struct EfiBlockIoMedia EfiBlockIoMedia;
-typedef struct EfiBlockIo2Protocol EfiBlockIo2Protocol;
-
-typedef struct {
-  EfiEvent event;
-  EfiStatus transaction_status;
-} EfiBlockIo2Token;
-
-struct EfiBlockIo2Protocol {
-  EfiBlockIoMedia* media;
-  EfiStatus (*reset)(EfiBlockIo2Protocol* self, bool extended_verification);
-  EfiStatus (*read_blocks_ex)(EfiBlockIo2Protocol* self, uint32_t media_id,
-                              uint64_t lba, EfiBlockIo2Token* token,
-                              size_t buffer_size, void* buffer);
-  EfiStatus (*write_blocks_ex)(EfiBlockIo2Protocol* self, uint32_t media_id,
-                               uint64_t lba, EfiBlockIo2Token* token,
-                               size_t buffer_size, const void* buffer);
-  EfiStatus (*flush_blocks_ex)(EfiBlockIo2Protocol* self,
-                               EfiBlockIo2Token* token);
-};
-
-#endif  //__BLOCK_IO2_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/block_io_protocol.h b/gbl/libefi_types/defs/protocols/block_io_protocol.h
deleted file mode 100644
index 7655c50..0000000
--- a/gbl/libefi_types/defs/protocols/block_io_protocol.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __BLOCK_IO_PROTOCOL_H__
-#define __BLOCK_IO_PROTOCOL_H__
-
-#include "types.h"
-
-typedef struct EfiBlockIoMedia EfiBlockIoMedia;
-typedef struct EfiBlockIoProtocol EfiBlockIoProtocol;
-
-struct EfiBlockIoProtocol {
-  uint64_t revision;
-  EfiBlockIoMedia* media;
-  EfiStatus (*reset)(EfiBlockIoProtocol* self, bool extended_verification);
-  EfiStatus (*read_blocks)(EfiBlockIoProtocol* self, uint32_t media_id, uint64_t lba,
-                           size_t buffer_size, void* buffer);
-  EfiStatus (*write_blocks)(EfiBlockIoProtocol* self, uint32_t media_id, uint64_t lba,
-                            size_t buffer_size, void* buffer);
-  EfiStatus (*flush_blocks)(EfiBlockIoProtocol* self);
-};
-
-struct EfiBlockIoMedia {
-  // present in rev1
-  uint32_t media_id;
-  bool removable_media;
-  bool media_present;
-  bool logical_partition;
-  bool read_only;
-  bool write_caching;
-  uint32_t block_size;
-  uint32_t io_align;
-  uint64_t last_block;
-
-  // present in rev2
-  uint64_t lowest_aligned_lba;
-  uint32_t logical_blocks_per_physical_block;
-
-  // present in rev3
-  uint32_t optimal_transfer_length_granularity;
-};
-
-#endif  //__BLOCK_IO_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/device_path_protocol.h b/gbl/libefi_types/defs/protocols/device_path_protocol.h
deleted file mode 100644
index 8c9da3b..0000000
--- a/gbl/libefi_types/defs/protocols/device_path_protocol.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __DEVICE_PATH_PROTOCOL_H__
-#define __DEVICE_PATH_PROTOCOL_H__
-
-#include "types.h"
-
-typedef struct EfiDevicePathProtocol {
-  uint8_t type;
-  uint8_t sub_type;
-  uint8_t length[2];
-} EfiDevicePathProtocol;
-
-#define EFI_DEVICE_PATH_TO_TEXT_PROTOCOL_GUID \
-  EFI_GUID(0x8b843e20, 0x8132, 0x4852, 0x90, 0xcc, 0x55, 0x1a, 0x4e, 0x4a, 0x7f, 0x1c)
-
-typedef struct EfiDevicePathToTextProtocol {
-  uint16_t* (*convert_device_node_to_text)(struct EfiDevicePathProtocol* device_node,
-                                           bool display_only, bool allow_shortcuts);
-  uint16_t* (*convert_device_path_to_text)(struct EfiDevicePathProtocol* device_path,
-                                           bool display_only, bool allow_shortcuts);
-} EfiDevicePathToTextProtocol;
-
-#endif  //__DEVICE_PATH_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/dt_fixup_protocol.h b/gbl/libefi_types/defs/protocols/dt_fixup_protocol.h
deleted file mode 100644
index 5d220b2..0000000
--- a/gbl/libefi_types/defs/protocols/dt_fixup_protocol.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// This is a protocol proposed by U-boot and being used by Kernel UEFI stub.
-// https://github.com/U-Boot-EFI/EFI_DT_FIXUP_PROTOCOL
-// https://github.com/u-boot/u-boot/blob/master/include/efi_dt_fixup.h
-
-#ifndef __EFI_DT_FIXUP_PROTOCOL_H__
-#define __EFI_DT_FIXUP_PROTOCOL_H__
-
-#include "types.h"
-
-const uint64_t EFI_DT_FIXUP_PROTOCOL_REVISION = 0x00010000;
-
-// Add nodes and update properties
-const uint32_t EFI_DT_APPLY_FIXUPS = 0x00000001;
-// Reserve memory according to the /reserved-memory node and the memory
-// reservation block
-const uint32_t EFI_DT_RESERVE_MEMORY = 0x00000002;
-// Install the device-tree as configuration table
-const uint32_t EFI_DT_INSTALL_TABLE = 0x00000004;
-const uint32_t EFI_DT_ALL =
-    EFI_DT_APPLY_FIXUPS | EFI_DT_RESERVE_MEMORY | EFI_DT_INSTALL_TABLE;
-
-typedef struct EfiDtFixupProtocol {
-  uint64_t revision;
-  EfiStatus (*fixup)(struct EfiDtFixupProtocol* self, void* fdt,
-                     size_t* buffer_size, uint32_t flags);
-} EfiDtFixupProtocol;
-
-#endif  // __EFI_DT_FIXUP_PROTOCOL_H__
\ No newline at end of file
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
deleted file mode 100644
index cbeb888..0000000
--- a/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __GBL_EFI_AB_SLOT_PROTOCOL_H__
-#define __GBL_EFI_AB_SLOT_PROTOCOL_H__
-
-#include "system_table.h"
-#include "types.h"
-
-typedef enum GBL_EFI_SLOT_MERGE_STATUS {
-  GBL_EFI_SLOT_MERGE_STATUS_NONE = 0,
-  GBL_EFI_SLOT_MERGE_STATUS_UNKNOWN,
-  GBL_EFI_SLOT_MERGE_STATUS_SNAPSHOTTED,
-  GBL_EFI_SLOT_MERGE_STATUS_MERGING,
-  GBL_EFI_SLOT_MERGE_STATUS_CANCELLED,
-} GblEfiSlotMergeStatus;
-
-typedef enum GBL_EFI_UNBOOTABLE_REASON {
-  GBL_EFI_UNKNOWN_REASON = 0,
-  GBL_EFI_NO_MORE_TRIES,
-  GBL_EFI_SYSTEM_UPDATE,
-  GBL_EFI_USER_REQUESTED,
-  GBL_EFI_VERIFICATION_FAILURE,
-} GblEfiUnbootableReason;
-
-// We are currently following
-// https://cs.android.com/android/platform/superproject/main/+/main:system/core/bootstat/bootstat.cpp;l=229
-// for boot reason code.
-//
-// But we may want to revisit this since GBL mostly just cares normal,
-// bootloader, fastbootd, recovery mode.
-typedef enum GBL_EFI_BOOT_REASON {
-  EMPTY_BOOT_REASON = 0,
-  UNKNOWN_EFI_BOOT_REASON = 1,
-  WATCHDOG = 14,
-  KERNEL_PANIC = 15,
-  RECOVERY = 3,
-  BOOTLOADER = 55,
-  COLD = 56,
-  HARD = 57,
-  WARM = 58,
-  SHUTDOWN,
-  REBOOT = 18,
-  FASTBOOTD = 196,
-} GblEfiBootReason;
-
-typedef struct {
-  // One UTF-8 encoded single character
-  uint32_t suffix;
-  // Any value other than those explicitly enumerated in EFI_UNBOOTABLE_REASON
-  // will be interpreted as UNKNOWN_REASON.
-  uint32_t unbootable_reason;
-  uint8_t priority;
-  uint8_t tries;
-  // Value of 1 if slot has successfully booted.
-  uint8_t successful;
-} GblEfiSlotInfo;
-
-typedef struct {
-  // Value of 1 if persistent metadata tracks slot unbootable reasons.
-  uint8_t unbootable_metadata;
-  uint8_t max_retries;
-  uint8_t slot_count;
-  // See GblEFiSlotMergeStatus for enum values.
-  uint8_t merge_status;
-} GblEfiSlotMetadataBlock;
-
-typedef struct GblEfiABSlotProtocol {
-  // Currently must contain 0x00010000
-  uint32_t version;
-  // Slot metadata query methods
-  EfiStatus (*load_boot_data)(struct GblEfiABSlotProtocol*,
-                              GblEfiSlotMetadataBlock* /* out param*/);
-  EfiStatus (*get_slot_info)(struct GblEfiABSlotProtocol*, uint8_t,
-                             GblEfiSlotInfo* /* out param */);
-  EfiStatus (*get_current_slot)(struct GblEfiABSlotProtocol*,
-                                GblEfiSlotInfo* /* out param */);
-  EfiStatus (*get_next_slot)(struct GblEfiABSlotProtocol*, bool,
-                             GblEfiSlotInfo* /* out param */);
-  // Slot metadata manipulation methods
-  EfiStatus (*set_active_slot)(struct GblEfiABSlotProtocol*, uint8_t);
-  EfiStatus (*set_slot_unbootable)(struct GblEfiABSlotProtocol*, uint8_t,
-                                   uint32_t);
-  EfiStatus (*reinitialize)(struct GblEfiABSlotProtocol*);
-  // Miscellaneous methods
-  EfiStatus (*get_boot_reason)(struct GblEfiABSlotProtocol*,
-                               uint32_t* /* out param */,
-                               size_t* /* in-out param */,
-                               uint8_t* /* out param*/);
-  EfiStatus (*set_boot_reason)(struct GblEfiABSlotProtocol*, uint32_t, size_t,
-                               const uint8_t*);
-  EfiStatus (*flush)(struct GblEfiABSlotProtocol*);
-} GblEfiABSlotProtocol;
-
-#endif  // __GBL_EFI_AB_SLOT_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_avb_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_avb_protocol.h
deleted file mode 100644
index a91caae..0000000
--- a/gbl/libefi_types/defs/protocols/gbl_efi_avb_protocol.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// This is a custom protocol introduced by GBL.
-// See gbl/docs/gbl_efi_avb_protocol.md for details.
-
-#ifndef __GBL_AVB_PROTOCOL_H__
-#define __GBL_AVB_PROTOCOL_H__
-
-#include "types.h"
-
-// Os boot state color.
-//
-// https://source.android.com/docs/security/features/verifiedboot/boot-flow#communicating-verified-boot-state-to-users
-typedef enum GBL_EFI_AVB_BOOT_STATE_COLOR {
-  GREEN,
-  YELLOW,
-  ORANGE,
-  RED_EIO,
-  RED,
-} GblEfiAvbBootStateColor;
-
-// Vbmeta key validation status.
-//
-// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
-typedef enum GBL_EFI_AVB_KEY_VALIDATION_STATUS {
-  VALID,
-  VALID_CUSTOM_KEY,
-  INVALID,
-} GblEfiAvbKeyValidationStatus;
-
-typedef struct {
-  // GblEfiAvbBootStateColor
-  uint32_t color;
-
-  // Pointer to nul-terminated ASCII hex digest calculated by libavb. May be
-  // null in case of verification failed (RED boot state color).
-  const char8_t* digest;
-
-  // Pointers to nul-terminated os versions and security_patches for different
-  // boot components. NULL is provided in case value isn't presented in the boot
-  // artifacts or fatal AVB failure.
-  // https://source.android.com/docs/core/architecture/bootloader/version-info-avb
-  const char8_t* boot_version;
-  const char8_t* boot_security_patch;
-  const char8_t* system_version;
-  const char8_t* system_security_patch;
-  const char8_t* vendor_version;
-  const char8_t* vendor_security_patch;
-} GblEfiAvbVerificationResult;
-
-typedef struct GblEfiAvbProtocol {
-  uint64_t revision;
-
-  EfiStatus (*validate_vbmeta_public_key)(
-      struct GblEfiAvbProtocol* self, const uint8_t* public_key_data,
-      size_t public_key_length, const uint8_t* public_key_metadata,
-      size_t public_key_metadata_length,
-      /* GblEfiAvbKeyValidationStatus */ uint32_t* validation_status);
-
-  EfiStatus (*read_is_device_unlocked)(struct GblEfiAvbProtocol* self,
-                                       bool* is_unlocked);
-
-  EfiStatus (*read_rollback_index)(struct GblEfiAvbProtocol* self,
-                                   size_t index_location,
-                                   uint64_t* rollback_index);
-
-  EfiStatus (*write_rollback_index)(struct GblEfiAvbProtocol* self,
-                                    size_t index_location,
-                                    uint64_t rollback_index);
-
-  EfiStatus (*read_persistent_value)(struct GblEfiAvbProtocol* self,
-                                     const char* name, uint8_t* value,
-                                     size_t* value_size);
-
-  EfiStatus (*write_persistent_value)(struct GblEfiAvbProtocol* self,
-                                      const char* name, const uint8_t* value,
-                                      size_t value_size);
-
-  EfiStatus (*handle_verification_result)(
-      struct GblEfiAvbProtocol* self,
-      const GblEfiAvbVerificationResult* result);
-
-} GblEfiAvbProtocol;
-
-#endif  //__GBL_AVB_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
deleted file mode 100644
index c0f0f57..0000000
--- a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// This is a custom protocol introduced by GBL.
-// See gbl/docs/GBL_EFI_FASTBOOT_PROTOCOL.md for details.
-
-#ifndef __GBL_EFI_FASTBOOT_PROTOCOL_H__
-#define __GBL_EFI_FASTBOOT_PROTOCOL_H__
-
-#include "types.h"
-
-#define GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8 32
-
-typedef struct GblEfiFastbootPolicy {
-  // Indicates whether device can be unlocked
-  bool can_unlock;
-  // Device firmware supports 'critical' partition locking
-  bool has_critical_lock;
-  // Indicates whether device allows booting from image loaded directly from
-  // RAM.
-  bool can_ram_boot;
-} GblEfiFastbootPolicy;
-
-// Callback function pointer passed to GblEfiFastbootProtocol.get_var_all.
-//
-// context: Caller specific context.
-// args: An array of NULL-terminated strings that contains the variable name
-//       followed by additional arguments if any.
-// val: A NULL-terminated string representing the value.
-typedef void (*GetVarAllCallback)(void* context, const char* const* args,
-                                  size_t num_args, const char* val);
-
-typedef enum GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS {
-  // Firmware can read the given partition and send its data to fastboot client.
-  GBL_EFI_FASTBOOT_PARTITION_READ = 0x1 << 0,
-  // Firmware can overwrite the given partition.
-  GBL_EFI_FASTBOOT_PARTITION_WRITE = 0x1 << 1,
-  // Firmware can erase the given partition.
-  GBL_EFI_FASTBOOT_PARTITION_ERASE = 0x1 << 2,
-} GblEfiFastbootPartitionPermissionFlags;
-
-typedef enum GBL_EFI_FASTBOOT_LOCK_FLAGS {
-  // All device partitions are locked.
-  GBL_EFI_FASTBOOT_GBL_EFI_LOCKED = 0x1 << 0,
-  // All 'critical' device partitions are locked.
-  GBL_EFI_FASTBOOT_GBL_EFI_CRITICAL_LOCKED = 0x1 << 1,
-} GblEfiFastbootLockFlags;
-
-typedef struct GblEfiFastbootProtocol {
-  // Revision of the protocol supported.
-  uint32_t version;
-  // Null-terminated UTF-8 encoded string
-  char8_t serial_number[GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8];
-
-  // Fastboot variable methods
-  EfiStatus (*get_var)(struct GblEfiFastbootProtocol* self,
-                       const char* const* args, size_t num_args, uint8_t* out,
-                       size_t* out_size);
-  EfiStatus (*get_var_all)(struct GblEfiFastbootProtocol* self, void* ctx,
-                           GetVarAllCallback cb);
-
-  // Fastboot oem function methods
-  EfiStatus (*run_oem_function)(struct GblEfiFastbootProtocol* this,
-                                const char8_t* command, size_t command_len,
-                                char8_t* buf, size_t* bufsize);
-
-  // Device lock methods
-  EfiStatus (*get_policy)(struct GblEfiFastbootProtocol* this,
-                          GblEfiFastbootPolicy* policy);
-  EfiStatus (*set_lock)(struct GblEfiFastbootProtocol* this,
-                        uint64_t lock_state);
-  EfiStatus (*clear_lock)(struct GblEfiFastbootProtocol* this,
-                          uint64_t lock_state);
-
-  // Local session methods
-  EfiStatus (*start_local_session)(struct GblEfiFastbootProtocol* this,
-                                   void** ctx);
-  EfiStatus (*update_local_session)(struct GblEfiFastbootProtocol* this,
-                                    void* ctx, uint8_t* buf, size_t* buf_size);
-  EfiStatus (*close_local_session)(struct GblEfiFastbootProtocol* this,
-                                   void* ctx);
-
-  // Misc methods
-  EfiStatus (*get_partition_permissions)(struct GblEfiFastbootProtocol* this,
-                                         const char8_t* part_name,
-                                         size_t part_name_len,
-                                         uint64_t* permissions);
-  EfiStatus (*wipe_user_data)(struct GblEfiFastbootProtocol* this);
-  bool (*should_stop_in_fastboot)(struct GblEfiFastbootProtocol* this);
-} GblEfiFastbootProtocol;
-
-#endif  // __GBL_EFI_FASTBOOT_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_usb.h b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_usb.h
deleted file mode 100644
index 28197c0..0000000
--- a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_usb.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// This is a custom protocol introduced by GBL.
-// See gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md for details.
-
-#ifndef __GBL_EFI_FASTBOOT_USB_H__
-#define __GBL_EFI_FASTBOOT_USB_H__
-
-#include "types.h"
-
-typedef struct GblEfiFastbootUsbProtocol {
-  uint64_t revision;
-  EfiStatus (*fastboot_usb_interface_start)(struct GblEfiFastbootUsbProtocol* self,
-                                            size_t* max_packet_size);
-  EfiStatus (*fastboot_usb_interface_stop)(struct GblEfiFastbootUsbProtocol* self);
-  EfiStatus (*fastboot_usb_receive)(struct GblEfiFastbootUsbProtocol* self,
-                                    size_t* buffer_size, void* buffer);
-  EfiStatus (*fastboot_usb_send)(struct GblEfiFastbootUsbProtocol* self,
-                                 size_t* buffer_size, const void* buffer);
-  EfiEvent wait_for_send_completion;
-} GblEfiFastbootUsbProtocol;
-
-#endif  //__GBL_EFI_FASTBOOT_USB_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_image_loading_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_image_loading_protocol.h
deleted file mode 100644
index 6ab592d..0000000
--- a/gbl/libefi_types/defs/protocols/gbl_efi_image_loading_protocol.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __GBL_EFI_IMAGE_LOADING_PROTOCOL_H__
-#define __GBL_EFI_IMAGE_LOADING_PROTOCOL_H__
-
-#include <stddef.h>
-
-#include "types.h"
-
-const uint64_t GBL_EFI_IMAGE_LOADING_PROTOCOL_REVISION = 0x00010000;
-
-const size_t PARTITION_NAME_LEN_U16 = 36;
-
-//******************************************************
-// GBL reserved image types
-//******************************************************
-// Buffer for loading, verifying and fixing up OS images.
-#define GBL_IMAGE_TYPE_OS_LOAD L"os_load"
-// Buffer for use as fastboot download buffer.
-#define GBL_IMAGE_TYPE_FASTBOOT L"fastboot"
-
-typedef struct GblEfiImageInfo {
-  char16_t ImageType[PARTITION_NAME_LEN_U16];
-  size_t SizeBytes;
-} GblEfiImageInfo;
-
-typedef struct GblEfiImageBuffer {
-  void* Memory;
-  size_t SizeBytes;
-} GblEfiImageBuffer;
-
-typedef struct GblEfiPartitionName {
-  char16_t StrUtf16[PARTITION_NAME_LEN_U16];
-} GblEfiPartitionName;
-
-typedef struct GblEfiImageLoadingProtocol {
-  uint64_t revision;
-  EfiStatus (*get_buffer)(struct GblEfiImageLoadingProtocol* self,
-                          const GblEfiImageInfo* ImageInfo,
-                          GblEfiImageBuffer* Buffer);
-  EfiStatus (*get_verify_partitions)(struct GblEfiImageLoadingProtocol* self,
-                                     size_t* NumberOfPartitions,
-                                     GblEfiPartitionName* Partitions);
-} GblEfiImageLoadingProtocol;
-
-#endif  //__GBL_EFI_IMAGE_LOADING_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
deleted file mode 100644
index be4e957..0000000
--- a/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// This is a custom protocol introduced by GBL.
-// See gbl/docs/gbl_efi_os_configuration_protocol.md for details.
-
-#ifndef __GBL_OS_CONFIGURATION_PROTOCOL_H__
-#define __GBL_OS_CONFIGURATION_PROTOCOL_H__
-
-#include "types.h"
-
-typedef enum GBL_EFI_DEVICE_TREE_SOURCE {
-  BOOT,
-  VENDOR_BOOT,
-  DTBO,
-  DTB
-} GblEfiDeviceTreeSource;
-
-typedef struct {
-  // GblDeviceTreeSource
-  uint32_t source;
-  // Values are zeroed and must not be used in case of BOOT / VENDOR_BOOT source
-  uint32_t id;
-  uint32_t rev;
-  uint32_t custom[4];
-  // Make sure GblDeviceTreeMetadata size is 8-bytes aligned. Also reserved for
-  // the future cases
-  uint32_t reserved;
-} GblEfiDeviceTreeMetadata;
-
-typedef struct {
-  GblEfiDeviceTreeMetadata metadata;
-  // Base device tree / overlay buffer (guaranteed to be 8-bytes aligned),
-  // cannot be NULL. Device tree size can be identified by the header totalsize
-  // field
-  const void* device_tree;
-  // Indicates whether this device tree (or overlay) must be included in the
-  // final device tree. Set to true by a FW if this component must be used
-  bool selected;
-} GblEfiVerifiedDeviceTree;
-
-// Warning: API is UNSTABLE
-// Documentation:
-// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
-typedef struct GblEfiOsConfigurationProtocol {
-  uint64_t revision;
-
-  // Generates fixups for the kernel command line built by GBL.
-  EfiStatus (*fixup_kernel_commandline)(
-      struct GblEfiOsConfigurationProtocol* self, const char8_t* command_line,
-      char8_t* fixup, size_t* fixup_buffer_size);
-
-  // Generates fixups for the bootconfig built by GBL.
-  EfiStatus (*fixup_bootconfig)(struct GblEfiOsConfigurationProtocol* self,
-                                const char8_t* bootconfig, size_t size,
-                                char8_t* fixup, size_t* fixup_buffer_size);
-
-  // Selects which device trees and overlays to use from those loaded by GBL.
-  EfiStatus (*select_device_trees)(struct GblEfiOsConfigurationProtocol* self,
-                                   GblEfiVerifiedDeviceTree* device_trees,
-                                   size_t num_device_trees);
-} GblEfiOsConfigurationProtocol;
-
-#endif  //__GBL_OS_CONFIGURATION_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/loaded_image_protocol.h b/gbl/libefi_types/defs/protocols/loaded_image_protocol.h
deleted file mode 100644
index 69a46f2..0000000
--- a/gbl/libefi_types/defs/protocols/loaded_image_protocol.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __LOADED_IMAGE_PROTOCOL_H__
-#define __LOADED_IMAGE_PROTOCOL_H__
-
-#include "system_table.h"
-#include "types.h"
-
-#include "protocols/device_path_protocol.h"
-
-typedef struct {
-  uint32_t revision;
-  EfiHandle parent_handle;
-  EfiSystemTable* system_table;
-  EfiHandle device_handle;
-  EfiDevicePathToTextProtocol* file_path;
-  void* reserved;
-  uint32_t load_options_size;
-  void* load_options;
-  void* image_base;
-  uint64_t image_size;
-  EfiMemoryType image_code_type;
-  EfiMemoryType image_data_type;
-
-  EfiStatus (*unload)(EfiHandle img);
-} EfiLoadedImageProtocol;
-
-#endif
diff --git a/gbl/libefi_types/defs/protocols/riscv_efi_boot_protocol.h b/gbl/libefi_types/defs/protocols/riscv_efi_boot_protocol.h
deleted file mode 100644
index 528844b..0000000
--- a/gbl/libefi_types/defs/protocols/riscv_efi_boot_protocol.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __RISCV_EFI_BOOT_PROTOCOL_H__
-#define __RISCV_EFI_BOOT_PROTOCOL_H__
-
-#include <stddef.h>
-
-#include "types.h"
-
-// Source: https://github.com/riscv-non-isa/riscv-uefi
-struct EfiRiscvBootProtocol {
-  uint64_t revision;
-
-  EfiStatus (*get_boot_hartid)(struct EfiRiscvBootProtocol* self, size_t* boot_hartid);
-};
-
-#endif  // __RISCV_EFI_BOOT_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/simple_network_protocol.h b/gbl/libefi_types/defs/protocols/simple_network_protocol.h
deleted file mode 100644
index dac43dd..0000000
--- a/gbl/libefi_types/defs/protocols/simple_network_protocol.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// Reference:
-// https://uefi.org/specs/UEFI/2.10/24_Network_Protocols_SNP_PXE_BIS.html#simple-network-protocol
-
-#ifndef __SIMPLE_NETWORK_PROTOCOL_H__
-#define __SIMPLE_NETWORK_PROTOCOL_H__
-
-#include <stddef.h>
-
-#include "types.h"
-
-#define EFI_SIMPLE_NETWORK_PROTOCOL_REVISION 0x00010000
-#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST 0x01
-#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST 0x02
-#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST 0x04
-#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS 0x08
-#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
-
-#define MAX_MCAST_FILTER_CNT 16
-
-typedef struct {
-  uint8_t addr[32];
-} EfiMacAddress;
-
-typedef struct {
-  uint8_t addr[4];
-} EfiIpV4Address;
-
-typedef struct {
-  uint8_t addr[16];
-} EfiIpV6Address;
-
-typedef union {
-  EfiIpV4Address v4;
-  EfiIpV6Address v6;
-  uint32_t addr[4];
-} EfiIpAddr;
-
-typedef struct {
-  uint32_t state;
-  uint32_t hw_address_size;
-  uint32_t media_header_size;
-  uint32_t max_packet_size;
-  uint32_t nv_ram_size;
-  uint32_t nv_ram_access_size;
-  uint32_t receive_filter_mask;
-  uint32_t receive_filter_setting;
-  uint32_t max_m_cast_filter_count;
-  uint32_t m_cast_filter_count;
-  EfiMacAddress m_cast_filter[MAX_MCAST_FILTER_CNT];
-  EfiMacAddress current_address;
-  EfiMacAddress broadcast_address;
-  EfiMacAddress permanent_address;
-  uint8_t if_type;
-  bool mac_address_changeable;
-  bool multiple_tx_supported;
-  bool media_present_supported;
-  bool media_present;
-} EfiSimpleNetworkMode;
-
-typedef struct {
-  uint64_t rx_total_frames;
-  uint64_t rx_good_frames;
-  uint64_t rx_undersize_frames;
-  uint64_t rx_oversize_frames;
-  uint64_t rx_dropped_frames;
-  uint64_t rx_unicast_frames;
-  uint64_t rx_broadcast_frames;
-  uint64_t rx_multicast_frames;
-  uint64_t rx_crc_error_frames;
-  uint64_t rx_total_bytes;
-  uint64_t tx_total_frames;
-  uint64_t tx_good_frames;
-  uint64_t tx_undersize_frames;
-  uint64_t tx_oversize_frames;
-  uint64_t tx_dropped_frames;
-  uint64_t tx_unicast_frames;
-  uint64_t tx_broadcast_frames;
-  uint64_t tx_multicast_frames;
-  uint64_t tx_crc_error_frames;
-  uint64_t tx_total_bytes;
-  uint64_t collisions;
-  uint64_t unsupported_protocol;
-  uint64_t rx_duplicated_frames;
-  uint64_t rx_decrypt_error_frames;
-  uint64_t tx_error_frames;
-  uint64_t tx_retry_frames;
-} EfiNetworkStatistics;
-
-typedef struct EfiSimpleNetworkProtocol {
-  uint64_t revision;
-  EfiStatus (*start)(struct EfiSimpleNetworkProtocol* self);
-  EfiStatus (*stop)(struct EfiSimpleNetworkProtocol* self);
-  EfiStatus (*initialize)(struct EfiSimpleNetworkProtocol* self, size_t extra_rx_buffer_size,
-                          size_t extra_tx_buffer_size);
-  EfiStatus (*reset)(struct EfiSimpleNetworkProtocol* self, bool extended_verification);
-  EfiStatus (*shutdown)(struct EfiSimpleNetworkProtocol* self);
-  EfiStatus (*receive_filters)(struct EfiSimpleNetworkProtocol* self, uint32_t enable,
-                               uint32_t disable, bool reset_mcast_filter, size_t mcast_filter_count,
-                               EfiMacAddress* mcast_filter);
-  EfiStatus (*station_address)(struct EfiSimpleNetworkProtocol* self, bool reset,
-                               EfiMacAddress* new_addr);
-  EfiStatus (*statistics)(struct EfiSimpleNetworkProtocol* self, bool reset, size_t* stats_size,
-                          EfiNetworkStatistics* stats_table);
-  EfiStatus (*m_cast_ip_to_mac)(struct EfiSimpleNetworkProtocol* self, bool ipv6, EfiIpAddr* ip,
-                                EfiMacAddress* mac);
-  EfiStatus (*nv_data)(struct EfiSimpleNetworkProtocol* self, bool read_write, size_t offset,
-                       size_t buf_size, void* buf);
-  EfiStatus (*get_status)(struct EfiSimpleNetworkProtocol* self, uint32_t* interrupt_status,
-                          void** tx_buf);
-  EfiStatus (*transmit)(struct EfiSimpleNetworkProtocol* self, size_t header_size, size_t buf_size,
-                        void* buf, EfiMacAddress* src, EfiMacAddress* dest, uint16_t* protocol);
-  EfiStatus (*receive)(struct EfiSimpleNetworkProtocol* self, size_t* header_size, size_t* buf_size,
-                       void* buf, EfiMacAddress* src, EfiMacAddress* dest, uint16_t* protocol);
-
-  EfiEvent wait_for_packet;
-  EfiSimpleNetworkMode* mode;
-} EfiSimpleNetworkProtocol;
-
-#endif  // __SIMPLE_NETWORK_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/simple_text_input_protocol.h b/gbl/libefi_types/defs/protocols/simple_text_input_protocol.h
deleted file mode 100644
index ff46823..0000000
--- a/gbl/libefi_types/defs/protocols/simple_text_input_protocol.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __SIMPLE_TEXT_INPUT_PROTOCOL_H__
-#define __SIMPLE_TEXT_INPUT_PROTOCOL_H__
-
-#include "types.h"
-
-typedef struct EfiInputKey {
-  uint16_t scan_code;
-  char16_t unicode_char;
-} EfiInputKey;
-
-typedef struct EfiSimpleTextInputProtocol {
-  EfiStatus (*reset)(struct EfiSimpleTextInputProtocol* self,
-                     bool extendend_verification);
-
-  EfiStatus (*read_key_stroke)(struct EfiSimpleTextInputProtocol* self,
-                               EfiInputKey* key);
-
-  EfiEvent wait_for_key;
-} EfiSimpleTextInputProtocol;
-
-#endif  // __SIMPLE_TEXT_INPUT_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/simple_text_output_protocol.h b/gbl/libefi_types/defs/protocols/simple_text_output_protocol.h
deleted file mode 100644
index 67c7c8c..0000000
--- a/gbl/libefi_types/defs/protocols/simple_text_output_protocol.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __SIMPLE_TEXT_OUTPUT_PROTOCOL_H__
-#define __SIMPLE_TEXT_OUTPUT_PROTOCOL_H__
-
-#include "types.h"
-
-typedef struct {
-  int32_t max_mode;
-  int32_t mode;
-  int32_t attribute;
-  int32_t cursor_column;
-  int32_t cursor_row;
-  bool cursor_visible;
-} SimpleTextOutputMode;
-
-typedef struct EfiSimpleTextOutputProtocol {
-  EfiStatus (*reset)(struct EfiSimpleTextOutputProtocol* self, bool extended_verification);
-  EfiStatus (*output_string)(struct EfiSimpleTextOutputProtocol* self, char16_t* string);
-  EfiStatus (*test_string)(struct EfiSimpleTextOutputProtocol* self, char16_t* string);
-  EfiStatus (*query_mode)(struct EfiSimpleTextOutputProtocol* self, size_t mode_num, size_t* cols,
-                          size_t* rows);
-  EfiStatus (*set_mode)(struct EfiSimpleTextOutputProtocol* self, size_t mode_num);
-  EfiStatus (*set_attribute)(struct EfiSimpleTextOutputProtocol* self, size_t attribute);
-  EfiStatus (*clear_screen)(struct EfiSimpleTextOutputProtocol* self);
-  EfiStatus (*set_cursor_position)(struct EfiSimpleTextOutputProtocol* self, size_t col,
-                                   size_t row);
-  EfiStatus (*enable_cursor)(struct EfiSimpleTextOutputProtocol* self, bool visible);
-  SimpleTextOutputMode* mode;
-} EfiSimpleTextOutputProtocol;
-
-#endif  // __SIMPLE_TEXT_OUTPUT_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/runtime_service.h b/gbl/libefi_types/defs/runtime_service.h
deleted file mode 100644
index dbff3ad..0000000
--- a/gbl/libefi_types/defs/runtime_service.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef __RUNTIME_SERVICE_H__
-#define __RUNTIME_SERVICE_H__
-
-#include "types.h"
-
-typedef struct {
-  EfiTableHeader hdr;
-  EfiStatus (*get_time)(EfiTime* time, EfiTimeCapabilities* capabilities);
-  EfiStatus (*set_time)(EfiTime* time);
-  EfiStatus (*get_wakeup_time)(bool* enabled, bool* pending, EfiTime* time);
-  EfiStatus (*set_wakeup_time)(bool enable, EfiTime* time);
-  EfiStatus (*set_virtual_address_map)(size_t memory_map_size,
-                                       size_t descriptor_size,
-                                       uint32_t descriptor_version,
-                                       EfiMemoryDescriptor* virtual_map);
-  EfiStatus (*convert_pointer)(size_t debug_disposition, void** address);
-  EfiStatus (*get_variable)(const char16_t* variable_name,
-                            const EfiGuid* vendor_guid, uint32_t* attributes,
-                            size_t* data_size, void* data);
-  EfiStatus (*get_next_variable_name)(size_t* variable_name_size,
-                                      char16_t* variable_name,
-                                      EfiGuid* vendor_guid);
-  EfiStatus (*set_variable)(const char16_t* variable_name,
-                            const EfiGuid* vendor_guid, uint32_t attributes,
-                            size_t data_size, const void* data);
-  EfiStatus (*get_next_high_monotonic_count)(uint32_t* high_count);
-  void (*reset_system)(EfiResetType reset_type, EfiStatus reset_status,
-                       size_t data_size, void* reset_data);
-  EfiStatus (*update_capsule)(EfiCapsuleHeader** capsule_header_array,
-                              size_t capsule_count,
-                              EfiPhysicalAddr scatter_gather_list);
-  EfiStatus (*query_capsule_capabilities)(
-      EfiCapsuleHeader** capsule_header_array, size_t capsule_count,
-      uint64_t* maximum_capsule_size, EfiResetType* reset_type);
-  EfiStatus (*query_variable_info)(uint32_t attributes,
-                                   uint64_t* maximum_variable_storage_size,
-                                   uint64_t* remaining_variable_storage_size,
-                                   uint64_t* maximum_variable_size);
-} EfiRuntimeService;
-
-#endif  // __RUNTIME_SERVICE_H__
diff --git a/gbl/libefi_types/defs/system_table.h b/gbl/libefi_types/defs/system_table.h
deleted file mode 100644
index 5319c98..0000000
--- a/gbl/libefi_types/defs/system_table.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __SYSTEM_TABLE_H__
-#define __SYSTEM_TABLE_H__
-
-#include "types.h"
-
-#include "boot_service.h"
-#include "protocols/simple_text_output_protocol.h"
-#include "runtime_service.h"
-
-typedef struct {
-  EfiGuid vendor_guid;
-  const void* vendor_table;
-} EfiConfigurationTable;
-
-typedef struct EfiSystemTable {
-  EfiTableHeader header;
-  char16_t* firmware_vendor;
-  uint32_t firmware_revision;
-  EfiHandle console_in_handle;
-  void* con_in;
-  EfiHandle console_out_handle;
-  EfiSimpleTextOutputProtocol* con_out;
-  EfiHandle standard_error_handle;
-  EfiSimpleTextOutputProtocol* std_err;
-  EfiRuntimeService* runtime_services;
-  EfiBootService* boot_services;
-  size_t number_of_table_entries;
-  const EfiConfigurationTable* configuration_table;
-} EfiSystemTable;
-
-#endif  // __SYSTEM_TABLE_H__
diff --git a/gbl/libefi_types/defs/types.h b/gbl/libefi_types/defs/types.h
deleted file mode 100644
index 29758c9..0000000
--- a/gbl/libefi_types/defs/types.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef __EFI_TYPES_H__
-#define __EFI_TYPES_H__
-
-typedef void* EfiHandle;
-typedef uint8_t char8_t;
-typedef uint16_t char16_t;
-typedef void* EfiEvent;
-typedef uint64_t EfiPhysicalAddr;
-typedef uint64_t EfiVirtualAddr;
-
-typedef struct EfiTableHeader {
-  uint64_t signature;
-  uint32_t revision;
-  uint32_t header_size;
-  uint32_t crc32;
-  uint32_t reserved;
-} EfiTableHeader;
-
-typedef struct EfiGuid {
-  uint32_t data1;
-  uint16_t data2;
-  uint16_t data3;
-  uint8_t data4[8];
-} EfiGuid;
-
-typedef struct EfiMemoryAttributesTableHeader {
-  uint32_t version;
-  uint32_t number_of_entries;
-  uint32_t descriptor_size;
-  uint32_t reserved;
-} EfiMemoryAttributesTableHeader;
-
-typedef enum EFI_MEMORY_ATTRIBUTE : uint64_t {
-  EMA_UC = 0x0000000000000001, /* uncached */
-  EMA_WC = 0x0000000000000002, /* write-coalescing */
-  EMA_WT = 0x0000000000000004, /* write-through */
-  EMA_WB = 0x0000000000000008, /* write-back */
-  EMA_WP = 0x0000000000001000, /* write-protect */
-  EMA_RP = 0x0000000000002000, /* read-protect */
-  EMA_XP = 0x0000000000004000, /* execute-protect */
-  EMA_RUNTIME = 0x8000000000000000,
-} EfiMemoryAttribute;
-
-typedef struct EfiMemoryDescriptor {
-  uint32_t memory_type;
-  uint32_t padding;
-  EfiPhysicalAddr physical_start;
-  EfiVirtualAddr virtual_start;
-  uint64_t number_of_pages;
-  uint64_t attributes;
-} EfiMemoryDescriptor;
-
-typedef struct EfiTime {
-  uint16_t year;
-  uint8_t month;
-  uint8_t day;
-  uint8_t hour;
-  uint8_t minute;
-  uint8_t second;
-  uint8_t pad1;
-  uint32_t nanosecond;
-  int16_t timezone;
-  uint8_t daylight;
-  uint8_t pad2;
-} EfiTime;
-
-typedef struct EfiTimeCapabilities {
-  uint32_t resolution;
-  uint32_t accuracy;
-  bool sets_to_zero;
-} EfiTimeCapabilities;
-
-typedef struct EfiCapsuleHeader {
-  EfiGuid CapsuleGuid;
-  uint32_t HeaderSize;
-  uint32_t Flags;
-  uint32_t CapsuleImageSize;
-} EfiCapsuleHeader;
-
-typedef void (*EfiEventNotify)(EfiEvent event, void* ctx);
-
-typedef enum EFI_EVENT_TYPE : uint32_t {
-  TIMER = 0x80000000,
-  RUNTIME = 0x40000000,
-  NOTIFY_WAIT = 0x00000100,
-  NOTIFY_SIGNAL = 0x00000200,
-  SIGNAL_EXIT_BOOT_SERVICES = 0x00000201,
-  SIGNAL_VIRTUAL_ADDRESS_CHANGE = 0x60000202,
-} EfiEventType;
-
-typedef enum EFI_TPL : size_t {
-  APPLICATION = 4,
-  CALLBACK = 8,
-  NOTIFY = 16,
-  HIGH_LEVEL = 31,
-} EfiTpl;
-
-typedef enum EFI_TIMER_DELAY {
-  TIMER_CANCEL,
-  TIMER_PERIODIC,
-  TIMER_RELATIVE
-} EfiTimerDelay;
-
-typedef enum {
-  RESERVED_MEMORY_TYPE,
-  LOADER_CODE,
-  LOADER_DATA,
-  BOOT_SERVICES_CODE,
-  BOOT_SERVICES_DATA,
-  RUNTIME_SERVICES_CODE,
-  RUNTIME_SERVICES_DATA,
-  CONVENTIONAL_MEMORY,
-  UNUSABLE_MEMORY,
-  ACPIRECLAIM_MEMORY,
-  ACPIMEMORY_NVS,
-  MEMORY_MAPPED_IO,
-  MEMORY_MAPPED_IOPORT_SPACE,
-  PAL_CODE,
-  PERSISTENT_MEMORY,
-  MAX_MEMORY_TYPE
-} EFI_MEMORY_TYPE;
-
-typedef EFI_MEMORY_TYPE EfiMemoryType;
-
-typedef enum {
-  EFI_RESET_COLD,
-  EFI_RESET_WARM,
-  EFI_RESET_SHUTDOWN,
-  EFI_RESET_PLATFORM_SPECIFIC
-} EFI_RESET_TYPE;
-
-typedef EFI_RESET_TYPE EfiResetType;
-
-#define EFI_ERROR_MASK ((uintptr_t)INTPTR_MAX + 1)
-#define EFI_ERR(x) (EFI_ERROR_MASK | (x))
-
-typedef enum EFI_STATUS : uintptr_t {
-  SUCCESS = 0u,
-  LOAD_ERROR = EFI_ERR(1),
-  INVALID_PARAMETER = EFI_ERR(2),
-  UNSUPPORTED = EFI_ERR(3),
-  BAD_BUFFER_SIZE = EFI_ERR(4),
-  BUFFER_TOO_SMALL = EFI_ERR(5),
-  NOT_READY = EFI_ERR(6),
-  DEVICE_ERROR = EFI_ERR(7),
-  WRITE_PROTECTED = EFI_ERR(8),
-  OUT_OF_RESOURCES = EFI_ERR(9),
-  VOLUME_CORRUPTED = EFI_ERR(10),
-  VOLUME_FULL = EFI_ERR(11),
-  NO_MEDIA = EFI_ERR(12),
-  MEDIA_CHANGED = EFI_ERR(13),
-  NOT_FOUND = EFI_ERR(14),
-  ACCESS_DENIED = EFI_ERR(15),
-  NO_RESPONSE = EFI_ERR(16),
-  NO_MAPPING = EFI_ERR(17),
-  TIMEOUT = EFI_ERR(18),
-  NOT_STARTED = EFI_ERR(19),
-  ALREADY_STARTED = EFI_ERR(20),
-  ABORTED = EFI_ERR(21),
-  ICMP_ERROR = EFI_ERR(22),
-  TFTP_ERROR = EFI_ERR(23),
-  PROTOCOL_ERROR = EFI_ERR(24),
-  INCOMPATIBLE_VERSION = EFI_ERR(25),
-  SECURITY_VIOLATION = EFI_ERR(26),
-  CRC_ERROR = EFI_ERR(27),
-  END_OF_MEDIA = EFI_ERR(28),
-  END_OF_FILE = EFI_ERR(31),
-  INVALID_LANGUAGE = EFI_ERR(32),
-  COMPROMISED_DATA = EFI_ERR(33),
-  IP_ADDRESS_CONFLICT = EFI_ERR(34),
-  HTTP_ERROR = EFI_ERR(35),
-  CONNECTION_FIN = EFI_ERR(104),
-  CONNECTION_RESET = EFI_ERR(105),
-  CONNECTION_REFUSED = EFI_ERR(106),
-} EfiStatus;
-
-#endif  // __EFI_TYPES_H__
diff --git a/gbl/libefi_types/src/lib.rs b/gbl/libefi_types/src/lib.rs
deleted file mode 100644
index 8d9e2fa..0000000
--- a/gbl/libefi_types/src/lib.rs
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Syntax error: unmatched thing in thing from
-//! std::nonstd::__map<_Cyrillic, _$$$dollars>const basic_string<epic_mystery,
-//! mongoose_traits &lt; char>, __default_alloc_<casual_Fridays = maybe>>
-
-#![cfg_attr(not(test), no_std)]
-
-#[rustfmt::skip]
-pub mod defs;
-pub use defs::*;
-
-impl EfiGuid {
-    /// Returns a new `[EfiGuid]` using the given data.
-    pub const fn new(data1: u32, data2: u16, data3: u16, data4: [u8; 8usize]) -> Self {
-        EfiGuid { data1, data2, data3, data4 }
-    }
-}
-
-impl GblEfiPartitionName {
-    /// Decodes the UCS2 GblEfiPartitionName using buffer, and returns &str of UTF8 representation.
-    ///
-    /// Buffer must be big enough to contain UTF8 representation of the UCS2 partition name.
-    ///
-    /// Maximum partition name as UCS2 is PARTITION_NAME_LEN_U16.
-    /// And [PARTITION_NAME_LEN_U8] bytes is maximum buffer size needed for UTF8 representation.
-    ///
-    /// # Result
-    /// Ok(&str) - On success return UTF8 representation of the partition name
-    /// Err(usize) if provided buffer is too small, with the minimum buffer size as the payload.
-    pub fn get_str<'a>(&self, buffer_utf8: &'a mut [u8]) -> Result<&'a str, usize> {
-        let mut index = 0;
-        let chars_iter = char::decode_utf16(self.StrUtf16.iter().copied())
-            .map(|c_res| c_res.unwrap_or(char::REPLACEMENT_CHARACTER))
-            .take_while(|c| *c != '\0');
-        for c in chars_iter.clone() {
-            if c.len_utf8() <= buffer_utf8[index..].len() {
-                index += c.encode_utf8(&mut buffer_utf8[index..]).len();
-            } else {
-                let buffer_min_len = chars_iter.clone().map(char::len_utf8).sum();
-                return Err(buffer_min_len);
-            }
-        }
-        // SAFETY:
-        // _unchecked should be OK here since we wrote each utf8 byte ourselves,
-        // but it's just an optimization, checked version would be fine also.
-        unsafe { Ok(core::str::from_utf8_unchecked(&buffer_utf8[..index])) }
-    }
-}
-
-impl From<&[u16]> for GblEfiPartitionName {
-    fn from(value: &[u16]) -> Self {
-        let mut res: GblEfiPartitionName = Default::default();
-        res.StrUtf16[..value.len()].copy_from_slice(value);
-        res
-    }
-}
-
-impl<const N: usize> From<[u16; N]> for GblEfiPartitionName {
-    fn from(value: [u16; N]) -> Self {
-        value[..].into()
-    }
-}
diff --git a/gbl/libelf/BUILD b/gbl/libelf/BUILD
deleted file mode 100644
index c246487..0000000
--- a/gbl/libelf/BUILD
+++ /dev/null
@@ -1,59 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "relocation",
-    srcs = ["relocation.cpp"],
-    hdrs = ["public/elf/relocation.h"],
-    copts = select({
-        "@gbl//toolchain:gbl_rust_elf_riscv64": [],
-        # For the `elf_static_relocation_checker` host tool, enable
-        # print and panics as exit().
-        "//conditions:default": ["-DHOST_TOOLING"],
-    }),
-    includes = ["public"],
-    deps = ["@elfutils//:elf_type_header"],
-)
-
-cc_test(
-    name = "relocation_test",
-    size = "small",
-    srcs = ["relocation_test.cpp"],
-    target_compatible_with = [
-        "@platforms//os:linux",
-    ],
-    deps = [
-        ":relocation",
-        "@elfutils//:elf_type_header",
-        "@googletest//:gtest_main",
-    ],
-)
-
-cc_binary(
-    name = "elf_static_relocation_checker",
-    srcs = ["elf_static_relocation_checker.cpp"],
-    copts = [
-        "-std=c++17",
-        "-Wall",
-        "-Werror",
-    ],
-    deps = [
-        ":relocation",
-        "@elfutils//:elf_type_header",
-    ],
-)
diff --git a/gbl/libelf/elf_static_relocation_checker.cpp b/gbl/libelf/elf_static_relocation_checker.cpp
deleted file mode 100644
index f103f83..0000000
--- a/gbl/libelf/elf_static_relocation_checker.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stddef.h>
-#include <stdint.h>
-#include <string.h>
-
-#include <fstream>
-#include <memory>
-#include <optional>
-#include <vector>
-
-#include "elf/relocation.h"
-#include "libelf/elf.h"
-
-namespace {
-// Read an entire ELF file into the memory
-std::vector<uint8_t> ReadFile(const std::string& file_name) {
-  std::ifstream elf_file(file_name, std::ios::binary | std::ios::ate);
-  std::streamsize file_size = elf_file.tellg();
-  elf_file.seekg(0, std::ios::beg);
-
-  std::vector<uint8_t> ret(file_size);
-  elf_file.read(reinterpret_cast<char*>(ret.data()), file_size);
-  return ret;
-}
-}  // namespace
-
-#define ASSERT(cond)                                                                 \
-  {                                                                                  \
-    if (!(cond)) {                                                                   \
-      fprintf(stderr, "%s:%d. Assert failed \"(%s)\"\n", __FILE__, __LINE__, #cond); \
-      exit(1);                                                                       \
-    }                                                                                \
-  }
-
-// Simulate an ELF relocation processs using GBL relocation library. Fail if the ELF contains
-// relocation types that we don't expect.
-//
-// Usage:
-//   <executable> <ELF file> <Binary only version (ELF header stripped) of the ELF>
-//
-// The binary only version can be obtained by `llvm-objcopy -O binary <ELF> <output>`
-//
-// Return 0 if successful.
-int main(int argc, char* argv[]) {
-  if (argc != 3) {
-    return 1;
-  }
-
-  std::vector<uint8_t> elf_file = ReadFile(argv[1]);
-  std::vector<uint8_t> bin_file = ReadFile(argv[2]);
-
-  Elf64_Ehdr elf_header;
-  ASSERT(elf_file.size() >= sizeof(elf_header));
-  memcpy(&elf_header, elf_file.data(), sizeof(elf_header));
-
-  // Iterate all program headers and find out the address for dynamic section.
-  const uint8_t* program_hdr_start = elf_file.data() + elf_header.e_phoff;
-  std::optional<uint64_t> dynamic_section_offset = std::nullopt;
-  for (size_t i = 0; i < elf_header.e_phnum; i++) {
-    const uint8_t* header_start = program_hdr_start + i * sizeof(Elf64_Phdr);
-    Elf64_Phdr elf_program_header;
-    ASSERT(static_cast<size_t>(header_start + sizeof(elf_program_header) - elf_file.data()) <=
-           elf_file.size());
-    memcpy(&elf_program_header, header_start, sizeof(elf_program_header));
-    if (elf_program_header.p_type == PT_DYNAMIC) {
-      // Store the physical address
-      // For PIE ELF this is the relative offset to ELF file start.
-      dynamic_section_offset = elf_program_header.p_paddr;
-      break;
-    }
-  }
-
-  // Dynamic section not found.
-  if (!dynamic_section_offset) {
-    return 1;
-  }
-
-  ASSERT(bin_file.size() >= *dynamic_section_offset);
-  // Perform relocation as if we have loaded the program @ address bin_file.data().
-  return ApplyRelocation(reinterpret_cast<uintptr_t>(bin_file.data()),
-                         reinterpret_cast<uintptr_t>(bin_file.data() + *dynamic_section_offset))
-             ? 0
-             : 1;
-}
diff --git a/gbl/libelf/public/elf/relocation.h b/gbl/libelf/public/elf/relocation.h
deleted file mode 100644
index 286f070..0000000
--- a/gbl/libelf/public/elf/relocation.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-// Check .dynamic section in an ELF and apply necessary relocation.
-//
-// The API assumes that program_base and dynamic section address are properly aligned.
-// For 64bit applications, alignment should be at least multiple of 8bytes.
-//
-// @program_base: Absolute address the program loaded to.
-// @dynamic_section: Absolute address of the dynamic section
-//
-// Return true on success.
-extern "C" bool ApplyRelocation(uintptr_t program_base, uintptr_t dynamic_section);
diff --git a/gbl/libelf/relocation.cpp b/gbl/libelf/relocation.cpp
deleted file mode 100644
index 8c7e8d6..0000000
--- a/gbl/libelf/relocation.cpp
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// The code in this file is responsible for applying dynamic relocation
-// for position independent ELF. It itself has to work without any relocation.
-// That means all dependencies of this file need to be statically linked. There
-// shall not be any reference to any symbol from dynamically linked library
-// before relocation is done.
-//
-// It would be worth to investigate if this can be implemented in rust.
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include "libelf/elf.h"
-
-#include "elf/relocation.h"
-
-#ifdef HOST_TOOLING
-#include <stdio.h>
-#include <stdlib.h>
-#define RELOCATION_PRINTF(...) fprintf(stderr, __VA_ARGS__)
-#else
-#define RELOCATION_PRINTF(...)
-#endif
-
-namespace {
-
-struct DynamicSectionInfo {
-  const Elf64_Dyn* rel;
-  const Elf64_Dyn* rel_size;
-  const Elf64_Dyn* rela;
-  const Elf64_Dyn* rela_size;
-  const Elf64_Sym* symtab;
-};
-
-Elf64_Sxword GetRelxAddend(const Elf64_Rela& entry, uint64_t*) {
-  return entry.r_addend;
-}
-Elf64_Sxword GetRelxAddend(const Elf64_Rel&, uint64_t* addr) {
-  return *addr;
-}
-
-// Perform relocation fixup for the given RELA/REL relocation table.
-//
-// For more information about REL/RELA relocation, see the Relocation and Dynamic linking
-// related sections in System V ABI (https://www.sco.com/developers/gabi/latest/contents.html)
-template <typename T>
-bool FixUpRelxTable(uintptr_t program_base, [[maybe_unused]] const Elf64_Sym* symtab,
-                    uintptr_t table_addr, size_t size) {
-  size_t num_entries = size / sizeof(T);
-  const T* table = reinterpret_cast<const T*>(table_addr);
-  for (size_t i = 0; i < num_entries; i++) {
-    const T& entry = table[i];
-    // Type of the relocation. It determines the calculation.
-    uint64_t reloc_type = entry.r_info & 0xffffffff;
-    // Address for storing the new calculated address.
-    // TODO(294059825): Add support for overflow checking.
-    uint64_t* addr = reinterpret_cast<uint64_t*>(program_base + entry.r_offset);
-    // Addend value. For RELA, it comes from the entry. For REL, it's the current
-    // value at address `addr`.
-    Elf64_Sxword addend = GetRelxAddend(entry, addr);
-    // Index of the corresponding symbol in the symbol table.
-    // Certain type of relocation requires to modify symbol table. Keep this here
-    // for reference.
-    [[maybe_unused]] size_t symbol_index = entry.r_info >> 32;
-
-    // Now process the various type of relocation.
-    //
-    // For documents about AARCH64 relocation, see
-    // https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#5712dynamic-relocations
-    //
-    // For document about RISC-V relocation, see
-    // https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#relocations
-    //
-    // GBL's usage of ELF is restricted. We only implement relocations that we expect to see.
-    if (reloc_type == R_RISCV_RELATIVE) {
-      // This is the most common type of relocation. For position independent executable,
-      // symbol address is typically the relative offset to program start. Relocated absolute
-      // address is obtained by adding the address the program is loaded to.
-      *addr = program_base + addend;
-    } else {
-      RELOCATION_PRINTF("Unhandled relocation type: %lx\n", reloc_type);
-      return false;
-    }
-  }
-
-  return true;
-}
-
-// Search for RELA type relocation table from the .dynamic section and apply relocation fix up if
-// there is one.
-bool ApplyRelaRelocation(uintptr_t program_base, const DynamicSectionInfo& info) {
-  if ((info.rela == NULL) != (info.rela_size == NULL)) {
-    return false;
-  } else if (!info.rela) {
-    return true;
-  }
-  return FixUpRelxTable<Elf64_Rela>(program_base, info.symtab, info.rela->d_un.d_ptr + program_base,
-                                    info.rela_size->d_un.d_val);
-}
-
-// Search for REL type relocation table from the .dynamic section and apply relocation fix up if
-// there is one.
-bool ApplyRelRelocation(uintptr_t program_base, const DynamicSectionInfo& info) {
-  if ((info.rel == NULL) != (info.rel_size == NULL)) {
-    return false;
-  } else if (!info.rel) {
-    return true;
-  }
-  return FixUpRelxTable<Elf64_Rel>(program_base, info.symtab, info.rel->d_un.d_ptr + program_base,
-                                   info.rel_size->d_un.d_val);
-}
-
-}  // namespace
-
-extern "C" bool ApplyRelocation(uintptr_t program_base, uintptr_t dynamic_section) {
-  DynamicSectionInfo dynamic_section_info = {
-      .rel = NULL,
-      .rel_size = NULL,
-      .rela = NULL,
-      .rela_size = NULL,
-      .symtab = NULL,
-  };
-
-  const Elf64_Dyn* dynamic_section_table = reinterpret_cast<const Elf64_Dyn*>(dynamic_section);
-  for (size_t i = 0; dynamic_section_table[i].d_tag != DT_NULL; i++) {
-    switch (dynamic_section_table[i].d_tag) {
-      // RELA type relocation entries
-      case DT_RELA:
-        dynamic_section_info.rela = &dynamic_section_table[i];
-        break;
-      // RELA type relocation entries total size
-      case DT_RELASZ:
-        dynamic_section_info.rela_size = &dynamic_section_table[i];
-        break;
-      // REL type relocation entries
-      case DT_REL:
-        dynamic_section_info.rel = &dynamic_section_table[i];
-        break;
-      // RELA type relocation entries total size
-      case DT_RELSZ:
-        dynamic_section_info.rel_size = &dynamic_section_table[i];
-        break;
-      // Symbol table
-      case DT_SYMTAB:
-        dynamic_section_info.symtab =
-            (const Elf64_Sym*)(dynamic_section_table[i].d_un.d_ptr + program_base);
-        break;
-      // We shouldn't see RELR relocation unless `-Wl,--pack-dyn-relocs=relr` is used.
-      case DT_RELR:
-      // We shouldn't see PLT relocation unless we are loading a shared library.
-      case DT_JMPREL:
-        return false;
-      default:
-        break;
-    }
-  }
-
-  if (!dynamic_section_info.symtab) {
-    return false;
-  }
-
-  return ApplyRelRelocation(program_base, dynamic_section_info) &&
-         ApplyRelaRelocation(program_base, dynamic_section_info);
-}
diff --git a/gbl/libelf/relocation_test.cpp b/gbl/libelf/relocation_test.cpp
deleted file mode 100644
index 4c635e9..0000000
--- a/gbl/libelf/relocation_test.cpp
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vector>
-
-#include "gtest/gtest.h"
-
-#include "elf/relocation.h"
-#include "libelf/elf.h"
-
-template <typename T>
-struct DtTags {};
-
-template <>
-struct DtTags<Elf64_Rela> {
-  static constexpr uint64_t kTableTag = DT_RELA;
-  static constexpr uint64_t kTableSizeTag = DT_RELASZ;
-};
-
-template <>
-struct DtTags<Elf64_Rel> {
-  static constexpr uint64_t kTableTag = DT_REL;
-  static constexpr uint64_t kTableSizeTag = DT_RELSZ;
-};
-
-template <size_t num_relocs, typename RelocType>
-class Program {
- public:
-  struct DynamicSection {
-    Elf64_Dyn symtab;
-    Elf64_Dyn relx;
-    Elf64_Dyn relx_size;
-    Elf64_Dyn other_entry;
-    Elf64_Dyn end;
-  };
-
-  Program() {
-    dynamic_section_ = {
-        .symtab =
-            {
-                .d_tag = DT_SYMTAB,
-                .d_un = {.d_ptr = offsetof(ThisType, symtab_)},
-            },
-        .relx =
-            {
-                .d_tag = DtTags<RelocType>::kTableTag,
-                .d_un = {.d_ptr = offsetof(ThisType, table_)},
-            },
-        .relx_size =
-            {
-                .d_tag = DtTags<RelocType>::kTableSizeTag,
-                .d_un = {.d_ptr = sizeof(table_)},
-            },
-        .other_entry =
-            {
-                .d_tag = DT_NULL,
-            },
-        .end =
-            {
-                .d_tag = DT_NULL,
-            },
-    };
-
-    for (size_t i = 0; i < num_relocs; i++) {
-      table_[i].r_offset = offsetof(ThisType, relocated_addr_table_) + i * sizeof(uint64_t);
-    }
-  }
-
-  uint64_t GetRelocatedAddr(size_t index) { return relocated_addr_table_[index]; }
-
-  void SetRelocationInfo(size_t index, uint64_t type, uint64_t addend) {
-    ASSERT_LE(index, num_relocs);
-    table_[index].r_info = type;
-    SetAddend(table_[index], relocated_addr_table_[index], addend);
-  }
-
-  uint64_t DynamicSectionAddr() { return reinterpret_cast<uint64_t>(&dynamic_section_); }
-
-  uint64_t ProgramBase() { return reinterpret_cast<uint64_t>(this); }
-
-  DynamicSection& dynamic_section() { return dynamic_section_; }
-
- public:
-  using ThisType = Program<num_relocs, RelocType>;
-  DynamicSection dynamic_section_;
-  Elf64_Sym symtab_;
-  RelocType table_[num_relocs];
-  uint64_t relocated_addr_table_[num_relocs];
-
-  void SetAddend(Elf64_Rela& entry, uint64_t&, uint64_t addend) { entry.r_addend = addend; }
-
-  void SetAddend(Elf64_Rel&, uint64_t& relocated_addr, uint64_t addend) { relocated_addr = addend; }
-};
-
-template <typename T>
-void TestRelxRelocation() {
-  Program<2, T> program;
-
-  const uint64_t kAddend_0 = 0x100;
-  program.SetRelocationInfo(0, R_RISCV_RELATIVE, kAddend_0);
-  const uint64_t kAddend_1 = 0x200;
-  program.SetRelocationInfo(1, R_RISCV_RELATIVE, kAddend_1);
-
-  EXPECT_TRUE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-
-  EXPECT_EQ(program.GetRelocatedAddr(0), program.ProgramBase() + kAddend_0);
-  EXPECT_EQ(program.GetRelocatedAddr(1), program.ProgramBase() + kAddend_1);
-}
-
-TEST(RelocationTest, RelaRelocation) {
-  TestRelxRelocation<Elf64_Rela>();
-}
-
-TEST(RelocationTest, RelRelocation) {
-  TestRelxRelocation<Elf64_Rel>();
-}
-
-template <typename T>
-void TestUnrecognizeRelcoationType() {
-  Program<1, T> program;
-  program.SetRelocationInfo(0, R_RISCV_RELATIVE + 1, 0x1000);
-  EXPECT_FALSE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-}
-
-TEST(RelocationTest, RelaUnrecognizeRelcoationType) {
-  TestUnrecognizeRelcoationType<Elf64_Rela>();
-}
-
-TEST(RelocationTest, RelUnrecognizeRelcoationType) {
-  TestUnrecognizeRelcoationType<Elf64_Rel>();
-}
-
-template <typename T>
-void TestRelxIncompleteInformation() {
-  {
-    Program<1, T> program;
-    program.SetRelocationInfo(0, R_RISCV_RELATIVE, 0x1000);
-    // Missing table size.
-    program.dynamic_section().relx_size.d_tag = DT_HASH;  // Don't care
-    EXPECT_FALSE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-  }
-
-  {
-    Program<1, T> program;
-    program.SetRelocationInfo(0, R_RISCV_RELATIVE, 0x1000);
-    // Missing table itself.
-    program.dynamic_section().relx.d_tag = DT_HASH;  // Don't care
-    EXPECT_FALSE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-  }
-}
-
-TEST(RelocationTest, TestRelaIncompleteInformation) {
-  TestRelxIncompleteInformation<Elf64_Rela>();
-}
-
-TEST(RelocationTest, TestRelIncompleteInformation) {
-  TestRelxIncompleteInformation<Elf64_Rel>();
-}
-
-TEST(RelocationTest, PltUnsupported) {
-  Program<1, Elf64_Rela> program;
-  program.SetRelocationInfo(0, R_RISCV_RELATIVE, 0x1000);
-  program.dynamic_section().other_entry.d_tag = DT_JMPREL;
-  EXPECT_FALSE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-}
-
-TEST(RelocationTest, RelrUnsupported) {
-  Program<1, Elf64_Rela> program;
-  program.SetRelocationInfo(0, R_RISCV_RELATIVE, 0x1000);
-  program.dynamic_section().other_entry.d_tag = DT_RELR;
-  EXPECT_FALSE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-}
-
-TEST(RelocationTest, MissingSymtab) {
-  Program<1, Elf64_Rela> program;
-  program.SetRelocationInfo(0, R_RISCV_RELATIVE, 0x1000);
-  program.dynamic_section().symtab.d_tag = DT_HASH;  // Don't care
-  EXPECT_FALSE(ApplyRelocation(program.ProgramBase(), program.DynamicSectionAddr()));
-}
diff --git a/gbl/liberror/BUILD b/gbl/liberror/BUILD
deleted file mode 100644
index 754ea76..0000000
--- a/gbl/liberror/BUILD
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-rust_library(
-    name = "liberror",
-    srcs = glob(
-        ["**/*.rs"],
-    ),
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-    deps = [
-        "@gbl//libefi_types",
-        "@gbl//libsafemath",
-    ],
-)
-
-rust_test(
-    name = "liberror_test",
-    crate = ":liberror",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/liberror/src/lib.rs b/gbl/liberror/src/lib.rs
deleted file mode 100644
index 269d2ce..0000000
--- a/gbl/liberror/src/lib.rs
+++ /dev/null
@@ -1,385 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Unified error type library
-//!
-//! This crate defines a common error type for all of GBL.
-//! It is intended to reduce conversion boilerplate and to make
-//! the various GBL libraries interoperate more cleanly.
-//!
-//! Because of its intended broad application, certain error types will
-//! be highly specific to particular libraries.
-//! More specific errors can be useful when writing unit tests or when defining
-//! APIs that third party code may interact with.
-//! It's a judgement call whether a new variant should be added,
-//! but if possible try to use an existing variant.
-//!
-//! It is a further judgement call whether a new variant should wrap a payload.
-//! The rule of thumb is that a payload requires one of the following conditions:
-//! 1) The error will be logged and the payload will help with debugging.
-//! 2) The error is transient or retriable, and the payload helps with the retry.
-//!
-//! New error variants should be inserted alphabetically.
-
-#![cfg_attr(not(any(test, android_dylib)), no_std)]
-
-use core::{
-    ffi::{FromBytesUntilNulError, FromBytesWithNulError},
-    str::Utf8Error,
-};
-
-use efi_types as efi;
-
-/// Gpt related errors.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum GptError {
-    /// Secondary header is valid, but different from primary.
-    DifferentFromPrimary,
-    /// Disk size is not enough to accommodate maximum allowed entries.
-    DiskTooSmall,
-    /// GPT entries buffer is too small for the expected number of entries.
-    EntriesTruncated,
-    /// GPT header CRC is not correct.
-    IncorrectHeaderCrc,
-    /// GPT header MAGIC is not correct.
-    IncorrectMagic(u64),
-    /// GPT entries CRC doesn't match.
-    IncorrectEntriesCrc,
-    /// Invalid first and last usable block in the GPT header.
-    InvalidFirstLastUsableBlock {
-        /// The value of first usable block in the GPT header.
-        first: u64,
-        /// The value of last usable block in the GPT header.
-        last: u64,
-        /// Expected range inclusive.
-        range: (u64, u64),
-    },
-    /// Partition range is invalid.
-    InvalidPartitionRange {
-        /// Partition index (1-based).
-        idx: usize,
-        /// Range of the partition, inclusive.
-        part_range: (u64, u64),
-        /// Range of usable block, inclusive.
-        usable_range: (u64, u64),
-    },
-    /// Invalid start block for primary GPT entries.
-    InvalidPrimaryEntriesStart {
-        /// The entry start block value.
-        value: u64,
-        /// Expected range.
-        expect_range: (u64, u64),
-    },
-    /// Invalid start block for secondary GPT entries.
-    InvalidSecondaryEntriesStart {
-        /// The entry start block value.
-        value: u64,
-        /// Expected range.
-        expect_range: (u64, u64),
-    },
-    /// Number of entries greater than maximum allowed.
-    NumberOfEntriesOverflow {
-        /// Actual number of entries,
-        entries: u32,
-        /// Maximum allowed.
-        max_allowed: usize,
-    },
-    /// Two partitions overlap.
-    PartitionRangeOverlap {
-        /// Previous partition in overlap. (partition index, first, last)
-        prev: (usize, u64, u64),
-        /// Next partition in overlap. (partition index, first, last)
-        next: (usize, u64, u64),
-    },
-    /// Unexpected GPT header size.
-    UnexpectedEntrySize {
-        /// The actual entry size in the GPT header.
-        actual: u32,
-        /// The expected size.
-        expect: usize,
-    },
-    /// Unexpected GPT header size.
-    UnexpectedHeaderSize {
-        /// The actual header size in the GPT header.
-        actual: u32,
-        /// The expected size.
-        expect: usize,
-    },
-    /// Zero partition type GUID.
-    ZeroPartitionTypeGUID {
-        /// Partition index (1-based).
-        idx: usize,
-    },
-    /// Zero partition unique GUID.
-    ZeroPartitionUniqueGUID {
-        /// Partition index (1-based).
-        idx: usize,
-    },
-}
-
-/// Common, universal error type
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum Error {
-    /// An operation has been aborted. Useful for async or IO operations.
-    Aborted,
-    /// Access was denied.
-    AccessDenied,
-    /// The protocol has already been started.
-    AlreadyStarted,
-    /// A checked arithmetic operation has overflowed.
-    ArithmeticOverflow(safemath::Error),
-    /// The buffer was not the proper size for the request (different from BufferTooSmall).
-    BadBufferSize,
-    /// Data verification has encountered an invalid checksum.
-    BadChecksum,
-    /// An operation attempted to access data outside of the valid range.
-    /// Includes the problematic index.
-    BadIndex(usize),
-    /// Data verification has encountered an invalid magic number.
-    BadMagic,
-    /// Generic BlockIO error.
-    BlockIoError,
-    /// Generic boot failure has occurred.
-    BootFailed,
-    /// Buffers provided by third party code overlap.
-    BufferOverlap,
-    /// The provided buffer is too small.
-    /// If Some(n), provides the minimum required buffer size.
-    BufferTooSmall(Option<usize>),
-    /// The security status of the data is unknown or compromised
-    /// and the data must be updated or replaced to restore a valid security status.
-    CompromisedData,
-    /// The remote peer has reset the network connection.
-    ConnectionReset,
-    /// A relevant device encountered an error.
-    DeviceError,
-    /// The connected peripheral or network peer has disconnected.
-    Disconnected,
-    /// The end of the file was reached.
-    EndOfFile,
-    /// Beginning or end of media was reached
-    EndOfMedia,
-    /// A polled operation has finished
-    Finished,
-    /// GPT related errors.
-    GptError(GptError),
-    /// A HTTP error occurred during a network operation.
-    HttpError,
-    /// An ICMP error occurred during a network operation.
-    IcmpError,
-    /// The provided buffer or data structure is invalidly aligned.
-    InvalidAlignment,
-    /// A connected agent failed a multi-stage handshake.
-    InvalidHandshake,
-    /// At least one parameter fails preconditions.
-    InvalidInput,
-    /// The language specified was invalid.
-    InvalidLanguage,
-    /// A state machine has entered an invalid state.
-    InvalidState,
-    /// There was a conflict in IP address allocation.
-    IpAddressConflict,
-    /// Image failed to load
-    LoadError,
-    /// The medium in the device has changed since the last access.
-    MediaChanged,
-    /// Memory map error with error code.
-    MemoryMapCallbackError(i64),
-    /// An image required for system boot is missing.
-    MissingImage,
-    /// A valid Flattened Device Tree was not found.
-    NoFdt,
-    /// The block device does not have a valid GUID Partition Table.
-    NoGpt,
-    /// A mapping to a device does not exist.
-    NoMapping,
-    /// The device does not contain any medium to perform the operation.
-    NoMedia,
-    /// The server was not found or did not respond to the request.
-    NoResponse,
-    /// The requested element (e.g. device, partition, or value) was not found.
-    NotFound,
-    /// The default implementation for a trait method has not been overridden.
-    NotImplemented,
-    /// The polled device or future is not ready.
-    NotReady,
-    /// The protocol has not been started.
-    NotStarted,
-    /// The provided name does not uniquely describe a partition.
-    NotUnique,
-    /// Generic permissions failure.
-    OperationProhibited,
-    /// Catch-all error with optional debugging string.
-    Other(Option<&'static str>),
-    /// Out of range.
-    OutOfRange,
-    /// A resource has run out.
-    OutOfResources,
-    /// A protocol error occurred during the network operation.
-    ProtocolError,
-    /// The function was not performed due to a security violation.
-    SecurityViolation,
-    /// A TFTP error occurred during a network operation.
-    TftpError,
-    /// Operation has timed out.
-    Timeout,
-    /// Exceeds maximum number of partition for verification. The contained value represents the
-    /// maximum allowed number of partitions.
-    TooManyPartitions(usize),
-    /// The remote network endpoint is not addressable.
-    Unaddressable,
-    /// An unknown, unexpected EFI_STATUS error code was returned,
-    UnexpectedEfiError(efi::EfiStatus),
-    /// Return from function that is not expected to return.
-    UnexpectedReturn,
-    /// Operation is unsupported
-    Unsupported,
-    /// Data verification has encountered a version number that is not supported.
-    UnsupportedVersion,
-    /// An inconstancy was detected on the file system causing the operating to fail.
-    VolumeCorrupted,
-    /// There is no more space on the file system.
-    VolumeFull,
-    /// The device cannot be written to.
-    WriteProtected,
-}
-
-impl From<Option<&'static str>> for Error {
-    fn from(val: Option<&'static str>) -> Self {
-        Self::Other(val)
-    }
-}
-
-impl From<&'static str> for Error {
-    fn from(val: &'static str) -> Self {
-        Self::Other(Some(val))
-    }
-}
-
-impl From<safemath::Error> for Error {
-    fn from(err: safemath::Error) -> Self {
-        Self::ArithmeticOverflow(err)
-    }
-}
-
-impl From<core::num::TryFromIntError> for Error {
-    #[track_caller]
-    fn from(err: core::num::TryFromIntError) -> Self {
-        Self::ArithmeticOverflow(err.into())
-    }
-}
-
-impl From<FromBytesUntilNulError> for Error {
-    fn from(_: FromBytesUntilNulError) -> Self {
-        Self::InvalidInput
-    }
-}
-
-impl From<FromBytesWithNulError> for Error {
-    fn from(_: FromBytesWithNulError) -> Self {
-        Self::InvalidInput
-    }
-}
-
-impl From<Utf8Error> for Error {
-    fn from(_: Utf8Error) -> Self {
-        Self::InvalidInput
-    }
-}
-
-impl core::fmt::Display for Error {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        write!(f, "{:#?}", self)
-    }
-}
-
-impl From<core::fmt::Error> for Error {
-    fn from(_: core::fmt::Error) -> Self {
-        Self::Unsupported
-    }
-}
-
-/// Helper type alias.
-pub type Result<T> = core::result::Result<T, Error>;
-
-/// Workaround for orphan rule.
-pub fn efi_status_to_result(e: efi::EfiStatus) -> Result<()> {
-    match e {
-        efi::EFI_STATUS_SUCCESS => Ok(()),
-        efi::EFI_STATUS_CRC_ERROR => Err(Error::BadChecksum),
-        efi::EFI_STATUS_ABORTED => Err(Error::Aborted),
-        efi::EFI_STATUS_ACCESS_DENIED => Err(Error::AccessDenied),
-        efi::EFI_STATUS_ALREADY_STARTED => Err(Error::AlreadyStarted),
-        efi::EFI_STATUS_BAD_BUFFER_SIZE => Err(Error::BadBufferSize),
-        efi::EFI_STATUS_BUFFER_TOO_SMALL => Err(Error::BufferTooSmall(None)),
-        efi::EFI_STATUS_COMPROMISED_DATA => Err(Error::CompromisedData),
-        efi::EFI_STATUS_CONNECTION_FIN => Err(Error::Disconnected),
-        efi::EFI_STATUS_CONNECTION_REFUSED => Err(Error::OperationProhibited),
-        efi::EFI_STATUS_CONNECTION_RESET => Err(Error::ConnectionReset),
-        efi::EFI_STATUS_DEVICE_ERROR => Err(Error::DeviceError),
-        efi::EFI_STATUS_END_OF_FILE => Err(Error::EndOfFile),
-        efi::EFI_STATUS_END_OF_MEDIA => Err(Error::EndOfMedia),
-        efi::EFI_STATUS_HTTP_ERROR => Err(Error::HttpError),
-        efi::EFI_STATUS_ICMP_ERROR => Err(Error::IcmpError),
-        efi::EFI_STATUS_INCOMPATIBLE_VERSION => Err(Error::UnsupportedVersion),
-        efi::EFI_STATUS_INVALID_LANGUAGE => Err(Error::InvalidLanguage),
-        efi::EFI_STATUS_INVALID_PARAMETER => Err(Error::InvalidInput),
-        efi::EFI_STATUS_IP_ADDRESS_CONFLICT => Err(Error::IpAddressConflict),
-        efi::EFI_STATUS_LOAD_ERROR => Err(Error::LoadError),
-        efi::EFI_STATUS_MEDIA_CHANGED => Err(Error::MediaChanged),
-        efi::EFI_STATUS_NOT_FOUND => Err(Error::NotFound),
-        efi::EFI_STATUS_NOT_READY => Err(Error::NotReady),
-        efi::EFI_STATUS_NOT_STARTED => Err(Error::NotStarted),
-        efi::EFI_STATUS_NO_MAPPING => Err(Error::NoMapping),
-        efi::EFI_STATUS_NO_MEDIA => Err(Error::NoMedia),
-        efi::EFI_STATUS_NO_RESPONSE => Err(Error::NoResponse),
-        efi::EFI_STATUS_OUT_OF_RESOURCES => Err(Error::OutOfResources),
-        efi::EFI_STATUS_PROTOCOL_ERROR => Err(Error::ProtocolError),
-        efi::EFI_STATUS_SECURITY_VIOLATION => Err(Error::SecurityViolation),
-        efi::EFI_STATUS_TFTP_ERROR => Err(Error::TftpError),
-        efi::EFI_STATUS_TIMEOUT => Err(Error::Timeout),
-        efi::EFI_STATUS_UNSUPPORTED => Err(Error::Unsupported),
-        efi::EFI_STATUS_VOLUME_CORRUPTED => Err(Error::VolumeCorrupted),
-        efi::EFI_STATUS_VOLUME_FULL => Err(Error::VolumeFull),
-        efi::EFI_STATUS_WRITE_PROTECTED => Err(Error::WriteProtected),
-        // The UEFI spec reserves part of the error space for
-        // OEM defined errors and warnings.
-        // We can't know in advance what these are or what they mean,
-        // so just preserve them as is.
-        e => Err(Error::UnexpectedEfiError(e)),
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_from_safemath_error() {
-        let n = u8::try_from(safemath::SafeNum::ZERO - 1).unwrap_err();
-        let _e: Error = n.into();
-    }
-
-    #[test]
-    fn test_from_str() {
-        let _e: Error = "error string".into();
-    }
-
-    #[test]
-    fn test_from_str_option() {
-        let _e: Error = Some("error string").into();
-        let n: Option<&str> = None;
-        let _e2: Error = n.into();
-    }
-}
diff --git a/gbl/libfastboot/BUILD b/gbl/libfastboot/BUILD
deleted file mode 100644
index 334842d..0000000
--- a/gbl/libfastboot/BUILD
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libfastboot",
-    srcs = glob(["**/*.rs"]),
-    crate_name = "fastboot",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libasync",
-        "@gbl//liberror",
-        "@gbl//libutils",
-    ],
-)
-
-rust_test(
-    name = "libfastboot_test",
-    crate = ":libfastboot",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libfastboot/src/lib.rs b/gbl/libfastboot/src/lib.rs
deleted file mode 100644
index d589f2d..0000000
--- a/gbl/libfastboot/src/lib.rs
+++ /dev/null
@@ -1,1763 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides APIs for receiving, processing and replying to fastboot commands. To use
-//! the library:
-//!
-//! 1. Provide a transport backend by implementing the `Transport` trait.
-//!
-//! ```
-//!
-//! struct FastbootTransport {}
-//!
-//! impl Transport<MyErrorType> for TestTransport {
-//!     fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, TransportError> {
-//!         todo!();
-//!     }
-//!
-//!     fn send_packet(&mut self, packet: &[u8]) -> Result<(), TransportError> {
-//!         todo!();
-//!     }
-//! }
-//! ```
-//!
-//! 2. Provide a fastboot command backend by implementing the `FastbootImplementation` trait.
-//!    i.e.
-//!
-//! ```
-//!
-//! struct FastbootCommand {}
-//!
-//! impl FastbootImplementation for FastbootTest {
-//!     fn get_var(
-//!         &mut self,
-//!         var: &str,
-//!         args: Split<char>,
-//!         out: &mut [u8],
-//!     ) -> CommandResult<usize> {
-//!         todo!();
-//!     }
-//!
-//!     ...
-//! }
-//!```
-//!
-//! 3. Construct a `Fastboot` object with a given download buffer. Pass the transport, command
-//!    implementation and call the `run()` method:
-//!
-//! ```
-//! let mut fastboot_impl: FastbootCommand = ...;
-//! let mut transport: TestTransport = ...;
-//! let download_buffer: &mut [u8] = ...;
-//! let mut fastboot = Fastboot::new();
-//! let result = run(&mut transport, &mut fastboot_impl, &[]);
-//! ```
-
-#![cfg_attr(not(test), no_std)]
-#![allow(async_fn_in_trait)]
-
-use core::{
-    ffi::CStr,
-    fmt::{Debug, Display, Formatter, Write},
-    str::{from_utf8, Split},
-};
-use gbl_async::{block_on, yield_now};
-use liberror::{Error, Result};
-use libutils::{snprintf, FormattedBytes};
-
-/// Local session module
-pub mod local_session;
-
-/// Maximum packet size that can be accepted from the host.
-///
-/// The transport layer may have its own size limits that reduce the packet size further.
-pub const MAX_COMMAND_SIZE: usize = 4096;
-/// Maximum packet size that will be sent to the host.
-///
-/// The `fastboot` host tool originally had a 64-byte packet size max, but this was increased
-/// to 256 in 2020, so any reasonably recent host binary should be able to support 256.
-///
-/// The transport layer may have its own size limits that reduce the packet size further.
-pub const MAX_RESPONSE_SIZE: usize = 256;
-
-/// Trait to provide the transport layer for a fastboot implementation.
-///
-/// Fastboot supports these transports:
-/// * USB
-/// * TCP
-/// * UDP
-pub trait Transport {
-    /// Fetches the next fastboot packet into `out`.
-    ///
-    /// Returns the actual size of the packet on success.
-    ///
-    /// TODO(b/322540167): In the future, we may want to support using `[MaybeUninit<u8>]` as the
-    /// download buffer to avoid expensive initialization at the beginning. This would require an
-    /// interface where the implementation provides the buffer for us to copy instead of us.
-    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize>;
-
-    /// Sends a fastboot packet.
-    ///
-    /// The method assumes `packet` is sent or at least copied to queue after it returns, where
-    /// the buffer can go out of scope without affecting anything.
-    async fn send_packet(&mut self, packet: &[u8]) -> Result<()>;
-}
-
-/// For now, we hardcode the expected version, until we need to distinguish between multiple
-/// versions.
-const TCP_HANDSHAKE_MESSAGE: &[u8] = b"FB01";
-
-/// A trait representing a TCP stream reader/writer. Fastboot over TCP has additional handshake
-/// process and uses a length-prefixed wire message format. It is recommended that caller
-/// implements this trait instead of `Transport`, and uses the API `Fastboot::run_tcp_session()`
-/// to perform fastboot over TCP. It internally handles handshake and wire message parsing.
-pub trait TcpStream {
-    /// Reads to `out` for exactly `out.len()` number bytes from the TCP connection.
-    async fn read_exact(&mut self, out: &mut [u8]) -> Result<()>;
-
-    /// Sends exactly `data.len()` number bytes from `data` to the TCP connection.
-    async fn write_exact(&mut self, data: &[u8]) -> Result<()>;
-}
-
-/// Implements [Transport] on a [TcpStream].
-pub struct TcpTransport<'a, T: TcpStream>(&'a mut T);
-
-impl<'a, T: TcpStream> TcpTransport<'a, T> {
-    /// Creates an instance from a newly connected TcpStream and performs handshake.
-    pub fn new_and_handshake(tcp_stream: &'a mut T) -> Result<Self> {
-        let mut handshake = [0u8; 4];
-        block_on(tcp_stream.write_exact(TCP_HANDSHAKE_MESSAGE))?;
-        block_on(tcp_stream.read_exact(&mut handshake[..]))?;
-        match handshake == *TCP_HANDSHAKE_MESSAGE {
-            true => Ok(Self(tcp_stream)),
-            _ => Err(Error::InvalidHandshake),
-        }
-    }
-}
-
-impl<'a, T: TcpStream> Transport for TcpTransport<'a, T> {
-    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
-        let mut length_prefix = [0u8; 8];
-        self.0.read_exact(&mut length_prefix[..]).await?;
-        let packet_size: usize = u64::from_be_bytes(length_prefix).try_into()?;
-        match out.len() < packet_size {
-            true => Err(Error::InvalidInput),
-            _ => {
-                self.0.read_exact(&mut out[..packet_size]).await?;
-                Ok(packet_size)
-            }
-        }
-    }
-
-    async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
-        self.0.write_exact(&mut u64::try_from(packet.len())?.to_be_bytes()[..]).await?;
-        self.0.write_exact(packet).await
-    }
-}
-
-const COMMAND_ERROR_LENGTH: usize = MAX_RESPONSE_SIZE - 4;
-
-/// `CommandError` is the return error type for methods in trait `FastbootImplementation` when
-/// they fail. It will be converted into string and sent as fastboot error message "FAIL<string>".
-///
-/// Any type that implements `Display` trait can be converted into it. However, because fastboot
-/// response message is limited to `MAX_RESPONSE_SIZE`. If the final displayed string length
-/// exceeds it, the rest of the content is ignored.
-pub struct CommandError(FormattedBytes<[u8; COMMAND_ERROR_LENGTH]>);
-
-impl CommandError {
-    /// Converts to string.
-    pub fn to_str(&self) -> &str {
-        self.0.to_str()
-    }
-
-    /// Clones the error.
-    pub fn clone(&self) -> Self {
-        self.to_str().into()
-    }
-}
-
-impl Debug for CommandError {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        write!(f, "{}", self.to_str())
-    }
-}
-
-impl<T: Display> From<T> for CommandError {
-    fn from(val: T) -> Self {
-        let mut res = CommandError(FormattedBytes::new([0u8; COMMAND_ERROR_LENGTH]));
-        write!(res.0, "{}", val).unwrap();
-        res
-    }
-}
-
-/// Type alias for Result that wraps a CommandError
-pub type CommandResult<T> = core::result::Result<T, CommandError>;
-
-/// Fastboot reboot mode
-#[derive(Debug, Copy, Clone, PartialEq)]
-pub enum RebootMode {
-    /// "fastboot reboot". Normal reboot.
-    Normal,
-    /// "fastboot reboot-bootloader". Reboot to bootloader.
-    Bootloader,
-    /// "fastboot reboot-fastboot". Reboot to userspace fastboot.
-    Fastboot,
-    /// "fastboot reboot-recovery". Reboot to recovery.
-    Recovery,
-}
-
-/// Implementation for Fastboot command backends.
-pub trait FastbootImplementation {
-    /// Backend for `fastboot getvar ...`
-    ///
-    /// Gets the value of a variable specified by name and configuration represented by list of
-    /// additional arguments in `args`.
-    ///
-    /// Variable `max-download-size`, `version` are reserved by the library.
-    ///
-    /// # Args
-    ///
-    /// * `var`: Name of the variable.
-    /// * `args`: Additional arguments.
-    /// * `out`: Output buffer for storing the variable value.
-    /// * `responder`: An instance of `InfoSender`.
-    ///
-    /// TODO(b/322540167): Figure out other reserved variables.
-    async fn get_var(
-        &mut self,
-        var: &CStr,
-        args: impl Iterator<Item = &'_ CStr> + Clone,
-        out: &mut [u8],
-        responder: impl InfoSender,
-    ) -> CommandResult<usize>;
-
-    /// A helper API for getting the value of a fastboot variable and decoding it into string.
-    async fn get_var_as_str<'s>(
-        &mut self,
-        var: &CStr,
-        args: impl Iterator<Item = &'_ CStr> + Clone,
-        responder: impl InfoSender,
-        out: &'s mut [u8],
-    ) -> CommandResult<&'s str> {
-        let size = self.get_var(var, args, out, responder).await?;
-        Ok(from_utf8(out.get(..size).ok_or("Invalid variable size")?)
-            .map_err(|_| "Value is not string")?)
-    }
-
-    /// Backend for `fastboot getvar all`.
-    ///
-    /// Iterates all combinations of fastboot variable, configurations and values that need to be
-    /// included in the response to `fastboot getvar all`.
-    ///
-    /// # Args
-    ///
-    /// * `responder`: An implementation VarInfoSender. Implementation should call
-    ///   `VarInfoSender::send` for all combinations of Fastboot variable/argument/value that needs
-    ///   to be included in the response to `fastboot getvarl all`:
-    ///
-    ///   async fn get_var_all(&mut self, f: F, resp: impl VarInfoSender)
-    ///     -> CommandResult<()> {
-    ///       resp.send("partition-size", &["boot_a"], /* size of boot_a */).await?;
-    ///       resp.send("partition-size", &["boot_b"], /* size of boot_b */).await?;
-    ///       resp.send("partition-size", &["init_boot_a"], /* size of init_boot_a */).await?;
-    ///       resp.send("partition-size", &["init_boot_b"], /* size of init_boot_b */).await?;
-    ///       Ok(())
-    ///   }
-    ///
-    ///   will generates the following outputs for `fastboot getvar all`:
-    ///
-    ///   ...
-    ///   (bootloader) partition-size:boot_a: <size of boot_a>
-    ///   (bootloader) partition-size:boot_b: <size of boot_b>
-    ///   (bootloader) partition-size:init_boot_a: <size of init_boot_a>
-    ///   (bootloader) partition-size:init_boot_b: <size of init_boot_b>
-    ///   ...
-    ///
-    /// TODO(b/322540167): This and `get_var()` contain duplicated logic. Investigate if there can
-    /// be better solutions for doing the combination traversal.
-    async fn get_var_all(&mut self, responder: impl VarInfoSender) -> CommandResult<()>;
-
-    /// Backend for getting download buffer
-    async fn get_download_buffer(&mut self) -> &mut [u8];
-
-    /// Called when a download is completed.
-    async fn download_complete(
-        &mut self,
-        download_size: usize,
-        responder: impl InfoSender,
-    ) -> CommandResult<()>;
-
-    /// Backend for `fastboot flash ...`
-    ///
-    /// # Args
-    ///
-    /// * `part`: Name of the partition.
-    /// * `responder`: An instance of `InfoSender`.
-    async fn flash(&mut self, part: &str, responder: impl InfoSender) -> CommandResult<()>;
-
-    /// Backend for `fastboot erase ...`
-    ///
-    /// # Args
-    ///
-    /// * `part`: Name of the partition.
-    /// * `responder`: An instance of `InfoSender`.
-    async fn erase(&mut self, part: &str, responder: impl InfoSender) -> CommandResult<()>;
-
-    /// Backend for `fastboot get_staged ...`
-    ///
-    /// # Args
-    ///
-    /// * `responder`: An instance of `UploadBuilder + InfoSender` for initiating and uploading
-    ///   data. For example:
-    ///
-    ///   ```
-    ///   async fn upload(
-    ///       &mut self,
-    ///       responder: impl UploadBuilder + InfoSender,
-    ///   ) -> CommandResult<()> {
-    ///       let data = ..;
-    ///       // Sends a total of 1024 bytes data.
-    ///       responder.send_info("About to upload...").await?;
-    ///       let mut uploader = responder.initiate_upload(1024).await?;
-    ///       // Can upload in multiple batches.
-    ///       uploader.upload(&data[..512]).await?;
-    ///       uploader.upload(&data[512..]).await?;
-    ///       Ok(())
-    ///   }
-    ///   ```
-    ///
-    ///   If implementation fails to upload enough, or attempts to upload more than expected data
-    ///   with `Uploader::upload()`, an error will be returned.
-    async fn upload(&mut self, responder: impl UploadBuilder + InfoSender) -> CommandResult<()>;
-
-    /// Backend for `fastboot fetch ...`
-    ///
-    /// # Args
-    ///
-    /// * `part`: The partition name.
-    /// * `offset`: The offset into the partition for upload.
-    /// * `size`: The number of bytes to upload.
-    /// * `responder`: An instance of `UploadBuilder + InfoSender` for initiating and uploading data.
-    async fn fetch(
-        &mut self,
-        part: &str,
-        offset: u64,
-        size: u64,
-        responder: impl UploadBuilder + InfoSender,
-    ) -> CommandResult<()>;
-
-    /// Backend for `fastboot reboot/reboot-bootloader/reboot-fastboot/reboot-recovery`
-    ///
-    /// # Args
-    ///
-    /// * `mode`: An `RebootMode` specifying the reboot mode.
-    /// * `responder`: An instance of `InfoSender + OkaySender`. Implementation should call
-    ///   `responder.send_okay("")` right before reboot to notify the remote host that the
-    ///   operation is successful.
-    ///
-    /// # Returns
-    ///
-    /// * The method is not expected to return if reboot is successful.
-    /// * Returns `Err(e)` on error.
-    async fn reboot(
-        &mut self,
-        mode: RebootMode,
-        responder: impl InfoSender + OkaySender,
-    ) -> CommandError;
-
-    /// Method for handling `fastboot continue` clean up.
-    ///
-    /// `run()` and `run_tcp_session()` exit after receiving `fastboot continue.` The method is for
-    /// implementation to perform necessary clean up.
-    ///
-    /// # Args
-    ///
-    /// * `responder`: An instance of `InfoSender`.
-    async fn r#continue(&mut self, responder: impl InfoSender) -> CommandResult<()>;
-
-    /// Backend for `fastboot set_active`.
-    async fn set_active(&mut self, slot: &str, responder: impl InfoSender) -> CommandResult<()>;
-
-    /// Backend for `fastboot boot`
-    ///
-    /// # Args
-    ///
-    /// * `responder`: An instance of `InfoSender + OkaySender`. Implementation should call
-    ///   `responder.send_okay("")` right before boot to notify the remote host that the
-    ///   operation is successful.
-    ///
-    /// # Returns
-    ///
-    /// * The method is always return OK to let fastboot continue.
-    /// * Returns `Err(e)` on error.
-    async fn boot(&mut self, responder: impl InfoSender + OkaySender) -> CommandResult<()>;
-
-    /// Backend for `fastboot oem ...`.
-    ///
-    /// # Args
-    ///
-    /// * `cmd`: The OEM command string that comes after "oem ".
-    /// * `responder`: An instance of `InfoSender`.
-    /// * `res`: The responder buffer. Upon success, implementation can use the buffer to
-    ///   construct a valid UTF8 string which will be sent as "OKAY<string>"
-    ///
-    /// # Returns
-    ///
-    /// On success, returns the portion of `res` used by the construction of string message.
-    async fn oem<'a>(
-        &mut self,
-        cmd: &str,
-        responder: impl InfoSender,
-        res: &'a mut [u8],
-    ) -> CommandResult<&'a [u8]>;
-
-    // TODO(b/322540167): Add methods for other commands.
-}
-
-/// An internal convenient macro helper for `fastboot_okay`, `fastboot_fail` and `fastboot_info`.
-macro_rules! fastboot_msg {
-    ( $arr:expr, $msg_type:expr, $( $x:expr ),* $(,)? ) => {
-        {
-            let mut formatted_bytes = FormattedBytes::new(&mut $arr[..]);
-            write!(formatted_bytes, $msg_type).unwrap();
-            write!(formatted_bytes, $($x,)*).unwrap();
-            let size = formatted_bytes.size();
-            &mut $arr[..size]
-        }
-    };
-}
-
-/// An internal convenient macro that constructs a formatted fastboot OKAY message.
-macro_rules! fastboot_okay {
-    ( $arr:expr, $( $x:expr ),* $(,)?) => { fastboot_msg!($arr, "OKAY", $($x,)*) };
-}
-
-/// An internal convenient macro that constructs a formatted fastboot FAIL message.
-macro_rules! fastboot_fail {
-    ( $arr:expr, $( $x:expr ),* $(,)?) => { fastboot_msg!($arr, "FAIL", $($x,)*) };
-}
-
-/// `VarInfoSender` provide an interface for sending variable/args/value combination during the
-/// processing of `fastboot getvar all`
-pub trait VarInfoSender {
-    /// Send a combination of variable name, arguments and value.
-    ///
-    /// The method sends a fastboot message "INFO<var>:<args>:<val>" to the host.
-    ///
-    /// # Args
-    ///
-    /// * `name`: Name of the fastboot variable.
-    /// * `args`: An iterator to additional arguments.
-    /// * `val`: Value of the variable.
-    async fn send_var_info(
-        &mut self,
-        name: &str,
-        args: impl IntoIterator<Item = &'_ str>,
-        val: &str,
-    ) -> Result<()>;
-}
-
-/// Provides an API for sending fastboot INFO messages.
-pub trait InfoSender {
-    /// Sends formatted INFO message.
-    ///
-    /// # Args:
-    ///
-    /// * `cb`: A closure provided by the caller for constructing the formatted messagae.
-    async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(&mut self, cb: F) -> Result<()>;
-
-    /// Sends a Fastboot "INFO<`msg`>" packet.
-    async fn send_info(&mut self, msg: &str) -> Result<()> {
-        self.send_formatted_info(|w| write!(w, "{}", msg).unwrap()).await
-    }
-}
-
-/// Provides an API for sending fastboot OKAY messages.
-pub trait OkaySender {
-    /// Sends formatted Okay message.
-    ///
-    /// # Args:
-    ///
-    /// * `cb`: A closure provided by the caller for constructing the formatted messagae.
-    async fn send_formatted_okay<F: FnOnce(&mut dyn Write)>(self, cb: F) -> Result<()>;
-
-    /// Sends a fastboot OKAY<msg> packet. `Self` is consumed.
-    async fn send_okay(self, msg: &str) -> Result<()>
-    where
-        Self: Sized,
-    {
-        self.send_formatted_okay(|w| write!(w, "{}", msg).unwrap()).await
-    }
-}
-
-/// `UploadBuilder` provides API for initiating a fastboot upload.
-pub trait UploadBuilder {
-    /// Starts the upload.
-    ///
-    /// In a real fastboot context, the method should send `DATA0xXXXXXXXX` to the remote host to
-    /// start the download. An `Uploader` implementation should be returned for uploading payload.
-    async fn initiate_upload(self, data_size: u64) -> Result<impl Uploader>;
-}
-
-/// `UploadBuilder` provides API for uploading payload.
-pub trait Uploader {
-    /// Uploads data to the Fastboot host.
-    async fn upload(&mut self, data: &[u8]) -> Result<()>;
-}
-
-/// `Responder` implements APIs for fastboot backend to send fastboot messages and uploading data.
-struct Responder<'a, T: Transport> {
-    buffer: [u8; MAX_RESPONSE_SIZE],
-    transport: &'a mut T,
-    transport_error: Result<()>,
-    remaining_upload: u64,
-}
-
-impl<'a, T: Transport> Responder<'a, T> {
-    fn new(transport: &'a mut T) -> Self {
-        Self {
-            buffer: [0u8; MAX_RESPONSE_SIZE],
-            transport,
-            transport_error: Ok(()),
-            remaining_upload: 0,
-        }
-    }
-
-    /// A helper for sending a fastboot message in the buffer.
-    async fn send_buffer(&mut self, size: usize) -> Result<()> {
-        self.transport_error?;
-        assert!(size < self.buffer.len());
-        self.transport_error = self.transport.send_packet(&self.buffer[..size]).await;
-        Ok(self.transport_error?)
-    }
-
-    /// Helper for sending a formatted fastboot message.
-    ///
-    /// # Args:
-    ///
-    /// * `cb`: A closure provided by the caller for constructing the formatted messagae.
-    async fn send_formatted_msg<F: FnOnce(&mut dyn Write)>(
-        &mut self,
-        msg_type: &str,
-        cb: F,
-    ) -> Result<()> {
-        let mut formatted_bytes = FormattedBytes::new(&mut self.buffer);
-        write!(formatted_bytes, "{}", msg_type).unwrap();
-        cb(&mut formatted_bytes);
-        let size = formatted_bytes.size();
-        self.send_buffer(size).await
-    }
-
-    /// Sends a fastboot DATA message.
-    async fn send_data_message(&mut self, data_size: u64) -> Result<()> {
-        self.send_formatted_msg("DATA", |v| write!(v, "{:08x}", data_size).unwrap()).await
-    }
-}
-
-impl<'a, T: Transport> VarInfoSender for &mut Responder<'a, T> {
-    async fn send_var_info(
-        &mut self,
-        name: &str,
-        args: impl IntoIterator<Item = &'_ str>,
-        val: &str,
-    ) -> Result<()> {
-        // Sends a "INFO<var>:<':'-separated args>:<val>" packet to the host.
-        Ok(self
-            .send_formatted_msg("INFO", |v| {
-                write!(v, "{}", name).unwrap();
-                args.into_iter().for_each(|arg| write!(v, ":{}", arg).unwrap());
-                write!(v, ": {}", val).unwrap();
-            })
-            .await?)
-    }
-}
-
-/// An internal convenient macro that sends a formatted fastboot OKAY message via a `Responder`
-macro_rules! reply_okay {
-    ( $resp:expr, $( $x:expr ),* $(,)?) => {
-        {
-            let len = fastboot_okay!($resp.buffer, $($x,)*).len();
-            $resp.send_buffer(len).await
-        }
-    };
-}
-
-/// An internal convenient macro that sends a formatted fastboot FAIL message via a `Responder`
-macro_rules! reply_fail {
-    ( $resp:expr, $( $x:expr ),* $(,)?) => {
-        {
-            let len = fastboot_fail!($resp.buffer, $($x,)*).len();
-            $resp.send_buffer(len).await
-        }
-    };
-}
-
-impl<T: Transport> InfoSender for &mut Responder<'_, T> {
-    async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(&mut self, cb: F) -> Result<()> {
-        Ok(self.send_formatted_msg("INFO", cb).await?)
-    }
-}
-
-impl<T: Transport> OkaySender for &mut Responder<'_, T> {
-    async fn send_formatted_okay<F: FnOnce(&mut dyn Write)>(self, cb: F) -> Result<()> {
-        Ok(self.send_formatted_msg("OKAY", cb).await?)
-    }
-}
-
-impl<'a, T: Transport> UploadBuilder for &mut Responder<'a, T> {
-    async fn initiate_upload(self, data_size: u64) -> Result<impl Uploader> {
-        self.send_data_message(data_size).await?;
-        self.remaining_upload = data_size;
-        Ok(self)
-    }
-}
-
-impl<'a, T: Transport> Uploader for &mut Responder<'a, T> {
-    /// Uploads data. Returns error if accumulative amount exceeds `data_size` passed to
-    /// `UploadBuilder::start()`.
-    async fn upload(&mut self, data: &[u8]) -> Result<()> {
-        self.transport_error?;
-        self.remaining_upload = self
-            .remaining_upload
-            .checked_sub(data.len().try_into().map_err(|_| "")?)
-            .ok_or(Error::Other(Some("Invalid size of upload data")))?;
-        self.transport_error = self.transport.send_packet(data).await;
-        Ok(())
-    }
-}
-
-pub mod test_utils {
-    //! Test utilities to help users of this library write unit tests.
-
-    use crate::{InfoSender, UploadBuilder, Uploader};
-    use core::fmt::Write;
-    use liberror::Error;
-
-    /// A test implementation of `UploadBuilder` for unittesting
-    /// `FastbootImplementation::upload()`.
-    ///
-    /// The test uploader simply uploads to a user provided buffer.
-    pub struct TestUploadBuilder<'a>(pub &'a mut [u8]);
-
-    impl<'a> UploadBuilder for TestUploadBuilder<'a> {
-        async fn initiate_upload(self, _: u64) -> Result<impl Uploader, Error> {
-            Ok(TestUploader(0, self.0))
-        }
-    }
-
-    impl<'a> InfoSender for TestUploadBuilder<'a> {
-        async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(
-            &mut self,
-            _: F,
-        ) -> Result<(), Error> {
-            // Not needed currently.
-            Ok(())
-        }
-    }
-
-    // (Bytes sent, upload buffer)
-    struct TestUploader<'a>(usize, &'a mut [u8]);
-
-    impl Uploader for TestUploader<'_> {
-        async fn upload(&mut self, data: &[u8]) -> Result<(), Error> {
-            self.1[self.0..][..data.len()].clone_from_slice(data);
-            self.0 = self.0.checked_add(data.len()).unwrap();
-            Ok(())
-        }
-    }
-}
-
-const MAX_DOWNLOAD_SIZE_NAME: &'static str = "max-download-size";
-
-/// Converts a null-terminated command line string where arguments are separated by ':' into an
-/// iterator of individual argument as CStr.
-fn cmd_to_c_string_args(cmd: &mut [u8]) -> impl Iterator<Item = &CStr> + Clone {
-    let end = cmd.iter().position(|v| *v == 0).unwrap();
-    // Replace ':' with NULL.
-    cmd.iter_mut().filter(|v| **v == b':').for_each(|v| *v = 0);
-    cmd[..end + 1].split_inclusive(|v| *v == 0).map(|v| CStr::from_bytes_until_nul(v).unwrap())
-}
-
-/// Helper for handling "fastboot getvar ..."
-async fn get_var(
-    cmd: &mut [u8],
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let mut args = cmd_to_c_string_args(cmd).skip(1);
-    let Some(var) = args.next() else {
-        return reply_fail!(resp, "Missing variable");
-    };
-
-    match var.to_str()? {
-        "all" => return get_var_all(transport, fb_impl).await,
-        MAX_DOWNLOAD_SIZE_NAME => {
-            return reply_okay!(resp, "{:#x}", fb_impl.get_download_buffer().await.len());
-        }
-        _ => {
-            let mut val = [0u8; MAX_RESPONSE_SIZE];
-            match fb_impl.get_var_as_str(var, args, &mut resp, &mut val[..]).await {
-                Ok(s) => reply_okay!(resp, "{}", s),
-                Err(e) => reply_fail!(resp, "{}", e.to_str()),
-            }
-        }
-    }
-}
-
-/// A wrapper of `get_var_all()` that first iterates reserved variables.
-async fn get_var_all_with_native(
-    fb_impl: &mut impl FastbootImplementation,
-    mut sender: impl VarInfoSender,
-) -> CommandResult<()> {
-    // Process the built-in MAX_DOWNLOAD_SIZE_NAME variable.
-    let mut size_str = [0u8; 32];
-    let size_str = snprintf!(size_str, "{:#x}", fb_impl.get_download_buffer().await.len());
-    sender.send_var_info(MAX_DOWNLOAD_SIZE_NAME, [], size_str).await?;
-    fb_impl.get_var_all(sender).await
-}
-
-/// Method for handling "fastboot getvar all"
-async fn get_var_all(
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    // Don't allow custom INFO messages because variable values are sent as INFO messages.
-    let get_res = get_var_all_with_native(fb_impl, &mut resp).await;
-    match get_res {
-        Ok(()) => reply_okay!(resp, ""),
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-    }
-}
-
-/// Helper for handling "fastboot download:...".
-async fn download(
-    mut args: Split<'_, char>,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let total_download_size = match (|| -> CommandResult<usize> {
-        usize::try_from(next_arg_u64(&mut args)?.ok_or("Not enough argument")?)
-            .map_err(|_| "Download size overflow".into())
-    })() {
-        Err(e) => return reply_fail!(resp, "{}", e.to_str()),
-        Ok(v) => v,
-    };
-    let download_buffer = &mut fb_impl.get_download_buffer().await;
-    if total_download_size > download_buffer.len() {
-        return reply_fail!(resp, "Download size is too big");
-    } else if total_download_size == 0 {
-        return reply_fail!(resp, "Zero download size");
-    }
-
-    // Starts the download
-    let download_buffer = &mut download_buffer[..total_download_size];
-    // `total_download_size` is parsed from `next_arg_u64` and thus should fit into u64.
-    resp.send_data_message(u64::try_from(total_download_size).unwrap()).await?;
-    let mut downloaded = 0;
-    while downloaded < total_download_size {
-        let (_, remains) = &mut download_buffer.split_at_mut(downloaded);
-        match resp.transport.receive_packet(remains).await? {
-            0 => yield_now().await,
-            v => match downloaded.checked_add(v) {
-                Some(v) if v > total_download_size => {
-                    return reply_fail!(resp, "More data received then expected");
-                }
-                Some(v) => downloaded = v,
-                _ => return Err(Error::Other(Some("Invalid read size from transport"))),
-            },
-        };
-    }
-    match fb_impl.download_complete(downloaded, &mut resp).await {
-        Ok(()) => reply_okay!(resp, ""),
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-    }
-}
-
-/// Helper for handling "fastboot flash ...".
-async fn flash(
-    cmd: &str,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let flash_res =
-        match cmd.strip_prefix("flash:").ok_or::<CommandError>("Missing partition".into()) {
-            Ok(part) => fb_impl.flash(part, &mut resp).await,
-            Err(e) => Err(e),
-        };
-    match flash_res {
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-        _ => reply_okay!(resp, ""),
-    }
-}
-
-/// Helper for handling "fastboot erase ...".
-async fn erase(
-    cmd: &str,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let flash_res =
-        match cmd.strip_prefix("erase:").ok_or::<CommandError>("Missing partition".into()) {
-            Ok(part) => fb_impl.erase(part, &mut resp).await,
-            Err(e) => Err(e),
-        };
-    match flash_res {
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-        _ => reply_okay!(resp, ""),
-    }
-}
-
-/// Helper for handling "fastboot get_staged ...".
-async fn upload(
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let upload_res = fb_impl.upload(&mut resp).await;
-    match resp.remaining_upload > 0 {
-        true => return Err(Error::InvalidInput),
-        _ => match upload_res {
-            Err(e) => reply_fail!(resp, "{}", e.to_str()),
-            _ => reply_okay!(resp, ""),
-        },
-    }
-}
-
-/// Helper for handling "fastboot fetch ...".
-async fn fetch(
-    cmd: &str,
-    args: Split<'_, char>,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let fetch_res = async {
-        let cmd = cmd.strip_prefix("fetch:").ok_or::<CommandError>("Missing arguments".into())?;
-        if args.clone().count() < 3 {
-            return Err("Not enough argments".into());
-        }
-        // Parses backward. Parses size, offset first and treats the remaining string as
-        // partition name. This allows ":" in partition name.
-        let mut rev = args.clone().rev();
-        let sz = next_arg(&mut rev).ok_or("Missing size")?;
-        let off = next_arg(&mut rev).ok_or("Invalid offset")?;
-        let part = &cmd[..cmd.len() - (off.len() + sz.len() + 2)];
-        fb_impl.fetch(part, hex_to_u64(off)?, hex_to_u64(sz)?, &mut resp).await
-    }
-    .await;
-    match resp.remaining_upload > 0 {
-        true => return Err(Error::InvalidInput),
-        _ => match fetch_res {
-            Err(e) => reply_fail!(resp, "{}", e.to_str()),
-            _ => reply_okay!(resp, ""),
-        },
-    }
-}
-
-// Handles `fastboot reboot*`
-async fn reboot(
-    mode: RebootMode,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let e = fb_impl.reboot(mode, &mut resp).await;
-    reply_fail!(resp, "{}", e.to_str())
-}
-
-// Handles `fastboot boot`
-async fn boot(
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let boot_res = async { fb_impl.boot(&mut resp).await }.await;
-    match boot_res {
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-        _ => reply_okay!(resp, "boot_command"),
-    }
-}
-
-// Handles `fastboot continue`
-async fn r#continue(
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    match fb_impl.r#continue(&mut resp).await {
-        Ok(_) => reply_okay!(resp, ""),
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-    }
-}
-
-// Handles `fastboot set_active`
-async fn set_active(
-    mut args: Split<'_, char>,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let res = async {
-        let slot = next_arg(&mut args).ok_or("Missing slot")?;
-        fb_impl.set_active(slot, &mut resp).await
-    };
-    match res.await {
-        Ok(_) => reply_okay!(resp, ""),
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-    }
-}
-
-/// Helper for handling "fastboot oem ...".
-async fn oem(
-    cmd: &str,
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut resp = Responder::new(transport);
-    let mut oem_out = [0u8; MAX_RESPONSE_SIZE - 4];
-    let oem_res = fb_impl.oem(cmd, &mut resp, &mut oem_out[..]).await;
-    match oem_res {
-        Ok(msg) => match from_utf8(msg) {
-            Ok(s) => reply_okay!(resp, "{}", s),
-            Err(e) => reply_fail!(resp, "Invalid return string {}", e),
-        },
-        Err(e) => reply_fail!(resp, "{}", e.to_str()),
-    }
-}
-
-/// Process the next Fastboot command from  the transport.
-///
-/// # Returns
-///
-/// * Returns Ok(is_continue) on success where `is_continue` is true if command is
-///   `fastboot continue`.
-/// * Returns Err() on errors.
-pub async fn process_next_command(
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<bool> {
-    let mut packet = [0u8; MAX_COMMAND_SIZE + 1];
-    let cmd_size = match transport.receive_packet(&mut packet[..MAX_COMMAND_SIZE]).await? {
-        0 => return Ok(false),
-        v => v,
-    };
-    let Ok(cmd_str) = from_utf8(&packet[..cmd_size]) else {
-        transport.send_packet(fastboot_fail!(packet, "Invalid Command")).await?;
-        return Ok(false);
-    };
-    let mut args = cmd_str.split(':');
-    let Some(cmd) = args.next() else {
-        return transport.send_packet(fastboot_fail!(packet, "No command")).await.map(|_| false);
-    };
-    match cmd {
-        "boot" => {
-            boot(transport, fb_impl).await?;
-            return Ok(true);
-        }
-        "continue" => {
-            r#continue(transport, fb_impl).await?;
-            return Ok(true);
-        }
-        "download" => download(args, transport, fb_impl).await,
-        "erase" => erase(cmd_str, transport, fb_impl).await,
-        "fetch" => fetch(cmd_str, args, transport, fb_impl).await,
-        "flash" => flash(cmd_str, transport, fb_impl).await,
-        "getvar" => get_var(&mut packet[..], transport, fb_impl).await,
-        "reboot" => reboot(RebootMode::Normal, transport, fb_impl).await,
-        "reboot-bootloader" => reboot(RebootMode::Bootloader, transport, fb_impl).await,
-        "reboot-fastboot" => reboot(RebootMode::Fastboot, transport, fb_impl).await,
-        "reboot-recovery" => reboot(RebootMode::Recovery, transport, fb_impl).await,
-        "set_active" => set_active(args, transport, fb_impl).await,
-        "upload" => upload(transport, fb_impl).await,
-        _ if cmd_str.starts_with("oem ") => oem(&cmd_str[4..], transport, fb_impl).await,
-        _ => transport.send_packet(fastboot_fail!(packet, "Command not found")).await,
-    }?;
-    Ok(false)
-}
-
-/// Keeps polling and processing fastboot commands from the transport.
-///
-/// # Returns
-///
-/// * Returns Ok(()) if "fastboot continue" is received.
-/// * Returns Err() on errors.
-pub async fn run(
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    while !process_next_command(transport, fb_impl).await? {}
-    Ok(())
-}
-
-/// Runs a fastboot over TCP session.
-///
-/// The method performs fastboot over TCP handshake and then call `run(...)`.
-///
-/// Returns Ok(()) if "fastboot continue" is received.
-pub async fn run_tcp_session(
-    tcp_stream: &mut impl TcpStream,
-    fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    run(&mut TcpTransport::new_and_handshake(tcp_stream)?, fb_impl).await
-}
-
-/// A helper to convert a hex string into u64.
-pub(crate) fn hex_to_u64(s: &str) -> CommandResult<u64> {
-    Ok(u64::from_str_radix(s.strip_prefix("0x").unwrap_or(s), 16)?)
-}
-
-/// A helper to check and fetch the next non-empty argument.
-///
-/// # Args
-///
-/// args: A string iterator.
-pub fn next_arg<'a, T: Iterator<Item = &'a str>>(args: &mut T) -> Option<&'a str> {
-    args.next().filter(|v| *v != "")
-}
-
-/// A helper to check and fetch the next argument as a u64 hex string.
-///
-/// # Args
-///
-/// args: A string iterator.
-///
-///
-/// # Returns
-///
-/// * Returns Ok(Some(v)) is next argument is available and a valid u64 hex.
-/// * Returns Ok(None) is next argument is not available
-/// * Returns Err() if next argument is present but not a valid u64 hex.
-pub fn next_arg_u64<'a, T: Iterator<Item = &'a str>>(args: &mut T) -> CommandResult<Option<u64>> {
-    match next_arg(args) {
-        Some(v) => Ok(Some(hex_to_u64(v)?)),
-        _ => Ok(None),
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use core::cmp::min;
-    use std::collections::{BTreeMap, VecDeque};
-
-    #[derive(Default)]
-    struct FastbootTest {
-        // A mapping from (variable name, argument) to variable value.
-        vars: BTreeMap<(&'static str, &'static [&'static str]), &'static str>,
-        // The partition arg from Fastboot flash command
-        flash_partition: String,
-        // The partition arg from Fastboot erase command
-        erase_partition: String,
-        // Upload size, batches of data to upload,
-        upload_config: (u64, Vec<Vec<u8>>),
-        // A map from partition name to (upload size override, partition data)
-        fetch_data: BTreeMap<&'static str, (u64, Vec<u8>)>,
-        // result string, INFO strings.
-        oem_output: (String, Vec<String>),
-        oem_command: String,
-        download_buffer: Vec<u8>,
-        downloaded_size: usize,
-        reboot_mode: Option<RebootMode>,
-        active_slot: Option<String>,
-    }
-
-    impl FastbootImplementation for FastbootTest {
-        async fn get_var(
-            &mut self,
-            var: &CStr,
-            args: impl Iterator<Item = &'_ CStr> + Clone,
-            out: &mut [u8],
-            _: impl InfoSender,
-        ) -> CommandResult<usize> {
-            let args = args.map(|v| v.to_str().unwrap()).collect::<Vec<_>>();
-            match self.vars.get(&(var.to_str()?, &args[..])) {
-                Some(v) => {
-                    out[..v.len()].clone_from_slice(v.as_bytes());
-                    Ok(v.len())
-                }
-                _ => Err("Not Found".into()),
-            }
-        }
-
-        async fn get_var_all(&mut self, mut responder: impl VarInfoSender) -> CommandResult<()> {
-            for ((var, config), value) in &self.vars {
-                responder.send_var_info(var, config.iter().copied(), value).await?;
-            }
-            Ok(())
-        }
-
-        async fn get_download_buffer(&mut self) -> &mut [u8] {
-            self.download_buffer.as_mut_slice()
-        }
-
-        async fn download_complete(
-            &mut self,
-            download_size: usize,
-            _: impl InfoSender,
-        ) -> CommandResult<()> {
-            self.downloaded_size = download_size;
-            Ok(())
-        }
-
-        async fn flash(&mut self, part: &str, _: impl InfoSender) -> CommandResult<()> {
-            self.flash_partition = part.into();
-            Ok(())
-        }
-
-        async fn erase(&mut self, part: &str, _: impl InfoSender) -> CommandResult<()> {
-            self.erase_partition = part.into();
-            Ok(())
-        }
-
-        async fn upload(&mut self, responder: impl UploadBuilder) -> CommandResult<()> {
-            let (size, batches) = &self.upload_config;
-            let mut uploader = responder.initiate_upload(*size).await?;
-            for ele in batches {
-                uploader.upload(&ele[..]).await?;
-            }
-            Ok(())
-        }
-
-        async fn fetch(
-            &mut self,
-            part: &str,
-            offset: u64,
-            size: u64,
-            responder: impl UploadBuilder + InfoSender,
-        ) -> CommandResult<()> {
-            let (size_override, data) = self.fetch_data.get(part).ok_or("Not Found")?;
-            let mut uploader = responder.initiate_upload(*size_override).await?;
-            Ok(uploader
-                .upload(&data[offset.try_into().unwrap()..][..size.try_into().unwrap()])
-                .await?)
-        }
-
-        async fn boot(&mut self, mut responder: impl InfoSender + OkaySender) -> CommandResult<()> {
-            Ok(responder.send_info("Boot to boot.img...").await?)
-        }
-
-        async fn reboot(
-            &mut self,
-            mode: RebootMode,
-            responder: impl InfoSender + OkaySender,
-        ) -> CommandError {
-            responder.send_okay("").await.unwrap();
-            self.reboot_mode = Some(mode);
-            "reboot-return".into()
-        }
-
-        async fn r#continue(&mut self, mut responder: impl InfoSender) -> CommandResult<()> {
-            Ok(responder.send_info("Continuing to boot...").await?)
-        }
-
-        async fn set_active(&mut self, slot: &str, _: impl InfoSender) -> CommandResult<()> {
-            self.active_slot = Some(slot.into());
-            Ok(())
-        }
-
-        async fn oem<'b>(
-            &mut self,
-            cmd: &str,
-            mut responder: impl InfoSender,
-            res: &'b mut [u8],
-        ) -> CommandResult<&'b [u8]> {
-            let (res_str, infos) = &mut self.oem_output;
-            self.oem_command = cmd.into();
-            for ele in infos {
-                responder.send_info(ele.as_str()).await?;
-            }
-            Ok(snprintf!(res, "{}", *res_str).as_bytes())
-        }
-    }
-
-    struct TestTransport {
-        in_queue: VecDeque<Vec<u8>>,
-        out_queue: VecDeque<Vec<u8>>,
-    }
-
-    impl TestTransport {
-        fn new() -> Self {
-            Self { in_queue: VecDeque::new(), out_queue: VecDeque::new() }
-        }
-
-        fn add_input(&mut self, packet: &[u8]) {
-            self.in_queue.push_back(packet.into());
-        }
-    }
-
-    impl Transport for TestTransport {
-        async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
-            match self.in_queue.pop_front() {
-                Some(v) => {
-                    let size = min(out.len(), v.len());
-                    out[..size].clone_from_slice(&v[..size]);
-                    // Returns the input length so that we can test bogus download size.
-                    Ok(v.len())
-                }
-                _ => Err(Error::Other(Some("No more data"))),
-            }
-        }
-
-        async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
-            self.out_queue.push_back(packet.into());
-            Ok(())
-        }
-    }
-
-    #[derive(Default)]
-    struct TestTcpStream {
-        in_queue: VecDeque<u8>,
-        out_queue: VecDeque<u8>,
-    }
-
-    impl TestTcpStream {
-        /// Adds bytes to input stream.
-        fn add_input(&mut self, data: &[u8]) {
-            data.iter().for_each(|v| self.in_queue.push_back(*v));
-        }
-
-        /// Adds a length pre-fixed bytes stream.
-        fn add_length_prefixed_input(&mut self, data: &[u8]) {
-            self.add_input(&(data.len() as u64).to_be_bytes());
-            self.add_input(data);
-        }
-    }
-
-    impl TcpStream for TestTcpStream {
-        async fn read_exact(&mut self, out: &mut [u8]) -> Result<()> {
-            for ele in out {
-                *ele = self.in_queue.pop_front().ok_or(Error::OperationProhibited)?;
-            }
-            Ok(())
-        }
-
-        async fn write_exact(&mut self, data: &[u8]) -> Result<()> {
-            data.iter().for_each(|v| self.out_queue.push_back(*v));
-            Ok(())
-        }
-    }
-
-    #[test]
-    fn test_boot() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"boot");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"INFOBoot to boot.img...".into(),
-                b"OKAYboot_command".into()
-            ])
-        );
-    }
-
-    #[test]
-    fn test_non_exist_command() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"non_exist");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, [b"FAILCommand not found"]);
-    }
-
-    #[test]
-    fn test_non_ascii_command_string() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"\xff\xff\xff");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, [b"FAILInvalid Command"]);
-    }
-
-    #[test]
-    fn test_get_var_max_download_size() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"getvar:max-download-size");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, [b"OKAY0x400"]);
-    }
-
-    #[test]
-    fn test_get_var() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let vars: [((&str, &[&str]), &str); 4] = [
-            (("var_0", &[]), "val_0"),
-            (("var_1", &["a", "b"]), "val_1_a_b"),
-            (("var_1", &["c", "d"]), "val_1_c_d"),
-            (("var_2", &["e", "f"]), "val_2_e_f"),
-        ];
-        fastboot_impl.vars = BTreeMap::from(vars);
-
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"getvar:var_0");
-        transport.add_input(b"getvar:var_1:a:b");
-        transport.add_input(b"getvar:var_1:c:d");
-        transport.add_input(b"getvar:var_1"); // Not Found
-        transport.add_input(b"getvar:var_2:e:f");
-        transport.add_input(b"getvar:var_3"); // Not Found
-        transport.add_input(b"getvar"); // Not Found
-
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"OKAYval_0".into(),
-                b"OKAYval_1_a_b".into(),
-                b"OKAYval_1_c_d".into(),
-                b"FAILNot Found".into(),
-                b"OKAYval_2_e_f".into(),
-                b"FAILNot Found".into(),
-                b"FAILMissing variable".into(),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_get_var_all() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let vars: [((&str, &[&str]), &str); 4] = [
-            (("var_0", &[]), "val_0"),
-            (("var_1", &["a", "b"]), "val_1_a_b"),
-            (("var_1", &["c", "d"]), "val_1_c_d"),
-            (("var_2", &["e", "f"]), "val_2_e_f"),
-        ];
-        fastboot_impl.vars = BTreeMap::from(vars);
-
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"getvar:all");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"INFOmax-download-size: 0x400".into(),
-                b"INFOvar_0: val_0".into(),
-                b"INFOvar_1:a:b: val_1_a_b".into(),
-                b"INFOvar_1:c:d: val_1_c_d".into(),
-                b"INFOvar_2:e:f: val_2_e_f".into(),
-                b"OKAY".into(),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_download() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let download_content: Vec<u8> =
-            (0..fastboot_impl.download_buffer.len()).into_iter().map(|v| v as u8).collect();
-        let mut transport = TestTransport::new();
-        // Splits download into two batches.
-        let (first, second) = download_content.as_slice().split_at(download_content.len() / 2);
-        transport.add_input(format!("download:{:#x}", download_content.len()).as_bytes());
-        transport.add_input(first);
-        transport.add_input(second);
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([b"DATA00000400".into(), b"OKAY".into(),])
-        );
-        assert_eq!(fastboot_impl.downloaded_size, download_content.len());
-        assert_eq!(fastboot_impl.download_buffer, download_content);
-    }
-
-    #[test]
-    fn test_download_not_enough_args() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"download");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, [b"FAILNot enough argument"]);
-    }
-
-    #[test]
-    fn test_download_invalid_hex_string() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"download:hhh");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue.len(), 1);
-        assert!(transport.out_queue[0].starts_with(b"FAIL"));
-    }
-
-    fn test_download_size(download_buffer_size: usize, download_size: usize, msg: &str) {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; download_buffer_size];
-        let mut transport = TestTransport::new();
-        transport.add_input(format!("download:{:#x}", download_size).as_bytes());
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([msg.as_bytes().into()]));
-    }
-
-    #[test]
-    fn test_download_download_size_too_big() {
-        test_download_size(1024, 1025, "FAILDownload size is too big");
-    }
-
-    #[test]
-    fn test_download_zero_download_size() {
-        test_download_size(1024, 0, "FAILZero download size");
-    }
-
-    #[test]
-    fn test_download_more_than_expected() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let download_content: Vec<u8> = vec![0u8; fastboot_impl.download_buffer.len()];
-        let mut transport = TestTransport::new();
-        transport.add_input(format!("download:{:#x}", download_content.len() - 1).as_bytes());
-        transport.add_input(&download_content[..]);
-        // State should be reset to command state.
-        transport.add_input(b"getvar:max-download-size");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"DATA000003ff".into(),
-                b"FAILMore data received then expected".into(),
-                b"OKAY0x400".into(),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_oem_cmd() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"oem oem-command");
-        fastboot_impl.oem_output =
-            ("oem-return".into(), vec!["oem-info-1".into(), "oem-info-2".into()]);
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(fastboot_impl.oem_command, "oem-command");
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"INFOoem-info-1".into(),
-                b"INFOoem-info-2".into(),
-                b"OKAYoem-return".into(),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_flash() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"flash:boot_a:0::");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(fastboot_impl.flash_partition, "boot_a:0::");
-        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"OKAY".into()]));
-    }
-
-    #[test]
-    fn test_flash_missing_partition() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"flash");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, [b"FAILMissing partition"]);
-    }
-
-    #[test]
-    fn test_erase() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"erase:boot_a:0::");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(fastboot_impl.erase_partition, "boot_a:0::");
-        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"OKAY".into()]));
-    }
-
-    #[test]
-    fn test_erase_missing_partition() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"erase");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(transport.out_queue, [b"FAILMissing partition"]);
-    }
-
-    #[test]
-    fn test_upload() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let upload_content: Vec<u8> = (0..1024).into_iter().map(|v| v as u8).collect();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"upload");
-        fastboot_impl.upload_config = (
-            upload_content.len().try_into().unwrap(),
-            vec![
-                upload_content[..upload_content.len() / 2].to_vec(),
-                upload_content[upload_content.len() / 2..].to_vec(),
-            ],
-        );
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"DATA00000400".into(),
-                upload_content[..upload_content.len() / 2].to_vec(),
-                upload_content[upload_content.len() / 2..].to_vec(),
-                b"OKAY".into(),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_upload_not_enough_data() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"upload");
-        fastboot_impl.upload_config = (0x400, vec![vec![0u8; 0x400 - 1]]);
-        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
-    }
-
-    #[test]
-    fn test_upload_more_data() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"upload");
-        fastboot_impl.upload_config = (0x400, vec![vec![0u8; 0x400 + 1]]);
-        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
-    }
-
-    #[test]
-    fn test_fetch() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"fetch:boot_a:0:::200:400");
-        fastboot_impl
-            .fetch_data
-            .insert("boot_a:0::", (0x400, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"DATA00000400".into(),
-                [1u8; 0x400].to_vec(),
-                b"OKAY".into(),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_fetch_not_enough_data() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"fetch:boot_a:0:::200:400");
-        fastboot_impl
-            .fetch_data
-            .insert("boot_a:0::", (0x400 - 1, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
-        assert!(block_on(process_next_command(&mut transport, &mut fastboot_impl)).is_err());
-    }
-
-    #[test]
-    fn test_fetch_more_data() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"fetch:boot_a:0:::200:400");
-        fastboot_impl
-            .fetch_data
-            .insert("boot_a:0::", (0x400 + 1, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
-        assert!(block_on(process_next_command(&mut transport, &mut fastboot_impl)).is_err());
-    }
-
-    #[test]
-    fn test_fetch_invalid_args() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 2048];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"fetch");
-        transport.add_input(b"fetch:");
-        transport.add_input(b"fetch:boot_a");
-        transport.add_input(b"fetch:boot_a:200");
-        transport.add_input(b"fetch:boot_a::400");
-        transport.add_input(b"fetch:boot_a::");
-        transport.add_input(b"fetch:boot_a:xxx:400");
-        transport.add_input(b"fetch:boot_a:200:xxx");
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert!(transport.out_queue.iter().all(|v| v.starts_with(b"FAIL")));
-    }
-
-    #[test]
-    fn test_fastboot_tcp() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let download_content: Vec<u8> =
-            (0..fastboot_impl.download_buffer.len()).into_iter().map(|v| v as u8).collect();
-        let mut tcp_stream: TestTcpStream = Default::default();
-        tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
-        // Add two commands and verify both are executed.
-        tcp_stream.add_length_prefixed_input(b"getvar:max-download-size");
-        tcp_stream.add_length_prefixed_input(
-            format!("download:{:#x}", download_content.len()).as_bytes(),
-        );
-        tcp_stream.add_length_prefixed_input(&download_content[..]);
-        let _ = block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl));
-        let expected: &[&[u8]] = &[
-            b"FB01",
-            b"\x00\x00\x00\x00\x00\x00\x00\x09OKAY0x400",
-            b"\x00\x00\x00\x00\x00\x00\x00\x0cDATA00000400",
-            b"\x00\x00\x00\x00\x00\x00\x00\x04OKAY",
-        ];
-        assert_eq!(tcp_stream.out_queue, VecDeque::from(expected.concat()));
-        assert_eq!(fastboot_impl.download_buffer, download_content);
-    }
-
-    #[test]
-    fn test_fastboot_tcp_invalid_handshake() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut tcp_stream: TestTcpStream = Default::default();
-        tcp_stream.add_input(b"ABCD");
-        assert_eq!(
-            block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl)).unwrap_err(),
-            Error::InvalidHandshake
-        );
-    }
-
-    #[test]
-    fn test_fastboot_tcp_packet_size_exceeds_maximum() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut tcp_stream: TestTcpStream = Default::default();
-        tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
-        tcp_stream.add_input(&(MAX_COMMAND_SIZE + 1).to_be_bytes());
-        assert_eq!(
-            block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl)).unwrap_err(),
-            Error::InvalidInput
-        );
-    }
-
-    #[test]
-    fn test_reboot() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"reboot");
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Normal));
-        assert_eq!(transport.out_queue[0], b"OKAY");
-        // Failure is expected here because test reboot implementation always returns, which
-        // automatically generates a fastboot failure packet.
-        assert!(transport.out_queue[1].starts_with(b"FAIL"));
-    }
-
-    #[test]
-    fn test_reboot_bootloader() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"reboot-bootloader");
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Bootloader));
-        assert_eq!(transport.out_queue[0], b"OKAY");
-        // Failure is expected here because test reboot implementation always returns, which
-        // automatically generates a fastboot failure packet.
-        assert!(transport.out_queue[1].starts_with(b"FAIL"));
-    }
-
-    #[test]
-    fn test_reboot_fastboot() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"reboot-fastboot");
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Fastboot));
-        assert_eq!(transport.out_queue[0], b"OKAY");
-        // Failure is expected here because test reboot implementation always returns, which
-        // automatically generates a fastboot failure packet.
-        assert!(transport.out_queue[1].starts_with(b"FAIL"));
-    }
-
-    #[test]
-    fn test_reboot_recovery() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut transport = TestTransport::new();
-        transport.add_input(b"reboot-recovery");
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Recovery));
-        assert_eq!(transport.out_queue[0], b"OKAY");
-        // Failure is expected here because test reboot implementation always returns, which
-        // automatically generates a fastboot failure packet.
-        assert!(transport.out_queue[1].starts_with(b"FAIL"));
-    }
-
-    #[test]
-    fn test_continue() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"getvar:max-download-size");
-        transport.add_input(b"continue");
-        transport.add_input(b"getvar:max-download-size");
-        block_on(run(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([
-                b"OKAY0x400".into(),
-                b"INFOContinuing to boot...".into(),
-                b"OKAY".into()
-            ])
-        );
-    }
-
-    #[test]
-    fn test_continue_run_tcp() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        let mut tcp_stream: TestTcpStream = Default::default();
-        tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
-        tcp_stream.add_length_prefixed_input(b"continue");
-        block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl)).unwrap();
-    }
-
-    #[test]
-    fn test_set_active() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"set_active:a");
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"OKAY".into()]));
-        assert_eq!(fastboot_impl.active_slot, Some("a".into()));
-    }
-
-    #[test]
-    fn test_set_active_missing_slot() {
-        let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
-        let mut transport = TestTransport::new();
-        transport.add_input(b"set_active");
-        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
-        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"FAILMissing slot".into()]));
-    }
-}
diff --git a/gbl/libfastboot/src/local_session.rs b/gbl/libfastboot/src/local_session.rs
deleted file mode 100644
index 63303fa..0000000
--- a/gbl/libfastboot/src/local_session.rs
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2025, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::Transport;
-use liberror::Result;
-
-/// Trait for a device-local fastboot-like session.
-pub trait LocalSession {
-    /// Updates the context of the local session.
-    /// Polls inputs, updates graphics, and so forth.
-    async fn update(&mut self, buf: &mut [u8]) -> Result<usize>;
-
-    /// This is a hack to allow test structures to capture outgoing packets.
-    async fn process_outgoing_packet(&mut self, _: &[u8]) {}
-}
-
-impl<T: LocalSession> Transport for T {
-    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
-        self.update(out).await
-    }
-
-    async fn send_packet(&mut self, buf: &[u8]) -> Result<()> {
-        self.process_outgoing_packet(buf).await;
-        Ok(())
-    }
-}
diff --git a/gbl/libfdt/BUILD b/gbl/libfdt/BUILD
deleted file mode 100644
index a73779f..0000000
--- a/gbl/libfdt/BUILD
+++ /dev/null
@@ -1,153 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-rust_bindgen(
-    name = "libfdt_c_bindgen",
-    bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
-        "--with-derive-custom-struct=fdt_header=Immutable,IntoBytes,KnownLayout,FromBytes,PartialEq",
-        "--allowlist-function",
-        "(fdt_.*)",
-        "--allowlist-type",
-        "(fdt_.*)",
-        "--raw-line",
-        """
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![allow(dead_code)]
-#![allow(unsafe_op_in_unsafe_fn)]
-#![cfg_attr(not(test), no_std)]
-
-use zerocopy::{Immutable, IntoBytes, KnownLayout, FromBytes};
-""",
-    ],
-    cc_lib = "@libfdt_c",
-    # For x86_32, we need to explicitly specify 32bit architecture.
-    clang_flags = select({
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-        "//conditions:default": ["-m64"],
-    }) + [
-        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
-        "-nostdinc",
-    ],
-    header = "@libfdt_c//:libfdt.h",
-)
-
-rust_bindgen(
-    name = "libufdt_c_bindgen",
-    bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
-        "--opaque-type",
-        "fdt_header",
-        "--allowlist-function",
-        "ufdt_apply_multioverlay",
-        "--raw-line",
-        """
-# ![cfg_attr(not(test), no_std)]
-""",
-    ],
-    cc_lib = "@libufdt_c",
-    # For x86_32, we need to explicitly specify 32bit architecture.
-    clang_flags = select({
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-        "//conditions:default": ["-m64"],
-    }) + [
-        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
-        "-nostdinc",
-    ],
-    header = "@libufdt_c//:include/ufdt_overlay.h",
-)
-
-rust_library(
-    name = "libfdt_bindgen",
-    srcs = [":libfdt_c_bindgen"],
-    deps = ["@zerocopy"],
-)
-
-rust_library(
-    name = "libufdt_bindgen",
-    srcs = [":libufdt_c_bindgen"],
-)
-
-rust_library(
-    name = "libfdt_sysdeps",
-    srcs = ["deps/lib.rs"],
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libc",
-    ],
-)
-
-link_static_cc_library(
-    name = "libfdt_sysdeps_static",
-    cc_library = ":libfdt_sysdeps",
-)
-
-rust_library(
-    name = "libfdt",
-    srcs = ["src/lib.rs"],
-    crate_name = "fdt",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":libfdt_bindgen",
-        ":libfdt_c_static",
-        ":libfdt_sysdeps_static",
-        ":libufdt_bindgen",
-        ":libufdt_c_static",
-        "@arrayvec",
-        "@gbl//libc",
-        "@gbl//liberror",
-        "@gbl//libsafemath",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libfdt_test",
-    compile_data = [
-        "@gbl//libfdt/test/data:all",
-    ],
-    crate = ":libfdt",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libc:libc_deps_posix",
-    ],
-)
-
-link_static_cc_library(
-    name = "libfdt_c_static",
-    cc_library = "@libfdt_c",
-)
-
-link_static_cc_library(
-    name = "libufdt_c_static",
-    cc_library = "@libufdt_c",
-)
diff --git a/gbl/libfdt/BUILD.libfdt_c.bazel b/gbl/libfdt/BUILD.libfdt_c.bazel
deleted file mode 100644
index 6a8fed4..0000000
--- a/gbl/libfdt/BUILD.libfdt_c.bazel
+++ /dev/null
@@ -1,50 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-cc_library(
-    name = "libfdt_c",
-    srcs = [
-        "acpi.c",
-        "fdt.c",
-        "fdt_addresses.c",
-        "fdt_check.c",
-        "fdt_empty_tree.c",
-        "fdt_overlay.c",
-        "fdt_ro.c",
-        "fdt_rw.c",
-        "fdt_strerror.c",
-        "fdt_sw.c",
-        "fdt_wip.c",
-    ],
-    hdrs = [
-        "fdt.h",
-        "libacpi.h",
-        "libfdt.h",
-        "libfdt_env.h",
-        "libfdt_internal.h",
-    ],
-    copts = [
-        "-Wno-int-conversion",
-        "-Wno-implicit-function-declaration",
-        "-Wno-pointer-integer-compare",
-    ],
-    includes = ["."],
-    deps = ["@gbl//libc:headers"],
-)
diff --git a/gbl/libfdt/BUILD.libufdt_c.bazel b/gbl/libfdt/BUILD.libufdt_c.bazel
deleted file mode 100644
index 8d16281..0000000
--- a/gbl/libfdt/BUILD.libufdt_c.bazel
+++ /dev/null
@@ -1,64 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_cc//cc:defs.bzl", "cc_library")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "libufdt_c",
-    srcs = [
-        "ufdt_convert.c",
-        "ufdt_node.c",
-        "ufdt_node_pool.c",
-        "ufdt_overlay.c",
-        "ufdt_prop_dict.c",
-        "@gbl//libfdt:deps/print.c",
-    ] + select({
-        "@gbl//toolchain:gbl_rust_host_x86_64": ["sysdeps/libufdt_sysdeps_posix.c"],
-        "//conditions:default": [
-            "sysdeps/libufdt_sysdeps_vendor.c",
-        ],
-    }),
-    hdrs = [
-        "include/libufdt.h",
-        "include/ufdt_node_pool.h",
-        "include/ufdt_overlay.h",
-        "include/ufdt_overlay_internal.h",
-        "include/ufdt_types.h",
-        "sysdeps/include/libufdt_sysdeps.h",
-        "ufdt_prop_dict.h",
-    ],
-    copts = [
-        # Disable default dto_print implementation to include libufdt_sysdeps_vendor.c
-        "-DDTO_DISABLE_DEFAULT_VENDOR_LIBC_PRINT",
-        # Disable default dto_malloc, dto_free implementations to include libufdt_sysdeps_vendor.c
-        "-DDTO_DISABLE_DEFAULT_VENDOR_LIBC_ALLOCATION",
-        # Disable default dto_print implementation to include libufdt_sysdeps_posix.c
-        "-DDTO_DISABLE_DEFAULT_POSIX_LIBC_PRINT",
-        # Disable default dto_malloc, dto_free implementations to include libufdt_sysdeps_posix.c
-        "-DDTO_DISABLE_DEFAULT_POSIX_LIBC_ALLOCATION",
-    ],
-    includes = [
-        ".",
-        "include",
-        "sysdeps/include",
-    ],
-    deps = [
-        "@gbl//libc:headers",
-        "@libfdt_c",
-    ],
-)
diff --git a/gbl/libfdt/deps/lib.rs b/gbl/libfdt/deps/lib.rs
deleted file mode 100644
index 65fa302..0000000
--- a/gbl/libfdt/deps/lib.rs
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides one possible implementation of the sysdeps functions for libufdt.
-//! Global allocator is required.
-
-#![cfg_attr(not(test), no_std)]
-
-use core::ffi::c_void;
-use libc::{gbl_free, gbl_malloc};
-
-const DTO_MALLOC_ALIGNMENT: usize = 8;
-
-/// void *malloc(size_t size)
-///
-/// # Safety:
-///
-/// * `return value` pointing buffer must be used within provided `size`
-#[no_mangle]
-pub unsafe extern "C" fn dto_malloc(size: usize) -> *mut c_void {
-    // SAFETY: libufdt calls are compatible with libc counterparts, alignment the same as
-    // dto_free
-    unsafe { gbl_malloc(size, DTO_MALLOC_ALIGNMENT) }
-}
-
-/// void free(void *ptr)
-///
-/// # Safety:
-///
-/// * `ptr` must be a pointer allocated by `dto_malloc` or null
-#[no_mangle]
-pub unsafe extern "C" fn dto_free(ptr: *mut c_void) {
-    // SAFETY: libufdt calls are compatible with libc counterparts, alignment the same as
-    // dto_malloc
-    unsafe { gbl_free(ptr, DTO_MALLOC_ALIGNMENT) }
-}
diff --git a/gbl/libfdt/deps/print.c b/gbl/libfdt/deps/print.c
deleted file mode 100644
index 9c856c5..0000000
--- a/gbl/libfdt/deps/print.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#include <gbl/print.h>
-
-void dto_print(const char* fmt, ...) {
-  va_list args;
-  va_start(args, fmt);
-  gbl_printf(fmt, args);
-  va_end(args);
-}
\ No newline at end of file
diff --git a/gbl/libfdt/src/lib.rs b/gbl/libfdt/src/lib.rs
deleted file mode 100644
index 406ce73..0000000
--- a/gbl/libfdt/src/lib.rs
+++ /dev/null
@@ -1,725 +0,0 @@
-// Copyright 2023-2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides a few wrapper APIs for libfdt_c
-
-#![cfg_attr(not(test), no_std)]
-
-extern crate alloc;
-extern crate libc;
-
-use arrayvec::ArrayVec;
-use core::ffi::{c_int, CStr};
-use core::mem::size_of;
-use core::slice::{from_raw_parts, from_raw_parts_mut};
-use liberror::{Error, Result};
-use libfdt_bindgen::{
-    fdt_add_subnode_namelen, fdt_del_node, fdt_get_property, fdt_header, fdt_move, fdt_setprop,
-    fdt_setprop_placeholder, fdt_strerror, fdt_subnode_offset_namelen,
-};
-use libufdt_bindgen::ufdt_apply_multioverlay;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref};
-
-/// Fdt header structure size.
-pub const FDT_HEADER_SIZE: usize = size_of::<FdtHeader>();
-const MAXIMUM_OVERLAYS_TO_APPLY: usize = 16;
-const MAXIMUM_OVERLAYS_ERROR_MSG: &str = "At most 16 overlays are supported to apply at a time";
-
-/// Convert libfdt_c error code to Result
-fn map_result(code: c_int) -> Result<c_int> {
-    match code {
-        // SAFETY: Static null terminated string returned from libfdt_c API.
-        v if v < 0 => {
-            Err(Error::Other(Some(unsafe { CStr::from_ptr(fdt_strerror(v)).to_str().unwrap() })))
-        }
-        v => Ok(v),
-    }
-}
-
-/// Convert libufdt_c error code to Result
-fn map_result_libufdt(code: c_int) -> Result<c_int> {
-    match code {
-        v if v < 0 => Err(Error::Other(Some("Failed to execute libufdt call"))),
-        v => Ok(v),
-    }
-}
-
-/// Check header.
-fn fdt_check_header(header: &[u8]) -> Result<()> {
-    // SAFETY:
-    // `fdt_check_header` is only access the memory pointed to by `header` during this call and
-    // not store the pointer for later use. `header` remains valid for the duration of this call.
-    map_result(unsafe { libfdt_bindgen::fdt_check_header(header.as_ptr() as *const _) })?;
-    Ok(())
-}
-
-/// Check header and verified that totalsize does not exceed buffer size.
-fn fdt_check_buffer(fdt: &[u8]) -> Result<()> {
-    match FdtHeader::from_bytes_ref(fdt)?.totalsize() <= fdt.len() {
-        true => Ok(()),
-        _ => Err(Error::InvalidInput),
-    }
-}
-
-/// Wrapper of fdt_add_subnode_namelen()
-fn fdt_add_subnode(fdt: &mut [u8], parent: c_int, name: &str) -> Result<c_int> {
-    // SAFETY: API from libfdt_c.
-    map_result(unsafe {
-        fdt_add_subnode_namelen(
-            fdt.as_mut_ptr() as *mut _,
-            parent,
-            name.as_ptr() as *const _,
-            name.len().try_into()?,
-        )
-    })
-}
-
-/// Wrapper of fdt_subnode_offset_namelen()
-fn fdt_subnode_offset(fdt: &[u8], parent: c_int, name: &str) -> Result<c_int> {
-    // SAFETY: API from libfdt_c.
-    map_result(unsafe {
-        fdt_subnode_offset_namelen(
-            fdt.as_ptr() as *const _,
-            parent,
-            name.as_ptr() as *const _,
-            name.len().try_into()?,
-        )
-    })
-}
-
-/// Rust wrapper for the FDT header data.
-#[repr(transparent)]
-#[derive(Debug, Copy, Clone, Immutable, IntoBytes, KnownLayout, FromBytes, PartialEq)]
-pub struct FdtHeader(fdt_header);
-
-impl FdtHeader {
-    /// Return the totalsize field.
-    pub fn totalsize(&self) -> usize {
-        u32::from_be(self.0.totalsize) as usize
-    }
-
-    /// Return the minimal size of the FDT. Disregard trailing free space.
-    pub fn actual_size(&self) -> usize {
-        u32::from_be(self.0.off_dt_strings)
-            .checked_add(u32::from_be(self.0.size_dt_strings))
-            .unwrap() as usize
-    }
-
-    /// Update the totalsize field.
-    pub fn set_totalsize(&mut self, value: u32) {
-        self.0.totalsize = value.to_be();
-    }
-
-    /// Cast a bytes into a reference of FDT header
-    pub fn from_bytes_ref(buffer: &[u8]) -> Result<&FdtHeader> {
-        fdt_check_header(buffer)?;
-
-        Ok(Ref::into_ref(
-            Ref::<_, FdtHeader>::new_from_prefix(buffer)
-                .ok_or(Error::BufferTooSmall(Some(FDT_HEADER_SIZE)))?
-                .0,
-        ))
-    }
-
-    /// Cast a bytes into a mutable reference of FDT header.
-    pub fn from_bytes_mut(buffer: &mut [u8]) -> Result<&mut FdtHeader> {
-        fdt_check_header(buffer)?;
-
-        Ok(Ref::into_mut(
-            Ref::<_, FdtHeader>::new_from_prefix(buffer)
-                .ok_or(Error::BufferTooSmall(Some(FDT_HEADER_SIZE)))?
-                .0,
-        ))
-    }
-
-    /// Get FDT header and raw bytes from a raw pointer.
-    ///
-    /// Caller should guarantee that
-    ///   1. `ptr` contains a valid FDT.
-    ///   2. The buffer remains valid as long as the returned references are in use.
-    pub unsafe fn from_raw(ptr: *const u8) -> Result<(&'static FdtHeader, &'static [u8])> {
-        // SAFETY: By safety requirement of this function, `ptr` points to a valid FDT and remains
-        // valid when in use.
-        unsafe {
-            let header_bytes = from_raw_parts(ptr, FDT_HEADER_SIZE);
-            let header = Self::from_bytes_ref(header_bytes)?;
-            Ok((header, from_raw_parts(ptr, header.totalsize())))
-        }
-    }
-}
-
-/// Object for managing an FDT.
-pub struct Fdt<T>(T);
-
-/// Read only APIs.
-impl<'a, T: AsRef<[u8]> + 'a> Fdt<T> {
-    /// Creates a new [Fdt] wrapping the contents of `init`.
-    pub fn new(init: T) -> Result<Self> {
-        fdt_check_buffer(init.as_ref())?;
-        Ok(Fdt(init))
-    }
-
-    /// Returns the [FdtHeader], or an error if the underlying buffer was invalid.
-    pub fn header_ref(&self) -> Result<&FdtHeader> {
-        FdtHeader::from_bytes_ref(self.0.as_ref())
-    }
-
-    /// Returns the totalsize according to FDT header. Trailing free space is included.
-    pub fn size(&self) -> Result<usize> {
-        Ok(self.header_ref()?.totalsize())
-    }
-
-    /// Get a property from an existing node.
-    pub fn get_property(&self, path: &str, name: &CStr) -> Result<&'a [u8]> {
-        let node = self.find_node(path)?;
-        let mut len: c_int = 0;
-        // SAFETY: API from libfdt_c.
-        let ptr = unsafe {
-            fdt_get_property(
-                self.0.as_ref().as_ptr() as *const _,
-                node,
-                name.to_bytes_with_nul().as_ptr() as *const _,
-                &mut len as *mut _,
-            )
-        };
-        // SAFETY: Buffer returned by API from libfdt_c.
-        match unsafe { ptr.as_ref() } {
-            // SAFETY: Buffer returned by API from libfdt_c.
-            Some(v) => Ok(unsafe {
-                from_raw_parts(
-                    v.data.as_ptr() as *const u8,
-                    u32::from_be(v.len).try_into().or(Err(Error::Other(None)))?,
-                )
-            }),
-            _ => Err(map_result(len).unwrap_err()),
-        }
-    }
-
-    /// Find the offset of a node by a given node path.
-    fn find_node(&self, path: &str) -> Result<c_int> {
-        let mut curr: c_int = 0;
-        for name in path.split('/') {
-            if name.len() == 0 {
-                continue;
-            }
-            curr = fdt_subnode_offset(self.0.as_ref(), curr, name)?;
-        }
-        Ok(curr)
-    }
-}
-
-/// APIs when data can be modified.
-impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
-    /// Creates a new mut [Fdt] wrapping the contents of `init`.
-    pub fn new_mut(init: T) -> Result<Self> {
-        let mut fdt = Fdt::new(init)?;
-        fdt.expand_to_buffer()?;
-        Ok(fdt)
-    }
-
-    /// Creates a mutable [Fdt] copied from `init`.
-    pub fn new_from_init(mut fdt: T, init: &[u8]) -> Result<Self> {
-        fdt_check_buffer(init)?;
-        // SAFETY: API from libfdt_c.
-        map_result(unsafe {
-            fdt_move(
-                init.as_ptr() as *const _,
-                fdt.as_mut().as_ptr() as *mut _,
-                fdt.as_mut().len().try_into().or(Err(Error::Other(None)))?,
-            )
-        })?;
-        let mut ret = Fdt::new(fdt)?;
-        ret.expand_to_buffer()?;
-        Ok(ret)
-    }
-
-    /// Parse and get the FDT header.
-    fn header_mut(&mut self) -> Result<&mut FdtHeader> {
-        FdtHeader::from_bytes_mut(self.0.as_mut())
-    }
-
-    /// Reduce the total size field in the header to minimum that will fit existing content.
-    /// No more data can be added to the FDT. This should be called after all modification is
-    /// done and before passing to the kernel. This is to prevent kernel hang when FDT size is too
-    /// big.
-    pub fn shrink_to_fit(&mut self) -> Result<()> {
-        let actual = self.header_ref()?.actual_size();
-        self.header_mut()?.set_totalsize(actual.try_into().unwrap());
-        Ok(())
-    }
-
-    /// Expand the total size field in the header to match the full buffer size.
-    /// This allows the FDT to be modified further by ensuring sufficient space is available.
-    /// Typically used before making modifications to an existing FDT, especially if it was
-    /// previously shrunk. After modifications are complete, consider calling `shrink_to_fit`
-    /// to reduce the size before passing to the kernel.
-    pub fn expand_to_buffer(&mut self) -> Result<()> {
-        let buffer_size = self.0.as_ref().len().try_into().unwrap();
-        self.header_mut()?.set_totalsize(buffer_size);
-        Ok(())
-    }
-
-    /// Delete node by `path``. Fail if node doesn't exist.
-    pub fn delete_node(&mut self, path: &str) -> Result<()> {
-        let node = self.find_node(path)?;
-        // SAFETY:
-        // * `self.0` is guaranteed to be a proper fdt header reference
-        // * `node` is offset of the node to delete within `self.0` fdt buffer
-        map_result(unsafe { fdt_del_node(self.0.as_mut().as_mut_ptr() as *mut _, node) })?;
-        Ok(())
-    }
-
-    /// Set the value of a node's property. Create the node and property if it doesn't exist.
-    pub fn set_property(&mut self, path: &str, name: &CStr, val: &[u8]) -> Result<()> {
-        let node = self.find_or_add_node(path)?;
-        // SAFETY: API from libfdt_c.
-        map_result(unsafe {
-            fdt_setprop(
-                self.0.as_mut().as_mut_ptr() as *mut _,
-                node,
-                name.to_bytes_with_nul().as_ptr() as *const _,
-                val.as_ptr() as *const _,
-                val.len().try_into().or(Err(Error::Other(None)))?,
-            )
-        })?;
-        Ok(())
-    }
-
-    /// Wrapper/equivalent of fdt_setprop_placeholder.
-    /// It creates/resizes a node's property to the given size and returns the buffer for caller
-    /// to modify content.
-    pub fn set_property_placeholder(
-        &mut self,
-        path: &str,
-        name: &CStr,
-        len: usize,
-    ) -> Result<&mut [u8]> {
-        let node = self.find_or_add_node(path)?;
-        let mut out_ptr: *mut u8 = core::ptr::null_mut();
-        // SAFETY: API from libfdt_c.
-        map_result(unsafe {
-            fdt_setprop_placeholder(
-                self.0.as_mut().as_mut_ptr() as *mut _,
-                node,
-                name.to_bytes_with_nul().as_ptr() as *const _,
-                len.try_into().or(Err(Error::Other(None)))?,
-                &mut out_ptr as *mut *mut u8 as *mut _,
-            )
-        })?;
-        assert!(!out_ptr.is_null());
-        // SAFETY: Buffer returned by API from libfdt_c.
-        Ok(unsafe { from_raw_parts_mut(out_ptr, len) })
-    }
-
-    /// Wrapper/equivalent of ufdt_apply_multioverlay.
-    /// It extend current FDT buffer by applying passed overlays.
-    pub fn multioverlay_apply(&mut self, overlays: &[&[u8]]) -> Result<()> {
-        // Avoid shrinking device tree or doing any other actions in case nothing to apply.
-        if overlays.is_empty() {
-            return Ok(());
-        }
-        if overlays.len() > MAXIMUM_OVERLAYS_TO_APPLY {
-            return Err(Error::Other(Some(MAXIMUM_OVERLAYS_ERROR_MSG)));
-        }
-
-        self.shrink_to_fit()?;
-
-        // Convert input fat references into the raw pointers.
-        let pointers: ArrayVec<_, MAXIMUM_OVERLAYS_TO_APPLY> =
-            overlays.iter().map(|&slice| slice.as_ptr()).collect();
-
-        // SAFETY: The `ufdt_apply_multioverlay` function guarantees that `self.0` is accessed
-        // within the specified length boundaries. The `pointers` are non-null and are accessed
-        // by indexes only within the provided length.
-        map_result_libufdt(unsafe {
-            ufdt_apply_multioverlay(
-                self.0.as_mut().as_mut_ptr() as *mut _,
-                self.0.as_ref().len(),
-                pointers.as_ptr().cast(),
-                overlays.len(),
-            )
-        })?;
-
-        self.expand_to_buffer()?;
-
-        Ok(())
-    }
-
-    /// Find the offset of a node by a given node path. Add if node does not exist.
-    fn find_or_add_node(&mut self, path: &str) -> Result<c_int> {
-        let mut curr: c_int = 0;
-        for name in path.split('/') {
-            if name.len() == 0 {
-                continue;
-            }
-            curr = match fdt_subnode_offset(self.0.as_ref(), curr, name) {
-                Ok(v) => v,
-                _ => fdt_add_subnode(self.0.as_mut(), curr, name)?,
-            };
-        }
-        Ok(curr)
-    }
-}
-
-impl<T: AsMut<[u8]>> AsMut<[u8]> for Fdt<T> {
-    fn as_mut(&mut self) -> &mut [u8] {
-        self.0.as_mut()
-    }
-}
-
-impl<T: AsRef<[u8]>> AsRef<[u8]> for Fdt<T> {
-    fn as_ref(&self) -> &[u8] {
-        self.0.as_ref()
-    }
-}
-
-#[cfg(test)]
-mod test {
-    extern crate libc_deps_posix;
-
-    use super::*;
-
-    // Fdt is required to be 8 bytes aligned. Buffer to test alignment-related logic.
-    #[repr(align(8))]
-    struct AlignedBytes<const N: usize>([u8; N]);
-
-    /// Checks to verify `overlay_*_by_path`/`overlay_*_by_reference` are successfully applied
-    fn check_overlays_are_applied(fdt: &[u8]) {
-        let fdt = Fdt::new(fdt).unwrap();
-
-        assert_eq!(fdt.header_ref().unwrap().totalsize(), fdt.as_ref().len());
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "overlay1-property-1-value",
-            "overlay_modify: failed to modify \"property-1\" in \"/dev-2/dev-2.2/dev-2.2.1\""
-        );
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-1/overlay1-new-node", c"overlay1-new-node-property")
-                    .unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "overlay1-new-node-property-value",
-            "overlay_modify: failed to add \"overlay1-new-node\" to \"/dev-1\""
-        );
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-4", c"overlay1-root-node-property").unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "overlay1-root-node-property-value",
-            "overlay_modify: failed to add \"/dev-4/overlay1-root-node-property\""
-        );
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"overlay1-new-property").unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "overlay2-new-property-value",
-            "overlay_modify2: failed to modify \"overlay1-new-property\" in \"/dev-2/dev-2.2/dev-2.2.1\""
-        );
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-4", c"overlay2-root-node-property").unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "overlay2-root-node-property-value",
-            "overlay_modify2: failed to add \"overlay2-root-node-property\" to \"/dev-4\""
-        );
-    }
-
-    #[test]
-    fn test_new_from_invalid_fdt() {
-        let mut init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len()];
-        // Invalid total size
-        assert!(Fdt::new_from_init(&mut fdt_buf[..], &init[..init.len() - 1]).is_err());
-        // Invalid FDT
-        init[..4].fill(0);
-        assert!(Fdt::new_from_init(&mut fdt_buf[..], &init[..]).is_err());
-    }
-
-    #[test]
-    fn test_get_property() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len()];
-        let fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert_eq!(
-            CStr::from_bytes_with_nul(fdt.get_property("/", c"info").unwrap())
-                .unwrap()
-                .to_str()
-                .unwrap(),
-            "test device tree"
-        );
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "dev-2.2.1-property-1"
-        );
-
-        // Non eixsts
-        assert!(fdt.get_property("/", c"non-existent").is_err());
-    }
-
-    #[test]
-    fn test_set_property() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len() + 512];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-        let data = vec![0x11u8, 0x22u8, 0x33u8];
-        fdt.set_property("/new-node", c"custom", &data).unwrap();
-        assert_eq!(fdt.get_property("/new-node", c"custom").unwrap().to_vec(), data);
-    }
-
-    #[test]
-    fn test_delete_node() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert_eq!(
-            CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").unwrap()
-            )
-            .unwrap()
-            .to_str()
-            .unwrap(),
-            "dev-2.2.1-property-1"
-        );
-
-        fdt.delete_node("dev-2").unwrap();
-
-        assert!(
-            fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").is_err(),
-            "dev-2.2.1-property-1 expected to be deleted"
-        );
-    }
-
-    #[test]
-    fn test_delete_nost_existed_node_is_failed() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert!(
-            fdt.delete_node("/non-existent").is_err(),
-            "expected failed to delete non existent node"
-        );
-    }
-
-    #[test]
-    fn test_set_property_placeholder() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len() + 512];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-        let data = vec![0x11u8, 0x22u8, 0x33u8, 0x44u8, 0x55u8];
-        let payload = fdt.set_property_placeholder("/new-node", c"custom", data.len()).unwrap();
-        payload.clone_from_slice(&data[..]);
-        assert_eq!(fdt.get_property("/new-node", c"custom").unwrap().to_vec(), data);
-    }
-
-    #[test]
-    fn test_header_from_bytes() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let header = FdtHeader::from_bytes_ref(&init[..]).unwrap();
-
-        assert_eq!(header.totalsize(), init.len());
-    }
-
-    #[test]
-    fn test_header_from_bytes_wrong_alignment() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-
-        const HEADER_SIZE: usize = size_of::<FdtHeader>();
-        let mut bytes = AlignedBytes([0u8; HEADER_SIZE + 1]);
-
-        // Guaranteed not to be 8 bytes aligned.
-        let (_, unaligned) = bytes.0.split_at_mut(1);
-        unaligned.copy_from_slice(&init[..HEADER_SIZE]);
-
-        assert!(FdtHeader::from_bytes_ref(unaligned).is_err());
-    }
-
-    #[test]
-    fn test_header_from_raw() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        // Pointer points to `init`
-        let (header, bytes) = unsafe { FdtHeader::from_raw(init.as_ptr()).unwrap() };
-        assert_eq!(header.totalsize(), init.len());
-        assert_eq!(bytes.to_vec(), init);
-    }
-
-    #[test]
-    fn test_header_from_raw_invalid() {
-        let mut init = include_bytes!("../test/data/base.dtb").to_vec();
-        init[..4].fill(0);
-        // Pointer points to `init`
-        assert!(unsafe { FdtHeader::from_raw(init.as_ptr()).is_err() });
-    }
-
-    #[test]
-    fn test_fdt_shrink_to_fit() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let mut fdt_buf = vec![0u8; init.len() + 512];
-        let fdt_buf_len = fdt_buf.len();
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-        assert_eq!(fdt.size().unwrap(), fdt_buf_len);
-        fdt.shrink_to_fit().unwrap();
-        assert_eq!(fdt.size().unwrap(), init.len());
-    }
-
-    #[test]
-    fn test_fdt_multioverlay_apply_by_path() {
-        let base = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_modify = include_bytes!("../test/data/overlay_by_path.dtbo").to_vec();
-        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_path.dtbo").to_vec();
-
-        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
-
-        fdt.multioverlay_apply(&[&overlay_modify[..] as _, &overlay_modify2[..] as _]).unwrap();
-
-        check_overlays_are_applied(fdt.0);
-    }
-
-    #[test]
-    fn test_fdt_multioverlay_apply_by_path_separately() {
-        let base = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_modify = include_bytes!("../test/data/overlay_by_path.dtbo").to_vec();
-        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_path.dtbo").to_vec();
-
-        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
-
-        fdt.multioverlay_apply(&[&overlay_modify[..] as _]).unwrap();
-        fdt.multioverlay_apply(&[&overlay_modify2[..] as _]).unwrap();
-
-        check_overlays_are_applied(fdt.0);
-    }
-
-    // TODO(b/362486327): symbols from overlay are not added to the result tree
-    // so cannot refer to them.
-    #[ignore]
-    #[test]
-    fn test_fdt_multioverlay_apply_by_reference() {
-        let base = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_modify = include_bytes!("../test/data/overlay_by_reference.dtbo").to_vec();
-        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_reference.dtbo").to_vec();
-
-        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
-
-        fdt.multioverlay_apply(&[&overlay_modify[..] as _, &overlay_modify2[..] as _]).unwrap();
-
-        check_overlays_are_applied(fdt.0);
-    }
-
-    // TODO(b/362486327): symbols from overlay are not added to the result tree
-    // so cannot refer to them.
-    #[ignore]
-    #[test]
-    fn test_fdt_multioverlay_apply_by_reference_separately() {
-        let base = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_modify = include_bytes!("../test/data/overlay_by_reference.dtbo").to_vec();
-        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_reference.dtbo").to_vec();
-
-        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
-
-        fdt.multioverlay_apply(&[&overlay_modify[..] as _]).unwrap();
-        fdt.multioverlay_apply(&[&overlay_modify2[..] as _]).unwrap();
-
-        check_overlays_are_applied(fdt.0);
-    }
-
-    #[test]
-    fn test_fdt_multioverlay_apply_not_enough_space() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_basic = include_bytes!("../test/data/overlay_by_path.dtbo").to_vec();
-
-        let mut fdt_buf = vec![0u8; init.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert!(
-            fdt.multioverlay_apply(&[&overlay_basic[..]]).is_err(),
-            "expected the problem is catched when not enough space in the main fdt buffer"
-        );
-    }
-
-    #[test]
-    fn test_fdt_multioverlay_apply_corrupted() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_corrupted: Vec<u8> = include_bytes!("../test/data/overlay_by_path.dtbo")
-            .to_vec()
-            .iter()
-            .copied()
-            .rev()
-            .collect();
-
-        let mut fdt_buf = vec![0u8; init.len() + overlay_corrupted.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert!(
-            fdt.multioverlay_apply(&[&overlay_corrupted[..]]).is_err(),
-            "expected the problem is catched when applying corrupted overlay"
-        );
-    }
-
-    #[test]
-    fn test_fdt_multioverlay_apply_with_wrong_target_path() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let overlay_wrong_path = include_bytes!("../test/data/overlay_wrong_path.dtbo").to_vec();
-
-        let mut fdt_buf = vec![0u8; init.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert!(
-            fdt.multioverlay_apply(&[&overlay_wrong_path[..]]).is_err(),
-            "expected the problem is catched when applying overlay with wrong target path"
-        );
-    }
-
-    #[test]
-    fn test_fdt_multioverlay_apply_maximum_amount_of_overlays_handled() {
-        let init = include_bytes!("../test/data/base.dtb").to_vec();
-        let too_many_overlays = &[&[] as &[u8]; MAXIMUM_OVERLAYS_TO_APPLY + 1];
-
-        let mut fdt_buf = vec![0u8; init.len()];
-        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
-
-        assert_eq!(
-            fdt.multioverlay_apply(too_many_overlays),
-            Err(Error::Other(Some(MAXIMUM_OVERLAYS_ERROR_MSG))),
-            "too many overlays isn't handled"
-        );
-    }
-}
diff --git a/gbl/libfdt/test/base.dts b/gbl/libfdt/test/base.dts
deleted file mode 100644
index b02a9f9..0000000
--- a/gbl/libfdt/test/base.dts
+++ /dev/null
@@ -1,22 +0,0 @@
-/dts-v1/;
-
-// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
-/ {
-	info = "test device tree";
-
-    dev1: dev-1 {};
-
-    dev-2 {
-        dev-2.1 {};
-
-        dev-2.2 {
-            dev221: dev-2.2.1 {
-                property-1 = "dev-2.2.1-property-1";
-            };
-        };
-
-        dev-1.3 {};
-    };
-
-    dev-3 {};
-};
diff --git a/gbl/libfdt/test/data/base.dtb b/gbl/libfdt/test/data/base.dtb
deleted file mode 100644
index 18e587c..0000000
Binary files a/gbl/libfdt/test/data/base.dtb and /dev/null differ
diff --git a/gbl/libfdt/test/data/overlay_2_by_path.dtbo b/gbl/libfdt/test/data/overlay_2_by_path.dtbo
deleted file mode 100644
index 397e7a6..0000000
Binary files a/gbl/libfdt/test/data/overlay_2_by_path.dtbo and /dev/null differ
diff --git a/gbl/libfdt/test/data/overlay_2_by_reference.dtbo b/gbl/libfdt/test/data/overlay_2_by_reference.dtbo
deleted file mode 100644
index 7ee1f7d..0000000
Binary files a/gbl/libfdt/test/data/overlay_2_by_reference.dtbo and /dev/null differ
diff --git a/gbl/libfdt/test/data/overlay_by_path.dtbo b/gbl/libfdt/test/data/overlay_by_path.dtbo
deleted file mode 100644
index 4fb94a9..0000000
Binary files a/gbl/libfdt/test/data/overlay_by_path.dtbo and /dev/null differ
diff --git a/gbl/libfdt/test/data/overlay_by_reference.dtbo b/gbl/libfdt/test/data/overlay_by_reference.dtbo
deleted file mode 100644
index 0b72ff0..0000000
Binary files a/gbl/libfdt/test/data/overlay_by_reference.dtbo and /dev/null differ
diff --git a/gbl/libfdt/test/data/overlay_wrong_path.dtbo b/gbl/libfdt/test/data/overlay_wrong_path.dtbo
deleted file mode 100644
index 04cef77..0000000
Binary files a/gbl/libfdt/test/data/overlay_wrong_path.dtbo and /dev/null differ
diff --git a/gbl/libfdt/test/gen_test_dtb.sh b/gbl/libfdt/test/gen_test_dtb.sh
deleted file mode 100755
index 5d4764a..0000000
--- a/gbl/libfdt/test/gen_test_dtb.sh
+++ /dev/null
@@ -1,30 +0,0 @@
-#!/bin/bash
-#
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-set -e
-
-readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
-readonly DATA_DIR="${SCRIPT_DIR}/data/"
-
-dtc -@ -I dts -O dtb -o ${DATA_DIR}/base.dtb ${SCRIPT_DIR}/base.dts
-
-dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_by_path.dtbo ${SCRIPT_DIR}/overlay_by_path.dts
-dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_2_by_path.dtbo ${SCRIPT_DIR}/overlay_2_by_path.dts
-
-dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_by_reference.dtbo ${SCRIPT_DIR}/overlay_by_reference.dts
-dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_2_by_reference.dtbo ${SCRIPT_DIR}/overlay_2_by_reference.dts
-
-dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_wrong_path.dtbo ${SCRIPT_DIR}/overlay_wrong_path.dts
diff --git a/gbl/libfdt/test/overlay_2_by_path.dts b/gbl/libfdt/test/overlay_2_by_path.dts
deleted file mode 100644
index c23e54e..0000000
--- a/gbl/libfdt/test/overlay_2_by_path.dts
+++ /dev/null
@@ -1,21 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
-/ {
-    // change the value of a property added by a previous overlay
-    fragment@1 {
-        target-path = "/dev-2/dev-2.2/dev-2.2.1";
-        __overlay__ {
-            overlay1-new-property = "overlay2-new-property-value";
-        };
-    };
-
-    // add a new property to the node added by a previous overlay
-    fragment@2 {
-        target-path = "/dev-4";
-        __overlay__ {
-            overlay2-root-node-property = "overlay2-root-node-property-value";
-        };
-    };
-};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_2_by_reference.dts b/gbl/libfdt/test/overlay_2_by_reference.dts
deleted file mode 100644
index 489ac5c..0000000
--- a/gbl/libfdt/test/overlay_2_by_reference.dts
+++ /dev/null
@@ -1,22 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
-/ {
-    // change the value of a property added by a previous overlay
-    fragment@1 {
-        target = <&dev221>;
-        __overlay__ {
-            overlay1-new-property = "overlay2-new-property-value";
-        };
-    };
-
-    // add a new property to the node added by a previous overlay
-    fragment@2 {
-        // TODO(b/362486327): failed to refer dev4 added by previous overlay
-        target = <&dev4>;
-        __overlay__ {
-            overlay2-root-node-property = "overlay2-root-node-property-value";
-        };
-    };
-};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_by_path.dts b/gbl/libfdt/test/overlay_by_path.dts
deleted file mode 100644
index ad483a0..0000000
--- a/gbl/libfdt/test/overlay_by_path.dts
+++ /dev/null
@@ -1,41 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
-/ {
-    // modify a property in an existing node
-    fragment@0 {
-        target-path = "/dev-2/dev-2.2/dev-2.2.1";
-        __overlay__ {
-            property-1 = "overlay1-property-1-value";
-        };
-    };
-
-    // add a new property to an existing node
-    fragment@1 {
-        target-path = "/dev-2/dev-2.2/dev-2.2.1";
-        __overlay__ {
-            overlay1-new-property = "overlay1-new-property-value";
-        };
-    };
-
-    // add a new node under an existing node
-    fragment@2 {
-        target-path = "/dev-1";
-        __overlay__ {
-            overlay1-new-node {
-                overlay1-new-node-property = "overlay1-new-node-property-value";
-            };
-        };
-    };
-
-    // add a new node at the root level
-    fragment@3 {
-        target-path = "/";
-        __overlay__ {
-            dev4: dev-4 {
-                overlay1-root-node-property = "overlay1-root-node-property-value";
-            };
-        };
-    };
-};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_by_reference.dts b/gbl/libfdt/test/overlay_by_reference.dts
deleted file mode 100644
index ac46bfd..0000000
--- a/gbl/libfdt/test/overlay_by_reference.dts
+++ /dev/null
@@ -1,42 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
-/ {
-    // modify a property in an existing node
-    fragment@0 {
-        target = <&dev221>;
-        __overlay__ {
-            property-1 = "overlay1-property-1-value";
-        };
-    };
-
-    // add a new property to an existing node
-    fragment@1 {
-        target = <&dev221>;
-        __overlay__ {
-            overlay1-new-property = "overlay1-new-property-value";
-        };
-    };
-
-    // add a new node under an existing node
-    fragment@2 {
-        target = <&dev1>;
-        __overlay__ {
-            overlay1-new-node {
-                overlay1-new-node-property = "overlay1-new-node-property-value";
-            };
-        };
-    };
-
-    // add a new node at the root level
-    fragment@3 {
-        target-path = "/";
-        __overlay__ {
-            // TODO(b/362486327): failed to refer dev4 in the following overlays
-            dev4: dev-4 {
-                overlay1-root-node-property = "overlay1-root-node-property-value";
-            };
-        };
-    };
-};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_wrong_path.dts b/gbl/libfdt/test/overlay_wrong_path.dts
deleted file mode 100644
index 7f1a4e7..0000000
--- a/gbl/libfdt/test/overlay_wrong_path.dts
+++ /dev/null
@@ -1,13 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
-/ {
-    // check wrong target-path
-    fragment@0 {
-        target-path = "/doesnt-exist";
-        __overlay__ {
-            property-1 = "overlay1-property-1-value";
-        };
-    };
-};
\ No newline at end of file
diff --git a/gbl/libgbl/BUILD b/gbl/libgbl/BUILD
deleted file mode 100644
index 8d68061..0000000
--- a/gbl/libgbl/BUILD
+++ /dev/null
@@ -1,85 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libgbl",
-    srcs = glob(
-        ["**/*.rs"],
-        exclude = ["tests/**/*.rs"],
-    ),
-    aliases = {"@itertools_noalloc": "itertools_noalloc"},
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-    deps = [
-        "@arrayvec",
-        "@avb",
-        "@avb//:avb_bindgen",
-        "@bitflags",
-        "@crc32fast",
-        "@gbl//libabr",
-        "@gbl//libasync",
-        "@gbl//libboot",
-        "@gbl//libbootimg",
-        "@gbl//libbootparams",
-        "@gbl//libdttable",
-        "@gbl//liberror",
-        "@gbl//libfastboot",
-        "@gbl//libfdt",
-        "@gbl//libmisc",
-        "@gbl//libsafemath",
-        "@gbl//libstorage",
-        "@gbl//libutils",
-        "@itertools_noalloc",
-        "@lz4_flex",
-        "@spin",
-        "@static_assertions",
-        "@uuid",
-        "@zbi",
-        "@zerocopy",
-        "@zune_inflate",
-    ],
-)
-
-rust_test(
-    name = "libgbl_test",
-    aliases = {"@itertools_noalloc": "itertools_noalloc"},
-    compile_data = [
-        "@gbl//libstorage/test:test_data",
-        "@gbl//libdttable/test/data:all",
-        "@gbl//libfdt/test/data:all",
-    ],
-    crate = ":libgbl",
-    crate_features = ["uuid"],
-    data = ["@gbl//libgbl/testdata"],
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@avb//:avb_crypto_ops_sha_impl_staticlib",
-        "@avb//:avb_test",
-        "@gbl//libasync:cyclic_executor",
-        "@gbl//libavb:sysdeps",
-        "@gbl//libc:libc_deps_posix",
-        "@itertools",
-        "@itertools_noalloc",
-        "@static_assertions",
-        "@uuid",
-    ],
-)
diff --git a/gbl/libgbl/Cargo.toml b/gbl/libgbl/Cargo.toml
deleted file mode 100644
index 12c938b..0000000
--- a/gbl/libgbl/Cargo.toml
+++ /dev/null
@@ -1,36 +0,0 @@
-# Copyright 2023, The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# For now this file is only provided so that `rustfmt` can run, but it may
-# be worthwhile to set it up properly as a reference implementation for building
-# with libgbl.
-
-[package]
-name = "gbl"
-version = "0.1.0"
-
-[features]
-default = []
-alloc = []
-
-[dependencies]
-gbl_storage = {version = "0.1", path = "../libstorage"}
-spin = "0.9"
-static_assertions = "0"
-lazy_static = "1"
-zerocopy = {version = "=0.8"}
-crc32fast = "1.3"
-
-[dev-dependencies]
-itertools = "0"
diff --git a/gbl/libgbl/src/android_boot/load.rs b/gbl/libgbl/src/android_boot/load.rs
deleted file mode 100644
index e4ddb21..0000000
--- a/gbl/libgbl/src/android_boot/load.rs
+++ /dev/null
@@ -1,1623 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use super::{avb_verify_slot, cstr_bytes_to_str};
-use crate::{
-    android_boot::PartitionsToVerify,
-    constants::{FDT_ALIGNMENT, KERNEL_ALIGNMENT, PAGE_SIZE},
-    decompress::decompress_kernel,
-    gbl_print, gbl_println,
-    ops::GblOps,
-    partition::RAW_PARTITION_NAME_LEN,
-    IntegrationError,
-};
-use arrayvec::ArrayString;
-use bootimg::{defs::*, BootImage, VendorImageHeader};
-use bootparams::bootconfig::BootConfigBuilder;
-use core::{
-    array,
-    ffi::CStr,
-    fmt::Write,
-    ops::{Deref, Range},
-};
-use liberror::Error;
-use libutils::aligned_subslice;
-use safemath::SafeNum;
-use zerocopy::{IntoBytes, Ref};
-
-const DEFAULT_BUILD_ID: &str = "eng.build";
-
-// Represents a slot suffix.
-struct SlotSuffix([u8; 3]);
-
-impl SlotSuffix {
-    // Creates a new instance.
-    fn new(slot: u8) -> Result<Self, Error> {
-        let suffix = u32::from(slot) + u32::from(b'a');
-        match char::from_u32(suffix).map(|v| v.is_ascii_lowercase()) {
-            Some(true) => Ok(Self([b'_', suffix.try_into().unwrap(), 0])),
-            _ => Err(Error::Other(Some("Invalid slot index"))),
-        }
-    }
-
-    // Casts as CStr.
-    fn as_cstr(&self) -> &CStr {
-        CStr::from_bytes_with_nul(&self.0[..]).unwrap()
-    }
-}
-
-impl Deref for SlotSuffix {
-    type Target = str;
-
-    fn deref(&self) -> &Self::Target {
-        self.as_cstr().to_str().unwrap()
-    }
-}
-
-/// Returns a slotted partition name.
-fn slotted_part(part: &str, slot: u8) -> Result<ArrayString<RAW_PARTITION_NAME_LEN>, Error> {
-    let mut res = ArrayString::new_const();
-    write!(res, "{}{}", part, &SlotSuffix::new(slot)? as &str).unwrap();
-    Ok(res)
-}
-
-// Helper for constructing a range that ends at a page aligned boundary. Specifically, it returns
-// `start..round_up(start + sz, page_size)`
-fn page_aligned_range(
-    start: impl Into<SafeNum>,
-    sz: impl Into<SafeNum>,
-    page_size: impl Into<SafeNum>,
-) -> Result<Range<usize>, Error> {
-    let start = start.into();
-    Ok(start.try_into()?..(start + sz.into()).round_up(page_size.into()).try_into()?)
-}
-
-/// Represents a loaded boot image of version 2 and lower.
-///
-/// TODO(b/384964561): Investigate if the APIs are better suited for bootimg.rs. The issue
-/// is that it uses `Error` and `SafeNum` from GBL.
-struct BootImageV2Info<'a> {
-    cmdline: &'a str,
-    page_size: usize,
-    kernel_range: Range<usize>,
-    ramdisk_range: Range<usize>,
-    dtb_range: Range<usize>,
-    // Actual dtb size without padding.
-    //
-    // We need to know the exact size because the fdt buffer will be passed to
-    // `DeviceTreeComponentsRegistry::append` which assumes that the buffer contains concatenated
-    // device trees and will try to parse for additional device trees if the preivous one doesn't
-    // consume all buffer.
-    dtb_sz: usize,
-    image_size: usize,
-}
-
-impl<'a> BootImageV2Info<'a> {
-    /// Creates a new instance.
-    fn new(buffer: &'a [u8]) -> Result<Self, Error> {
-        let header = BootImage::parse(buffer)?;
-        if matches!(header, BootImage::V3(_) | BootImage::V4(_)) {
-            return Err(Error::InvalidInput);
-        }
-        // This is valid since v1/v2 are superset of v0.
-        let v0 = Ref::into_ref(Ref::<_, boot_img_hdr_v0>::from_prefix(&buffer[..]).unwrap().0);
-        let page_size: usize = v0.page_size.try_into()?;
-        let cmdline = cstr_bytes_to_str(&v0.cmdline[..])?;
-        let kernel_range = page_aligned_range(page_size, v0.kernel_size, page_size)?;
-        let ramdisk_range = page_aligned_range(kernel_range.end, v0.ramdisk_size, page_size)?;
-        let second_range = page_aligned_range(ramdisk_range.end, v0.second_size, page_size)?;
-
-        let start = u64::try_from(second_range.end)?;
-        let (off, sz) = match header {
-            BootImage::V1(v) => (v.recovery_dtbo_offset, v.recovery_dtbo_size),
-            BootImage::V2(v) => (v._base.recovery_dtbo_offset, v._base.recovery_dtbo_size),
-            _ => (start, 0),
-        };
-        let recovery_dtb_range = match off >= start {
-            true => page_aligned_range(off, sz, page_size)?,
-            _ if off == 0 => page_aligned_range(start, 0, page_size)?,
-            _ => return Err(Error::Other(Some("Unexpected recovery_dtbo_offset"))),
-        };
-        let dtb_sz: usize = match header {
-            BootImage::V2(v) => v.dtb_size.try_into().unwrap(),
-            _ => 0,
-        };
-        let dtb_range = page_aligned_range(recovery_dtb_range.end, dtb_sz, page_size)?;
-        let image_size = dtb_range.end;
-        Ok(Self { cmdline, page_size, kernel_range, ramdisk_range, dtb_range, dtb_sz, image_size })
-    }
-}
-
-// Contains information of a V3/V4 boot image.
-struct BootImageV3Info {
-    kernel_range: Range<usize>,
-    ramdisk_range: Range<usize>,
-    image_size: usize,
-}
-
-impl BootImageV3Info {
-    /// Creates a new instance.
-    fn new(buffer: &[u8]) -> Result<Self, Error> {
-        let header = BootImage::parse(buffer)?;
-        if !matches!(header, BootImage::V3(_) | BootImage::V4(_)) {
-            return Err(Error::InvalidInput);
-        }
-        let v3 = Self::v3(buffer);
-        let kernel_range = page_aligned_range(PAGE_SIZE, v3.kernel_size, PAGE_SIZE)?;
-        let ramdisk_range = page_aligned_range(kernel_range.end, v3.ramdisk_size, PAGE_SIZE)?;
-        let sz = match header {
-            BootImage::V4(v) => v.signature_size,
-            _ => 0,
-        };
-        let signature_range = page_aligned_range(ramdisk_range.end, sz, PAGE_SIZE)?;
-        let image_size = signature_range.end;
-
-        Ok(Self { kernel_range, ramdisk_range, image_size })
-    }
-
-    /// Gets the v3 base header.
-    fn v3(buffer: &[u8]) -> &boot_img_hdr_v3 {
-        // This is valid since v4 is superset of v3.
-        Ref::into_ref(Ref::from_prefix(&buffer[..]).unwrap().0)
-    }
-
-    // Decodes the kernel cmdline
-    fn cmdline(buffer: &[u8]) -> Result<&str, Error> {
-        cstr_bytes_to_str(&Self::v3(buffer).cmdline[..])
-    }
-}
-
-/// Contains vendor boot image information.
-struct VendorBootImageInfo {
-    header_size: usize,
-    ramdisk_range: Range<usize>,
-    dtb_range: Range<usize>,
-    // Actual dtb size without padding.
-    //
-    // We need to know the exact size because the fdt buffer will be passed to
-    // `DeviceTreeComponentsRegistry::append` which assumes that the buffer contains concatenated
-    // device trees and will try to parse for additional device trees if the preivous one doesn't
-    // consume all buffer.
-    dtb_sz: usize,
-    bootconfig_range: Range<usize>,
-    image_size: usize,
-}
-
-impl VendorBootImageInfo {
-    /// Creates a new instance.
-    fn new(buffer: &[u8]) -> Result<Self, Error> {
-        let header = VendorImageHeader::parse(buffer)?;
-        let v3 = Self::v3(buffer);
-        let page_size = v3.page_size;
-        let header_size = match header {
-            VendorImageHeader::V3(hdr) => SafeNum::from(hdr.as_bytes().len()),
-            VendorImageHeader::V4(hdr) => SafeNum::from(hdr.as_bytes().len()),
-        }
-        .round_up(page_size)
-        .try_into()?;
-        let ramdisk_range = page_aligned_range(header_size, v3.vendor_ramdisk_size, page_size)?;
-        let dtb_sz: usize = v3.dtb_size.try_into().unwrap();
-        let dtb_range = page_aligned_range(ramdisk_range.end, dtb_sz, page_size)?;
-
-        let (table_sz, bootconfig_sz) = match header {
-            VendorImageHeader::V4(hdr) => (hdr.vendor_ramdisk_table_size, hdr.bootconfig_size),
-            _ => (0, 0),
-        };
-        let table = page_aligned_range(dtb_range.end, table_sz, page_size)?;
-        let bootconfig_range = table.end..(table.end + usize::try_from(bootconfig_sz)?);
-        let image_size = SafeNum::from(bootconfig_range.end).round_up(page_size).try_into()?;
-        Ok(Self { header_size, ramdisk_range, dtb_range, dtb_sz, bootconfig_range, image_size })
-    }
-
-    /// Gets the v3 base header.
-    fn v3(buffer: &[u8]) -> &vendor_boot_img_hdr_v3 {
-        Ref::into_ref(Ref::<_, _>::from_prefix(&buffer[..]).unwrap().0)
-    }
-
-    // Decodes the vendor cmdline
-    fn cmdline(buffer: &[u8]) -> Result<&str, Error> {
-        cstr_bytes_to_str(&Self::v3(buffer).cmdline[..])
-    }
-}
-
-/// Contains various loaded image components by `android_load_verify`
-pub struct LoadedImages<'a> {
-    /// dtbo image.
-    pub dtbo: &'a mut [u8],
-    /// Kernel commandline.
-    pub boot_cmdline: &'a str,
-    /// Vendor commandline,
-    pub vendor_cmdline: &'a str,
-    /// DTB.
-    pub dtb: &'a mut [u8],
-    /// DTB from partition.
-    pub dtb_part: &'a mut [u8],
-    /// Kernel image.
-    pub kernel: &'a mut [u8],
-    /// Ramdisk image.
-    pub ramdisk: &'a mut [u8],
-    /// Unused portion. Can be used by the caller to construct FDT.
-    pub unused: &'a mut [u8],
-}
-
-impl<'a> Default for LoadedImages<'a> {
-    fn default() -> LoadedImages<'a> {
-        LoadedImages {
-            dtbo: &mut [][..],
-            boot_cmdline: "",
-            vendor_cmdline: "",
-            dtb: &mut [][..],
-            dtb_part: &mut [][..],
-            kernel: &mut [][..],
-            ramdisk: &mut [][..],
-            unused: &mut [][..],
-        }
-    }
-}
-
-/// Loads and verifies Android images of the given slot.
-pub fn android_load_verify<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    slot: u8,
-    is_recovery: bool,
-    load: &'c mut [u8],
-) -> Result<LoadedImages<'c>, IntegrationError> {
-    let mut res = LoadedImages::default();
-
-    let slot_suffix = SlotSuffix::new(slot)?;
-    // Additional partitions loaded before loading standard boot images.
-    let mut partitions = PartitionsToVerify::default();
-
-    // Loads dtbo.
-    let dtbo_part = slotted_part("dtbo", slot)?;
-    let (dtbo, remains) = load_entire_part(ops, &dtbo_part, &mut load[..])?;
-    if dtbo.len() > 0 {
-        partitions.try_push_preloaded(c"dtbo", &dtbo[..])?;
-    }
-
-    // Loads dtb.
-    let remains = aligned_subslice(remains, FDT_ALIGNMENT)?;
-    let dtb_part = slotted_part("dtb", slot)?;
-    let (dtb, remains) = load_entire_part(ops, &dtb_part, &mut remains[..])?;
-    if dtb.len() > 0 {
-        partitions.try_push_preloaded(c"dtb", &dtb[..])?;
-    }
-
-    let add = |v: &mut BootConfigBuilder| {
-        if !is_recovery {
-            v.add("androidboot.force_normal_boot=1\n")?;
-        }
-        write!(v, "androidboot.slot_suffix={}\n", &slot_suffix as &str)?;
-
-        // Placeholder value for now. Userspace can use this value to tell if device is booted with GBL.
-        // TODO(yochiang): Generate useful value like version, build_incremental in the bootconfig.
-        v.add("androidboot.gbl.version=0\n")?;
-
-        let build_number = match option_env!("BUILD_NUMBER") {
-            None | Some("") => DEFAULT_BUILD_ID,
-            Some(build_number) => build_number,
-        };
-        write!(v, "androidboot.gbl.build_number={}\n", build_number)?;
-        Ok(())
-    };
-
-    // Loads boot image header and inspect version
-    ops.read_from_partition_sync(&slotted_part("boot", slot)?, 0, &mut remains[..PAGE_SIZE])?;
-    match BootImage::parse(&remains[..]).map_err(Error::from)? {
-        BootImage::V3(_) | BootImage::V4(_) => {
-            load_verify_v3_and_v4(ops, slot, &partitions, add, &mut res, remains)?
-        }
-        _ => load_verify_v2_and_lower(ops, slot, &partitions, add, &mut res, remains)?,
-    };
-
-    drop(partitions);
-    res.dtbo = dtbo;
-    res.dtb_part = dtb;
-    Ok(res)
-}
-
-/// Loads and verifies android boot images of version 0, 1 and 2.
-///
-/// * Both kernel and ramdisk come from the boot image.
-/// * vendor_boot, init_boot are irrelevant.
-///
-/// # Args
-///
-/// * `ops`: An implementation of [GblOps].
-/// * `slot`: slot index.
-/// * `additional_partitions`: Additional partitions for verification.
-/// * `out`: A `&mut LoadedImages` for output.
-/// * `load`: The load buffer. The boot header must be preloaded into this buffer.
-fn load_verify_v2_and_lower<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    slot: u8,
-    additional_partitions: &PartitionsToVerify,
-    add_additional_bootconfig: impl FnOnce(&mut BootConfigBuilder) -> Result<(), Error>,
-    out: &mut LoadedImages<'c>,
-    load: &'c mut [u8],
-) -> Result<(), IntegrationError> {
-    gbl_println!(ops, "Android loading v2 or lower");
-    // Loads boot image.
-    let boot_size = BootImageV2Info::new(load).unwrap().image_size;
-    let boot_part = slotted_part("boot", slot)?;
-    let (boot, remains) = split(load, boot_size)?;
-    ops.read_from_partition_sync(&boot_part, 0, boot)?;
-
-    // Performs libavb verification.
-
-    // Prepares a BootConfigBuilder to add avb generated bootconfig.
-    let mut bootconfig_builder = BootConfigBuilder::new(remains)?;
-    // Puts in a subscope for auto dropping `to_verify`, so that the slices it
-    // borrows can be released.
-    {
-        let mut to_verify = PartitionsToVerify::default();
-        to_verify.try_push_preloaded(c"boot", &boot[..])?;
-        to_verify.try_extend_preloaded(additional_partitions)?;
-        avb_verify_slot(ops, slot, &to_verify, &mut bootconfig_builder)?;
-    }
-
-    add_additional_bootconfig(&mut bootconfig_builder)?;
-    // Adds platform-specific bootconfig.
-    bootconfig_builder.add_with(|bytes, out| {
-        Ok(ops.fixup_bootconfig(&bytes, out)?.map(|slice| slice.len()).unwrap_or(0))
-    })?;
-    let bootconfig_size = bootconfig_builder.config_bytes().len();
-
-    // We now have the following layout:
-    //
-    // | boot_hdr | kernel | ramdisk | second | recovery_dtb | dtb | bootconfig | remains |
-    // |------------------------------`boot_ex`---------------------------------|
-    //
-    // We need to:
-    // 1. move bootconfig to after ramdisk.
-    // 2. relocate the kernel to the tail so that all memory after it can be used as scratch memory.
-    //    It is observed that riscv kernel reaches into those memory and overwrites data.
-    //
-    // TODO(b/384964561): Investigate if `second`, `recovery_dtb` needs to be kept.
-    let (boot_ex, remains) = load.split_at_mut(boot_size + bootconfig_size);
-    let boot_img = BootImageV2Info::new(boot_ex).unwrap();
-    let page_size = boot_img.page_size;
-    let dtb_sz = boot_img.dtb_sz;
-    // Relocates kernel to tail.
-    let kernel_range = boot_img.kernel_range;
-    let kernel = boot_ex.get(kernel_range.clone()).unwrap();
-    let (remains, _, kernel_sz) = relocate_kernel(ops, kernel, remains)?;
-    // Relocates dtb to tail.
-    let dtb_range = boot_img.dtb_range;
-    let (_, dtb) = split_aligned_tail(remains, dtb_range.len(), FDT_ALIGNMENT)?;
-    dtb[..dtb_range.len()].clone_from_slice(boot_ex.get(dtb_range).unwrap());
-    // Move ramdisk forward and bootconfig following it.
-    let ramdisk_range = boot_img.ramdisk_range;
-    boot_ex.copy_within(ramdisk_range.start..ramdisk_range.end, kernel_range.start);
-    boot_ex.copy_within(boot_size.., kernel_range.start + ramdisk_range.len());
-
-    // We now have the following layout:
-    // | boot_hdr | ramdisk + bootconfig | unused | dtb | kernel |
-    let ramdisk_sz = ramdisk_range.len() + bootconfig_size;
-    let unused_sz = slice_offset(dtb, boot_ex) - page_size - ramdisk_sz;
-    let dtb_padding = dtb.len() - dtb_sz;
-    let hdr;
-    ([hdr, out.ramdisk, out.unused, out.dtb, _, out.kernel], _) =
-        split_chunks(load, &[page_size, ramdisk_sz, unused_sz, dtb_sz, dtb_padding, kernel_sz]);
-    out.boot_cmdline = BootImageV2Info::new(hdr).unwrap().cmdline;
-    Ok(())
-}
-
-/// Loads and verifies android boot images of version 3 and 4.
-///
-/// V3, V4 images have the following characteristics:
-///
-/// * Kernel comes from "boot_a/b" partition.
-/// * Generic ramdisk may come from either "boot_a/b" or "init_boot_a/b" partitions.
-/// * Vendor ramdisk comes from "vendor_boot_a/b" partition.
-/// * V4 vendor_boot contains additional bootconfig.
-///
-/// From the perspective of Android versions:
-///
-/// Android 11:
-///
-/// * Can use v3 header.
-/// * Generic ramdisk is in the "boot_a/b" partitions.
-///
-/// Android 12:
-///
-/// * Can use v3 or v4 header.
-/// * Generic ramdisk is in the "boot_a/b" partitions.
-///
-/// Android 13:
-///
-/// * Can use v3 or v4 header.
-/// * Generic ramdisk is in the "init_boot_a/b" partitions.
-///
-/// # References
-///
-/// https://source.android.com/docs/core/architecture/bootloader/boot-image-header
-/// https://source.android.com/docs/core/architecture/partitions/vendor-boot-partitions
-/// https://source.android.com/docs/core/architecture/partitions/generic-boot
-///
-/// # Args
-///
-/// * `ops`: An implementation of [GblOps].
-/// * `slot`: slot index.
-/// * `additional_partitions`: Additional partitions for verification.
-/// * `out`: A `&mut LoadedImages` for output.
-/// * `load`: The load buffer. The boot header must be preloaded into this buffer.
-fn load_verify_v3_and_v4<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    slot: u8,
-    additional_partitions: &PartitionsToVerify,
-    add_additional_bootconfig: impl FnOnce(&mut BootConfigBuilder) -> Result<(), Error>,
-    out: &mut LoadedImages<'c>,
-    load: &'c mut [u8],
-) -> Result<(), IntegrationError> {
-    gbl_println!(ops, "Android loading v3 or higher");
-    // Creates a `start` marker for `slice_offset()` to compute absolute slice offset later.
-    let (start, load) = load.split_at_mut(0);
-
-    let boot_part = slotted_part("boot", slot)?;
-    let vendor_boot_part = slotted_part("vendor_boot", slot)?;
-    let init_boot_part = slotted_part("init_boot", slot)?;
-
-    let boot_img_info = BootImageV3Info::new(load).unwrap();
-
-    // Loads vendor boot image.
-    ops.read_from_partition_sync(&vendor_boot_part, 0, &mut load[..PAGE_SIZE])?;
-    let vendor_boot_info = VendorBootImageInfo::new(&load[..PAGE_SIZE])?;
-    let (vendor_boot, remains) = split(&mut load[..], vendor_boot_info.image_size)?;
-    ops.read_from_partition_sync(&vendor_boot_part, 0, vendor_boot)?;
-
-    // Loads boot image.
-    let (boot, remains) = split(remains, boot_img_info.image_size)?;
-    ops.read_from_partition_sync(&boot_part, 0, boot)?;
-
-    // Loads init_boot image if boot doesn't contain a ramdisk.
-    let (init_boot, remains, init_boot_info) = match boot_img_info.ramdisk_range.len() > 0 {
-        false => {
-            ops.read_from_partition_sync(&init_boot_part, 0, &mut remains[..PAGE_SIZE])?;
-            let init_boot_info = BootImageV3Info::new(&remains[..])?;
-            let (out, remains) = split(remains, init_boot_info.image_size)?;
-            ops.read_from_partition_sync(&init_boot_part, 0, out)?;
-            (out, remains, Some(init_boot_info))
-        }
-        _ => (&mut [][..], remains, None),
-    };
-
-    // Performs libavb verification.
-
-    // Prepares a BootConfigBuilder to add avb generated bootconfig.
-    let mut bootconfig_builder = BootConfigBuilder::new(remains)?;
-    // Puts in a subscope for auto dropping `to_verify`, so that the slices it
-    // borrows can be released.
-    {
-        let mut to_verify = PartitionsToVerify::default();
-        to_verify.try_push_preloaded(c"boot", &boot)?;
-        to_verify.try_push_preloaded(c"vendor_boot", &vendor_boot)?;
-        if init_boot.len() > 0 {
-            to_verify.try_push_preloaded(c"init_boot", &init_boot)?;
-        }
-        to_verify.try_extend_preloaded(additional_partitions)?;
-        avb_verify_slot(ops, slot, &to_verify, &mut bootconfig_builder)?;
-    }
-
-    add_additional_bootconfig(&mut bootconfig_builder)?;
-    // Adds platform-specific bootconfig.
-    bootconfig_builder.add_with(|bytes, out| {
-        Ok(ops.fixup_bootconfig(&bytes, out)?.map(|slice| slice.len()).unwrap_or(0))
-    })?;
-
-    // We now have the following layout:
-    //
-    // +------------------------+
-    // | vendor boot header     |
-    // +------------------------+
-    // | vendor ramdisk         |
-    // +------------------------+
-    // | dtb                    |
-    // +------------------------+
-    // | vendor ramdisk table   |
-    // +------------------------+
-    // | vendor bootconfig      |
-    // +------------------------+    +------------------------+
-    // | boot hdr               |    | boot hdr               |
-    // +------------------------+    +------------------------+
-    // | kernel                 |    | kernel                 |
-    // +------------------------+    +------------------------+
-    // |                        |    | boot signature         |
-    // |                        | or +------------------------+
-    // | generic ramdisk        |    | init_boot hdr          |
-    // |                        |    +------------------------+
-    // |                        |    | generic ramdisk        |
-    // +------------------------+    +------------------------+
-    // | boot signature         |    | boot signature         |
-    // +------------------------+    +------------------------+
-    // | avb + board bootconfig |
-    // +------------------------+
-    // | unused                 |
-    // +------------------------+
-    //
-    // We need to:
-    // * Relocate kernel to the tail of the load buffer to reserve all memory after it for scratch.
-    // * Relocates dtb, boot hdr to elsewhere.
-    // * Move generic ramdisk to follow vendor ramdisk.
-    // * Move vendor bootconfig, avb + board bootconfig to follow generic ramdisk.
-
-    // Appends vendor bootconfig so that the section can be discarded.
-    let vendor_bootconfig = vendor_boot.get(vendor_boot_info.bootconfig_range).unwrap();
-    bootconfig_builder.add_with(|_, out| {
-        out.get_mut(..vendor_bootconfig.len())
-            .ok_or(Error::BufferTooSmall(Some(vendor_bootconfig.len())))?
-            .clone_from_slice(vendor_bootconfig);
-        Ok(vendor_bootconfig.len())
-    })?;
-    let bootconfig_size = bootconfig_builder.config_bytes().len();
-    let (bootconfig, remains) = remains.split_at_mut(bootconfig_size);
-
-    // Relocates kernel to tail.
-    let kernel = boot.get(boot_img_info.kernel_range.clone()).unwrap();
-    let (remains, kernel, kernel_sz) = relocate_kernel(ops, kernel, remains)?;
-    let kernel_buf_len = kernel.len();
-
-    // Relocates boot header to tail.
-    let (remains, boot_hdr) = split_aligned_tail(remains, PAGE_SIZE, 1)?;
-    boot_hdr.clone_from_slice(&boot[..PAGE_SIZE]);
-    let boot_hdr_sz = boot_hdr.len();
-
-    // Relocates dtb to tail.
-    let dtb = vendor_boot.get(vendor_boot_info.dtb_range).unwrap();
-    let (_, dtb_reloc) = split_aligned_tail(remains, dtb.len(), FDT_ALIGNMENT)?;
-    dtb_reloc[..dtb.len()].clone_from_slice(dtb);
-    let dtb_sz = vendor_boot_info.dtb_sz;
-    let dtb_pad = dtb_reloc.len() - dtb_sz;
-
-    // Moves generic ramdisk and bootconfig forward
-    let generic_ramdisk_range = match init_boot_info {
-        Some(v) => offset_range(v.ramdisk_range, slice_offset(init_boot, start)),
-        _ => offset_range(boot_img_info.ramdisk_range, slice_offset(boot, start)),
-    };
-    let vendor_ramdisk_range = vendor_boot_info.ramdisk_range;
-    let bootconfig_range = offset_range(0..bootconfig_size, slice_offset(bootconfig, start));
-    load.copy_within(generic_ramdisk_range.clone(), vendor_ramdisk_range.end);
-    load.copy_within(bootconfig_range, vendor_ramdisk_range.end + generic_ramdisk_range.len());
-    let ramdisk_sz = vendor_ramdisk_range.len() + generic_ramdisk_range.len() + bootconfig_size;
-
-    // We now have the following layout:
-    //
-    // +------------------------+
-    // | vendor boot header     |
-    // +------------------------+
-    // | vendor ramdisk         |
-    // +------------------------+
-    // | generic ramdisk        |
-    // +------------------------+
-    // | vendor bootconfig      |
-    // +------------------------+
-    // | avb + board bootconfig |
-    // +------------------------+
-    // | unused                 |
-    // +------------------------+
-    // | dtb                    |
-    // +------------------------+
-    // | boot hdr               |
-    // +------------------------+
-    // | kernel                 |
-    // +------------------------+
-    //
-    // Splits out the images and returns.
-    let vendor_hdr_sz = vendor_boot_info.header_size;
-    let unused_sz =
-        load.len() - vendor_hdr_sz - ramdisk_sz - boot_hdr_sz - dtb_sz - dtb_pad - kernel_buf_len;
-    let (vendor_hdr, boot_hdr);
-    ([vendor_hdr, out.ramdisk, out.unused, out.dtb, _, boot_hdr, out.kernel], _) = split_chunks(
-        load,
-        &[vendor_hdr_sz, ramdisk_sz, unused_sz, dtb_sz, dtb_pad, boot_hdr_sz, kernel_sz],
-    );
-    out.boot_cmdline = BootImageV3Info::cmdline(boot_hdr)?;
-    out.vendor_cmdline = VendorBootImageInfo::cmdline(vendor_hdr)?;
-    Ok(())
-}
-
-// A helper for calculating the relative offset of `buf` to `src`.
-fn slice_offset(buf: &[u8], src: &[u8]) -> usize {
-    (buf.as_ptr() as usize).checked_sub(src.as_ptr() as usize).unwrap()
-}
-
-/// Wrapper of `split_at_mut_checked` with error conversion.
-fn split(buffer: &mut [u8], size: usize) -> Result<(&mut [u8], &mut [u8]), Error> {
-    buffer.split_at_mut_checked(size).ok_or(Error::BufferTooSmall(Some(size)))
-}
-
-/// Calculates the offset from the start of the buffer to obtain an aligned tail
-/// that can fit at least `size` bytes with the given alignment.
-///
-/// Returns the starting offset of the aligned tail slice.
-fn aligned_tail_offset(buffer: &[u8], size: usize, align: usize) -> Result<usize, Error> {
-    let off = SafeNum::from(buffer.len()) - size;
-    let rem = buffer[off.try_into()?..].as_ptr() as usize % align;
-    Ok(usize::try_from(off - rem)?)
-}
-
-/// Split buffer from the tail with the given alignment such that the buffer is at least `size`
-/// bytes.
-fn split_aligned_tail(
-    buffer: &mut [u8],
-    size: usize,
-    align: usize,
-) -> Result<(&mut [u8], &mut [u8]), Error> {
-    split(buffer, aligned_tail_offset(buffer, size, align)?)
-}
-
-/// Splits a buffer into multiple chunks of the given sizes.
-///
-/// Returns an array of slices corresponding to the given sizes and the remaining slice.
-pub(super) fn split_chunks<'a, const N: usize>(
-    buf: &'a mut [u8],
-    sizes: &[usize; N],
-) -> ([&'a mut [u8]; N], &'a mut [u8]) {
-    let mut chunks: [_; N] = array::from_fn(|_| &mut [][..]);
-    let mut remains = buf;
-    for (i, ele) in sizes.iter().enumerate() {
-        (chunks[i], remains) = remains.split_at_mut(*ele);
-    }
-    (chunks, remains)
-}
-
-/// Helper for loading entire partition.
-///
-/// * Returns the loaded slice and the remaining slice.
-/// * If the partition doesn't exist, an empty loaded slice is returned.
-fn load_entire_part<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    part: &str,
-    load: &'c mut [u8],
-) -> Result<(&'c mut [u8], &'c mut [u8]), Error> {
-    match ops.partition_size(&part)? {
-        Some(sz) => {
-            let sz = sz.try_into()?;
-            gbl_println!(ops, "Found {} partition.", &part);
-            let (out, remains) = split(load, sz)?;
-            ops.read_from_partition_sync(&part, 0, out)?;
-            Ok((out, remains))
-        }
-        _ => {
-            gbl_println!(ops, "Partition {} doesn't exist. Skip loading.", &part);
-            Ok((&mut [][..], &mut load[..]))
-        }
-    }
-}
-
-/// A helper function for relocating and decompressing kernel to a different buffer.
-///
-/// The relocated kernel will be place at the tail.
-///
-/// Returns the leading unused slice, the relocated slice and the actual kernel size without
-/// alignment padding.
-fn relocate_kernel<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    kernel: &[u8],
-    dst: &'c mut [u8],
-) -> Result<(&'c mut [u8], &'c mut [u8], usize), Error> {
-    let decompressed_size = decompress_kernel(ops, kernel, dst)?;
-    let aligned_tail_off = aligned_tail_offset(dst, decompressed_size, KERNEL_ALIGNMENT)?;
-    dst.copy_within(0..decompressed_size, aligned_tail_off);
-    let (prefix, tail) = split(dst, aligned_tail_off)?;
-    Ok((prefix, tail, decompressed_size))
-}
-
-// Adds offset to a given range i.e. [start+off, end+off)
-fn offset_range(lhs: Range<usize>, off: usize) -> Range<usize> {
-    lhs.start.checked_add(off).unwrap()..lhs.end.checked_add(off).unwrap()
-}
-
-#[cfg(test)]
-pub(crate) mod tests {
-    use super::*;
-    use crate::{
-        gbl_avb::state::{BootStateColor, KeyValidationStatus},
-        ops::test::{FakeGblOps, FakeGblOpsStorage},
-        tests::AlignedBuffer,
-    };
-    use bootparams::bootconfig::BOOTCONFIG_TRAILER_SIZE;
-    use std::{
-        ascii::escape_default, collections::HashMap, ffi::CString, fmt, fs, path::Path,
-        string::String,
-    };
-
-    /// Export DEFAULT_BUILD_ID for other test modules.
-    pub const TEST_DEFAULT_BUILD_ID: &str = DEFAULT_BUILD_ID;
-
-    // See libgbl/testdata/gen_test_data.py for test data generation.
-    const TEST_ROLLBACK_INDEX_LOCATION: usize = 1;
-
-    // The commandline in the generated vendor boot image.
-    // See libgbl/testdata/gen_test_data.py for test data generation.
-    const TEST_VENDOR_CMDLINE: &str =
-        "cmd_vendor_key_1=cmd_vendor_val_1,cmd_vendor_key_2=cmd_vendor_val_2";
-    // The vendor bootconfig in the generated vendor boot image.
-    // See libgbl/testdata/gen_test_data.py for test data generation.
-    pub(crate) const TEST_VENDOR_BOOTCONFIG: &str =
-        "androidboot.config_1=val_1\x0aandroidboot.config_2=val_2\x0a";
-
-    /// Digest of public key used to execute AVB.
-    pub(crate) const TEST_PUBLIC_KEY_DIGEST: &str =
-        "7ec02ee1be696366f3fa91240a8ec68125c4145d698f597aa2b3464b59ca7fc3";
-
-    // Test data path
-    const TEST_DATA_PATH: &str = "external/gbl/libgbl/testdata/android";
-
-    /// Reads a data file under libgbl/testdata/
-    pub(crate) fn read_test_data(file: impl AsRef<str>) -> Vec<u8> {
-        println!("reading file: {}", file.as_ref());
-        fs::read(Path::new(format!("{TEST_DATA_PATH}/{}", file.as_ref()).as_str())).unwrap()
-    }
-
-    /// Reads a data file as string under libgbl/testdata/
-    pub(crate) fn read_test_data_as_str(file: impl AsRef<str>) -> String {
-        fs::read_to_string(Path::new(format!("{TEST_DATA_PATH}/{}", file.as_ref()).as_str()))
-            .unwrap()
-    }
-
-    // Returns the test dtb
-    fn test_dtb() -> Vec<u8> {
-        read_test_data("device_tree.dtb")
-    }
-
-    /// Generates a readable string for a bootconfig bytes.
-    pub(crate) fn dump_bootconfig(data: &[u8]) -> String {
-        let s = data.iter().map(|v| escape_default(*v).to_string()).collect::<Vec<_>>().concat();
-        let s = s.split("\\\\").collect::<Vec<_>>().join("\\");
-        s.split("\\n").collect::<Vec<_>>().join("\n")
-    }
-
-    /// A helper for assert checking ramdisk binary and bootconfig separately.
-    pub(crate) fn check_ramdisk(ramdisk: &[u8], expected_bin: &[u8], expected_bootconfig: &[u8]) {
-        let (ramdisk, bootconfig) = ramdisk.split_at(expected_bin.len());
-        assert_eq!(ramdisk, expected_bin);
-        assert_eq!(
-            bootconfig,
-            expected_bootconfig,
-            "\nexpect: \n{}\nactual: \n{}\n",
-            dump_bootconfig(expected_bootconfig),
-            dump_bootconfig(bootconfig),
-        );
-    }
-
-    /// Helper for testing load/verify and assert verfiication success.
-    fn test_android_load_verify_success(
-        slot: u8,
-        partitions: &[(CString, String)],
-        expected_kernel: &[u8],
-        expected_ramdisk: &[u8],
-        expected_bootconfig: &[u8],
-        expected_dtb: &[u8],
-        expected_dtbo: &[u8],
-        expected_vendor_cmdline: &str,
-    ) {
-        let mut storage = FakeGblOpsStorage::default();
-        for (part, file) in partitions {
-            storage.add_raw_device(part, read_test_data(file));
-        }
-        let mut ops = FakeGblOps::new(&storage);
-        ops.avb_ops.unlock_state = Ok(false);
-        ops.avb_ops.rollbacks = HashMap::from([(TEST_ROLLBACK_INDEX_LOCATION, Ok(0))]);
-        let mut load_buffer = AlignedBuffer::new(64 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let mut out_color = None;
-        let mut handler = |color,
-                           _: Option<&CStr>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>| {
-            out_color = Some(color);
-            Ok(())
-        };
-        ops.avb_handle_verification_result = Some(&mut handler);
-        ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Valid));
-        let loaded = android_load_verify(&mut ops, slot, false, &mut load_buffer).unwrap();
-
-        assert_eq!(loaded.dtb, expected_dtb);
-        assert_eq!(out_color, Some(BootStateColor::Green));
-        assert_eq!(loaded.boot_cmdline, "cmd_key_1=cmd_val_1,cmd_key_2=cmd_val_2");
-        assert_eq!(loaded.vendor_cmdline, expected_vendor_cmdline);
-        assert_eq!(loaded.kernel, expected_kernel);
-        assert_eq!(loaded.kernel.as_ptr() as usize % KERNEL_ALIGNMENT, 0);
-        assert_eq!(loaded.dtbo, expected_dtbo);
-        check_ramdisk(loaded.ramdisk, expected_ramdisk, expected_bootconfig);
-    }
-
-    /// A helper for generating avb bootconfig with the given parameters.
-    pub(crate) struct AvbResultBootconfigBuilder {
-        vbmeta_size: usize,
-        digest: String,
-        boot_digest: Option<String>,
-        init_boot_digest: Option<String>,
-        dtb_digest: Option<String>,
-        dtbo_digest: Option<String>,
-        vendor_boot_digest: Option<String>,
-        public_key_digest: String,
-        color: BootStateColor,
-        unlocked: bool,
-        extra: String,
-    }
-
-    impl AvbResultBootconfigBuilder {
-        pub(crate) fn new() -> Self {
-            Self {
-                vbmeta_size: 0,
-                digest: String::new(),
-                boot_digest: None,
-                init_boot_digest: None,
-                dtb_digest: None,
-                dtbo_digest: None,
-                vendor_boot_digest: None,
-                public_key_digest: String::new(),
-                color: BootStateColor::Green,
-                unlocked: false,
-                extra: String::new(),
-            }
-        }
-
-        pub(crate) fn vbmeta_size(mut self, size: usize) -> Self {
-            self.vbmeta_size = size;
-            self
-        }
-
-        pub(crate) fn digest(mut self, digest: impl Into<String>) -> Self {
-            self.digest = digest.into();
-            self
-        }
-
-        pub(crate) fn partition_digest(mut self, name: &str, digest: impl Into<String>) -> Self {
-            let digest = Some(digest.into());
-            match name {
-                "boot" => self.boot_digest = digest,
-                "init_boot" => self.init_boot_digest = digest,
-                "vendor_boot" => self.vendor_boot_digest = digest,
-                "dtb" => self.dtb_digest = digest,
-                "dtbo" => self.dtbo_digest = digest,
-                _ => panic!("unknown digest name requested"),
-            };
-            self
-        }
-
-        pub(crate) fn public_key_digest(mut self, pk_digest: impl Into<String>) -> Self {
-            self.public_key_digest = pk_digest.into();
-            self
-        }
-
-        pub(crate) fn color(mut self, color: BootStateColor) -> Self {
-            self.color = color;
-            self
-        }
-
-        pub(crate) fn unlocked(mut self, unlocked: bool) -> Self {
-            self.unlocked = unlocked;
-            self
-        }
-
-        pub(crate) fn extra(mut self, extra: impl Into<String>) -> Self {
-            self.extra += &extra.into();
-            self
-        }
-
-        pub(crate) fn build_string(self) -> String {
-            let device_state = match self.unlocked {
-                true => "unlocked",
-                false => "locked",
-            };
-
-            let mut boot_digests = String::new();
-            for (name, maybe_digest) in [
-                ("boot", &self.boot_digest),
-                ("dtb", &self.dtb_digest),
-                ("dtbo", &self.dtbo_digest),
-                ("init_boot", &self.init_boot_digest),
-                ("vendor_boot", &self.vendor_boot_digest),
-            ] {
-                if let Some(digest) = maybe_digest {
-                    boot_digests += format!(
-                        "androidboot.vbmeta.{name}.hash_alg=sha256
-androidboot.vbmeta.{name}.digest={digest}\n"
-                    )
-                    .as_str()
-                }
-            }
-
-            format!(
-                "androidboot.vbmeta.device=PARTUUID=00000000-0000-0000-0000-000000000000
-androidboot.vbmeta.public_key_digest={}
-androidboot.vbmeta.avb_version=1.3
-androidboot.vbmeta.device_state={}
-androidboot.vbmeta.hash_alg=sha512
-androidboot.vbmeta.size={}
-androidboot.vbmeta.digest={}
-androidboot.vbmeta.invalidate_on_error=yes
-androidboot.veritymode=enforcing
-{}androidboot.verifiedbootstate={}
-{}",
-                self.public_key_digest,
-                device_state,
-                self.vbmeta_size,
-                self.digest,
-                boot_digests.as_str(),
-                self.color,
-                self.extra
-            )
-        }
-
-        pub(crate) fn build(self) -> Vec<u8> {
-            make_bootconfig(self.build_string())
-        }
-    }
-
-    // A helper for generating expected bootconfig.
-    pub(crate) fn make_bootconfig(bootconfig: impl AsRef<str>) -> Vec<u8> {
-        let bootconfig = bootconfig.as_ref();
-        let mut buffer = vec![0u8; bootconfig.len() + BOOTCONFIG_TRAILER_SIZE];
-        let mut res = BootConfigBuilder::new(&mut buffer).unwrap();
-        res.add_with(|_, out| {
-            out[..bootconfig.len()].clone_from_slice(bootconfig.as_bytes());
-            Ok(bootconfig.as_bytes().len())
-        })
-        .unwrap();
-        res.config_bytes().to_vec()
-    }
-
-    pub(crate) struct MakeExpectedBootconfigInclude {
-        pub boot: bool,
-        pub init_boot: bool,
-        pub vendor_boot: bool,
-        pub dtb: bool,
-        pub dtbo: bool,
-    }
-
-    impl MakeExpectedBootconfigInclude {
-        fn is_include_str(&self, name: &str) -> bool {
-            match name {
-                "boot" => self.boot,
-                "init_boot" => self.init_boot,
-                "vendor_boot" => self.vendor_boot,
-                "dtb" => self.dtb,
-                "dtbo" => self.dtbo,
-                _ => false,
-            }
-        }
-    }
-
-    impl Default for MakeExpectedBootconfigInclude {
-        fn default() -> MakeExpectedBootconfigInclude {
-            MakeExpectedBootconfigInclude {
-                boot: true,
-                init_boot: true,
-                vendor_boot: true,
-                dtb: true,
-                dtbo: true,
-            }
-        }
-    }
-
-    /// Helper for generating expected bootconfig after load and verification.
-    pub(crate) fn make_expected_bootconfig(
-        vbmeta_file: &str,
-        slot: char,
-        vendor_config: &str,
-        include: MakeExpectedBootconfigInclude,
-    ) -> Vec<u8> {
-        let vbmeta_file = Path::new(vbmeta_file);
-        let vbmeta_digest = vbmeta_file.with_extension("digest.txt");
-        let vbmeta_digest = vbmeta_digest.to_str().unwrap();
-        let mut builder = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data(vbmeta_file.to_str().unwrap()).len())
-            .digest(read_test_data_as_str(vbmeta_digest).strip_suffix("\n").unwrap())
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .extra("androidboot.force_normal_boot=1\n")
-            .extra(format!("androidboot.slot_suffix=_{slot}\n"))
-            .extra("androidboot.gbl.version=0\n")
-            .extra(format!("androidboot.gbl.build_number={TEST_DEFAULT_BUILD_ID}\n"))
-            .extra(FakeGblOps::GBL_TEST_BOOTCONFIG)
-            .extra(vendor_config);
-
-        for name in ["boot", "vendor_boot", "init_boot", "dtbo", "dtb"].iter() {
-            let file = vbmeta_file.with_extension(format!("{name}.digest.txt"));
-            println!("{file:?}");
-            if include.is_include_str(name)
-                && Path::new(format!("{TEST_DATA_PATH}/{}", file.to_str().unwrap()).as_str())
-                    .exists()
-            {
-                builder = builder.partition_digest(
-                    name,
-                    read_test_data_as_str(file.to_str().unwrap()).strip_suffix("\n").unwrap(),
-                );
-            }
-        }
-
-        builder.build()
-    }
-
-    /// Helper for testing load/verify for a/b slot v0,1,2 image with dtbo partition.
-    ///
-    /// # Args
-    ///
-    /// * `ver`: Boot image version.
-    /// * `slot`: Target slot to boot.
-    /// * `additional_part`: A list of pair `(partition name, file name)` representing additional
-    ///   partitions for creating boot storage.
-    /// * `expected_dtb`: The expected DTB.
-    /// * `expected_dtbo`: The expected DTBO.
-    fn test_android_load_verify_v2_and_lower_slot(
-        ver: u8,
-        slot: char,
-        additional_part: &[(CString, String)],
-        expected_dtb: &[u8],
-        expected_dtbo: &[u8],
-    ) {
-        let dtbo =
-            additional_part.iter().any(|(name, _)| name.to_str().unwrap().starts_with("dtbo_"));
-        let vbmeta = format!("vbmeta_v{ver}_{slot}.img");
-        let boot = format!("boot_v{ver}_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (CString::new(format!("boot_{slot}")).unwrap(), boot.clone()),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        parts.extend_from_slice(additional_part);
-
-        test_android_load_verify_success(
-            (u64::from(slot) - ('a' as u64)).try_into().unwrap(),
-            &parts,
-            &read_test_data(format!("kernel_{slot}.img")),
-            &read_test_data(format!("generic_ramdisk_{slot}.img")),
-            &make_expected_bootconfig(
-                &vbmeta,
-                slot,
-                "",
-                MakeExpectedBootconfigInclude { dtbo, dtb: false, ..Default::default() },
-            ),
-            expected_dtb,
-            expected_dtbo,
-            "",
-        );
-    }
-
-    #[test]
-    fn test_android_load_verify_v0_slot_a() {
-        test_android_load_verify_v2_and_lower_slot(0, 'a', &[], &[], &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_v0_slot_b() {
-        test_android_load_verify_v2_and_lower_slot(0, 'b', &[], &[], &[]);
-    }
-
-    #[test]
-    fn test_android_load_verify_v1_slot_a() {
-        test_android_load_verify_v2_and_lower_slot(1, 'a', &[], &[], &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_v1_slot_b() {
-        test_android_load_verify_v2_and_lower_slot(1, 'b', &[], &[], &[]);
-    }
-
-    #[test]
-    fn test_android_load_verify_v2_slot_a() {
-        test_android_load_verify_v2_and_lower_slot(2, 'a', &[], &test_dtb(), &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_v2_slot_b() {
-        test_android_load_verify_v2_and_lower_slot(2, 'b', &[], &test_dtb(), &[]);
-    }
-
-    fn test_android_load_verify_v2_and_lower_slot_with_dtbo(
-        ver: u8,
-        slot: char,
-        expected_dtb: &[u8],
-    ) {
-        let dtbo = read_test_data(format!("dtbo_{slot}.img"));
-        let parts: Vec<(CString, String)> =
-            vec![(CString::new(format!("dtbo_{slot}")).unwrap(), format!("dtbo_{slot}.img"))];
-        test_android_load_verify_v2_and_lower_slot(ver, slot, &parts, expected_dtb, &dtbo);
-    }
-
-    #[test]
-    fn test_android_load_verify_v0_slot_a_with_dtbo() {
-        test_android_load_verify_v2_and_lower_slot_with_dtbo(0, 'a', &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_v0_slot_b_with_dtbo() {
-        test_android_load_verify_v2_and_lower_slot_with_dtbo(0, 'b', &[]);
-    }
-
-    #[test]
-    fn test_android_load_verify_v1_slot_a_with_dtbo() {
-        test_android_load_verify_v2_and_lower_slot_with_dtbo(1, 'a', &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_v1_slot_b_with_dtbo() {
-        test_android_load_verify_v2_and_lower_slot_with_dtbo(1, 'b', &[]);
-    }
-
-    #[test]
-    fn test_android_load_verify_v2_slot_a_with_dtbo() {
-        test_android_load_verify_v2_and_lower_slot_with_dtbo(2, 'a', &test_dtb())
-    }
-
-    #[test]
-    fn test_android_load_verify_v2_slot_b_with_dtbo() {
-        test_android_load_verify_v2_and_lower_slot_with_dtbo(2, 'b', &test_dtb());
-    }
-
-    /// Helper for testing load/verify for v3/v4 boot/vendor_boot images.
-    ///
-    /// # Args
-    ///
-    /// * `partitions`: A list of pair `(partition name, file name)` for creating boot storage.
-    /// * `vbmeta_file`: The vbmeta file for the storage. Used for constructing expected bootconfig.
-    /// * `expected_kernel`: The expected kernel.
-    /// * `expected_digest`: The expected digest outputed by vbmeta.
-    /// * `expected_vendor_bootconfig`: The expected vendor_boot_config.
-    fn test_android_load_verify_v3_and_v4(
-        slot: char,
-        partitions: &[(CString, String)],
-        vbmeta: &str,
-        expected_kernel: &[u8],
-        expected_vendor_bootconfig: &str,
-        expected_dtbo: &[u8],
-    ) {
-        let dtbo = partitions.iter().any(|(name, _)| name.to_str().unwrap().starts_with("dtbo_"));
-        test_android_load_verify_success(
-            (u64::from(slot) - ('a' as u64)).try_into().unwrap(),
-            partitions,
-            expected_kernel,
-            &[
-                read_test_data(format!("vendor_ramdisk_{slot}.img")),
-                read_test_data(format!("generic_ramdisk_{slot}.img")),
-            ]
-            .concat(),
-            &make_expected_bootconfig(
-                &vbmeta,
-                slot,
-                expected_vendor_bootconfig,
-                MakeExpectedBootconfigInclude { dtbo, dtb: false, ..Default::default() },
-            ),
-            &test_dtb(),
-            expected_dtbo,
-            TEST_VENDOR_CMDLINE,
-        );
-    }
-
-    /// Helper for testing v3/v4 boot image without init_boot partition.
-    fn test_android_load_verify_boot_v3_v4_slot_no_init_boot(
-        slot: char,
-        boot_ver: u32,
-        vendor_ver: u32,
-        additional_part: &[(CString, String)],
-        expected_vendor_bootconfig: &str,
-        expected_dtbo: &[u8],
-    ) {
-        let vbmeta = format!("vbmeta_v{boot_ver}_v{vendor_ver}_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (CString::new(format!("boot_{slot}")).unwrap(), format!("boot_v{boot_ver}_{slot}.img")),
-            (
-                CString::new(format!("vendor_boot_{slot}")).unwrap(),
-                format!("vendor_boot_v{vendor_ver}_{slot}.img"),
-            ),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        parts.extend_from_slice(additional_part);
-        test_android_load_verify_v3_and_v4(
-            slot,
-            &parts[..],
-            &vbmeta,
-            &read_test_data(format!("kernel_{slot}.img")),
-            expected_vendor_bootconfig,
-            expected_dtbo,
-        );
-    }
-
-    /// Helper for testing v3/v4 boot image with init_boot partition.
-    fn test_android_load_verify_boot_v3_v4_slot_init_boot(
-        slot: char,
-        boot_ver: u32,
-        vendor_ver: u32,
-        additional_part: &[(CString, String)],
-        expected_vendor_bootconfig: &str,
-        expected_dtbo: &[u8],
-    ) {
-        let vbmeta = format!("vbmeta_v{boot_ver}_v{vendor_ver}_init_boot_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (
-                CString::new(format!("boot_{slot}")).unwrap(),
-                format!("boot_no_ramdisk_v{boot_ver}_{slot}.img"),
-            ),
-            (
-                CString::new(format!("vendor_boot_{slot}")).unwrap(),
-                format!("vendor_boot_v{vendor_ver}_{slot}.img"),
-            ),
-            (CString::new(format!("init_boot_{slot}")).unwrap(), format!("init_boot_{slot}.img")),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        parts.extend_from_slice(additional_part);
-        test_android_load_verify_v3_and_v4(
-            slot,
-            &parts[..],
-            &vbmeta,
-            &read_test_data(format!("kernel_{slot}.img")),
-            expected_vendor_bootconfig,
-            expected_dtbo,
-        );
-    }
-
-    enum KernelCompression {
-        LZ4,
-        GZIP,
-    }
-
-    impl fmt::Display for KernelCompression {
-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-            match self {
-                KernelCompression::LZ4 => write!(f, "lz4"),
-                KernelCompression::GZIP => write!(f, "gz"),
-            }
-        }
-    }
-
-    /// Helper for testing v4 boot image with different kernel compression.
-    fn test_android_load_verify_boot_v4_compression_slot(
-        compression: KernelCompression,
-        slot: char,
-        expected_vendor_bootconfig: &str,
-        expected_dtbo: &[u8],
-    ) {
-        let vbmeta = format!("vbmeta_v4_{compression}_{slot}.img");
-        let parts: Vec<(CString, String)> = vec![
-            (
-                CString::new(format!("boot_{slot}")).unwrap(),
-                format!("boot_v4_{compression}_{slot}.img"),
-            ),
-            (
-                CString::new(format!("vendor_boot_{slot}")).unwrap(),
-                format!("vendor_boot_v4_{slot}.img"),
-            ),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        test_android_load_verify_v3_and_v4(
-            slot,
-            &parts[..],
-            &vbmeta,
-            &read_test_data(format!("gki_boot_{compression}_kernel_uncompressed")),
-            expected_vendor_bootconfig,
-            expected_dtbo,
-        );
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_no_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot('a', 3, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_no_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot('b', 3, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot('a', 3, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot('b', 3, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_no_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot(
-            'a',
-            3,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_no_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot(
-            'b',
-            3,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot(
-            'a',
-            3,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot(
-            'b',
-            3,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_no_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot('a', 4, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_no_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot('b', 4, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot('a', 4, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot('b', 4, 3, &[], "", &[])
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_no_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot(
-            'a',
-            4,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_no_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot(
-            'b',
-            4,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_init_boot_slot_a() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot(
-            'a',
-            4,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_init_boot_slot_b() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot(
-            'b',
-            4,
-            4,
-            &[],
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    /// Same as `test_android_load_verify_boot_v3_v4_slot_no_init_boot` but with dtbo partition.
-    fn test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo(
-        slot: char,
-        boot_ver: u32,
-        vendor_ver: u32,
-        expected_vendor_bootconfig: &str,
-    ) {
-        let dtbo = read_test_data(format!("dtbo_{slot}.img"));
-        let parts: Vec<(CString, String)> =
-            vec![(CString::new(format!("dtbo_{slot}")).unwrap(), format!("dtbo_{slot}.img"))];
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot(
-            slot,
-            boot_ver,
-            vendor_ver,
-            &parts,
-            expected_vendor_bootconfig,
-            &dtbo,
-        );
-    }
-
-    /// Same as `test_android_load_verify_boot_v3_v4_slot_init_boot` but with dtbo partition.
-    fn test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo(
-        slot: char,
-        boot_ver: u32,
-        vendor_ver: u32,
-        expected_vendor_bootconfig: &str,
-    ) {
-        let dtbo = read_test_data(format!("dtbo_{slot}.img"));
-        let parts: Vec<(CString, String)> =
-            vec![(CString::new(format!("dtbo_{slot}")).unwrap(), format!("dtbo_{slot}.img"))];
-        test_android_load_verify_boot_v3_v4_slot_init_boot(
-            slot,
-            boot_ver,
-            vendor_ver,
-            &parts,
-            expected_vendor_bootconfig,
-            &dtbo,
-        );
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_no_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo('a', 3, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_no_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo('b', 3, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo('a', 3, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v3_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo('b', 3, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_no_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo(
-            'a',
-            3,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_no_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo(
-            'b',
-            3,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo(
-            'a',
-            3,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v3_vendor_v4_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo(
-            'b',
-            3,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_no_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo('a', 4, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_no_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo('b', 4, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo('a', 4, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v3_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo('b', 4, 3, "")
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_no_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo(
-            'a',
-            4,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_no_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_no_init_boot_with_dtbo(
-            'b',
-            4,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_init_boot_slot_a_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo(
-            'a',
-            4,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_boot_v4_vendor_v4_init_boot_slot_b_with_dtbo() {
-        test_android_load_verify_boot_v3_v4_slot_init_boot_with_dtbo(
-            'b',
-            4,
-            4,
-            TEST_VENDOR_BOOTCONFIG,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_gzip_boot_v4_vendor_v4_slot_a() {
-        test_android_load_verify_boot_v4_compression_slot(
-            KernelCompression::GZIP,
-            'a',
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_lz4_boot_v4_vendor_v4_slot_a() {
-        test_android_load_verify_boot_v4_compression_slot(
-            KernelCompression::LZ4,
-            'a',
-            TEST_VENDOR_BOOTCONFIG,
-            &[],
-        )
-    }
-}
diff --git a/gbl/libgbl/src/android_boot/mod.rs b/gbl/libgbl/src/android_boot/mod.rs
deleted file mode 100644
index f5b9932..0000000
--- a/gbl/libgbl/src/android_boot/mod.rs
+++ /dev/null
@@ -1,1377 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Android boot support.
-
-use crate::{
-    constants::{FDT_ALIGNMENT, KERNEL_ALIGNMENT},
-    device_tree::{DeviceTreeComponentSource, DeviceTreeComponentsRegistry},
-    fastboot::{
-        run_gbl_fastboot, run_gbl_fastboot_stack, BufferPool, GblFastbootResult, GblTcpStream,
-        GblUsbTransport, LoadedImageInfo, PinFutContainer, Shared,
-    },
-    gbl_print, gbl_println,
-    ops::RebootReason,
-    GblOps, Result,
-};
-use bootparams::commandline::CommandlineBuilder;
-use core::{array::from_fn, ffi::CStr};
-use dttable::DtTableImage;
-use fastboot::local_session::LocalSession;
-use fdt::{Fdt, FdtHeader};
-use gbl_async::block_on;
-use liberror::Error;
-use libutils::{aligned_offset, aligned_subslice};
-use misc::{AndroidBootMode, BootloaderMessage};
-use safemath::SafeNum;
-
-mod vboot;
-use vboot::{avb_verify_slot, PartitionsToVerify};
-
-pub(crate) mod load;
-use load::split_chunks;
-pub use load::{android_load_verify, LoadedImages};
-
-/// Device tree bootargs property to store kernel command line.
-pub const BOOTARGS_PROP: &CStr = c"bootargs";
-
-/// A helper to convert a bytes slice containing a null-terminated string to `str`
-fn cstr_bytes_to_str(data: &[u8]) -> core::result::Result<&str, Error> {
-    Ok(CStr::from_bytes_until_nul(data)?.to_str()?)
-}
-
-/// Loads Android images from the given slot on disk and fixes up bootconfig, commandline, and FDT.
-///
-/// On success, returns a tuple of (ramdisk, fdt, kernel, unused buffer).
-pub fn android_load_verify_fixup<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'b, 'c>,
-    slot: u8,
-    is_recovery: bool,
-    load: &'a mut [u8],
-) -> Result<(&'a mut [u8], &'a mut [u8], &'a mut [u8], &'a mut [u8])> {
-    let load_addr = load.as_ptr() as usize;
-    let images = android_load_verify(ops, slot, is_recovery, load)?;
-
-    let mut components = DeviceTreeComponentsRegistry::new();
-    let fdt_load = &mut images.unused[..];
-    // TODO(b/353272981): Remove get_custom_device_tree
-    let (fdt_load, base, overlays) = match ops.get_custom_device_tree() {
-        Some(v) => (fdt_load, v, &[][..]),
-        _ => {
-            let mut remains = match images.dtbo.len() > 0 {
-                // TODO(b/384964561, b/374336105): Investigate if we can avoid additional copy.
-                true => {
-                    gbl_println!(ops, "Handling overlays from dtbo");
-                    components.append_from_dttable(
-                        DeviceTreeComponentSource::Dtbo,
-                        &DtTableImage::from_bytes(images.dtbo)?,
-                        fdt_load,
-                    )?
-                }
-                _ => fdt_load,
-            };
-
-            if images.dtb.len() > 0 {
-                gbl_println!(ops, "Handling device tree from boot/vendor_boot");
-                remains = if FdtHeader::from_bytes_ref(images.dtb).is_ok() {
-                    gbl_println!(ops, "Device tree found in boot/vendor_boot");
-                    components.append(ops, DeviceTreeComponentSource::Boot, images.dtb, remains)?
-                } else if let Ok(table) = DtTableImage::from_bytes(images.dtb) {
-                    gbl_println!(
-                        ops,
-                        "Dttable with {} entries found in boot/vendor_boot",
-                        table.entries_count()
-                    );
-                    components.append_from_dttable(
-                        DeviceTreeComponentSource::Boot,
-                        &table,
-                        remains,
-                    )?
-                } else {
-                    return Err(Error::Other(Some(
-                        "Invalid or unrecognized device tree format in boot/vendor_boot",
-                    ))
-                    .into());
-                }
-            }
-
-            if images.dtb_part.len() > 0 {
-                gbl_println!(ops, "Handling device trees from dtb");
-                let dttable = DtTableImage::from_bytes(images.dtb_part)?;
-                remains = components.append_from_dttable(
-                    DeviceTreeComponentSource::Dtb,
-                    &dttable,
-                    remains,
-                )?;
-            }
-
-            gbl_println!(ops, "Selecting device tree components");
-            ops.select_device_trees(&mut components)?;
-            let (base, overlays) = components.selected()?;
-            (remains, base, overlays)
-        }
-    };
-    let fdt_load = aligned_subslice(fdt_load, FDT_ALIGNMENT)?;
-    let mut fdt = Fdt::new_from_init(&mut fdt_load[..], base)?;
-
-    // Adds ramdisk range to FDT
-    let ramdisk_addr: u64 = (images.ramdisk.as_ptr() as usize).try_into().map_err(Error::from)?;
-    let ramdisk_end: u64 = ramdisk_addr + u64::try_from(images.ramdisk.len()).unwrap();
-    fdt.set_property("chosen", c"linux,initrd-start", &ramdisk_addr.to_be_bytes())?;
-    fdt.set_property("chosen", c"linux,initrd-end", &ramdisk_end.to_be_bytes())?;
-    gbl_println!(ops, "linux,initrd-start: {:#x}", ramdisk_addr);
-    gbl_println!(ops, "linux,initrd-end: {:#x}", ramdisk_end);
-
-    // Updates the FDT commandline.
-    let device_tree_commandline_length = match fdt.get_property("chosen", BOOTARGS_PROP) {
-        Ok(val) => CStr::from_bytes_until_nul(val).map_err(Error::from)?.to_bytes().len(),
-        Err(_) => 0,
-    };
-
-    // Reserves 1024 bytes for separators and fixup.
-    let final_commandline_len = device_tree_commandline_length
-        + images.boot_cmdline.len()
-        + images.vendor_cmdline.len()
-        + 1024;
-    let final_commandline_buffer =
-        fdt.set_property_placeholder("chosen", BOOTARGS_PROP, final_commandline_len)?;
-    let mut commandline_builder =
-        CommandlineBuilder::new_from_prefix(&mut final_commandline_buffer[..])?;
-    commandline_builder.add(images.boot_cmdline)?;
-    commandline_builder.add(images.vendor_cmdline)?;
-
-    // TODO(b/353272981): Handle buffer too small
-    commandline_builder.add_with(|current, out| {
-        // TODO(b/353272981): Verify provided command line and fail here.
-        Ok(ops.fixup_os_commandline(current, out)?.map(|fixup| fixup.len()).unwrap_or(0))
-    })?;
-    gbl_println!(ops, "final cmdline: \"{}\"", commandline_builder.as_str());
-
-    gbl_println!(ops, "Applying {} overlays", overlays.len());
-    fdt.multioverlay_apply(overlays)?;
-    gbl_println!(ops, "Overlays applied");
-    // `DeviceTreeComponentsRegistry` internally uses ArrayVec which causes it to have a default
-    // life time equal to the scope it lives in. This is unnecessarily strict and prevents us from
-    // accessing `load` buffer.
-    drop(components);
-
-    // Make sure we provide an actual device tree size, so FW can calculate amount of space
-    // available for fixup.
-    fdt.shrink_to_fit()?;
-    // TODO(b/353272981): Make a copy of current device tree and verify provided fixup.
-    // TODO(b/353272981): Handle buffer too small
-    ops.fixup_device_tree(fdt.as_mut())?;
-    fdt.shrink_to_fit()?;
-
-    // Moves the kernel forward to reserve as much space as possible. This is in case there is not
-    // enough memory after `load`, i.e. the memory after it is not mapped or is reserved.
-    let ramdisk_off = usize::try_from(ramdisk_addr).unwrap() - load_addr;
-    let fdt_len = fdt.header_ref()?.actual_size();
-    let fdt_off = fdt_load.as_ptr() as usize - load_addr;
-    let kernel_off = images.kernel.as_ptr() as usize - load_addr;
-    let kernel_len = images.kernel.len();
-    let mut kernel_new = (SafeNum::from(fdt_off) + fdt_len).try_into().map_err(Error::from)?;
-    kernel_new += aligned_offset(&mut load[kernel_new..], KERNEL_ALIGNMENT)?;
-    load.copy_within(kernel_off..kernel_off + kernel_len, kernel_new);
-    let ([_, ramdisk, fdt, kernel], unused) =
-        split_chunks(load, &[ramdisk_off, fdt_off - ramdisk_off, kernel_new - fdt_off, kernel_len]);
-    let ramdisk = &mut ramdisk[..usize::try_from(ramdisk_end - ramdisk_addr).unwrap()];
-    Ok((ramdisk, fdt, kernel, unused))
-}
-
-/// Gets the target slot to boot.
-///
-/// * If GBL is slotless (`GblOps::get_current_slot()` returns `Error::Unsupported`), the API
-///   behaves the same as `GblOps::get_next_slot()`.
-/// * If GBL is slotted, the API behaves the same as `GblOps::get_current_slot()` and
-///   `mark_boot_attempt` is ignored.
-/// * Default to A slot if slotting backend is not implemented on the platform.
-pub(crate) fn get_boot_slot<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    mark_boot_attempt: bool,
-) -> Result<char> {
-    let slot = match ops.get_current_slot() {
-        // Slotless bootloader
-        Err(Error::Unsupported) => {
-            gbl_println!(ops, "GBL is Slotless.");
-            ops.get_next_slot(mark_boot_attempt)
-        }
-        v => v,
-    };
-    match slot {
-        Ok(slot) => Ok(slot.suffix.0),
-        Err(Error::Unsupported) => {
-            // Default to slot A if slotting is not supported.
-            // Slotless partition name is currently not supported. Revisit if this causes problems.
-            gbl_println!(ops, "Slotting is not supported. Choose A slot by default");
-            Ok('a')
-        }
-        Err(e) => {
-            gbl_println!(ops, "Failed to get boot slot: {e}");
-            Err(e.into())
-        }
-    }
-}
-
-/// Provides methods to run GBL fastboot.
-pub struct GblFastbootEntry<'d, G> {
-    ops: &'d mut G,
-    load: &'d mut [u8],
-    result: &'d mut GblFastbootResult,
-}
-
-impl<'a, 'd, 'e, G> GblFastbootEntry<'d, G>
-where
-    G: GblOps<'a, 'e>,
-{
-    /// Runs GBL fastboot with the given buffer pool, tasks container, and usb/tcp/local transport
-    /// channels.
-    ///
-    /// # Args
-    ///
-    /// * `buffer_pool`: An implementation of `BufferPool` wrapped in `Shared` for allocating
-    ///    download buffers.
-    /// * `tasks`: An implementation of `PinFutContainer` used as task container for GBL fastboot to
-    // /   schedule dynamically spawned async tasks.
-    /// * `local`: An implementation of `LocalSession` which exchanges fastboot packet from platform
-    ///   specific channels i.e. UX.
-    /// * `usb`: An implementation of `GblUsbTransport` that represents USB channel.
-    /// * `tcp`: An implementation of `GblTcpStream` that represents TCP channel.
-    pub async fn run<'b: 'c, 'c>(
-        self,
-        buffer_pool: &'b Shared<impl BufferPool>,
-        tasks: impl PinFutContainer<'c> + 'c,
-        local: Option<impl LocalSession>,
-        usb: Option<impl GblUsbTransport>,
-        tcp: Option<impl GblTcpStream>,
-    ) where
-        'a: 'c,
-        'd: 'c,
-    {
-        *self.result =
-            run_gbl_fastboot(self.ops, buffer_pool, tasks, local, usb, tcp, self.load).await;
-    }
-
-    /// Runs fastboot with N pre-allocated async worker tasks.
-    ///
-    /// Comparing  to `Self::run()`, this API   simplifies the input by handling the implementation of
-    /// `BufferPool` and `PinFutContainer` internally . However it only supports up to N parallel
-    /// tasks where N is determined at build time. The download buffer will be split into N chunks
-    /// evenly.
-    ///
-    /// The choice of N depends on the level of parallelism the platform can support. For platform
-    /// with `n` storage devices that can independently perform non-blocking IO, it will required
-    /// `N = n + 1` in order to achieve parallel flashing to all storages plus a parallel download.
-    /// However, it is common for partitions that need to be flashed to be on the same block device
-    /// so flashing of them becomes sequential, in which case N can be smaller. Caller should take
-    /// into consideration usage pattern for determining N. If platform only has one physical disk
-    /// or does not expect disks to be parallelizable, a common choice is N=2 which allows
-    /// downloading and flashing to be performed in parallel.
-    pub fn run_n<const N: usize>(
-        self,
-        download: &mut [u8],
-        local: Option<impl LocalSession>,
-        usb: Option<impl GblUsbTransport>,
-        tcp: Option<impl GblTcpStream>,
-    ) {
-        if N < 1 {
-            return self.run_n::<1>(download, local, usb, tcp);
-        }
-        // Splits into N download buffers.
-        let mut arr: [_; N] = from_fn(|_| Default::default());
-        for (i, v) in download.chunks_exact_mut(download.len() / N).enumerate() {
-            arr[i] = v;
-        }
-        let bufs = &mut arr[..];
-        *self.result =
-            block_on(run_gbl_fastboot_stack::<N>(self.ops, bufs, local, usb, tcp, self.load));
-    }
-}
-
-/// Runs full Android bootloader bootflow before kernel handoff.
-///
-/// The API performs slot selection, handles boot mode, fastboot and loads and verifies Android from
-/// disk.
-///
-/// # Args:
-///
-/// * `ops`: An implementation of `GblOps`.
-/// * `load`: Buffer for loading various Android images.
-/// * `run_fastboot`: A closure for running GBL fastboot. The closure is passed a
-///   `GblFastbootEntry` type which provides methods for running GBL fastboot. The caller is
-///   responsible for preparing the required inputs and calling the method in the closure. See
-///   `GblFastbootEntry` for more details.
-///
-/// On success, returns a tuple of slices corresponding to `(ramdisk, FDT, kernel, unused)`
-pub fn android_main<'a, 'b, 'c, G: GblOps<'a, 'b>>(
-    ops: &mut G,
-    load: &'c mut [u8],
-    run_fastboot: impl FnOnce(GblFastbootEntry<'_, G>),
-) -> Result<(&'c mut [u8], &'c mut [u8], &'c mut [u8], &'c mut [u8])> {
-    let (bcb_buffer, _) = load
-        .split_at_mut_checked(BootloaderMessage::SIZE_BYTES)
-        .ok_or(Error::BufferTooSmall(Some(BootloaderMessage::SIZE_BYTES)))
-        .inspect_err(|e| gbl_println!(ops, "Buffer too small for reading misc. {e}"))?;
-    ops.read_from_partition_sync("misc", 0, bcb_buffer)
-        .inspect_err(|e| gbl_println!(ops, "Failed to read misc partition {e}"))?;
-    let bcb = BootloaderMessage::from_bytes_ref(bcb_buffer)
-        .inspect_err(|e| gbl_println!(ops, "Failed to parse bootloader messgae {e}"))?;
-    let boot_mode = bcb
-        .boot_mode()
-        .inspect_err(|e| gbl_println!(ops, "Failed to parse BCB boot mode {e}. Ignored"))
-        .unwrap_or(AndroidBootMode::Normal);
-    gbl_println!(ops, "Boot mode from BCB: {}", boot_mode);
-
-    if matches!(boot_mode, AndroidBootMode::BootloaderBootOnce) {
-        let mut zeroed_command = [0u8; misc::COMMAND_FIELD_SIZE];
-        ops.write_to_partition_sync(
-            "misc",
-            misc::COMMAND_FIELD_OFFSET.try_into().unwrap(),
-            &mut zeroed_command,
-        )?;
-    }
-
-    // Checks platform reboot reason.
-    let reboot_reason = ops
-        .get_reboot_reason()
-        .inspect_err(|e| {
-            gbl_println!(ops, "Failed to get reboot reason from platform: {e}. Ignored.")
-        })
-        .unwrap_or(RebootReason::Normal);
-    gbl_println!(ops, "Reboot reason from platform: {reboot_reason:?}");
-
-    // Checks and enters fastboot.
-    let result = &mut Default::default();
-    if matches!(reboot_reason, RebootReason::Bootloader)
-        || matches!(boot_mode, AndroidBootMode::BootloaderBootOnce)
-        || ops
-            .should_stop_in_fastboot()
-            .inspect_err(|e| {
-                gbl_println!(ops, "Warning: error while checking fastboot trigger ({:?})", e);
-                gbl_println!(ops, "Ignoring error and continuing with normal boot");
-            })
-            .unwrap_or(false)
-    {
-        gbl_println!(ops, "Entering fastboot mode...");
-        run_fastboot(GblFastbootEntry { ops, load: &mut load[..], result });
-        gbl_println!(ops, "Leaving fastboot mode...");
-    }
-
-    // Checks if "fastboot boot" has loaded an android image.
-    match &result.loaded_image_info {
-        Some(LoadedImageInfo::Android { .. }) => {
-            gbl_println!(ops, "Booting from \"fastboot boot\"");
-            return Ok(result.split_loaded_android(load).unwrap());
-        }
-        _ => {}
-    }
-
-    // Checks whether fastboot has set a different active slot. Reboot if it does.
-    let slot_suffix = get_boot_slot(ops, true)?;
-    if result.last_set_active_slot.unwrap_or(slot_suffix) != slot_suffix {
-        gbl_println!(ops, "Active slot changed by \"fastboot set_active\". Reset..");
-        ops.reboot();
-        return Err(Error::UnexpectedReturn.into());
-    }
-
-    // Currently we assume slot suffix only takes value within 'a' to 'z'. Revisit if this
-    // is not the case.
-    //
-    // It's a little awkward to convert suffix char to integer which will then be converted
-    // back to char by the API. Consider passing in the char bytes directly.
-    let slot_idx = (u64::from(slot_suffix) - u64::from('a')).try_into().unwrap();
-
-    let is_recovery = matches!(reboot_reason, RebootReason::Recovery)
-        || matches!(boot_mode, AndroidBootMode::Recovery);
-    android_load_verify_fixup(ops, slot_idx, is_recovery, load)
-}
-
-#[cfg(test)]
-pub(crate) mod tests {
-    use super::*;
-    use crate::{
-        fastboot::test::{make_expected_usb_out, SharedTestListener, TestLocalSession},
-        gbl_avb::state::KeyValidationStatus,
-        ops::test::{slot, FakeGblOps, FakeGblOpsStorage},
-        tests::AlignedBuffer,
-    };
-    use load::tests::{
-        check_ramdisk, make_expected_bootconfig, read_test_data, read_test_data_as_str,
-        AvbResultBootconfigBuilder, MakeExpectedBootconfigInclude, TEST_DEFAULT_BUILD_ID,
-        TEST_PUBLIC_KEY_DIGEST, TEST_VENDOR_BOOTCONFIG,
-    };
-    use std::{collections::HashMap, ffi::CString};
-
-    const TEST_ROLLBACK_INDEX_LOCATION: usize = 1;
-
-    /// Helper for testing `android_load_verify_fixup` given a partition layout, target slot and
-    /// custom device tree.
-    fn test_android_load_verify_fixup(
-        slot: u8,
-        partitions: &[(CString, String)],
-        expected_kernel: &[u8],
-        expected_ramdisk: &[u8],
-        expected_bootconfig: &[u8],
-        expected_bootargs: &str,
-        expected_fdt_property: &[(&str, &CStr, Option<&[u8]>)],
-    ) {
-        let mut storage = FakeGblOpsStorage::default();
-        for (part, file) in partitions {
-            storage.add_raw_device(part, read_test_data(file));
-        }
-        let mut ops = FakeGblOps::new(&storage);
-        ops.avb_ops.unlock_state = Ok(false);
-        ops.avb_ops.rollbacks = HashMap::from([(TEST_ROLLBACK_INDEX_LOCATION, Ok(0))]);
-        let mut out_color = None;
-        let mut handler = |color,
-                           _: Option<&CStr>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>| {
-            out_color = Some(color);
-            Ok(())
-        };
-        ops.avb_handle_verification_result = Some(&mut handler);
-        ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Valid));
-
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, fdt, kernel, _) =
-            android_load_verify_fixup(&mut ops, slot, false, &mut load_buffer).unwrap();
-        assert_eq!(kernel, expected_kernel);
-        check_ramdisk(ramdisk, expected_ramdisk, expected_bootconfig);
-
-        let fdt = Fdt::new(fdt).unwrap();
-        // "linux,initrd-start/end" are updated.
-        assert_eq!(
-            fdt.get_property("/chosen", c"linux,initrd-start").unwrap(),
-            (ramdisk.as_ptr() as usize).to_be_bytes(),
-        );
-        assert_eq!(
-            fdt.get_property("/chosen", c"linux,initrd-end").unwrap(),
-            (ramdisk.as_ptr() as usize + ramdisk.len()).to_be_bytes(),
-        );
-
-        // Commandlines are updated.
-        assert_eq!(
-            CStr::from_bytes_until_nul(fdt.get_property("/chosen", c"bootargs").unwrap()).unwrap(),
-            CString::new(expected_bootargs).unwrap().as_c_str(),
-        );
-
-        // Fixup is applied.
-        assert_eq!(fdt.get_property("/chosen", c"fixup").unwrap(), &[1]);
-
-        // Other FDT properties are as expected.
-        for (path, property, res) in expected_fdt_property {
-            assert_eq!(
-                fdt.get_property(&path, &property).ok(),
-                res.clone(),
-                "{path}:{property:?} value doesn't match"
-            );
-        }
-    }
-
-    /// Helper for testing `android_load_verify_fixup` for v2 boot image or lower.
-    fn test_android_load_verify_fixup_v2_or_lower(
-        ver: u8,
-        slot: char,
-        additional_parts: &[(&CStr, &str)],
-        additional_expected_fdt_properties: &[(&str, &CStr, Option<&[u8]>)],
-    ) {
-        let dtb =
-            additional_parts.iter().any(|(name, _)| name.to_str().unwrap().starts_with("dtb_"));
-        let dtbo =
-            additional_parts.iter().any(|(name, _)| name.to_str().unwrap().starts_with("dtbo_"));
-        let vbmeta = format!("vbmeta_v{ver}_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (CString::new(format!("boot_{slot}")).unwrap(), format!("boot_v{ver}_{slot}.img")),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        for (part, file) in additional_parts.iter().cloned() {
-            parts.push((part.into(), file.into()));
-        }
-
-        test_android_load_verify_fixup(
-            (u64::from(slot) - ('a' as u64)).try_into().unwrap(),
-            &parts,
-            &read_test_data(format!("kernel_{slot}.img")),
-            &read_test_data(format!("generic_ramdisk_{slot}.img")),
-            &make_expected_bootconfig(&vbmeta, slot, "",
-                MakeExpectedBootconfigInclude {dtb, dtbo, ..Default::default() }
-            ),
-            "existing_arg_1=existing_val_1 existing_arg_2=existing_val_2 cmd_key_1=cmd_val_1,cmd_key_2=cmd_val_2",
-            additional_expected_fdt_properties,
-        )
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v0_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"dtb_slot", Some(b"a\0"))];
-        // V0 image doesn't have built-in dtb. We need to provide from dtb partition.
-        let parts = &[(c"dtb_a", "dtb_a.img")];
-        test_android_load_verify_fixup_v2_or_lower(0, 'a', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v0_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"dtb_slot", Some(b"a\0")),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a", "dtbo_a.img"), (c"dtb_a", "dtb_a.img")];
-        test_android_load_verify_fixup_v2_or_lower(0, 'a', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v0_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"dtb_slot", Some(b"b\0"))];
-        let parts = &[(c"dtb_b", "dtb_b.img")];
-        test_android_load_verify_fixup_v2_or_lower(0, 'b', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v0_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"dtb_slot", Some(b"b\0")),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b", "dtbo_b.img"), (c"dtb_b", "dtb_b.img")];
-        test_android_load_verify_fixup_v2_or_lower(0, 'b', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v1_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"dtb_slot", Some(b"a\0"))];
-        // V1 image doesn't have built-in dtb. We need to provide from dtb partition.
-        let parts = &[(c"dtb_a", "dtb_a.img")];
-        test_android_load_verify_fixup_v2_or_lower(1, 'a', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v1_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"dtb_slot", Some(b"a\0")),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a", "dtbo_a.img"), (c"dtb_a", "dtb_a.img")];
-        test_android_load_verify_fixup_v2_or_lower(1, 'a', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v1_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"dtb_slot", Some(b"b\0"))];
-        let parts = &[(c"dtb_b", "dtb_b.img")];
-        test_android_load_verify_fixup_v2_or_lower(1, 'b', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v1_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"dtb_slot", Some(b"b\0")),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b", "dtbo_b.img"), (c"dtb_b", "dtb_b.img")];
-        test_android_load_verify_fixup_v2_or_lower(1, 'b', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v2_slot_a() {
-        // V2 image has built-in dtb. We don't need to provide custom device tree.
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v2_or_lower(2, 'a', &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v2_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        test_android_load_verify_fixup_v2_or_lower(2, 'a', parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v2_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v2_or_lower(2, 'b', &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v2_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        test_android_load_verify_fixup_v2_or_lower(2, 'b', parts, fdt_prop);
-    }
-
-    /// Common helper for testing `android_load_verify_fixup` for v3/v4 boot image.
-    fn test_android_load_verify_fixup_v3_or_v4(
-        slot: char,
-        partitions: &[(CString, String)],
-        vbmeta_file: &str,
-        expected_vendor_bootconfig: &str,
-        additional_expected_fdt_properties: &[(&str, &CStr, Option<&[u8]>)],
-    ) {
-        let dtbo = partitions
-            .iter()
-            .any(|(name, _)| name.clone().into_string().unwrap().starts_with("dtbo_"));
-        let expected_ramdisk = [
-            read_test_data(format!("vendor_ramdisk_{slot}.img")),
-            read_test_data(format!("generic_ramdisk_{slot}.img")),
-        ]
-        .concat();
-        test_android_load_verify_fixup(
-            (u64::from(slot) - ('a' as u64)).try_into().unwrap(),
-            &partitions,
-            &read_test_data(format!("kernel_{slot}.img")),
-            &expected_ramdisk,
-            &make_expected_bootconfig(&vbmeta_file, slot, expected_vendor_bootconfig,
-                MakeExpectedBootconfigInclude { dtbo, dtb: false, ..Default::default() },
-                ),
-            "existing_arg_1=existing_val_1 existing_arg_2=existing_val_2 cmd_key_1=cmd_val_1,cmd_key_2=cmd_val_2 cmd_vendor_key_1=cmd_vendor_val_1,cmd_vendor_key_2=cmd_vendor_val_2",
-            additional_expected_fdt_properties,
-        )
-    }
-
-    /// Helper for testing `android_load_verify_fixup` for v3/v4 boot image without init_boot.
-    fn test_android_load_verify_fixup_v3_or_v4_no_init_boot(
-        boot_ver: u32,
-        vendor_ver: u32,
-        slot: char,
-        expected_vendor_bootconfig: &str,
-        additional_parts: &[(CString, String)],
-        additional_expected_fdt_properties: &[(&str, &CStr, Option<&[u8]>)],
-    ) {
-        let vbmeta = format!("vbmeta_v{boot_ver}_v{vendor_ver}_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (CString::new(format!("boot_{slot}")).unwrap(), format!("boot_v{boot_ver}_{slot}.img")),
-            (
-                CString::new(format!("vendor_boot_{slot}")).unwrap(),
-                format!("vendor_boot_v{vendor_ver}_{slot}.img"),
-            ),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        parts.extend_from_slice(additional_parts);
-        test_android_load_verify_fixup_v3_or_v4(
-            slot,
-            &parts,
-            &vbmeta,
-            expected_vendor_bootconfig,
-            additional_expected_fdt_properties,
-        );
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_no_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_no_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 3, 'a', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_no_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_no_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 3, 'b', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_no_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_no_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 3, 'a', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_no_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_no_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 3, 'b', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_no_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_no_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 4, 'a', config, parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_no_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_no_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(3, 4, 'b', config, parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_no_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_no_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 4, 'a', config, parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_no_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_no_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_no_init_boot(4, 4, 'b', config, parts, fdt_prop);
-    }
-
-    /// Helper for testing `android_load_verify_fixup` with dttable vendor_boot
-    fn test_android_load_verify_fixup_v4_vendor_boot_dttable(
-        slot: char,
-        expected_vendor_bootconfig: &str,
-        additional_parts: &[(CString, String)],
-        additional_expected_fdt_properties: &[(&str, &CStr, Option<&[u8]>)],
-    ) {
-        let vbmeta = format!("vbmeta_v4_dttable_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (CString::new(format!("boot_{slot}")).unwrap(), format!("boot_v4_{slot}.img")),
-            (
-                CString::new(format!("vendor_boot_{slot}")).unwrap(),
-                format!("vendor_boot_v4_dttable_{slot}.img"),
-            ),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        parts.extend_from_slice(additional_parts);
-        test_android_load_verify_fixup_v3_or_v4(
-            slot,
-            &parts,
-            &vbmeta,
-            expected_vendor_bootconfig,
-            additional_expected_fdt_properties,
-        );
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_no_init_boot_slot_dttable_vendor_boot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v4_vendor_boot_dttable('a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_no_init_boot_slot_dttable_vendor_boot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v4_vendor_boot_dttable('b', config, &[], fdt_prop);
-    }
-
-    /// Helper for testing `android_load_verify_fixup` for v3/v4 boot image with init_boot.
-    fn test_android_load_verify_fixup_v3_or_v4_init_boot(
-        boot_ver: u32,
-        vendor_ver: u32,
-        slot: char,
-        expected_vendor_bootconfig: &str,
-        additional_parts: &[(CString, String)],
-        additional_expected_fdt_properties: &[(&str, &CStr, Option<&[u8]>)],
-    ) {
-        let vbmeta = format!("vbmeta_v{boot_ver}_v{vendor_ver}_init_boot_{slot}.img");
-        let mut parts: Vec<(CString, String)> = vec![
-            (
-                CString::new(format!("boot_{slot}")).unwrap(),
-                format!("boot_no_ramdisk_v{boot_ver}_{slot}.img"),
-            ),
-            (
-                CString::new(format!("vendor_boot_{slot}")).unwrap(),
-                format!("vendor_boot_v{vendor_ver}_{slot}.img"),
-            ),
-            (CString::new(format!("init_boot_{slot}")).unwrap(), format!("init_boot_{slot}.img")),
-            (CString::new(format!("vbmeta_{slot}")).unwrap(), vbmeta.clone()),
-        ];
-        parts.extend_from_slice(additional_parts);
-        test_android_load_verify_fixup_v3_or_v4(
-            slot,
-            &parts,
-            &vbmeta,
-            expected_vendor_bootconfig,
-            additional_expected_fdt_properties,
-        );
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 3, 'a', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v3_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 3, 'b', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 3, 'a', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 3, 'a', "", &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v3_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 3, 'b', "", parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 4, 'a', config, parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v3_v4_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(3, 4, 'b', config, parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_init_boot_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_init_boot_dtbo_slot_a() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_a_property", Some(b"overlay_a_val\0")),
-        ];
-        let parts = &[(c"dtbo_a".into(), "dtbo_a.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 4, 'a', config, parts, fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_init_boot_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[("/chosen", c"builtin", Some(&[1]))];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 4, 'a', config, &[], fdt_prop);
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_v4_v4_init_boot_dtbo_slot_b() {
-        let fdt_prop: &[(&str, &CStr, Option<&[u8]>)] = &[
-            ("/chosen", c"builtin", Some(&[1])),
-            ("/chosen", c"overlay_b_property", Some(b"overlay_b_val\0")),
-        ];
-        let parts = &[(c"dtbo_b".into(), "dtbo_b.img".into())];
-        let config = TEST_VENDOR_BOOTCONFIG;
-        test_android_load_verify_fixup_v3_or_v4_init_boot(4, 4, 'b', config, parts, fdt_prop);
-    }
-
-    /// Helper for checking V2 image loaded from slot A and in normal mode.
-    pub(crate) fn checks_loaded_v2_slot_a_normal_mode(ramdisk: &[u8], kernel: &[u8]) {
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v2_a.img").len())
-            .digest(read_test_data_as_str("vbmeta_v2_a.digest.txt").strip_suffix("\n").unwrap())
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v2_a.boot.digest.txt").strip_suffix("\n").unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .extra("androidboot.force_normal_boot=1\n")
-            .extra(format!("androidboot.slot_suffix=_a\n"))
-            .extra("androidboot.gbl.version=0\n")
-            .extra(format!("androidboot.gbl.build_number={TEST_DEFAULT_BUILD_ID}\n"))
-            .extra(FakeGblOps::GBL_TEST_BOOTCONFIG)
-            .build();
-        check_ramdisk(ramdisk, &read_test_data("generic_ramdisk_a.img"), &expected_bootconfig);
-        assert_eq!(kernel, read_test_data("kernel_a.img"));
-    }
-
-    /// Helper for checking V2 image loaded from slot A and in recovery mode.
-    fn checks_loaded_v2_slot_a_recovery_mode(ramdisk: &[u8], kernel: &[u8]) {
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v2_a.img").len())
-            .digest(read_test_data_as_str("vbmeta_v2_a.digest.txt").strip_suffix("\n").unwrap())
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v2_a.boot.digest.txt").strip_suffix("\n").unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .extra(format!("androidboot.slot_suffix=_a\n"))
-            .extra("androidboot.gbl.version=0\n")
-            .extra(format!("androidboot.gbl.build_number={TEST_DEFAULT_BUILD_ID}\n"))
-            .extra(FakeGblOps::GBL_TEST_BOOTCONFIG)
-            .build();
-        check_ramdisk(ramdisk, &read_test_data("generic_ramdisk_a.img"), &expected_bootconfig);
-        assert_eq!(kernel, read_test_data("kernel_a.img"));
-    }
-
-    /// Helper for getting default FakeGblOps for tests.
-    pub(crate) fn default_test_gbl_ops(storage: &FakeGblOpsStorage) -> FakeGblOps {
-        let mut ops = FakeGblOps::new(&storage);
-        ops.avb_ops.unlock_state = Ok(false);
-        ops.avb_ops.rollbacks = HashMap::from([(TEST_ROLLBACK_INDEX_LOCATION, Ok(0))]);
-        ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Valid));
-        ops.current_slot = Some(Ok(slot('a')));
-        ops.reboot_reason = Some(Ok(RebootReason::Normal));
-        ops
-    }
-
-    #[test]
-    fn test_android_load_verify_fixup_recovery_mode() {
-        // Recovery mode is specified by the absence of bootconfig arg
-        // "androidboot.force_normal_boot=1\n" and therefore independent of image versions. We can
-        // pick any image version for test. Use v2 for simplicity.
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-
-        let mut ops = default_test_gbl_ops(&storage);
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) =
-            android_load_verify_fixup(&mut ops, 0, true, &mut load_buffer).unwrap();
-        checks_loaded_v2_slot_a_recovery_mode(ramdisk, kernel)
-    }
-
-    #[test]
-    fn test_android_main_bcb_normal_mode() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel)
-    }
-
-    #[test]
-    fn test_android_main_bcb_recovery_mode() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.write_to_partition_sync("misc", 0, &mut b"boot-recovery".to_vec()).unwrap();
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        checks_loaded_v2_slot_a_recovery_mode(ramdisk, kernel)
-    }
-
-    #[test]
-    fn test_android_main_reboot_reason_recovery_mode() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.reboot_reason = Some(Ok(RebootReason::Recovery));
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        checks_loaded_v2_slot_a_recovery_mode(ramdisk, kernel)
-    }
-
-    /// Helper for checking V2 image loaded from slot B and in normal mode.
-    pub(crate) fn checks_loaded_v2_slot_b_normal_mode(ramdisk: &[u8], kernel: &[u8]) {
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v2_b.img").len())
-            .digest(read_test_data_as_str("vbmeta_v2_b.digest.txt").strip_suffix("\n").unwrap())
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v2_b.boot.digest.txt").strip_suffix("\n").unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .extra("androidboot.force_normal_boot=1\n")
-            .extra(format!("androidboot.slot_suffix=_b\n"))
-            .extra("androidboot.gbl.version=0\n")
-            .extra(format!("androidboot.gbl.build_number={TEST_DEFAULT_BUILD_ID}\n"))
-            .extra(FakeGblOps::GBL_TEST_BOOTCONFIG)
-            .build();
-        check_ramdisk(ramdisk, &read_test_data("generic_ramdisk_b.img"), &expected_bootconfig);
-        assert_eq!(kernel, read_test_data("kernel_b.img"));
-    }
-
-    #[test]
-    fn test_android_main_slotted_gbl_slot_a() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        assert_eq!(ops.mark_boot_attempt_called, 0);
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel)
-    }
-
-    #[test]
-    fn test_android_main_slotless_gbl_slot_a() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.current_slot = Some(Err(Error::Unsupported));
-        ops.next_slot = Some(Ok(slot('a')));
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        assert_eq!(ops.mark_boot_attempt_called, 1);
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel)
-    }
-
-    #[test]
-    fn test_android_main_slotted_gbl_slot_b() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_b", read_test_data("boot_v2_b.img"));
-        storage.add_raw_device(c"vbmeta_b", read_test_data("vbmeta_v2_b.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.current_slot = Some(Ok(slot('b')));
-
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        assert_eq!(ops.mark_boot_attempt_called, 0);
-        checks_loaded_v2_slot_b_normal_mode(ramdisk, kernel)
-    }
-
-    #[test]
-    fn test_android_main_slotless_gbl_slot_b() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_b", read_test_data("boot_v2_b.img"));
-        storage.add_raw_device(c"vbmeta_b", read_test_data("vbmeta_v2_b.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.current_slot = Some(Err(Error::Unsupported));
-        ops.next_slot = Some(Ok(slot('b')));
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        assert_eq!(ops.mark_boot_attempt_called, 1);
-        checks_loaded_v2_slot_b_normal_mode(ramdisk, kernel);
-    }
-
-    #[test]
-    fn test_android_main_unsupported_slot_default_to_a() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.current_slot = Some(Err(Error::Unsupported));
-        ops.next_slot = Some(Err(Error::Unsupported));
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |_| {}).unwrap();
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel)
-    }
-
-    /// Helper for testing that fastboot mode is triggered.
-    fn test_fastboot_is_triggered<'a, 'b>(ops: &mut impl GblOps<'a, 'b>) {
-        let listener: SharedTestListener = Default::default();
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(ops, &mut load_buffer, |fb| {
-            listener.add_usb_input(b"getvar:max-fetch-size");
-            listener.add_usb_input(b"continue");
-            fb.run_n::<2>(
-                &mut vec![0u8; 256 * 1024],
-                Some(&mut TestLocalSession::default()),
-                Some(&listener),
-                Some(&listener),
-            )
-        })
-        .unwrap();
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(
-                &[b"OKAY0xffffffffffffffff", b"INFOSyncing storage...", b"OKAY",]
-            ),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel);
-    }
-
-    #[test]
-    fn test_android_main_bootonce_bootloader_bcb_command_is_cleared() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.write_to_partition_sync("misc", 0, &mut b"bootonce-bootloader".to_vec()).unwrap();
-        test_fastboot_is_triggered(&mut ops);
-
-        let mut bcb_buffer = [0u8; BootloaderMessage::SIZE_BYTES];
-        ops.read_from_partition_sync("misc", 0, &mut bcb_buffer[..]).unwrap();
-        let bcb = BootloaderMessage::from_bytes_ref(&bcb_buffer).unwrap();
-        assert_eq!(
-            bcb.boot_mode().unwrap(),
-            AndroidBootMode::Normal,
-            "BCB mode is expected to be cleared after bootonce-bootloader is handled"
-        );
-    }
-
-    #[test]
-    fn test_android_main_enter_fastboot_via_bcb() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.write_to_partition_sync("misc", 0, &mut b"bootonce-bootloader".to_vec()).unwrap();
-        test_fastboot_is_triggered(&mut ops);
-    }
-
-    #[test]
-    fn test_android_main_enter_fastboot_via_reboot_reason() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.reboot_reason = Some(Ok(RebootReason::Bootloader));
-        test_fastboot_is_triggered(&mut ops);
-    }
-
-    #[test]
-    fn test_android_main_enter_fastboot_via_should_stop_in_fastboot() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"boot_a", read_test_data("boot_v2_a.img"));
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.stop_in_fastboot = Some(Ok(true));
-        test_fastboot_is_triggered(&mut ops);
-    }
-
-    #[test]
-    fn test_android_main_fastboot_boot() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"vbmeta_a", read_test_data("vbmeta_v2_a.img"));
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.stop_in_fastboot = Some(Ok(true));
-        ops.current_slot = Some(Ok(slot('a')));
-
-        let listener: SharedTestListener = Default::default();
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = android_main(&mut ops, &mut load_buffer, |fb| {
-            let data = read_test_data(format!("boot_v2_a.img"));
-            listener.add_usb_input(format!("download:{:#x}", data.len()).as_bytes());
-            listener.add_usb_input(&data);
-            listener.add_usb_input(b"boot");
-            listener.add_usb_input(b"continue");
-            fb.run_n::<2>(
-                &mut vec![0u8; 256 * 1024],
-                Some(&mut TestLocalSession::default()),
-                Some(&listener),
-                Some(&listener),
-            )
-        })
-        .unwrap();
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"DATA00004000", b"OKAY", b"OKAYboot_command",]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel);
-    }
-
-    #[test]
-    fn test_android_main_reboot_if_set_active_to_different_slot() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"misc", vec![0u8; 4 * 1024 * 1024]);
-        let mut ops = default_test_gbl_ops(&storage);
-        ops.stop_in_fastboot = Some(Ok(true));
-        ops.current_slot = Some(Ok(slot('a')));
-
-        let listener: SharedTestListener = Default::default();
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        assert_eq!(
-            android_main(&mut ops, &mut load_buffer, |fb| {
-                listener.add_usb_input(b"set_active:b");
-                listener.add_usb_input(b"continue");
-                fb.run_n::<2>(
-                    &mut vec![0u8; 256 * 1024],
-                    Some(&mut TestLocalSession::default()),
-                    Some(&listener),
-                    Some(&listener),
-                )
-            })
-            .unwrap_err(),
-            Error::UnexpectedReturn.into()
-        );
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"OKAY", b"INFOSyncing storage...", b"OKAY",]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-}
diff --git a/gbl/libgbl/src/android_boot/vboot.rs b/gbl/libgbl/src/android_boot/vboot.rs
deleted file mode 100644
index 6da6185..0000000
--- a/gbl/libgbl/src/android_boot/vboot.rs
+++ /dev/null
@@ -1,599 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    gbl_avb::{
-        ops::{GblAvbOps, AVB_DIGEST_KEY},
-        state::{BootStateColor, KeyValidationStatus},
-    },
-    gbl_print, gbl_println, GblOps, Result,
-};
-use abr::SlotIndex;
-use arrayvec::ArrayVec;
-use avb::{slot_verify, HashtreeErrorMode, Ops as _, SlotVerifyFlags};
-use bootparams::{bootconfig::BootConfigBuilder, entry::CommandlineParser};
-use core::{ffi::CStr, fmt::Write};
-use liberror::Error;
-
-// Maximum number of partition allowed for verification.
-//
-// The value is randomly chosen for now. We can update it as we see more usecases.
-const MAX_NUM_PARTITION: usize = 16;
-
-// Type alias for ArrayVec of size `MAX_NUM_PARTITION`:
-type ArrayMaxParts<T> = ArrayVec<T, MAX_NUM_PARTITION>;
-
-/// A container holding partitions for libavb verification
-pub(crate) struct PartitionsToVerify<'a> {
-    partitions: ArrayMaxParts<&'a CStr>,
-    preloaded: ArrayMaxParts<(&'a str, &'a [u8])>,
-}
-
-impl<'a> PartitionsToVerify<'a> {
-    /// Appends a partition to verify
-    #[cfg(test)]
-    pub fn try_push(&mut self, name: &'a CStr) -> Result<()> {
-        self.partitions.try_push(name).or(Err(Error::TooManyPartitions(MAX_NUM_PARTITION)))?;
-        Ok(())
-    }
-
-    /// Appends a partition, along with its preloaded data
-    pub fn try_push_preloaded(&mut self, name: &'a CStr, data: &'a [u8]) -> Result<()> {
-        let err = Err(Error::TooManyPartitions(MAX_NUM_PARTITION));
-        self.partitions.try_push(name).or(err)?;
-        self.preloaded.try_push((name.to_str().unwrap(), data)).or(err)?;
-        Ok(())
-    }
-
-    /// Appends partitions, along with preloaded data
-    pub fn try_extend_preloaded(&mut self, partitions: &PartitionsToVerify<'a>) -> Result<()> {
-        let err = Err(Error::TooManyPartitions(MAX_NUM_PARTITION));
-        self.partitions.try_extend_from_slice(partitions.partitions()).or(err)?;
-        self.preloaded.try_extend_from_slice(partitions.preloaded()).or(err)?;
-        Ok(())
-    }
-
-    fn partitions(&self) -> &[&'a CStr] {
-        &self.partitions
-    }
-
-    fn preloaded(&self) -> &[(&'a str, &'a [u8])] {
-        &self.preloaded
-    }
-}
-
-impl<'a> Default for PartitionsToVerify<'a> {
-    fn default() -> Self {
-        Self { partitions: ArrayMaxParts::new(), preloaded: ArrayMaxParts::new() }
-    }
-}
-
-/// Android verified boot flow.
-///
-/// All relevant images from disk must be preloaded and provided as `partitions`; in its final
-/// state `ops` will provide the necessary callbacks for where the images should go in RAM and
-/// which ones are preloaded.
-///
-/// # Arguments
-/// * `ops`: [GblOps] providing device-specific backend.
-/// * `slot`: The slot index.
-/// * `partitions`: [PartitionsToVerify] providing pre-loaded partitions.
-/// * `bootconfig_builder`: object to write the bootconfig data into.
-///
-/// # Returns
-/// `()` on success. Returns an error if verification process failed and boot cannot
-/// continue, or if parsing the command line or updating the boot configuration fail.
-pub(crate) fn avb_verify_slot<'a, 'b, 'c>(
-    ops: &mut impl GblOps<'a, 'b>,
-    slot: u8,
-    partitions: &PartitionsToVerify<'c>,
-    bootconfig_builder: &mut BootConfigBuilder,
-) -> Result<()> {
-    let slot = match slot {
-        0 => SlotIndex::A,
-        1 => SlotIndex::B,
-        _ => {
-            gbl_println!(ops, "AVB: Invalid slot index: {slot}");
-            return Err(Error::InvalidInput.into());
-        }
-    };
-
-    let mut avb_ops = GblAvbOps::new(ops, Some(slot), partitions.preloaded(), false);
-    let unlocked = avb_ops.read_is_device_unlocked()?;
-    let verify_result = slot_verify(
-        &mut avb_ops,
-        partitions.partitions(),
-        Some(slot.into()),
-        // TODO(b/337846185): Pass AVB_SLOT_VERIFY_FLAGS_RESTART_CAUSED_BY_HASHTREE_CORRUPTION in
-        // case verity corruption is detected by HLOS.
-        match unlocked {
-            true => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,
-            _ => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-        },
-        // TODO(b/337846185): For demo, we use the same setting as Cuttlefish u-boot.
-        // Pass AVB_HASHTREE_ERROR_MODE_MANAGED_RESTART_AND_EIO and handle EIO.
-        HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_RESTART_AND_INVALIDATE,
-    );
-    let (color, verify_data) = match verify_result {
-        Ok(ref verify_data) => {
-            let color = match unlocked {
-                false
-                    if avb_ops.key_validation_status()? == KeyValidationStatus::ValidCustomKey =>
-                {
-                    BootStateColor::Yellow
-                }
-                false => BootStateColor::Green,
-                true => BootStateColor::Orange,
-            };
-
-            gbl_println!(
-                avb_ops.gbl_ops,
-                "AVB verification passed. Device is unlocked: {unlocked}. Color: {color}"
-            );
-
-            (color, Some(verify_data))
-        }
-        // Non-fatal error, can continue booting since verify_data is available.
-        Err(ref e) if e.verification_data().is_some() && unlocked => {
-            let color = BootStateColor::Orange;
-
-            gbl_println!(
-                avb_ops.gbl_ops,
-                "AVB verification failed with {e}. Device is unlocked: {unlocked}. Color: {color}. \
-                Continue current boot attempt."
-            );
-
-            (color, Some(e.verification_data().unwrap()))
-        }
-        // Fatal error. Cannot boot.
-        Err(ref e) => {
-            let color = BootStateColor::Red;
-
-            gbl_println!(
-                avb_ops.gbl_ops,
-                "AVB verification failed with {e}. Device is unlocked: {unlocked}. Color: {color}. \
-                Cannot continue boot."
-            );
-
-            (color, None)
-        }
-    };
-
-    // Gets digest from the result command line.
-    let mut digest = None;
-    if let Some(ref verify_data) = verify_data {
-        for entry in CommandlineParser::new(verify_data.cmdline().to_str().unwrap()) {
-            let entry = entry?;
-            if entry.key == AVB_DIGEST_KEY {
-                digest = entry.value;
-            }
-            write!(bootconfig_builder, "{}\n", entry).or(Err(Error::BufferTooSmall(None)))?;
-        }
-    }
-
-    // Allowes FW to handle verification result.
-    avb_ops.handle_verification_result(verify_data, color, digest)?;
-
-    match color {
-        BootStateColor::Red => Err(verify_result.unwrap_err().without_verify_data().into()),
-        _ => {
-            write!(bootconfig_builder, "androidboot.verifiedbootstate={}\n", color)
-                .or(Err(Error::BufferTooSmall(None)))?;
-
-            Ok(())
-        }
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::{
-        android_boot::load::tests::{
-            dump_bootconfig, make_bootconfig, read_test_data, read_test_data_as_str,
-            AvbResultBootconfigBuilder, TEST_PUBLIC_KEY_DIGEST,
-        },
-        ops::test::{FakeGblOps, FakeGblOpsStorage},
-        IntegrationError::AvbIoError,
-    };
-    use avb::{IoError, SlotVerifyError};
-    use std::{collections::HashMap, ffi::CStr};
-
-    /// Helper for testing avb_verify_slot
-    fn test_avb_verify_slot<'a>(
-        partitions: &[(&CStr, &str)],
-        partitions_to_verify: &PartitionsToVerify<'a>,
-        device_unlocked: std::result::Result<bool, avb::IoError>,
-        rollback_result: std::result::Result<u64, avb::IoError>,
-        slot: u8,
-        expected_reported_color: Option<BootStateColor>,
-        expected_bootconfig: &[u8],
-    ) -> Result<()> {
-        let mut storage = FakeGblOpsStorage::default();
-        for (part, file) in partitions {
-            storage.add_raw_device(part, read_test_data(file));
-        }
-        let mut ops = FakeGblOps::new(&storage);
-        ops.avb_ops.unlock_state = device_unlocked;
-        ops.avb_ops.rollbacks = HashMap::from([(1, rollback_result)]);
-        let mut out_color = None;
-        let mut handler = |color,
-                           _: Option<&CStr>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>,
-                           _: Option<&[u8]>| {
-            out_color = Some(color);
-            Ok(())
-        };
-        ops.avb_handle_verification_result = Some(&mut handler);
-        ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Valid));
-
-        let mut bootconfig_buffer = vec![0u8; 512 * 1024];
-        let mut bootconfig_builder = BootConfigBuilder::new(&mut bootconfig_buffer).unwrap();
-        let verify_result =
-            avb_verify_slot(&mut ops, slot, partitions_to_verify, &mut bootconfig_builder);
-        let bootconfig_bytes = bootconfig_builder.config_bytes();
-
-        assert_eq!(out_color, expected_reported_color);
-        assert_eq!(
-            bootconfig_bytes,
-            expected_bootconfig,
-            "\nexpect: \n{}\nactual: \n{}\n",
-            dump_bootconfig(expected_bootconfig),
-            dump_bootconfig(bootconfig_bytes),
-        );
-
-        verify_result
-    }
-
-    #[test]
-    fn test_avb_verify_slot_success() {
-        let mut partitions_to_verify = PartitionsToVerify::default();
-        partitions_to_verify.try_push(c"boot").unwrap();
-        partitions_to_verify.try_push(c"init_boot").unwrap();
-        partitions_to_verify.try_push(c"vendor_boot").unwrap();
-        let partitions_data = [
-            (c"boot_a", "boot_no_ramdisk_v4_a.img"),
-            (c"init_boot_a", "init_boot_a.img"),
-            (c"vendor_boot_a", "vendor_boot_v4_a.img"),
-            (c"vbmeta_a", "vbmeta_v4_v4_init_boot_a.img"),
-        ];
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v4_v4_init_boot_a.img").len())
-            .digest(
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "init_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.init_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "vendor_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .build();
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &partitions_data,
-                &partitions_to_verify,
-                // Unlocked result
-                Ok(false),
-                // Rollback index result
-                Ok(0),
-                // Slot
-                0,
-                // Expected color
-                Some(BootStateColor::Green),
-                // Expected bootcofnig
-                &expected_bootconfig,
-            ),
-            Ok(()),
-        );
-    }
-
-    #[test]
-    fn test_avb_verify_slot_from_preloaded_success() {
-        let boot = read_test_data("boot_no_ramdisk_v4_a.img");
-        let init_boot = read_test_data("init_boot_a.img");
-        let vendor_boot = read_test_data("vendor_boot_v4_a.img");
-
-        let mut partitions_to_verify = PartitionsToVerify::default();
-        partitions_to_verify.try_push_preloaded(c"boot", &boot).unwrap();
-        partitions_to_verify.try_push_preloaded(c"init_boot", &init_boot).unwrap();
-        partitions_to_verify.try_push_preloaded(c"vendor_boot", &vendor_boot).unwrap();
-        let partitions_data = [
-            // Required images aren't presented. Have to rely on preloaded.
-            (c"vbmeta_a", "vbmeta_v4_v4_init_boot_a.img"),
-        ];
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v4_v4_init_boot_a.img").len())
-            .digest(
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "init_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.init_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "vendor_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .build();
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &partitions_data,
-                &partitions_to_verify,
-                // Unlocked result
-                Ok(false),
-                // Rollback index result
-                Ok(0),
-                // Slot
-                0,
-                // Expected color
-                Some(BootStateColor::Green),
-                // Expected bootcofnig
-                &expected_bootconfig,
-            ),
-            Ok(()),
-        );
-    }
-
-    #[test]
-    fn test_avb_verify_slot_success_unlocked() {
-        let mut partitions_to_verify = PartitionsToVerify::default();
-        partitions_to_verify.try_push(c"boot").unwrap();
-        partitions_to_verify.try_push(c"init_boot").unwrap();
-        partitions_to_verify.try_push(c"vendor_boot").unwrap();
-        let partitions_data = [
-            (c"boot_a", "boot_no_ramdisk_v4_a.img"),
-            (c"init_boot_a", "init_boot_a.img"),
-            (c"vendor_boot_a", "vendor_boot_v4_a.img"),
-            (c"vbmeta_a", "vbmeta_v4_v4_init_boot_a.img"),
-        ];
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v4_v4_init_boot_a.img").len())
-            .digest(
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "init_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.init_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "vendor_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .color(BootStateColor::Orange)
-            .unlocked(true)
-            .build();
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &partitions_data,
-                &partitions_to_verify,
-                // Unlocked result
-                Ok(true),
-                // Rollback index result
-                Ok(0),
-                // Slot
-                0,
-                // Expected color
-                Some(BootStateColor::Orange),
-                // Expected bootconfig
-                &expected_bootconfig,
-            ),
-            Ok(()),
-        );
-    }
-
-    #[test]
-    fn test_avb_verify_slot_verification_failed_unlocked() {
-        let mut partitions_to_verify = PartitionsToVerify::default();
-        partitions_to_verify.try_push(c"boot").unwrap();
-        partitions_to_verify.try_push(c"init_boot").unwrap();
-        partitions_to_verify.try_push(c"vendor_boot").unwrap();
-        let partitions_data = [
-            (c"boot_a", "boot_no_ramdisk_v4_a.img"),
-            (c"init_boot_a", "init_boot_a.img"),
-            (c"vendor_boot_a", "vendor_boot_v4_a.img"),
-            (c"vbmeta_a", "vbmeta_v4_v4_init_boot_a.img"),
-        ];
-        let expected_bootconfig = AvbResultBootconfigBuilder::new()
-            .vbmeta_size(read_test_data("vbmeta_v4_v4_init_boot_a.img").len())
-            .digest(
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "init_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.init_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .partition_digest(
-                "vendor_boot",
-                read_test_data_as_str("vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt")
-                    .strip_suffix("\n")
-                    .unwrap(),
-            )
-            .public_key_digest(TEST_PUBLIC_KEY_DIGEST)
-            .color(BootStateColor::Orange)
-            .unlocked(true)
-            .build();
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &partitions_data,
-                &partitions_to_verify,
-                // Unlocked result
-                Ok(true),
-                // Rollback index result
-                Ok(0),
-                // Slot
-                0,
-                // Expected color
-                Some(BootStateColor::Orange),
-                // Expected bootconfig
-                &expected_bootconfig,
-            ),
-            // Device is unlocked, so can continue boot
-            Ok(()),
-        );
-    }
-
-    #[test]
-    fn test_avb_verify_slot_verification_fatal_failed_unlocked() {
-        let mut partitions_to_verify = PartitionsToVerify::default();
-        partitions_to_verify.try_push(c"boot").unwrap();
-        partitions_to_verify.try_push(c"init_boot").unwrap();
-        partitions_to_verify.try_push(c"vendor_boot").unwrap();
-        let partitions_data = [
-            (c"boot_a", "boot_no_ramdisk_v4_a.img"),
-            (c"init_boot_a", "init_boot_a.img"),
-            (c"vendor_boot_a", "vendor_boot_v4_a.img"),
-            (c"vbmeta_a", "vbmeta_v4_v4_init_boot_a.img"),
-        ];
-        let expected_bootconfig = make_bootconfig("");
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &partitions_data,
-                &partitions_to_verify,
-                // Unlocked result
-                Ok(true),
-                // Get rollback index is failed
-                Err(IoError::NoSuchValue),
-                // Slot
-                0,
-                // Expected color
-                Some(BootStateColor::Red),
-                // Expected bootconfig
-                &expected_bootconfig,
-            ),
-            // Fatal error, so cannot continue boot
-            Err(SlotVerifyError::Io.into()),
-        );
-    }
-
-    #[test]
-    fn test_avb_verify_slot_verification_failed_locked() {
-        let mut partitions_to_verify = PartitionsToVerify::default();
-        partitions_to_verify.try_push(c"boot").unwrap();
-        partitions_to_verify.try_push(c"init_boot").unwrap();
-        partitions_to_verify.try_push(c"vendor_boot").unwrap();
-        let partitions_data = [
-            // Wrong boot image, expect verification to fail.
-            (c"boot_a", "boot_v0_a.img"),
-            (c"init_boot_a", "init_boot_a.img"),
-            (c"vendor_boot_a", "vendor_boot_v4_a.img"),
-            (c"vbmeta_a", "vbmeta_v4_v4_init_boot_a.img"),
-        ];
-        let expected_bootconfig = make_bootconfig("");
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &partitions_data,
-                &partitions_to_verify,
-                // Unlocked result
-                Ok(false),
-                // Rollback index result
-                Ok(0),
-                // Slot
-                0,
-                // Expected color
-                Some(BootStateColor::Red),
-                // Expected bootconfig
-                &expected_bootconfig,
-            ),
-            // Cannot continue boot
-            Err(SlotVerifyError::Verification(None).into()),
-        );
-    }
-
-    #[test]
-    fn test_avb_verify_slot_verification_failed_obtain_lock_status() {
-        let partitions_to_verify = PartitionsToVerify::default();
-        let expected_bootconfig = make_bootconfig("");
-
-        assert_eq!(
-            test_avb_verify_slot(
-                &[],
-                &partitions_to_verify,
-                // Unlocked result
-                Err(avb::IoError::NoSuchValue),
-                // Rollback index result
-                Ok(0),
-                // Slot
-                0,
-                // Expected color
-                None,
-                // Expected bootconfig
-                &expected_bootconfig,
-            ),
-            // Cannot continue boot
-            Err(AvbIoError(IoError::NoSuchValue)),
-        );
-    }
-}
diff --git a/gbl/libgbl/src/boot_mode.rs b/gbl/libgbl/src/boot_mode.rs
deleted file mode 100644
index 4da1cf1..0000000
--- a/gbl/libgbl/src/boot_mode.rs
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Possible boot modes.
-
-// TODO: b/312605899 - find full list of supported boot modes
-// Looks like we need only compliant items from map: system/core/bootstat/bootstat.cpp
-// kBootReasonMap
-// It might be required to assemble this type in format: <reason>,<sub_reason>,<detil>,...
-// Bootloaders must provide a kernel set or a blunt set reason, and are strongly encouraged to
-// provide a subreason if it can be determined. For example, a power key long press that may or may
-// not have ramoops backup would have the boot reason "reboot,longkey".
-/* good reasons from kBootReasonMap
-{"reboot,[empty]", kEmptyBootReason},
-{"recovery", 3},
-{"reboot", 4},
-{"kernel_panic", 7},
-{"watchdog", 40},
-{"shutdown,", 45},  // Trailing comma is intentional. Do NOT use.
-{"shutdown,userrequested", 46},
-{"reboot,bootloader", 47},
-{"reboot,cold", 48},
-{"reboot,recovery", 49},
-{"kernel_panic,sysrq", 52},
-{"kernel_panic,null", 53},
-{"kernel_panic,bug", 54},
-{"bootloader", 55},
-{"cold", 56},
-{"hard", 57},
-{"warm", 58},
-{"reboot,kernel_power_off_charging__reboot_system", 59},  // Can not happen
-{"shutdown,thermal", 61},
-{"shutdown,battery", 62},
-{"reboot,ota", 63},
-{"reboot,factory_reset", 64},
-{"reboot,", 65},
-{"reboot,shell", 66},
-{"reboot,adb", 67},
-{"reboot,userrequested", 68},
-{"shutdown,container", 69},  // Host OS asking Android Container to shutdown
-{"cold,powerkey", 70},
-{"warm,s3_wakeup", 71},
-{"hard,hw_reset", 72},
-{"shutdown,suspend", 73},    // Suspend to RAM
-{"shutdown,hibernate", 74},  // Suspend to DISK
-{"reboot,by_key", 84},
-{"reboot,longkey", 85},
-{"reboot,2sec", 86},  // Deprecate in two years, replaced with cold,rtc,2sec
-{"shutdown,thermal,battery", 87},
-{"reboot,its_just_so_hard", 88},  // produced by boot_reason_test
-{"reboot,rescueparty", 90},
-{"reboot,powerloss", 119},
-{"reboot,undervoltage", 120},
-{"cold,charger", 148},
-{"cold,rtc", 149},
-{"cold,rtc,2sec", 150},   // Mediatek
-{"reboot,tool", 151},     // Mediatek
-{"reboot,wdt", 152},      // Mediatek
-{"reboot,unknown", 153},  // Mediatek
-{"kernel_panic,audit", 154},
-{"kernel_panic,atomic", 155},
-{"kernel_panic,hung", 156},
-{"kernel_panic,hung,rcu", 157},
-{"kernel_panic,init", 158},
-{"kernel_panic,oom", 159},
-{"kernel_panic,stack", 160},
-{"kernel_panic,sysrq,livelock,alarm", 161},   // llkd
-{"kernel_panic,sysrq,livelock,driver", 162},  // llkd
-{"kernel_panic,sysrq,livelock,zombie", 163},  // llkd
-{"kernel_panic,modem", 164},
-{"kernel_panic,adsp", 165},
-{"kernel_panic,dsps", 166},
-{"kernel_panic,wcnss", 167},
-{"kernel_panic,_sde_encoder_phys_cmd_handle_ppdone_timeout", 168},
-{"recovery,quiescent", 169},
-{"reboot,quiescent", 170},
-{"reboot,rtc", 171},
-{"reboot,dm-verity_device_corrupted", 172},
-{"reboot,dm-verity_enforcing", 173},
-{"reboot,keys_clear", 174},
-{"reboot,pmic_off_fault,.*", 175},
-{"reboot,pmic_off_s3rst,.*", 176},
-{"reboot,pmic_off_other,.*", 177},
-{"reboot,userrequested,fastboot", 178},
-{"reboot,userrequested,recovery", 179},
-{"reboot,userrequested,recovery,ui", 180},
-{"shutdown,userrequested,fastboot", 181},
-{"shutdown,userrequested,recovery", 182},
-{"reboot,unknown[0-9]*", 183},
-{"reboot,longkey,.*", 184},
-{"reboot,boringssl-self-check-failed", 185},
-{"reboot,userspace_failed,shutdown_aborted", 186},
-{"reboot,userspace_failed,watchdog_triggered", 187},
-{"reboot,userspace_failed,watchdog_fork", 188},
-{"reboot,userspace_failed,*", 189},
-{"reboot,mount_userdata_failed", 190},
-{"reboot,forcedsilent", 191},
-{"reboot,forcednonsilent", 192},
-{"reboot,thermal,tj", 193},
-{"reboot,emergency", 194},
-{"reboot,factory", 195},
-{"reboot,fastboot", 196},
-{"reboot,gsa,hard", 197},
-{"reboot,gsa,soft", 198},
-{"reboot,master_dc,fault_n", 199},
-{"reboot,master_dc,reset", 200},
-{"reboot,ocp", 201},
-{"reboot,pin", 202},
-{"reboot,rom_recovery", 203},
-{"reboot,uvlo", 204},
-{"reboot,uvlo,pmic,if", 205},
-{"reboot,uvlo,pmic,main", 206},
-{"reboot,uvlo,pmic,sub", 207},
-{"reboot,warm", 208},
-{"watchdog,aoc", 209},
-{"watchdog,apc", 210},
-{"watchdog,apc,bl,debug,early", 211},
-{"watchdog,apc,bl,early", 212},
-{"watchdog,apc,early", 213},
-{"watchdog,apm", 214},
-{"watchdog,gsa,hard", 215},
-{"watchdog,gsa,soft", 216},
-{"watchdog,pmucal", 217},
-{"reboot,early,bl", 218},
-{"watchdog,apc,gsa,crashed", 219},
-{"watchdog,apc,bl31,crashed", 220},
-{"watchdog,apc,pbl,crashed", 221},
-{"reboot,memory_protect,hyp", 222},
-{"reboot,tsd,pmic,main", 223},
-{"reboot,tsd,pmic,sub", 224},
-{"reboot,ocp,pmic,main", 225},
-{"reboot,ocp,pmic,sub", 226},
-{"reboot,sys_ldo_ok,pmic,main", 227},
-{"reboot,sys_ldo_ok,pmic,sub", 228},
-{"reboot,smpl_timeout,pmic,main", 229},
-{"reboot,ota,.*", 230},
-{"reboot,periodic,.*", 231},
-*/
-
-/// Boot mode
-///
-/// This is subset of compliant tems from map: system/core/bootstat/bootstat.cpp kBootReasonMap
-// Underlying format is <reason>,<sub_reason>,<detil>,...
-#[derive(Debug, PartialEq, Copy, Clone)]
-pub enum BootMode {
-    /// Normal system start
-    Normal,
-    /// Recovery mode
-    Recovery,
-    /// Request to boot into bootloader mode staying in CMD-line or fastboot mode.
-    Bootloader,
-    // TODO: b/312605899 - need full list of supported modes
-    // Quiescent,
-}
diff --git a/gbl/libgbl/src/boot_reason.rs b/gbl/libgbl/src/boot_reason.rs
deleted file mode 100644
index e4559e6..0000000
--- a/gbl/libgbl/src/boot_reason.rs
+++ /dev/null
@@ -1,69 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Possible boot reasons.
-
-use core::fmt::{Debug, Display, Formatter};
-
-#[derive(Debug, PartialEq, Clone)]
-/// Boot reasons that could be used in [BootMode]
-pub enum KnownBootReason {
-    // kernel
-    /// Watchdog
-    Watchdog,
-    /// Kerner panic
-    KernelPanic,
-    // strong
-    /// Recovery
-    Recovery,
-    /// Bootloader
-    Bootloader,
-    // blunt
-    /// Generally indicates a full reset of all devices, including memory
-    Cold,
-    /// Generally indicates the hardware has its state reset and ramoops should retain persistent
-    /// content
-    Hard,
-    /// Generally indicates the memory and the devices retain some state, and the ramoops (see
-    /// pstore driver in kernel) backing store contains persistent content
-    Warm,
-    // super blunt
-    /// Shutdown
-    Shutdown,
-    /// Generally means the ramoops state is unknown and the hardware state is unknown. This value
-    /// is a catchall as the cold, hard, and warm values provide clues as to the depth of the reset
-    /// for the device
-    Reboot,
-}
-
-impl Display for KnownBootReason {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        let str = match self {
-            // kernel
-            KnownBootReason::Watchdog => "watchdog",
-            KnownBootReason::KernelPanic => "kernel_panic",
-            // strong
-            KnownBootReason::Recovery => "recovery",
-            KnownBootReason::Bootloader => "bootloader",
-            // blunt
-            KnownBootReason::Cold => "cold",
-            KnownBootReason::Hard => "hard",
-            KnownBootReason::Warm => "warm",
-            // super blunt
-            KnownBootReason::Shutdown => "shutdown",
-            KnownBootReason::Reboot => "reboot",
-        };
-        write!(f, "{str}")
-    }
-}
diff --git a/gbl/libgbl/src/constants.rs b/gbl/libgbl/src/constants.rs
deleted file mode 100644
index 03ff4f5..0000000
--- a/gbl/libgbl/src/constants.rs
+++ /dev/null
@@ -1,111 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides common constants that are used in GBL
-
-// TODO(b/380392958) Cleanup other used of the constants. Move them here as well.
-
-use core::fmt::{Debug, Display, Formatter};
-use liberror::Error;
-use static_assertions::const_assert_eq;
-
-/// Macro for defining Kibibyte-sized constants
-#[macro_export]
-macro_rules! KiB  (
-    ($x:expr) => {
-        $x*1024
-    }
-);
-const_assert_eq!(KiB!(1), 1024);
-const_assert_eq!(KiB!(5), 5 * 1024);
-
-/// Macro for defining Mebibyte-sized constants
-#[macro_export]
-macro_rules! MiB  (
-    ($x:expr) => {
-        $x*KiB!(1024)
-    }
-);
-const_assert_eq!(MiB!(1), 1024 * 1024);
-const_assert_eq!(MiB!(5), 5 * 1024 * 1024);
-
-pub use KiB;
-pub use MiB;
-
-/// Kernel image alignment requirement.
-pub const KERNEL_ALIGNMENT: usize = MiB!(2);
-
-/// Zircon Kernel image alignment requirement.
-pub const ZIRCON_KERNEL_ALIGNMENT: usize = KiB!(64);
-
-/// FDT image alignment requirement.
-pub const FDT_ALIGNMENT: usize = 8;
-
-/// Expected max size for BootCmd zbi item.
-pub const BOOTCMD_SIZE: usize = KiB!(16);
-
-/// Page size
-pub const PAGE_SIZE: usize = KiB!(4);
-
-/// Image names list.
-/// Used for identifying what buffer size/alignment is necessary.
-#[derive(Debug, PartialEq, Clone)]
-pub enum ImageName {
-    /// ZBI for Zircon kernel
-    ZbiZircon,
-    /// ZBI items
-    ZbiItems,
-    /// Boot
-    Boot,
-    /// FDT
-    Fdt,
-}
-
-impl ImageName {
-    /// Get alignment required for the [ImageName]
-    pub fn alignment(&self) -> usize {
-        match self {
-            Self::ZbiZircon => ZIRCON_KERNEL_ALIGNMENT,
-            Self::ZbiItems => PAGE_SIZE,
-            Self::Boot => KERNEL_ALIGNMENT,
-            Self::Fdt => FDT_ALIGNMENT,
-        }
-    }
-}
-
-impl Display for ImageName {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        let str = match self {
-            ImageName::ZbiZircon => "zbi_zircon",
-            ImageName::ZbiItems => "zbi_items",
-            ImageName::Boot => "boot",
-            ImageName::Fdt => "fdt",
-        };
-        write!(f, "{str}")
-    }
-}
-
-impl TryFrom<&str> for ImageName {
-    type Error = Error;
-
-    fn try_from(value: &str) -> Result<Self, Self::Error> {
-        Ok(match value {
-            "zbi_zircon" => ImageName::ZbiZircon,
-            "zbi_items" => ImageName::ZbiItems,
-            "boot" => ImageName::Boot,
-            "fdt" => ImageName::Fdt,
-            _ => return Err(Error::InvalidInput),
-        })
-    }
-}
diff --git a/gbl/libgbl/src/decompress.rs b/gbl/libgbl/src/decompress.rs
deleted file mode 100644
index 5db9815..0000000
--- a/gbl/libgbl/src/decompress.rs
+++ /dev/null
@@ -1,196 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Image decompression support.
-
-// gzip [DeflateDecoder] requires heap allocation.
-extern crate alloc;
-
-use crate::{gbl_print, gbl_println, GblOps};
-use liberror::{Error, Result};
-use lz4_flex::decompress_into;
-use zune_inflate::DeflateDecoder;
-
-const LZ4_NEXT_BLOCK_FAILED_ERROR_MESSAGE: &str =
-    "Failed to handle next block of lz4-compressed kernel";
-
-/// Returns if the data is a gzip compressed data.
-fn is_gzip_compressed(data: &[u8]) -> bool {
-    data.starts_with(b"\x1f\x8b")
-}
-
-/// Returns if the data is a lz4 compressed data.
-fn is_lz4_compressed(data: &[u8]) -> bool {
-    data.starts_with(b"\x02\x21\x4c\x18")
-}
-
-/// To iterate over compressed blocks within lz4 structure.
-struct LZ4BlocksIterator<'a> {
-    data: &'a [u8],
-}
-
-impl<'a> LZ4BlocksIterator<'a> {
-    /// Creates a new iterator from lz4 payload.
-    fn new(data: &'a [u8]) -> Self {
-        LZ4BlocksIterator { data }
-    }
-}
-
-impl<'a> Iterator for LZ4BlocksIterator<'a> {
-    type Item = Result<&'a [u8]>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.data.is_empty() {
-            return None;
-        }
-
-        let Some((block_size, data)) = self.data.split_at_checked(4) else {
-            return Some(Err(Error::Other(Some(LZ4_NEXT_BLOCK_FAILED_ERROR_MESSAGE))));
-        };
-        self.data = data;
-
-        let block_size = u32::from_le_bytes(block_size.try_into().unwrap()).try_into().unwrap();
-        // Hit end marker
-        if block_size == 0 {
-            return None;
-        }
-
-        let Some((block_content, data)) = self.data.split_at_checked(block_size) else {
-            return Some(Err(Error::Other(Some(LZ4_NEXT_BLOCK_FAILED_ERROR_MESSAGE))));
-        };
-        self.data = data;
-
-        Some(Ok(block_content))
-    }
-}
-
-/// Decompresses lz4 `content` into `out`.
-fn decompress_lz4(content: &[u8], out: &mut [u8]) -> Result<usize> {
-    let blocks = LZ4BlocksIterator::new(content);
-    let mut out_pos = 0;
-
-    for block in blocks {
-        match block {
-            Ok(block) => {
-                out_pos += decompress_into(&block, &mut out[out_pos..])
-                    .map_err(|_| Error::Other(Some("Failed to decompress lz4 block")))?;
-            }
-            Err(e) => {
-                return Err(e);
-            }
-        }
-    }
-
-    Ok(out_pos)
-}
-
-/// Decompresses gzip `content` into `out`.
-///
-/// Dynamic allocation is used insize `decoder.decode_gzip()`.
-fn decompress_gzip(content: &[u8], out: &mut [u8]) -> Result<usize> {
-    let mut decoder = DeflateDecoder::new(content);
-
-    let decompressed_data =
-        decoder.decode_gzip().map_err(|_| Error::Other(Some("Failed to decompress gzip data")))?;
-
-    let decompressed_len = decompressed_data.len();
-    out.get_mut(..decompressed_len)
-        .ok_or(Error::BufferTooSmall(Some(decompressed_len)))?
-        .clone_from_slice(&decompressed_data);
-
-    Ok(decompressed_len)
-}
-
-/// Decompresses `kernel` into `out`.
-///
-/// Supported formats: gzip, lz4, and plain (uncompressed).
-/// If the provided `kernel` is not compressed, it will be copied into `out`
-/// without decompression.
-///
-/// Returns the size of the decompressed data copied into `out`.
-pub fn decompress_kernel<'a, 'b>(
-    ops: &mut impl GblOps<'a, 'b>,
-    kernel: &[u8],
-    out: &mut [u8],
-) -> Result<usize> {
-    if is_gzip_compressed(kernel) {
-        gbl_println!(ops, "kernel is gzip compressed");
-        let decompressed = decompress_gzip(kernel, out)?;
-        gbl_println!(ops, "kernel decompressed size: {decompressed}");
-        Ok(decompressed)
-    } else if is_lz4_compressed(kernel) {
-        gbl_println!(ops, "kernel is lz4 compressed");
-        let without_magic = &kernel[4..];
-        let decompressed = decompress_lz4(without_magic, out)?;
-        gbl_println!(ops, "kernel decompressed size: {decompressed}");
-        Ok(decompressed)
-    } else {
-        // Uncompressed case. Just copy into out.
-        out.get_mut(..kernel.len())
-            .ok_or(Error::BufferTooSmall(Some(kernel.len())))?
-            .clone_from_slice(kernel);
-        Ok(kernel.len())
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::ops::test::FakeGblOps;
-
-    // Asserts byte slice equality with clear error on first mismatch.
-    // Avoids full data dump from default assert, which can be very verbose.
-    fn assert_bytes_eq(actual: &[u8], expected: &[u8]) {
-        assert_eq!(actual.len(), expected.len());
-
-        for (i, (l, r)) in expected.iter().zip(actual.iter()).enumerate() {
-            assert_eq!(l, r, "Unmatched byte at index {i}")
-        }
-    }
-
-    fn test_decompress_kernel(input: &[u8], expected_output: &[u8]) {
-        let mut output_buffer = vec![0u8; input.len() * 10];
-
-        let decompressed_len =
-            decompress_kernel(&mut FakeGblOps::default(), input, &mut output_buffer).unwrap();
-
-        assert_bytes_eq(&output_buffer[..decompressed_len], expected_output);
-    }
-
-    #[test]
-    fn decompress_kernel_gzip() {
-        let compressed_gzip = include_bytes!("../testdata/android/gki_boot_gz_kernel").to_vec();
-        let expected_result =
-            include_bytes!("../testdata/android/gki_boot_gz_kernel_uncompressed").to_vec();
-
-        test_decompress_kernel(&compressed_gzip, &expected_result);
-    }
-
-    #[test]
-    fn decompress_kernel_lz4() {
-        let compressed_gzip = include_bytes!("../testdata/android/gki_boot_lz4_kernel").to_vec();
-        let expected_result =
-            include_bytes!("../testdata/android/gki_boot_lz4_kernel_uncompressed").to_vec();
-
-        test_decompress_kernel(&compressed_gzip, &expected_result);
-    }
-
-    #[test]
-    fn decompress_kernel_raw() {
-        let kernel = include_bytes!("../testdata/android/kernel_a.img").to_vec();
-        let expected_kernel = kernel.clone();
-
-        test_decompress_kernel(&kernel, &expected_kernel);
-    }
-}
diff --git a/gbl/libgbl/src/device_tree.rs b/gbl/libgbl/src/device_tree.rs
deleted file mode 100644
index 0d5a0fb..0000000
--- a/gbl/libgbl/src/device_tree.rs
+++ /dev/null
@@ -1,641 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! GblOps trait that defines device tree components helpers.
-
-use crate::{constants::FDT_ALIGNMENT, gbl_print, gbl_println, GblOps};
-use arrayvec::ArrayVec;
-use dttable::{DtTableImage, DtTableMetadata};
-use fdt::{Fdt, FdtHeader, FDT_HEADER_SIZE};
-use liberror::{Error, Result};
-use libutils::aligned_subslice;
-
-/// Maximum amount of device tree components GBL can handle to select from.
-/// TODO(b/353272981): Use dynamic memory to store components. Currently
-/// DeviceTreeComponentsRegistry takes about 18kb of stack, which can be slow and dangerous.
-pub const MAXIMUM_DEVICE_TREE_COMPONENTS: usize = 256;
-/// Error message to fail in case of unsupported amount of device tree components.
-pub const MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG: &str =
-    "At most 256 device components are supported to build the final one";
-
-/// The source device tree component is coming from.
-#[derive(Copy, Clone, Eq, PartialEq, Debug)]
-pub enum DeviceTreeComponentSource {
-    /// Loaded from Boot partition.
-    Boot,
-    /// Loaded from Vendor Boot partition.
-    VendorBoot,
-    /// Loaded from DTB partition.
-    Dtb,
-    /// Loaded from DTBO partition.
-    Dtbo,
-}
-
-impl core::fmt::Display for DeviceTreeComponentSource {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        match self {
-            DeviceTreeComponentSource::Boot => write!(f, "Boot"),
-            DeviceTreeComponentSource::VendorBoot => write!(f, "VendorBoot"),
-            DeviceTreeComponentSource::Dtb => write!(f, "Dtb"),
-            DeviceTreeComponentSource::Dtbo => write!(f, "Dtbo"),
-        }
-    }
-}
-
-/// Device tree component (device tree or overlay) to build the final one.
-#[derive(Copy, Clone, Eq, PartialEq, Debug)]
-pub struct DeviceTreeComponent<'a> {
-    /// Source the component is loaded from.
-    pub source: DeviceTreeComponentSource,
-    /// Metadata for entries loaded from dt_table structure.
-    pub metadata: Option<DtTableMetadata>,
-    /// Device tree component payload. Must be 8 bytes aligned.
-    pub dt: &'a [u8],
-    /// Device tree component is selected.
-    pub selected: bool,
-}
-
-/// Maintain, select and get the device tree components to build the final device tree.
-pub struct DeviceTreeComponentsRegistry<'a> {
-    components: ArrayVec<DeviceTreeComponent<'a>, MAXIMUM_DEVICE_TREE_COMPONENTS>,
-    /// `selected_overlays` array is used to return selected overlays as a sequential reference
-    /// slice. It must only be used within the `selected()` method and must not be assumed
-    /// valid elsewhere.
-    selected_overlays: ArrayVec<&'a [u8], MAXIMUM_DEVICE_TREE_COMPONENTS>,
-}
-
-impl<'a> DeviceTreeComponent<'a> {
-    /// Whether device tree component is base device tree or overlay.
-    pub fn is_base_device_tree(&self) -> bool {
-        matches!(
-            self.source,
-            DeviceTreeComponentSource::Boot
-                | DeviceTreeComponentSource::VendorBoot
-                | DeviceTreeComponentSource::Dtb
-        )
-    }
-}
-
-fn try_dt_totalsize_from_unaligned_bytes_ref(header: &[u8], buffer: &mut [u8]) -> Result<usize> {
-    let aligned_buffer = aligned_subslice(buffer, FDT_ALIGNMENT)?;
-    let header_slice = aligned_buffer
-        .get_mut(..FDT_HEADER_SIZE)
-        .ok_or(Error::BufferTooSmall(Some(FDT_HEADER_SIZE)))?;
-
-    // Fdt header must be aligned, so copy to an aligned buffer.
-    header_slice.copy_from_slice(
-        &header.get(..FDT_HEADER_SIZE).ok_or(Error::BufferTooSmall(Some(FDT_HEADER_SIZE)))?,
-    );
-
-    match FdtHeader::from_bytes_ref(&header_slice) {
-        Ok(header) => Ok(header.totalsize()),
-        Err(e) => Err(e),
-    }
-}
-
-impl<'a> DeviceTreeComponentsRegistry<'a> {
-    /// Create new empty DeviceTreeComponentsRegistry.
-    pub fn new() -> Self {
-        DeviceTreeComponentsRegistry {
-            components: ArrayVec::new(),
-            selected_overlays: ArrayVec::new(),
-        }
-    }
-
-    /// Load device tree components from a dt table image. Ensure components are 8 bytes
-    /// aligned by using provided buffer to cut from. Returns remain buffer.
-    pub fn append_from_dttable<'b>(
-        &mut self,
-        source: DeviceTreeComponentSource,
-        dttable: &DtTableImage<'b>,
-        buffer: &'a mut [u8],
-    ) -> Result<&'a mut [u8]> {
-        if dttable.entries_count() > self.components.remaining_capacity() {
-            return Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)));
-        }
-
-        let mut remains = buffer;
-        for entry in dttable.entries() {
-            // TODO(b/374336105): Find a better way to handle 8-bytes alignment rather than copy.
-            let (aligned_buffer, rest) = aligned_subslice(remains, FDT_ALIGNMENT)?
-                .split_at_mut_checked(entry.dtb.len())
-                .ok_or(Error::Other(Some(
-                    "Provided buffer is too small to ensure dttable entry is aligned",
-                )))?;
-            aligned_buffer.copy_from_slice(entry.dtb);
-
-            self.components.push(DeviceTreeComponent {
-                source: source,
-                metadata: Some(entry.metadata),
-                dt: aligned_buffer,
-                selected: false,
-            });
-
-            remains = rest;
-        }
-
-        Ok(remains)
-    }
-
-    /// Append additional device trees from the buffer, where they are stored sequentially.
-    /// Ensure components are 8 bytes aligned by using provided buffer to cut from. Returns remain
-    /// buffer.
-    /// TODO(b/363244924): Remove after partners migrated to DTB.
-    fn append_from_multifdt_buffer<'b, 'c>(
-        &mut self,
-        ops: &mut impl GblOps<'b, 'c>,
-        source: DeviceTreeComponentSource,
-        data: &'a [u8],
-        buffer: &'a mut [u8],
-    ) -> Result<&'a mut [u8]> {
-        let mut components_added = 0;
-        let mut data_remains = data;
-        let mut buffer_remains = buffer;
-
-        while let Ok(next_fdt_size) =
-            try_dt_totalsize_from_unaligned_bytes_ref(data_remains, buffer_remains)
-        {
-            if self.components.is_full() {
-                return Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)));
-            }
-
-            // Cut fdt and temporary buffers to make sure result fdt is 8 bytes aligned
-            let (data_buffer, data_buffer_remains) =
-                data_remains.split_at_checked(next_fdt_size).ok_or(Error::Other(Some(
-                    "Multidt structure has a valid header but doesn't have a device tree payload",
-                )))?;
-            let aligned_buffer = aligned_subslice(buffer_remains, FDT_ALIGNMENT)?;
-            let (aligned_buffer, aligned_buffer_remains) =
-                aligned_buffer.split_at_mut_checked(next_fdt_size).ok_or(Error::Other(Some(
-                    "Provided buffer is too small to ensure multidt entry is aligned",
-                )))?;
-            aligned_buffer.copy_from_slice(data_buffer);
-
-            Fdt::new(&aligned_buffer)?;
-            self.components.push(DeviceTreeComponent {
-                source: source,
-                metadata: None,
-                dt: &aligned_buffer[..],
-                selected: false,
-            });
-
-            components_added += 1;
-            data_remains = data_buffer_remains;
-            buffer_remains = aligned_buffer_remains;
-        }
-
-        if components_added > 0 {
-            gbl_println!(
-                ops,
-                "WARNING: {} additional device trees detected in {}. This is only temporarily \
-                supported in GBL. Please migrate to the DTB partition to provide multiple device \
-                trees for selection.",
-                components_added,
-                source,
-            );
-        }
-
-        Ok(buffer_remains)
-    }
-
-    /// Append device tree components from provided buffer prefix. `fdt` must be a 8 bytes aligned
-    /// valid fdt buffer. `fdt` may also have multiple fdt buffers placed sequentially. Ensure each
-    /// of such components are 8 bytes aligned by using provided `buffer` to cut from. Returns
-    /// remain buffer.
-    /// TODO(b/363244924): Remove multiple fdt support after partners migrated to DTB.
-    pub fn append<'b, 'c>(
-        &mut self,
-        ops: &mut impl GblOps<'b, 'c>,
-        source: DeviceTreeComponentSource,
-        fdt: &'a [u8],
-        buffer: &'a mut [u8],
-    ) -> Result<&'a mut [u8]> {
-        if self.components.is_full() {
-            return Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)));
-        }
-
-        let header = FdtHeader::from_bytes_ref(fdt)?;
-        let (fdt_buffer, fdt_remains) = fdt.split_at(header.totalsize());
-        self.components.push(DeviceTreeComponent {
-            source: source,
-            metadata: None,
-            dt: fdt_buffer,
-            selected: false,
-        });
-
-        // TODO(b/363244924): Remove after partners migrated to DTB.
-        self.append_from_multifdt_buffer(ops, source, fdt_remains, buffer)
-    }
-
-    /// Default implementation of selected logic in case external one isn't provided.
-    /// Only base device tree is supported to choose from. Otherwise fail. No overlays will be
-    /// selected.
-    pub fn autoselect(&mut self) -> Result<()> {
-        let base_device_tree_count =
-            self.components.iter().filter(|component| component.is_base_device_tree()).count();
-        if base_device_tree_count > 1 {
-            return Err(Error::Other(Some(
-                "Base device tree autoselection isn't supported if multiple device trees are \
-                provided",
-            )));
-        }
-
-        let base = self
-            .components
-            .iter_mut()
-            .find(|component| component.is_base_device_tree())
-            .ok_or(Error::Other(Some("0 base device trees to autoselect from")))?;
-        base.selected = true;
-
-        Ok(())
-    }
-
-    /// Return selected base device tree and overlays to apply. Fail in case selection isn't
-    /// correct. For correctness rules refer to `GblOps.select_device_trees` requirements.
-    pub fn selected(&mut self) -> Result<(&[u8], &[&[u8]])> {
-        let base_device_tree_count = self
-            .components
-            .iter()
-            .filter(|component| component.is_base_device_tree() && component.selected)
-            .count();
-        if base_device_tree_count > 1 {
-            return Err(Error::Other(Some("More than 1 base device tree is selected")));
-        }
-
-        let base = self
-            .components
-            .iter()
-            .find(|component| component.is_base_device_tree() && component.selected)
-            .ok_or(Error::Other(Some("0 base device trees are selected")))?;
-
-        self.selected_overlays = self
-            .components
-            .iter()
-            .filter(|component| !component.is_base_device_tree() && component.selected)
-            .map(|component| component.dt)
-            .collect();
-
-        Ok((base.dt, &self.selected_overlays[..]))
-    }
-
-    /// Iterator over components.
-    pub fn components(&self) -> impl Iterator<Item = &DeviceTreeComponent<'a>> {
-        self.components.iter()
-    }
-
-    /// Mutable iterator over components.
-    pub fn components_mut(&mut self) -> impl Iterator<Item = &mut DeviceTreeComponent<'a>> {
-        self.components.iter_mut()
-    }
-}
-
-#[cfg(test)]
-pub(crate) mod test {
-    use super::*;
-    use crate::ops::test::FakeGblOps;
-
-    #[test]
-    fn test_components_registry_empty() {
-        let registry = DeviceTreeComponentsRegistry::new();
-
-        assert_eq!(registry.components().count(), 0);
-    }
-
-    #[test]
-    fn test_components_registry_append_component() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], &mut buffer)
-            .unwrap();
-
-        assert_eq!(registry.components().count(), 1);
-
-        let component = registry.components().next().unwrap();
-
-        assert_eq!(
-            component,
-            &DeviceTreeComponent {
-                source: DeviceTreeComponentSource::Boot,
-                metadata: None,
-                dt: &dt[..],
-                selected: false,
-            }
-        );
-        assert!(component.is_base_device_tree());
-    }
-
-    #[test]
-    fn test_components_registry_append_component_with_tail() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let dt_with_tail = [dt.clone(), vec![0; 100]].concat();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt_with_tail[..], &mut buffer)
-            .unwrap();
-
-        assert_eq!(registry.components().count(), 1);
-
-        let component = registry.components().next().unwrap();
-
-        assert_eq!(
-            component,
-            &DeviceTreeComponent {
-                source: DeviceTreeComponentSource::Boot,
-                metadata: None,
-                dt: &dt[..],
-                selected: false,
-            }
-        );
-        assert!(component.is_base_device_tree());
-    }
-
-    #[test]
-    fn test_components_registry_append_too_many_components() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let mut current_buffer = &mut buffer[..];
-        // Fill the whole reserved space
-        for _ in 0..MAXIMUM_DEVICE_TREE_COMPONENTS {
-            current_buffer = registry
-                .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], current_buffer)
-                .unwrap();
-        }
-
-        assert_eq!(
-            registry.append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], current_buffer),
-            Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)))
-        );
-    }
-
-    #[test]
-    fn test_components_append_from_dttable() {
-        let dttable = include_bytes!("../../libdttable/test/data/dttable.img").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
-        registry
-            .append_from_dttable(DeviceTreeComponentSource::Dtbo, &table, &mut buffer[..])
-            .unwrap();
-
-        // Check data is loaded
-        let components: Vec<_> = registry.components().cloned().collect();
-        let expected_components: Vec<DeviceTreeComponent> = table
-            .entries()
-            .map(|e| DeviceTreeComponent {
-                source: DeviceTreeComponentSource::Dtbo,
-                metadata: Some(e.metadata),
-                dt: e.dtb,
-                selected: false,
-            })
-            .collect();
-        assert_eq!(components, expected_components);
-
-        // Check data is aligned
-        registry.components().for_each(|c| assert!(c.dt.as_ptr().align_offset(FDT_ALIGNMENT) == 0));
-    }
-
-    #[test]
-    fn test_components_returns_selected() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let sources = [
-            DeviceTreeComponentSource::VendorBoot,
-            DeviceTreeComponentSource::Boot,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-        ];
-        let mut current_buffer = &mut buffer[..];
-        for source in sources.iter() {
-            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
-        }
-
-        // Select base device tree
-        registry.components_mut().nth(1).unwrap().selected = true;
-        // Select first overlay
-        registry.components_mut().nth(2).unwrap().selected = true;
-        // Select second overlay
-        registry.components_mut().nth(3).unwrap().selected = true;
-
-        let expected_overlays =
-            &[registry.components().nth(2).unwrap().dt, registry.components().nth(3).unwrap().dt];
-        // Expected selected data
-        let expected_selected = (registry.components().nth(1).unwrap().dt, &expected_overlays[..]);
-
-        assert_eq!(registry.selected().unwrap(), expected_selected);
-    }
-
-    #[test]
-    fn test_components_returns_selected_no_overlays() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let sources = [
-            DeviceTreeComponentSource::VendorBoot,
-            DeviceTreeComponentSource::Boot,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-        ];
-        let mut current_buffer = &mut buffer[..];
-        for source in sources.iter() {
-            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
-        }
-
-        // Select base device tree
-        registry.components_mut().nth(1).unwrap().selected = true;
-
-        // Expected selected data
-        let expected_selected = (registry.components().nth(1).unwrap().dt, &[][..]);
-
-        assert_eq!(registry.selected().unwrap(), expected_selected);
-    }
-
-    #[test]
-    fn test_components_returns_no_base_device_tree_failed() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let sources = [
-            DeviceTreeComponentSource::VendorBoot,
-            DeviceTreeComponentSource::Boot,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-        ];
-        let mut current_buffer = &mut buffer[..];
-        for source in sources.iter() {
-            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
-        }
-
-        // Select first overlay
-        registry.components_mut().nth(2).unwrap().selected = true;
-        // Select second overlay
-        registry.components_mut().nth(3).unwrap().selected = true;
-
-        assert!(registry.selected().is_err());
-    }
-
-    #[test]
-    fn test_components_returns_multiple_base_device_trees_failed() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let sources = [
-            DeviceTreeComponentSource::VendorBoot,
-            DeviceTreeComponentSource::Boot,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-        ];
-        let mut current_buffer = &mut buffer[..];
-        for source in sources.iter() {
-            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
-        }
-
-        // Select first base device tree
-        registry.components_mut().nth(0).unwrap().selected = true;
-        // Select second base device tree
-        registry.components_mut().nth(1).unwrap().selected = true;
-
-        assert!(registry.selected().is_err());
-    }
-
-    #[test]
-    fn test_components_autoselect() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let sources = [
-            DeviceTreeComponentSource::VendorBoot,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-            DeviceTreeComponentSource::Dtbo,
-        ];
-        let mut current_buffer = &mut buffer[..];
-        for source in sources.iter() {
-            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
-        }
-
-        assert!(registry.autoselect().is_ok());
-
-        // Expected auto selected data
-        let expected_selected = (registry.components().nth(0).unwrap().dt, &[][..]);
-
-        assert_eq!(registry.selected().unwrap(), expected_selected);
-    }
-
-    #[test]
-    fn test_components_autoselect_no_overlays() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], &mut buffer)
-            .unwrap();
-
-        assert!(registry.autoselect().is_ok());
-
-        // Expected auto selected data
-        let expected_selected = (registry.components().nth(0).unwrap().dt, &[][..]);
-
-        assert_eq!(registry.selected().unwrap(), expected_selected);
-    }
-
-    #[test]
-    fn test_components_autoselect_multiple_base_device_trees_failed() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        let mut current_buffer = &mut buffer[..];
-        current_buffer = registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], current_buffer)
-            .unwrap();
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], current_buffer)
-            .unwrap();
-
-        assert!(registry.autoselect().is_err());
-    }
-
-    #[test]
-    fn test_components_autoselect_no_base_device_trees_failed() {
-        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::Dtbo, &dt[..], &mut buffer)
-            .unwrap();
-
-        assert!(registry.autoselect().is_err());
-    }
-
-    #[test]
-    fn test_components_append_from_multifd() {
-        let half = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let dt = [half.clone(), half].concat();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], &mut buffer)
-            .unwrap();
-
-        assert_eq!(registry.components().count(), 2);
-    }
-
-    #[test]
-    fn test_components_append_from_multifd_with_tail() {
-        let half = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
-        let dt = [half.clone(), half, vec![0; 100]].concat();
-        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut registry = DeviceTreeComponentsRegistry::new();
-
-        registry
-            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], &mut buffer)
-            .unwrap();
-
-        assert_eq!(registry.components().count(), 2);
-    }
-}
diff --git a/gbl/libgbl/src/digest.rs b/gbl/libgbl/src/digest.rs
deleted file mode 100644
index c0435a1..0000000
--- a/gbl/libgbl/src/digest.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! GBL Digest trait that defines interface for hash computation.
-
-/// List of supported algorithms
-#[derive(Debug, Eq, PartialEq, Clone, Copy)]
-pub enum Algorithm {
-    /// SHA256 algorithm
-    SHA256,
-    /// SHA512 algorithm
-    SHA512,
-}
-
-/// Digest output trait that return algorithm and ref to the value
-pub trait Digest: AsRef<[u8]> {
-    /// Get digest algorithm
-    fn algorithm(&self) -> &Algorithm;
-}
-
-/// Context trait that implements digesting.
-/// Sha256 or Sha512.
-pub trait Context {
-    /// Digest type
-    type Digest: Digest;
-
-    /// Create [Context] object that can calculate digest with requested algorithm.
-    ///
-    /// # Arguments
-    ///
-    /// * algorithm - requested algorithm
-    fn new(algorithm: Algorithm) -> Self;
-
-    /// Process next portion of data for the digest.
-    ///
-    /// # Arguments
-    ///
-    /// * input - block of data to be processed
-    fn update(&mut self, input: &[u8]);
-
-    /// Finalise digest computation.
-    ///
-    /// Object is consumed to prevent reusing.
-    fn finish(self) -> Self::Digest;
-
-    /// The algorithm that this context is using.
-    fn algorithm(&self) -> &Algorithm;
-}
diff --git a/gbl/libgbl/src/error.rs b/gbl/libgbl/src/error.rs
deleted file mode 100644
index 13ec813..0000000
--- a/gbl/libgbl/src/error.rs
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Error types used in libgbl.
-
-use avb::{DescriptorError, IoError, SlotVerifyError};
-use core::{
-    fmt::{Debug, Display, Formatter},
-    num::TryFromIntError,
-};
-
-/// A helper macro for declaring a composite enum type that simply wraps other types as entries.
-/// It auto-generate `From<...>` implementation for each entry type. The type for each entry must
-/// be different from each other. i.e.:
-///
-/// ```rust
-///   composite_enum! {
-///       pub enum MyEnum {
-///           Usize(usize),
-///           I64(i64),
-///       }
-///   }
-/// ```
-///
-/// expands to
-///
-/// ```rust
-///   pub enum MyEnum {
-///       Usize(usize),
-///       I64(i64),
-///   }
-///
-///   impl From<usize> for MyEnum {
-///       fn from(ent: usize) -> MyEnum {
-///           MyEnum::Usize(ent)
-///       }
-///   }
-///
-///   impl From<i64> for MyEnum {
-///       fn from(ent: i64) -> MyEnum {
-///           MyEnum::I64(ent)
-///       }
-///   }
-/// ```
-#[macro_export]
-macro_rules! composite_enum {
-    (
-        $(#[$outer:meta])*
-        $vis:vis enum $name:ident {
-            $(
-                $(#[$inner:ident $($args:tt)*])*
-                $ent:ident($ent_t:ty)
-            ),*
-            $(,)*
-        }
-    ) => {
-        #[allow(missing_docs)]
-        // Copy over enum declaration as it is.
-        $(#[$outer])*
-        $vis enum $name {
-            $(
-                $(#[$inner $($args)*])*
-                $ent($ent_t)
-            ),*
-        }
-
-        // Generate `From<...>` implementation.
-        composite_enum!{$name,  $($ent($ent_t)),*}
-    };
-    // `From<>` implementation generation. Base case.
-    ($name:ident, $ent:ident($ent_t:ty)) => {
-        impl From<$ent_t> for $name {
-            fn from(ent: $ent_t) -> $name {
-                $name::$ent(ent)
-            }
-        }
-    };
-    // `From<>` implementation generation. Recursive case.
-    ($name:ident, $ent:ident($ent_t:ty), $($next:ident($next_t:ty)),+) => {
-        composite_enum!{$name, $ent($ent_t)}
-        composite_enum!{$name, $($next($next_t)),*}
-    };
-}
-
-composite_enum! {
-    /// Top level error type that integrates errors from various dependency libraries.
-    #[derive(Debug, PartialEq, Eq)]
-    pub enum IntegrationError {
-        /// Failed to get descriptor from AvbMeta
-        AvbDescriptorError(DescriptorError),
-        AvbIoError(IoError),
-        /// Avb slot verification failed.
-        /// SlotVerifyError is used without verify data.
-        AvbSlotVerifyError(SlotVerifyError<'static>),
-        UnificationError(liberror::Error),
-        ZbiError(zbi::ZbiError),
-        TryFromIntError(TryFromIntError),
-    }
-}
-
-impl Display for IntegrationError {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        write!(f, "{:?}", self)
-    }
-}
-
-/// Helper type GBL functions will return.
-pub type Result<T> = core::result::Result<T, IntegrationError>;
diff --git a/gbl/libgbl/src/fastboot/buffer_pool.rs b/gbl/libgbl/src/fastboot/buffer_pool.rs
deleted file mode 100644
index 5f34106..0000000
--- a/gbl/libgbl/src/fastboot/buffer_pool.rs
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use super::shared::Shared;
-use core::{
-    mem::{swap, take},
-    ops::{Deref, DerefMut},
-};
-use gbl_async::yield_now;
-
-/// Provides interfaces for allocating and deallocating buffers.
-pub trait BufferPool {
-    /// The type that can be dereferenced into a buffer.
-    type Buffer: DerefMut<Target = [u8]>;
-
-    /// Allocates a buffer.
-    ///
-    /// * Returns Some(_) on success.
-    /// * Returns None if buffer is not available.
-    fn allocate(&mut self) -> Option<Self::Buffer>;
-
-    /// Deallocates a buffer.
-    fn deallocate(&mut self, buf: Self::Buffer);
-}
-
-// Implements for all types of fixed size preallocated buffers, including `&mut [&mut [u8]]`,
-// `Vec<Vec<u8>`, `&mut [Vec<u8>]` and `Vec<&mut [u8]>`.
-impl<B, T> BufferPool for T
-where
-    B: DerefMut<Target = [u8]> + Default, // Can be `&mut [u8]`, `Vec<u8>`
-    T: DerefMut<Target = [B]>,            // Can be `&mut [B]`, `Vec<B>`
-{
-    type Buffer = B;
-
-    fn allocate(&mut self) -> Option<B> {
-        self.iter_mut().find_map(|v| (v.len() > 0).then_some(take(v)))
-    }
-
-    fn deallocate(&mut self, mut buf: B) {
-        swap(&mut buf, self.iter_mut().find(|v| v.len() == 0).unwrap());
-    }
-}
-
-impl<T: BufferPool> Shared<T> {
-    // Try allocate a [ScopedBuffer]
-    pub(crate) fn allocate(&self) -> Option<ScopedBuffer<T>> {
-        self.borrow_mut().allocate().map(|v| ScopedBuffer { buf: Some(v), pool: self })
-    }
-
-    // Allocates a [ScopedBuffer] and waits until succeed.
-    pub(crate) async fn allocate_async(&self) -> ScopedBuffer<T> {
-        loop {
-            match self.allocate() {
-                Some(v) => return v,
-                _ => yield_now().await,
-            }
-        }
-    }
-}
-
-/// Represents a scoped buffer allocated by `BufferPool`.
-pub(crate) struct ScopedBuffer<'a, T: BufferPool> {
-    buf: Option<T::Buffer>,
-    pool: &'a Shared<T>,
-}
-
-impl<T: BufferPool> Drop for ScopedBuffer<'_, T> {
-    fn drop(&mut self) {
-        self.pool.borrow_mut().deallocate(self.buf.take().unwrap())
-    }
-}
-
-impl<T: BufferPool> Deref for ScopedBuffer<'_, T> {
-    type Target = [u8];
-
-    fn deref(&self) -> &Self::Target {
-        self.buf.as_ref().unwrap()
-    }
-}
-
-impl<T: BufferPool> DerefMut for ScopedBuffer<'_, T> {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        self.buf.as_mut().unwrap()
-    }
-}
diff --git a/gbl/libgbl/src/fastboot/mod.rs b/gbl/libgbl/src/fastboot/mod.rs
deleted file mode 100644
index 9762dc4..0000000
--- a/gbl/libgbl/src/fastboot/mod.rs
+++ /dev/null
@@ -1,2995 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Fastboot backend for libgbl.
-
-use crate::{
-    android_boot::{android_load_verify_fixup, get_boot_slot},
-    fuchsia_boot::GblAbrOps,
-    gbl_print, gbl_println,
-    ops::RambootOps,
-    partition::{check_part_unique, GblDisk, PartitionIo},
-    GblOps,
-};
-pub use abr::{mark_slot_active, set_one_shot_bootloader, set_one_shot_recovery, SlotIndex};
-use core::{
-    array::from_fn, cmp::min, ffi::CStr, fmt::Write, future::Future, marker::PhantomData,
-    mem::take, ops::DerefMut, ops::Range, pin::Pin, str::from_utf8,
-};
-use fastboot::{
-    local_session::LocalSession, next_arg, next_arg_u64, process_next_command, run_tcp_session,
-    CommandError, CommandResult, FastbootImplementation, InfoSender, OkaySender, RebootMode,
-    UploadBuilder, Uploader, VarInfoSender, MAX_COMMAND_SIZE,
-};
-use gbl_async::{join, yield_now};
-use gbl_storage::{BlockIo, Disk, Gpt};
-use liberror::Error;
-use libutils::snprintf;
-use libutils::FormattedBytes;
-use safemath::SafeNum;
-use zbi::{ZbiContainer, ZbiType};
-
-mod vars;
-
-pub(crate) mod sparse;
-use sparse::is_sparse_image;
-
-mod shared;
-pub use shared::Shared;
-
-mod buffer_pool;
-pub use buffer_pool::BufferPool;
-use buffer_pool::ScopedBuffer;
-
-mod pin_fut_container;
-pub use pin_fut_container::PinFutContainer;
-use pin_fut_container::{PinFutContainerTyped, PinFutSlice};
-
-// Re-exports dependency types
-pub use fastboot::{TcpStream, Transport};
-
-/// Reserved name for indicating flashing GPT.
-const FLASH_GPT_PART: &str = "gpt";
-
-/// Represents the workload of a GBL Fastboot async task.
-enum TaskWorkload<'a, 'b, B: BlockIo, P: BufferPool> {
-    /// Image flashing task. (partition io, downloaded data, data size)
-    Flash(PartitionIo<'a, B>, ScopedBuffer<'b, P>, usize),
-    /// Sparse image flashing task. (partition io, downloaded data)
-    FlashSparse(PartitionIo<'a, B>, ScopedBuffer<'b, P>),
-    // Image erase task.
-    Erase(PartitionIo<'a, B>, ScopedBuffer<'b, P>),
-    None,
-}
-
-impl<'a, 'b, B: BlockIo, P: BufferPool> TaskWorkload<'a, 'b, B, P> {
-    /// Runs the task and returns the result
-    async fn run(self) -> Result<(), Error> {
-        match self {
-            Self::Flash(mut io, mut data, sz) => io.write(0, &mut data[..sz]).await,
-            Self::FlashSparse(mut io, mut data) => io.write_sparse(0, &mut data).await,
-            Self::Erase(mut io, mut buffer) => io.zeroize(&mut buffer).await,
-            _ => Ok(()),
-        }
-    }
-}
-
-/// Represents a GBL Fastboot async task.
-struct Task<'a, 'b, B: BlockIo, P: BufferPool> {
-    workload: TaskWorkload<'a, 'b, B, P>,
-    context: [u8; MAX_COMMAND_SIZE],
-}
-
-impl<'a, 'b, B: BlockIo, P: BufferPool> Task<'a, 'b, B, P> {
-    /// Creates a new instance with the given workload.
-    fn new(workload: TaskWorkload<'a, 'b, B, P>) -> Self {
-        Self { workload, context: [0u8; MAX_COMMAND_SIZE] }
-    }
-
-    /// Sets the context string.
-    fn set_context(&mut self, mut f: impl FnMut(&mut dyn Write) -> Result<(), core::fmt::Error>) {
-        let _ = f(&mut FormattedBytes::new(&mut self.context[..]));
-    }
-
-    /// Runs the task and returns the result.
-    async fn run_checked(self) -> Result<(), Error> {
-        self.workload.run().await
-    }
-
-    /// Runs the task. Panics on error.
-    ///
-    /// The method is intended for use in the context of parallel/background async task where errors
-    /// can't be easily handled by the main routine.
-    async fn run(self) {
-        match self.workload.run().await {
-            Err(e) => panic!(
-                "A Fastboot async task failed: {e:?}, context: {}",
-                from_utf8(&self.context[..]).unwrap_or("")
-            ),
-            _ => {}
-        }
-    }
-}
-
-impl<'a, 'b, B: BlockIo, P: BufferPool> Default for Task<'a, 'b, B, P> {
-    fn default() -> Self {
-        // Creates a noop task. This is mainly used for type inference for inline declaration of
-        // pre-allocated task pool.
-        Self::new(TaskWorkload::None)
-    }
-}
-
-/// Contains the load buffer layout of images loaded by "fastboot boot".
-#[derive(Debug, Clone)]
-pub enum LoadedImageInfo {
-    /// Android loaded images.
-    Android {
-        /// Offset and length of ramdisk in `GblFastboot::load_buffer`.
-        ramdisk: Range<usize>,
-        /// Offset and length of fdt in `GblFastboot::load_buffer`.
-        fdt: Range<usize>,
-        /// Offset and length of kernel in `GblFastboot::load_buffer`.
-        kernel: Range<usize>,
-    },
-}
-
-/// Contains result data returned by GBL Fastboot.
-#[derive(Debug, Clone, Default)]
-pub struct GblFastbootResult {
-    /// Buffer layout for images loaded by "fastboot boot"
-    pub loaded_image_info: Option<LoadedImageInfo>,
-    /// Slot suffix that was last set active by "fastboot set_active"
-    pub last_set_active_slot: Option<char>,
-}
-
-impl GblFastbootResult {
-    /// Splits the given buffer into `(ramdisk, fdt, kernel, unused)` according to layout info in
-    ///  `Self::loaded_image_info` if it is a `Some(LoadedImageInfo::Android)`.
-    pub fn split_loaded_android<'a>(
-        &self,
-        load: &'a mut [u8],
-    ) -> Option<(&'a mut [u8], &'a mut [u8], &'a mut [u8], &'a mut [u8])> {
-        let Some(LoadedImageInfo::Android { ramdisk, fdt, kernel }) = &self.loaded_image_info
-        else {
-            return None;
-        };
-        let (ramdisk_buf, rem) = load[ramdisk.start..].split_at_mut(ramdisk.len());
-        let (fdt_buf, rem) = rem[fdt.start - ramdisk.end..].split_at_mut(fdt.len());
-        let (kernel_buf, rem) = rem[kernel.start - fdt.end..].split_at_mut(kernel.len());
-        Some((ramdisk_buf, fdt_buf, kernel_buf, rem))
-    }
-}
-
-/// `GblFastboot` implements fastboot commands in the GBL context.
-///
-/// # Lifetimes
-///
-/// * `'a`: [GblOps] and disks lifetime.
-/// * `'b`: Lifetime for the buffer allocated by `P`.
-/// * `'c`: Lifetime of the pinned [Future]s in task container `task`.
-/// * `'d`: Lifetime of the `tasks` and `gbl_ops` objects borrowed.
-/// * `'e`: Lifetime of the ImageBuffers returned by `get_image_buffer()`.
-///
-/// # Generics
-///
-/// * `G`: Type of `Self::gbl_ops` which implements [GblOps].
-/// * `B`: Type that implements [BlockIo] in the [Disk] parameter of [GblDisk] for `Self::disks`.
-/// * `S`: Type of scratch buffer in the [Disk] parameter of [GblDisk] for `Self::disks`.
-/// * `T`: Type of gpt buffer in the [Gpt] parameter of [GblDisk] for `Self::disks`.
-/// * `P`: Type of `Self::buffer_pool` which implements [BufferPool].
-/// * `C`: Type of `Self::tasks` which implements [PinFutContainerTyped].
-/// * `F`: Type of [Future] stored by `Self::Tasks`.
-struct GblFastboot<'a, 'b, 'c, 'd, 'e, G, B, S, T, P, C, F>
-where
-    G: GblOps<'a, 'e>,
-    B: BlockIo,
-    S: DerefMut<Target = [u8]>,
-    T: DerefMut<Target = [u8]>,
-    P: BufferPool,
-{
-    pub(crate) gbl_ops: &'d mut G,
-    // We store the partition devices returned by `gbl_ops.disks()` directly instead of getting it
-    // from `gbl_ops` later because we need to establish to the compiler that the hidden type of
-    // [BlockIo] in `GblDisk<Disk<impl BlockIO...>...>` returned by `gbl_ops.disks()` will be the
-    // same as the [BlockIo] type (denoted as B) in the function pointer
-    // `task_mapper`: fn(Task<'a, 'b, B, P>) -> F`. Otherwise, compiler won't allow `fn flash()`
-    // to call `task_mapper` with a `Task` constructed from `GblDisk<Disk<impl BlockIO...>...>`.
-    disks: &'a [GblDisk<Disk<B, S>, Gpt<T>>],
-    buffer_pool: &'b Shared<P>,
-    task_mapper: fn(Task<'a, 'b, B, P>) -> F,
-    tasks: &'d Shared<C>,
-    current_download_buffer: Option<ScopedBuffer<'b, P>>,
-    current_download_size: usize,
-    enable_async_task: bool,
-    default_block: Option<usize>,
-    load_buffer: &'b mut [u8],
-    result: GblFastbootResult,
-    // Introduces marker type so that we can enforce constraint 'd <= min('b, 'c).
-    // The constraint is expressed in the implementation block for the `FastbootImplementation`
-    // trait.
-    _tasks_context_lifetime: PhantomData<&'c P>,
-    _get_image_buffer_lifetime: PhantomData<&'e ()>,
-}
-
-// See definition of [GblFastboot] for docs on lifetimes and generics parameters.
-impl<'a: 'c, 'b: 'c, 'c, 'd, 'e, G, B, S, T, P, C, F>
-    GblFastboot<'a, 'b, 'c, 'd, 'e, G, B, S, T, P, C, F>
-where
-    G: GblOps<'a, 'e>,
-    B: BlockIo,
-    S: DerefMut<Target = [u8]>,
-    T: DerefMut<Target = [u8]>,
-    P: BufferPool,
-    C: PinFutContainerTyped<'c, F>,
-    F: Future<Output = ()> + 'c,
-{
-    /// Creates a new [GblFastboot].
-    ///
-    /// # Args
-    ///
-    /// * `gbl_ops`: An implementation of `GblOps`.
-    /// * `disks`: The disk devices returned by `gbl_ops.disks()`. This is needed for expressing the
-    ///   property that the hidden [BlockIo] type is the same as that in `task_mapper`.
-    /// * `task_mapper`: A function pointer that maps `Task<'a, 'b, G, B>` to the target [Future]
-    ///   type `F` for input to `PinFutContainerTyped<F>::add_with()`.
-    /// * `tasks`: A shared instance of `PinFutContainerTyped<F>`.
-    /// * `buffer_pool`: A shared instance of `BufferPool`.
-    ///
-    /// The combination of `task_mapper` and `tasks` allows type `F`, which will be running the
-    /// async function `Task::run()`, to be defined at the callsite. This is necessary for the
-    /// usage of preallocated pinned futures (by `run_gbl_fastboot_stack()`) because the returned
-    /// type of a `async fn` is compiler-generated and can't be named. The only way to create a
-    /// preallocated slice of anonymous future is to keep the type generic and pass in the
-    /// anonymous future instance at the initialization callsite (aka defining use) and let compiler
-    /// infer and propagate it.
-    fn new(
-        gbl_ops: &'d mut G,
-        disks: &'a [GblDisk<Disk<B, S>, Gpt<T>>],
-        task_mapper: fn(Task<'a, 'b, B, P>) -> F,
-        tasks: &'d Shared<C>,
-        buffer_pool: &'b Shared<P>,
-        load_buffer: &'b mut [u8],
-    ) -> Self {
-        Self {
-            gbl_ops,
-            disks,
-            task_mapper,
-            tasks,
-            buffer_pool,
-            current_download_buffer: None,
-            current_download_size: 0,
-            enable_async_task: false,
-            default_block: None,
-            load_buffer,
-            result: Default::default(),
-            _tasks_context_lifetime: PhantomData,
-            _get_image_buffer_lifetime: PhantomData,
-        }
-    }
-
-    /// Returns the shared task container.
-    fn tasks(&self) -> &'d Shared<impl PinFutContainerTyped<'c, F>> {
-        self.tasks
-    }
-
-    /// Listens on the given USB, TCP, and local session channels and runs fastboot.
-    async fn run(
-        &mut self,
-        mut local: Option<impl LocalSession>,
-        mut usb: Option<impl GblUsbTransport>,
-        mut tcp: Option<impl GblTcpStream>,
-    ) {
-        if usb.is_none() && tcp.is_none() && local.is_none() {
-            gbl_println!(self.gbl_ops, "No USB, TCP, or local session found for GBL Fastboot");
-            return;
-        }
-        let tasks = self.tasks();
-        // The fastboot command loop task for interacting with the remote host.
-        let cmd_loop_end = Shared::from(false);
-        let cmd_loop_task = async {
-            loop {
-                if let Some(ref mut l) = local {
-                    let res = match process_next_command(l, self).await {
-                        Ok(true) => break,
-                        l => l,
-                    };
-                    if res.is_err() {
-                        gbl_println!(self.gbl_ops, "GBL Fastboot local session error: {:?}", res);
-                    }
-                }
-
-                if let Some(v) = usb.as_mut() {
-                    if v.has_packet() {
-                        let res = match process_next_command(v, self).await {
-                            Ok(true) => break,
-                            v => v,
-                        };
-                        if res.is_err() {
-                            gbl_println!(self.gbl_ops, "GBL Fastboot USB session error: {:?}", res);
-                        }
-                    }
-                }
-
-                if let Some(v) = tcp.as_mut() {
-                    if v.accept_new() {
-                        let res = match run_tcp_session(v, self).await {
-                            Ok(()) => break,
-                            v => v,
-                        };
-                        if res.is_err_and(|e| e != Error::Disconnected) {
-                            gbl_println!(self.gbl_ops, "GBL Fastboot TCP session error: {:?}", res);
-                        }
-                    }
-                }
-
-                yield_now().await;
-            }
-            *cmd_loop_end.borrow_mut() = true;
-        };
-
-        // Schedules [Task] spawned by GBL fastboot.
-        let gbl_fb_tasks = async {
-            while tasks.borrow_mut().poll_all() > 0 || !*cmd_loop_end.borrow_mut() {
-                yield_now().await;
-            }
-        };
-
-        let _ = join(cmd_loop_task, gbl_fb_tasks).await;
-    }
-
-    /// Extracts the next argument and verifies that it is a valid block device ID if present.
-    ///
-    /// # Returns
-    ///
-    /// * Returns `Ok(Some(blk_id))` if next argument is present and is a valid block device ID.
-    /// * Returns `None` if next argument is not available and there are more than one block
-    ///   devices.
-    /// * Returns `Err(())` if next argument is present but is an invalid block device ID.
-    fn check_next_arg_blk_id<'s>(
-        &self,
-        args: &mut impl Iterator<Item = &'s str>,
-    ) -> CommandResult<Option<usize>> {
-        let devs = self.disks;
-        let blk_id = match next_arg_u64(args)? {
-            Some(v) => {
-                let v = usize::try_from(v)?;
-                // Checks out of range.
-                devs.get(v).ok_or("Invalid block ID")?;
-                Some(v)
-            }
-            _ => None,
-        };
-        let blk_id = blk_id.or(self.default_block);
-        let blk_id = blk_id.or((devs.len() == 1).then_some(0));
-        Ok(blk_id)
-    }
-
-    /// Parses and checks the argument for "fastboot flash gpt/<blk_idx>/"resize".
-    ///
-    /// # Returns
-    ///
-    /// * Returns `Ok(Some((blk_idx, resize)))` if command is a GPT flashing command.
-    /// * Returns `Ok(None)` if command is not a GPT flashing command.
-    /// * Returns `Err()` otherwise.
-    pub(crate) fn parse_flash_gpt_args(&self, part: &str) -> CommandResult<Option<(usize, bool)>> {
-        // Syntax: flash gpt/<blk_idx>/"resize"
-        let mut args = part.split('/');
-        if next_arg(&mut args).filter(|v| *v == FLASH_GPT_PART).is_none() {
-            return Ok(None);
-        }
-        // Parses block device ID.
-        let blk_id = self
-            .check_next_arg_blk_id(&mut args)?
-            .ok_or("Block ID is required for flashing GPT")?;
-        // Parses resize option.
-        let resize = match next_arg(&mut args) {
-            Some("resize") => true,
-            Some(_) => return Err("Unknown argument".into()),
-            _ => false,
-        };
-        Ok(Some((blk_id, resize)))
-    }
-
-    /// Parses and checks the partition argument and returns the partition name, block device
-    /// index, start offset and size.
-    pub(crate) fn parse_partition<'s>(
-        &self,
-        part: &'s str,
-    ) -> CommandResult<(Option<&'s str>, usize, u64, u64)> {
-        let devs = self.disks;
-        let mut args = part.split('/');
-        // Parses partition name.
-        let part = next_arg(&mut args);
-        // Parses block device ID.
-        let blk_id = self.check_next_arg_blk_id(&mut args)?;
-        // Parses sub window offset.
-        let window_offset = next_arg_u64(&mut args)?.unwrap_or(0);
-        // Parses sub window size.
-        let window_size = next_arg_u64(&mut args)?;
-        // Checks uniqueness of the partition and resolves its block device ID.
-        let find = |p: Option<&'s str>| match blk_id {
-            None => Ok((check_part_unique(devs, p.ok_or("Must provide a partition")?)?, p)),
-            Some(v) => Ok(((v, devs[v].find_partition(p)?), p)),
-        };
-        let ((blk_id, partition), actual) = match find(part) {
-            // Some legacy Fuchsia devices in the field uses name "fuchsia-fvm" for the standard
-            // "fvm" partition. However all of our infra uses the standard name "fvm" when flashing.
-            // Here we do a one off mapping if the device falls into this case. Once we have a
-            // solution for migrating those devices off the legacy name, we can remove this.
-            //
-            // If we run into more of such legacy aliases that we can't migrate, consider adding
-            // interfaces in GblOps for this.
-            Err(Error::NotFound) if part == Some("fvm") => find(Some("fuchsia-fvm"))?,
-            v => v?,
-        };
-        let part_sz = SafeNum::from(partition.size()?);
-        let window_size = window_size.unwrap_or((part_sz - window_offset).try_into()?);
-        u64::try_from(part_sz - window_size - window_offset)?;
-        Ok((actual, blk_id, window_offset, window_size))
-    }
-
-    /// Takes the download data and resets download size.
-    fn take_download(&mut self) -> Option<(ScopedBuffer<'b, P>, usize)> {
-        Some((self.current_download_buffer.take()?, take(&mut self.current_download_size)))
-    }
-
-    /// Waits until a Disk device is ready and get the [PartitionIo] for `part`.
-    pub async fn wait_partition_io(
-        &self,
-        blk: usize,
-        part: Option<&str>,
-    ) -> CommandResult<PartitionIo<'a, B>> {
-        loop {
-            match self.disks[blk].partition_io(part) {
-                Err(Error::NotReady) => yield_now().await,
-                v => return Ok(v?),
-            }
-        }
-    }
-
-    /// An internal helper for parsing a partition and getting the partition IO
-    async fn parse_and_get_partition_io(
-        &self,
-        part: &str,
-    ) -> CommandResult<(usize, PartitionIo<'a, B>)> {
-        let (part, blk_idx, start, sz) = self.parse_partition(part)?;
-        Ok((blk_idx, self.wait_partition_io(blk_idx, part).await?.sub(start, sz)?))
-    }
-
-    /// Helper for scheduiling an async task.
-    ///
-    /// * If `Self::enable_async_task` is true, the method will add the task to the background task
-    ///   list. Otherwise it simply runs the task.
-    async fn schedule_task(
-        &mut self,
-        task: Task<'a, 'b, B, P>,
-        responder: &mut impl InfoSender,
-    ) -> CommandResult<()> {
-        Ok(match self.enable_async_task {
-            true => {
-                let mut t = Some((self.task_mapper)(task));
-                self.tasks.borrow_mut().add_with(|| t.take().unwrap());
-                while t.is_some() {
-                    yield_now().await;
-                    self.tasks.borrow_mut().add_with(|| t.take().unwrap());
-                }
-                self.tasks.borrow_mut().poll_all();
-                let info =
-                    "An async task is launched. To sync manually, run \"oem gbl-sync-tasks\".";
-                responder.send_info(info).await?
-            }
-            _ => task.run_checked().await?,
-        })
-    }
-
-    /// Waits for all block devices to be ready.
-    async fn sync_all_blocks(&self) -> CommandResult<()> {
-        for (idx, _) in self.disks.iter().enumerate() {
-            let _ = self.wait_partition_io(idx, None).await;
-        }
-        Ok(())
-    }
-
-    /// Implementation for "fastboot oem gbl-sync-tasks".
-    async fn oem_sync_tasks<'s>(
-        &self,
-        mut _responder: impl InfoSender,
-        _res: &'s mut [u8],
-    ) -> CommandResult<&'s [u8]> {
-        self.sync_all_blocks().await?;
-        Ok(b"")
-    }
-
-    /// Syncs all storage devices and reboots.
-    async fn sync_tasks_and_reboot(
-        &mut self,
-        mode: RebootMode,
-        mut resp: impl InfoSender + OkaySender,
-    ) -> CommandResult<()> {
-        resp.send_info("Syncing storage...").await?;
-        self.sync_all_blocks().await?;
-        match mode {
-            RebootMode::Normal => {
-                resp.send_info("Rebooting...").await?;
-                resp.send_okay("").await?;
-                self.gbl_ops.reboot();
-            }
-            RebootMode::Bootloader => {
-                let f = self.gbl_ops.reboot_bootloader()?;
-                resp.send_info("Rebooting to bootloader...").await?;
-                resp.send_okay("").await?;
-                f()
-            }
-            RebootMode::Recovery => {
-                let f = self.gbl_ops.reboot_recovery()?;
-                resp.send_info("Rebooting to recovery...").await?;
-                resp.send_okay("").await?;
-                f()
-            }
-            _ => return Err("Unsupported".into()),
-        }
-        Ok(())
-    }
-
-    /// Appends a staged payload as bootloader file.
-    async fn add_staged_bootloader_file(&mut self, file_name: &str) -> CommandResult<()> {
-        let buffer = self
-            .gbl_ops
-            .get_zbi_bootloader_files_buffer_aligned()
-            .ok_or("No ZBI bootloader file buffer is provided")?;
-        let data = self.current_download_buffer.as_mut().ok_or("No file staged")?;
-        let data = &mut data[..self.current_download_size];
-        let mut zbi = match ZbiContainer::parse(&mut buffer[..]) {
-            Ok(v) => v,
-            _ => ZbiContainer::new(&mut buffer[..])?,
-        };
-        let next_payload = zbi.get_next_payload()?;
-        // Format: name length (1 byte) | name | file content.
-        let (name_len, rest) = next_payload.split_at_mut_checked(1).ok_or("Buffer too small")?;
-        let (name, rest) = rest.split_at_mut_checked(file_name.len()).ok_or("Buffer too small")?;
-        let file_content = rest.get_mut(..data.len()).ok_or("Buffer too small")?;
-        name_len[0] = file_name.len().try_into().map_err(|_| "File name length overflows 256")?;
-        name.clone_from_slice(file_name.as_bytes());
-        file_content.clone_from_slice(data);
-        // Creates the entry;
-        zbi.create_entry(
-            ZbiType::BootloaderFile,
-            0,
-            Default::default(),
-            1 + file_name.len() + data.len(),
-        )?;
-        Ok(())
-    }
-
-    /// Sets active slot.
-    async fn set_active_slot(&mut self, slot: &str) -> CommandResult<()> {
-        self.sync_all_blocks().await?;
-        match self.gbl_ops.expected_os_is_fuchsia()? {
-            // TODO(b/374776896): Prioritizes platform specific `set_active_slot`  if available.
-            true => Ok(mark_slot_active(
-                &mut GblAbrOps(self.gbl_ops),
-                match slot {
-                    "a" => SlotIndex::A,
-                    "b" => SlotIndex::B,
-                    _ => return Err("Invalid slot index for Fuchsia A/B/R".into()),
-                },
-            )?),
-            // We currently assume that slot indices are mapped to suffix 'a' to 'z' starting from
-            // 0. Revisit if we need to support arbitrary slot suffix to index mapping.
-            _ => Ok(self
-                .gbl_ops
-                .set_active_slot(u8::try_from(slot.chars().next().unwrap())? - b'a')?),
-        }
-    }
-}
-
-// See definition of [GblFastboot] for docs on lifetimes and generics parameters.
-impl<'a: 'c, 'b: 'c, 'c, 'e, G, B, S, T, P, C, F> FastbootImplementation
-    for GblFastboot<'a, 'b, 'c, '_, 'e, G, B, S, T, P, C, F>
-where
-    G: GblOps<'a, 'e>,
-    B: BlockIo,
-    S: DerefMut<Target = [u8]>,
-    T: DerefMut<Target = [u8]>,
-    P: BufferPool,
-    C: PinFutContainerTyped<'c, F>,
-    F: Future<Output = ()> + 'c,
-{
-    async fn get_var(
-        &mut self,
-        var: &CStr,
-        args: impl Iterator<Item = &'_ CStr> + Clone,
-        out: &mut [u8],
-        _: impl InfoSender,
-    ) -> CommandResult<usize> {
-        Ok(self.get_var_internal(var, args, out)?.len())
-    }
-
-    async fn get_var_all(&mut self, mut resp: impl VarInfoSender) -> CommandResult<()> {
-        self.get_var_all_internal(&mut resp).await
-    }
-
-    async fn get_download_buffer(&mut self) -> &mut [u8] {
-        if self.current_download_buffer.is_none() {
-            self.current_download_buffer = Some(self.buffer_pool.allocate_async().await);
-        }
-        self.current_download_buffer.as_mut().unwrap()
-    }
-
-    async fn download_complete(
-        &mut self,
-        download_size: usize,
-        _: impl InfoSender,
-    ) -> CommandResult<()> {
-        self.current_download_size = download_size;
-        Ok(())
-    }
-
-    async fn flash(&mut self, part: &str, mut responder: impl InfoSender) -> CommandResult<()> {
-        let disks = self.disks;
-
-        // Checks if we are flashing new GPT partition table
-        if let Some((blk_idx, resize)) = self.parse_flash_gpt_args(part)? {
-            self.wait_partition_io(blk_idx, None).await?;
-            let (mut gpt, size) = self.take_download().ok_or("No GPT downloaded")?;
-            responder.send_info("Updating GPT...").await?;
-            return match disks[blk_idx].update_gpt(&mut gpt[..size], resize).await {
-                Err(Error::NotReady) => panic!("Should not be busy"),
-                Err(Error::Unsupported) => Err("Block device is not for GPT".into()),
-                v => Ok(v?),
-            };
-        }
-
-        let (_, part_io) = self.parse_and_get_partition_io(part).await?;
-        let (data, sz) = self.take_download().ok_or("No download")?;
-        let mut task = Task::new(match is_sparse_image(&data) {
-            Ok(v) => TaskWorkload::FlashSparse(part_io.sub(0, v.data_size())?, data),
-            _ => TaskWorkload::Flash(part_io.sub(0, sz.try_into().unwrap())?, data, sz),
-        });
-        task.set_context(|f| write!(f, "flash:{part}"));
-        Ok(self.schedule_task(task, &mut responder).await?)
-    }
-
-    async fn erase(&mut self, part: &str, mut responder: impl InfoSender) -> CommandResult<()> {
-        let disks = self.disks;
-
-        // Checks if we are erasing GPT partition table.
-        if let Some((blk_idx, _)) = self.parse_flash_gpt_args(part)? {
-            self.wait_partition_io(blk_idx, None).await?;
-            return match disks[blk_idx].erase_gpt().await {
-                Err(Error::NotReady) => panic!("Should not be busy"),
-                Err(Error::Unsupported) => Err("Block device is not for GPT".into()),
-                v => Ok(v?),
-            };
-        }
-
-        let (_, part_io) = self.parse_and_get_partition_io(part).await?;
-        self.get_download_buffer().await;
-        let mut task = Task::new(TaskWorkload::Erase(part_io, self.take_download().unwrap().0));
-        task.set_context(|f| write!(f, "erase:{part}"));
-        Ok(self.schedule_task(task, &mut responder).await?)
-    }
-
-    async fn upload(&mut self, _: impl UploadBuilder) -> CommandResult<()> {
-        Err("Unimplemented".into())
-    }
-
-    async fn fetch(
-        &mut self,
-        part: &str,
-        offset: u64,
-        size: u64,
-        mut responder: impl UploadBuilder + InfoSender,
-    ) -> CommandResult<()> {
-        let (_, mut part_io) = self.parse_and_get_partition_io(part).await?;
-        let buffer = self.get_download_buffer().await;
-        let end = u64::try_from(SafeNum::from(offset) + size)?;
-        let mut curr = offset;
-        responder
-            .send_formatted_info(|v| write!(v, "Uploading {} bytes...", size).unwrap())
-            .await?;
-        let mut uploader = responder.initiate_upload(size).await?;
-        while curr < end {
-            let to_send = min(usize::try_from(end - curr)?, buffer.len());
-            part_io.read(curr, &mut buffer[..to_send]).await?;
-            uploader.upload(&mut buffer[..to_send]).await?;
-            curr += u64::try_from(to_send)?;
-        }
-        Ok(())
-    }
-
-    async fn reboot(
-        &mut self,
-        mode: RebootMode,
-        resp: impl InfoSender + OkaySender,
-    ) -> CommandError {
-        match self.sync_tasks_and_reboot(mode, resp).await {
-            Err(e) => e,
-            _ => "Unknown".into(),
-        }
-    }
-
-    async fn r#continue(&mut self, mut resp: impl InfoSender) -> CommandResult<()> {
-        resp.send_info("Syncing storage...").await?;
-        Ok(self.sync_all_blocks().await?)
-    }
-
-    async fn set_active(&mut self, slot: &str, _: impl InfoSender) -> CommandResult<()> {
-        if slot.len() > 1 {
-            return Err("Slot suffix must be one character".into());
-        }
-
-        let slot_ch = slot.chars().next().ok_or("Invalid slot")?;
-        self.set_active_slot(slot).await?;
-        self.result.last_set_active_slot = Some(slot_ch);
-        Ok(())
-    }
-
-    async fn oem<'s>(
-        &mut self,
-        cmd: &str,
-        mut responder: impl InfoSender,
-        res: &'s mut [u8],
-    ) -> CommandResult<&'s [u8]> {
-        let mut args = cmd.split(' ');
-        let cmd = args.next().ok_or("Missing command")?;
-        match cmd {
-            "gbl-sync-tasks" => self.oem_sync_tasks(responder, res).await,
-            "gbl-enable-async-task" => {
-                self.enable_async_task = true;
-                Ok(b"")
-            }
-            "gbl-disable-async-task" => {
-                self.enable_async_task = false;
-                Ok(b"")
-            }
-            "gbl-unset-default-block" => {
-                self.default_block = None;
-                Ok(b"")
-            }
-            "gbl-set-default-block" => {
-                let id = next_arg_u64(&mut args)?.ok_or("Missing block device ID")?;
-                let id = usize::try_from(id)?;
-                self.disks.get(id).ok_or("Out of range")?;
-                self.default_block = Some(id.try_into()?);
-                responder
-                    .send_formatted_info(|f| write!(f, "Default block device: {id:#x}").unwrap())
-                    .await?;
-                Ok(b"")
-            }
-            "add-staged-bootloader-file" => {
-                let file_name = next_arg(&mut args).ok_or("Missing file name")?;
-                self.add_staged_bootloader_file(file_name).await?;
-                Ok(b"")
-            }
-            _ => Err("Unknown oem command".into()),
-        }
-    }
-
-    async fn boot(&mut self, _: impl InfoSender + OkaySender) -> CommandResult<()> {
-        let (mut data, sz) = self.take_download().ok_or("No boot image staged")?;
-        let bootimg_buffer = &mut data[..sz];
-        let load_buffer_addr = self.load_buffer.as_ptr() as usize;
-        let slot_suffix = get_boot_slot(self.gbl_ops, false)?;
-        let mut boot_part = [0u8; 16];
-        let boot_part = snprintf!(boot_part, "boot_{slot_suffix}");
-        // We still need to specify slot because other components such as vendor_boot, dtb, dtbo and
-        // vbmeta still come from the disk.
-        let slot_idx = (u64::from(slot_suffix) - u64::from('a')).try_into().unwrap();
-        let mut ramboot_ops =
-            RambootOps { ops: self.gbl_ops, preloaded_partitions: &[(boot_part, bootimg_buffer)] };
-        let (ramdisk, fdt, kernel, _) =
-            android_load_verify_fixup(&mut ramboot_ops, slot_idx, false, self.load_buffer)?;
-        self.result.loaded_image_info = Some(LoadedImageInfo::Android {
-            ramdisk: to_range(ramdisk.as_ptr() as usize - load_buffer_addr, ramdisk.len()),
-            fdt: to_range(fdt.as_ptr() as usize - load_buffer_addr, fdt.len()),
-            kernel: to_range(kernel.as_ptr() as usize - load_buffer_addr, kernel.len()),
-        });
-        Ok(())
-    }
-}
-
-/// Helper to convert a offset and length to a range.
-fn to_range(off: usize, len: usize) -> Range<usize> {
-    off..off.checked_add(len).unwrap()
-}
-
-/// `GblUsbTransport` defines transport interfaces for running GBL fastboot over USB.
-pub trait GblUsbTransport: Transport {
-    /// Checks whether there is a new USB packet.
-    fn has_packet(&mut self) -> bool;
-}
-
-/// `GblTcpStream` defines transport interfaces for running GBL fastboot over TCP.
-pub trait GblTcpStream: TcpStream {
-    /// Accepts a new TCP connection.
-    ///
-    /// If a connection is in progress, it should be aborted first.
-    ///
-    /// Returns true if a new connection is established, false otherwise.
-    fn accept_new(&mut self) -> bool;
-}
-
-/// Runs GBL fastboot on the given USB/TCP channels.
-///
-/// # Args:
-///
-/// * `gbl_ops`: An instance of [GblOps].
-/// * `buffer_pool`: An implementation of [BufferPool].
-/// * `tasks`: An implementation of [PinFutContainer]
-/// * `usb`: An optional implementation of [GblUsbTransport].
-/// * `tcp`: An optional implementation of [GblTcpStream].
-///
-/// # Lifetimes
-/// * `'a`: Lifetime of [GblOps].
-/// * `'b`: Lifetime of `download_buffers`.
-/// * `'c`: Lifetime of `tasks`.
-pub async fn run_gbl_fastboot<'a: 'c, 'b: 'c, 'c, 'd>(
-    gbl_ops: &mut impl GblOps<'a, 'd>,
-    buffer_pool: &'b Shared<impl BufferPool>,
-    tasks: impl PinFutContainer<'c> + 'c,
-    local: Option<impl LocalSession>,
-    usb: Option<impl GblUsbTransport>,
-    tcp: Option<impl GblTcpStream>,
-    load_buffer: &'b mut [u8],
-) -> GblFastbootResult {
-    let tasks = tasks.into();
-    let disks = gbl_ops.disks();
-    let mut fb = GblFastboot::new(gbl_ops, disks, Task::run, &tasks, buffer_pool, load_buffer);
-    fb.run(local, usb, tcp).await;
-    fb.result
-}
-
-/// Runs GBL fastboot on the given USB/TCP channels with N stack allocated worker tasks.
-///
-/// The choice of N depends on the level of parallelism the platform can support. For platform with
-/// `n` storage devices that can independently perform non-blocking IO, it will required `N = n`
-/// and a `buffer_pool` that can allocate at least n+1 buffers at the same time in order to achieve
-/// parallel flashing to all storages plus a parallel downloading. However, it is common for
-/// disks that need to be flashed to be on the same block deviece so flashing of them becomes
-/// sequential, in which case N can be smaller. Caller should take into consideration usage pattern
-/// for determining N.
-///
-/// # Args:
-///
-/// * `gbl_ops`: An instance of [GblOps].
-/// * `buffer_pool`: An implementation of [BufferPool].
-/// * `usb`: An optional implementation of [GblUsbTransport].
-/// * `tcp`: An optional implementation of [GblTcpStream].
-pub async fn run_gbl_fastboot_stack<'a, 'b, const N: usize>(
-    gbl_ops: &mut impl GblOps<'a, 'b>,
-    buffer_pool: impl BufferPool,
-    local: Option<impl LocalSession>,
-    usb: Option<impl GblUsbTransport>,
-    tcp: Option<impl GblTcpStream>,
-    load_buffer: &mut [u8],
-) -> GblFastbootResult {
-    let buffer_pool = buffer_pool.into();
-    // Creates N worker tasks.
-    let mut tasks: [_; N] = from_fn(|_| Task::default().run());
-    // It is possible to avoid the use of the unsafe `Pin::new_unchecked` by delaring the array and
-    // manually pinning each element i.e.
-    //
-    // ```
-    // let mut tasks = [
-    //     core::pin::pin!(Task::None.run()),
-    //     core::pin::pin!(Task::None.run()),
-    //     core::pin::pin!(Task::None.run()),
-    // ];
-    // ```
-    //
-    // Parameterization of `N` will be an issue, but might be solvable with procedural macro.
-    // SAFETY: `tasks` is immediately shadowed and thus guaranteed not moved for the rest of its
-    // lifetime.
-    let mut tasks: [_; N] = tasks.each_mut().map(|v| unsafe { Pin::new_unchecked(v) });
-    let tasks = PinFutSlice::new(&mut tasks[..]).into();
-    let disks = gbl_ops.disks();
-    let mut fb = GblFastboot::new(gbl_ops, disks, Task::run, &tasks, &buffer_pool, load_buffer);
-    fb.run(local, usb, tcp).await;
-    fb.result
-}
-
-/// Pre-generates a Fuchsia Fastboot MDNS service broadcast packet.
-///
-/// Fuchsia ffx development flow can detect fastboot devices that broadcast a "_fastboot_tcplocal"
-/// MDNS service. This API generates the broadcast MDNS packet for Ipv6. Caller is reponsible for
-/// sending this packet via UDP at the following address and port (defined by MDNS):
-///
-/// * ipv6: ff02::fb
-/// * port: 5353
-///
-/// # Args
-///
-/// * `node_name`: The Fuchsia node name for the service. Must be a 22 character ASCII string in the
-///   format "fuchsia-xxxx-xxxx-xxxx".
-/// * `ipv6_addr`: The Ipv6 address bytes.
-///
-/// The packet generated by the API contains the given IPv6 address and a fuchsia node name derived
-/// from the given ethernet mac address `eth_mac`.
-pub fn fuchsia_fastboot_mdns_packet(node_name: &str, ipv6_addr: &[u8]) -> Result<[u8; 140], Error> {
-    // Pre-generated Fuchsia fastboot MDNS service packet template.
-    // It contains the node name and ipv6 address. We simply replace with the device's node name and
-    // ipv6 address.
-    let mut packet: [u8; 140] = [
-        0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x09, 0x5f, 0x66,
-        0x61, 0x73, 0x74, 0x62, 0x6f, 0x6f, 0x74, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x05, 0x6c, 0x6f,
-        0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x19, 0x16,
-        0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x34, 0x38, 0x32, 0x31, 0x2d, 0x30, 0x62,
-        0x33, 0x31, 0x2d, 0x65, 0x61, 0x66, 0x38, 0xc0, 0x0c, 0xc0, 0x2c, 0x00, 0x21, 0x80, 0x01,
-        0x00, 0x00, 0x00, 0x78, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x15, 0xb2, 0x16, 0x66, 0x75,
-        0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x34, 0x38, 0x32, 0x31, 0x2d, 0x30, 0x62, 0x33, 0x31,
-        0x2d, 0x65, 0x61, 0x66, 0x38, 0xc0, 0x1b, 0xc0, 0x57, 0x00, 0x1c, 0x80, 0x01, 0x00, 0x00,
-        0x00, 0x78, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x21, 0x0b,
-        0xff, 0xfe, 0x31, 0xea, 0xf8,
-    ];
-    // Offsets to the fuchsia node name field.
-    const NODE_NAME_OFFSETS: &[usize; 2] = &[45, 88];
-    // Offset to the IPv6 address field.
-    const IP6_ADDR_OFFSET: usize = 124;
-
-    if node_name.as_bytes().len() != 22 {
-        return Err(Error::InvalidInput);
-    }
-
-    for off in NODE_NAME_OFFSETS {
-        packet[*off..][..node_name.len()].clone_from_slice(node_name.as_bytes());
-    }
-    packet[IP6_ADDR_OFFSET..][..ipv6_addr.len()].clone_from_slice(ipv6_addr);
-    Ok(packet)
-}
-
-#[cfg(test)]
-pub(crate) mod test {
-    use super::*;
-    use crate::{
-        android_boot::{
-            load::tests::read_test_data,
-            tests::{
-                checks_loaded_v2_slot_a_normal_mode, checks_loaded_v2_slot_b_normal_mode,
-                default_test_gbl_ops,
-            },
-        },
-        constants::KiB,
-        constants::KERNEL_ALIGNMENT,
-        ops::test::{slot, FakeGblOps, FakeGblOpsStorage},
-        tests::AlignedBuffer,
-        Os,
-    };
-    use abr::{
-        get_and_clear_one_shot_bootloader, get_boot_slot, mark_slot_unbootable, ABR_DATA_SIZE,
-    };
-    use core::{
-        mem::size_of,
-        pin::{pin, Pin},
-        str::from_utf8,
-    };
-    use fastboot::{test_utils::TestUploadBuilder, MAX_RESPONSE_SIZE};
-    use gbl_async::{block_on, poll, poll_n_times};
-    use gbl_storage::GPT_GUID_LEN;
-    use liberror::Error;
-    use spin::{Mutex, MutexGuard};
-    use std::ffi::CString;
-    use std::{collections::VecDeque, io::Read};
-    use zerocopy::IntoBytes;
-
-    /// A test implementation of [InfoSender] and [OkaySender].
-    #[derive(Default)]
-    struct TestResponder {
-        okay_sent: Mutex<bool>,
-        info_messages: Mutex<Vec<String>>,
-    }
-
-    impl InfoSender for &TestResponder {
-        async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(
-            &mut self,
-            cb: F,
-        ) -> Result<(), Error> {
-            let mut msg: String = "".into();
-            cb(&mut msg);
-            self.info_messages.try_lock().unwrap().push(msg);
-            Ok(())
-        }
-    }
-
-    impl OkaySender for &TestResponder {
-        /// Sends a Fastboot "INFO<`msg`>" packet.
-        async fn send_formatted_okay<F: FnOnce(&mut dyn Write)>(self, _: F) -> Result<(), Error> {
-            *self.okay_sent.try_lock().unwrap() = true;
-            Ok(())
-        }
-    }
-
-    /// Helper to test fastboot variable value.
-    fn check_var(gbl_fb: &mut impl FastbootImplementation, var: &str, args: &str, expected: &str) {
-        let resp: TestResponder = Default::default();
-        let args_c = args.split(':').map(|v| CString::new(v).unwrap()).collect::<Vec<_>>();
-        let args_c = args_c.iter().map(|v| v.as_c_str());
-        let var_c = CString::new(var).unwrap();
-        let mut out = vec![0u8; MAX_RESPONSE_SIZE];
-        let val =
-            block_on(gbl_fb.get_var_as_str(var_c.as_c_str(), args_c, &resp, &mut out[..])).unwrap();
-        assert_eq!(val, expected, "var {}:{} = {} != {}", var, args, val, expected,);
-    }
-
-    /// A helper to set the download content.
-    fn set_download(gbl_fb: &mut impl FastbootImplementation, data: &[u8]) {
-        block_on(gbl_fb.get_download_buffer())[..data.len()].clone_from_slice(data);
-        block_on(gbl_fb.download_complete(data.len(), &TestResponder::default())).unwrap();
-    }
-
-    impl<'a> PinFutContainer<'a> for Vec<Pin<Box<dyn Future<Output = ()> + 'a>>> {
-        fn add_with<F: Future<Output = ()> + 'a>(&mut self, f: impl FnOnce() -> F) {
-            self.push(Box::pin(f()));
-        }
-
-        fn for_each_remove_if(
-            &mut self,
-            mut cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
-        ) {
-            for idx in (0..self.len()).rev() {
-                cb(&mut self[idx].as_mut()).then(|| self.swap_remove(idx));
-            }
-        }
-    }
-
-    #[test]
-    fn test_get_var_gbl() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let storage = FakeGblOpsStorage::default();
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        check_var(
-            &mut gbl_fb,
-            FakeGblOps::GBL_TEST_VAR,
-            "arg",
-            format!("{}:Some(\"arg\")", FakeGblOps::GBL_TEST_VAR_VAL).as_str(),
-        );
-    }
-
-    #[test]
-    fn test_get_var_partition_info() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        storage.add_raw_device(c"raw_0", [0xaau8; KiB!(4)]);
-        storage.add_raw_device(c"raw_1", [0x55u8; KiB!(8)]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        // Check different semantics
-        check_var(&mut gbl_fb, "partition-size", "boot_a", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a/", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a//", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a///", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a/0", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a/0/", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a//0", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a/0/0", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a//0x1000", "0x1000");
-
-        check_var(&mut gbl_fb, "partition-size", "boot_b/0", "0x3000");
-        check_var(&mut gbl_fb, "partition-size", "vendor_boot_a/1", "0x1000");
-        check_var(&mut gbl_fb, "partition-size", "vendor_boot_b/1", "0x1800");
-        check_var(&mut gbl_fb, "partition-size", "boot_a//0x1000", "0x1000");
-        check_var(&mut gbl_fb, "partition-size", "raw_0", "0x1000");
-        check_var(&mut gbl_fb, "partition-size", "raw_1", "0x2000");
-
-        let resp: TestResponder = Default::default();
-        let mut out = vec![0u8; MAX_RESPONSE_SIZE];
-        assert!(block_on(gbl_fb.get_var_as_str(
-            c"partition",
-            [c"non-existent"].into_iter(),
-            &resp,
-            &mut out[..],
-        ))
-        .is_err());
-    }
-
-    /// `TestVarSender` implements `TestVarSender`. It stores outputs in a vector of string.
-    struct TestVarSender(Vec<String>);
-
-    impl VarInfoSender for &mut TestVarSender {
-        async fn send_var_info(
-            &mut self,
-            name: &str,
-            args: impl IntoIterator<Item = &'_ str>,
-            val: &str,
-        ) -> Result<(), Error> {
-            let args = args.into_iter().collect::<Vec<_>>();
-            self.0.push(format!("{}:{}: {}", name, args.join(":"), val));
-            Ok(())
-        }
-    }
-
-    #[test]
-    fn test_get_var_all() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        storage.add_raw_device(c"raw_0", [0xaau8; KiB!(4)]);
-        storage.add_raw_device(c"raw_1", [0x55u8; KiB!(8)]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        let mut logger = TestVarSender(vec![]);
-        block_on(gbl_fb.get_var_all(&mut logger)).unwrap();
-        assert_eq!(
-            logger.0,
-            [
-                "version-bootloader:: 1.0",
-                "max-fetch-size:: 0xffffffffffffffff",
-                "block-device:0:total-blocks: 0x80",
-                "block-device:0:block-size: 0x200",
-                "block-device:0:status: idle",
-                "block-device:1:total-blocks: 0x100",
-                "block-device:1:block-size: 0x200",
-                "block-device:1:status: idle",
-                "block-device:2:total-blocks: 0x1000",
-                "block-device:2:block-size: 0x1",
-                "block-device:2:status: idle",
-                "block-device:3:total-blocks: 0x2000",
-                "block-device:3:block-size: 0x1",
-                "block-device:3:status: idle",
-                "gbl-default-block:: None",
-                "partition-size:boot_a/0: 0x2000",
-                "partition-type:boot_a/0: raw",
-                "partition-size:boot_b/0: 0x3000",
-                "partition-type:boot_b/0: raw",
-                "partition-size:vendor_boot_a/1: 0x1000",
-                "partition-type:vendor_boot_a/1: raw",
-                "partition-size:vendor_boot_b/1: 0x1800",
-                "partition-type:vendor_boot_b/1: raw",
-                "partition-size:raw_0/2: 0x1000",
-                "partition-type:raw_0/2: raw",
-                "partition-size:raw_1/3: 0x2000",
-                "partition-type:raw_1/3: raw",
-                format!("{}:1: {}:1", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
-                    .as_str(),
-                format!("{}:2: {}:2", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
-                    .as_str(),
-            ]
-        );
-    }
-
-    /// A helper for fetching partition from a `GblFastboot`
-    fn fetch<EOff: core::fmt::Debug, ESz: core::fmt::Debug>(
-        fb: &mut impl FastbootImplementation,
-        part: String,
-        off: impl TryInto<u64, Error = EOff>,
-        size: impl TryInto<u64, Error = ESz>,
-    ) -> CommandResult<Vec<u8>> {
-        let off = off.try_into().unwrap();
-        let size = size.try_into().unwrap();
-        let mut upload_out = vec![0u8; usize::try_from(size).unwrap()];
-        let test_uploader = TestUploadBuilder(&mut upload_out[..]);
-        block_on(fb.fetch(part.as_str(), off, size, test_uploader))?;
-        Ok(upload_out)
-    }
-
-    #[test]
-    fn test_fetch_invalid_partition_arg() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        // Missing mandatory block device ID for raw block partition.
-        assert!(fetch(&mut gbl_fb, "//0/0".into(), 0, 0).is_err());
-
-        // GPT partition does not exist.
-        assert!(fetch(&mut gbl_fb, "non///".into(), 0, 0).is_err());
-
-        // GPT Partition is not unique.
-        assert!(fetch(&mut gbl_fb, "vendor_boot_a///".into(), 0, 0).is_err());
-
-        // Offset overflows.
-        assert!(fetch(&mut gbl_fb, "boot_a//0x2001/".into(), 0, 1).is_err());
-        assert!(fetch(&mut gbl_fb, "boot_a".into(), 0x2000, 1).is_err());
-
-        // Size overflows.
-        assert!(fetch(&mut gbl_fb, "boot_a///0x2001".into(), 0, 0).is_err());
-        assert!(fetch(&mut gbl_fb, "boot_a".into(), 0, 0x2001).is_err());
-    }
-
-    /// A helper for testing raw block upload. It verifies that data read from block device
-    /// `blk_id` in range [`off`, `off`+`size`) is the same as `disk[off..][..size]`
-    fn check_blk_upload(
-        fb: &mut impl FastbootImplementation,
-        blk_id: u64,
-        off: u64,
-        size: u64,
-        disk: &[u8],
-    ) {
-        let expected = disk[off.try_into().unwrap()..][..size.try_into().unwrap()].to_vec();
-        // offset/size as part of the partition string.
-        let part = format!("/{:#x}/{:#x}/{:#x}", blk_id, off, size);
-        assert_eq!(fetch(fb, part, 0, size).unwrap(), expected);
-        // offset/size as separate fetch arguments.
-        let part = format!("/{:#x}", blk_id);
-        assert_eq!(fetch(fb, part, off, size).unwrap(), expected);
-    }
-
-    #[test]
-    fn test_fetch_raw_block() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        let disk_0 = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let disk_1 = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        storage.add_gpt_device(disk_0);
-        storage.add_gpt_device(disk_1);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        let off = 512;
-        let size = 512;
-        check_blk_upload(&mut gbl_fb, 0, off, size, disk_0);
-        check_blk_upload(&mut gbl_fb, 1, off, size, disk_1);
-    }
-
-    /// A helper for testing uploading GPT partition. It verifies that data read from GPT partition
-    /// `part` at disk `blk_id` in range [`off`, `off`+`size`) is the same as
-    /// `partition_data[off..][..size]`.
-    fn check_part_upload(
-        fb: &mut impl FastbootImplementation,
-        part: &str,
-        off: u64,
-        size: u64,
-        blk_id: Option<u64>,
-        partition_data: &[u8],
-    ) {
-        let expected =
-            partition_data[off.try_into().unwrap()..][..size.try_into().unwrap()].to_vec();
-        let blk_id = blk_id.map_or("".to_string(), |v| format!("{:#x}", v));
-        // offset/size as part of the partition string.
-        let gpt_part = format!("{}/{}/{:#x}/{:#x}", part, blk_id, off, size);
-        assert_eq!(fetch(fb, gpt_part, 0, size).unwrap(), expected);
-        // offset/size as separate fetch arguments.
-        let gpt_part = format!("{}/{}", part, blk_id);
-        assert_eq!(fetch(fb, gpt_part, off, size).unwrap(), expected);
-    }
-
-    #[test]
-    fn test_fetch_partition() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        storage.add_raw_device(c"raw_0", [0xaau8; KiB!(4)]);
-        storage.add_raw_device(c"raw_1", [0x55u8; KiB!(8)]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        let expect_boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
-        let expect_boot_b = include_bytes!("../../../libstorage/test/boot_b.bin");
-        let expect_vendor_boot_a = include_bytes!("../../../libstorage/test/vendor_boot_a.bin");
-        let expect_vendor_boot_b = include_bytes!("../../../libstorage/test/vendor_boot_b.bin");
-
-        let size = 512;
-        let off = 512;
-
-        check_part_upload(&mut gbl_fb, "boot_a", off, size, Some(0), expect_boot_a);
-        check_part_upload(&mut gbl_fb, "boot_b", off, size, Some(0), expect_boot_b);
-        check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, Some(1), expect_vendor_boot_a);
-        check_part_upload(&mut gbl_fb, "vendor_boot_b", off, size, Some(1), expect_vendor_boot_b);
-        check_part_upload(&mut gbl_fb, "raw_0", off, size, Some(2), &[0xaau8; KiB!(4)]);
-        check_part_upload(&mut gbl_fb, "raw_1", off, size, Some(3), &[0x55u8; KiB!(8)]);
-
-        // No block device id
-        check_part_upload(&mut gbl_fb, "boot_a", off, size, None, expect_boot_a);
-        check_part_upload(&mut gbl_fb, "boot_b", off, size, None, expect_boot_b);
-        check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, None, expect_vendor_boot_a);
-        check_part_upload(&mut gbl_fb, "vendor_boot_b", off, size, None, expect_vendor_boot_b);
-        check_part_upload(&mut gbl_fb, "raw_0", off, size, None, &[0xaau8; KiB!(4)]);
-        check_part_upload(&mut gbl_fb, "raw_1", off, size, None, &[0x55u8; KiB!(8)]);
-    }
-
-    /// A helper function to get a bit-flipped copy of the input data.
-    fn flipped_bits(data: &[u8]) -> Vec<u8> {
-        data.iter().map(|v| !(*v)).collect::<Vec<_>>()
-    }
-
-    /// A helper function to flash data to a partition
-    fn flash_part(fb: &mut impl FastbootImplementation, part: &str, data: &[u8]) {
-        // Prepare a download buffer.
-        let dl_size = data.len();
-        let download = data.to_vec();
-        let resp: TestResponder = Default::default();
-        set_download(fb, &download[..]);
-        block_on(fb.flash(part, &resp)).unwrap();
-        assert_eq!(fetch(fb, part.into(), 0, dl_size).unwrap(), download);
-    }
-
-    /// A helper for testing partition flashing.
-    fn check_flash_part(fb: &mut impl FastbootImplementation, part: &str, expected: &[u8]) {
-        flash_part(fb, part, expected);
-        // Also flashes bit-wise reversed version in case the initial content is the same.
-        flash_part(fb, part, &flipped_bits(expected));
-    }
-
-    #[test]
-    fn test_flash_partition() {
-        let disk_0 = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let disk_1 = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(disk_0);
-        storage.add_gpt_device(disk_1);
-        storage.add_raw_device(c"raw_0", [0xaau8; KiB!(4)]);
-        storage.add_raw_device(c"raw_1", [0x55u8; KiB!(8)]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        let expect_boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
-        let expect_boot_b = include_bytes!("../../../libstorage/test/boot_b.bin");
-        check_flash_part(&mut gbl_fb, "boot_a", expect_boot_a);
-        check_flash_part(&mut gbl_fb, "boot_b", expect_boot_b);
-        check_flash_part(&mut gbl_fb, "raw_0", &[0xaau8; KiB!(4)]);
-        check_flash_part(&mut gbl_fb, "raw_1", &[0x55u8; KiB!(8)]);
-        check_flash_part(&mut gbl_fb, "/0", disk_0);
-        check_flash_part(&mut gbl_fb, "/1", disk_1);
-
-        // Partital flash
-        let off = 0x200;
-        let size = 1024;
-        check_flash_part(&mut gbl_fb, "boot_a//200", &expect_boot_a[off..size]);
-        check_flash_part(&mut gbl_fb, "boot_b//200", &expect_boot_b[off..size]);
-        check_flash_part(&mut gbl_fb, "/0/200", &disk_0[off..size]);
-        check_flash_part(&mut gbl_fb, "/1/200", &disk_1[off..size]);
-    }
-
-    #[test]
-    fn test_flash_partition_sparse() {
-        let raw = include_bytes!("../../testdata/sparse_test_raw.bin");
-        let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"raw", vec![0u8; raw.len()]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-
-        let download = sparse.to_vec();
-        let resp: TestResponder = Default::default();
-        set_download(&mut gbl_fb, &download[..]);
-        block_on(gbl_fb.flash("/0", &resp)).unwrap();
-        assert_eq!(fetch(&mut gbl_fb, "/0".into(), 0, raw.len()).unwrap(), raw);
-    }
-
-    /// A helper to invoke OEM commands.
-    ///
-    /// Returns the result and INFO strings.
-    async fn oem(
-        fb: &mut impl FastbootImplementation,
-        oem_cmd: &str,
-        resp: impl InfoSender,
-    ) -> CommandResult<String> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        fb.oem(oem_cmd, resp, &mut res[..]).await?;
-        Ok(from_utf8(&mut res[..]).unwrap().into())
-    }
-
-    #[test]
-    fn test_async_flash() {
-        // Creates two block devices for writing raw and sparse image.
-        let sparse_raw = include_bytes!("../../testdata/sparse_test_raw.bin");
-        let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(vec![0u8; sparse_raw.len() + 67 * 512]);
-        let mut gpt_builder = storage[1].gpt_builder().unwrap();
-        gpt_builder.add("sparse", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, None).unwrap();
-        block_on(gpt_builder.persist()).unwrap();
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        // "oem gbl-sync-tasks" should return immediately when there is no pending IOs.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-sync-tasks", &resp))).unwrap().is_ok());
-        // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
-
-        // Flashes "boot_a".
-        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
-        set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
-        check_var(&mut gbl_fb, "block-device", "0:status", "IO pending");
-
-        // Flashes the "sparse" partition on the different block device.
-        set_download(&mut gbl_fb, sparse);
-        block_on(gbl_fb.flash("sparse", &resp)).unwrap();
-        check_var(&mut gbl_fb, "block-device", "1:status", "IO pending");
-
-        {
-            // "oem gbl-sync-tasks" should block.
-            let oem_sync_blk_fut = &mut pin!(oem(&mut gbl_fb, "gbl-sync-tasks", &resp));
-            assert!(poll(oem_sync_blk_fut).is_none());
-            // Schedules the disk IO tasks to completion.
-            tasks.borrow_mut().run();
-            // "oem gbl-sync-tasks" should now be able to finish.
-            assert!(poll(oem_sync_blk_fut).unwrap().is_ok());
-        }
-
-        // The two blocks should be in the idle state.
-        check_var(&mut gbl_fb, "block-device", "0:status", "idle");
-        check_var(&mut gbl_fb, "block-device", "1:status", "idle");
-
-        // Verifies flashed image.
-        assert_eq!(
-            fetch(&mut gbl_fb, "boot_a".into(), 0, expect_boot_a.len()).unwrap(),
-            expect_boot_a
-        );
-        assert_eq!(fetch(&mut gbl_fb, "sparse".into(), 0, sparse_raw.len()).unwrap(), sparse_raw);
-    }
-
-    #[test]
-    fn test_async_flash_block_on_busy_blk() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
-
-        // Flashes boot_a partition.
-        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
-        set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
-
-        // Flashes boot_b partition.
-        let expect_boot_b = flipped_bits(include_bytes!("../../../libstorage/test/boot_b.bin"));
-        set_download(&mut gbl_fb, expect_boot_b.as_slice());
-        {
-            let flash_boot_b_fut = &mut pin!(gbl_fb.flash("boot_b", &resp));
-            // Previous IO has not completed. Block is busy.
-            assert!(poll(flash_boot_b_fut).is_none());
-            // There should only be the previous disk IO task for "boot_a".
-            assert_eq!(tasks.borrow_mut().size(), 1);
-            // Schedule the disk IO task for "flash boot_a" to completion.
-            tasks.borrow_mut().run();
-            // The blocked "flash boot_b" should now be able to finish.
-            assert!(poll(flash_boot_b_fut).is_some());
-            // There should be a disk IO task spawned for "flash boot_b".
-            assert_eq!(tasks.borrow_mut().size(), 1);
-            // Schedule the disk IO tasks for "flash boot_b" to completion.
-            tasks.borrow_mut().run();
-        }
-
-        // Verifies flashed image.
-        assert_eq!(
-            fetch(&mut gbl_fb, "boot_a".into(), 0, expect_boot_a.len()).unwrap(),
-            expect_boot_a
-        );
-        assert_eq!(
-            fetch(&mut gbl_fb, "boot_b".into(), 0, expect_boot_b.len()).unwrap(),
-            expect_boot_b
-        );
-    }
-
-    #[test]
-    #[should_panic(
-        expected = "A Fastboot async task failed: Other(Some(\"test\")), context: flash:boot_a"
-    )]
-    fn test_async_flash_error() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        // Injects an error.
-        storage[0].partition_io(None).unwrap().dev().io().error =
-            liberror::Error::Other(Some("test")).into();
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
-        // Flashes boot_a partition.
-        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
-        set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
-        // Schedules the disk IO tasks to completion.
-        tasks.borrow_mut().run();
-    }
-
-    #[test]
-    fn test_async_erase() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"raw_0", [0xaau8; 4096]);
-        storage.add_raw_device(c"raw_1", [0x55u8; 4096]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
-
-        // Erases "raw_0".
-        block_on(gbl_fb.erase("raw_0", &resp)).unwrap();
-        check_var(&mut gbl_fb, "block-device", "0:status", "IO pending");
-
-        // Erases second half of "raw_1"
-        block_on(gbl_fb.erase("raw_1//800", &resp)).unwrap();
-        check_var(&mut gbl_fb, "block-device", "1:status", "IO pending");
-
-        {
-            // "oem gbl-sync-tasks" should block.
-            let oem_sync_blk_fut = &mut pin!(oem(&mut gbl_fb, "gbl-sync-tasks", &resp));
-            assert!(poll(oem_sync_blk_fut).is_none());
-            // Schedules the disk IO tasks to completion.
-            tasks.borrow_mut().run();
-            // "oem gbl-sync-tasks" should now be able to finish.
-            assert!(poll(oem_sync_blk_fut).unwrap().is_ok());
-        }
-
-        // The two blocks should be in the idle state.
-        check_var(&mut gbl_fb, "block-device", "0:status", "idle");
-        check_var(&mut gbl_fb, "block-device", "1:status", "idle");
-
-        assert_eq!(storage[0].partition_io(None).unwrap().dev().io().storage, [0u8; 4096]);
-        assert_eq!(
-            storage[1].partition_io(None).unwrap().dev().io().storage,
-            [[0x55u8; 2048], [0u8; 2048]].concat()
-        );
-    }
-
-    #[test]
-    #[should_panic(
-        expected = "A Fastboot async task failed: Other(Some(\"test\")), context: erase:boot_a"
-    )]
-    fn test_async_erase_error() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        // Injects an error.
-        storage[0].partition_io(None).unwrap().dev().io().error =
-            liberror::Error::Other(Some("test")).into();
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
-        // Erases boot_a partition.
-        block_on(gbl_fb.erase("boot_a", &resp)).unwrap();
-        // Schedules the disk IO tasks to completion.
-        tasks.borrow_mut().run();
-    }
-
-    #[test]
-    fn test_default_block() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 1]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let disk_dup = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        storage.add_gpt_device(disk_dup);
-        storage.add_gpt_device(disk_dup);
-        let raw_a = [0xaau8; KiB!(4)];
-        let raw_b = [0x55u8; KiB!(8)];
-        storage.add_raw_device(c"raw", raw_a);
-        storage.add_raw_device(c"raw", raw_b);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let resp: TestResponder = Default::default();
-
-        let boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
-        // Flips the bits on partition "vendor_boot_a" on block device #2 to make it different from
-        // block #1.
-        let vendor_boot_a =
-            flipped_bits(include_bytes!("../../../libstorage/test/vendor_boot_a.bin"));
-        flash_part(&mut gbl_fb, "vendor_boot_a/2", &vendor_boot_a);
-
-        let size = 512;
-        let off = 512;
-
-        check_var(&mut gbl_fb, "gbl-default-block", "", "None");
-        // Sets default block to #2
-        block_on(oem(&mut gbl_fb, "gbl-set-default-block 2", &resp)).unwrap();
-        check_var(&mut gbl_fb, "gbl-default-block", "", "0x2");
-        // The following fetch should succeed and fetch from "vendor_boot_a" on block 2.
-        check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, None, &vendor_boot_a);
-
-        // Sets default block to #4 (raw_b)
-        block_on(oem(&mut gbl_fb, "gbl-set-default-block 4", &resp)).unwrap();
-        check_var(&mut gbl_fb, "gbl-default-block", "", "0x4");
-        // The following fetch should succeed and fetch from "raw" on block 4.
-        check_part_upload(&mut gbl_fb, "raw", off, size, None, &raw_b);
-
-        // Fetches with explicit storage ID shouldn't be affected.
-        check_part_upload(&mut gbl_fb, "boot_a", off, size, Some(0), boot_a);
-        check_part_upload(&mut gbl_fb, "raw", off, size, Some(3), &raw_a);
-        check_blk_upload(&mut gbl_fb, 1, off, size, disk_dup);
-
-        // Fetching without storage ID should use default ID and thus the following should fail.
-        assert!(fetch(&mut gbl_fb, "boot_a".into(), 0, boot_a.len()).is_err());
-
-        // Sets default block to #1 (unmodified `disk_dup`)
-        block_on(oem(&mut gbl_fb, "gbl-set-default-block 1", &resp)).unwrap();
-        check_var(&mut gbl_fb, "gbl-default-block", "", "0x1");
-        // Fetches whole raw block but without block ID should use the default block.
-        check_part_upload(&mut gbl_fb, "", off, size, None, disk_dup);
-
-        // Unset default block
-        block_on(oem(&mut gbl_fb, "gbl-unset-default-block", &resp)).unwrap();
-        check_var(&mut gbl_fb, "gbl-default-block", "", "None");
-        // Fetching non-unique partitions should now fail.
-        assert!(fetch(&mut gbl_fb, "raw".into(), 0, raw_a.len()).is_err());
-        assert!(fetch(&mut gbl_fb, "vendor_boot_a".into(), 0, vendor_boot_a.len()).is_err());
-        assert!(fetch(&mut gbl_fb, "/".into(), 0, 512).is_err());
-    }
-
-    #[test]
-    fn test_set_default_block_invalid_arg() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let storage = FakeGblOpsStorage::default();
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let resp: TestResponder = Default::default();
-        // Missing block device ID.
-        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block ", &resp)).is_err());
-        // Invalid block device ID.
-        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block zzz", &resp)).is_err());
-        // Out of range block device ID. (We've added no block device).
-        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block 0", &resp)).is_err());
-    }
-
-    #[test]
-    fn test_reboot_sync_all_blocks() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        block_on(oem(&mut gbl_fb, "gbl-enable-async-task", &resp)).unwrap();
-
-        // Flashes "boot_a".
-        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
-        set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
-        // Checks initial state, okay_sent=false.
-        assert!(!(*resp.okay_sent.try_lock().unwrap()));
-        // Performs a reboot.
-        let mut reboot_fut = pin!(gbl_fb.reboot(RebootMode::Normal, &resp));
-        // There is a pending flash task. Reboot should wait.
-        assert!(poll(&mut reboot_fut).is_none());
-        assert!(!(*resp.okay_sent.try_lock().unwrap()));
-        assert_eq!(resp.info_messages.try_lock().unwrap()[1], "Syncing storage...");
-        // Schedules the disk IO tasks to completion.
-        tasks.borrow_mut().run();
-        // The reboot can now complete.
-        assert!(poll(&mut reboot_fut).is_some());
-        assert!((*resp.okay_sent.try_lock().unwrap()));
-        assert_eq!(resp.info_messages.try_lock().unwrap()[2], "Rebooting...");
-    }
-
-    #[test]
-    fn test_continue_sync_all_blocks() {
-        let dl_buffers = Shared::from(vec![vec![0u8; KiB!(128)]; 2]);
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let tasks = vec![].into();
-        let parts = gbl_ops.disks();
-        let mut gbl_fb =
-            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
-        let tasks = gbl_fb.tasks();
-        let resp: TestResponder = Default::default();
-
-        block_on(oem(&mut gbl_fb, "gbl-enable-async-task", &resp)).unwrap();
-
-        // Flashes "boot_a".
-        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
-        set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
-        // Performs a continue.
-        let mut continue_fut = pin!(gbl_fb.r#continue(&resp));
-        // There is a pending flash task. Continue should wait.
-        assert!(poll(&mut continue_fut).is_none());
-        assert!(!(*resp.okay_sent.try_lock().unwrap()));
-        assert_eq!(resp.info_messages.try_lock().unwrap()[1], "Syncing storage...");
-        // Schedules the disk IO tasks to completion.
-        tasks.borrow_mut().run();
-        // The continue can now complete.
-        assert!(poll(&mut continue_fut).is_some());
-    }
-
-    /// Generates a length prefixed byte sequence.
-    fn length_prefixed(data: &[u8]) -> Vec<u8> {
-        [&data.len().to_be_bytes()[..], data].concat()
-    }
-
-    /// Used for a test implementation of [GblUsbTransport] and [GblTcpStream].
-    #[derive(Default)]
-    struct TestListener {
-        usb_in_queue: VecDeque<Vec<u8>>,
-        usb_out_queue: VecDeque<Vec<u8>>,
-
-        tcp_in_queue: VecDeque<u8>,
-        tcp_out_queue: VecDeque<u8>,
-    }
-
-    /// A shared [TestListener].
-    #[derive(Default)]
-    pub(crate) struct SharedTestListener(Mutex<TestListener>);
-
-    impl SharedTestListener {
-        /// Locks the listener
-        fn lock(&self) -> MutexGuard<TestListener> {
-            self.0.try_lock().unwrap()
-        }
-
-        /// Adds packet to USB input
-        pub(crate) fn add_usb_input(&self, packet: &[u8]) {
-            self.lock().usb_in_queue.push_back(packet.into());
-        }
-
-        /// Adds bytes to input stream.
-        pub(crate) fn add_tcp_input(&self, data: &[u8]) {
-            self.lock().tcp_in_queue.append(&mut data.to_vec().into());
-        }
-
-        /// Adds a length pre-fixed bytes stream.
-        pub(crate) fn add_tcp_length_prefixed_input(&self, data: &[u8]) {
-            self.add_tcp_input(&length_prefixed(data));
-        }
-
-        /// Gets a copy of `Self::usb_out_queue`.
-        pub(crate) fn usb_out_queue(&self) -> VecDeque<Vec<u8>> {
-            self.lock().usb_out_queue.clone()
-        }
-
-        /// Gets a copy of `Self::tcp_out_queue`.
-        pub(crate) fn tcp_out_queue(&self) -> VecDeque<u8> {
-            self.lock().tcp_out_queue.clone()
-        }
-
-        /// A helper for decoding USB output packets as a string
-        pub(crate) fn dump_usb_out_queue(&self) -> String {
-            let mut res = String::from("");
-            for v in self.lock().usb_out_queue.iter() {
-                let v = String::from_utf8(v.clone()).unwrap_or(format!("{:?}", v));
-                res += format!("b{:?},\n", v).as_str();
-            }
-            res
-        }
-
-        /// A helper for decoding TCP output data as strings
-        pub(crate) fn dump_tcp_out_queue(&self) -> String {
-            let mut data = self.lock();
-            let mut v;
-            let (_, mut remains) = data.tcp_out_queue.make_contiguous().split_at(4);
-            let mut res = String::from("");
-            while !remains.is_empty() {
-                // Parses length-prefixed payload.
-                let (len, rest) = remains.split_first_chunk::<{ size_of::<u64>() }>().unwrap();
-                (v, remains) = rest.split_at(u64::from_be_bytes(*len).try_into().unwrap());
-                let s = String::from_utf8(v.to_vec()).unwrap_or(format!("{:?}", v));
-                res += format!("b{:?},\n", s).as_str();
-            }
-            res
-        }
-    }
-
-    impl Transport for &SharedTestListener {
-        async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, Error> {
-            match self.lock().usb_in_queue.pop_front() {
-                Some(v) => Ok((&v[..]).read(out).unwrap()),
-                _ => Err(Error::Other(Some("No more data"))),
-            }
-        }
-
-        async fn send_packet(&mut self, packet: &[u8]) -> Result<(), Error> {
-            Ok(self.lock().usb_out_queue.push_back(packet.into()))
-        }
-    }
-
-    impl GblUsbTransport for &SharedTestListener {
-        fn has_packet(&mut self) -> bool {
-            !self.lock().usb_in_queue.is_empty()
-        }
-    }
-
-    impl TcpStream for &SharedTestListener {
-        async fn read_exact(&mut self, out: &mut [u8]) -> Result<(), Error> {
-            match self.lock().tcp_in_queue.read(out).unwrap() == out.len() {
-                true => Ok(()),
-                _ => Err(Error::Other(Some("No more data"))),
-            }
-        }
-
-        async fn write_exact(&mut self, data: &[u8]) -> Result<(), Error> {
-            Ok(self.lock().tcp_out_queue.append(&mut data.to_vec().into()))
-        }
-    }
-
-    impl GblTcpStream for &SharedTestListener {
-        fn accept_new(&mut self) -> bool {
-            !self.lock().tcp_in_queue.is_empty()
-        }
-    }
-
-    /// A helper to make an expected stream of USB output.
-    pub(crate) fn make_expected_usb_out(data: &[&[u8]]) -> VecDeque<Vec<u8>> {
-        VecDeque::from(data.iter().map(|v| v.to_vec()).collect::<Vec<_>>())
-    }
-
-    /// A helper to make an expected stream of TCP output.
-    fn make_expected_tcp_out(data: &[&[u8]]) -> VecDeque<u8> {
-        let mut res = VecDeque::<u8>::from(b"FB01".to_vec());
-        data.iter().for_each(|v| res.append(&mut length_prefixed(v).into()));
-        res
-    }
-
-    #[derive(Default)]
-    pub(crate) struct TestLocalSession {
-        requests: VecDeque<&'static str>,
-        outgoing_packets: VecDeque<Vec<u8>>,
-    }
-
-    impl LocalSession for &mut TestLocalSession {
-        async fn update(&mut self, buf: &mut [u8]) -> Result<usize, Error> {
-            let Some(front) = self.requests.pop_front() else {
-                return Ok(0);
-            };
-            let front_len = front.len();
-            if front_len >= buf.len() {
-                self.requests.push_front(front);
-                return Err(Error::BufferTooSmall(Some(front_len)));
-            }
-            buf[..front_len].copy_from_slice(front.as_bytes());
-            buf[front_len] = b'\0';
-            Ok(front_len)
-        }
-
-        async fn process_outgoing_packet(&mut self, buf: &[u8]) {
-            self.outgoing_packets.push_back(buf.into());
-        }
-    }
-
-    impl From<&[&'static str]> for TestLocalSession {
-        fn from(elts: &[&'static str]) -> Self {
-            let elts = elts.into_iter();
-            let mut requests = VecDeque::with_capacity(elts.len());
-            for e in elts {
-                requests.push_back(*e);
-            }
-            Self { requests, outgoing_packets: VecDeque::new() }
-        }
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"getvar:version-bootloader");
-        listener.add_tcp_input(b"FB01");
-        listener.add_tcp_length_prefixed_input(b"getvar:max-download-size");
-        listener.add_tcp_length_prefixed_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"OKAY1.0"]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        assert_eq!(
-            listener.tcp_out_queue(),
-            make_expected_tcp_out(&[b"OKAY0x20000", b"INFOSyncing storage...", b"OKAY"]),
-            "\nActual TCP output:\n{}",
-            listener.dump_tcp_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_local_session() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let mut local = TestLocalSession::from(["reboot", "continue"].as_slice());
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut local),
-            None::<&SharedTestListener>,
-            None::<&SharedTestListener>,
-            &mut [],
-        ));
-
-        assert!(gbl_ops.rebooted);
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_parallel_task() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"raw_0", [0u8; KiB!(4)]);
-        storage.add_raw_device(c"raw_1", [0u8; KiB!(8)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-        let mut local = TestLocalSession::from(["getvar:all"].as_slice());
-
-        // New scope to release reference on local
-        {
-            let mut fb_fut = pin!(run_gbl_fastboot_stack::<3>(
-                &mut gbl_ops,
-                buffers,
-                Some(&mut local),
-                Some(usb),
-                Some(tcp),
-                &mut []
-            ));
-
-            listener.add_usb_input(b"oem gbl-enable-async-task");
-            listener.add_usb_input(format!("download:{:#x}", KiB!(4)).as_bytes());
-            listener.add_usb_input(&[0x55u8; KiB!(4)]);
-            listener.add_usb_input(b"flash:raw_0");
-
-            listener.add_tcp_input(b"FB01");
-            listener.add_tcp_length_prefixed_input(format!("download:{:#x}", KiB!(8)).as_bytes());
-            listener.add_tcp_length_prefixed_input(&[0xaau8; KiB!(8)]);
-            listener.add_tcp_length_prefixed_input(b"flash:raw_1");
-
-            assert!(poll_n_times(&mut fb_fut, 100).is_none());
-        }
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"OKAY",
-                b"DATA00001000",
-                b"OKAY",
-                b"INFOAn async task is launched. To sync manually, run \"oem gbl-sync-tasks\".",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        assert_eq!(
-            listener.tcp_out_queue(),
-            make_expected_tcp_out(&[
-                b"DATA00002000",
-                b"OKAY",
-                b"INFOAn async task is launched. To sync manually, run \"oem gbl-sync-tasks\".",
-                b"OKAY",
-            ]),
-            "\nActual TCP output:\n{}",
-            listener.dump_tcp_out_queue()
-        );
-
-        assert_eq!(
-            local.outgoing_packets,
-            VecDeque::from(vec![
-                Vec::from(b"INFOmax-download-size: 0x20000"),
-                Vec::from(b"INFOversion-bootloader: 1.0"),
-                Vec::from(b"INFOmax-fetch-size: 0xffffffffffffffff"),
-                Vec::from(b"INFOblock-device:0:total-blocks: 0x1000"),
-                Vec::from(b"INFOblock-device:0:block-size: 0x1"),
-                Vec::from(b"INFOblock-device:0:status: idle"),
-                Vec::from(b"INFOblock-device:1:total-blocks: 0x2000"),
-                Vec::from(b"INFOblock-device:1:block-size: 0x1"),
-                Vec::from(b"INFOblock-device:1:status: idle"),
-                Vec::from(b"INFOgbl-default-block: None"),
-                Vec::from(b"INFOpartition-size:raw_0/0: 0x1000"),
-                Vec::from(b"INFOpartition-type:raw_0/0: raw"),
-                Vec::from(b"INFOpartition-size:raw_1/1: 0x2000"),
-                Vec::from(b"INFOpartition-type:raw_1/1: raw"),
-                Vec::from(b"INFOgbl-test-var:1: gbl-test-var-val:1"),
-                Vec::from(b"INFOgbl-test-var:2: gbl-test-var-val:2"),
-                Vec::from(b"OKAY"),
-            ])
-        );
-
-        // Verifies flashed image on raw_0.
-        assert_eq!(storage[0].partition_io(None).unwrap().dev().io().storage, [0x55u8; KiB!(4)]);
-
-        // Verifies flashed image on raw_1.
-        assert_eq!(storage[1].partition_io(None).unwrap().dev().io().storage, [0xaau8; KiB!(8)]);
-    }
-
-    #[test]
-    fn test_oem_add_staged_bootloader_file() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.get_zbi_bootloader_files_buffer().unwrap().fill(0);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        // Stages two zbi files.
-        listener.add_usb_input(format!("download:{:#x}", 3).as_bytes());
-        listener.add_usb_input(b"foo");
-        listener.add_usb_input(b"oem add-staged-bootloader-file file_1");
-        listener.add_usb_input(format!("download:{:#x}", 3).as_bytes());
-        listener.add_usb_input(b"bar");
-        listener.add_usb_input(b"oem add-staged-bootloader-file file_2");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        let buffer = gbl_ops.get_zbi_bootloader_files_buffer_aligned().unwrap();
-        let container = ZbiContainer::parse(&buffer[..]).unwrap();
-        let mut iter = container.iter();
-        assert_eq!(iter.next().unwrap().payload.as_bytes(), b"\x06file_1foo");
-        assert_eq!(iter.next().unwrap().payload.as_bytes(), b"\x06file_2bar");
-        assert!(iter.next().is_none());
-    }
-
-    #[test]
-    fn test_oem_add_staged_bootloader_file_missing_file_name() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(format!("download:{:#x}", 3).as_bytes());
-        listener.add_usb_input(b"foo");
-        listener.add_usb_input(b"oem add-staged-bootloader-file");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"DATA00000003",
-                b"OKAY",
-                b"FAILMissing file name",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        )
-    }
-
-    #[test]
-    fn test_oem_add_staged_bootloader_file_missing_download() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"oem add-staged-bootloader-file file1");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"FAILNo file staged", b"INFOSyncing storage...", b"OKAY",]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_fuchsia_fastboot_mdns_packet() {
-        let expected = [
-            0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x09, 0x5f,
-            0x66, 0x61, 0x73, 0x74, 0x62, 0x6f, 0x6f, 0x74, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x05,
-            0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78,
-            0x00, 0x19, 0x16, 0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x35, 0x32, 0x35,
-            0x34, 0x2d, 0x30, 0x30, 0x31, 0x32, 0x2d, 0x33, 0x34, 0x35, 0x36, 0xc0, 0x0c, 0xc0,
-            0x2c, 0x00, 0x21, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x1f, 0x00, 0x00, 0x00,
-            0x00, 0x15, 0xb2, 0x16, 0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x35, 0x32,
-            0x35, 0x34, 0x2d, 0x30, 0x30, 0x31, 0x32, 0x2d, 0x33, 0x34, 0x35, 0x36, 0xc0, 0x1b,
-            0xc0, 0x57, 0x00, 0x1c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x10, 0xfe, 0x80,
-            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x54, 0x00, 0xff, 0xfe, 0x12, 0x34, 0x56,
-        ];
-        let ip6_addr = &[
-            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x54, 0x00, 0xff, 0xfe, 0x12,
-            0x34, 0x56,
-        ];
-        assert_eq!(
-            fuchsia_fastboot_mdns_packet("fuchsia-5254-0012-3456", ip6_addr).unwrap(),
-            expected
-        );
-    }
-
-    #[test]
-    fn test_fuchsia_fastboot_mdns_packet_invalid_node_name() {
-        let ip6_addr = &[
-            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x54, 0x00, 0xff, 0xfe, 0x12,
-            0x34, 0x56,
-        ];
-        assert!(fuchsia_fastboot_mdns_packet("fuchsia-5254-0012-345", ip6_addr).is_err());
-        assert!(fuchsia_fastboot_mdns_packet("fuchsia-5254-0012-34567", ip6_addr).is_err());
-    }
-
-    #[test]
-    fn test_oem_update_gpt() {
-        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        // Erase the primary and secondary header.
-        let mut disk = disk_orig.to_vec();
-        disk[512..][..512].fill(0);
-        disk.last_chunk_mut::<512>().unwrap().fill(0);
-
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(&disk);
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        // Checks that there is no valid partitions for block #0.
-        listener.add_usb_input(b"getvar:partition-size:boot_a");
-        listener.add_usb_input(b"getvar:partition-size:boot_b");
-        // No partitions on block #0 should show up in `getvar:all` despite being a GPT device,
-        // since the GPTs are corrupted.
-        listener.add_usb_input(b"getvar:all");
-        // Download a GPT
-        let gpt = &disk_orig[..34 * 512];
-        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
-        listener.add_usb_input(gpt);
-        listener.add_usb_input(b"flash:gpt/0");
-        // Checks that we can get partition info now.
-        listener.add_usb_input(b"getvar:partition-size:boot_a");
-        listener.add_usb_input(b"getvar:partition-size:boot_b");
-        listener.add_usb_input(b"getvar:all");
-
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"FAILNotFound",
-                b"FAILNotFound",
-                b"INFOmax-download-size: 0x20000",
-                b"INFOversion-bootloader: 1.0",
-                b"INFOmax-fetch-size: 0xffffffffffffffff",
-                b"INFOblock-device:0:total-blocks: 0x80",
-                b"INFOblock-device:0:block-size: 0x200",
-                b"INFOblock-device:0:status: idle",
-                b"INFOblock-device:1:total-blocks: 0x100",
-                b"INFOblock-device:1:block-size: 0x200",
-                b"INFOblock-device:1:status: idle",
-                b"INFOgbl-default-block: None",
-                b"INFOpartition-size:vendor_boot_a/1: 0x1000",
-                b"INFOpartition-type:vendor_boot_a/1: raw",
-                b"INFOpartition-size:vendor_boot_b/1: 0x1800",
-                b"INFOpartition-type:vendor_boot_b/1: raw",
-                format!("INFO{}:1: {}:1", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
-                    .as_bytes(),
-                format!("INFO{}:2: {}:2", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
-                    .as_bytes(),
-                b"OKAY",
-                b"DATA00004400",
-                b"OKAY",
-                b"INFOUpdating GPT...",
-                b"OKAY",
-                b"OKAY0x2000",
-                b"OKAY0x3000",
-                b"INFOmax-download-size: 0x20000",
-                b"INFOversion-bootloader: 1.0",
-                b"INFOmax-fetch-size: 0xffffffffffffffff",
-                b"INFOblock-device:0:total-blocks: 0x80",
-                b"INFOblock-device:0:block-size: 0x200",
-                b"INFOblock-device:0:status: idle",
-                b"INFOblock-device:1:total-blocks: 0x100",
-                b"INFOblock-device:1:block-size: 0x200",
-                b"INFOblock-device:1:status: idle",
-                b"INFOgbl-default-block: None",
-                b"INFOpartition-size:boot_a/0: 0x2000",
-                b"INFOpartition-type:boot_a/0: raw",
-                b"INFOpartition-size:boot_b/0: 0x3000",
-                b"INFOpartition-type:boot_b/0: raw",
-                b"INFOpartition-size:vendor_boot_a/1: 0x1000",
-                b"INFOpartition-type:vendor_boot_a/1: raw",
-                b"INFOpartition-size:vendor_boot_b/1: 0x1800",
-                b"INFOpartition-type:vendor_boot_b/1: raw",
-                format!("INFO{}:1: {}:1", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
-                    .as_bytes(),
-                format!("INFO{}:2: {}:2", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
-                    .as_bytes(),
-                b"OKAY",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_update_gpt_resize() {
-        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let mut disk = disk_orig.to_vec();
-        // Doubles the size of the disk
-        disk.resize(disk_orig.len() * 2, 0);
-
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        storage.add_gpt_device(&disk);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        // Checks current size of last partition `boot_b`.
-        listener.add_usb_input(b"getvar:partition-size:boot_b");
-        // Sets a default block.
-        listener.add_usb_input(b"oem gbl-set-default-block 1");
-        let gpt = &disk_orig[..34 * 512];
-        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
-        listener.add_usb_input(gpt);
-        // No need to specify block device index
-        listener.add_usb_input(b"flash:gpt//resize");
-        // Checks updated size of last partition `boot_b`.
-        listener.add_usb_input(b"getvar:partition-size:boot_b");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"OKAY0x3000",
-                b"INFODefault block device: 0x1",
-                b"OKAY",
-                b"DATA00004400",
-                b"OKAY",
-                b"INFOUpdating GPT...",
-                b"OKAY",
-                b"OKAY0x15a00",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_update_gpt_no_downloaded_gpt() {
-        let disk = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(&disk);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"flash:gpt/0");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"FAILNo GPT downloaded", b"INFOSyncing storage...", b"OKAY",]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_update_gpt_bad_gpt() {
-        let disk = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(&disk);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-        // Download a bad GPT.
-        let mut gpt = disk[..34 * 512].to_vec();
-        gpt[512] = !gpt[512];
-        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
-        listener.add_usb_input(&gpt);
-        listener.add_usb_input(b"flash:gpt/0");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"DATA00004400",
-                b"OKAY",
-                b"INFOUpdating GPT...",
-                b"FAILGptError(\n    IncorrectMagic(\n        6075990659671082682,\n    ),\n)",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_update_gpt_invalid_input() {
-        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(&disk_orig);
-        storage.add_gpt_device(&disk_orig);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        let gpt = &disk_orig[..34 * 512];
-        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
-        listener.add_usb_input(gpt);
-        // Missing block device ID.
-        listener.add_usb_input(b"flash:gpt");
-        // Out of range block device ID.
-        listener.add_usb_input(b"flash:gpt/2");
-        // Invalid option.
-        listener.add_usb_input(b"flash:gpt/0/invalid-arg");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"DATA00004400",
-                b"OKAY",
-                b"FAILBlock ID is required for flashing GPT",
-                b"FAILInvalid block ID",
-                b"FAILUnknown argument",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_update_gpt_fail_on_raw_blk() {
-        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"raw_0", [0u8; KiB!(1024)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        let gpt = &disk_orig[..34 * 512];
-        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
-        listener.add_usb_input(gpt);
-        listener.add_usb_input(b"flash:gpt/0");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"DATA00004400",
-                b"OKAY",
-                b"INFOUpdating GPT...",
-                b"FAILBlock device is not for GPT",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_erase_gpt() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        // Erases the GPT on disk #0.
-        listener.add_usb_input(b"erase:gpt/0");
-        // Checks that we can no longer get partition info on disk #0.
-        listener.add_usb_input(b"getvar:partition-size:boot_a");
-        listener.add_usb_input(b"getvar:partition-size:boot_b");
-        // Checks that we can still get partition info on disk #1.
-        listener.add_usb_input(b"getvar:partition-size:vendor_boot_a");
-        listener.add_usb_input(b"getvar:partition-size:vendor_boot_b");
-        listener.add_usb_input(b"continue");
-
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"OKAY",
-                b"FAILNotFound",
-                b"FAILNotFound",
-                b"OKAY0x1000",
-                b"OKAY0x1800",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_oem_erase_gpt_fail_on_raw_blk() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"raw_0", [0u8; KiB!(1024)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"erase:gpt/0");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"FAILBlock device is not for GPT",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    /// Helper for testing fastboot set_active in fuchsia A/B/R mode.
-    fn test_run_gbl_fastboot_set_active_fuchsia_abr(slot_ch: char, slot: SlotIndex) {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; KiB!(4)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        mark_slot_unbootable(&mut GblAbrOps(&mut gbl_ops), SlotIndex::A).unwrap();
-        mark_slot_unbootable(&mut GblAbrOps(&mut gbl_ops), SlotIndex::B).unwrap();
-
-        // Flash some data to `durable_boot` after A/B/R metadata. This is for testing that sync
-        // storage is done first.
-        let data = vec![0x55u8; KiB!(4) - ABR_DATA_SIZE];
-        listener.add_usb_input(b"oem gbl-enable-async-task");
-        listener.add_usb_input(format!("download:{:#x}", KiB!(4) - ABR_DATA_SIZE).as_bytes());
-        listener.add_usb_input(&data);
-        listener.add_usb_input(format!("flash:durable_boot//{:#x}", ABR_DATA_SIZE).as_bytes());
-        // Issues set_active commands
-        listener.add_usb_input(format!("set_active:{slot_ch}").as_bytes());
-        listener.add_usb_input(b"continue");
-        let res = block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-        assert_eq!(res.last_set_active_slot, Some(slot_ch));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"OKAY",
-                b"DATA00000fe0",
-                b"OKAY",
-                b"INFOAn async task is launched. To sync manually, run \"oem gbl-sync-tasks\".",
-                b"OKAY",
-                b"OKAY",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (slot, false));
-        // Verifies storage sync
-        assert_eq!(
-            storage[0].partition_io(None).unwrap().dev().io().storage[ABR_DATA_SIZE..],
-            data
-        );
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_set_active_fuchsia_abr_a() {
-        test_run_gbl_fastboot_set_active_fuchsia_abr('a', SlotIndex::A);
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_set_active_fuchsia_abr_b() {
-        test_run_gbl_fastboot_set_active_fuchsia_abr('b', SlotIndex::B);
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_set_active_fuchsia_abr_invalid_slot() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; KiB!(4)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"set_active:r");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"FAILInvalid slot index for Fuchsia A/B/R",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_set_active_android() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Android);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"set_active:b");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<2>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"OKAY", b"INFOSyncing storage...", b"OKAY",]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-        assert_eq!(gbl_ops.last_set_active_slot, Some(1));
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_set_active_multichar_slot() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-        listener.add_usb_input(b"set_active:ab");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"FAILSlot suffix must be one character",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_fuchsia_reboot_bootloader_abr() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; KiB!(4)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"reboot-bootloader");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"INFOSyncing storage...",
-                b"INFORebooting to bootloader...",
-                b"OKAY",
-                b"FAILUnknown",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        assert_eq!(get_and_clear_one_shot_bootloader(&mut GblAbrOps(&mut gbl_ops)), Ok(true));
-    }
-
-    #[test]
-    fn test_run_gbl_fastboot_fuchsia_reboot_recovery_abr() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; KiB!(4)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(b"reboot-recovery");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"INFOSyncing storage...",
-                b"INFORebooting to recovery...",
-                b"OKAY",
-                b"FAILUnknown",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        // One shot recovery is set.
-        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::R, false));
-        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::A, false));
-    }
-
-    #[test]
-    fn test_legacy_fvm_partition_alias() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"fuchsia-fvm", [0x00u8; KiB!(4)]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        listener.add_usb_input(format!("download:{:#x}", KiB!(4)).as_bytes());
-        listener.add_usb_input(&[0xaau8; KiB!(4)]);
-        listener.add_usb_input(b"flash:fvm");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"DATA00001000",
-                b"OKAY",
-                b"OKAY",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    #[test]
-    fn test_async_flash_early_errors() {
-        let sparse_raw = include_bytes!("../../testdata/sparse_test_raw.bin");
-        let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"raw", vec![0u8; sparse_raw.len() - 1]);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-        listener.add_usb_input(b"oem gbl-enable-async-task");
-        // Flashes an oversized image.
-        listener.add_usb_input(format!("download:{:#x}", sparse_raw.len()).as_bytes());
-        listener.add_usb_input(&vec![0xaau8; sparse_raw.len()]);
-        listener.add_usb_input(b"flash:raw");
-        // Flashes an oversized sparse image.
-        listener.add_usb_input(format!("download:{:#x}", sparse.len()).as_bytes());
-        listener.add_usb_input(sparse);
-        listener.add_usb_input(b"flash:raw");
-        listener.add_usb_input(b"continue");
-        block_on(run_gbl_fastboot_stack::<3>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut [],
-        ));
-
-        // The out-of-range errors should be caught before async task is launched.
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[
-                b"OKAY",
-                b"DATA0000e000",
-                b"OKAY",
-                b"FAILOutOfRange",
-                b"DATA00006080",
-                b"OKAY",
-                b"FAILOutOfRange",
-                b"INFOSyncing storage...",
-                b"OKAY",
-            ]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-    }
-
-    fn test_fastboot_boot_slot(
-        suffix: char,
-        load_buffer: &mut [u8],
-    ) -> (&mut [u8], &mut [u8], &mut [u8], &mut [u8]) {
-        let mut storage = FakeGblOpsStorage::default();
-        let vbmeta = CString::new(format!("vbmeta_{suffix}")).unwrap();
-        let vbmeta_img = read_test_data(format!("vbmeta_v2_{suffix}.img"));
-        storage.add_raw_device(&vbmeta, vbmeta_img);
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = default_test_gbl_ops(&storage);
-        gbl_ops.current_slot = Some(Ok(slot(suffix)));
-        let listener: SharedTestListener = Default::default();
-        let (usb, tcp) = (&listener, &listener);
-
-        let data = read_test_data(format!("boot_v2_{suffix}.img"));
-        listener.add_usb_input(format!("download:{:#x}", data.len()).as_bytes());
-        listener.add_usb_input(&data);
-        listener.add_usb_input(b"boot");
-        listener.add_usb_input(b"continue");
-
-        let res = block_on(run_gbl_fastboot_stack::<2>(
-            &mut gbl_ops,
-            buffers,
-            Some(&mut TestLocalSession::default()),
-            Some(usb),
-            Some(tcp),
-            &mut load_buffer[..],
-        ));
-
-        assert_eq!(
-            listener.usb_out_queue(),
-            make_expected_usb_out(&[b"DATA00004000", b"OKAY", b"OKAYboot_command",]),
-            "\nActual USB output:\n{}",
-            listener.dump_usb_out_queue()
-        );
-
-        res.split_loaded_android(&mut load_buffer[..]).unwrap()
-    }
-
-    #[test]
-    fn test_fastboot_boot_slot_a() {
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = test_fastboot_boot_slot('a', &mut load_buffer);
-        checks_loaded_v2_slot_a_normal_mode(ramdisk, kernel);
-    }
-
-    #[test]
-    fn test_fastboot_boot_slot_b() {
-        let mut load_buffer = AlignedBuffer::new(8 * 1024 * 1024, KERNEL_ALIGNMENT);
-        let (ramdisk, _, kernel, _) = test_fastboot_boot_slot('b', &mut load_buffer);
-        checks_loaded_v2_slot_b_normal_mode(ramdisk, kernel);
-    }
-
-    #[test]
-    fn test_fastboot_no_channels() {
-        let storage = FakeGblOpsStorage::default();
-        let buffers = vec![vec![0u8; KiB!(128)]; 2];
-        let mut gbl_ops = default_test_gbl_ops(&storage);
-
-        block_on(run_gbl_fastboot_stack::<2>(
-            &mut gbl_ops,
-            buffers,
-            None::<&mut TestLocalSession>,
-            None::<&SharedTestListener>,
-            None::<&SharedTestListener>,
-            &mut [],
-        ));
-    }
-}
diff --git a/gbl/libgbl/src/fastboot/pin_fut_container.rs b/gbl/libgbl/src/fastboot/pin_fut_container.rs
deleted file mode 100644
index 88d8849..0000000
--- a/gbl/libgbl/src/fastboot/pin_fut_container.rs
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use core::{future::Future, pin::Pin};
-use gbl_async::poll;
-
-/// A container abstraction that takes input of dynamically typed [Future]s and stores them at
-/// pinned memory locations.
-pub trait PinFutContainer<'a> {
-    /// Adds and pins a new [Future] of any type generated by the given closure `f`.
-    ///
-    /// If operation cannot be performed, such as due to no capacity, `f` should not be called.
-    fn add_with<F: Future<Output = ()> + 'a>(&mut self, f: impl FnOnce() -> F);
-
-    /// Calls the closure on each element in the container. Removes the element if it returns true.
-    fn for_each_remove_if(
-        &mut self,
-        cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
-    );
-}
-
-/// An internal container abstraction that takes input of a specific type of [Future] and stores
-/// them at pinned memory locations.
-pub(crate) trait PinFutContainerTyped<'a, F: Future + 'a> {
-    /// Adds and pins a new [Future] of type T into the container returned by `f`.
-    ///
-    /// If operation cannot be performed, such as due to no capacity, `f` should not be called.
-    fn add_with(&mut self, f: impl FnOnce() -> F);
-
-    /// Calls the closure on each element in the container. Removes the element if it returns true.
-    fn for_each_remove_if(
-        &mut self,
-        cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
-    );
-
-    /// Returns the number of items
-    #[cfg(test)]
-    fn size(&mut self) -> usize {
-        let mut res = 0;
-        self.for_each_remove_if(|_| {
-            res += 1;
-            false
-        });
-        res
-    }
-
-    /// Polls all the [Future] once. Returns the number or unfinished ones.
-    fn poll_all(&mut self) -> usize {
-        let mut res = 0;
-        self.for_each_remove_if(|v| {
-            let finished = poll(v).is_some();
-            res += usize::from(!finished);
-            finished
-        });
-        res
-    }
-
-    /// Runs until all futures are finished
-    #[cfg(test)]
-    fn run(&mut self) {
-        while self.poll_all() > 0 {}
-    }
-}
-
-/// `PinFutContainer` can implement `PinFutContainerTyped` for any [Future] type.
-impl<'a, F: Future<Output = ()> + 'a, T: PinFutContainer<'a>> PinFutContainerTyped<'a, F> for T {
-    fn add_with(&mut self, f: impl FnOnce() -> F) {
-        PinFutContainer::add_with(self, move || f())
-    }
-
-    fn for_each_remove_if(
-        &mut self,
-        cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
-    ) {
-        PinFutContainer::for_each_remove_if(self, cb)
-    }
-}
-
-/// An implementation of `PinFutContainerTyped` backed by a preallocated slice.
-pub(crate) struct PinFutSlice<'a, F> {
-    arr: &'a mut [Pin<&'a mut F>],
-    used: usize,
-}
-
-impl<'a, F> PinFutSlice<'a, F> {
-    /// Creates a new instance
-    pub fn new(arr: &'a mut [Pin<&'a mut F>]) -> Self {
-        Self { arr, used: 0 }
-    }
-}
-
-impl<'a, F: Future<Output = ()> + 'a> PinFutContainerTyped<'a, F> for PinFutSlice<'a, F> {
-    fn add_with(&mut self, f: impl FnOnce() -> F) {
-        if self.used < self.arr.len() {
-            self.arr[self.used].set(f());
-            self.used += 1;
-        }
-    }
-
-    fn for_each_remove_if(
-        &mut self,
-        mut cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
-    ) {
-        // Iterates from the end because we swap remove with the last.
-        for idx in (0..self.used).rev() {
-            if cb(&mut (self.arr[idx].as_mut() as _)) {
-                // Swaps remove with the last element
-                self.used -= 1;
-                self.arr.swap(idx, self.used);
-            }
-        }
-    }
-}
diff --git a/gbl/libgbl/src/fastboot/shared.rs b/gbl/libgbl/src/fastboot/shared.rs
deleted file mode 100644
index e5d1908..0000000
--- a/gbl/libgbl/src/fastboot/shared.rs
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use core::{
-    cell::RefCell,
-    ops::{Deref, DerefMut},
-};
-
-/// A shared instance guarded by `RefCell`.
-pub struct Shared<T>(RefCell<T>);
-
-impl<T> From<T> for Shared<T> {
-    fn from(val: T) -> Self {
-        Shared(val.into())
-    }
-}
-
-impl<T> Deref for Shared<T> {
-    type Target = RefCell<T>;
-
-    fn deref(&self) -> &Self::Target {
-        &self.0
-    }
-}
-
-impl<T> DerefMut for Shared<T> {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.0
-    }
-}
diff --git a/gbl/libgbl/src/fastboot/sparse.rs b/gbl/libgbl/src/fastboot/sparse.rs
deleted file mode 100644
index ab80bf1..0000000
--- a/gbl/libgbl/src/fastboot/sparse.rs
+++ /dev/null
@@ -1,364 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use core::{
-    cmp::{max, min},
-    mem::size_of,
-};
-use liberror::Error;
-use static_assertions::const_assert;
-use zerocopy::{FromBytes, Immutable, IntoBytes, Ref};
-
-// TODO(b/331854173): Switch to use bindgen for the following type definitions once
-// system/core/libsparse is added to repo checkout.
-
-const HEADER_MAGIC: u32 = 0xED26FF3A;
-const CHUNK_TYPE_RAW: u16 = 0xCAC1;
-const CHUNK_TYPE_FILL: u16 = 0xCAC2;
-const CHUNK_TYPE_DONT_CARE: u16 = 0xCAC3;
-const CHUNK_TYPE_CRC32: u16 = 0xCAC4;
-
-const SPARSE_HEADER_MAJOR_VER: u16 = 1;
-const SPARSE_HEADER_MINOR_VER: u16 = 0;
-
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, Immutable, IntoBytes, FromBytes)]
-pub struct SparseHeader {
-    pub magic: u32,
-    pub major_version: u16,
-    pub minor_version: u16,
-    pub file_hdr_sz: u16,
-    pub chunk_hdr_sz: u16,
-    pub blk_sz: u32,
-    pub total_blks: u32,
-    pub total_chunks: u32,
-    pub image_checksum: u32,
-}
-
-impl SparseHeader {
-    /// Returns the total size in bytes for the data after unsparsified.
-    pub fn data_size(&self) -> u64 {
-        (self.total_blks as u64) * (self.blk_sz as u64)
-    }
-}
-
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, IntoBytes, FromBytes)]
-pub struct ChunkHeader {
-    pub chunk_type: u16,
-    pub reserved1: u16,
-    pub chunk_sz: u32,
-    pub total_sz: u32,
-}
-
-const ERR_ARITHMETIC_OVERFLOW: &str = "Arithmetic Overflow";
-const ERR_IMAGE_SIZE: &str = "Bad image. Invalid image size";
-
-/// Checks if a sparse image is valid and returns the sparse header.
-pub fn is_sparse_image(sparse_img: &[u8]) -> Result<SparseHeader, Error> {
-    let sparse_header: SparseHeader = copy_from(sparse_img)?;
-    if sparse_header.magic != HEADER_MAGIC {
-        return Err("Sparse magic mismatch".into());
-    } else if sparse_header.major_version != SPARSE_HEADER_MAJOR_VER {
-        return Err("Sparse major version mismatch".into());
-    } else if sparse_header.minor_version != SPARSE_HEADER_MINOR_VER {
-        return Err("Sparse minor version mismatch".into());
-    }
-    Ok(sparse_header)
-}
-
-/// `FillInfo` is derived from a sparse chunk and contains information whether to fill a value or
-/// skip for a number of blocks.
-///
-/// Context and uses:
-///
-/// When writing fill chunks from a sparse image, it is usually better to write a larger buffer
-/// with the filled value instead of a single u32 at a time. However, separately maintaining a fill
-/// buffer can be inconvenient for the caller. Therefore, we use a strategy that re-uses the input
-/// buffer for fill buffer.
-///
-/// The idea is to write the sparse image in two passes. In the first pass, we only write non-fill
-/// chunks. For each sparse chunk, we create a `FillInfo` and append it from the beginning of the
-/// input buffer. For fill chunks, `FillInfo::fill_blocks` and
-/// `FillInfo::fill_value_or_skip_blocks` are set to the chunk size and fill value. For others,
-/// `FillInfo::fill_blocks` will be set to 0 and `FillInfo::fill_value_or_skip_blocks` will be set
-/// to the chunk size instead to represent number of blocks to skip. The second pass writes the
-/// fill chunk according to `FillInfo`.
-///
-/// Because a sparse chunk is at least 12 bytes, whereas `FillInfo` is 8 bytes, at the end of the
-/// first pass, we are guaranteed to have at least 1/3 of the input buffer free to use as fill
-/// buffer.
-#[repr(C, packed)]
-#[derive(Debug, Default, Copy, Clone, Immutable, IntoBytes, FromBytes)]
-struct FillInfo {
-    // Number of blocks to fill.
-    pub fill_blocks: u32,
-    // If `fill_blocks` is None, this field represents the number of blocks to skip.
-    // Otherwise, it represents the fill value.
-    pub fill_value_or_skip_blocks: u32,
-}
-
-impl FillInfo {
-    /// Creates an instance that represents filling a number of blocks.
-    fn new_fill(blocks: u32, value: u32) -> Self {
-        assert_ne!(blocks, 0);
-        Self { fill_blocks: blocks, fill_value_or_skip_blocks: value }
-    }
-
-    /// Creates an instance that represents skipping a number of blocks.
-    fn new_skip(blocks: u32) -> Self {
-        Self { fill_blocks: 0, fill_value_or_skip_blocks: blocks }
-    }
-
-    // Returns (blocks, None) for the skip case or (blocks, Some(value)) for the fill case.
-    fn get_blocks_and_value(&self) -> (u32, Option<u32>) {
-        match self.fill_blocks {
-            0 => (self.fill_value_or_skip_blocks, None),
-            v => (v, Some(self.fill_value_or_skip_blocks)),
-        }
-    }
-}
-
-const_assert!(size_of::<FillInfo>() < size_of::<ChunkHeader>());
-
-/// `SparseRawWriter` defines an interface for writing to raw storage used by `write_sparse_image`.
-pub(crate) trait SparseRawWriter {
-    /// Writes bytes from `data` to the destination storage at offset `off`
-    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error>;
-}
-
-/// Write a sparse image in `sparse_img`.
-///
-/// # Args
-//
-/// * `sparse_img`: The input buffer containing the sparse image. The API modifes input buffer for
-///   internal optimization.
-/// * `writer`: An implementation of `SparseRawWriter`.
-///
-/// # Returns
-///
-/// Returns the total number of bytes written, including don't care chunks.
-pub async fn write_sparse_image(
-    sparse_img: &mut [u8],
-    writer: &mut impl SparseRawWriter,
-) -> Result<u64, Error> {
-    let sparse_header: SparseHeader = is_sparse_image(sparse_img)?;
-    let mut curr: usize = size_of::<SparseHeader>();
-    let mut write_offset = 0u64;
-
-    // First pass. Writes non-fill chunk and constructs `FillInfo`.
-    let mut fill_off = 0usize;
-    for _ in 0..sparse_header.total_chunks {
-        let header: ChunkHeader = copy_from(&mut sparse_img[curr..])?;
-        let payload = &mut sparse_img[curr + size_of::<ChunkHeader>()..];
-        let payload_sz = u64_mul(header.chunk_sz, sparse_header.blk_sz)?;
-        let mut fill = FillInfo::new_skip(header.chunk_sz);
-        match header.chunk_type {
-            CHUNK_TYPE_RAW => {
-                writer.write(write_offset, get_mut(payload, 0, to_usize(payload_sz)?)?).await?;
-            }
-            CHUNK_TYPE_FILL if header.chunk_sz != 0 => {
-                let fill_val = u32::from_le_bytes(get_mut(payload, 0, 4)?.try_into().unwrap());
-                fill = FillInfo::new_fill(header.chunk_sz, fill_val);
-            }
-            CHUNK_TYPE_DONT_CARE | CHUNK_TYPE_CRC32 => {}
-            _ => return Err("Invalid Chunk Type".into()),
-        };
-        write_offset = u64_add(write_offset, payload_sz)?;
-        sparse_img[fill_off..][..size_of::<FillInfo>()].clone_from_slice(fill.as_bytes());
-        fill_off = usize_add(fill_off, size_of::<FillInfo>())?;
-        curr = usize_add(curr, header.total_sz)?;
-    }
-    let total = write_offset;
-
-    // Second pass. Writes fill chunks.
-    // Use all reamining buffer as fill buffer.
-    let (fill_infos, fill_buffer) = sparse_img.split_at_mut(fill_off);
-    let mut fill_buffer = FillBuffer { curr_val: None, curr_size: 0, buffer: fill_buffer };
-    let fill_infos = Ref::<_, [FillInfo]>::new_slice(fill_infos).unwrap().into_slice();
-    write_offset = 0;
-    for ele in fill_infos {
-        match ele.get_blocks_and_value() {
-            (blks, None) => {
-                write_offset = u64_add(write_offset, u64_mul(blks, sparse_header.blk_sz)?)?;
-            }
-            (blks, Some(v)) => {
-                let sz = u64_mul(blks, sparse_header.blk_sz)?;
-                let buffer = fill_buffer.get(v, sz)?;
-                let buffer_len = to_u64(buffer.len())?;
-                let end = u64_add(write_offset, sz)?;
-                while write_offset < end {
-                    let to_write = min(buffer_len, end - write_offset);
-                    writer.write(write_offset, &mut buffer[..to_usize(to_write).unwrap()]).await?;
-                    write_offset += to_write;
-                }
-            }
-        }
-    }
-    Ok(total)
-}
-
-/// `FillUnit` is a packed C struct wrapping a u32. It is mainly used for filling a buffer of
-/// arbitrary alignment with a u32 value.
-#[repr(C, packed)]
-#[derive(Debug, Default, Copy, Clone, Immutable, IntoBytes, FromBytes)]
-struct FillUnit(u32);
-
-/// `FillBuffer` manages a buffer and provides API for making a fill buffer with the given value.
-struct FillBuffer<'a> {
-    curr_val: Option<u32>,
-    curr_size: usize,
-    buffer: &'a mut [u8],
-}
-
-impl FillBuffer<'_> {
-    /// Get a buffer up to `size` number of bytes filled with `val`.
-    fn get(&mut self, val: u32, size: u64) -> Result<&mut [u8], Error> {
-        let aligned_len = self.buffer.len() - (self.buffer.len() % size_of::<u32>());
-        let size: usize = min(to_u64(aligned_len)?, size).try_into().unwrap();
-        if Some(val) != self.curr_val {
-            self.curr_size = 0;
-            self.curr_val = Some(val);
-        }
-        let gap = max(self.curr_size, size) - self.curr_size;
-        let to_fill = &mut self.buffer[self.curr_size..][..gap];
-        Ref::<_, [FillUnit]>::new_slice(to_fill).unwrap().into_mut_slice().fill(FillUnit(val));
-        self.curr_size += gap;
-        Ok(&mut self.buffer[..size])
-    }
-}
-
-/// A helper to check and get a mutable sub slice.
-fn get_mut<L: TryInto<usize>, R: TryInto<usize>>(
-    bytes: &mut [u8],
-    start: L,
-    end: R,
-) -> Result<&mut [u8], Error> {
-    bytes.get_mut(to_usize(start)?..to_usize(end)?).ok_or(ERR_IMAGE_SIZE.into())
-}
-
-/// A helper to check and get a sub slice.
-fn get<L: TryInto<usize>, R: TryInto<usize>>(
-    bytes: &[u8],
-    start: L,
-    end: R,
-) -> Result<&[u8], Error> {
-    bytes.get(to_usize(start)?..to_usize(end)?).ok_or(ERR_IMAGE_SIZE.into())
-}
-
-/// A helper to return a copy of a zerocopy object from bytes.
-fn copy_from<T: IntoBytes + FromBytes + Default>(bytes: &[u8]) -> Result<T, Error> {
-    let mut res: T = Default::default();
-    res.as_bytes_mut().clone_from_slice(get(bytes, 0, size_of::<T>())?);
-    Ok(res)
-}
-
-// Investigate switching the following to use SafeNum. A naive replacement results in too many
-// `try_into()?` callsites which looks chaotics. Some proper wrapper might still be needed.
-
-/// Checks and converts an integer into usize.
-fn to_usize<T: TryInto<usize>>(val: T) -> Result<usize, Error> {
-    Ok(val.try_into().map_err(|_| ERR_ARITHMETIC_OVERFLOW)?)
-}
-
-/// Adds two usize convertible numbers and checks overflow.
-fn usize_add<L: TryInto<usize>, R: TryInto<usize>>(lhs: L, rhs: R) -> Result<usize, Error> {
-    Ok(to_usize(lhs)?.checked_add(to_usize(rhs)?).ok_or(ERR_ARITHMETIC_OVERFLOW)?)
-}
-
-/// Checks and converts an integer into u64
-fn to_u64<T: TryInto<u64>>(val: T) -> Result<u64, Error> {
-    Ok(val.try_into().map_err(|_| ERR_ARITHMETIC_OVERFLOW)?)
-}
-
-/// Adds two u64 convertible numbers and checks overflow.
-fn u64_add<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, Error> {
-    Ok(to_u64(lhs)?.checked_add(to_u64(rhs)?).ok_or(ERR_ARITHMETIC_OVERFLOW)?)
-}
-
-/// Multiplies two u64 convertible numbers and checks overflow.
-fn u64_mul<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, Error> {
-    Ok(to_u64(lhs)?.checked_mul(to_u64(rhs)?).ok_or(ERR_ARITHMETIC_OVERFLOW)?)
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use gbl_async::block_on;
-
-    impl SparseRawWriter for Vec<u8> {
-        async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
-            self[off.try_into().unwrap()..][..data.len()].clone_from_slice(data);
-            Ok(())
-        }
-    }
-
-    #[test]
-    fn test_sparse_write() {
-        let raw = include_bytes!("../../testdata/sparse_test_raw.bin");
-        let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        // Gives a larger output buffer.
-        let mut out = vec![0u8; 2 * raw.len()];
-        assert_eq!(
-            block_on(write_sparse_image(&mut sparse.to_vec()[..], &mut out)).unwrap(),
-            raw.len().try_into().unwrap()
-        );
-        assert_eq!(out[..raw.len()].to_vec(), raw);
-    }
-
-    #[test]
-    fn test_sparse_write_non_default_block_size() {
-        let raw = include_bytes!("../../testdata/sparse_test_raw.bin");
-        let sparse = include_bytes!("../../testdata/sparse_test_blk1024.bin");
-        // Gives a larger output buffer.
-        let mut out = vec![0u8; 2 * raw.len()];
-        assert_eq!(
-            block_on(write_sparse_image(&mut sparse.to_vec()[..], &mut out)).unwrap(),
-            raw.len().try_into().unwrap()
-        );
-        assert_eq!(out[..raw.len()].to_vec(), raw);
-    }
-
-    /// A helper to copy a zerocopy object into a buffer
-    fn copy_to<T: Immutable + IntoBytes + FromBytes>(val: &T, bytes: &mut [u8]) {
-        bytes[..size_of::<T>()].clone_from_slice(val.as_bytes());
-    }
-
-    #[test]
-    fn test_sparse_invalid_magic() {
-        let mut sparse = include_bytes!("../../testdata/sparse_test.bin").to_vec();
-        let mut sparse_header: SparseHeader = copy_from(&sparse[..]).unwrap();
-        sparse_header.magic = 0;
-        copy_to(&sparse_header, &mut sparse[..]);
-        assert!(block_on(write_sparse_image(&mut sparse[..], &mut vec![])).is_err());
-    }
-
-    #[test]
-    fn test_sparse_invalid_major_version() {
-        let mut sparse = include_bytes!("../../testdata/sparse_test.bin").to_vec();
-        let mut sparse_header: SparseHeader = copy_from(&sparse[..]).unwrap();
-        sparse_header.major_version = SPARSE_HEADER_MAJOR_VER + 1;
-        copy_to(&sparse_header, &mut sparse[..]);
-        assert!(block_on(write_sparse_image(&mut sparse[..], &mut vec![])).is_err());
-    }
-
-    #[test]
-    fn test_sparse_invalid_minor_version() {
-        let mut sparse = include_bytes!("../../testdata/sparse_test.bin").to_vec();
-        let mut sparse_header: SparseHeader = copy_from(&sparse[..]).unwrap();
-        sparse_header.minor_version = SPARSE_HEADER_MINOR_VER + 1;
-        copy_to(&sparse_header, &mut sparse[..]);
-        assert!(block_on(write_sparse_image(&mut sparse[..], &mut vec![])).is_err());
-    }
-}
diff --git a/gbl/libgbl/src/fastboot/vars.rs b/gbl/libgbl/src/fastboot/vars.rs
deleted file mode 100644
index 5a45261..0000000
--- a/gbl/libgbl/src/fastboot/vars.rs
+++ /dev/null
@@ -1,226 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::fastboot::PinFutContainerTyped;
-use crate::{
-    fastboot::{BufferPool, GblFastboot},
-    GblOps,
-};
-use core::{ffi::CStr, future::Future, ops::DerefMut, str::from_utf8};
-use fastboot::{next_arg, next_arg_u64, CommandResult, VarInfoSender};
-use gbl_async::{block_on, select, yield_now};
-use gbl_storage::BlockIo;
-use libutils::snprintf;
-
-// See definition of [GblFastboot] for docs on lifetimes and generics parameters.
-impl<'a: 'c, 'b: 'c, 'c, 'd, 'e, G, B, S, T, P, C, F>
-    GblFastboot<'a, 'b, 'c, 'd, 'e, G, B, S, T, P, C, F>
-where
-    G: GblOps<'a, 'e>,
-    B: BlockIo,
-    S: DerefMut<Target = [u8]>,
-    T: DerefMut<Target = [u8]>,
-    P: BufferPool,
-    C: PinFutContainerTyped<'c, F>,
-    F: Future<Output = ()> + 'c,
-{
-    const VERSION_BOOTLOADER: &'static str = "version-bootloader";
-    const VERSION_BOOTLOADER_VAL: &'static str = "1.0";
-
-    const MAX_FETCH_SIZE: &'static str = "max-fetch-size";
-    const MAX_FETCH_SIZE_VAL: &'static str = "0xffffffffffffffff";
-
-    /// Entry point for "fastboot getvar <variable>..."
-    pub(crate) fn get_var_internal<'s, 't>(
-        &mut self,
-        name: &CStr,
-        args: impl Iterator<Item = &'t CStr> + Clone,
-        out: &'s mut [u8],
-    ) -> CommandResult<&'s str> {
-        let args_str = args.clone().map(|v| v.to_str());
-        // Checks that all arguments are valid str first.
-        args_str.clone().find(|v| v.is_err()).unwrap_or(Ok(""))?;
-        let args_str = args_str.map(|v| v.unwrap());
-        Ok(match name.to_str()? {
-            Self::VERSION_BOOTLOADER => snprintf!(out, "{}", Self::VERSION_BOOTLOADER_VAL),
-            Self::MAX_FETCH_SIZE => snprintf!(out, "{}", Self::MAX_FETCH_SIZE_VAL),
-            Self::PARTITION_SIZE => self.get_var_partition_size(args_str, out)?,
-            Self::PARTITION_TYPE => self.get_var_partition_type(args_str, out)?,
-            Self::BLOCK_DEVICE => self.get_var_block_device(args_str, out)?,
-            Self::DEFAULT_BLOCK => self.get_var_default_block(out)?,
-            _ => {
-                let sz = self.gbl_ops.fastboot_variable(name, args, out)?;
-                from_utf8(out.get(..sz).ok_or("Invalid variable value size")?)?
-            }
-        })
-    }
-
-    /// Entry point for "fastboot getvar all..."
-    pub(crate) async fn get_var_all_internal(
-        &mut self,
-        send: &mut impl VarInfoSender,
-    ) -> CommandResult<()> {
-        send.send_var_info(Self::VERSION_BOOTLOADER, [], Self::VERSION_BOOTLOADER_VAL).await?;
-        send.send_var_info(Self::MAX_FETCH_SIZE, [], Self::MAX_FETCH_SIZE_VAL).await?;
-        self.get_all_block_device(send).await?;
-        let mut buf = [0u8; 32];
-        send.send_var_info(Self::DEFAULT_BLOCK, [], self.get_var_default_block(&mut buf)?).await?;
-        self.get_all_partition_size_type(send).await?;
-
-        // Gets platform specific variables
-        let tasks = self.tasks();
-        Ok(self.gbl_ops.fastboot_visit_all_variables(|args, val| {
-            if let Some((name, args)) = args.split_first_chunk::<1>() {
-                let name = name[0].to_str().unwrap_or("?");
-                let args = args.iter().map(|v| v.to_str().unwrap_or("?"));
-                let val = val.to_str().unwrap_or("?");
-                // Manually polls async tasks so that we can still get parallelism while running in
-                // the context of backend.
-                let _ = block_on(select(send.send_var_info(name, args, val), async {
-                    loop {
-                        tasks.borrow_mut().poll_all();
-                        yield_now().await;
-                    }
-                }));
-            }
-        })?)
-    }
-
-    const PARTITION_SIZE: &'static str = "partition-size";
-    const PARTITION_TYPE: &'static str = "partition-type";
-
-    /// "fastboot getvar partition-size"
-    fn get_var_partition_size<'s, 't>(
-        &mut self,
-        mut args: impl Iterator<Item = &'t str> + Clone,
-        out: &'s mut [u8],
-    ) -> CommandResult<&'s str> {
-        let (_, _, _, sz) = self.parse_partition(args.next().ok_or("Missing partition")?)?;
-        Ok(snprintf!(out, "{:#x}", sz))
-    }
-
-    /// "fastboot getvar partition-type"
-    fn get_var_partition_type<'s, 't>(
-        &mut self,
-        mut args: impl Iterator<Item = &'t str> + Clone,
-        out: &'s mut [u8],
-    ) -> CommandResult<&'s str> {
-        self.parse_partition(args.next().ok_or("Missing partition")?)?;
-        Ok(snprintf!(out, "raw"))
-    }
-
-    /// Gets all "partition-size/partition-type"
-    async fn get_all_partition_size_type(
-        &mut self,
-        responder: &mut impl VarInfoSender,
-    ) -> CommandResult<()> {
-        // Though any sub range of a GPT partition or raw block counts as a partition in GBL
-        // Fastboot, for "getvar all" we only enumerate whole range GPT partitions.
-        let disks = self.disks;
-        let mut size_str = [0u8; 32];
-        for (idx, blk) in disks.iter().enumerate() {
-            for ptn_idx in 0..blk.num_partitions().unwrap_or(0) {
-                let ptn = blk.get_partition_by_idx(ptn_idx)?;
-                let sz: u64 = ptn.size()?;
-                let part = ptn.name()?;
-                // Assumes max partition name length of 72 plus max u64 hex string length 18.
-                let mut part_id_buf = [0u8; 128];
-                let part = snprintf!(part_id_buf, "{}/{:x}", part, idx);
-                responder
-                    .send_var_info(Self::PARTITION_SIZE, [part], snprintf!(size_str, "{:#x}", sz))
-                    .await?;
-                // Image type is not supported yet.
-                responder
-                    .send_var_info(Self::PARTITION_TYPE, [part], snprintf!(size_str, "raw"))
-                    .await?;
-            }
-        }
-        Ok(())
-    }
-
-    const BLOCK_DEVICE: &'static str = "block-device";
-    const TOTAL_BLOCKS: &'static str = "total-blocks";
-    const BLOCK_SIZE: &'static str = "block-size";
-    const BLOCK_DEVICE_STATUS: &'static str = "status";
-
-    /// Block device related information.
-    ///
-    /// `fastboot getvar block-device:<id>:total-blocks`
-    /// `fastboot getvar block-device:<id>:block-size`
-    /// `fastboot getvar block-device:<id>:status`
-    fn get_var_block_device<'s, 't>(
-        &mut self,
-        mut args: impl Iterator<Item = &'t str> + Clone,
-        out: &'s mut [u8],
-    ) -> CommandResult<&'s str> {
-        let id = next_arg_u64(&mut args)?.ok_or("Missing block device ID")?;
-        let id = usize::try_from(id)?;
-        let val_type = next_arg(&mut args).ok_or("Missing value type")?;
-        let blk = &self.disks[id];
-        let info = blk.block_info();
-        Ok(match val_type {
-            Self::TOTAL_BLOCKS => snprintf!(out, "{:#x}", info.num_blocks),
-            Self::BLOCK_SIZE => snprintf!(out, "{:#x}", info.block_size),
-            Self::BLOCK_DEVICE_STATUS => {
-                snprintf!(out, "{}", blk.status().to_str())
-            }
-            _ => return Err("Invalid type".into()),
-        })
-    }
-
-    /// Gets all "block-device" variables.
-    async fn get_all_block_device(
-        &mut self,
-        responder: &mut impl VarInfoSender,
-    ) -> CommandResult<()> {
-        let mut val = [0u8; 32];
-        for (idx, blk) in self.gbl_ops.disks().iter().enumerate() {
-            let mut id_str = [0u8; 32];
-            let id = snprintf!(id_str, "{:x}", idx);
-            let info = blk.block_info();
-            responder
-                .send_var_info(
-                    Self::BLOCK_DEVICE,
-                    [id, Self::TOTAL_BLOCKS],
-                    snprintf!(val, "{:#x}", info.num_blocks),
-                )
-                .await?;
-            responder
-                .send_var_info(
-                    Self::BLOCK_DEVICE,
-                    [id, Self::BLOCK_SIZE],
-                    snprintf!(val, "{:#x}", info.block_size),
-                )
-                .await?;
-            responder
-                .send_var_info(
-                    Self::BLOCK_DEVICE,
-                    [id, Self::BLOCK_DEVICE_STATUS],
-                    snprintf!(val, "{}", blk.status().to_str()),
-                )
-                .await?;
-        }
-        Ok(())
-    }
-
-    const DEFAULT_BLOCK: &'static str = "gbl-default-block";
-
-    /// "fastboot getvar gbl-default-block"
-    fn get_var_default_block<'s>(&mut self, out: &'s mut [u8]) -> CommandResult<&'s str> {
-        Ok(match self.default_block {
-            Some(v) => snprintf!(out, "{:#x}", v),
-            None => snprintf!(out, "None"),
-        })
-    }
-}
diff --git a/gbl/libgbl/src/fuchsia_boot/mod.rs b/gbl/libgbl/src/fuchsia_boot/mod.rs
deleted file mode 100644
index 43c8b99..0000000
--- a/gbl/libgbl/src/fuchsia_boot/mod.rs
+++ /dev/null
@@ -1,840 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file provides APIs for loading, verifying and booting Fuchsia/Zircon.
-
-use crate::{gbl_print, gbl_println, image_buffer::ImageBuffer, GblOps, Result as GblResult};
-pub use abr::{get_and_clear_one_shot_bootloader, get_boot_slot, Ops as AbrOps, SlotIndex};
-use core::{fmt::Write, mem::MaybeUninit, num::NonZeroUsize};
-use liberror::{Error, Result};
-use libutils::aligned_subslice;
-use safemath::SafeNum;
-use zbi::{ZbiContainer, ZbiFlags, ZbiHeader, ZbiType};
-use zerocopy::IntoBytes;
-
-mod vboot;
-use vboot::zircon_verify_kernel;
-
-/// Kernel load address alignment. Value taken from
-/// https://fuchsia.googlesource.com/fuchsia/+/4f204d8a0243e84a86af4c527a8edcc1ace1615f/zircon/kernel/target/arm64/boot-shim/BUILD.gn#38
-pub const ZIRCON_KERNEL_ALIGN: usize = 64 * 1024;
-
-const DURABLE_BOOT_PARTITION: &str = "durable_boot";
-const MISC_PARTITION: &str = "misc";
-const ABR_PARTITION_ALIASES: &[&str] = &[DURABLE_BOOT_PARTITION, MISC_PARTITION];
-
-/// Helper function to find partition given a list of possible aliases.
-fn find_part_aliases<'a, 'b, 'c>(
-    ops: &mut (impl GblOps<'a, 'c> + ?Sized),
-    aliases: &'b [&str],
-) -> Result<&'b str> {
-    Ok(*aliases
-        .iter()
-        .find(|v| matches!(ops.partition_size(v), Ok(Some(_))))
-        .ok_or(Error::NotFound)?)
-}
-
-/// `GblAbrOps` wraps an object implementing `GblOps` and implements the `abr::Ops` trait.
-pub(crate) struct GblAbrOps<'a, T: ?Sized>(pub &'a mut T);
-
-impl<'b, 'c, T: GblOps<'b, 'c> + ?Sized> AbrOps for GblAbrOps<'_, T> {
-    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
-        let part = find_part_aliases(self.0, &ABR_PARTITION_ALIASES)?;
-        self.0.read_from_partition_sync(part, 0, out)
-    }
-
-    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
-        let part = find_part_aliases(self.0, &ABR_PARTITION_ALIASES)?;
-        self.0.write_to_partition_sync(part, 0, data)
-    }
-
-    fn console(&mut self) -> Option<&mut dyn Write> {
-        self.0.console_out()
-    }
-}
-
-/// A helper for splitting the trailing unused portion of a ZBI container buffer.
-///
-/// Returns a tuple of used subslice and unused subslice
-fn zbi_split_unused_buffer(zbi: &mut [u8]) -> GblResult<(&mut [u8], &mut [u8])> {
-    Ok(zbi.split_at_mut(ZbiContainer::parse(&zbi[..])?.container_size()?))
-}
-
-/// Relocates a ZBI kernel to a different buffer.
-///
-/// * `dest` must be aligned to `ZIRCON_KERNEL_ALIGN`.
-/// * `dest` will be a ZBI container containing only the kernel item.
-pub fn relocate_kernel(kernel: &[u8], dest: &mut [u8]) -> GblResult<()> {
-    if (dest.as_ptr() as usize % ZIRCON_KERNEL_ALIGN) != 0 {
-        return Err(Error::InvalidAlignment.into());
-    }
-
-    let kernel = ZbiContainer::parse(&kernel[..])?;
-    let kernel_item = kernel.get_bootable_kernel_item()?;
-    let hdr = kernel_item.header;
-    // Creates a new ZBI kernel item at the destination.
-    let mut relocated = ZbiContainer::new(&mut dest[..])?;
-    let zbi_type = ZbiType::try_from(hdr.type_)?;
-    relocated.create_entry_with_payload(
-        zbi_type,
-        hdr.extra,
-        hdr.get_flags() & !ZbiFlags::CRC32,
-        kernel_item.payload.as_bytes(),
-    )?;
-    let (_, reserved_memory_size) = relocated.get_kernel_entry_and_reserved_memory_size()?;
-    let buf_len = u64::try_from(zbi_split_unused_buffer(dest)?.1.len()).map_err(Error::from)?;
-    match reserved_memory_size > buf_len {
-        true => Err(Error::BufferTooSmall(None).into()),
-        _ => Ok(()),
-    }
-}
-
-/// Relocate a ZBI kernel to the trailing unused buffer.
-///
-/// Returns the original kernel subslice and relocated kernel subslice.
-pub fn relocate_to_tail(kernel: &mut [u8]) -> GblResult<(&mut [u8], &mut [u8])> {
-    let reloc_size = ZbiContainer::parse(&kernel[..])?.get_buffer_size_for_kernel_relocation()?;
-    let (original, relocated) = zbi_split_unused_buffer(kernel)?;
-    let relocated = aligned_subslice(relocated, ZIRCON_KERNEL_ALIGN)?;
-    let off = (SafeNum::from(relocated.len()) - reloc_size)
-        .round_down(ZIRCON_KERNEL_ALIGN)
-        .try_into()
-        .map_err(Error::from)?;
-    let relocated = &mut relocated[off..];
-    relocate_kernel(original, relocated)?;
-    let reloc_addr = relocated.as_ptr() as usize;
-    Ok(kernel.split_at_mut(reloc_addr.checked_sub(kernel.as_ptr() as usize).unwrap()))
-}
-
-/// Gets the list of aliases for slotted/slotless zircon partition name.
-fn zircon_part_name_aliases(slot: Option<SlotIndex>) -> &'static [&'static str] {
-    match slot {
-        Some(SlotIndex::A) => &["zircon_a", "zircon-a"][..],
-        Some(SlotIndex::B) => &["zircon_b", "zircon-b"][..],
-        Some(SlotIndex::R) => &["zircon_r", "zircon-r"][..],
-        _ => &["zircon"][..],
-    }
-}
-
-/// Gets the slotted/slotless standard zircon partition name.
-pub fn zircon_part_name(slot: Option<SlotIndex>) -> &'static str {
-    zircon_part_name_aliases(slot)[0]
-}
-
-/// Gets the ZBI command line string for the current slot.
-fn slot_cmd_line(slot: SlotIndex) -> &'static str {
-    match slot {
-        SlotIndex::A => "zvb.current_slot=a",
-        SlotIndex::B => "zvb.current_slot=b",
-        SlotIndex::R => "zvb.current_slot=r",
-    }
-}
-
-/// Loads and verifies a kernel of the given slot or slotless.
-///
-/// # Args
-///
-/// * `ops`: A reference to an object that implements `GblOps`.
-/// * `slot`: None if slotless. Otherwise the target slot to boot.
-/// * `slot_booted_successfully`: whether the slot is known-successful boot, and if so then this
-/// function will update the anti-rollbacks.
-///
-/// On success returns a pair containing: 1. the slice of the ZBI container with device ZBI items
-/// and 2. the slice of container containing the kernel.
-pub fn zircon_load_verify<'a, 'd>(
-    ops: &mut impl GblOps<'a, 'd>,
-    slot: Option<SlotIndex>,
-    slot_booted_successfully: bool,
-) -> GblResult<(ImageBuffer<'d>, ImageBuffer<'d>)> {
-    // TODO(b/379778252): use single `zbi_zircon` buffer for container to store both kernel and
-    // arguments/items
-    let mut zbi_items_img =
-        ops.get_image_buffer("zbi_items", NonZeroUsize::new(64 * 1024 * 1024).unwrap()).unwrap();
-
-    let init_len = zbi_items_img.tail().len();
-    // TODO(b/379787423): it is possible to optimize this initialisation by treating
-    // `zbi_items_img` same as kernel image (&[MaybeUninit]).
-    MaybeUninit::fill(zbi_items_img.tail(), 0);
-
-    // SAFETY: buffer was fully filled with 0 which is valid init value for u8
-    unsafe {
-        zbi_items_img.advance_used(init_len).unwrap();
-    }
-    let mut zbi_items = ZbiContainer::new(zbi_items_img.used_mut())?;
-
-    let zircon_part = find_part_aliases(ops, zircon_part_name_aliases(slot))?;
-
-    // Reads ZBI header to computes the total size of kernel.
-    let mut zbi_header: ZbiHeader = Default::default();
-    ops.read_from_partition_sync(zircon_part, 0, zbi_header.as_bytes_mut())?;
-    let image_length = (SafeNum::from(zbi_header.as_bytes_mut().len()) + zbi_header.length)
-        .try_into()
-        .map_err(Error::from)?;
-
-    // Reads the entire kernel
-    // TODO(b/379778252): as part of an attempt to use single container for kernel and arguments,
-    // it would be necessary to read kernel header first to figure out how much space needed
-    // (kernel size + scratch space)
-    let mut kernel_img =
-        ops.get_image_buffer("zbi_zircon", NonZeroUsize::new(128 * 1024 * 1024).unwrap()).unwrap();
-    let kernel_uninit = kernel_img
-        .as_mut()
-        .get_mut(..image_length)
-        .ok_or(Error::BufferTooSmall(Some(image_length)))?;
-    ops.read_from_partition_sync(zircon_part, 0, kernel_uninit)?;
-    // SAFETY: buffer was successfully filled from partition
-    unsafe {
-        kernel_img.advance_used(image_length).unwrap();
-    }
-    let load = kernel_img.used_mut();
-
-    // Performs AVB verification.
-    // TODO(b/379789161) verify that kernel buffer is big enough for the image and scratch buffer.
-    zircon_verify_kernel(ops, slot, slot_booted_successfully, load, &mut zbi_items)?;
-
-    // Append additional ZBI items.
-    match slot {
-        Some(slot) => {
-            // Appends current slot item.
-            zbi_items.create_entry_with_payload(
-                ZbiType::CmdLine,
-                0,
-                ZbiFlags::default(),
-                slot_cmd_line(slot).as_bytes(),
-            )?;
-        }
-        _ => {}
-    }
-
-    // Appends device specific ZBI items.
-    ops.zircon_add_device_zbi_items(&mut zbi_items)?;
-
-    // Appends staged bootloader file if present.
-    match ops.get_zbi_bootloader_files_buffer_aligned().map(|v| ZbiContainer::parse(v)) {
-        Some(Ok(v)) => zbi_items.extend(&v)?,
-        _ => {}
-    }
-
-    Ok((zbi_items_img, kernel_img))
-}
-
-/// Loads and verifies the active slot kernel according to A/B/R.
-///
-/// On disk A/B/R metadata will be updated.
-///
-/// # Args
-///
-/// * `ops`: A reference to an object that implements `GblOps`.
-///
-/// Returns a tuple containing: 1. the slice of the ZBI container with device ZBI items, 2. the
-/// slice of the relocated kernel, and 3. the selected slot index.
-pub fn zircon_load_verify_abr<'a, 'd>(
-    ops: &mut impl GblOps<'a, 'd>,
-) -> GblResult<(ImageBuffer<'d>, ImageBuffer<'d>, SlotIndex)> {
-    let (slot, successful) = get_boot_slot(&mut GblAbrOps(ops), true);
-    gbl_println!(ops, "Loading kernel from {}...", zircon_part_name(Some(slot)));
-    let (zbi_items_img, kernel_img) = zircon_load_verify(ops, Some(slot), successful)?;
-    gbl_println!(ops, "Successfully loaded slot: {}", zircon_part_name(Some(slot)));
-    Ok((zbi_items_img, kernel_img, slot))
-}
-
-/// Checks whether platform or A/B/R metadata instructs GBL to boot into fastboot mode.
-///
-/// # Returns
-///
-/// Returns true if fastboot mode is enabled, false if not.
-pub fn zircon_check_enter_fastboot<'a, 'b>(ops: &mut impl GblOps<'a, 'b>) -> bool {
-    match get_and_clear_one_shot_bootloader(&mut GblAbrOps(ops)) {
-        Ok(true) => {
-            gbl_println!(ops, "A/B/R one-shot-bootloader is set");
-            return true;
-        }
-        Err(e) => {
-            gbl_println!(ops, "Warning: error while checking A/B/R one-shot-bootloader ({:?})", e);
-            gbl_println!(ops, "Ignoring error and considered not set");
-        }
-        _ => {}
-    };
-
-    match ops.should_stop_in_fastboot() {
-        Ok(true) => {
-            gbl_println!(ops, "Platform instructs GBL to enter fastboot mode");
-            return true;
-        }
-        Err(e) => {
-            gbl_println!(ops, "Warning: error while checking platform fastboot trigger ({:?})", e);
-            gbl_println!(ops, "Ignoring error and considered not triggered");
-        }
-        _ => {}
-    };
-    false
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::{
-        ops::{
-            test::{FakeGblOps, FakeGblOpsStorage, TestGblDisk},
-            CertPermanentAttributes,
-        },
-        tests::AlignedBuffer,
-    };
-    use abr::{
-        mark_slot_active, mark_slot_unbootable, set_one_shot_bootloader, ABR_MAX_TRIES_REMAINING,
-    };
-    use avb_bindgen::{AVB_CERT_PIK_VERSION_LOCATION, AVB_CERT_PSK_VERSION_LOCATION};
-    use gbl_storage::as_uninit_mut;
-    use std::{
-        collections::{BTreeSet, HashMap, LinkedList},
-        fs,
-        path::Path,
-    };
-    use zbi::ZBI_ALIGNMENT_USIZE;
-    use zerocopy::FromBytes;
-
-    // The cert test keys were both generated with rollback version 42.
-    const TEST_CERT_PIK_VERSION: u64 = 42;
-    const TEST_CERT_PSK_VERSION: u64 = 42;
-
-    // The `reserve_memory_size` value in the test ZBI kernel.
-    // See `gen_zircon_test_images()` in libgbl/testdata/gen_test_data.py.
-    const TEST_KERNEL_RESERVED_MEMORY_SIZE: usize = 1024;
-
-    // The rollback index value and location in the generated test vbmetadata.
-    // See `gen_zircon_test_images()` in libgbl/testdata/gen_test_data.py.
-    const TEST_ROLLBACK_INDEX_LOCATION: usize = 1;
-    const TEST_ROLLBACK_INDEX_VALUE: u64 = 2;
-
-    pub(crate) const ZIRCON_A_ZBI_FILE: &str = "zircon_a.zbi";
-    pub(crate) const ZIRCON_B_ZBI_FILE: &str = "zircon_b.zbi";
-    pub(crate) const ZIRCON_R_ZBI_FILE: &str = "zircon_r.zbi";
-    pub(crate) const ZIRCON_SLOTLESS_ZBI_FILE: &str = "zircon_slotless.zbi";
-    pub(crate) const VBMETA_A_FILE: &str = "vbmeta_a.bin";
-    pub(crate) const VBMETA_B_FILE: &str = "vbmeta_b.bin";
-    pub(crate) const VBMETA_R_FILE: &str = "vbmeta_r.bin";
-    pub(crate) const VBMETA_SLOTLESS_FILE: &str = "vbmeta_slotless.bin";
-
-    /// Reads a data file under libgbl/testdata/
-    pub(crate) fn read_test_data(file: &str) -> Vec<u8> {
-        fs::read(Path::new(format!("external/gbl/libgbl/testdata/{}", file).as_str())).unwrap()
-    }
-
-    /// Returns a default [FakeGblOpsStorage] with valid test images.
-    ///
-    /// Rather than the typical use case of partitions on a single GPT device, this structures data
-    /// as separate raw single-partition devices. This is easier for tests since we don't need to
-    /// generate a GPT, and should be functionally equivalent since our code looks for partitions
-    /// on all devices.
-    pub(crate) fn create_storage() -> FakeGblOpsStorage {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"zircon_a", read_test_data(ZIRCON_A_ZBI_FILE));
-        storage.add_raw_device(c"zircon_b", read_test_data(ZIRCON_B_ZBI_FILE));
-        storage.add_raw_device(c"zircon_r", read_test_data(ZIRCON_R_ZBI_FILE));
-        storage.add_raw_device(c"zircon", read_test_data(ZIRCON_SLOTLESS_ZBI_FILE));
-        storage.add_raw_device(c"vbmeta_a", read_test_data(VBMETA_A_FILE));
-        storage.add_raw_device(c"vbmeta_b", read_test_data(VBMETA_B_FILE));
-        storage.add_raw_device(c"vbmeta_r", read_test_data(VBMETA_R_FILE));
-        storage.add_raw_device(c"vbmeta", read_test_data(VBMETA_SLOTLESS_FILE));
-        storage.add_raw_device(c"durable_boot", vec![0u8; 64 * 1024]);
-        storage
-    }
-
-    /// Returns a default [FakeGblOpsStorage] with valid test images and using legacy partition
-    /// names.
-    pub(crate) fn create_storage_legacy_names() -> FakeGblOpsStorage {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"zircon-a", read_test_data(ZIRCON_A_ZBI_FILE));
-        storage.add_raw_device(c"zircon-b", read_test_data(ZIRCON_B_ZBI_FILE));
-        storage.add_raw_device(c"zircon-r", read_test_data(ZIRCON_R_ZBI_FILE));
-        storage.add_raw_device(c"zircon", read_test_data(ZIRCON_SLOTLESS_ZBI_FILE));
-        storage.add_raw_device(c"vbmeta_a", read_test_data(VBMETA_A_FILE));
-        storage.add_raw_device(c"vbmeta_b", read_test_data(VBMETA_B_FILE));
-        storage.add_raw_device(c"vbmeta_r", read_test_data(VBMETA_R_FILE));
-        storage.add_raw_device(c"vbmeta", read_test_data(VBMETA_SLOTLESS_FILE));
-        storage.add_raw_device(c"misc", vec![0u8; 64 * 1024]);
-        storage
-    }
-
-    pub(crate) fn create_gbl_ops<'a>(partitions: &'a [TestGblDisk]) -> FakeGblOps<'a, 'static> {
-        let mut ops = FakeGblOps::new(&partitions);
-        ops.avb_ops.unlock_state = Ok(false);
-        ops.avb_ops.rollbacks = HashMap::from([
-            (TEST_ROLLBACK_INDEX_LOCATION, Ok(0)),
-            (AVB_CERT_PSK_VERSION_LOCATION.try_into().unwrap(), Ok(0)),
-            (AVB_CERT_PIK_VERSION_LOCATION.try_into().unwrap(), Ok(0)),
-        ]);
-        ops.avb_ops.use_cert = true;
-        ops.avb_ops.cert_permanent_attributes = Some(
-            CertPermanentAttributes::read_from(
-                &read_test_data("cert_permanent_attributes.bin")[..],
-            )
-            .unwrap(),
-        );
-        ops.avb_ops.cert_permanent_attributes_hash =
-            Some(read_test_data("cert_permanent_attributes.hash").try_into().unwrap());
-        ops
-    }
-
-    /// Normalizes a ZBI container by converting each ZBI item into raw bytes and storing them in
-    /// an ordered set. The function is mainly used for comparing two ZBI containers have identical
-    /// set of items, disregarding order.
-    pub(crate) fn normalize_zbi(zbi: &[u8]) -> BTreeSet<Vec<u8>> {
-        let zbi = ZbiContainer::parse(zbi).unwrap();
-        BTreeSet::from_iter(zbi.iter().map(|v| {
-            let mut hdr = *v.header;
-            hdr.crc32 = 0; // ignores crc32 field.
-            hdr.flags &= !ZbiFlags::CRC32.bits();
-            [hdr.as_bytes(), v.payload.as_bytes()].concat()
-        }))
-    }
-
-    /// Helper to append a command line ZBI item to a ZBI container
-    pub(crate) fn append_cmd_line(zbi: &mut [u8], cmd: &[u8]) {
-        let mut container = ZbiContainer::parse(zbi).unwrap();
-        container.create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), cmd).unwrap();
-    }
-
-    /// Helper to append a command line ZBI item to a ZBI container
-    pub(crate) fn append_zbi_file(zbi: &mut [u8], payload: &[u8]) {
-        let mut container = ZbiContainer::parse(zbi).unwrap();
-        container
-            .create_entry_with_payload(ZbiType::BootloaderFile, 0, ZbiFlags::default(), payload)
-            .unwrap();
-    }
-
-    /// Helper for testing `zircon_load_verify`.
-    fn test_load_verify(
-        ops: &mut FakeGblOps,
-        slot: Option<SlotIndex>,
-        expected_zbi_items: &[u8],
-        expected_kernel: &[u8],
-    ) {
-        let original_rb = ops.avb_ops.rollbacks.clone();
-        // Loads and verifies with unsuccessful slot flag first.
-        let (mut zbi_items, mut kernel) = zircon_load_verify(ops, slot, false).unwrap();
-        // Verifies loaded ZBI kernel/items
-        assert_eq!(normalize_zbi(expected_zbi_items), normalize_zbi(zbi_items.used_mut()));
-        // Verifies kernel
-        assert_eq!(normalize_zbi(expected_kernel), normalize_zbi(kernel.used_mut()));
-        // Kernel is at aligned address
-        assert_eq!(kernel.used_mut().as_ptr() as usize % ZIRCON_KERNEL_ALIGN, 0);
-
-        // Verifies that the slot successful flag is passed correctly.
-        // Unsuccessful slot, rollback not updated.
-        assert_eq!(ops.avb_ops.rollbacks, original_rb);
-        // Loads and verifies with successful slot flag.
-        zircon_load_verify(ops, slot, true).unwrap();
-        // Successful slot, rollback updated.
-        assert_eq!(
-            ops.avb_ops.rollbacks,
-            [
-                (TEST_ROLLBACK_INDEX_LOCATION, Ok(TEST_ROLLBACK_INDEX_VALUE)),
-                (
-                    usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(),
-                    Ok(TEST_CERT_PSK_VERSION)
-                ),
-                (
-                    usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(),
-                    Ok(TEST_CERT_PIK_VERSION)
-                )
-            ]
-            .into()
-        );
-    }
-
-    // Helper to create local buffers and convert them to be used as ImageBuffers
-    // This struct owns the buffers, and returns ImageBuffers maps that reference them.
-    //
-    // Tests should make sure to provide enough buffers for all `get_image_buffer()` calls.
-    //
-    struct ImageBuffersPool(LinkedList<(String, Vec<AlignedBuffer>)>);
-
-    impl ImageBuffersPool {
-        pub fn builder() -> ImageBuffersBuilder {
-            ImageBuffersBuilder::new()
-        }
-
-        // number - number of expected get_image_buffer calls. Each call consumes buffers from the
-        // list. If there are not enough it will start returning errors.
-        //
-        // size - size for the buffers
-        fn new(number: usize, size: usize) -> Self {
-            let mut zbi_items_buffer_vec = Vec::<AlignedBuffer>::new();
-            let mut zbi_zircon_buffer_vec = Vec::<AlignedBuffer>::new();
-            for _ in 0..number {
-                zbi_zircon_buffer_vec.push(AlignedBuffer::new(size, ZIRCON_KERNEL_ALIGN));
-                zbi_items_buffer_vec.push(AlignedBuffer::new(size, ZBI_ALIGNMENT_USIZE));
-            }
-
-            Self(
-                [
-                    (String::from("zbi_zircon"), zbi_zircon_buffer_vec),
-                    (String::from("zbi_items"), zbi_items_buffer_vec),
-                ]
-                .into(),
-            )
-        }
-
-        pub fn get(&mut self) -> HashMap<String, LinkedList<ImageBuffer>> {
-            self.0
-                .iter_mut()
-                .map(|(key, val_vec)| {
-                    (
-                        key.clone(),
-                        val_vec
-                            .iter_mut()
-                            .map(|e| ImageBuffer::new(as_uninit_mut(e.as_mut())))
-                            .collect(),
-                    )
-                })
-                .collect()
-        }
-    }
-
-    struct ImageBuffersBuilder {
-        // Number of buffers for each image name
-        number: usize,
-        // Size of the buffers
-        size: usize,
-    }
-
-    /// Tests should make sure to provide enough buffers for all `get_image_buffer()` calls.
-    /// Default number of calls is 1, if more expected use `builder().number(N).build()`
-    /// Default buffer sizes are 2KiB, if different size required use `builder().size(1MiB).build()`
-    impl ImageBuffersBuilder {
-        pub fn new() -> ImageBuffersBuilder {
-            Self { number: 1, size: 2 * 1024 }
-        }
-
-        /// If more than 1 `get_image_buffer()` call expected `number(N)` should be used to create
-        /// big enough pool of buffers.
-        pub fn number(mut self, number: usize) -> ImageBuffersBuilder {
-            self.number = number;
-            self
-        }
-
-        /// To change size of buffers use `builder(). size(S).build()`.
-        pub fn size(mut self, size: usize) -> ImageBuffersBuilder {
-            self.size = size;
-            self
-        }
-
-        pub fn build(self) -> ImageBuffersPool {
-            ImageBuffersPool::new(self.number, self.size)
-        }
-    }
-
-    #[test]
-    fn test_zircon_load_verify_slotless() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        let zbi = &read_test_data(ZIRCON_SLOTLESS_ZBI_FILE);
-        let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
-        // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_1);
-        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_2);
-        test_load_verify(&mut ops, None, &expected_zbi_items, &expected_kernel);
-    }
-
-    /// Helper for testing `zircon_load_verify` using A/B/R.
-    fn test_load_verify_slotted_helper(
-        ops: &mut FakeGblOps,
-        slot: SlotIndex,
-        zbi: &[u8],
-        slot_item: &str,
-    ) {
-        let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
-        // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        append_cmd_line(&mut expected_zbi_items, slot_item.as_bytes());
-        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_1);
-        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_2);
-        test_load_verify(ops, Some(slot), &expected_zbi_items, &expected_kernel);
-    }
-
-    #[test]
-    fn test_load_verify_slot_a() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        let zircon_a_zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        test_load_verify_slotted_helper(&mut ops, SlotIndex::A, zircon_a_zbi, "zvb.current_slot=a");
-    }
-
-    #[test]
-    fn test_load_verify_slot_b() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        let zircon_b_zbi = &read_test_data(ZIRCON_B_ZBI_FILE);
-        test_load_verify_slotted_helper(&mut ops, SlotIndex::B, zircon_b_zbi, "zvb.current_slot=b");
-    }
-
-    #[test]
-    fn test_load_verify_slot_r() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        let zircon_r_zbi = &read_test_data(ZIRCON_R_ZBI_FILE);
-        test_load_verify_slotted_helper(&mut ops, SlotIndex::R, zircon_r_zbi, "zvb.current_slot=r");
-    }
-
-    #[test]
-    fn test_not_enough_buffer_for_reserved_memory() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().size(1024).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        assert!(zircon_load_verify(&mut ops, Some(SlotIndex::A), true).is_err());
-    }
-
-    /// A helper for assembling a set of test needed data. These include:
-    ///
-    /// * The original ZBI kernel image on partition `part` in the given `FakeGblOps`.
-    /// * A buffer for loading and verifying the kernel.
-    /// * The expected ZBI item buffer, if successfully loaded as slot index `slot`.
-    /// * The expected ZBI kernel buffer, if successfully loaded.
-    fn load_verify_test_data(
-        ops: &mut FakeGblOps,
-        slot: SlotIndex,
-        part: &str,
-    ) -> (Vec<u8>, AlignedBuffer, AlignedBuffer, AlignedBuffer) {
-        // Read the (possibly modified) ZBI from disk.
-        let zbi = ops.copy_partition(part);
-        let sz = ZIRCON_KERNEL_ALIGN + zbi.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE;
-        let load_buffer = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
-        let expected_kernel = AlignedBuffer::new_with_data(&zbi, ZBI_ALIGNMENT_USIZE);
-        // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        append_cmd_line(
-            &mut expected_zbi_items,
-            format!("zvb.current_slot={}", char::from(slot)).as_bytes(),
-        );
-        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_1);
-        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_2);
-        (zbi, load_buffer, expected_zbi_items, expected_kernel)
-    }
-
-    // Calls `zircon_load_verify_abr` and checks that the specified slot is loaded.
-    fn expect_load_verify_abr_ok(ops: &mut FakeGblOps, slot: SlotIndex, part: &str) {
-        let (_, _load, expected_items, expected_kernel) = load_verify_test_data(ops, slot, part);
-        let (mut zbi_items, mut kernel, active) = zircon_load_verify_abr(ops).unwrap();
-        assert_eq!(normalize_zbi(&expected_items), normalize_zbi(zbi_items.used_mut()));
-        assert_eq!(normalize_zbi(&expected_kernel), normalize_zbi(kernel.used_mut()));
-        assert_eq!(active, slot);
-    }
-
-    #[test]
-    fn test_load_verify_abr_slot_a() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon_a");
-    }
-
-    #[test]
-    fn test_load_verify_abr_slot_b() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        mark_slot_active(&mut GblAbrOps(&mut ops), SlotIndex::B).unwrap();
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon_b");
-    }
-
-    #[test]
-    fn test_load_verify_abr_slot_r() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        mark_slot_unbootable(&mut GblAbrOps(&mut ops), SlotIndex::A).unwrap();
-        mark_slot_unbootable(&mut GblAbrOps(&mut ops), SlotIndex::B).unwrap();
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
-    }
-
-    #[test]
-    fn test_load_verify_abr_exhaust_retries() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool =
-            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon_a");
-        }
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon_b");
-        }
-        // Tests that load falls back to R eventually.
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
-    }
-
-    /// Modifies data in the given partition.
-    pub(crate) fn corrupt_data(ops: &mut FakeGblOps, part_name: &str) {
-        let mut data = [0u8];
-        assert!(ops.read_from_partition_sync(part_name, 64, &mut data[..]).is_ok());
-        data[0] ^= 0x01;
-        assert!(ops.write_to_partition_sync(part_name, 64, &mut data[..]).is_ok());
-    }
-
-    #[test]
-    fn test_load_verify_abr_verify_failure_a_b() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool =
-            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        corrupt_data(&mut ops, "zircon_a");
-        corrupt_data(&mut ops, "zircon_b");
-
-        let (_, _load, _, _) = load_verify_test_data(&mut ops, SlotIndex::A, "zircon_a");
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            assert!(zircon_load_verify_abr(&mut ops).is_err());
-        }
-        let (_, _load, _, _) = load_verify_test_data(&mut ops, SlotIndex::B, "zircon_b");
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            assert!(zircon_load_verify_abr(&mut ops).is_err());
-        }
-        // Tests that load falls back to R eventually.
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
-    }
-
-    #[test]
-    fn test_load_verify_abr_verify_failure_unlocked() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool =
-            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        ops.avb_ops.unlock_state = Ok(true);
-        corrupt_data(&mut ops, "zircon_a");
-        corrupt_data(&mut ops, "zircon_b");
-
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon_a");
-        }
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon_b");
-        }
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
-    }
-
-    #[test]
-    fn test_check_enter_fastboot_stop_in_fastboot() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        ops.stop_in_fastboot = Ok(false).into();
-        assert!(!zircon_check_enter_fastboot(&mut ops));
-
-        ops.stop_in_fastboot = Ok(true).into();
-        assert!(zircon_check_enter_fastboot(&mut ops));
-
-        ops.stop_in_fastboot = Err(Error::NotImplemented).into();
-        assert!(!zircon_check_enter_fastboot(&mut ops));
-    }
-
-    #[test]
-    fn test_check_enter_fastboot_abr() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        set_one_shot_bootloader(&mut GblAbrOps(&mut ops), true).unwrap();
-        assert!(zircon_check_enter_fastboot(&mut ops));
-        // One-shot only.
-        assert!(!zircon_check_enter_fastboot(&mut ops));
-    }
-
-    #[test]
-    fn test_check_enter_fastboot_prioritize_abr() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        set_one_shot_bootloader(&mut GblAbrOps(&mut ops), true).unwrap();
-        ops.stop_in_fastboot = Ok(true).into();
-        assert!(zircon_check_enter_fastboot(&mut ops));
-        ops.stop_in_fastboot = Ok(false).into();
-        // A/B/R metadata should be prioritized in the previous check and thus one-shot-booloader
-        // flag should be cleared.
-        assert!(!zircon_check_enter_fastboot(&mut ops));
-    }
-    #[test]
-    fn test_load_verify_abr_legacy_naming() {
-        let storage = create_storage_legacy_names();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool =
-            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
-        ops.image_buffers = image_buffers_pool.get();
-
-        // Tests by exhausting all slots retries so it exercises all legacy name matching code
-        // paths.
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon-a");
-        }
-        for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon-b");
-        }
-        // Tests that load falls back to R eventually.
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon-r");
-    }
-
-    #[test]
-    fn test_zircon_load_verify_no_bootloader_file() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
-        ops.image_buffers = image_buffers_pool.get();
-        ops.get_zbi_bootloader_files_buffer().unwrap().fill(0);
-
-        let zbi = &read_test_data(ZIRCON_SLOTLESS_ZBI_FILE);
-        let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
-        // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        test_load_verify(&mut ops, None, &expected_zbi_items, &expected_kernel);
-    }
-}
diff --git a/gbl/libgbl/src/fuchsia_boot/vboot.rs b/gbl/libgbl/src/fuchsia_boot/vboot.rs
deleted file mode 100644
index 71fc819..0000000
--- a/gbl/libgbl/src/fuchsia_boot/vboot.rs
+++ /dev/null
@@ -1,370 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    fuchsia_boot::{zbi_split_unused_buffer, zircon_part_name, SlotIndex},
-    gbl_avb::ops::GblAvbOps,
-    gbl_print, GblOps, Result as GblResult,
-};
-use avb::{slot_verify, Descriptor, HashtreeErrorMode, Ops as _, SlotVerifyFlags};
-use zbi::ZbiContainer;
-use zerocopy::SplitByteSliceMut;
-
-/// Verifies a loaded ZBI kernel.
-///
-/// # Arguments
-///
-/// * glb_ops - GblOps implementation
-/// * slot - slot to verify
-/// * slot_booted_successfully - if true, roll back indexes will be increased
-/// * zbi_kernel - preloaded kernel to verify
-/// * zbi_items - vbmeta items will be appended to this ZbiContainer
-pub(crate) fn zircon_verify_kernel<'a, 'b, 'c, B: SplitByteSliceMut + PartialEq>(
-    gbl_ops: &mut impl GblOps<'b, 'c>,
-    slot: Option<SlotIndex>,
-    slot_booted_successfully: bool,
-    zbi_kernel: &'a mut [u8],
-    zbi_items: &mut ZbiContainer<B>,
-) -> GblResult<()> {
-    // Copy ZBI items after kernel first. Because ordering matters, and new items should override
-    // older ones.
-    // TODO(b/379778252) It is not as efficient as moving kernel since ZBI items would contain file
-    // system and be bigger than kernel.
-    copy_items_after_kernel(zbi_kernel, zbi_items)?;
-
-    let (kernel, _) = zbi_split_unused_buffer(&mut zbi_kernel[..])?;
-
-    // Verifies the kernel.
-    let part = zircon_part_name(slot);
-    let slotless_part = zircon_part_name(None);
-    let preloaded = [(slotless_part, &kernel[..])];
-    let mut avb_ops = GblAvbOps::new(gbl_ops, slot, &preloaded[..], true);
-
-    // Determines verify flags and error mode.
-    let unlocked = avb_ops.read_is_device_unlocked()?;
-    let mode = HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_EIO; // Don't care for fuchsia
-    let flag = match unlocked {
-        true => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,
-        _ => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-    };
-
-    // TODO(b/334962583): Supports optional additional partitions to verify.
-    let verify_res = slot_verify(&mut avb_ops, &[c"zircon"], slot.map(|s| s.into()), flag, mode);
-    let verified_success = verify_res.is_ok();
-    let verify_data = match verify_res {
-        Ok(ref v) => {
-            gbl_print!(avb_ops.gbl_ops, "{} successfully verified.\r\n", part);
-            v
-        }
-        Err(ref e) if e.verification_data().is_some() && unlocked => {
-            gbl_print!(avb_ops.gbl_ops, "Verification failed. Device is unlocked. Ignore.\r\n");
-            e.verification_data().unwrap()
-        }
-        Err(_) if unlocked => {
-            gbl_print!(
-                avb_ops.gbl_ops,
-                "Verification failed. No valid verify metadata. \
-                    Device is unlocked. Ignore.\r\n"
-            );
-            return Ok(());
-        }
-        Err(e) => {
-            gbl_print!(avb_ops.gbl_ops, "Verification failed {:?}.\r\n", e);
-            return Err(e.without_verify_data().into());
-        }
-    };
-
-    // Collects ZBI items from vbmetadata and appends to the `zbi_items`.
-    for vbmeta_data in verify_data.vbmeta_data() {
-        for prop in vbmeta_data.descriptors()?.iter().filter_map(|d| match d {
-            Descriptor::Property(p) if p.key.starts_with("zbi") => Some(p),
-            _ => None,
-        }) {
-            zbi_items.extend_unaligned(prop.value)?;
-        }
-    }
-
-    // Increases rollback indices if the slot has successfully booted.
-    if verified_success && slot_booted_successfully {
-        for (loc, val) in verify_data.rollback_indexes().iter().enumerate() {
-            if *val > 0 && avb_ops.read_rollback_index(loc)? != *val {
-                avb_ops.write_rollback_index(loc, *val)?;
-            }
-        }
-
-        // Increases rollback index values for Fuchsia key version locations.
-        for key_version in avb_ops.key_versions {
-            match key_version {
-                Some((loc, rollback)) if avb_ops.read_rollback_index(loc)? != rollback => {
-                    avb_ops.write_rollback_index(loc, rollback)?;
-                }
-                _ => {}
-            }
-        }
-    }
-
-    Ok(())
-}
-
-/// Copy ZBI items following kernel to separate container.
-pub fn copy_items_after_kernel<'a, B: SplitByteSliceMut + PartialEq>(
-    zbi_kernel: &'a mut [u8],
-    zbi_items: &mut ZbiContainer<B>,
-) -> GblResult<()> {
-    let zbi_container = ZbiContainer::parse(&mut zbi_kernel[..])?;
-    let mut items_iter = zbi_container.iter();
-    items_iter.next(); // Skip first kernel item
-    zbi_items.extend_items(items_iter)?;
-    Ok(())
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::{
-        fuchsia_boot::{
-            test::{
-                append_cmd_line, corrupt_data, create_gbl_ops, create_storage, normalize_zbi,
-                read_test_data, ZIRCON_A_ZBI_FILE,
-            },
-            ZIRCON_KERNEL_ALIGN,
-        },
-        tests::AlignedBuffer,
-    };
-    use avb_bindgen::{AVB_CERT_PIK_VERSION_LOCATION, AVB_CERT_PSK_VERSION_LOCATION};
-    use zbi::ZBI_ALIGNMENT_USIZE;
-
-    // The cert test keys were both generated with rollback version 42.
-    const TEST_CERT_PIK_VERSION: u64 = 42;
-    const TEST_CERT_PSK_VERSION: u64 = 42;
-
-    #[test]
-    fn test_verify_success() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        let expect_rollback = ops.avb_ops.rollbacks.clone();
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), false, &mut load_buffer, &mut zbi_items)
-            .unwrap();
-
-        // Verifies that vbmeta ZBI items are appended. Non-zbi items are ignored.
-        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, 8);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        assert_eq!(normalize_zbi(&zbi_items_buffer), normalize_zbi(&expected_zbi_items));
-
-        // Slot is not successful, rollback index should not be updated.
-        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
-    }
-
-    #[test]
-    fn test_verify_update_rollback_index_for_successful_slot() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer, &mut zbi_items)
-            .unwrap();
-
-        // Slot is successful, rollback index should be updated.
-        // vbmeta_a has rollback index value 2 at location 1.
-        assert_eq!(
-            ops.avb_ops.rollbacks,
-            [
-                (1, Ok(2)),
-                (
-                    usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(),
-                    Ok(TEST_CERT_PSK_VERSION)
-                ),
-                (
-                    usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(),
-                    Ok(TEST_CERT_PIK_VERSION)
-                )
-            ]
-            .into()
-        );
-    }
-
-    #[test]
-    fn test_verify_failed_on_corrupted_image() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        let expect_rollback = ops.avb_ops.rollbacks.clone();
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        // Corrupts a random kernel bytes. Skips pass two ZBI headers.
-        load_buffer[64] = !load_buffer[64];
-        let expect_load = load_buffer.to_vec();
-        assert!(zircon_verify_kernel(
-            &mut ops,
-            Some(SlotIndex::A),
-            true,
-            &mut load_buffer,
-            &mut zbi_items
-        )
-        .is_err());
-        // Failed while device is locked. ZBI items should not be appended.
-        assert_eq!(expect_load, &load_buffer[..]);
-        // Rollback index should not be updated on verification failure.
-        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
-    }
-
-    #[test]
-    fn test_verify_failed_on_corrupted_vbmetadata() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        let expect_rollback = ops.avb_ops.rollbacks.clone();
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        load[..zbi.len()].clone_from_slice(zbi);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        let expect_load = load.to_vec();
-        // Corrupts vbmetadata
-        corrupt_data(&mut ops, "vbmeta_a");
-        assert!(zircon_verify_kernel(
-            &mut ops,
-            Some(SlotIndex::A),
-            true,
-            &mut load,
-            &mut zbi_items
-        )
-        .is_err());
-        // Failed while device is locked. ZBI items should not be appended.
-        assert_eq!(expect_load, &load[..]);
-        // Rollback index should not be updated on verification failure.
-        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
-    }
-
-    #[test]
-    fn test_verify_failed_on_rollback_protection() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        let expect_load = load_buffer.to_vec();
-        // vbmeta_a has rollback index value 2 at location 1. Setting min rollback value of 3 should
-        // cause rollback protection failure.
-        ops.avb_ops.rollbacks.insert(1, Ok(3));
-        let expect_rollback = ops.avb_ops.rollbacks.clone();
-        assert!(zircon_verify_kernel(
-            &mut ops,
-            Some(SlotIndex::A),
-            true,
-            &mut load_buffer,
-            &mut zbi_items
-        )
-        .is_err());
-        // Failed while device is locked. ZBI items should not be appended.
-        assert_eq!(expect_load, &load_buffer[..]);
-        // Rollback index should not be updated on verification failure.
-        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
-    }
-
-    #[test]
-    fn test_verify_failure_when_unlocked() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        ops.avb_ops.unlock_state = Ok(true);
-        let expect_rollback = ops.avb_ops.rollbacks.clone();
-
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        // Corrupts a random kernel bytes. Skips pass two ZBI headers.
-        load_buffer[64] = !load_buffer[64];
-        // Verification should proceeds OK.
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer, &mut zbi_items)
-            .unwrap();
-        // Verifies that vbmeta ZBI items are appended as long as unlocked.
-        let mut expected_zbi_items = AlignedBuffer::new(load_buffer.len(), ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        assert_eq!(normalize_zbi(&zbi_items_buffer), normalize_zbi(&expected_zbi_items));
-        // Rollback index should not be updated in any failure cases, even when unlocked.
-        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
-    }
-
-    #[test]
-    fn test_copy_items_after_kernel() {
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        // Add items that will be copied
-        append_cmd_line(&mut load_buffer, b"vb_prop_0=val\0");
-        append_cmd_line(&mut load_buffer, b"vb_prop_1=val\0");
-
-        // Create ZBI items container that contain 1 element
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        append_cmd_line(&mut zbi_items_buffer, b"vb_prop_2=val\0");
-        let mut zbi_items = ZbiContainer::parse(&mut zbi_items_buffer[..]).unwrap();
-
-        // Verifies that ZBI items are appended
-        let mut expected_zbi_items = AlignedBuffer::new(load_buffer.len(), ZBI_ALIGNMENT_USIZE);
-        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_2=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
-        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-
-        copy_items_after_kernel(&mut load_buffer, &mut zbi_items).unwrap();
-        assert_eq!(normalize_zbi(&zbi_items_buffer), normalize_zbi(&expected_zbi_items));
-    }
-
-    #[test]
-    fn test_verify_failure_by_corrupted_vbmetadata_unlocked() {
-        let storage = create_storage();
-        let mut ops = create_gbl_ops(&storage);
-
-        ops.avb_ops.unlock_state = Ok(true);
-        let expect_rollback = ops.avb_ops.rollbacks.clone();
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
-        load_buffer[..zbi.len()].clone_from_slice(zbi);
-        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
-        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
-        let expect_load = load_buffer.to_vec();
-        // Corrupts vbmetadata
-        corrupt_data(&mut ops, "vbmeta_a");
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer, &mut zbi_items)
-            .unwrap();
-        // Unlocked but vbmetadata is invalid so no ZBI items should be appended.
-        assert_eq!(expect_load, &load_buffer[..]);
-        // Rollback index should not be updated on verification failure.
-        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
-    }
-}
diff --git a/gbl/libgbl/src/gbl_avb/mod.rs b/gbl/libgbl/src/gbl_avb/mod.rs
deleted file mode 100644
index 4d90083..0000000
--- a/gbl/libgbl/src/gbl_avb/mod.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! GBL AVB implementation.
-
-pub(crate) mod ops;
-pub mod state;
diff --git a/gbl/libgbl/src/gbl_avb/ops.rs b/gbl/libgbl/src/gbl_avb/ops.rs
deleted file mode 100644
index 9401587..0000000
--- a/gbl/libgbl/src/gbl_avb/ops.rs
+++ /dev/null
@@ -1,929 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Gbl AVB operations.
-
-use crate::{
-    gbl_avb::state::{BootStateColor, KeyValidationStatus},
-    gbl_print, gbl_println, GblOps,
-};
-use abr::SlotIndex;
-use arrayvec::ArrayString;
-use avb::{
-    cert_validate_vbmeta_public_key, CertOps, CertPermanentAttributes, IoError, IoResult,
-    Ops as AvbOps, PublicKeyForPartitionInfo, SlotVerifyData, SHA256_DIGEST_SIZE,
-    SHA512_DIGEST_SIZE,
-};
-use core::fmt::Write;
-use core::{
-    cmp::{max, min},
-    ffi::CStr,
-};
-use liberror::Error;
-use safemath::SafeNum;
-use uuid::Uuid;
-
-/// The digest key in commandline provided by libavb.
-pub const AVB_DIGEST_KEY: &str = "androidboot.vbmeta.digest";
-
-// AVB cert tracks versions for the PIK and PSK; PRK cannot be changed so has no version info.
-const AVB_CERT_NUM_KEY_VERSIONS: usize = 2;
-
-/// Implements avb ops callbacks for [GblOps].
-pub struct GblAvbOps<'a, T> {
-    /// The underlying [GblOps].
-    pub gbl_ops: &'a mut T,
-    slot: Option<SlotIndex>,
-    /// Slotless partitions pre-loaded by the implementation. Provided to avoid redundant IO.
-    preloaded_partitions: &'a [(&'a str, &'a [u8])],
-    /// Used for storing key versions to be set (location, version).
-    ///
-    /// These will initially be `None`, but if using the cert extensions they will be updated during
-    /// verification. These values will not be automatically persisted to disk because whether to do
-    /// so depends on other factors such as slot success state; it's up to the user to persist them
-    /// post-verification if needed.
-    // If `array_map` is imported in the future, consider switching to it.
-    pub key_versions: [Option<(usize, u64)>; AVB_CERT_NUM_KEY_VERSIONS],
-    /// True to use the AVB cert extensions.
-    use_cert: bool,
-    /// Avb public key validation status reported by validate_vbmeta_public_key.
-    /// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
-    key_validation_status: Option<KeyValidationStatus>,
-}
-
-impl<'a, 'p, 'q, T: GblOps<'p, 'q>> GblAvbOps<'a, T> {
-    /// Creates a new [GblAvbOps].
-    pub fn new(
-        gbl_ops: &'a mut T,
-        slot: Option<SlotIndex>,
-        preloaded_partitions: &'a [(&'a str, &'a [u8])],
-        use_cert: bool,
-    ) -> Self {
-        Self {
-            gbl_ops,
-            slot,
-            preloaded_partitions,
-            key_versions: [None; AVB_CERT_NUM_KEY_VERSIONS],
-            use_cert,
-            key_validation_status: None,
-        }
-    }
-
-    /// Returns the size of a partition.
-    ///
-    /// This will only consider the [GblOps] partitions. To include preloaded partitions as well,
-    /// use [AvbOps::get_size_of_partition].
-    fn partition_size(&mut self, partition: &str) -> IoResult<u64> {
-        self.gbl_ops.partition_size(partition).or(Err(IoError::Io))?.ok_or(IoError::NoSuchPartition)
-    }
-
-    /// Allowes implementation side to handle verification result.
-    pub fn handle_verification_result(
-        &mut self,
-        slot_verify: Option<&SlotVerifyData>,
-        color: BootStateColor,
-        digest: Option<&str>,
-    ) -> IoResult<()> {
-        // The Android build system automatically generates only the main vbmeta, but also allows
-        // to have separate chained partitions like vbmeta_system (for system, product, system_ext,
-        // etc.) or vbmeta_vendor (for vendor).
-        // https://android.googlesource.com/platform/external/avb/+/master/README.md#build-system-integration
-        //
-        // It may also integrate chained vbmeta into system level metadata partitions such as boot
-        // or init_boot, so they can be updated separately.
-        // https://android.googlesource.com/platform/external/avb/+/master/README.md#gki-2_0-integration
-        //
-        // Custom chained partitions are also supported by the Android build system, but we expect
-        // OEMs to follow about the same pattern.
-        // https://android-review.googlesource.com/q/Id671e2c3aee9ada90256381cce432927df03169b
-        let (
-            boot_os_version,
-            boot_security_patch,
-            system_os_version,
-            system_security_patch,
-            vendor_os_version,
-            vendor_security_patch,
-        ) = match slot_verify {
-            Some(slot_verify) => {
-                let mut vbmeta = None;
-                let mut vbmeta_boot = None;
-                let mut vbmeta_system = None;
-                let mut vbmeta_vendor = None;
-
-                for data in slot_verify.vbmeta_data() {
-                    match data.partition_name().to_str().unwrap_or_default() {
-                        "vbmeta" => vbmeta = Some(data),
-                        "boot" => vbmeta_boot = Some(data),
-                        "vbmeta_system" => vbmeta_system = Some(data),
-                        "vbmeta_vendor" => vbmeta_vendor = Some(data),
-                        _ => {}
-                    }
-                }
-
-                let data = vbmeta.ok_or(IoError::NoSuchPartition)?;
-                let boot_data = vbmeta_boot.unwrap_or(data);
-                let system_data = vbmeta_system.unwrap_or(data);
-                let vendor_data = vbmeta_vendor.unwrap_or(data);
-
-                (
-                    boot_data.get_property_value("com.android.build.boot.os_version"),
-                    boot_data.get_property_value("com.android.build.boot.security_patch"),
-                    system_data.get_property_value("com.android.build.system.os_version"),
-                    system_data.get_property_value("com.android.build.system.security_patch"),
-                    vendor_data.get_property_value("com.android.build.vendor.os_version"),
-                    vendor_data.get_property_value("com.android.build.vendor.security_patch"),
-                )
-            }
-            None => (None, None, None, None, None, None),
-        };
-
-        // Convert digest rust string to null-terminated string by copying it into separate buffer.
-        let mut digest_buffer = ArrayString::<{ 2 * SHA512_DIGEST_SIZE + 1 }>::new();
-        let digest_cstr = match digest {
-            Some(digest) => {
-                write!(digest_buffer, "{}\0", digest).or(Err(IoError::InvalidValueSize))?;
-                Some(
-                    CStr::from_bytes_until_nul(digest_buffer.as_bytes())
-                        .or(Err(IoError::InvalidValueSize))?,
-                )
-            }
-            None => None,
-        };
-
-        self.gbl_ops.avb_handle_verification_result(
-            color,
-            digest_cstr,
-            boot_os_version,
-            boot_security_patch,
-            system_os_version,
-            system_security_patch,
-            vendor_os_version,
-            vendor_security_patch,
-        )
-    }
-
-    /// Get vbmeta public key validation status reported by validate_vbmeta_public_key.
-    pub fn key_validation_status(&self) -> IoResult<KeyValidationStatus> {
-        self.key_validation_status.ok_or(IoError::NotImplemented)
-    }
-}
-
-/// A helper function for converting `CStr` to `str`
-fn cstr_to_str<E>(s: &CStr, err: E) -> Result<&str, E> {
-    Ok(s.to_str().or(Err(err))?)
-}
-
-/// A helper function to split partition into base name and slot index
-fn split_slotted(partition: &str) -> Result<(&str, SlotIndex), Error> {
-    // Attempt to split on the last underscore
-    let (partition_name, suffix) = partition.rsplit_once('_').ok_or(Error::InvalidInput)?;
-
-    // Ensure suffix has exactly one character
-    if suffix.len() != 1 {
-        return Err(Error::InvalidInput);
-    }
-
-    // Convert that single character into a SlotIndex
-    let slot_char = suffix.chars().next().unwrap();
-    let slot = slot_char.try_into().map_err(|_| Error::InvalidInput)?;
-
-    Ok((partition_name, slot))
-}
-
-/// # Lifetimes
-/// * `'a`: preloaded data lifetime
-/// * `'b`: [GblOps] partition lifetime
-impl<'a, 'b, 'c, T: GblOps<'b, 'c>> AvbOps<'a> for GblAvbOps<'a, T> {
-    fn read_from_partition(
-        &mut self,
-        partition: &CStr,
-        offset: i64,
-        buffer: &mut [u8],
-    ) -> IoResult<usize> {
-        let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-        let partition_size = SafeNum::from(self.partition_size(part_str)?);
-        let read_off = match offset < 0 {
-            true => partition_size - offset.abs(),
-            _ => SafeNum::from(offset),
-        };
-        let read_sz = partition_size - read_off;
-        let read_off = read_off.try_into().or(Err(IoError::RangeOutsidePartition))?;
-        let read_sz =
-            min(buffer.len(), read_sz.try_into().or(Err(IoError::RangeOutsidePartition))?);
-        self.gbl_ops.read_from_partition_sync(part_str, read_off, &mut buffer[..read_sz]).map_err(
-            |e| match e {
-                Error::NotFound => IoError::NoSuchPartition,
-                Error::ArithmeticOverflow(_) => IoError::RangeOutsidePartition,
-                _ => IoError::Io,
-            },
-        )?;
-        Ok(read_sz)
-    }
-
-    fn get_preloaded_partition(&mut self, partition: &CStr) -> IoResult<&'a [u8]> {
-        let part_str = cstr_to_str(partition, IoError::NotImplemented)?;
-
-        let partition_name = match self.slot {
-            // Extract partition slot and ensure it's matched.
-            Some(slot) => {
-                let (partition_name, partition_slot) =
-                    split_slotted(part_str).map_err(|_| IoError::NotImplemented)?;
-
-                if partition_slot != slot {
-                    return Err(IoError::NotImplemented);
-                }
-
-                partition_name
-            }
-            _ => part_str,
-        };
-
-        self.preloaded_partitions
-            .iter()
-            .find(|(name, _)| *name == partition_name)
-            .map(|(_, data)| *data)
-            .ok_or_else(|| IoError::NotImplemented)
-    }
-
-    fn validate_vbmeta_public_key(
-        &mut self,
-        public_key: &[u8],
-        public_key_metadata: Option<&[u8]>,
-    ) -> IoResult<bool> {
-        let status = if self.use_cert {
-            match cert_validate_vbmeta_public_key(self, public_key, public_key_metadata)? {
-                true => KeyValidationStatus::Valid,
-                false => KeyValidationStatus::Invalid,
-            }
-        } else {
-            self.gbl_ops.avb_validate_vbmeta_public_key(public_key, public_key_metadata).or_else(
-                |err| {
-                    // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-                    // forced.
-                    fallback_not_implemented(
-                        self.gbl_ops,
-                        err,
-                        "validate_vbmeta_public_key",
-                        KeyValidationStatus::ValidCustomKey,
-                    )
-                },
-            )?
-        };
-
-        self.key_validation_status = Some(status);
-
-        Ok(matches!(status, KeyValidationStatus::Valid | KeyValidationStatus::ValidCustomKey))
-    }
-
-    fn read_rollback_index(&mut self, rollback_index_location: usize) -> IoResult<u64> {
-        self.gbl_ops.avb_read_rollback_index(rollback_index_location).or_else(|err| {
-            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-            // forced.
-            fallback_not_implemented(self.gbl_ops, err, "read_rollback_index", 0)
-        })
-    }
-
-    fn write_rollback_index(&mut self, rollback_index_location: usize, index: u64) -> IoResult<()> {
-        self.gbl_ops.avb_write_rollback_index(rollback_index_location, index).or_else(|err| {
-            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-            // forced.
-            fallback_not_implemented(self.gbl_ops, err, "write_rollback_index", ())
-        })
-    }
-
-    fn read_is_device_unlocked(&mut self) -> IoResult<bool> {
-        self.gbl_ops.avb_read_is_device_unlocked().or_else(|err| {
-            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-            // forced.
-            fallback_not_implemented(self.gbl_ops, err, "read_is_device_unlocked", true)
-        })
-    }
-
-    fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> IoResult<Uuid> {
-        // The ops is only used to check that a partition exists. GUID is not used.
-        self.partition_size(cstr_to_str(partition, IoError::NoSuchPartition)?)?;
-        Ok(Uuid::nil())
-    }
-
-    fn get_size_of_partition(&mut self, partition: &CStr) -> IoResult<u64> {
-        match self.get_preloaded_partition(partition) {
-            Ok(img) => Ok(img.len().try_into().unwrap()),
-            _ => {
-                let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-                self.partition_size(part_str)
-            }
-        }
-    }
-
-    fn read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> IoResult<usize> {
-        self.gbl_ops.avb_read_persistent_value(name, value).or_else(|err| {
-            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-            // forced.
-            fallback_not_implemented(self.gbl_ops, err, "read_persistent_value", 0)
-        })
-    }
-
-    fn write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> IoResult<()> {
-        self.gbl_ops.avb_write_persistent_value(name, value).or_else(|err| {
-            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-            // forced.
-            fallback_not_implemented(self.gbl_ops, err, "write_persistent_value", ())
-        })
-    }
-
-    fn erase_persistent_value(&mut self, name: &CStr) -> IoResult<()> {
-        self.gbl_ops.avb_erase_persistent_value(name).or_else(|err| {
-            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
-            // forced.
-            fallback_not_implemented(self.gbl_ops, err, "erase_persistent_value", ())
-        })
-    }
-
-    fn validate_public_key_for_partition(
-        &mut self,
-        _partition: &CStr,
-        _public_key: &[u8],
-        _public_key_metadata: Option<&[u8]>,
-    ) -> IoResult<PublicKeyForPartitionInfo> {
-        // Not needed yet; eventually we will plumb this through [GblOps].
-        unreachable!();
-    }
-
-    fn cert_ops(&mut self) -> Option<&mut dyn CertOps> {
-        match self.use_cert {
-            true => Some(self),
-            false => None,
-        }
-    }
-}
-
-/// [GblAvbOps] always implements [CertOps], but it's only used if `use_cert` is set.
-impl<'a, 'b, T: GblOps<'a, 'b>> CertOps for GblAvbOps<'_, T> {
-    fn read_permanent_attributes(
-        &mut self,
-        attributes: &mut CertPermanentAttributes,
-    ) -> IoResult<()> {
-        self.gbl_ops.avb_cert_read_permanent_attributes(attributes)
-    }
-
-    fn read_permanent_attributes_hash(&mut self) -> IoResult<[u8; SHA256_DIGEST_SIZE]> {
-        self.gbl_ops.avb_cert_read_permanent_attributes_hash()
-    }
-
-    fn set_key_version(&mut self, rollback_index_location: usize, key_version: u64) {
-        // Checks if there is already an allocated slot for this location.
-        let existing = self
-            .key_versions
-            .iter_mut()
-            .find_map(|v| v.as_mut().filter(|(loc, _)| *loc == rollback_index_location));
-        match existing {
-            Some((_, val)) => *val = max(*val, key_version),
-            _ => {
-                // Finds an empty slot and stores the rollback index.
-                *self
-                    .key_versions
-                    .iter_mut()
-                    .find(|v| v.is_none())
-                    .expect("Ran out of key version slots") =
-                    Some((rollback_index_location, key_version))
-            }
-        }
-    }
-
-    fn get_random(&mut self, _: &mut [u8]) -> IoResult<()> {
-        // Not needed yet; eventually we will plumb this through [GblOps].
-        unimplemented!()
-    }
-}
-
-fn fallback_not_implemented<'a, 'b, T>(
-    ops: &mut impl GblOps<'a, 'b>,
-    error: IoError,
-    method_name: &str,
-    value: T,
-) -> IoResult<T> {
-    match error {
-        IoError::NotImplemented => {
-            gbl_println!(
-                ops,
-                "WARNING: UEFI GblEfiAvbProtocol.{} implementation is missing. This will not be \
-                permitted in the future.",
-                method_name,
-            );
-            Ok(value)
-        }
-        err => Err(err),
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::ops::test::{FakeGblOps, FakeGblOpsStorage};
-
-    // Returns test data consisting of `size` incrementing bytes (0-255 repeating).
-    fn test_data(size: usize) -> Vec<u8> {
-        let mut data = vec![0u8; size];
-        for index in 0..data.len() {
-            data[index] = index as u8;
-        }
-        data
-    }
-
-    #[test]
-    fn read_from_partition_positive_off() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"test_part", test_data(512));
-
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        // Positive offset.
-        let mut out = [0u8; 4];
-        assert_eq!(avb_ops.read_from_partition(c"test_part", 1, &mut out[..]), Ok(4));
-        assert_eq!(out, [1, 2, 3, 4]);
-    }
-
-    #[test]
-    fn read_from_partition_negative_off() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"test_part", test_data(512));
-
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        // Negative offset should wrap from the end
-        let mut out = [0u8; 6];
-        assert_eq!(avb_ops.read_from_partition(c"test_part", -6, &mut out[..]), Ok(6));
-        assert_eq!(out, [0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF]);
-    }
-
-    #[test]
-    fn read_from_partition_partial_read() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"test_part", test_data(512));
-
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        // Reading past the end of the partition should truncate.
-        let mut out = [0u8; 6];
-        assert_eq!(avb_ops.read_from_partition(c"test_part", -3, &mut out[..]), Ok(3));
-        assert_eq!(out, [0xFD, 0xFE, 0xFF, 0, 0, 0]);
-    }
-
-    #[test]
-    fn read_from_partition_out_of_bounds() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"test_part", test_data(512));
-
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        // Reads starting out of bounds should fail.
-        let mut out = [0u8; 4];
-        assert_eq!(
-            avb_ops.read_from_partition(c"test_part", 513, &mut out[..]),
-            Err(IoError::RangeOutsidePartition)
-        );
-        assert_eq!(
-            avb_ops.read_from_partition(c"test_part", -513, &mut out[..]),
-            Err(IoError::RangeOutsidePartition)
-        );
-    }
-
-    #[test]
-    fn read_from_partition_unknown_part() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        let mut out = [0u8; 4];
-        assert_eq!(
-            avb_ops.read_from_partition(c"unknown_part", 0, &mut out[..]),
-            Err(IoError::NoSuchPartition)
-        );
-    }
-
-    /// Helper function to test reading pre-loaded partitions.
-    fn test_read_preloaded_partition(
-        preloaded_partition: &str,
-        slot: Option<SlotIndex>,
-        partition_to_read: &CStr,
-        expect_success: bool,
-    ) {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-
-        let data = &test_data(512);
-        let slice = &data[..];
-        let preloaded = [(preloaded_partition, slice)];
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, slot, &preloaded, false);
-
-        match expect_success {
-            true => {
-                assert_eq!(
-                    avb_ops.get_size_of_partition(partition_to_read),
-                    Ok(data.len().try_into().unwrap())
-                );
-                assert_eq!(avb_ops.get_preloaded_partition(partition_to_read), Ok(slice));
-            }
-            false => {
-                assert_eq!(
-                    avb_ops.get_preloaded_partition(partition_to_read),
-                    Err(IoError::NotImplemented),
-                );
-            }
-        }
-    }
-
-    #[test]
-    fn read_from_preloaded_a_partition() {
-        test_read_preloaded_partition(
-            "test_partition",
-            Some(SlotIndex::A),
-            c"test_partition_a",
-            true,
-        );
-    }
-
-    #[test]
-    fn read_from_preloaded_b_partition() {
-        test_read_preloaded_partition(
-            "test_partition",
-            Some(SlotIndex::B),
-            c"test_partition_b",
-            true,
-        );
-    }
-
-    #[test]
-    fn read_from_preloaded_r_partition() {
-        test_read_preloaded_partition(
-            "test_partition",
-            Some(SlotIndex::R),
-            c"test_partition_r",
-            true,
-        );
-    }
-
-    #[test]
-    fn read_from_preloaded_slotless_partition() {
-        test_read_preloaded_partition("test_partition", None, c"test_partition", true);
-    }
-
-    #[test]
-    fn read_from_preloaded_partition_wrong_slot() {
-        // Ops are slotless but _a is used, so cannot read.
-        test_read_preloaded_partition("test_partition", None, c"test_partition_a", false);
-
-        // Ops are using A slot but slotless is getting read, so cannot read.
-        test_read_preloaded_partition(
-            "test_partition",
-            Some(SlotIndex::A),
-            c"test_partition",
-            false,
-        );
-
-        // Ops are using A slot but _b is getting read, so cannot read.
-        test_read_preloaded_partition(
-            "test_partition",
-            Some(SlotIndex::A),
-            c"test_partition_b",
-            false,
-        );
-    }
-
-    #[test]
-    fn set_key_version_default() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        assert_eq!(avb_ops.key_versions, [None, None]);
-    }
-
-    #[test]
-    fn set_key_version_once() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        avb_ops.set_key_version(5, 10);
-        assert_eq!(avb_ops.key_versions, [Some((5, 10)), None]);
-    }
-
-    #[test]
-    fn set_key_version_twice() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        avb_ops.set_key_version(5, 10);
-        avb_ops.set_key_version(20, 40);
-        assert_eq!(avb_ops.key_versions, [Some((5, 10)), Some((20, 40))]);
-    }
-
-    #[test]
-    fn set_key_version_overwrite() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        avb_ops.set_key_version(5, 10);
-        avb_ops.set_key_version(20, 40);
-        avb_ops.set_key_version(5, 100);
-        assert_eq!(avb_ops.key_versions, [Some((5, 100)), Some((20, 40))]);
-    }
-
-    // AVB's key version callback cannot return an error, so if it fails we panic.
-    //
-    // It's possible we could stash the failure somewhere and check it later, but we'd have to be
-    // very careful, as failing to check the status would be a security vulnerability. For now it's
-    // safer to panic, and we only ever expect the PSK and PIK to have key versions.
-    #[test]
-    #[should_panic(expected = "Ran out of key version slots")]
-    fn set_key_version_overflow() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        avb_ops.set_key_version(5, 10);
-        avb_ops.set_key_version(20, 40);
-        avb_ops.set_key_version(40, 100);
-    }
-
-    #[test]
-    fn validate_vbmeta_public_key_valid() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Valid));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(true));
-        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::Valid));
-    }
-
-    #[test]
-    fn validate_vbmeta_public_key_valid_custom_key() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::ValidCustomKey));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(true));
-        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::ValidCustomKey));
-    }
-
-    #[test]
-    fn validate_vbmeta_public_key_invalid() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Invalid));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(false));
-        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::Invalid));
-    }
-
-    #[test]
-    fn validate_vbmeta_public_key_failed() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_key_validation_status = Some(Err(IoError::Io));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Err(IoError::Io));
-        assert!(avb_ops.key_validation_status().is_err());
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn validate_vbmeta_public_key_not_implemented() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_key_validation_status = Some(Err(IoError::NotImplemented));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(true));
-        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::ValidCustomKey));
-    }
-
-    #[test]
-    fn read_rollback_index_read_value() {
-        const EXPECTED_INDEX: usize = 1;
-        const EXPECTED_VALUE: u64 = 100;
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.rollbacks.insert(EXPECTED_INDEX, Ok(EXPECTED_VALUE));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.read_rollback_index(EXPECTED_INDEX), Ok(EXPECTED_VALUE));
-    }
-
-    #[test]
-    fn read_rollback_index_error_handled() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.read_rollback_index(0), Err(IoError::Io));
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn read_rollback_index_not_implemented() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.rollbacks.insert(0, Err(IoError::NotImplemented));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.read_rollback_index(0), Ok(0));
-    }
-
-    #[test]
-    fn write_rollback_index_write_value() {
-        const EXPECTED_INDEX: usize = 1;
-        const EXPECTED_VALUE: u64 = 100;
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.write_rollback_index(EXPECTED_INDEX, EXPECTED_VALUE), Ok(()));
-        assert_eq!(
-            gbl_ops.avb_ops.rollbacks.get(&EXPECTED_INDEX),
-            Some(Ok(EXPECTED_VALUE)).as_ref()
-        );
-    }
-
-    #[test]
-    fn write_rollback_index_error_handled() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.rollbacks.insert(0, Err(IoError::Io));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.write_rollback_index(0, 0), Err(IoError::Io));
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn write_rollback_index_not_implemented() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.rollbacks.insert(0, Err(IoError::NotImplemented));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.write_rollback_index(0, 0), Ok(()));
-    }
-
-    #[test]
-    fn read_is_device_unlocked_value_obtained() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.unlock_state = Ok(true);
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-
-        assert_eq!(avb_ops.read_is_device_unlocked(), Ok(true));
-    }
-
-    #[test]
-    fn read_is_device_unlocked_error_handled() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.unlock_state = Err(IoError::Io);
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.read_is_device_unlocked(), Err(IoError::Io));
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn read_is_device_unlocked_not_implemented() {
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.unlock_state = Err(IoError::NotImplemented);
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.read_is_device_unlocked(), Ok(true));
-    }
-
-    #[test]
-    fn read_persistent_value_success() {
-        const EXPECTED_NAME: &CStr = c"test";
-        const EXPECTED_VALUE: &[u8] = b"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Ok(EXPECTED_VALUE));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        let mut buffer = [0u8; EXPECTED_VALUE.len()];
-        assert_eq!(
-            avb_ops.read_persistent_value(EXPECTED_NAME, &mut buffer),
-            Ok(EXPECTED_VALUE.len())
-        );
-        assert_eq!(buffer, EXPECTED_VALUE);
-    }
-
-    #[test]
-    fn read_persistent_value_error() {
-        const EXPECTED_NAME: &CStr = c"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::Io));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        let mut buffer = [0u8; 4];
-        assert_eq!(avb_ops.read_persistent_value(EXPECTED_NAME, &mut buffer), Err(IoError::Io));
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn read_persistent_value_not_implemented() {
-        const EXPECTED_NAME: &CStr = c"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops
-            .avb_ops
-            .add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::NotImplemented));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        let mut buffer = [0u8; 0];
-        assert_eq!(avb_ops.read_persistent_value(EXPECTED_NAME, &mut buffer), Ok(0));
-    }
-
-    #[test]
-    fn write_persistent_value_success() {
-        const EXPECTED_NAME: &CStr = c"test";
-        const EXPECTED_VALUE: &[u8] = b"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.write_persistent_value(EXPECTED_NAME, EXPECTED_VALUE), Ok(()));
-
-        assert_eq!(
-            gbl_ops.avb_ops.persistent_values.get(EXPECTED_NAME.to_str().unwrap()),
-            Some(Ok(EXPECTED_VALUE.to_vec())).as_ref()
-        );
-    }
-
-    #[test]
-    fn write_persistent_value_error() {
-        const EXPECTED_NAME: &CStr = c"test";
-        const EXPECTED_VALUE: &[u8] = b"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::Io));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.write_persistent_value(EXPECTED_NAME, EXPECTED_VALUE), Err(IoError::Io));
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn write_persistent_value_not_implemented() {
-        const EXPECTED_NAME: &CStr = c"test";
-        const EXPECTED_VALUE: &[u8] = b"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops
-            .avb_ops
-            .add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::NotImplemented));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.write_persistent_value(EXPECTED_NAME, EXPECTED_VALUE), Ok(()));
-    }
-
-    #[test]
-    fn erase_persistent_value_success() {
-        const EXPECTED_NAME: &CStr = c"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Ok(b"test"));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.erase_persistent_value(EXPECTED_NAME), Ok(()));
-
-        assert!(!gbl_ops.avb_ops.persistent_values.contains_key(EXPECTED_NAME.to_str().unwrap()));
-    }
-
-    #[test]
-    fn erase_persistent_value_error() {
-        const EXPECTED_NAME: &CStr = c"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::Io));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.erase_persistent_value(EXPECTED_NAME), Err(IoError::Io));
-    }
-
-    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
-    #[test]
-    fn erase_persistent_value_not_implemented() {
-        const EXPECTED_NAME: &CStr = c"test";
-
-        let mut gbl_ops = FakeGblOps::new(&[]);
-        gbl_ops
-            .avb_ops
-            .add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::NotImplemented));
-
-        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, None, &[], false);
-        assert_eq!(avb_ops.erase_persistent_value(EXPECTED_NAME), Ok(()));
-    }
-}
diff --git a/gbl/libgbl/src/gbl_avb/state.rs b/gbl/libgbl/src/gbl_avb/state.rs
deleted file mode 100644
index eab94ee..0000000
--- a/gbl/libgbl/src/gbl_avb/state.rs
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Gbl AVB state (version, color, etc).
-
-use core::fmt::{Display, Formatter};
-
-/// https://source.android.com/docs/security/features/verifiedboot/boot-flow#communicating-verified-boot-state-to-users
-#[derive(Clone, Copy, PartialEq, Debug)]
-pub enum BootStateColor {
-    /// Success .
-    Green,
-    /// Success but custom key is used.
-    Yellow,
-    /// Device is unlocked.
-    Orange,
-    /// Dm-verity is corrupted.
-    RedEio,
-    /// No valid OS found.
-    Red,
-}
-
-/// To use in bootconfig.
-impl Display for BootStateColor {
-    fn fmt(&self, f: &mut Formatter) -> core::fmt::Result {
-        f.write_str(match self {
-            BootStateColor::Green => "green",
-            BootStateColor::Yellow => "yellow",
-            BootStateColor::Orange => "orange",
-            BootStateColor::RedEio => "red_eio",
-            BootStateColor::Red => "red",
-        })
-    }
-}
-
-/// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
-#[derive(Clone, Copy, Debug, PartialEq)]
-pub enum KeyValidationStatus {
-    /// Vbmeta key is matched with a production key.
-    Valid,
-    /// Vbmeta key is matched with a custom key.
-    ValidCustomKey,
-    /// Vbmeta key isn't matched.
-    Invalid,
-}
diff --git a/gbl/libgbl/src/image_buffer.rs b/gbl/libgbl/src/image_buffer.rs
deleted file mode 100644
index aee6537..0000000
--- a/gbl/libgbl/src/image_buffer.rs
+++ /dev/null
@@ -1,301 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! ImageBuffer is helper to store uninitialized memory buffer. And work with it allowing to read
-//! into the buffer and retrieve initialized part.
-//!
-//! Similar to [ReadBuf](https://docs.rs/tokio/latest/tokio/io/struct.ReadBuf.html) but works in
-//! `no_std`.
-
-use core::mem::MaybeUninit;
-use liberror::{Error, Result};
-
-/// Wrapper class for buffer received with [get_buffer] function.
-///
-/// Helps to keep track of allocated/init memory and avoid getting same buffer more than once.
-#[derive(Debug)]
-pub struct ImageBuffer<'a> {
-    buffer: Option<&'a mut [MaybeUninit<u8>]>,
-    // number of initialized and filled bytes.
-    used_bytes: usize,
-}
-
-// Unstable MaybeUninit API
-// feature = "maybe_uninit_slice", issue = "63569"
-
-// Assuming all the elements are initialized, get a mutable slice to them.
-//
-// # Safety
-//
-// It is up to the caller to guarantee that the `MaybeUninit<T>` elements
-// really are in an initialized state.
-// Calling this when the content is not yet fully initialized causes undefined behavior.
-#[inline(always)]
-unsafe fn slice_assume_init_mut<T>(slice: &mut [MaybeUninit<T>]) -> &mut [T] {
-    // SAFETY: Caller must make sure provided data is initialized.
-    unsafe { &mut *(slice as *mut [MaybeUninit<T>] as *mut [T]) }
-}
-
-// Assuming all the elements are initialized, get a slice of them.
-//
-// # Safety
-//
-// It is up to the caller to guarantee that the `MaybeUninit<T>` elements
-// really are in an initialized state.
-// Calling this when the content is not yet fully initialized causes undefined behavior.
-#[inline(always)]
-unsafe fn slice_assume_init_ref<T>(slice: &[MaybeUninit<T>]) -> &[T] {
-    // SAFETY: Caller must make sure provided data is initialized.
-    unsafe { &*(slice as *const [MaybeUninit<T>] as *const [T]) }
-}
-
-impl ImageBuffer<'_> {
-    /// Create new ImageBuffer from buffer and used_bytes
-    pub fn new(buffer: &mut [MaybeUninit<u8>]) -> ImageBuffer {
-        ImageBuffer { buffer: Some(buffer), used_bytes: 0 }
-    }
-
-    /// Total buffer capacity.
-    pub fn capacity(&self) -> usize {
-        self.buffer.as_ref().unwrap().len()
-    }
-
-    /// Increase used part of the buffer by `len`
-    ///
-    /// Return:
-    /// Error() - if current used_bytes + len > capacity, or causes arithmetic overflow.
-    /// Ok(()) - on success
-    ///
-    /// SAFETY:
-    /// It is up to the user to guarantee that `len` bytes for tail was initialized and filled.
-    pub unsafe fn advance_used(&mut self, len: usize) -> Result<()> {
-        let Some(new_len) = self.used_bytes.checked_add(len) else {
-            return Err(Error::Other(Some("Used bytes overflow")));
-        };
-        if new_len > self.capacity() {
-            return Err(Error::BufferTooSmall(Some(new_len)));
-        }
-        self.used_bytes = new_len;
-        Ok(())
-    }
-
-    /// Return used and tail parts of the buffer
-    pub fn get_split(&self) -> (&[u8], &[MaybeUninit<u8>]) {
-        let (used, tail) = self.buffer.as_ref().unwrap().split_at(self.used_bytes);
-        // SAFETY:
-        //
-        // ImageBuffer user guarantees that changing used elements means they were initialized.
-        // And object assumes initialized only for slice [..used_bytes]
-        let initialized = unsafe { slice_assume_init_ref(used) };
-        (initialized, tail)
-    }
-
-    /// Return used and tail parts of the buffer
-    pub fn get_split_mut(&mut self) -> (&mut [u8], &mut [MaybeUninit<u8>]) {
-        let (used, tail) = self.buffer.as_mut().unwrap().split_at_mut(self.used_bytes);
-        // SAFETY:
-        //
-        // ImageBuffer user guaranties that changing used elements means they were initialized.
-        // And object assumes initialized only for slice [..used_bytes]
-        let initialized = unsafe { slice_assume_init_mut(used) };
-        (initialized, tail)
-    }
-
-    /// Slice of the buffer that is used
-    pub fn used(&self) -> &[u8] {
-        let (used, _) = self.get_split();
-        used
-    }
-
-    /// Slice of the buffer that is used
-    pub fn used_mut(&mut self) -> &mut [u8] {
-        let (used, _) = self.get_split_mut();
-        used
-    }
-
-    /// Return part of the buffer that is not used
-    pub fn tail(&mut self) -> &mut [MaybeUninit<u8>] {
-        let (_, tail) = self.get_split_mut();
-        tail
-    }
-}
-
-impl AsRef<[MaybeUninit<u8>]> for ImageBuffer<'_> {
-    fn as_ref(&self) -> &[MaybeUninit<u8>] {
-        self.buffer.as_ref().unwrap()
-    }
-}
-
-impl AsMut<[MaybeUninit<u8>]> for ImageBuffer<'_> {
-    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
-        self.buffer.as_mut().unwrap()
-    }
-}
-
-impl PartialEq for ImageBuffer<'_> {
-    fn eq(&self, other: &Self) -> bool {
-        self.used() == other.used()
-    }
-}
-
-#[cfg(test)]
-/// Helper to create ImageBuffers from Vec<u8>
-pub struct ImageBufferVec {
-    buf: Vec<u8>,
-}
-
-#[cfg(test)]
-impl ImageBufferVec {
-    pub fn new(buf: Vec<u8>) -> Self {
-        Self { buf }
-    }
-
-    pub fn get(&mut self) -> ImageBuffer {
-        ImageBuffer::new(Self::slice_assume_not_init_mut(self.buf.as_mut_slice()))
-    }
-
-    fn slice_assume_not_init_mut<T>(slice: &mut [T]) -> &mut [MaybeUninit<T>] {
-        // SAFETY: similar to safety notes for `slice_get_ref`, but we have a
-        // mutable reference which is also guaranteed to be valid for writes.
-        unsafe { &mut *(slice as *mut [T] as *mut [MaybeUninit<T>]) }
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_image_buffer_capacity() {
-        assert_eq!(ImageBufferVec::new(vec![0u8; 0]).get().capacity(), 0);
-        assert_eq!(ImageBufferVec::new(vec![0u8; 0]).get().capacity(), 0);
-        assert_eq!(ImageBufferVec::new(vec![0u8; 1]).get().capacity(), 1);
-        assert_eq!(ImageBufferVec::new(vec![0u8; 100]).get().capacity(), 100);
-        assert_eq!(
-            ImageBufferVec::new(vec![0u8; 128 * 1024 * 1024]).get().capacity(),
-            128 * 1024 * 1024
-        );
-    }
-
-    #[test]
-    fn test_image_buffer_used() {
-        let mut img_buf_vec = ImageBufferVec::new(vec![0u8; 100]);
-        let mut img_buf = img_buf_vec.get();
-        assert_eq!(img_buf.used().len(), 0);
-        assert_eq!(img_buf.used_mut().len(), 0);
-        // SAFETY:
-        // All data in img_buf is initialized since it was created from vec
-        unsafe { img_buf.advance_used(1).unwrap() };
-        assert_eq!(img_buf.used().len(), 1);
-        assert_eq!(img_buf.used_mut().len(), 1);
-        // SAFETY:
-        // All data in img_buf is initialized since it was created from vec
-        unsafe { img_buf.advance_used(3).unwrap() };
-        assert_eq!(img_buf.used().len(), 4);
-        assert_eq!(img_buf.used_mut().len(), 4);
-        assert_eq!(
-            // SAFETY:
-            // All data in img_buf is initialized since it was created from vec
-            unsafe { img_buf.advance_used(1024) },
-            Err(Error::BufferTooSmall(Some(1028)))
-        );
-        assert_eq!(img_buf.used().len(), 4);
-        assert_eq!(img_buf.used_mut().len(), 4);
-    }
-
-    #[test]
-    fn test_image_buffer_get_split() {
-        let mut img_buf_vec = ImageBufferVec::new(vec![0u8, 1, 2, 3]);
-        let mut img_buf = img_buf_vec.get();
-
-        assert_eq!(img_buf.used(), [].as_slice());
-        assert_eq!(img_buf.used_mut(), [].as_mut_slice());
-        assert_eq!(img_buf.tail().len(), 4);
-        let (used, tail) = img_buf.get_split();
-        assert_eq!(used, [].as_slice());
-        assert_eq!(tail.len(), 4);
-
-        let (used, tail) = img_buf.get_split_mut();
-        assert_eq!(used, [].as_mut_slice());
-        assert_eq!(tail.len(), 4);
-
-        // SAFETY:
-        // All data in img_buf is initialized since it was created from vec
-        unsafe { img_buf.advance_used(2).unwrap() };
-        assert_eq!(img_buf.used(), [0, 1].as_slice());
-        assert_eq!(img_buf.used_mut(), [0, 1].as_mut_slice());
-        assert_eq!(img_buf.tail().len(), 2);
-        let (used, tail) = img_buf.get_split();
-        assert_eq!(used, [0, 1].as_slice());
-        assert_eq!(tail.len(), 2);
-        let (used, tail) = img_buf.get_split_mut();
-        assert_eq!(used, [0, 1].as_mut_slice());
-        assert_eq!(tail.len(), 2);
-
-        // SAFETY:
-        // All data in img_buf is initialized since it was created from vec
-        unsafe { img_buf.advance_used(2).unwrap() };
-        assert_eq!(img_buf.used(), [0, 1, 2, 3].as_slice());
-        assert_eq!(img_buf.used_mut(), [0, 1, 2, 3].as_mut_slice());
-        assert_eq!(img_buf.tail().len(), 0);
-        let (used, tail) = img_buf.get_split();
-        assert_eq!(used, [0, 1, 2, 3].as_slice());
-        assert_eq!(tail.len(), 0);
-        let (used, tail) = img_buf.get_split_mut();
-        assert_eq!(used, [0, 1, 2, 3].as_mut_slice());
-        assert_eq!(tail.len(), 0);
-    }
-
-    #[test]
-    fn test_image_buffer_eq_not_init() {
-        assert_eq!(
-            ImageBufferVec::new(vec![0u8, 1, 2]).get(),
-            ImageBufferVec::new(vec![0u8, 1, 2]).get()
-        );
-    }
-
-    #[test]
-    fn test_image_buffer_eq_init_same() {
-        let mut v1 = ImageBufferVec::new(vec![0u8, 1, 2]);
-        let mut v2 = ImageBufferVec::new(vec![0u8, 1, 2]);
-        let mut image_buffer_1 = v1.get();
-        let mut image_buffer_2 = v2.get();
-
-        // SAFETY:
-        // Buffers initialised on creation.
-        unsafe {
-            image_buffer_1.advance_used(3).unwrap();
-            image_buffer_2.advance_used(3).unwrap();
-        }
-
-        assert_eq!(image_buffer_1, image_buffer_2);
-    }
-
-    #[test]
-    fn test_image_buffer_eq_diff_capacity() {
-        let mut v1 = ImageBufferVec::new(vec![0u8, 1, 2]);
-        let mut v2 = ImageBufferVec::new(vec![0u8, 1, 2, 3]);
-        let mut image_buffer_1 = v1.get();
-        let mut image_buffer_2 = v2.get();
-
-        // SAFETY:
-        // Buffers initialised on creation.
-        unsafe {
-            image_buffer_1.advance_used(2).unwrap();
-            image_buffer_2.advance_used(2).unwrap();
-        }
-
-        assert_eq!(image_buffer_1, image_buffer_2);
-    }
-}
diff --git a/gbl/libgbl/src/lib.rs b/gbl/libgbl/src/lib.rs
deleted file mode 100644
index 6637d3e..0000000
--- a/gbl/libgbl/src/lib.rs
+++ /dev/null
@@ -1,375 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! # Generic Boot Loader (gbl) Library
-//!
-//! TODO: b/312610098 - add documentation.
-//!
-//! The intended users of this library are firmware, bootloader, and bring-up teams at OEMs and SOC
-//! Vendors
-//!
-//! This library is `no_std` as it is intended for use in bootloaders that typically will not
-//! support the Rust standard library. However, it does require `alloc` with a global allocator,
-//! currently used for:
-//! * libavb
-//! * kernel decompression
-
-#![cfg_attr(not(any(test, android_dylib)), no_std)]
-// TODO: b/312610985 - return warning for unused partitions
-#![allow(async_fn_in_trait)]
-// Needed for MaybeUninit::fill() experimental API
-#![feature(maybe_uninit_fill)]
-extern crate avb;
-extern crate core;
-extern crate gbl_storage;
-extern crate spin;
-extern crate zbi;
-
-use avb::{HashtreeErrorMode, SlotVerifyData, SlotVerifyFlags};
-use core::ffi::CStr;
-use core::marker::PhantomData;
-
-pub mod android_boot;
-pub mod boot_mode;
-pub mod boot_reason;
-pub mod constants;
-pub mod decompress;
-pub mod device_tree;
-pub mod error;
-pub mod fastboot;
-pub mod fuchsia_boot;
-pub mod gbl_avb;
-pub mod ops;
-pub mod partition;
-
-/// The 'slots' module, containing types and traits for
-/// querying and modifying slotted boot behavior.
-pub mod slots;
-
-mod image_buffer;
-
-use slots::{BootTarget, BootToken, Cursor, SuffixBytes};
-
-pub use avb::Descriptor;
-pub use boot_mode::BootMode;
-pub use boot_reason::KnownBootReason;
-pub use error::{IntegrationError, Result};
-use liberror::Error;
-pub use ops::{GblOps, Os};
-
-/// GBL object that provides implementation of helpers for boot process.
-pub struct Gbl<'a, 'd, G>
-where
-    G: GblOps<'a, 'd>,
-{
-    ops: &'a mut G,
-    boot_token: Option<BootToken>,
-    _get_image_buffer_lifetime: PhantomData<&'d ()>,
-}
-
-// TODO(b/312610985): Investigate whether to deprecate this and remove this allow.
-#[allow(unused_variables)]
-impl<'a, 'f, G> Gbl<'a, 'f, G>
-where
-    G: GblOps<'a, 'f>,
-{
-    /// Returns a new [Gbl] object.
-    ///
-    /// # Arguments
-    /// * `ops` - the [GblOps] callbacks to use
-    pub fn new(ops: &'a mut G) -> Self {
-        Self { ops, boot_token: Some(BootToken(())), _get_image_buffer_lifetime: PhantomData }
-    }
-
-    /// Verify + Load Image Into memory
-    ///
-    /// Load from disk, validate with AVB
-    ///
-    /// # Arguments
-    /// * `avb_ops` - implementation for `avb::Ops`
-    /// * `partitions_to_verify` - names of all the partitions to verify with libavb.
-    /// * `slot_verify_flags` - AVB slot verification flags
-    /// * `boot_target` - [Optional] Boot Target
-    ///
-    /// # Returns
-    /// * `Ok(SlotVerifyData)` - avb verification data
-    /// * `Err(Error)` - on failure
-    pub fn load_and_verify_image<'b>(
-        &mut self,
-        avb_ops: &mut impl avb::Ops<'b>,
-        partitions_to_verify: &[&CStr],
-        slot_verify_flags: SlotVerifyFlags,
-        boot_target: Option<BootTarget>,
-    ) -> Result<SlotVerifyData<'b>> {
-        let bytes: SuffixBytes =
-            if let Some(tgt) = boot_target { tgt.suffix().into() } else { Default::default() };
-
-        let avb_suffix = CStr::from_bytes_until_nul(&bytes).map_err(Error::from)?;
-
-        Ok(avb::slot_verify(
-            avb_ops,
-            partitions_to_verify,
-            Some(avb_suffix),
-            slot_verify_flags,
-            HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_EIO,
-        )
-        .map_err(|v| v.without_verify_data())?)
-    }
-
-    /// Load Slot Manager Interface
-    ///
-    /// The default implementation loads from the `durable_boot` partition
-    /// and writes changes back on the destruction of the cursor.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Cursor)` - Cursor object that manages a Manager
-    /// * `Err(Error)` - on failure
-    pub fn load_slot_interface(
-        &'a mut self,
-        persist: &'a mut dyn FnMut(&mut [u8]) -> core::result::Result<(), Error>,
-    ) -> Result<Cursor<'a>> {
-        let boot_token = self.boot_token.take().ok_or(Error::OperationProhibited)?;
-        self.ops.load_slot_interface(persist, boot_token)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    extern crate avb_sysdeps;
-    extern crate avb_test;
-    extern crate libc_deps_posix;
-
-    use super::*;
-    use crate::ops::test::FakeGblOps;
-    use avb::{CertPermanentAttributes, SlotVerifyError};
-    use avb_test::{FakeVbmetaKey, TestOps};
-    use libutils::aligned_offset;
-    use std::{
-        fs,
-        ops::{Deref, DerefMut},
-        path::Path,
-    };
-    use zerocopy::FromBytes;
-
-    // Helper object for allocating aligned buffer.
-    pub(crate) struct AlignedBuffer {
-        buffer: Vec<u8>,
-        size: usize,
-        alignment: usize,
-    }
-
-    impl AlignedBuffer {
-        /// Allocates a buffer.
-        pub(crate) fn new(size: usize, alignment: usize) -> Self {
-            Self { buffer: vec![0u8; alignment + size - 1], size, alignment }
-        }
-
-        /// Allocates a buffer and initializes with data.
-        pub(crate) fn new_with_data(data: &[u8], alignment: usize) -> Self {
-            let mut res = Self::new(data.len(), alignment);
-            res.clone_from_slice(data);
-            res
-        }
-    }
-
-    impl Deref for AlignedBuffer {
-        type Target = [u8];
-
-        fn deref(&self) -> &Self::Target {
-            let off = aligned_offset(&self.buffer, self.alignment).unwrap();
-            &self.buffer[off..][..self.size]
-        }
-    }
-
-    impl DerefMut for AlignedBuffer {
-        fn deref_mut(&mut self) -> &mut Self::Target {
-            let off = aligned_offset(&self.buffer, self.alignment).unwrap();
-            &mut self.buffer[off..][..self.size]
-        }
-    }
-
-    const TEST_ZIRCON_PARTITION_NAME: &str = "zircon_a";
-    const TEST_ZIRCON_PARTITION_NAME_CSTR: &CStr = c"zircon_a";
-    const TEST_ZIRCON_IMAGE_PATH: &str = "zircon_a.zbi";
-    const TEST_ZIRCON_VBMETA_PATH: &str = "zircon_a.vbmeta";
-    const TEST_ZIRCON_VBMETA_CERT_PATH: &str = "zircon_a.vbmeta.cert";
-    const TEST_PUBLIC_KEY_PATH: &str = "testkey_rsa4096_pub.bin";
-    const TEST_PERMANENT_ATTRIBUTES_PATH: &str = "cert_permanent_attributes.bin";
-    const TEST_PERMANENT_ATTRIBUTES_HASH_PATH: &str = "cert_permanent_attributes.hash";
-    const TEST_BAD_PERMANENT_ATTRIBUTES_PATH: &str = "cert_permanent_attributes.bad.bin";
-    const TEST_BAD_PERMANENT_ATTRIBUTES_HASH_PATH: &str = "cert_permanent_attributes.bad.hash";
-    const TEST_VBMETA_ROLLBACK_LOCATION: usize = 0; // Default value, we don't explicitly set this.
-    pub const TEST_CERT_PIK_VERSION: u64 = 42;
-    pub const TEST_CERT_PSK_VERSION: u64 = 42;
-
-    /// Returns the contents of a test data file.
-    ///
-    /// Panicks if the requested file cannot be read.
-    ///
-    /// # Arguments
-    /// * `path`: file path relative to libgbl's `testdata/` directory.
-    fn testdata(path: &str) -> Vec<u8> {
-        let full_path = Path::new("external/gbl/libgbl/testdata").join(path);
-        fs::read(full_path).unwrap()
-    }
-
-    /// Creates and returns a configured avb `TestOps`.
-    ///
-    /// The initial state will verify successfully with:
-    /// * a valid vbmeta image in the `vbmeta` partition, containing a hash descriptor for the
-    ///   `TEST_ZIRCON_PARTITION_NAME` partition
-    /// * an image in the `TEST_ZIRCON_PARTITION_NAME` partition matching the vbmeta hash
-    /// * no preloaded partition data
-    /// * a public key matching the vbmeta image
-    /// * a valid vbmeta rollback index
-    /// * a locked bootloader state
-    ///
-    /// The caller can modify any of this state as needed for their particular test.
-    fn test_avb_ops() -> TestOps<'static> {
-        let mut avb_ops = TestOps::default();
-
-        avb_ops.add_partition(TEST_ZIRCON_PARTITION_NAME, testdata(TEST_ZIRCON_IMAGE_PATH));
-        avb_ops.add_partition("vbmeta", testdata(TEST_ZIRCON_VBMETA_PATH));
-        avb_ops.default_vbmeta_key = Some(FakeVbmetaKey::Avb {
-            public_key: testdata(TEST_PUBLIC_KEY_PATH),
-            public_key_metadata: None,
-        });
-        avb_ops.rollbacks.insert(TEST_VBMETA_ROLLBACK_LOCATION, Ok(0));
-        avb_ops.unlock_state = Ok(false);
-
-        avb_ops
-    }
-
-    /// Similar to `test_avb_ops()`, but with the avb_cert extension enabled.
-    fn test_avb_cert_ops() -> TestOps<'static> {
-        let mut avb_ops = test_avb_ops();
-
-        // Replace vbmeta with the cert-signed version.
-        avb_ops.add_partition("vbmeta", testdata(TEST_ZIRCON_VBMETA_CERT_PATH));
-
-        // Tell `avb_ops` to use cert APIs and to route the default key through cert validation.
-        avb_ops.use_cert = true;
-        avb_ops.default_vbmeta_key = Some(FakeVbmetaKey::Cert);
-
-        // Add the permanent attributes.
-        let perm_attr_bytes = testdata(TEST_PERMANENT_ATTRIBUTES_PATH);
-        let perm_attr_hash = testdata(TEST_PERMANENT_ATTRIBUTES_HASH_PATH);
-        avb_ops.cert_permanent_attributes =
-            Some(CertPermanentAttributes::read_from(&perm_attr_bytes[..]).unwrap());
-        avb_ops.cert_permanent_attributes_hash = Some(perm_attr_hash.try_into().unwrap());
-
-        // Add the rollbacks for the cert keys.
-        avb_ops.rollbacks.insert(avb::CERT_PIK_VERSION_LOCATION, Ok(TEST_CERT_PIK_VERSION));
-        avb_ops.rollbacks.insert(avb::CERT_PSK_VERSION_LOCATION, Ok(TEST_CERT_PSK_VERSION));
-
-        avb_ops
-    }
-
-    #[test]
-    fn test_load_and_verify_image_success() {
-        let mut gbl_ops = FakeGblOps::default();
-        let mut gbl = Gbl::new(&mut gbl_ops);
-        let mut avb_ops = test_avb_ops();
-
-        let res = gbl.load_and_verify_image(
-            &mut avb_ops,
-            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
-            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-            None,
-        );
-        assert!(res.is_ok());
-    }
-
-    #[test]
-    fn test_load_and_verify_image_verification_error() {
-        let mut gbl_ops = FakeGblOps::default();
-        let mut gbl = Gbl::new(&mut gbl_ops);
-        let mut avb_ops = test_avb_ops();
-
-        // Modify the kernel image, it should now fail to validate against the vbmeta image.
-        avb_ops.partitions.get_mut(TEST_ZIRCON_PARTITION_NAME).unwrap().contents.as_mut_vec()[0] ^=
-            0x01;
-
-        let res = gbl.load_and_verify_image(
-            &mut avb_ops,
-            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
-            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-            None,
-        );
-        assert_eq!(
-            res.unwrap_err(),
-            IntegrationError::AvbSlotVerifyError(SlotVerifyError::Verification(None))
-        );
-    }
-
-    #[test]
-    fn test_load_and_verify_image_io_error() {
-        let mut gbl_ops = FakeGblOps::default();
-        let mut gbl = Gbl::new(&mut gbl_ops);
-        let mut avb_ops = test_avb_ops();
-
-        // Erase the fake rollbacks, which will result in an I/O error when attempting to access.
-        avb_ops.rollbacks.clear();
-
-        let res = gbl.load_and_verify_image(
-            &mut avb_ops,
-            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
-            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-            None,
-        );
-        assert_eq!(res.unwrap_err(), IntegrationError::AvbSlotVerifyError(SlotVerifyError::Io));
-    }
-
-    #[test]
-    fn test_load_and_verify_image_with_cert_success() {
-        let mut gbl_ops = FakeGblOps::default();
-        let mut gbl = Gbl::new(&mut gbl_ops);
-        let mut avb_ops = test_avb_cert_ops();
-
-        let res = gbl.load_and_verify_image(
-            &mut avb_ops,
-            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
-            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-            None,
-        );
-        assert!(res.is_ok());
-    }
-
-    #[test]
-    fn test_load_and_verify_image_with_cert_permanent_attribute_mismatch_error() {
-        let mut gbl_ops = FakeGblOps::default();
-        let mut gbl = Gbl::new(&mut gbl_ops);
-        let mut avb_ops = test_avb_cert_ops();
-
-        // Swap in the corrupted permanent attributes, which should cause the vbmeta image to fail
-        // validation due to key mismatch.
-        let perm_attr_bytes = testdata(TEST_BAD_PERMANENT_ATTRIBUTES_PATH);
-        let perm_attr_hash = testdata(TEST_BAD_PERMANENT_ATTRIBUTES_HASH_PATH);
-        avb_ops.cert_permanent_attributes =
-            Some(CertPermanentAttributes::read_from(&perm_attr_bytes[..]).unwrap());
-        avb_ops.cert_permanent_attributes_hash = Some(perm_attr_hash.try_into().unwrap());
-
-        let res = gbl.load_and_verify_image(
-            &mut avb_ops,
-            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
-            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-            None,
-        );
-        assert_eq!(
-            res.unwrap_err(),
-            IntegrationError::AvbSlotVerifyError(SlotVerifyError::PublicKeyRejected(None))
-        );
-    }
-}
diff --git a/gbl/libgbl/src/ops.rs b/gbl/libgbl/src/ops.rs
deleted file mode 100644
index 73aeeee..0000000
--- a/gbl/libgbl/src/ops.rs
+++ /dev/null
@@ -1,1160 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! GblOps trait that defines GBL callbacks.
-
-pub use crate::image_buffer::ImageBuffer;
-use crate::{
-    error::Result as GblResult,
-    fuchsia_boot::GblAbrOps,
-    gbl_avb::state::{BootStateColor, KeyValidationStatus},
-    partition::{check_part_unique, read_unique_partition, write_unique_partition, GblDisk},
-};
-pub use abr::{set_one_shot_bootloader, set_one_shot_recovery, SlotIndex};
-use core::{ffi::CStr, fmt::Write, num::NonZeroUsize, ops::DerefMut, result::Result};
-use gbl_async::block_on;
-use gbl_storage::SliceMaybeUninit;
-use libutils::aligned_subslice;
-
-// Re-exports of types from other dependencies that appear in the APIs of this library.
-pub use avb::{
-    CertPermanentAttributes, IoError as AvbIoError, IoResult as AvbIoResult, SHA256_DIGEST_SIZE,
-};
-pub use gbl_storage::{BlockIo, Disk, Gpt};
-use liberror::Error;
-pub use slots::{Slot, SlotsMetadata};
-pub use zbi::{ZbiContainer, ZBI_ALIGNMENT_USIZE};
-
-use super::device_tree;
-use super::slots;
-
-/// Target Type of OS to boot.
-#[derive(PartialEq, Debug, Copy, Clone)]
-pub enum Os {
-    /// Android
-    Android,
-    /// Fuchsia
-    Fuchsia,
-}
-
-/// Contains reboot reasons for instructing GBL to boot to different modes.
-#[derive(PartialEq, Debug, Copy, Clone)]
-pub enum RebootReason {
-    /// Normal boot.
-    Normal,
-    /// Bootloader Fastboot mode.
-    Bootloader,
-    /// Userspace Fastboot mode.
-    FastbootD,
-    /// Recovery mode.
-    Recovery,
-}
-
-// https://stackoverflow.com/questions/41081240/idiomatic-callbacks-in-rust
-// should we use traits for this? or optional/box FnMut?
-//
-/* TODO: b/312612203 - needed callbacks:
-missing:
-- key management => atx extension in callback =>  atx_ops: ptr::null_mut(), // support optional ATX.
-*/
-/// Trait that defines callbacks that can be provided to Gbl.
-pub trait GblOps<'a, 'd> {
-    /// Gets a console for logging messages.
-    fn console_out(&mut self) -> Option<&mut dyn Write>;
-
-    /// The string to use for console line termination with [gbl_println!].
-    ///
-    /// Defaults to "\n" if not overridden.
-    fn console_newline(&self) -> &'static str {
-        "\n"
-    }
-
-    /// This method can be used to implement platform specific mechanism for deciding whether boot
-    /// should abort and enter Fastboot mode.
-    fn should_stop_in_fastboot(&mut self) -> Result<bool, Error>;
-
-    /// Reboots the system into the last set boot mode.
-    ///
-    /// The method is not expected to return. Errors should be handled internally by the
-    /// implementation. In most cases, implementation should continue to reset even in the presence
-    /// of errors (users can force power cycle anyway). If there are error cases where reboot
-    /// absolutely can't be taken, implementation should hang and notify platform user in its own
-    /// way.
-    fn reboot(&mut self);
-
-    /// Reboots into recovery mode
-    ///
-    /// On success, returns a closure that performs the reboot.
-    fn reboot_recovery(&mut self) -> Result<impl FnOnce() + '_, Error> {
-        if self.expected_os_is_fuchsia()? {
-            // TODO(b/363075013): Checks and prioritizes platform specific `set_boot_reason()`.
-            set_one_shot_recovery(&mut GblAbrOps(self), true)?;
-            return Ok(|| self.reboot());
-        }
-        Err(Error::Unsupported)
-    }
-
-    /// Reboots into bootloader fastboot mode
-    ///
-    /// On success, returns a closure that performs the reboot.
-    fn reboot_bootloader(&mut self) -> Result<impl FnOnce() + '_, Error> {
-        if self.expected_os_is_fuchsia()? {
-            // TODO(b/363075013): Checks and prioritizes platform specific `set_boot_reason()`.
-            set_one_shot_bootloader(&mut GblAbrOps(self), true)?;
-            return Ok(|| self.reboot());
-        }
-        Err(Error::Unsupported)
-    }
-
-    /// Returns the list of disk devices on this platform.
-    ///
-    /// Notes that the return slice doesn't capture the life time of `&self`, meaning that the slice
-    /// reference must be producible without borrowing `Self`. This is intended and necessary to
-    /// make disk IO and the rest of GblOps methods independent and parallelizable, which is
-    /// required for features such as parallell fastboot flash, download and other commands. For
-    /// implementation, this typically means that the `GblOps` object should hold a reference of the
-    /// array instead of owning it.
-    fn disks(
-        &self,
-    ) -> &'a [GblDisk<
-        Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
-        Gpt<impl DerefMut<Target = [u8]> + 'a>,
-    >];
-
-    /// Reads data from a partition.
-    async fn read_from_partition(
-        &mut self,
-        part: &str,
-        off: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<(), Error> {
-        read_unique_partition(self.disks(), part, off, out).await
-    }
-
-    /// Reads data from a partition synchronously.
-    fn read_from_partition_sync(
-        &mut self,
-        part: &str,
-        off: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<(), Error> {
-        block_on(self.read_from_partition(part, off, out))
-    }
-
-    /// Writes data to a partition.
-    async fn write_to_partition(
-        &mut self,
-        part: &str,
-        off: u64,
-        data: &mut [u8],
-    ) -> Result<(), Error> {
-        write_unique_partition(self.disks(), part, off, data).await
-    }
-
-    /// Writes data to a partition synchronously.
-    fn write_to_partition_sync(
-        &mut self,
-        part: &str,
-        off: u64,
-        data: &mut [u8],
-    ) -> Result<(), Error> {
-        block_on(self.write_to_partition(part, off, data))
-    }
-
-    /// Returns the size of a partiiton. Returns Ok(None) if partition doesn't exist.
-    fn partition_size(&mut self, part: &str) -> Result<Option<u64>, Error> {
-        match check_part_unique(self.disks(), part) {
-            Ok((_, p)) => Ok(Some(p.size()?)),
-            Err(Error::NotFound) => Ok(None),
-            Err(e) => Err(e),
-        }
-    }
-
-    /// Returns which OS to load, or `None` to try to auto-detect based on disk layout & contents.
-    fn expected_os(&mut self) -> Result<Option<Os>, Error>;
-
-    /// Returns if the expected_os is fuchsia
-    fn expected_os_is_fuchsia(&mut self) -> Result<bool, Error> {
-        // TODO(b/374776896): Implement auto detection.
-        Ok(self.expected_os()?.map(|v| v == Os::Fuchsia).unwrap_or(false))
-    }
-
-    /// Adds device specific ZBI items to the given `container`
-    fn zircon_add_device_zbi_items(
-        &mut self,
-        container: &mut ZbiContainer<&mut [u8]>,
-    ) -> Result<(), Error>;
-
-    /// Gets a buffer for staging bootloader file from fastboot.
-    ///
-    /// Fuchsia uses bootloader file for staging SSH key in development flow.
-    ///
-    /// Returns `None` if the platform does not intend to support it.
-    fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]>;
-
-    /// Gets the aligned part of buffer returned by `get_zbi_bootloader_files_buffer()` according to
-    /// ZBI alignment requirement.
-    fn get_zbi_bootloader_files_buffer_aligned(&mut self) -> Option<&mut [u8]> {
-        aligned_subslice(self.get_zbi_bootloader_files_buffer()?, ZBI_ALIGNMENT_USIZE).ok()
-    }
-
-    // TODO(b/334962570): figure out how to plumb ops-provided hash implementations into
-    // libavb. The tricky part is that libavb hashing APIs are global with no way to directly
-    // correlate the implementation to a particular [GblOps] object, so we'll probably have to
-    // create a [Context] ahead of time and store it globally for the hashing APIs to access.
-    // However this would mean that [Context] must be a standalone object and cannot hold a
-    // reference to [GblOps], which may restrict implementations.
-    // fn new_digest(&self) -> Option<Self::Context>;
-
-    /// Load and initialize a slot manager and return a cursor over the manager on success.
-    ///
-    /// # Args
-    ///
-    /// * `persist`: A user provided closure for persisting a given slot metadata bytes to storage.
-    /// * `boot_token`: A [slots::BootToken].
-    fn load_slot_interface<'b>(
-        &'b mut self,
-        persist: &'b mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
-        boot_token: slots::BootToken,
-    ) -> GblResult<slots::Cursor<'b>>;
-
-    // The following is a selective subset of the interfaces in `avb::Ops` and `avb::CertOps` needed
-    // by GBL's usage of AVB. The rest of the APIs are either not relevant to or are implemented and
-    // managed by GBL APIs.
-
-    /// Returns if device is in an unlocked state.
-    ///
-    /// The interface has the same requirement as `avb::Ops::read_is_device_unlocked`.
-    fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool>;
-
-    /// Reads the AVB rollback index at the given location
-    ///
-    /// The interface has the same requirement as `avb::Ops::read_rollback_index`.
-    fn avb_read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64>;
-
-    /// Writes the AVB rollback index at the given location.
-    ///
-    /// The interface has the same requirement as `avb::Ops::write_rollback_index`.
-    fn avb_write_rollback_index(
-        &mut self,
-        rollback_index_location: usize,
-        index: u64,
-    ) -> AvbIoResult<()>;
-
-    /// Reads the AVB persistent value for the given name.
-    ///
-    /// The interface has the same requirement as `avb::Ops::read_persistent_value`.
-    fn avb_read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize>;
-
-    /// Writes the AVB persistent value for the given name.
-    ///
-    /// The interface has the same requirement as `avb::Ops::write_persistent_value`.
-    fn avb_write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()>;
-
-    /// Erases the AVB persistent value for the given name.
-    ///
-    /// The interface has the same requirement as `avb::Ops::erase_persistent_value`.
-    fn avb_erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()>;
-
-    /// Validate public key used to execute AVB.
-    ///
-    /// Used by `avb::CertOps::read_permanent_attributes_hash` so have similar requirements.
-    fn avb_validate_vbmeta_public_key(
-        &self,
-        public_key: &[u8],
-        public_key_metadata: Option<&[u8]>,
-    ) -> AvbIoResult<KeyValidationStatus>;
-
-    /// Reads AVB certificate extension permanent attributes.
-    ///
-    /// The interface has the same requirement as `avb::CertOps::read_permanent_attributes`.
-    fn avb_cert_read_permanent_attributes(
-        &mut self,
-        attributes: &mut CertPermanentAttributes,
-    ) -> AvbIoResult<()>;
-
-    /// Reads AVB certificate extension permanent attributes hash.
-    ///
-    /// The interface has the same requirement as `avb::CertOps::read_permanent_attributes_hash`.
-    fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]>;
-
-    /// Handle AVB result.
-    ///
-    /// Set device state (rot / version binding), show UI, etc.
-    fn avb_handle_verification_result(
-        &mut self,
-        color: BootStateColor,
-        digest: Option<&CStr>,
-        boot_os_version: Option<&[u8]>,
-        boot_security_patch: Option<&[u8]>,
-        system_os_version: Option<&[u8]>,
-        system_security_patch: Option<&[u8]>,
-        vendor_os_version: Option<&[u8]>,
-        vendor_security_patch: Option<&[u8]>,
-    ) -> AvbIoResult<()>;
-
-    /// Get buffer for specific image of requested size.
-    fn get_image_buffer(
-        &mut self,
-        image_name: &str,
-        size: NonZeroUsize,
-    ) -> GblResult<ImageBuffer<'d>>;
-
-    /// Returns the custom device tree to use, if any.
-    ///
-    /// If this returns a device tree, it will be used instead of any on-disk contents. This is
-    /// currently needed for Cuttlefish, but should not be used in production devices because this
-    /// data cannot be verified with libavb.
-    fn get_custom_device_tree(&mut self) -> Option<&'a [u8]>;
-
-    /// Requests an OS command line to be used alongside the one built by GBL.
-    ///
-    /// The returned command line will be verified and appended on top of the command line
-    /// built by GBL. Refer to the behavior specified for the corresponding UEFI interface:
-    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
-    fn fixup_os_commandline<'c>(
-        &mut self,
-        commandline: &CStr,
-        fixup_buffer: &'c mut [u8],
-    ) -> Result<Option<&'c str>, Error>;
-
-    /// Requests an OS bootconfig to be used alongside the one built by GBL.
-    ///
-    /// The returned bootconfig will be verified and appended on top of the bootconfig
-    /// built by GBL. Refer to the behavior specified for the corresponding UEFI interface:
-    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
-    fn fixup_bootconfig<'c>(
-        &mut self,
-        bootconfig: &[u8],
-        fixup_buffer: &'c mut [u8],
-    ) -> Result<Option<&'c [u8]>, Error>;
-
-    /// Selects from device tree components to build the final one.
-    ///
-    /// Provided components registry must be used to select one device tree (none is not allowed),
-    /// and any number of overlays. Refer to the behavior specified for the corresponding UEFI
-    /// interface:
-    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
-    fn select_device_trees(
-        &mut self,
-        components: &mut device_tree::DeviceTreeComponentsRegistry,
-    ) -> Result<(), Error>;
-
-    /// Provide writtable buffer of the device tree built by GBL.
-    ///
-    /// Modified device tree will be verified and used to boot a device. Refer to the behavior
-    /// specified for the corresponding UEFI interface:
-    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/efi_protocols.md
-    /// https://github.com/U-Boot-EFI/EFI_DT_FIXUP_PROTOCOL
-    fn fixup_device_tree(&mut self, device_tree: &mut [u8]) -> Result<(), Error>;
-
-    /// Gets platform-specific fastboot variable.
-    ///
-    /// # Args
-    ///
-    /// * `name`: Varaiable name.
-    /// * `args`: Additional arguments.
-    /// * `out`: The output buffer for the value of the variable. Must be a ASCII string.
-    ///
-    /// # Returns
-    ///
-    /// * Returns the number of bytes written in `out` on success.
-    fn fastboot_variable<'arg>(
-        &mut self,
-        name: &CStr,
-        args: impl Iterator<Item = &'arg CStr> + Clone,
-        out: &mut [u8],
-    ) -> Result<usize, Error>;
-
-    /// Iterates all fastboot variables, arguments and values.
-    ///
-    /// # Args
-    ///
-    /// * `cb`: A closure that takes 1) an array of CStr that contains the variable name followed by
-    ///   any additional arguments and 2) a CStr representing the value.
-    fn fastboot_visit_all_variables(
-        &mut self,
-        cb: impl FnMut(&[&CStr], &CStr),
-    ) -> Result<(), Error>;
-
-    /// Returns a [SlotsMetadata] for the platform.
-    fn slots_metadata(&mut self) -> Result<SlotsMetadata, Error>;
-
-    /// Gets the currently booted bootloader slot.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok(Some(slot index)) if bootloader is slotted.
-    /// * Returns Ok(Errorr::Unsupported) if bootloader is not slotted.
-    /// * Returns Err() on error.
-    fn get_current_slot(&mut self) -> Result<Slot, Error>;
-
-    /// Gets the slot for the next A/B decision.
-    ///
-    /// # Args
-    ///
-    /// * `mark_boot_attempt`: Passes true if the caller attempts to boot the returned slot and
-    ///   would like implementation to perform necessary update to the state of slot such as retry
-    ///   counter. Passes false if the caller only wants to query the slot decision and not cause
-    ///   any state change.
-    fn get_next_slot(&mut self, _mark_boot_attempt: bool) -> Result<Slot, Error>;
-
-    /// Sets the active slot for the next A/B decision.
-    ///
-    /// # Args
-    ///
-    /// * `slot`: The numeric index of the slot.
-    fn set_active_slot(&mut self, _slot: u8) -> Result<(), Error>;
-
-    /// Sets the reboot reason for the next reboot.
-    fn set_reboot_reason(&mut self, _reason: RebootReason) -> Result<(), Error>;
-
-    /// Gets the reboot reason for this boot.
-    fn get_reboot_reason(&mut self) -> Result<RebootReason, Error>;
-}
-
-/// Prints with `GblOps::console_out()`.
-#[macro_export]
-macro_rules! gbl_print {
-    ( $ops:expr, $( $x:expr ),* $(,)? ) => {
-        {
-            match $ops.console_out() {
-                Some(v) => write!(v, $($x,)*).unwrap(),
-                _ => {}
-            }
-        }
-    };
-}
-
-/// Prints the given text plus a newline termination with `GblOps::console_out()`.
-#[macro_export]
-macro_rules! gbl_println {
-    ( $ops:expr, $( $x:expr ),* $(,)? ) => {
-        {
-            let newline = $ops.console_newline();
-            gbl_print!($ops, $($x,)*);
-            gbl_print!($ops, "{}", newline);
-        }
-    };
-}
-
-/// Inherits everything from `ops` but override a few such as read boot_a from
-/// bootimg_buffer, avb_write_rollback_index(), slot operation etc
-pub(crate) struct RambootOps<'a, T> {
-    pub(crate) ops: &'a mut T,
-    pub(crate) preloaded_partitions: &'a [(&'a str, &'a [u8])],
-}
-
-impl<'a, 'd, T: GblOps<'a, 'd>> GblOps<'a, 'd> for RambootOps<'_, T> {
-    fn console_out(&mut self) -> Option<&mut dyn Write> {
-        self.ops.console_out()
-    }
-
-    fn should_stop_in_fastboot(&mut self) -> Result<bool, Error> {
-        self.ops.should_stop_in_fastboot()
-    }
-
-    fn reboot(&mut self) {
-        self.ops.reboot()
-    }
-
-    fn disks(
-        &self,
-    ) -> &'a [GblDisk<
-        Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
-        Gpt<impl DerefMut<Target = [u8]> + 'a>,
-    >] {
-        self.ops.disks()
-    }
-
-    fn expected_os(&mut self) -> Result<Option<Os>, Error> {
-        self.ops.expected_os()
-    }
-
-    fn zircon_add_device_zbi_items(
-        &mut self,
-        container: &mut ZbiContainer<&mut [u8]>,
-    ) -> Result<(), Error> {
-        self.ops.zircon_add_device_zbi_items(container)
-    }
-
-    fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
-        self.ops.get_zbi_bootloader_files_buffer()
-    }
-
-    fn load_slot_interface<'c>(
-        &'c mut self,
-        _fnmut: &'c mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
-        _boot_token: crate::BootToken,
-    ) -> GblResult<slots::Cursor<'c>> {
-        self.ops.load_slot_interface(_fnmut, _boot_token)
-    }
-
-    fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-        self.ops.avb_read_is_device_unlocked()
-    }
-
-    fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64> {
-        self.ops.avb_read_rollback_index(_rollback_index_location)
-    }
-
-    fn avb_write_rollback_index(&mut self, _: usize, _: u64) -> AvbIoResult<()> {
-        // We don't want to persist AVB related data such as updating antirollback indices.
-        Ok(())
-    }
-
-    fn avb_read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize> {
-        self.ops.avb_read_persistent_value(name, value)
-    }
-
-    fn avb_write_persistent_value(&mut self, _: &CStr, _: &[u8]) -> AvbIoResult<()> {
-        // We don't want to persist AVB related data such as updating current VBH.
-        Ok(())
-    }
-
-    fn avb_erase_persistent_value(&mut self, _: &CStr) -> AvbIoResult<()> {
-        // We don't want to persist AVB related data such as updating current VBH.
-        Ok(())
-    }
-
-    fn avb_cert_read_permanent_attributes(
-        &mut self,
-        attributes: &mut CertPermanentAttributes,
-    ) -> AvbIoResult<()> {
-        self.ops.avb_cert_read_permanent_attributes(attributes)
-    }
-
-    fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
-        self.ops.avb_cert_read_permanent_attributes_hash()
-    }
-
-    fn get_image_buffer(
-        &mut self,
-        image_name: &str,
-        size: NonZeroUsize,
-    ) -> GblResult<ImageBuffer<'d>> {
-        self.ops.get_image_buffer(image_name, size)
-    }
-
-    fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
-        self.ops.get_custom_device_tree()
-    }
-
-    fn fixup_os_commandline<'c>(
-        &mut self,
-        commandline: &CStr,
-        fixup_buffer: &'c mut [u8],
-    ) -> Result<Option<&'c str>, Error> {
-        self.ops.fixup_os_commandline(commandline, fixup_buffer)
-    }
-
-    fn fixup_bootconfig<'c>(
-        &mut self,
-        bootconfig: &[u8],
-        fixup_buffer: &'c mut [u8],
-    ) -> Result<Option<&'c [u8]>, Error> {
-        self.ops.fixup_bootconfig(bootconfig, fixup_buffer)
-    }
-
-    fn fixup_device_tree(&mut self, device_tree: &mut [u8]) -> Result<(), Error> {
-        self.ops.fixup_device_tree(device_tree)
-    }
-
-    fn select_device_trees(
-        &mut self,
-        components_registry: &mut device_tree::DeviceTreeComponentsRegistry,
-    ) -> Result<(), Error> {
-        self.ops.select_device_trees(components_registry)
-    }
-
-    fn read_from_partition_sync(
-        &mut self,
-        part: &str,
-        off: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<(), Error> {
-        match self.preloaded_partitions.iter().find(|(name, _)| *name == part) {
-            Some((_, data)) => {
-                let buf = data
-                    .get(off.try_into()?..)
-                    .and_then(|v| v.get(..out.len()))
-                    .ok_or(Error::OutOfRange)?;
-                Ok(out.clone_from_slice(buf))
-            }
-            _ => self.ops.read_from_partition_sync(part, off, out),
-        }
-    }
-
-    fn avb_handle_verification_result(
-        &mut self,
-        color: BootStateColor,
-        digest: Option<&CStr>,
-        boot_os_version: Option<&[u8]>,
-        boot_security_patch: Option<&[u8]>,
-        system_os_version: Option<&[u8]>,
-        system_security_patch: Option<&[u8]>,
-        vendor_os_version: Option<&[u8]>,
-        vendor_security_patch: Option<&[u8]>,
-    ) -> AvbIoResult<()> {
-        self.ops.avb_handle_verification_result(
-            color,
-            digest,
-            boot_os_version,
-            boot_security_patch,
-            system_os_version,
-            system_security_patch,
-            vendor_os_version,
-            vendor_security_patch,
-        )
-    }
-
-    fn avb_validate_vbmeta_public_key(
-        &self,
-        public_key: &[u8],
-        public_key_metadata: Option<&[u8]>,
-    ) -> AvbIoResult<KeyValidationStatus> {
-        self.ops.avb_validate_vbmeta_public_key(public_key, public_key_metadata)
-    }
-
-    fn slots_metadata(&mut self) -> Result<SlotsMetadata, Error> {
-        // Ramboot is not suppose to call this interface.
-        unreachable!()
-    }
-
-    fn get_current_slot(&mut self) -> Result<Slot, Error> {
-        // Ramboot is slotless
-        Err(Error::Unsupported)
-    }
-
-    fn get_next_slot(&mut self, _: bool) -> Result<Slot, Error> {
-        // Ramboot is not suppose to call this interface.
-        unreachable!()
-    }
-
-    fn set_active_slot(&mut self, _: u8) -> Result<(), Error> {
-        // Ramboot is not suppose to call this interface.
-        unreachable!()
-    }
-
-    fn set_reboot_reason(&mut self, _: RebootReason) -> Result<(), Error> {
-        // Ramboot is not suppose to call this interface.
-        unreachable!()
-    }
-
-    fn get_reboot_reason(&mut self) -> Result<RebootReason, Error> {
-        // Assumes that ramboot use normal boot mode. But we might consider supporting recovery
-        // if there is a usecase.
-        Ok(RebootReason::Normal)
-    }
-
-    fn fastboot_variable<'arg>(
-        &mut self,
-        _: &CStr,
-        _: impl Iterator<Item = &'arg CStr> + Clone,
-        _: &mut [u8],
-    ) -> Result<usize, Error> {
-        // Ramboot should not need this.
-        unreachable!();
-    }
-
-    fn fastboot_visit_all_variables(
-        &mut self,
-        _: impl FnMut(&[&CStr], &CStr),
-    ) -> Result<(), Error> {
-        // Ramboot should not need this.
-        unreachable!();
-    }
-}
-
-#[cfg(test)]
-pub(crate) mod test {
-    use super::*;
-    use crate::error::IntegrationError;
-    use crate::partition::GblDisk;
-    use abr::{get_and_clear_one_shot_bootloader, get_boot_slot};
-    use avb::{CertOps, Ops};
-    use avb_test::TestOps as AvbTestOps;
-    use core::{
-        fmt::Write,
-        ops::{Deref, DerefMut},
-    };
-    use fdt::Fdt;
-    use gbl_async::block_on;
-    use gbl_storage::{new_gpt_max, Disk, GptMax, RamBlockIo};
-    use libutils::snprintf;
-    use std::{
-        collections::{HashMap, LinkedList},
-        ffi::CString,
-    };
-    use zbi::{ZbiFlags, ZbiType};
-
-    /// Type of [GblDisk] in tests.
-    pub(crate) type TestGblDisk = GblDisk<Disk<RamBlockIo<Vec<u8>>, Vec<u8>>, GptMax>;
-
-    /// Backing storage for [FakeGblOps].
-    ///
-    /// This needs to be a separate object because [GblOps] has designed its lifetimes to borrow
-    /// the [GblDisk] objects rather than own it, so that they can outlive the ops
-    /// object when necessary.
-    ///
-    /// # Example usage
-    /// ```
-    /// let storage = FakeGblOpsStorage::default();
-    /// storage.add_gpt_device(&gpt_disk_contents);
-    /// storage.add_raw_device(c"raw", &raw_disk_contents);
-    ///
-    /// let fake_ops = FakeGblOps(&storage);
-    /// ```
-    #[derive(Default)]
-    pub(crate) struct FakeGblOpsStorage(pub Vec<TestGblDisk>);
-
-    impl FakeGblOpsStorage {
-        /// Adds a GPT disk.
-        pub(crate) fn add_gpt_device(&mut self, data: impl AsRef<[u8]>) {
-            // For test GPT images, all block sizes are 512.
-            self.0.push(TestGblDisk::new_gpt(
-                Disk::new_ram_alloc(512, 512, data.as_ref().to_vec()).unwrap(),
-                new_gpt_max(),
-            ));
-            let _ = block_on(self.0.last().unwrap().sync_gpt());
-        }
-
-        /// Adds a raw partition disk.
-        pub(crate) fn add_raw_device(&mut self, name: &CStr, data: impl AsRef<[u8]>) {
-            // For raw partition, use block_size=alignment=1 for simplicity.
-            TestGblDisk::new_raw(Disk::new_ram_alloc(1, 1, data.as_ref().to_vec()).unwrap(), name)
-                .and_then(|v| Ok(self.0.push(v)))
-                .unwrap()
-        }
-    }
-
-    impl Deref for FakeGblOpsStorage {
-        type Target = [TestGblDisk];
-
-        fn deref(&self) -> &Self::Target {
-            &self.0[..]
-        }
-    }
-
-    /// Fake [GblOps] implementation for testing.
-    #[derive(Default)]
-    pub(crate) struct FakeGblOps<'a, 'd> {
-        /// Partition data to expose.
-        pub partitions: &'a [TestGblDisk],
-
-        /// Test fixture for [avb::Ops] and [avb::CertOps], provided by libavb.
-        ///
-        /// We don't use all the available functionality here, in particular the backing storage
-        /// is provided by `partitions` and our custom storage APIs rather than the [AvbTestOps]
-        /// fake storage, so that we can more accurately test our storage implementation.
-        pub avb_ops: AvbTestOps<'static>,
-
-        /// Value returned by `should_stop_in_fastboot`.
-        pub stop_in_fastboot: Option<Result<bool, Error>>,
-
-        /// For returned by `fn get_zbi_bootloader_files_buffer()`
-        pub zbi_bootloader_files_buffer: Vec<u8>,
-
-        /// For checking that `Self::reboot` is called.
-        pub rebooted: bool,
-
-        /// For return by `Self::expected_os()`
-        pub os: Option<Os>,
-
-        /// For return by `Self::avb_validate_vbmeta_public_key`
-        pub avb_key_validation_status: Option<AvbIoResult<KeyValidationStatus>>,
-
-        /// For return by `Self::get_image_buffer()`
-        pub image_buffers: HashMap<String, LinkedList<ImageBuffer<'d>>>,
-
-        /// Custom device tree.
-        pub custom_device_tree: Option<&'a [u8]>,
-
-        /// Custom handler for `avb_handle_verification_result`
-        pub avb_handle_verification_result: Option<
-            &'a mut dyn FnMut(
-                BootStateColor,
-                Option<&CStr>,
-                Option<&[u8]>,
-                Option<&[u8]>,
-                Option<&[u8]>,
-                Option<&[u8]>,
-                Option<&[u8]>,
-                Option<&[u8]>,
-            ) -> AvbIoResult<()>,
-        >,
-
-        /// For returned by `get_current_slot`
-        //
-        // We wrap it in an `Option` so that if a test exercises code paths that use it but did not
-        // set it, it can panic with "unwrap()" which will give a clearer error and location
-        // message than a vague error such as `Error::Unimplemented`.
-        pub current_slot: Option<Result<Slot, Error>>,
-
-        /// For returned by `get_next_slot`
-        pub next_slot: Option<Result<Slot, Error>>,
-
-        /// Number of times `get_next_slot()` is called with `mark_boot_attempt` set to true.
-        pub mark_boot_attempt_called: usize,
-
-        /// slot index last set active by `set_active()`,
-        pub last_set_active_slot: Option<u8>,
-
-        /// For returned by `get_reboot_reason()`
-        pub reboot_reason: Option<Result<RebootReason, Error>>,
-    }
-
-    /// Print `console_out` output, which can be useful for debugging.
-    impl<'a, 'd> Write for FakeGblOps<'a, 'd> {
-        fn write_str(&mut self, s: &str) -> Result<(), std::fmt::Error> {
-            Ok(print!("{s}"))
-        }
-    }
-
-    impl<'a, 'd> FakeGblOps<'a, 'd> {
-        /// For now we've just hardcoded the `zircon_add_device_zbi_items()` callback to add a
-        /// single commandline ZBI item with these contents; if necessary we can generalize this
-        /// later and allow tests to configure the ZBI modifications.
-        pub const ADDED_ZBI_COMMANDLINE_CONTENTS: &'static [u8] = b"test_zbi_item";
-        pub const TEST_BOOTLOADER_FILE_1: &'static [u8] = b"\x06test_1foo";
-        pub const TEST_BOOTLOADER_FILE_2: &'static [u8] = b"\x06test_2bar";
-        pub const GBL_TEST_VAR: &'static str = "gbl-test-var";
-        pub const GBL_TEST_VAR_VAL: &'static str = "gbl-test-var-val";
-        pub const GBL_TEST_BOOTCONFIG: &'static str = "arg1=val1\x0aarg2=val2\x0a";
-
-        pub fn new(partitions: &'a [TestGblDisk]) -> Self {
-            let mut res = Self {
-                partitions,
-                zbi_bootloader_files_buffer: vec![0u8; 32 * 1024],
-                ..Default::default()
-            };
-            let mut container =
-                ZbiContainer::new(res.get_zbi_bootloader_files_buffer_aligned().unwrap()).unwrap();
-            for ele in [Self::TEST_BOOTLOADER_FILE_1, Self::TEST_BOOTLOADER_FILE_2] {
-                container
-                    .create_entry_with_payload(ZbiType::BootloaderFile, 0, ZbiFlags::default(), ele)
-                    .unwrap();
-            }
-
-            res
-        }
-
-        /// Copies an entire partition contents into a vector.
-        ///
-        /// This is a common enough operation in tests that it's worth a small wrapper to provide
-        /// a more convenient API using [Vec].
-        ///
-        /// Panics if the given partition name doesn't exist.
-        pub fn copy_partition(&mut self, name: &str) -> Vec<u8> {
-            let mut contents =
-                vec![0u8; self.partition_size(name).unwrap().unwrap().try_into().unwrap()];
-            assert!(self.read_from_partition_sync(name, 0, &mut contents[..]).is_ok());
-            contents
-        }
-    }
-
-    impl<'a, 'd> GblOps<'a, 'd> for FakeGblOps<'a, 'd> {
-        fn console_out(&mut self) -> Option<&mut dyn Write> {
-            Some(self)
-        }
-
-        fn should_stop_in_fastboot(&mut self) -> Result<bool, Error> {
-            self.stop_in_fastboot.unwrap_or(Ok(false))
-        }
-
-        fn reboot(&mut self) {
-            self.rebooted = true;
-        }
-
-        fn disks(
-            &self,
-        ) -> &'a [GblDisk<
-            Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
-            Gpt<impl DerefMut<Target = [u8]> + 'a>,
-        >] {
-            self.partitions
-        }
-
-        fn expected_os(&mut self) -> Result<Option<Os>, Error> {
-            Ok(self.os)
-        }
-
-        fn zircon_add_device_zbi_items(
-            &mut self,
-            container: &mut ZbiContainer<&mut [u8]>,
-        ) -> Result<(), Error> {
-            container
-                .create_entry_with_payload(
-                    ZbiType::CmdLine,
-                    0,
-                    ZbiFlags::default(),
-                    Self::ADDED_ZBI_COMMANDLINE_CONTENTS,
-                )
-                .unwrap();
-            Ok(())
-        }
-
-        fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
-            Some(self.zbi_bootloader_files_buffer.as_mut_slice())
-        }
-
-        fn load_slot_interface<'b>(
-            &'b mut self,
-            _: &'b mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
-            _: slots::BootToken,
-        ) -> GblResult<slots::Cursor<'b>> {
-            unimplemented!();
-        }
-
-        fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-            self.avb_ops.read_is_device_unlocked()
-        }
-
-        fn avb_read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64> {
-            self.avb_ops.read_rollback_index(rollback_index_location)
-        }
-
-        fn avb_write_rollback_index(
-            &mut self,
-            rollback_index_location: usize,
-            index: u64,
-        ) -> AvbIoResult<()> {
-            self.avb_ops.write_rollback_index(rollback_index_location, index)
-        }
-
-        fn avb_validate_vbmeta_public_key(
-            &self,
-            _public_key: &[u8],
-            _public_key_metadata: Option<&[u8]>,
-        ) -> AvbIoResult<KeyValidationStatus> {
-            self.avb_key_validation_status.clone().unwrap()
-        }
-
-        fn avb_cert_read_permanent_attributes(
-            &mut self,
-            attributes: &mut CertPermanentAttributes,
-        ) -> AvbIoResult<()> {
-            self.avb_ops.read_permanent_attributes(attributes)
-        }
-
-        fn avb_cert_read_permanent_attributes_hash(
-            &mut self,
-        ) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
-            self.avb_ops.read_permanent_attributes_hash()
-        }
-
-        fn avb_read_persistent_value(
-            &mut self,
-            name: &CStr,
-            value: &mut [u8],
-        ) -> AvbIoResult<usize> {
-            self.avb_ops.read_persistent_value(name, value)
-        }
-
-        fn avb_write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()> {
-            self.avb_ops.write_persistent_value(name, value)
-        }
-
-        fn avb_erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()> {
-            self.avb_ops.erase_persistent_value(name)
-        }
-
-        fn avb_handle_verification_result(
-            &mut self,
-            color: BootStateColor,
-            digest: Option<&CStr>,
-            boot_os_version: Option<&[u8]>,
-            boot_security_patch: Option<&[u8]>,
-            system_os_version: Option<&[u8]>,
-            system_security_patch: Option<&[u8]>,
-            vendor_os_version: Option<&[u8]>,
-            vendor_security_patch: Option<&[u8]>,
-        ) -> AvbIoResult<()> {
-            match self.avb_handle_verification_result.as_mut() {
-                Some(f) => (*f)(
-                    color,
-                    digest,
-                    boot_os_version,
-                    boot_security_patch,
-                    system_os_version,
-                    system_security_patch,
-                    vendor_os_version,
-                    vendor_security_patch,
-                ),
-                _ => Ok(()),
-            }
-        }
-
-        fn get_image_buffer(
-            &mut self,
-            image_name: &str,
-            _size: NonZeroUsize,
-        ) -> GblResult<ImageBuffer<'d>> {
-            if let Some(buf_list) = self.image_buffers.get_mut(image_name) {
-                if let Some(buf) = buf_list.pop_front() {
-                    return Ok(buf);
-                };
-            };
-
-            gbl_println!(self, "FakeGblOps.get_image_buffer({image_name}) no buffer for the image");
-            Err(IntegrationError::UnificationError(Error::Other(Some(
-                "No buffer provided. Add sufficient buffers to FakeGblOps.image_buffers",
-            ))))
-        }
-
-        fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
-            self.custom_device_tree
-        }
-
-        fn fixup_os_commandline<'c>(
-            &mut self,
-            _commandline: &CStr,
-            _fixup_buffer: &'c mut [u8],
-        ) -> Result<Option<&'c str>, Error> {
-            Ok(None)
-        }
-
-        fn fixup_bootconfig<'c>(
-            &mut self,
-            _bootconfig: &[u8],
-            fixup_buffer: &'c mut [u8],
-        ) -> Result<Option<&'c [u8]>, Error> {
-            let (out, _) = fixup_buffer.split_at_mut(Self::GBL_TEST_BOOTCONFIG.len());
-            out.clone_from_slice(Self::GBL_TEST_BOOTCONFIG.as_bytes());
-            Ok(Some(out))
-        }
-
-        fn fixup_device_tree(&mut self, fdt: &mut [u8]) -> Result<(), Error> {
-            Fdt::new_mut(fdt).unwrap().set_property("chosen", c"fixup", &[1])?;
-            Ok(())
-        }
-
-        fn select_device_trees(
-            &mut self,
-            device_tree: &mut device_tree::DeviceTreeComponentsRegistry,
-        ) -> Result<(), Error> {
-            // Select the first dtbo.
-            match device_tree.components_mut().find(|v| !v.is_base_device_tree()) {
-                Some(v) => v.selected = true,
-                _ => {}
-            }
-            device_tree.autoselect()
-        }
-
-        fn fastboot_variable<'arg>(
-            &mut self,
-            name: &CStr,
-            mut args: impl Iterator<Item = &'arg CStr> + Clone,
-            out: &mut [u8],
-        ) -> Result<usize, Error> {
-            match name.to_str()? {
-                Self::GBL_TEST_VAR => {
-                    Ok(snprintf!(out, "{}:{:?}", Self::GBL_TEST_VAR_VAL, args.next()).len())
-                }
-                _ => Err(Error::NotFound),
-            }
-        }
-
-        fn fastboot_visit_all_variables(
-            &mut self,
-            mut cb: impl FnMut(&[&CStr], &CStr),
-        ) -> Result<(), Error> {
-            cb(
-                &[CString::new(Self::GBL_TEST_VAR).unwrap().as_c_str(), c"1"],
-                CString::new(format!("{}:1", Self::GBL_TEST_VAR_VAL)).unwrap().as_c_str(),
-            );
-            cb(
-                &[CString::new(Self::GBL_TEST_VAR).unwrap().as_c_str(), c"2"],
-                CString::new(format!("{}:2", Self::GBL_TEST_VAR_VAL)).unwrap().as_c_str(),
-            );
-            Ok(())
-        }
-
-        fn slots_metadata(&mut self) -> Result<SlotsMetadata, Error> {
-            unimplemented!();
-        }
-
-        fn get_current_slot(&mut self) -> Result<Slot, Error> {
-            self.current_slot.unwrap()
-        }
-
-        fn get_next_slot(&mut self, mark_boot_attempt: bool) -> Result<Slot, Error> {
-            self.mark_boot_attempt_called += usize::from(mark_boot_attempt);
-            self.next_slot.unwrap()
-        }
-
-        fn set_active_slot(&mut self, slot: u8) -> Result<(), Error> {
-            self.last_set_active_slot = Some(slot);
-            Ok(())
-        }
-
-        fn set_reboot_reason(&mut self, _: RebootReason) -> Result<(), Error> {
-            unimplemented!()
-        }
-
-        fn get_reboot_reason(&mut self) -> Result<RebootReason, Error> {
-            self.reboot_reason.unwrap()
-        }
-    }
-
-    #[test]
-    fn test_fuchsia_reboot_bootloader() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        (gbl_ops.reboot_bootloader().unwrap())();
-        assert!(gbl_ops.rebooted);
-        assert_eq!(get_and_clear_one_shot_bootloader(&mut GblAbrOps(&mut gbl_ops)), Ok(true));
-    }
-
-    #[test]
-    fn test_non_fuchsia_reboot_bootloader() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Android);
-        assert!(gbl_ops.reboot_bootloader().is_err_and(|e| e == Error::Unsupported));
-        assert_eq!(get_and_clear_one_shot_bootloader(&mut GblAbrOps(&mut gbl_ops)), Ok(false));
-    }
-
-    #[test]
-    fn test_fuchsia_reboot_recovery() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Fuchsia);
-        (gbl_ops.reboot_recovery().unwrap())();
-        assert!(gbl_ops.rebooted);
-        // One shot recovery is set.
-        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::R, false));
-        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::A, false));
-    }
-
-    #[test]
-    fn test_non_fuchsia_reboot_recovery() {
-        let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
-        let mut gbl_ops = FakeGblOps::new(&storage);
-        gbl_ops.os = Some(Os::Android);
-        assert!(gbl_ops.reboot_recovery().is_err_and(|e| e == Error::Unsupported));
-        // One shot recovery is not set.
-        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::A, false));
-    }
-
-    /// Helper for creating a slot object.
-    pub(crate) fn slot(suffix: char) -> Slot {
-        Slot { suffix: suffix.into(), ..Default::default() }
-    }
-}
diff --git a/gbl/libgbl/src/partition.rs b/gbl/libgbl/src/partition.rs
deleted file mode 100644
index f56107a..0000000
--- a/gbl/libgbl/src/partition.rs
+++ /dev/null
@@ -1,756 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file implements storage and partition logic for libgbl.
-
-use crate::fastboot::sparse::{is_sparse_image, write_sparse_image, SparseRawWriter};
-use core::cell::{RefCell, RefMut};
-use core::{
-    ffi::CStr,
-    ops::{Deref, DerefMut},
-};
-use gbl_storage::{
-    BlockInfo, BlockIo, Disk, Gpt, GptBuilder, GptSyncResult, Partition as GptPartition,
-    SliceMaybeUninit,
-};
-use liberror::Error;
-use safemath::SafeNum;
-
-/// Maximum name length for raw partition.
-pub const RAW_PARTITION_NAME_LEN: usize = 72;
-
-/// Wraps a bytes buffer containing a null-terminated C string
-#[derive(Copy, Clone, PartialEq, Debug)]
-pub struct RawName([u8; RAW_PARTITION_NAME_LEN]);
-
-impl RawName {
-    fn new(name: &CStr) -> Result<Self, Error> {
-        let mut buf = [0u8; RAW_PARTITION_NAME_LEN];
-        name.to_str().map_err(|_| Error::InvalidInput)?;
-        let name = name.to_bytes_with_nul();
-        buf.get_mut(..name.len()).ok_or(Error::InvalidInput)?.clone_from_slice(name);
-        Ok(Self(buf))
-    }
-
-    /// Decodes to a string.
-    pub fn to_str(&self) -> &str {
-        CStr::from_bytes_until_nul(&self.0[..]).unwrap().to_str().unwrap()
-    }
-}
-
-/// Represents a GBL partition.
-#[derive(Copy, Clone, PartialEq, Debug)]
-pub enum Partition {
-    /// Raw storage partition.
-    Raw(RawName, u64),
-    /// Gpt Partition.
-    Gpt(GptPartition),
-}
-
-impl Partition {
-    /// Returns the size.
-    pub fn size(&self) -> Result<u64, Error> {
-        let (start, end) = self.absolute_range()?;
-        Ok((SafeNum::from(end) - start).try_into()?)
-    }
-
-    /// Returns the name.
-    pub fn name(&self) -> Result<&str, Error> {
-        Ok(match self {
-            Partition::Gpt(gpt) => gpt.name().ok_or(Error::InvalidInput)?,
-            Partition::Raw(name, _) => name.to_str(),
-        })
-    }
-
-    /// Computes the absolute start and end offset for the partition in the whole block device.
-    pub fn absolute_range(&self) -> Result<(u64, u64), Error> {
-        Ok(match self {
-            Partition::Gpt(gpt) => gpt.absolute_range()?,
-            Partition::Raw(_, size) => (0, *size),
-        })
-    }
-}
-
-/// Represents the partition table for a block device. It can either be a GPT partition table or a
-/// single whole device raw partition.
-enum PartitionTable<G> {
-    Raw(RawName, u64),
-    Gpt(G),
-}
-
-/// The status of block device
-pub enum BlockStatus {
-    /// Idle,
-    Idle,
-    /// An IO in progress.
-    Pending,
-}
-
-impl BlockStatus {
-    /// Converts to str.
-    pub fn to_str(&self) -> &'static str {
-        match self {
-            BlockStatus::Idle => "idle",
-            BlockStatus::Pending => "IO pending",
-        }
-    }
-}
-
-/// Represents a disk device that contains either GPT partitions or a single whole raw storage
-/// partition.
-pub struct GblDisk<D, G> {
-    // Contains a `Disk` for block IO.
-    //
-    // `disk` and `partitions` are wrapped in RefCell because they may be shared by multiple async
-    // blocks for operations such as parallel fastboot download/flashing. They are also wrapped
-    // separately in order to make operations on each independent and parallel for use cases such
-    // as getting partition info for `fastboot getvar` when disk IO is busy.
-    disk: RefCell<D>,
-    partitions: RefCell<PartitionTable<G>>,
-    info_cache: BlockInfo,
-}
-
-impl<B, S, T> GblDisk<Disk<B, S>, Gpt<T>>
-where
-    B: BlockIo,
-    S: DerefMut<Target = [u8]>,
-    T: DerefMut<Target = [u8]>,
-{
-    /// Creates a new instance as a GPT device.
-    pub fn new_gpt(mut disk: Disk<B, S>, gpt: Gpt<T>) -> Self {
-        let info_cache = disk.io().info();
-        Self { disk: disk.into(), info_cache, partitions: PartitionTable::Gpt(gpt).into() }
-    }
-
-    /// Creates a new instance as a raw storage partition.
-    pub fn new_raw(mut disk: Disk<B, S>, name: &CStr) -> Result<Self, Error> {
-        let info_cache = disk.io().info();
-        Ok(Self {
-            disk: disk.into(),
-            info_cache,
-            partitions: PartitionTable::Raw(RawName::new(name)?, info_cache.total_size()?).into(),
-        })
-    }
-
-    /// Gets the cached `BlockInfo`.
-    pub fn block_info(&self) -> BlockInfo {
-        self.info_cache
-    }
-
-    /// Gets the block status.
-    pub fn status(&self) -> BlockStatus {
-        match self.disk.try_borrow_mut().ok() {
-            None => BlockStatus::Pending,
-            _ => BlockStatus::Idle,
-        }
-    }
-
-    /// Borrows disk mutably.
-    fn get_disk(&self) -> Result<RefMut<'_, Disk<B, S>>, Error> {
-        self.disk.try_borrow_mut().map_err(|_| Error::NotReady)
-    }
-
-    /// Gets an instance of `PartitionIo` for a partition.
-    ///
-    /// If `part` is `None`, an IO for the whole block device is returned.
-    pub fn partition_io(&self, part: Option<&str>) -> Result<PartitionIo<'_, B>, Error> {
-        let (part_start, part_end) = self.find_partition(part)?.absolute_range()?;
-        Ok(PartitionIo { disk: Disk::from_ref_mut(self.get_disk()?), part_start, part_end })
-    }
-
-    /// Finds a partition.
-    ///
-    /// * If `part` is none, the method returns an unnamed `Partition` that represents the whole
-    //    raw storage.
-    pub fn find_partition(&self, part: Option<&str>) -> Result<Partition, Error> {
-        let Some(part) = part else {
-            return Ok(Partition::Raw(RawName::new(c"").unwrap(), self.info_cache.total_size()?));
-        };
-
-        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref() {
-            PartitionTable::Gpt(gpt) => Ok(Partition::Gpt(gpt.find_partition(part)?)),
-            PartitionTable::Raw(name, size) if name.to_str() == part => {
-                Ok(Partition::Raw(*name, *size))
-            }
-            _ => Err(Error::NotFound),
-        }
-    }
-
-    /// Get total number of partitions.
-    pub fn num_partitions(&self) -> Result<usize, Error> {
-        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref() {
-            PartitionTable::Raw(_, _) => Ok(1),
-            PartitionTable::Gpt(gpt) => gpt.num_partitions(),
-        }
-    }
-
-    /// Gets a partition by index.
-    pub fn get_partition_by_idx(&self, idx: usize) -> Result<Partition, Error> {
-        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref() {
-            PartitionTable::Raw(name, v) if idx == 0 => Ok(Partition::Raw(*name, *v)),
-            PartitionTable::Gpt(gpt) => Ok(Partition::Gpt(gpt.get_partition(idx)?)),
-            _ => Err(Error::InvalidInput),
-        }
-    }
-
-    /// Syncs GPT if the partition type is GPT.
-    ///
-    /// # Returns
-    ///
-    /// * Returns `Ok(Some(sync_res))` if partition type is GPT and disk access is successful, where
-    ///  `sync_res` contains the GPT verification and restoration result.
-    /// * Returns `Ok(None)` if partition type is not GPT.
-    /// * Returns `Err` in other cases.
-    pub async fn sync_gpt(&self) -> Result<Option<GptSyncResult>, Error> {
-        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref_mut() {
-            PartitionTable::Raw(_, _) => Ok(None),
-            PartitionTable::Gpt(ref mut gpt) => {
-                let mut blk = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
-                Ok(Some(blk.sync_gpt(gpt).await?))
-            }
-        }
-    }
-
-    /// Updates GPT to the block device and sync primary and secondary GPT.
-    ///
-    /// # Args
-    ///
-    /// * `mbr_primary`: A buffer containing the MBR block, primary GPT header and entries.
-    /// * `resize`: If set to true, the method updates the last partition to cover the rest of the
-    ///    storage.
-    ///
-    /// # Returns
-    ///
-    /// * Return `Err(Error::NotReady)` if device is busy.
-    /// * Return `Err(Error::Unsupported)` if partition type is not GPT.
-    /// * Return `Ok(())` new GPT is valid and device is updated and synced successfully.
-    pub async fn update_gpt(&self, mbr_primary: &mut [u8], resize: bool) -> Result<(), Error> {
-        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref_mut() {
-            PartitionTable::Raw(_, _) => Err(Error::Unsupported),
-            PartitionTable::Gpt(ref mut gpt) => {
-                let mut blk = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
-                blk.update_gpt(mbr_primary, resize, gpt).await
-            }
-        }
-    }
-
-    /// Erases GPT on the disk.
-    ///
-    /// # Returns
-    ///
-    /// * Return `Err(Error::NotReady)` if device is busy.
-    /// * Return `Err(Error::Unsupported)` if partition type is not GPT.
-    pub async fn erase_gpt(&self) -> Result<(), Error> {
-        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref_mut() {
-            PartitionTable::Raw(_, _) => Err(Error::Unsupported),
-            PartitionTable::Gpt(ref mut gpt) => {
-                let mut disk = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
-                disk.erase_gpt(gpt).await
-            }
-        }
-    }
-
-    /// Creates an instance of GptBuilder.
-    pub fn gpt_builder(
-        &self,
-    ) -> Result<GptBuilder<RefMut<'_, Disk<B, S>>, RefMut<'_, Gpt<T>>>, Error> {
-        let mut parts = self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?;
-        match parts.deref_mut() {
-            PartitionTable::Raw(_, _) => Err(Error::Unsupported),
-            PartitionTable::Gpt(_) => {
-                let gpt = RefMut::map(parts, |v| match v {
-                    PartitionTable::Gpt(v) => v,
-                    _ => unreachable!(),
-                });
-                Ok(GptBuilder::new(self.get_disk()?, gpt)?.0)
-            }
-        }
-    }
-}
-
-/// `PartitionIo` provides read/write APIs to a partition.
-pub struct PartitionIo<'a, B: BlockIo> {
-    disk: Disk<RefMut<'a, B>, RefMut<'a, [u8]>>,
-    part_start: u64,
-    part_end: u64,
-}
-
-impl<'a, B: BlockIo> PartitionIo<'a, B> {
-    /// Returns the size of the partition.
-    pub fn size(&self) -> u64 {
-        // Corrects by construction. Should not fail.
-        self.part_end.checked_sub(self.part_start).unwrap()
-    }
-
-    /// Gets the block device.
-    pub fn dev(&mut self) -> &mut Disk<RefMut<'a, B>, RefMut<'a, [u8]>> {
-        &mut self.disk
-    }
-
-    /// Checks the read/write parameters and returns the absolute offset in the block.
-    fn check_rw_range(&self, off: u64, size: impl Into<SafeNum>) -> Result<u64, Error> {
-        let ab_range_end = SafeNum::from(self.part_start) + off + size.into();
-        // Checks overflow by computing the difference between range end and partition end and
-        // making sure it succeeds.
-        (SafeNum::from(self.part_end) - ab_range_end)
-            .try_into()
-            .and_then(|_: u64| (SafeNum::from(self.part_start) + off).try_into())
-            .map_err(|_| Error::OutOfRange)
-    }
-
-    /// Writes to the partition.
-    pub async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
-        self.disk.write(self.check_rw_range(off, data.len())?, data).await
-    }
-
-    /// Reads from the partition.
-    pub async fn read(
-        &mut self,
-        off: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<(), Error> {
-        self.disk.read(self.check_rw_range(off, out.len())?, out).await
-    }
-
-    /// Writes zeroes to the partition.
-    pub async fn zeroize(&mut self, scratch: &mut [u8]) -> Result<(), Error> {
-        self.disk.fill(self.part_start, self.size(), 0, scratch).await
-    }
-
-    /// Writes sparse image to the partition.
-    pub async fn write_sparse(&mut self, off: u64, img: &mut [u8]) -> Result<(), Error> {
-        let sz = is_sparse_image(img).map_err(|_| Error::InvalidInput)?.data_size();
-        write_sparse_image(img, &mut (self.check_rw_range(off, sz)?, &mut self.disk)).await?;
-        Ok(())
-    }
-
-    /// Turns this IO into one for a subrange in the partition.
-    pub fn sub(self, off: u64, sz: u64) -> Result<Self, Error> {
-        self.check_rw_range(off, sz)?;
-        let mut sub = self;
-        sub.part_start += off;
-        sub.part_end = sub.part_start + sz;
-        Ok(sub)
-    }
-}
-
-// Implements `SparseRawWriter` for tuple (<flash offset>, <block device>)
-impl<B, S> SparseRawWriter for (u64, &mut Disk<B, S>)
-where
-    B: BlockIo,
-    S: DerefMut<Target = [u8]>,
-{
-    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
-        Ok(self.1.write((SafeNum::from(off) + self.0).try_into()?, data).await?)
-    }
-}
-
-/// Checks that a partition is unique.
-///
-/// Returns a pair `(<block device index>, `Partition`)` if the partition exists and is unique.
-pub fn check_part_unique(
-    devs: &'_ [GblDisk<
-        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-        Gpt<impl DerefMut<Target = [u8]>>,
-    >],
-    part: &str,
-) -> Result<(usize, Partition), Error> {
-    let mut filtered = devs
-        .iter()
-        .enumerate()
-        .filter_map(|(i, v)| v.find_partition(Some(part)).ok().map(|v| (i, v)));
-    match (filtered.next(), filtered.next()) {
-        (Some(v), None) => Ok(v),
-        (Some(_), Some(_)) => Err(Error::NotUnique),
-        _ => Err(Error::NotFound),
-    }
-}
-
-/// Checks that a partition is unique among all block devices and reads from it.
-pub async fn read_unique_partition(
-    devs: &'_ [GblDisk<
-        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-        Gpt<impl DerefMut<Target = [u8]>>,
-    >],
-    part: &str,
-    off: u64,
-    out: &mut (impl SliceMaybeUninit + ?Sized),
-) -> Result<(), Error> {
-    devs[check_part_unique(devs, part)?.0].partition_io(Some(part))?.read(off, out).await
-}
-
-/// Checks that a partition is unique among all block devices and writes to it.
-pub async fn write_unique_partition(
-    devs: &'_ [GblDisk<
-        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-        Gpt<impl DerefMut<Target = [u8]>>,
-    >],
-    part: &str,
-    off: u64,
-    data: &mut [u8],
-) -> Result<(), Error> {
-    devs[check_part_unique(devs, part)?.0].partition_io(Some(part))?.write(off, data).await
-}
-
-/// Syncs all GPT type partition devices.
-pub async fn sync_gpt(
-    devs: &'_ [GblDisk<
-        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-        Gpt<impl DerefMut<Target = [u8]>>,
-    >],
-) -> Result<(), Error> {
-    for ele in &devs[..] {
-        ele.sync_gpt().await?;
-    }
-    Ok(())
-}
-
-#[cfg(test)]
-pub(crate) mod test {
-    use super::*;
-    use crate::ops::test::{FakeGblOpsStorage, TestGblDisk};
-    use core::fmt::Debug;
-    use gbl_async::block_on;
-
-    /// Absolute start/end offset and size of "boot_a/b" partitions in
-    /// "../../libstorage/test/gpt_test_1.bin"
-    const BOOT_A_OFF: u64 = 17 * 1024;
-    const BOOT_A_END: u64 = 25 * 1024;
-    const BOOT_A_SZ: u64 = BOOT_A_END - BOOT_A_OFF;
-    const BOOT_B_OFF: u64 = 25 * 1024;
-    const BOOT_B_END: u64 = 37 * 1024;
-    const BOOT_B_SZ: u64 = BOOT_B_END - BOOT_B_OFF;
-    /// Total size of disk "../../libstorage/test/gpt_test_1.bin"
-    const GPT_DISK_1_SZ: u64 = 64 * 1024;
-
-    /// A helper to convert an integer into usize and panics on error.
-    fn to_usize(val: impl TryInto<usize, Error = impl Debug>) -> usize {
-        val.try_into().unwrap()
-    }
-
-    /// A helper to create a GPT type TestGblDisk
-    fn gpt_disk(data: impl AsRef<[u8]>) -> TestGblDisk {
-        let mut res = FakeGblOpsStorage::default();
-        res.add_gpt_device(data);
-        res.0.pop().unwrap()
-    }
-
-    /// A helper to create a raw disk partition type TestGblDisk
-    fn raw_disk(name: &CStr, data: impl AsRef<[u8]>) -> TestGblDisk {
-        let mut res = FakeGblOpsStorage::default();
-        res.add_raw_device(name, data);
-        res.0.pop().unwrap()
-    }
-
-    #[test]
-    fn test_find_partition_gpt() {
-        let gpt = gpt_disk(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
-
-        let boot_a = gpt.find_partition(Some("boot_a")).unwrap();
-        assert_eq!(boot_a.name().unwrap(), "boot_a");
-        assert_eq!(boot_a.size().unwrap(), BOOT_A_SZ);
-        assert_eq!(boot_a.absolute_range().unwrap(), (BOOT_A_OFF, BOOT_A_END));
-
-        let boot_b = gpt.find_partition(Some("boot_b")).unwrap();
-        assert_eq!(boot_b.name().unwrap(), "boot_b");
-        assert_eq!(boot_b.size().unwrap(), BOOT_B_SZ);
-        assert_eq!(boot_b.absolute_range().unwrap(), (BOOT_B_OFF, BOOT_B_END));
-
-        let unnamed_whole = gpt.find_partition(None).unwrap();
-        assert_eq!(unnamed_whole.name().unwrap(), "");
-        assert_eq!(unnamed_whole.size().unwrap(), GPT_DISK_1_SZ);
-        assert_eq!(unnamed_whole.absolute_range().unwrap(), (0, GPT_DISK_1_SZ));
-
-        assert!(gpt.find_partition(Some("not-exist")).is_err());
-    }
-
-    #[test]
-    fn test_find_partition_raw() {
-        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let raw = raw_disk(c"raw", &disk);
-
-        let raw_part = raw.find_partition(Some("raw")).unwrap();
-        assert_eq!(raw_part.name().unwrap(), "raw");
-        assert_eq!(raw_part.size().unwrap(), GPT_DISK_1_SZ);
-        assert_eq!(raw_part.absolute_range().unwrap(), (0, GPT_DISK_1_SZ));
-
-        let unnamed_whole = raw.find_partition(None).unwrap();
-        assert_eq!(unnamed_whole.name().unwrap(), "");
-        assert_eq!(unnamed_whole.size().unwrap(), GPT_DISK_1_SZ);
-        assert_eq!(unnamed_whole.absolute_range().unwrap(), (0, GPT_DISK_1_SZ));
-
-        assert!(raw.find_partition(Some("boot_a")).is_err());
-    }
-
-    /// A helper for testing partition read.
-    ///
-    /// Tests that the content read at `off..off+sz` is the same as `part_content[off..off+sz]`.
-    fn test_part_read(
-        blk: &TestGblDisk,
-        part: Option<&str>,
-        part_content: &[u8],
-        off: u64,
-        sz: u64,
-    ) {
-        let mut out = vec![0u8; to_usize(sz)];
-        block_on(blk.partition_io(part).unwrap().read(off, &mut out[..])).unwrap();
-        assert_eq!(out, part_content[to_usize(off)..][..out.len()].to_vec());
-
-        // Reads using the `sub()` and then read approach.
-        let mut out = vec![0u8; to_usize(sz)];
-        let mut io = blk.partition_io(part).unwrap().sub(off, sz).unwrap();
-        block_on(io.read(0, &mut out[..])).unwrap();
-        assert_eq!(out, part_content[to_usize(off)..][..out.len()].to_vec());
-    }
-
-    #[test]
-    fn test_read_partition_gpt() {
-        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let gpt = gpt_disk(&disk[..]);
-        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
-
-        let expect_boot_a = include_bytes!("../../libstorage/test/boot_a.bin");
-        test_part_read(&gpt, Some("boot_a"), expect_boot_a, 1, 1024);
-        let expect_boot_b = include_bytes!("../../libstorage/test/boot_b.bin");
-        test_part_read(&gpt, Some("boot_b"), expect_boot_b, 1, 1024);
-        // Whole block read.
-        test_part_read(&gpt, None, disk, 1, 1024);
-    }
-
-    #[test]
-    fn test_read_partition_raw() {
-        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let raw = raw_disk(c"raw", &disk);
-        test_part_read(&raw, Some("raw"), disk, 1, 1024);
-        test_part_read(&raw, None, disk, 1, 1024);
-    }
-
-    /// A helper for testing partition write.
-    fn test_part_write(blk: &TestGblDisk, part: Option<&str>, off: u64, sz: u64) {
-        // Reads the current partition content
-        let mut part_content = vec![0u8; to_usize(blk.partition_io(part).unwrap().size())];
-        block_on(blk.partition_io(part).unwrap().read(0, &mut part_content[..])).unwrap();
-
-        // Flips all the bits in the target range and writes back.
-        let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
-        seg.iter_mut().for_each(|v| *v = !(*v));
-        block_on(blk.partition_io(part).unwrap().write(off, seg)).unwrap();
-        // Checks that data is written.
-        test_part_read(blk, part, &part_content, off, sz);
-
-        // Writes using the `sub()` and then write approach.
-        let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
-        seg.iter_mut().for_each(|v| *v = !(*v));
-        block_on(blk.partition_io(part).unwrap().sub(off, sz).unwrap().write(0, seg)).unwrap();
-        test_part_read(blk, part, &part_content, off, sz);
-    }
-
-    #[test]
-    fn test_write_partition_gpt() {
-        let gpt = gpt_disk(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
-        test_part_write(&gpt, Some("boot_a"), 1, 1024);
-        test_part_write(&gpt, Some("boot_b"), 1, 1024);
-        test_part_write(&gpt, None, 1, 1024);
-    }
-
-    #[test]
-    fn test_write_partition_raw() {
-        let mut raw = raw_disk(c"raw", include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        test_part_write(&mut raw, Some("raw"), 1, 1024);
-        test_part_write(&mut raw, None, 1, 1024);
-    }
-
-    #[test]
-    fn test_read_write_partition_overflow() {
-        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let gpt = gpt_disk(&disk[..]);
-        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
-
-        let mut part_io = gpt.partition_io(Some("boot_a")).unwrap();
-        assert!(block_on(part_io.read(BOOT_A_END, &mut vec![0u8; 1][..])).is_err());
-        assert!(block_on(part_io.read(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1][..]))
-            .is_err());
-        assert!(block_on(part_io.write(BOOT_A_END, &mut vec![0u8; 1][..])).is_err());
-        assert!(block_on(part_io.write(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1][..]))
-            .is_err());
-
-        let raw = raw_disk(c"raw", &disk);
-        let mut part_io = raw.partition_io(Some("raw")).unwrap();
-        assert!(block_on(part_io.read(GPT_DISK_1_SZ, &mut vec![0u8; 1][..])).is_err());
-        assert!(block_on(part_io.read(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1][..])).is_err());
-        assert!(block_on(part_io.write(GPT_DISK_1_SZ, &mut vec![0u8; 1][..])).is_err());
-        assert!(
-            block_on(part_io.write(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1][..])).is_err()
-        );
-    }
-
-    #[test]
-    fn test_sub_overflow() {
-        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let gpt = gpt_disk(&disk[..]);
-        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
-        assert!(gpt.partition_io(Some("boot_a")).unwrap().sub(0, BOOT_A_SZ + 1).is_err());
-        assert!(gpt.partition_io(Some("boot_a")).unwrap().sub(1, BOOT_A_SZ).is_err());
-
-        let raw = raw_disk(c"raw", &disk);
-        assert!(raw.partition_io(Some("raw")).unwrap().sub(0, GPT_DISK_1_SZ + 1).is_err());
-        assert!(raw.partition_io(Some("raw")).unwrap().sub(1, GPT_DISK_1_SZ).is_err());
-    }
-
-    #[test]
-    fn test_write_sparse() {
-        let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
-        let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
-        let raw = &vec![0u8; sparse_raw.len() + 512][..];
-        let blk = raw_disk(c"raw", raw);
-        block_on(
-            blk.partition_io(Some("raw"))
-                .unwrap()
-                .sub(1, u64::try_from(raw.len() - 1).unwrap())
-                .unwrap()
-                .write_sparse(1, &mut sparse),
-        )
-        .unwrap();
-        let mut expected = vec![0u8; raw.len()];
-        expected[1 + 1..][..sparse_raw.len()].clone_from_slice(sparse_raw);
-        test_part_read(&blk, Some("raw"), &expected, 1, sparse_raw.len().try_into().unwrap());
-    }
-
-    #[test]
-    fn test_write_sparse_not_sparse_image() {
-        let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
-        let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
-        sparse[0] = !sparse[0]; // Corrupt image.
-        let raw = raw_disk(c"raw", vec![0u8; sparse_raw.len() + 512]);
-        assert!(
-            block_on(raw.partition_io(Some("raw")).unwrap().write_sparse(1, &mut sparse)).is_err()
-        );
-    }
-
-    #[test]
-    fn test_write_sparse_overflow_size() {
-        let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
-        let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
-        let raw = raw_disk(c"raw", vec![0u8; sparse_raw.len()]);
-        assert!(
-            block_on(raw.partition_io(Some("raw")).unwrap().write_sparse(1, &mut sparse)).is_err()
-        );
-    }
-
-    #[test]
-    fn test_partition_iter() {
-        let raw = raw_disk(c"raw", vec![0u8; 1024]);
-        assert_eq!(raw.num_partitions().unwrap(), 1);
-        assert_eq!(raw.get_partition_by_idx(0).unwrap().name(), Ok("raw"));
-        assert_eq!(raw.get_partition_by_idx(0).unwrap().size(), Ok(1024));
-
-        let gpt = gpt_disk(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        block_on(gpt.sync_gpt()).unwrap();
-        assert_eq!(gpt.num_partitions().unwrap(), 2);
-        assert_eq!(gpt.get_partition_by_idx(0).unwrap().name().unwrap(), "boot_a");
-        assert_eq!(gpt.get_partition_by_idx(0).unwrap().size().unwrap(), 0x2000);
-        assert_eq!(gpt.get_partition_by_idx(1).unwrap().name().unwrap(), "boot_b");
-        assert_eq!(gpt.get_partition_by_idx(1).unwrap().size().unwrap(), 0x3000);
-    }
-
-    /// A test helper for `read_unique_partition`
-    /// It verifies that data read from partition `part` at offset `off` is the same as
-    /// `part_content[off..off+sz]`.
-    fn check_read_partition(
-        devs: &[TestGblDisk],
-        part: &str,
-        part_content: &[u8],
-        off: u64,
-        sz: u64,
-    ) {
-        let mut out = vec![0u8; to_usize(sz)];
-        block_on(read_unique_partition(devs, part, off, &mut out[..])).unwrap();
-        assert_eq!(out, part_content[to_usize(off)..][..out.len()]);
-    }
-
-    #[test]
-    fn test_read_unique_partition() {
-        let mut devs = FakeGblOpsStorage::default();
-        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_2.bin"));
-        devs.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
-        devs.add_raw_device(c"raw_1", [0x55u8; 4 * 1024]);
-
-        let boot_a = include_bytes!("../../libstorage/test/boot_a.bin");
-        let boot_b = include_bytes!("../../libstorage/test/boot_b.bin");
-
-        let off = 512u64;
-        let sz = 1024u64;
-        check_read_partition(&mut devs, "boot_a", boot_a, off, sz);
-        check_read_partition(&mut devs, "boot_b", boot_b, off, sz);
-
-        let vendor_boot_a = include_bytes!("../../libstorage/test/vendor_boot_a.bin");
-        let vendor_boot_b = include_bytes!("../../libstorage/test/vendor_boot_b.bin");
-
-        check_read_partition(&mut devs, "vendor_boot_a", vendor_boot_a, off, sz);
-        check_read_partition(&mut devs, "vendor_boot_b", vendor_boot_b, off, sz);
-
-        check_read_partition(&mut devs, "raw_0", &[0xaau8; 4 * 1024][..], off, sz);
-        check_read_partition(&mut devs, "raw_1", &[0x55u8; 4 * 1024][..], off, sz);
-    }
-
-    /// A test helper for `write_unique_partition`
-    fn check_write_partition(devs: &[TestGblDisk], part: &str, off: u64, sz: u64) {
-        // Reads the current partition content
-        let (_, p) = check_part_unique(devs, part).unwrap();
-        let mut part_content = vec![0u8; to_usize(p.size().unwrap())];
-        block_on(read_unique_partition(devs, part, 0, &mut part_content[..])).unwrap();
-
-        // Flips all the bits in the target range and writes back.
-        let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
-        seg.iter_mut().for_each(|v| *v = !(*v));
-        block_on(write_unique_partition(devs, part, off, seg)).unwrap();
-        // Checks that data is written.
-        check_read_partition(devs, part, &part_content, off, sz);
-    }
-
-    #[test]
-    fn test_write_unique_partition() {
-        let mut devs = FakeGblOpsStorage::default();
-        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_2.bin"));
-        devs.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
-        devs.add_raw_device(c"raw_1", [0x55u8; 4 * 1024]);
-
-        let off = 512u64;
-        let sz = 1024u64;
-        check_write_partition(&mut devs, "boot_a", off, sz);
-        check_write_partition(&mut devs, "boot_b", off, sz);
-        check_write_partition(&mut devs, "vendor_boot_a", off, sz);
-        check_write_partition(&mut devs, "vendor_boot_b", off, sz);
-        check_write_partition(&mut devs, "raw_0", off, sz);
-        check_write_partition(&mut devs, "raw_1", off, sz);
-    }
-
-    #[test]
-    fn test_rw_fail_with_non_unique_partition() {
-        let mut devs = FakeGblOpsStorage::default();
-        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
-        devs.add_raw_device(c"raw", [0xaau8; 4 * 1024]);
-        devs.add_raw_device(c"raw", [0x55u8; 4 * 1024]);
-
-        assert!(block_on(read_unique_partition(&devs, "boot_a", 0, &mut [] as &mut [u8],)).is_err());
-        assert!(block_on(write_unique_partition(&devs, "boot_a", 0, &mut [],)).is_err());
-        assert!(block_on(read_unique_partition(&devs, "raw", 0, &mut [] as &mut [u8],)).is_err());
-        assert!(block_on(write_unique_partition(&devs, "raw", 0, &mut [],)).is_err());
-    }
-}
diff --git a/gbl/libgbl/src/slots.rs b/gbl/libgbl/src/slots.rs
deleted file mode 100644
index b96ba13..0000000
--- a/gbl/libgbl/src/slots.rs
+++ /dev/null
@@ -1,456 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-/// Export the default implementation
-pub mod fuchsia;
-
-/// Reference Android implementation
-pub mod android;
-
-/// Generic functionality for partition backed ABR schemes
-pub mod partition;
-
-use core::mem::size_of;
-use liberror::Error;
-
-/// A type safe container for describing the number of retries a slot has left
-/// before it becomes unbootable.
-/// Slot tries can only be compared to, assigned to, or assigned from other
-/// tries.
-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
-pub struct Tries(usize);
-
-impl From<usize> for Tries {
-    fn from(u: usize) -> Self {
-        Self(u)
-    }
-}
-impl From<u8> for Tries {
-    fn from(u: u8) -> Self {
-        Self(u.into())
-    }
-}
-
-/// A type safe container for describing the priority of a slot.
-/// Slot priorities can only be compared to, assigned to, or assigned from
-/// other priorities.
-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]
-pub struct Priority(usize);
-
-impl From<usize> for Priority {
-    fn from(u: usize) -> Self {
-        Self(u)
-    }
-}
-impl From<u8> for Priority {
-    fn from(u: u8) -> Self {
-        Self(u.into())
-    }
-}
-
-/// A type safe container for describing a slot's suffix.
-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
-pub struct Suffix(pub(crate) char);
-
-impl Suffix {
-    // We want lexigraphically lower suffixes
-    // to have higher priority.
-    // A cheater way to do this is to compare
-    // their negative values.
-    // A char is 4 bytes, and a signed 64 bit int
-    // can comfortably contain the negative of a
-    // number represented by an unsigned 32 bit int.
-    fn rank(&self) -> i64 {
-        -i64::from(u32::from(self.0))
-    }
-}
-
-impl From<char> for Suffix {
-    fn from(c: char) -> Self {
-        Self(c)
-    }
-}
-
-impl TryFrom<usize> for Suffix {
-    type Error = Error;
-
-    fn try_from(value: usize) -> Result<Self, Self::Error> {
-        u32::try_from(value).ok().and_then(char::from_u32).ok_or(Error::InvalidInput).map(Self)
-    }
-}
-
-impl TryFrom<u32> for Suffix {
-    type Error = Error;
-
-    fn try_from(value: u32) -> Result<Self, Self::Error> {
-        char::from_u32(value).ok_or(Error::InvalidInput).map(Self)
-    }
-}
-
-// Includes a null terminator
-const SUFFIX_CSTR_MAX_BYTES: usize = size_of::<Suffix>() + 1;
-
-/// A buffer large enough to contain the serialized representation of a Suffix.
-/// Can be turned into a &Cstr like so:
-///
-/// let suffix: Suffix = 'a'.into();
-/// let buffer: SuffixBytes = suffix.into();
-/// let cstr = CStr::from_bytes_until_nul(&buffer)?;
-pub type SuffixBytes = [u8; SUFFIX_CSTR_MAX_BYTES];
-
-impl From<Suffix> for SuffixBytes {
-    fn from(val: Suffix) -> Self {
-        let mut buffer: Self = Default::default();
-        let _ = val.0.encode_utf8(&mut buffer);
-        buffer
-    }
-}
-
-/// Slot metadata describing why that slot is unbootable.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum UnbootableReason {
-    /// No information is given about why this slot is not bootable.
-    Unknown,
-    /// This slot has exhausted its retry budget and cannot be booted.
-    NoMoreTries,
-    /// As part of a system update, the update agent downloads
-    /// an updated image and stores it into a slot other than the current
-    /// active slot.
-    SystemUpdate,
-    /// This slot has been marked unbootable by user request,
-    /// usually as part of a system test.
-    UserRequested,
-    /// This slot has failed a verification check as part of
-    /// Android Verified Boot.
-    VerificationFailure,
-}
-
-impl Default for UnbootableReason {
-    fn default() -> Self {
-        Self::Unknown
-    }
-}
-
-impl From<u8> for UnbootableReason {
-    fn from(val: u8) -> Self {
-        match val {
-            1 => Self::NoMoreTries,
-            2 => Self::SystemUpdate,
-            3 => Self::UserRequested,
-            4 => Self::VerificationFailure,
-            _ => Self::Unknown,
-        }
-    }
-}
-
-impl From<UnbootableReason> for u8 {
-    fn from(reason: UnbootableReason) -> Self {
-        match reason {
-            UnbootableReason::Unknown => 0,
-            UnbootableReason::NoMoreTries => 1,
-            UnbootableReason::SystemUpdate => 2,
-            UnbootableReason::UserRequested => 3,
-            UnbootableReason::VerificationFailure => 4,
-        }
-    }
-}
-
-/// Describes whether a slot has successfully booted and, if not,
-/// why it is not a valid boot target OR the number of attempts it has left.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum Bootability {
-    /// This slot has successfully booted.
-    Successful,
-    /// This slot cannot be booted.
-    Unbootable(UnbootableReason),
-    /// This slot has not successfully booted yet but has
-    /// one or more attempts left before either successfully booting,
-    /// and being marked successful, or failing, and being marked
-    /// unbootable due to having no more tries.
-    Retriable(Tries),
-}
-
-impl Default for Bootability {
-    fn default() -> Self {
-        Self::Retriable(7u8.into())
-    }
-}
-
-/// User-visible representation of a boot slot.
-/// Describes the slot's moniker (i.e. the suffix),
-/// its priority,
-/// and information about its bootability.
-///
-/// Note: structures that implement Manager will probably have a different
-/// internal representation for slots and will convert and return Slot structures
-/// on the fly as part of iteration.
-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
-pub struct Slot {
-    /// The partition suffix for the slot.
-    pub suffix: Suffix,
-    /// The slot's priority for booting.
-    pub priority: Priority,
-    /// Information about a slot's boot eligibility and history.
-    pub bootability: Bootability,
-}
-
-impl Slot {
-    /// Returns whether a slot is a valid boot target,
-    /// i.e. return true if its bootability is not Unbootable.
-    pub fn is_bootable(&self) -> bool {
-        !matches!(self.bootability, Bootability::Unbootable(_))
-    }
-}
-
-/// Describes the platform recovery mode boot target.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum RecoveryTarget {
-    /// The platform uses a dedicated recovery slot with special semantics.
-    /// It can't be marked unbootable, has unlimited retries,
-    /// and often doesn't have an explicit metadata entry.
-    Dedicated,
-    /// The platform enters recovery mode by booting to a regular slot
-    /// but with a special commandline and ramdisk.
-    Slotted(Slot),
-}
-
-/// Describes a system's boot target, which can be a regular boot to a slot
-/// or a recovery boot.
-/// Whether the recovery boot target is a dedicated slot or a regular slot
-/// with a special command line is platform specific.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum BootTarget {
-    /// The system will attempt a normal boot to the given slot.
-    NormalBoot(Slot),
-    /// The system will attempt a recovery boot.
-    ///
-    /// Some platforms, such as Fuchsia, have dedicated recovery partitions with
-    /// special semantics. On these platforms, Recovery contains None.
-    ///
-    /// Other platforms, such as Android, do not have dedicated recovery partitions.
-    /// They enter recovery mode by attempting to boot a regular slot with a special
-    /// kernel command line and ramdisk.
-    /// Under these circomstances, Recovery contains the slot that will be used for recovery.
-    Recovery(RecoveryTarget),
-}
-
-impl BootTarget {
-    /// Gets the suffix for a particular boot target.
-    /// Implemented for BootTarget instead of slot in order to handle
-    /// Fuchsia's recovery partition.
-    pub fn suffix(&self) -> Suffix {
-        match self {
-            Self::NormalBoot(slot) | Self::Recovery(RecoveryTarget::Slotted(slot)) => slot.suffix,
-            Self::Recovery(RecoveryTarget::Dedicated) => 'r'.into(),
-        }
-    }
-}
-
-#[doc(hidden)]
-pub mod private {
-    use super::*;
-
-    #[doc(hidden)]
-    pub trait SlotGet {
-        /// Given an index, returns the Slot that corresponds to that index,
-        /// or Error if the index is out of bounds.
-        /// This is intended to abstract storage details for structs that impl Manager.
-        /// Most implementors will use some other, internal representation for slots,
-        /// and will dynamically create and return Slots on the fly.
-        ///
-        /// This method is a helper, implementation detail for SlotIterator.
-        /// It is not intended to be called by other parts of GBL or other users.
-        fn get_slot_by_number(&self, number: usize) -> Result<Slot, Error>;
-    }
-}
-
-/// A helper structure for iterating over slots.
-pub struct SlotIterator<'a> {
-    count: usize,
-    slot_getter: &'a dyn private::SlotGet,
-}
-
-impl<'a> SlotIterator<'a> {
-    /// Constructor for SlotIterator
-    pub fn new(intf: &'a dyn private::SlotGet) -> Self {
-        Self { count: 0, slot_getter: intf }
-    }
-}
-
-impl<'a> Iterator for SlotIterator<'a> {
-    type Item = Slot;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        let maybe_slot = self.slot_getter.get_slot_by_number(self.count).ok();
-        if maybe_slot.is_some() {
-            self.count += 1;
-        }
-        maybe_slot
-    }
-}
-
-/// Describe a oneshot boot target.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum OneShot {
-    /// The bootloader will stop in some kind of interactive mode.
-    /// This can be Fastboot, a TUI boot menu, or something similar.
-    Bootloader,
-    /// The system will continue to the specified recovery target.
-    Continue(RecoveryTarget),
-}
-
-/// Opaque boot token generated by `mark_boot_attempt` and consumed by `kernel_jump`.
-/// Used to mandate that `mark_boot_attempt` is called **exactly** once continuing boot.
-///
-/// Custom structs that implement Manager should take a BootToken as an injected parameter
-/// on construction and return it on the first successful call to mark_boot_attempt.
-#[derive(Debug, PartialEq, Eq)]
-pub struct BootToken(pub(crate) ());
-
-/// The boot slot manager trait.
-/// Responsible for setting boot slot policy and abstracting over on-disk/in-memory
-/// representation of slot metadata.
-pub trait Manager: private::SlotGet {
-    /// Returns an iterator over all regular slots on the system.
-    fn slots_iter(&self) -> SlotIterator;
-
-    /// Returns the current active slot,
-    /// or Recovery if the system will try to boot to recovery.
-    fn get_boot_target(&self) -> Result<BootTarget, Error>;
-
-    /// Returns the slot last set active.
-    /// Note that this is different from get_boot_target in that
-    /// the slot last set active cannot be Recovery.
-    fn get_slot_last_set_active(&self) -> Result<Slot, Error> {
-        self.slots_iter()
-            .max_by_key(|slot| (slot.priority, slot.suffix.rank()))
-            .ok_or(Error::Other(Some("Couldn't get slot last set active")))
-    }
-
-    /// Updates internal metadata (usually the retry count)
-    /// indicating that the system will have tried to boot the current active slot.
-    /// Returns Ok(BootToken) on success to verify that boot attempt metadata has been updated.
-    /// The token must be consumed by `kernel_jump`.
-    ///
-    /// If the current boot target is a recovery target,
-    /// or if the oneshot target is a recovery target,
-    /// no metadata is updated but the boot token is still returned.
-    ///
-    /// Returns Err if `mark_boot_attempt` has already been called.
-    ///
-    /// Note: mark_boot_attempt is NOT idempotent.
-    /// It is intended to be called EXACTLY once,
-    /// right before jumping into the kernel.
-    fn mark_boot_attempt(&mut self) -> Result<BootToken, Error>;
-
-    /// Attempts to set the active slot.
-    ///
-    /// Can return Err if the designated slot does not exist,
-    /// if the bootloader does not have permission to set slots active,
-    /// or for other, backend policy reasons.
-    fn set_active_slot(&mut self, slot_suffix: Suffix) -> Result<(), Error>;
-
-    /// Attempts to mark a slot as unbootable.
-    fn set_slot_unbootable(
-        &mut self,
-        slot_suffix: Suffix,
-        reason: UnbootableReason,
-    ) -> Result<(), Error>;
-
-    /// Default for initial tries
-    fn get_max_retries(&self) -> Result<Tries, Error> {
-        Ok(7u8.into())
-    }
-
-    /// Optional oneshot boot support
-
-    /// Gets the current oneshot boot status,
-    /// or None if the system will try to boot normally.
-    ///
-    /// Oneshots are a special feature for temporarily bypassing
-    /// normal boot flow logic.
-    /// This can be used as part of device flashing, for tests, or interactive development.
-    fn get_oneshot_status(&self) -> Option<OneShot> {
-        None
-    }
-
-    /// Attempts to set the oneshot boot status.
-    ///
-    /// Returns Err if the system does not support oneshot boot,
-    /// if the designated slot does not exist,
-    /// or for other, backend reasons.
-    fn set_oneshot_status(&mut self, _: OneShot) -> Result<(), Error> {
-        Err(Error::OperationProhibited)
-    }
-
-    /// Clears the oneshot status.
-    fn clear_oneshot_status(&mut self);
-
-    /// If the slot manager caches changes before writing to a backing store,
-    /// writes back and sets the cache status to clean.
-    /// The implementation is responsible for handling any errors,
-    /// e.g. ignoring, logging, or aborting.
-    ///
-    /// This is useful for partition based slot setups,
-    /// where we do not write back every interaction in order to coalesce writes
-    /// and preserve disk lifetime.
-    fn write_back(&mut self, _: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {}
-}
-
-/// RAII helper object for coalescing changes.
-pub struct Cursor<'a> {
-    /// The backing manager for slot metadata.
-    pub ctx: &'a mut dyn Manager,
-    /// User provided closure for persisting slot metadata bytes.
-    pub persist: &'a mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
-}
-
-impl Drop for Cursor<'_> {
-    fn drop(&mut self) {
-        self.ctx.write_back(&mut self.persist);
-    }
-}
-
-/// Contains information of the platform's slot scheme.
-#[derive(Default, Debug, Copy, Clone)]
-pub struct SlotsMetadata {
-    /// Number of slots on this platform.
-    pub slot_count: usize,
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use core::ffi::CStr;
-
-    #[test]
-    fn test_suffix_to_cstr() {
-        let normal: Suffix = 'a'.into();
-        let normal_buffer: SuffixBytes = normal.into();
-        let normal_cstr = CStr::from_bytes_until_nul(&normal_buffer);
-        assert!(normal_cstr.is_ok());
-
-        // All UTF-8 characters are at most 4 bytes.
-        // The in-memory representation as a chr or Suffix
-        // uses all 4 bytes regardless of the length of the serialized
-        // representation, but we need to make sure that buffer for
-        // the serialized suffix can handle that too.
-        // All emoji are 4 bytes when encoded as UTF-8,
-        // so they're a reasonable test.
-        let squid: Suffix = ''.into();
-        let squid_buffer: SuffixBytes = squid.into();
-        let squid_cstr = CStr::from_bytes_until_nul(&squid_buffer);
-        assert!(squid_cstr.is_ok());
-    }
-}
diff --git a/gbl/libgbl/src/slots/android.rs b/gbl/libgbl/src/slots/android.rs
deleted file mode 100644
index af11c2e..0000000
--- a/gbl/libgbl/src/slots/android.rs
+++ /dev/null
@@ -1,599 +0,0 @@
-// Copyright (C) 2024  Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use super::partition::{MetadataBytes, SlotBlock};
-use super::{
-    BootTarget, BootToken, Bootability, Manager, OneShot, RecoveryTarget, Slot, SlotIterator,
-    Suffix, UnbootableReason,
-};
-
-use core::convert::TryInto;
-use core::iter::zip;
-use core::mem::size_of;
-use core::ops::{BitAnd, BitOr, Not, Shl, Shr};
-use crc32fast::Hasher;
-use liberror::Error;
-use zerocopy::byteorder::little_endian::U32 as LittleEndianU32;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref, SplitByteSlice};
-
-extern crate static_assertions;
-
-const MAX_SLOTS: u8 = 4;
-
-// TODO(b/332338968): remove the manual field definitions and use bindgen definitions.
-
-// Helper function to extract values from bitfields.
-// Preconditions:
-// 1) All bits in a bitfield are consecutive.
-// 1a) No fields interleave their bits.
-// 2) `offset` defines the position of the least significant bit in the field.
-// 3) If a bit is set in `mask`, all bits of lower significance are set.
-// 4) If a bit is NOT set in `mask`, all bits of greater significanec are NOT set.
-fn get_field<N, R>(base: N, offset: N, mask: N) -> R
-where
-    N: Shr<Output = N> + BitAnd<Output = N>,
-    R: Default + TryFrom<N>,
-{
-    ((base >> offset) & mask).try_into().unwrap_or_default()
-}
-
-// Helper function to set values in bit fields.
-// All the preconditions for `get_field` apply.
-// Returns the modified field. It is the caller's responsibility
-// to assign the result appropriately.
-fn set_field<N, R>(base: N, val: R, offset: N, mask: N) -> N
-where
-    N: Copy + Shl<Output = N> + BitAnd<Output = N> + BitOr<Output = N> + Not<Output = N>,
-    R: Into<N>,
-{
-    (base & !(mask << offset)) | ((val.into() & mask) << offset)
-}
-
-const DEFAULT_PRIORITY: u8 = 7;
-const DEFAULT_RETRIES: u8 = 7;
-
-/// Android reference implementation for slot-specific metadata.
-/// See `BootloaderControl` for more background information.
-///
-/// Does NOT contain unbootable reason information.
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Immutable, IntoBytes, FromBytes, KnownLayout)]
-struct SlotMetaData(u16);
-
-#[allow(dead_code)]
-#[allow(missing_docs)]
-impl SlotMetaData {
-    const PRIORITY_MASK: u16 = 0b1111;
-    const PRIORITY_OFFSET: u16 = 0;
-
-    const TRIES_MASK: u16 = 0b111;
-    const TRIES_OFFSET: u16 = 4;
-
-    const SUCCESSFUL_MASK: u16 = 0b1;
-    const SUCCESSFUL_OFFSET: u16 = 7;
-
-    const VERITY_CORRUPTED_MASK: u16 = 0b1;
-    const VERITY_CORRUPTED_OFFSET: u16 = 8;
-
-    fn priority(&self) -> u8 {
-        get_field(self.0, Self::PRIORITY_OFFSET, Self::PRIORITY_MASK)
-    }
-    fn set_priority(&mut self, priority: u8) {
-        self.0 = set_field(self.0, priority, Self::PRIORITY_OFFSET, Self::PRIORITY_MASK)
-    }
-
-    fn tries(&self) -> u8 {
-        get_field(self.0, Self::TRIES_OFFSET, Self::TRIES_MASK)
-    }
-    fn set_tries(&mut self, tries: u8) {
-        self.0 = set_field(self.0, tries, Self::TRIES_OFFSET, Self::TRIES_MASK)
-    }
-
-    fn successful(&self) -> bool {
-        get_field::<_, u8>(self.0, Self::SUCCESSFUL_OFFSET, Self::SUCCESSFUL_MASK) != 0
-    }
-    fn set_successful(&mut self, successful: bool) {
-        self.0 = set_field(self.0, successful, Self::SUCCESSFUL_OFFSET, Self::SUCCESSFUL_MASK);
-    }
-
-    fn verity_corrupted(&self) -> bool {
-        get_field::<_, u8>(self.0, Self::VERITY_CORRUPTED_OFFSET, Self::VERITY_CORRUPTED_MASK) != 0
-    }
-    fn set_verity_corrupted(&mut self, verity_corrupted: bool) {
-        self.0 = set_field(
-            self.0,
-            verity_corrupted,
-            Self::VERITY_CORRUPTED_OFFSET,
-            Self::VERITY_CORRUPTED_MASK,
-        );
-    }
-}
-static_assertions::const_assert_eq!(
-    core::mem::size_of::<SlotMetaData>(),
-    core::mem::size_of::<u16>()
-);
-
-impl Default for SlotMetaData {
-    fn default() -> Self {
-        let mut val = Self(0);
-        val.set_priority(DEFAULT_PRIORITY);
-        val.set_tries(DEFAULT_RETRIES);
-
-        val
-    }
-}
-
-#[derive(
-    Copy, Clone, Debug, Default, PartialEq, Eq, Immutable, IntoBytes, FromBytes, KnownLayout,
-)]
-#[repr(C, packed)]
-struct ControlBits(u16);
-
-#[allow(dead_code)]
-#[allow(missing_docs)]
-impl ControlBits {
-    const NB_SLOT_MASK: u16 = 0b111;
-    const NB_SLOT_OFFSET: u16 = 0;
-
-    const RECOVERY_TRIES_MASK: u16 = 0b111;
-    const RECOVERY_TRIES_OFFSET: u16 = 3;
-
-    const MERGE_STATUS_MASK: u16 = 0b111;
-    const MERGE_STATUS_OFFSET: u16 = 6;
-
-    fn nb_slots(&self) -> u8 {
-        core::cmp::min(get_field(self.0, Self::NB_SLOT_OFFSET, Self::NB_SLOT_MASK), MAX_SLOTS)
-    }
-    fn set_nb_slots(&mut self, nb_slots: u8) {
-        self.0 = set_field(
-            self.0,
-            core::cmp::min(nb_slots, MAX_SLOTS),
-            Self::NB_SLOT_OFFSET,
-            Self::NB_SLOT_MASK,
-        );
-    }
-
-    fn recovery_tries(&self) -> u8 {
-        get_field(self.0, Self::RECOVERY_TRIES_OFFSET, Self::RECOVERY_TRIES_MASK)
-    }
-    fn set_recovery_tries(&mut self, recovery_tries: u8) {
-        self.0 = set_field(
-            self.0,
-            recovery_tries,
-            Self::RECOVERY_TRIES_OFFSET,
-            Self::RECOVERY_TRIES_MASK,
-        );
-    }
-
-    fn merge_status(&self) -> u8 {
-        get_field(self.0, Self::MERGE_STATUS_OFFSET, Self::MERGE_STATUS_MASK)
-    }
-    fn set_merge_status(&mut self, merge_status: u8) {
-        self.0 =
-            set_field(self.0, merge_status, Self::MERGE_STATUS_OFFSET, Self::MERGE_STATUS_MASK);
-    }
-}
-
-const BOOT_CTRL_MAGIC: u32 = 0x42414342;
-const BOOT_CTRL_VERSION: u8 = 1;
-
-/// The reference implementation for Android A/B bootloader message structures.
-/// It is designed to be put in the `slot_suffix` field of the `bootloader_message`
-/// structure described bootloader_message.h.
-///
-/// See //hardware/interfaces/boot/1.1/default/boot_control/libboot_control.cpp
-/// and //hardware/interfaces/boot/1.1/default/boot_control/include/private/boot_control_definition.h
-/// for structure definition and semantics.
-///
-/// Does NOT support oneshots
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Immutable, IntoBytes, FromBytes, KnownLayout)]
-struct BootloaderControl {
-    slot_suffix: [u8; 4],
-    magic: u32,
-    version: u8,
-    control_bits: ControlBits,
-    reserved0: [u8; 1],
-    slot_metadata: [SlotMetaData; MAX_SLOTS as usize],
-    reserved1: [u8; 8],
-    crc32: LittleEndianU32,
-}
-static_assertions::const_assert_eq!(core::mem::size_of::<BootloaderControl>(), 32);
-
-impl BootloaderControl {
-    fn calculate_crc32(&self) -> u32 {
-        let mut hasher = Hasher::new();
-        hasher.update(&self.as_bytes()[..(size_of::<Self>() - size_of::<LittleEndianU32>())]);
-        hasher.finalize()
-    }
-}
-
-impl Default for BootloaderControl {
-    fn default() -> Self {
-        let mut data = Self {
-            slot_suffix: Default::default(),
-            magic: BOOT_CTRL_MAGIC,
-            version: BOOT_CTRL_VERSION,
-            control_bits: Default::default(),
-            reserved0: Default::default(),
-            slot_metadata: Default::default(),
-            reserved1: Default::default(),
-            crc32: LittleEndianU32::ZERO,
-        };
-        // The slot suffix field stores the current active slot,
-        // which starts as the first one.
-        // Notice that it stores the entire suffix,
-        // including the leading underscore.
-        '_'.encode_utf8(&mut data.slot_suffix[0..]);
-        'a'.encode_utf8(&mut data.slot_suffix[1..]);
-        data.control_bits.set_nb_slots(4);
-        data.crc32.set(data.calculate_crc32());
-        data
-    }
-}
-
-impl MetadataBytes for BootloaderControl {
-    fn validate<B: SplitByteSlice>(buffer: B) -> Result<Ref<B, Self>, Error> {
-        let boot_control_data = Ref::<B, Self>::new_from_prefix(buffer)
-            .ok_or(Error::BufferTooSmall(Some(size_of::<BootloaderControl>())))?
-            .0;
-
-        if boot_control_data.magic != BOOT_CTRL_MAGIC {
-            return Err(Error::BadMagic);
-        }
-        if boot_control_data.version > BOOT_CTRL_VERSION {
-            return Err(Error::UnsupportedVersion);
-        }
-        if boot_control_data.crc32.get() != boot_control_data.calculate_crc32() {
-            return Err(Error::BadChecksum);
-        }
-
-        Ok(boot_control_data)
-    }
-
-    fn prepare_for_sync(&mut self) {
-        self.crc32 = self.calculate_crc32().into();
-    }
-}
-
-impl super::private::SlotGet for SlotBlock<BootloaderControl> {
-    fn get_slot_by_number(&self, number: usize) -> Result<Slot, Error> {
-        let lower_ascii_suffixes = ('a'..='z').map(Suffix);
-        let control = self.get_data();
-        let (suffix, &slot_data) = zip(lower_ascii_suffixes, control.slot_metadata.iter())
-            // Note: there may be fewer slots than the maximum possible
-            .take(control.control_bits.nb_slots().into())
-            .nth(number)
-            .ok_or(Error::BadIndex(number))?;
-
-        let bootability = match (slot_data.successful(), slot_data.tries()) {
-            (true, _) => Bootability::Successful,
-            (false, t) if t > 0 => Bootability::Retriable(t.into()),
-            (_, _) => Bootability::Unbootable(UnbootableReason::Unknown),
-        };
-
-        Ok(Slot { suffix, priority: slot_data.priority().into(), bootability })
-    }
-}
-
-impl Manager for SlotBlock<BootloaderControl> {
-    fn slots_iter(&self) -> SlotIterator {
-        SlotIterator::new(self)
-    }
-
-    fn get_boot_target(&self) -> Result<BootTarget, Error> {
-        Ok(self
-            .slots_iter()
-            .filter(Slot::is_bootable)
-            .max_by_key(|slot| (slot.priority, slot.suffix.rank()))
-            .map_or(
-                // TODO(b/326253270): how is the recovery slot actually determined?
-                BootTarget::Recovery(RecoveryTarget::Slotted(self.get_slot_last_set_active()?)),
-                BootTarget::NormalBoot,
-            ))
-    }
-
-    fn set_slot_unbootable(
-        &mut self,
-        slot_suffix: Suffix,
-        reason: UnbootableReason,
-    ) -> Result<(), Error> {
-        let (idx, slot) = self
-            .slots_iter()
-            .enumerate()
-            .find(|(_, slot)| slot.suffix == slot_suffix)
-            .ok_or(Error::InvalidInput)?;
-        if slot.bootability == Bootability::Unbootable(reason) {
-            return Ok(());
-        }
-
-        let slot_data = &mut self.get_mut_data().slot_metadata[idx];
-        slot_data.set_tries(0);
-        slot_data.set_successful(false);
-
-        Ok(())
-    }
-
-    fn mark_boot_attempt(&mut self) -> Result<BootToken, Error> {
-        let target_slot = match self.get_boot_target()? {
-            BootTarget::NormalBoot(slot) => slot,
-            BootTarget::Recovery(RecoveryTarget::Dedicated) => Err(Error::OperationProhibited)?,
-            BootTarget::Recovery(RecoveryTarget::Slotted(slot)) => {
-                self.slots_iter().find(|s| s.suffix == slot.suffix).ok_or(Error::InvalidInput)?;
-                return self.take_boot_token().ok_or(Error::OperationProhibited);
-            }
-        };
-
-        let (idx, slot) = self
-            .slots_iter()
-            .enumerate()
-            .find(|(_, slot)| slot.suffix == target_slot.suffix)
-            .ok_or(Error::InvalidInput)?;
-        match slot.bootability {
-            Bootability::Unbootable(_) => Err(Error::OperationProhibited),
-            Bootability::Retriable(_) => {
-                let metadata = &mut self.get_mut_data().slot_metadata[idx];
-                metadata.set_tries(metadata.tries() - 1);
-                let token = self.take_boot_token().ok_or(Error::OperationProhibited)?;
-                Ok(token)
-            }
-            Bootability::Successful => {
-                let token = self.take_boot_token().ok_or(Error::OperationProhibited)?;
-                Ok(token)
-            }
-        }
-    }
-
-    fn set_active_slot(&mut self, slot_suffix: Suffix) -> Result<(), Error> {
-        let idx =
-            self.slots_iter().position(|s| s.suffix == slot_suffix).ok_or(Error::InvalidInput)?;
-
-        let data = self.get_mut_data();
-        for (i, slot) in data.slot_metadata.iter_mut().enumerate() {
-            if i == idx {
-                *slot = Default::default();
-            } else {
-                slot.set_priority(DEFAULT_PRIORITY - 1);
-            }
-        }
-
-        // Note: we know this is safe because the slot suffix is an ASCII char,
-        // which is only 1 byte long in utf8.
-        // The 0th element of self.data.slot_suffix is an underscore character.
-        slot_suffix.0.encode_utf8(&mut self.get_mut_data().slot_suffix[1..]);
-
-        Ok(())
-    }
-
-    fn set_oneshot_status(&mut self, _: OneShot) -> Result<(), Error> {
-        Err(Error::OperationProhibited)
-    }
-
-    fn clear_oneshot_status(&mut self) {}
-
-    fn write_back(&mut self, persist: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {
-        self.sync_to_disk(persist)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::slots::{android::BootloaderControl, partition::MetadataBytes};
-
-    #[test]
-    fn test_slot_block_defaults() {
-        let sb: SlotBlock<BootloaderControl> = Default::default();
-        let expected: Vec<Slot> = ('a'..='d')
-            .map(|c| Slot {
-                suffix: c.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
-            })
-            .collect();
-        let actual: Vec<Slot> = sb.slots_iter().collect();
-        assert_eq!(actual, expected);
-        assert_eq!(sb.get_oneshot_status(), None);
-        assert_eq!(sb.get_boot_target().unwrap(), BootTarget::NormalBoot(expected[0]));
-        // Include the explicit null bytes for safety.
-        assert_eq!(sb.get_data().slot_suffix.as_slice(), "_a\0\0".as_bytes());
-    }
-
-    #[test]
-    fn test_slot_block_fewer_slots() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        sb.get_mut_data().control_bits.set_nb_slots(2);
-
-        let expected: Vec<Slot> = ('a'..='b')
-            .map(|c| Slot {
-                suffix: c.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
-            })
-            .collect();
-        let actual: Vec<Slot> = sb.slots_iter().collect();
-        assert_eq!(actual, expected);
-    }
-
-    #[test]
-    fn test_slot_block_slot_count_saturates() {
-        let mut ctrl: BootloaderControl = Default::default();
-        ctrl.control_bits.set_nb_slots(255);
-        assert_eq!(ctrl.control_bits.nb_slots(), MAX_SLOTS);
-
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        sb.get_mut_data().control_bits.set_nb_slots(255);
-        assert_eq!(sb.slots_iter().count(), MAX_SLOTS.into());
-    }
-
-    #[test]
-    fn test_slot_block_parse() {
-        let boot_ctrl: BootloaderControl = Default::default();
-        assert_eq!(
-            BootloaderControl::validate(boot_ctrl.as_bytes()),
-            Ok(Ref::new(boot_ctrl.as_bytes()).unwrap())
-        );
-    }
-
-    #[test]
-    fn test_slot_block_parse_buffer_too_small() {
-        let buffer: [u8; 0] = Default::default();
-        assert_eq!(
-            BootloaderControl::validate(buffer.as_slice()),
-            Err(Error::BufferTooSmall(Some(size_of::<BootloaderControl>())))
-        );
-    }
-
-    #[test]
-    fn test_slot_block_parse_bad_magic() {
-        let mut boot_ctrl: BootloaderControl = Default::default();
-        boot_ctrl.magic += 1;
-        assert_eq!(BootloaderControl::validate(boot_ctrl.as_bytes()), Err(Error::BadMagic));
-    }
-
-    #[test]
-    fn test_slot_block_parse_bad_version() {
-        let mut boot_ctrl: BootloaderControl = Default::default();
-        boot_ctrl.version = 15;
-        assert_eq!(
-            BootloaderControl::validate(boot_ctrl.as_bytes()),
-            Err(Error::UnsupportedVersion)
-        );
-    }
-
-    #[test]
-    fn test_slot_block_parse_bad_crc() {
-        let mut boot_ctrl: BootloaderControl = Default::default();
-        let bad_crc = boot_ctrl.crc32.get() ^ LittleEndianU32::MAX_VALUE.get();
-        boot_ctrl.crc32 = bad_crc.into();
-        assert_eq!(BootloaderControl::validate(boot_ctrl.as_bytes()), Err(Error::BadChecksum));
-    }
-
-    #[test]
-    fn test_get_boot_target_recovery() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        sb.get_mut_data().slot_metadata.iter_mut().for_each(|bits| bits.set_tries(0));
-        let a_slot = sb.slots_iter().next().unwrap();
-
-        assert_eq!(
-            sb.get_boot_target().unwrap(),
-            BootTarget::Recovery(RecoveryTarget::Slotted(a_slot))
-        );
-    }
-
-    #[test]
-    fn test_get_boot_target_recovery_nondefault_recovery_slot() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        let b_suffix: Suffix = 'b'.into();
-        assert!(sb.set_active_slot(b_suffix).is_ok());
-        sb.get_mut_data().slot_metadata.iter_mut().for_each(|bits| bits.set_tries(0));
-        let b_slot = sb.slots_iter().find(|s| s.suffix == b_suffix).unwrap();
-
-        assert_eq!(
-            sb.get_boot_target().unwrap(),
-            BootTarget::Recovery(RecoveryTarget::Slotted(b_slot))
-        );
-    }
-
-    #[test]
-    fn test_get_slot_last_set_active() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        let v: Vec<Slot> = sb.slots_iter().collect();
-        assert_eq!(sb.set_active_slot(v[1].suffix), Ok(()));
-        assert_eq!(sb.get_slot_last_set_active().unwrap(), v[1]);
-        for slot in v.iter() {
-            assert_eq!(sb.set_slot_unbootable(slot.suffix, UnbootableReason::NoMoreTries), Ok(()));
-        }
-
-        assert_eq!(sb.get_slot_last_set_active().unwrap(), sb.slots_iter().nth(1).unwrap());
-        assert_eq!(sb.get_data().slot_suffix.as_slice(), "_b\0\0".as_bytes());
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        let slot = Slot { suffix: 'a'.into(), ..Default::default() };
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(
-            sb.slots_iter().next().unwrap(),
-            Slot {
-                suffix: slot.suffix,
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable((DEFAULT_RETRIES - 1).into())
-            }
-        );
-
-        // Make sure we can call exactly once
-        assert_eq!(sb.mark_boot_attempt(), Err(Error::OperationProhibited));
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt_no_more_tries() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        sb.get_mut_data().slot_metadata[0].set_tries(1);
-        let slot = Slot { suffix: 'a'.into(), ..Default::default() };
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(
-            sb.slots_iter().next().unwrap(),
-            Slot {
-                suffix: slot.suffix,
-                priority: DEFAULT_PRIORITY.into(),
-                // Default implementation does not track unbootable reasons
-                bootability: Bootability::Unbootable(UnbootableReason::Unknown)
-            }
-        );
-        assert_eq!(sb.get_data().slot_metadata[0].tries(), 0);
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt_successful() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        let initial_tries;
-        {
-            let metadata = &mut sb.get_mut_data().slot_metadata[0];
-            initial_tries = metadata.tries();
-            metadata.set_successful(true);
-        }
-        let target = BootTarget::NormalBoot(Slot {
-            suffix: 'a'.into(),
-            priority: DEFAULT_PRIORITY.into(),
-            bootability: Bootability::Successful,
-        });
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(BootTarget::NormalBoot(sb.slots_iter().next().unwrap()), target);
-        assert_eq!(sb.get_data().slot_metadata[0].tries(), initial_tries);
-    }
-
-    #[test]
-    fn test_mark_slot_tried_slotted_recovery() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        assert!(sb.set_slot_unbootable('a'.into(), UnbootableReason::UserRequested).is_ok());
-        assert!(sb.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested).is_ok());
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-    }
-
-    #[test]
-    fn test_set_oneshot_status_unsupported() {
-        let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        let oneshots = [
-            OneShot::Bootloader,
-            OneShot::Continue(RecoveryTarget::Dedicated),
-            OneShot::Continue(RecoveryTarget::Slotted(sb.get_slot_last_set_active().unwrap())),
-        ];
-
-        for oneshot in oneshots {
-            assert_eq!(sb.set_oneshot_status(oneshot), Err(Error::OperationProhibited));
-        }
-    }
-}
diff --git a/gbl/libgbl/src/slots/fuchsia.rs b/gbl/libgbl/src/slots/fuchsia.rs
deleted file mode 100644
index 4cc7011..0000000
--- a/gbl/libgbl/src/slots/fuchsia.rs
+++ /dev/null
@@ -1,664 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-extern crate bitflags;
-extern crate crc32fast;
-extern crate zerocopy;
-
-use super::partition::{MetadataBytes, SlotBlock};
-use super::{
-    BootTarget, BootToken, Bootability, Manager, OneShot, RecoveryTarget, Slot, SlotIterator,
-    Suffix, UnbootableReason,
-};
-use bitflags::bitflags;
-use core::iter::zip;
-use core::mem::size_of;
-use crc32fast::Hasher;
-use liberror::Error;
-use zerocopy::byteorder::big_endian::U32 as BigEndianU32;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref, SplitByteSlice};
-
-const DEFAULT_PRIORITY: u8 = 15;
-const DEFAULT_RETRIES: u8 = 7;
-
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Immutable, IntoBytes, FromBytes, KnownLayout)]
-struct AbrSlotData {
-    priority: u8,
-    tries: u8,
-    successful: u8,
-    unbootable_reason: u8,
-}
-
-impl Default for AbrSlotData {
-    fn default() -> Self {
-        Self {
-            priority: DEFAULT_PRIORITY,
-            tries: DEFAULT_RETRIES,
-            successful: 0,
-            unbootable_reason: 0,
-        }
-    }
-}
-
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Immutable, IntoBytes, FromBytes, KnownLayout)]
-struct OneShotFlags(u8);
-
-bitflags! {
-    impl OneShotFlags: u8 {
-        /// No oneshot specified
-        const NONE = 0;
-        /// Oneshot boot to recovery mode
-        const RECOVERY = 1 << 0;
-        /// Oneshot boot to fastboot
-        const BOOTLOADER = 1 << 1;
-    }
-}
-
-impl From<OneShotFlags> for Option<OneShot> {
-    fn from(flags: OneShotFlags) -> Self {
-        match flags {
-            OneShotFlags::RECOVERY => Some(OneShot::Continue(RecoveryTarget::Dedicated)),
-            OneShotFlags::BOOTLOADER => Some(OneShot::Bootloader),
-            _ => None,
-        }
-    }
-}
-
-impl From<Option<OneShot>> for OneShotFlags {
-    fn from(oneshot: Option<OneShot>) -> Self {
-        if let Some(target) = oneshot {
-            match target {
-                OneShot::Bootloader => Self::BOOTLOADER,
-                OneShot::Continue(RecoveryTarget::Dedicated) => Self::RECOVERY,
-                _ => Self::NONE,
-            }
-        } else {
-            Self::NONE
-        }
-    }
-}
-
-const ABR_MAGIC: &[u8; 4] = b"\0AB0";
-const ABR_VERSION_MAJOR: u8 = 2;
-const ABR_VERSION_MINOR: u8 = 3;
-
-#[repr(C, packed)]
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Immutable, IntoBytes, FromBytes, KnownLayout)]
-struct AbrData {
-    magic: [u8; 4],
-    version_major: u8,
-    version_minor: u8,
-    reserved: [u8; 2],
-    slot_data: [AbrSlotData; 2],
-    oneshot_flag: OneShotFlags,
-    reserved2: [u8; 11],
-    crc32: BigEndianU32,
-}
-
-impl AbrData {
-    fn calculate_crc32(&self) -> u32 {
-        let mut hasher = Hasher::new();
-        // Note: core::offset_of isn't stable yet,
-        // and size_of_val isn't permitted on unaligned structs.
-        hasher.update(&self.as_bytes()[..(size_of::<Self>() - size_of::<BigEndianU32>())]);
-        hasher.finalize()
-    }
-}
-
-impl MetadataBytes for AbrData {
-    fn validate<B: SplitByteSlice>(buffer: B) -> Result<Ref<B, AbrData>, Error> {
-        let abr_data = Ref::<B, AbrData>::new_from_prefix(buffer)
-            .ok_or(Error::BufferTooSmall(Some(size_of::<AbrData>())))?
-            .0;
-
-        if abr_data.magic != *ABR_MAGIC {
-            return Err(Error::BadMagic);
-        }
-        if abr_data.version_major > ABR_VERSION_MAJOR {
-            return Err(Error::UnsupportedVersion);
-        }
-        if abr_data.crc32.get() != abr_data.calculate_crc32() {
-            return Err(Error::BadChecksum);
-        }
-
-        Ok(abr_data)
-    }
-
-    fn prepare_for_sync(&mut self) {
-        self.version_minor = ABR_VERSION_MINOR;
-        self.crc32 = self.calculate_crc32().into();
-    }
-}
-
-impl Default for AbrData {
-    fn default() -> Self {
-        let mut data = Self {
-            magic: *ABR_MAGIC,
-            version_major: ABR_VERSION_MAJOR,
-            version_minor: ABR_VERSION_MINOR,
-            reserved: Default::default(),
-            slot_data: Default::default(),
-            oneshot_flag: OneShotFlags::NONE,
-            reserved2: Default::default(),
-            crc32: BigEndianU32::ZERO,
-        };
-        data.crc32.set(data.calculate_crc32());
-        data
-    }
-}
-
-impl super::private::SlotGet for SlotBlock<AbrData> {
-    fn get_slot_by_number(&self, number: usize) -> Result<Slot, Error> {
-        let lower_ascii_suffixes = ('a'..='z').map(Suffix);
-        let (suffix, &abr_slot) = zip(lower_ascii_suffixes, self.get_data().slot_data.iter())
-            .nth(number)
-            .ok_or(Error::BadIndex(number))?;
-
-        let bootability = match (abr_slot.successful, abr_slot.tries) {
-            (s, _) if s != 0 => Bootability::Successful,
-            (0, t) if t > 0 => Bootability::Retriable(t.into()),
-            (_, _) => Bootability::Unbootable(abr_slot.unbootable_reason.into()),
-        };
-
-        Ok(Slot { suffix, priority: abr_slot.priority.into(), bootability })
-    }
-}
-
-impl Manager for SlotBlock<AbrData> {
-    fn get_boot_target(&self) -> Result<BootTarget, Error> {
-        Ok(self
-            .slots_iter()
-            .filter(Slot::is_bootable)
-            .max_by_key(|slot| (slot.priority, slot.suffix.rank()))
-            .map_or(BootTarget::Recovery(RecoveryTarget::Dedicated), BootTarget::NormalBoot))
-    }
-
-    fn slots_iter(&self) -> SlotIterator {
-        SlotIterator::new(self)
-    }
-
-    fn set_slot_unbootable(
-        &mut self,
-        slot_suffix: Suffix,
-        reason: UnbootableReason,
-    ) -> Result<(), Error> {
-        let (idx, slot) = self.get_index_and_slot_with_suffix(slot_suffix)?;
-        if slot.bootability == Bootability::Unbootable(reason) {
-            return Ok(());
-        }
-
-        let abr_data = self.get_mut_data();
-        let slot_data = &mut abr_data.slot_data[idx];
-        slot_data.unbootable_reason = reason.into();
-        slot_data.tries = 0;
-        slot_data.successful = 0;
-
-        Ok(())
-    }
-
-    fn mark_boot_attempt(&mut self) -> Result<BootToken, Error> {
-        let target = if let Some(OneShot::Continue(r)) = self.get_oneshot_status() {
-            BootTarget::Recovery(r)
-        } else {
-            self.get_boot_target()?
-        };
-        let target_slot = match target {
-            BootTarget::NormalBoot(slot) => slot,
-            BootTarget::Recovery(RecoveryTarget::Slotted(_)) => Err(Error::OperationProhibited)?,
-            BootTarget::Recovery(RecoveryTarget::Dedicated) => {
-                // Even though boot to recovery does not cause a metadata update,
-                // we still need to gate access to the boot token.
-                return self.take_boot_token().ok_or(Error::OperationProhibited);
-            }
-        };
-
-        let (idx, slot) = self.get_index_and_slot_with_suffix(target_slot.suffix)?;
-
-        match slot.bootability {
-            Bootability::Unbootable(_) => Err(Error::OperationProhibited),
-            Bootability::Retriable(_) => {
-                let abr_slot = &mut self.get_mut_data().slot_data[idx];
-                abr_slot.tries -= 1;
-                if abr_slot.tries == 0 {
-                    abr_slot.unbootable_reason = UnbootableReason::NoMoreTries.into();
-                }
-                let token = self.take_boot_token().ok_or(Error::OperationProhibited)?;
-                Ok(token)
-            }
-            Bootability::Successful => {
-                let token = self.take_boot_token().ok_or(Error::OperationProhibited)?;
-                Ok(token)
-            }
-        }
-    }
-
-    fn set_active_slot(&mut self, slot_suffix: Suffix) -> Result<(), Error> {
-        let (idx, _) = self.get_index_and_slot_with_suffix(slot_suffix)?;
-
-        let abr_data = self.get_mut_data();
-        for (i, slot) in abr_data.slot_data.iter_mut().enumerate() {
-            if i == idx {
-                *slot = Default::default();
-            } else {
-                slot.priority = DEFAULT_PRIORITY - 1;
-            }
-        }
-        Ok(())
-    }
-
-    fn get_oneshot_status(&self) -> Option<OneShot> {
-        self.get_data().oneshot_flag.into()
-    }
-
-    fn set_oneshot_status(&mut self, oneshot: OneShot) -> Result<(), Error> {
-        if Some(oneshot) == self.get_oneshot_status() {
-            return Ok(());
-        }
-
-        let oneshot_flag = OneShotFlags::from(Some(oneshot));
-        if oneshot_flag == OneShotFlags::NONE {
-            Err(Error::OperationProhibited)
-        } else {
-            self.get_mut_data().oneshot_flag = oneshot_flag;
-            Ok(())
-        }
-    }
-
-    fn clear_oneshot_status(&mut self) {
-        if self.get_oneshot_status().is_some() {
-            self.get_mut_data().oneshot_flag = OneShotFlags::NONE;
-        }
-    }
-
-    fn write_back(&mut self, persist: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {
-        self.sync_to_disk(persist);
-    }
-}
-
-impl<'a> SlotBlock<AbrData> {
-    fn get_index_and_slot_with_suffix(&self, slot_suffix: Suffix) -> Result<(usize, Slot), Error> {
-        self.slots_iter()
-            .enumerate()
-            .find(|(_, s)| s.suffix == slot_suffix)
-            .ok_or(Error::InvalidInput)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::slots::{partition::CacheStatus, Cursor};
-    use gbl_async::block_on;
-    use gbl_storage::{new_gpt_max, Disk, RamBlockIo};
-
-    #[test]
-    fn test_slot_block_defaults() {
-        let sb: SlotBlock<AbrData> = Default::default();
-        let expected: Vec<Slot> = vec![
-            Slot {
-                suffix: 'a'.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
-            },
-            Slot {
-                suffix: 'b'.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
-            },
-        ];
-        let actual: Vec<Slot> = sb.slots_iter().collect();
-        assert_eq!(actual, expected);
-        assert_eq!(sb.get_oneshot_status(), None);
-    }
-
-    #[test]
-    fn test_suffix() {
-        let slot = Slot { suffix: 'a'.into(), ..Default::default() };
-        assert_eq!(BootTarget::Recovery(RecoveryTarget::Dedicated).suffix(), 'r'.into());
-        assert_eq!(BootTarget::Recovery(RecoveryTarget::Slotted(slot)).suffix(), slot.suffix);
-        assert_eq!(BootTarget::NormalBoot(slot).suffix(), slot.suffix);
-    }
-
-    #[test]
-    fn test_slot_block_parse() {
-        let abr: AbrData = Default::default();
-        assert_eq!(AbrData::validate(abr.as_bytes()), Ok(Ref::new(abr.as_bytes()).unwrap()));
-    }
-
-    #[test]
-    fn test_slot_block_parse_buffer_too_small() {
-        let buffer: [u8; 0] = Default::default();
-        assert_eq!(
-            AbrData::validate(&buffer[..]),
-            Err(Error::BufferTooSmall(Some(size_of::<AbrData>()))),
-        );
-    }
-
-    #[test]
-    fn test_slot_block_parse_bad_magic() {
-        let mut abr: AbrData = Default::default();
-        abr.magic[0] += 1;
-        assert_eq!(AbrData::validate(abr.as_bytes()), Err(Error::BadMagic));
-    }
-
-    #[test]
-    fn test_slot_block_parse_bad_version_major() {
-        let mut abr: AbrData = Default::default();
-        abr.version_major = 15;
-        assert_eq!(AbrData::validate(abr.as_bytes()), Err(Error::UnsupportedVersion));
-    }
-
-    #[test]
-    fn test_slot_block_parse_bad_crc() {
-        let mut abr: AbrData = Default::default();
-        let bad_crc = abr.crc32.get() ^ BigEndianU32::MAX_VALUE.get();
-        abr.crc32 = bad_crc.into();
-        assert_eq!(AbrData::validate(abr.as_bytes()), Err(Error::BadChecksum));
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(
-            sb.slots_iter().next().unwrap(),
-            Slot {
-                suffix: 'a'.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable((DEFAULT_RETRIES - 1).into())
-            }
-        );
-
-        // Make sure we can call exactly once
-        assert_eq!(sb.mark_boot_attempt(), Err(Error::OperationProhibited));
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt_tracks_active() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        assert!(sb.set_active_slot('b'.into()).is_ok());
-
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(
-            sb.get_boot_target().unwrap(),
-            BootTarget::NormalBoot(Slot {
-                suffix: 'b'.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable((DEFAULT_RETRIES - 1).into())
-            })
-        );
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt_no_more_tries() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        sb.get_mut_data().slot_data[0].tries = 1;
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(
-            sb.slots_iter().next().unwrap(),
-            Slot {
-                suffix: 'a'.into(),
-                priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Unbootable(UnbootableReason::NoMoreTries)
-            }
-        );
-    }
-
-    #[test]
-    fn test_slot_mark_boot_attempt_successful() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        sb.get_mut_data().slot_data[0].successful = 1;
-        let target = BootTarget::NormalBoot(Slot {
-            suffix: 'a'.into(),
-            priority: DEFAULT_PRIORITY.into(),
-            bootability: Bootability::Successful,
-        });
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(sb.get_boot_target().unwrap(), target);
-    }
-
-    #[test]
-    fn test_slot_mark_tried_recovery() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        assert!(sb.set_slot_unbootable('a'.into(), UnbootableReason::UserRequested).is_ok());
-        assert!(sb.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested).is_ok());
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-
-        // Make sure a second attempt fails due to the moved boot token
-        assert_eq!(sb.mark_boot_attempt(), Err(Error::OperationProhibited));
-    }
-
-    #[test]
-    fn test_slot_mark_tried_recovery_oneshot() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let tgt = sb.get_boot_target();
-        assert!(sb.set_oneshot_status(OneShot::Continue(RecoveryTarget::Dedicated)).is_ok());
-        assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-
-        // Verify that tries weren't decremented
-        assert_eq!(sb.get_boot_target(), tgt);
-    }
-
-    macro_rules! set_unbootable_tests {
-                ($($name:ident: $value:expr,)*) => {
-                    $(
-                        #[test]
-                        fn $name() {
-                            let mut sb: SlotBlock<AbrData> = Default::default();
-                            let suffix: Suffix = 'a'.into();
-                            assert_eq!(sb.set_slot_unbootable(suffix, $value), Ok(()));
-                            assert_eq!(sb.slots_iter()
-                                       .find(|s| s.suffix == suffix)
-                                       .unwrap()
-                                       .bootability,
-                                       Bootability::Unbootable($value)
-                            );
-                        }
-                    )*
-                }
-            }
-
-    use UnbootableReason::*;
-    set_unbootable_tests! {
-        test_set_unbootable_no_more_tries: NoMoreTries,
-        test_set_unbootable_system_update: SystemUpdate,
-        test_set_unbootable_user_requested: UserRequested,
-        test_set_unbootable_verification_failure: VerificationFailure,
-        test_set_unbootable_unknown: Unknown,
-    }
-
-    #[test]
-    fn test_no_bootable_slots_boot_recovery() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let v: Vec<Slot> = sb.slots_iter().collect();
-        for slot in v {
-            assert_eq!(
-                sb.set_slot_unbootable(slot.suffix, UnbootableReason::UserRequested),
-                Ok(())
-            );
-        }
-        assert_eq!(sb.get_boot_target().unwrap(), BootTarget::Recovery(RecoveryTarget::Dedicated));
-    }
-
-    #[test]
-    fn test_set_active_slot() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let v: Vec<Slot> = sb.slots_iter().collect();
-
-        assert_eq!(sb.get_boot_target().unwrap(), BootTarget::NormalBoot(v[0]));
-        for slot in v.iter() {
-            assert_eq!(sb.set_active_slot(slot.suffix), Ok(()));
-            assert_eq!(sb.get_boot_target().unwrap(), BootTarget::NormalBoot(*slot));
-        }
-    }
-
-    #[test]
-    fn test_set_active_slot_no_such_slot() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let bad_suffix: Suffix = '$'.into();
-        assert_eq!(sb.set_active_slot(bad_suffix), Err(Error::InvalidInput));
-    }
-
-    #[test]
-    fn test_get_slot_last_set_active() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let v: Vec<Slot> = sb.slots_iter().collect();
-        assert_eq!(sb.set_active_slot(v[0].suffix), Ok(()));
-        assert_eq!(sb.get_slot_last_set_active().unwrap(), v[0]);
-        for slot in v.iter() {
-            assert_eq!(sb.set_slot_unbootable(slot.suffix, NoMoreTries), Ok(()));
-        }
-
-        assert_eq!(sb.get_slot_last_set_active().unwrap(), sb.slots_iter().next().unwrap());
-    }
-
-    macro_rules! set_oneshot_tests {
-                ($($name:ident: $value:expr,)*) => {
-                    $(
-                        #[test]
-                        fn $name(){
-                            let mut sb: SlotBlock<AbrData> = Default::default();
-                            assert_eq!(sb.set_oneshot_status($value), Ok(()));
-                            assert_eq!(sb.get_oneshot_status(), Some($value));
-
-                            assert_eq!(sb.get_boot_target().unwrap(),
-                                       BootTarget::NormalBoot(
-                                           Slot{
-                                               suffix: 'a'.into(),
-                                               priority: DEFAULT_PRIORITY.into(),
-                                               bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
-                                           },
-                                       ));
-                        }
-                    )*
-                }
-            }
-
-    set_oneshot_tests! {
-        test_set_oneshot_bootloader: OneShot::Bootloader,
-        test_set_oneshot_recovery: OneShot::Continue(RecoveryTarget::Dedicated),
-    }
-
-    #[test]
-    fn test_clear_oneshot_status() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        assert_eq!(sb.set_oneshot_status(OneShot::Bootloader), Ok(()));
-        sb.clear_oneshot_status();
-        assert_eq!(sb.get_oneshot_status(), None);
-    }
-
-    #[test]
-    fn test_set_oneshot_mistaken_recovery_slotted() {
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let slot = sb.slots_iter().next().unwrap();
-        assert_eq!(
-            sb.set_oneshot_status(OneShot::Continue(RecoveryTarget::Slotted(slot))),
-            Err(Error::OperationProhibited)
-        );
-    }
-
-    #[test]
-    fn test_deserialize_default_to_dirty_cache() {
-        let mut abr_data: AbrData = Default::default();
-        // Changing the success both invalidates the crc
-        // and lets us verify that the deserialized slot block
-        // uses defaulted backing bytes instead of the provided bytes.
-        abr_data.slot_data[0].successful = 1;
-        let sb = SlotBlock::<AbrData>::deserialize(abr_data.as_bytes(), BootToken(()));
-        assert_eq!(sb.cache_status(), CacheStatus::Dirty);
-        assert_eq!(
-            sb.slots_iter().next().unwrap().bootability,
-            Bootability::Retriable(DEFAULT_RETRIES.into())
-        );
-    }
-
-    #[test]
-    fn test_deserialize_modified_to_clean_cache() {
-        let mut abr_data: AbrData = Default::default();
-        abr_data.slot_data[0].successful = 1;
-        // If we recalculate the crc,
-        // that just means we have a metadata block that stores
-        // relevant, non-default information.
-        abr_data.crc32.set(abr_data.calculate_crc32());
-        let sb = SlotBlock::<AbrData>::deserialize(abr_data.as_bytes(), BootToken(()));
-        assert_eq!(sb.cache_status(), CacheStatus::Clean);
-        assert_eq!(sb.slots_iter().next().unwrap().bootability, Bootability::Successful);
-    }
-
-    type TestDisk = Disk<RamBlockIo<Vec<u8>>, Vec<u8>>;
-
-    #[test]
-    fn test_writeback() {
-        const PARTITION: &str = "test_partition";
-        const OFFSET: u64 = 2112; // Deliberately wrong to test propagation of parameter.
-        let disk = include_bytes!("../../testdata/writeback_test_disk.bin").to_vec();
-        let mut blk = TestDisk::new_ram_alloc(512, 512, disk).unwrap();
-        let mut gpt = new_gpt_max();
-        block_on(blk.sync_gpt(&mut gpt)).unwrap();
-        let mut sb: SlotBlock<AbrData> = Default::default();
-        let mut read_buffer: [u8; size_of::<AbrData>()] = Default::default();
-
-        // Clean cache, write_back is a no-op
-        sb.write_back(&mut |data: &mut [u8]| {
-            Ok(block_on(blk.write_gpt_partition(&mut gpt, PARTITION, OFFSET, data))?)
-        });
-        let res =
-            block_on(blk.read_gpt_partition(&mut gpt, PARTITION, OFFSET, &mut read_buffer[..]));
-        assert!(res.is_ok());
-        assert_eq!(read_buffer, [0; std::mem::size_of::<AbrData>()]);
-
-        // Make a change, write_back writes back to the defined partition
-        // at the defined offset.
-        assert_eq!(sb.set_oneshot_status(OneShot::Bootloader), Ok(()));
-        assert_eq!(sb.cache_status(), CacheStatus::Dirty);
-
-        sb.write_back(&mut |data: &mut [u8]| {
-            Ok(block_on(blk.write_gpt_partition(&mut gpt, PARTITION, OFFSET, data))?)
-        });
-        let res =
-            block_on(blk.read_gpt_partition(&mut gpt, PARTITION, OFFSET, &mut read_buffer[..]));
-        assert!(res.is_ok());
-        assert_eq!(read_buffer, sb.get_data().as_bytes());
-        assert_eq!(sb.cache_status(), CacheStatus::Clean);
-    }
-
-    #[test]
-    fn test_writeback_with_cursor() {
-        const PARTITION: &str = "test_partition";
-        const OFFSET: u64 = 2112; // Deliberately wrong to test propagation of parameter.
-        let disk = include_bytes!("../../testdata/writeback_test_disk.bin").to_vec();
-        let mut blk = TestDisk::new_ram_alloc(512, 512, disk).unwrap();
-        let mut gpt = new_gpt_max();
-        block_on(blk.sync_gpt(&mut gpt)).unwrap();
-        let mut read_buffer: [u8; size_of::<AbrData>()] = Default::default();
-
-        let mut sb: SlotBlock<AbrData> = Default::default();
-
-        // New block to trigger drop on the cursor.
-        {
-            let mut persist = |data: &mut [u8]| {
-                Ok(block_on(blk.write_gpt_partition(&mut gpt, PARTITION, OFFSET, data))?)
-            };
-            let cursor = Cursor { ctx: &mut sb, persist: &mut persist };
-            assert!(cursor.ctx.set_active_slot('b'.into()).is_ok());
-        }
-
-        let res =
-            block_on(blk.read_gpt_partition(&mut gpt, PARTITION, OFFSET, &mut read_buffer[..]));
-        assert!(res.is_ok());
-        assert_eq!(read_buffer, sb.get_data().as_bytes());
-    }
-}
diff --git a/gbl/libgbl/src/slots/partition.rs b/gbl/libgbl/src/slots/partition.rs
deleted file mode 100644
index af362e5..0000000
--- a/gbl/libgbl/src/slots/partition.rs
+++ /dev/null
@@ -1,142 +0,0 @@
-// Copyright (C) 2024  Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use super::BootToken;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref, SplitByteSlice};
-
-use liberror::Error;
-
-/// Tracks whether slot metadata differs from on-disk representation.
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum CacheStatus {
-    /// Slot metadata is the same as on disk
-    Clean,
-    /// Slot metadata has been modified
-    Dirty,
-}
-
-/// Trait that describes the operations all slot metadata implementations must support
-/// to be used as the backing store in a SlotBlock.
-pub trait MetadataBytes: Copy + Immutable + IntoBytes + FromBytes + KnownLayout + Default {
-    /// Returns a zerocopy reference to Self if buffer
-    /// represents a valid serialization of Self.
-    /// Implementors should check for invariants,
-    /// e.g. checksums, magic numbers, and version numbers.
-    ///
-    /// Returns Err if the buffer does not represent a valid structure.
-    fn validate<B: SplitByteSlice>(buffer: B) -> Result<Ref<B, Self>, Error>;
-
-    /// Called right before writing metadata back to disk.
-    /// Implementors should restore invariants,
-    /// update checksums, or take other appropriate actions.
-    fn prepare_for_sync(&mut self);
-}
-
-/// Generalized description of a partition-backed ABR metadata structure.
-pub struct SlotBlock<MB: MetadataBytes> {
-    // Internally tracked cache clean/dirty info
-    cache_status: CacheStatus,
-    // SlotBlock holds the boot token until mark_boot_attempt gets called.
-    boot_token: Option<BootToken>,
-    // Serialized slot metadata
-    data: MB,
-}
-
-impl<'a, MB: MetadataBytes> SlotBlock<MB> {
-    /// Note to those implementing Manager for SlotBlock<CustomType>:
-    /// Be very, very careful with custody of the boot token.
-    /// If you release it outside of the implementation of Manager::mark_boot_attempt,
-    /// mark_boot_attempt will fail and the kernel may boot without tracking the attempt.
-    /// If you lose the token, the only way to get it back is to reboot the device.
-    pub fn take_boot_token(&mut self) -> Option<BootToken> {
-        self.boot_token.take()
-    }
-
-    /// Returns a mutable reference to the slot metadata and marks the cache as dirty.
-    pub fn get_mut_data(&mut self) -> &mut MB {
-        self.cache_status = CacheStatus::Dirty;
-        &mut self.data
-    }
-
-    /// Returns an immutable reference to the slot metadata
-    pub fn get_data(&self) -> &MB {
-        &self.data
-    }
-
-    #[cfg(test)]
-    /// Returns the cache status
-    pub fn cache_status(&self) -> CacheStatus {
-        self.cache_status
-    }
-
-    /// Attempt to deserialize a slot control block
-    ///
-    /// # Returns
-    /// * `SlotBlock` - returns either the deserialized
-    ///                 representation of the slot control block
-    ///                 OR a fresh, default valued slot control block
-    ///                 if there was an internal error.
-    ///
-    ///                 TODO(b/329116902): errors are logged
-    pub fn deserialize<B: SplitByteSlice>(buffer: B, boot_token: BootToken) -> Self {
-        // TODO(b/329116902): log failures
-        // validate(buffer)
-        // .inspect_err(|e| {
-        //     eprintln!("ABR metadata failed verification, using metadata defaults: {e}")
-        // })
-        let (data, cache_status) = match MB::validate(buffer) {
-            Ok(data) => (*data, CacheStatus::Clean),
-            Err(_) => (Default::default(), CacheStatus::Dirty),
-        };
-
-        SlotBlock { cache_status, boot_token: Some(boot_token), data }
-    }
-
-    /// Write back slot metadata to disk.
-    ///
-    /// The MetadataBytes type should reestablish any invariants when `prepare_for_sync` is called,
-    /// e.g. recalculating checksums.
-    ///
-    /// Does NOT write back to disk if no changes have been made and the cache is clean.
-    /// Panics if the write attempt fails.
-    ///
-    /// # Args
-    ///
-    /// * `persist`: A user provided closure for persisting a given slot metadata bytes to storage.
-    pub fn sync_to_disk(&mut self, persist: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {
-        if self.cache_status == CacheStatus::Clean {
-            return;
-        }
-
-        self.data.prepare_for_sync();
-
-        match persist(self.get_mut_data().as_bytes_mut()) {
-            Ok(_) => self.cache_status = CacheStatus::Clean,
-            Err(e) => panic!("{}", e),
-        };
-    }
-}
-
-#[cfg(test)]
-impl<MB: MetadataBytes> Default for SlotBlock<MB> {
-    /// Returns a default valued SlotBlock.
-    /// Only used in tests because BootToken cannot be constructed out of crate.
-    fn default() -> Self {
-        Self {
-            cache_status: CacheStatus::Clean,
-            boot_token: Some(BootToken(())),
-            data: Default::default(),
-        }
-    }
-}
diff --git a/gbl/libgbl/testdata/android/boot_no_ramdisk_v3_a.img b/gbl/libgbl/testdata/android/boot_no_ramdisk_v3_a.img
deleted file mode 100644
index 9152a34..0000000
Binary files a/gbl/libgbl/testdata/android/boot_no_ramdisk_v3_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_no_ramdisk_v3_b.img b/gbl/libgbl/testdata/android/boot_no_ramdisk_v3_b.img
deleted file mode 100644
index cdbbba6..0000000
Binary files a/gbl/libgbl/testdata/android/boot_no_ramdisk_v3_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_no_ramdisk_v4_a.img b/gbl/libgbl/testdata/android/boot_no_ramdisk_v4_a.img
deleted file mode 100644
index a0a3838..0000000
Binary files a/gbl/libgbl/testdata/android/boot_no_ramdisk_v4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_no_ramdisk_v4_b.img b/gbl/libgbl/testdata/android/boot_no_ramdisk_v4_b.img
deleted file mode 100644
index 434db34..0000000
Binary files a/gbl/libgbl/testdata/android/boot_no_ramdisk_v4_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v0_a.img b/gbl/libgbl/testdata/android/boot_v0_a.img
deleted file mode 100644
index 47d02cf..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v0_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v0_b.img b/gbl/libgbl/testdata/android/boot_v0_b.img
deleted file mode 100644
index 7587922..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v0_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v1_a.img b/gbl/libgbl/testdata/android/boot_v1_a.img
deleted file mode 100644
index ff24a4e..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v1_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v1_b.img b/gbl/libgbl/testdata/android/boot_v1_b.img
deleted file mode 100644
index 28b13fe..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v1_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v2_a.img b/gbl/libgbl/testdata/android/boot_v2_a.img
deleted file mode 100644
index c2b0c8c..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v2_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v2_b.img b/gbl/libgbl/testdata/android/boot_v2_b.img
deleted file mode 100644
index b7741c9..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v2_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v3_a.img b/gbl/libgbl/testdata/android/boot_v3_a.img
deleted file mode 100644
index f852aa2..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v3_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v3_b.img b/gbl/libgbl/testdata/android/boot_v3_b.img
deleted file mode 100644
index b3e33e9..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v3_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v4_a.img b/gbl/libgbl/testdata/android/boot_v4_a.img
deleted file mode 100644
index bdae1f6..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v4_b.img b/gbl/libgbl/testdata/android/boot_v4_b.img
deleted file mode 100644
index bca8775..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v4_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v4_gz_a.img b/gbl/libgbl/testdata/android/boot_v4_gz_a.img
deleted file mode 100644
index cd74a95..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v4_gz_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/boot_v4_lz4_a.img b/gbl/libgbl/testdata/android/boot_v4_lz4_a.img
deleted file mode 100644
index 2bdc049..0000000
Binary files a/gbl/libgbl/testdata/android/boot_v4_lz4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/device_tree.dtb b/gbl/libgbl/testdata/android/device_tree.dtb
deleted file mode 100644
index edccb90..0000000
Binary files a/gbl/libgbl/testdata/android/device_tree.dtb and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/device_tree.dts b/gbl/libgbl/testdata/android/device_tree.dts
deleted file mode 100644
index 916c616..0000000
--- a/gbl/libgbl/testdata/android/device_tree.dts
+++ /dev/null
@@ -1,11 +0,0 @@
-/dts-v1/;
-
-/ {
-    info = "test device tree";
-
-    chosen {
-        bootargs = "existing_arg_1=existing_val_1 existing_arg_2=existing_val_2";
-        builtin = [01];
-        fixup = <0x0>;
-    };
-};
diff --git a/gbl/libgbl/testdata/android/device_tree_a.dtb b/gbl/libgbl/testdata/android/device_tree_a.dtb
deleted file mode 100644
index 20bce9a..0000000
Binary files a/gbl/libgbl/testdata/android/device_tree_a.dtb and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/device_tree_a.dts b/gbl/libgbl/testdata/android/device_tree_a.dts
deleted file mode 100644
index 92deaff..0000000
--- a/gbl/libgbl/testdata/android/device_tree_a.dts
+++ /dev/null
@@ -1,11 +0,0 @@
-/dts-v1/;
-
-/ {
-    info = "test device tree from dtb partition";
-
-    chosen {
-        bootargs = "existing_arg_1=existing_val_1 existing_arg_2=existing_val_2";
-        dtb_slot = "a";
-        fixup = <0x0>;
-    };
-};
diff --git a/gbl/libgbl/testdata/android/device_tree_b.dtb b/gbl/libgbl/testdata/android/device_tree_b.dtb
deleted file mode 100644
index 0bad154..0000000
Binary files a/gbl/libgbl/testdata/android/device_tree_b.dtb and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/device_tree_b.dts b/gbl/libgbl/testdata/android/device_tree_b.dts
deleted file mode 100644
index 3b182ac..0000000
--- a/gbl/libgbl/testdata/android/device_tree_b.dts
+++ /dev/null
@@ -1,11 +0,0 @@
-/dts-v1/;
-
-/ {
-    info = "test device tree from dtb partition";
-
-    chosen {
-        bootargs = "existing_arg_1=existing_val_1 existing_arg_2=existing_val_2";
-        dtb_slot = "b";
-        fixup = <0x0>;
-    };
-};
diff --git a/gbl/libgbl/testdata/android/device_tree_custom.dtb b/gbl/libgbl/testdata/android/device_tree_custom.dtb
deleted file mode 100644
index b61150d..0000000
Binary files a/gbl/libgbl/testdata/android/device_tree_custom.dtb and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/device_tree_custom.dts b/gbl/libgbl/testdata/android/device_tree_custom.dts
deleted file mode 100644
index 0d8b85a..0000000
--- a/gbl/libgbl/testdata/android/device_tree_custom.dts
+++ /dev/null
@@ -1,11 +0,0 @@
-/dts-v1/;
-
-/ {
-    info = "test device tree";
-
-    chosen {
-        bootargs = "existing_arg_1=existing_val_1 existing_arg_2=existing_val_2";
-        fixup = <0x0>;
-        custom = "1";
-    };
-};
diff --git a/gbl/libgbl/testdata/android/dtb.img b/gbl/libgbl/testdata/android/dtb.img
deleted file mode 100644
index 1ea26fa..0000000
Binary files a/gbl/libgbl/testdata/android/dtb.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/dtb_a.img b/gbl/libgbl/testdata/android/dtb_a.img
deleted file mode 100644
index 4afcd61..0000000
Binary files a/gbl/libgbl/testdata/android/dtb_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/dtb_b.img b/gbl/libgbl/testdata/android/dtb_b.img
deleted file mode 100644
index fbeccda..0000000
Binary files a/gbl/libgbl/testdata/android/dtb_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/dtbo_a.img b/gbl/libgbl/testdata/android/dtbo_a.img
deleted file mode 100644
index 206d8a9..0000000
Binary files a/gbl/libgbl/testdata/android/dtbo_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/dtbo_b.img b/gbl/libgbl/testdata/android/dtbo_b.img
deleted file mode 100644
index 3b7aa23..0000000
Binary files a/gbl/libgbl/testdata/android/dtbo_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/generic_ramdisk_a.img b/gbl/libgbl/testdata/android/generic_ramdisk_a.img
deleted file mode 100644
index 6d0184e..0000000
Binary files a/gbl/libgbl/testdata/android/generic_ramdisk_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/generic_ramdisk_b.img b/gbl/libgbl/testdata/android/generic_ramdisk_b.img
deleted file mode 100644
index b7395a1..0000000
Binary files a/gbl/libgbl/testdata/android/generic_ramdisk_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/gki_boot_gz.img b/gbl/libgbl/testdata/android/gki_boot_gz.img
deleted file mode 100644
index 931e52a..0000000
Binary files a/gbl/libgbl/testdata/android/gki_boot_gz.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/gki_boot_gz_kernel b/gbl/libgbl/testdata/android/gki_boot_gz_kernel
deleted file mode 100644
index a90ef4d..0000000
Binary files a/gbl/libgbl/testdata/android/gki_boot_gz_kernel and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/gki_boot_gz_kernel_uncompressed b/gbl/libgbl/testdata/android/gki_boot_gz_kernel_uncompressed
deleted file mode 100644
index 81fd044..0000000
Binary files a/gbl/libgbl/testdata/android/gki_boot_gz_kernel_uncompressed and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/gki_boot_lz4.img b/gbl/libgbl/testdata/android/gki_boot_lz4.img
deleted file mode 100644
index f0418a1..0000000
Binary files a/gbl/libgbl/testdata/android/gki_boot_lz4.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/gki_boot_lz4_kernel b/gbl/libgbl/testdata/android/gki_boot_lz4_kernel
deleted file mode 100644
index ba8ef98..0000000
Binary files a/gbl/libgbl/testdata/android/gki_boot_lz4_kernel and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/gki_boot_lz4_kernel_uncompressed b/gbl/libgbl/testdata/android/gki_boot_lz4_kernel_uncompressed
deleted file mode 100644
index 81fd044..0000000
Binary files a/gbl/libgbl/testdata/android/gki_boot_lz4_kernel_uncompressed and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/init_boot_a.img b/gbl/libgbl/testdata/android/init_boot_a.img
deleted file mode 100644
index 19b56f1..0000000
Binary files a/gbl/libgbl/testdata/android/init_boot_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/init_boot_b.img b/gbl/libgbl/testdata/android/init_boot_b.img
deleted file mode 100644
index a24f376..0000000
Binary files a/gbl/libgbl/testdata/android/init_boot_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/kernel_a.img b/gbl/libgbl/testdata/android/kernel_a.img
deleted file mode 100644
index b313840..0000000
Binary files a/gbl/libgbl/testdata/android/kernel_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/kernel_b.img b/gbl/libgbl/testdata/android/kernel_b.img
deleted file mode 100644
index b524dd0..0000000
Binary files a/gbl/libgbl/testdata/android/kernel_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/overlay_a.dtb b/gbl/libgbl/testdata/android/overlay_a.dtb
deleted file mode 100644
index 4391b80..0000000
Binary files a/gbl/libgbl/testdata/android/overlay_a.dtb and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/overlay_a.dts b/gbl/libgbl/testdata/android/overlay_a.dts
deleted file mode 100644
index dc5b682..0000000
--- a/gbl/libgbl/testdata/android/overlay_a.dts
+++ /dev/null
@@ -1,12 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-/ {
-    // add a new node at the root level
-    fragment@0 {
-        target-path = "/chosen";
-        __overlay__ {
-            overlay_a_property = "overlay_a_val";
-        };
-    };
-};
diff --git a/gbl/libgbl/testdata/android/overlay_b.dtb b/gbl/libgbl/testdata/android/overlay_b.dtb
deleted file mode 100644
index c7b4fbb..0000000
Binary files a/gbl/libgbl/testdata/android/overlay_b.dtb and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/overlay_b.dts b/gbl/libgbl/testdata/android/overlay_b.dts
deleted file mode 100644
index 49e9905..0000000
--- a/gbl/libgbl/testdata/android/overlay_b.dts
+++ /dev/null
@@ -1,12 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-/ {
-    // add a new node at the root level
-    fragment@0 {
-        target-path = "/chosen";
-        __overlay__ {
-            overlay_b_property = "overlay_b_val";
-        };
-    };
-};
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_a.boot.digest.txt
deleted file mode 100644
index 4294d89..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-a3b8af36cf80e844e14bd9a3a5de4202afbbe4ebcabb9ba56f00abae53b864e5
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_a.digest.txt
deleted file mode 100644
index b7da618..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8cebef168617a32d627f43ae30e7d8e20413b9899e88a92bd6d0d4d3e311bba004930a7956a78b6ace1ceaca624cb965efb68eb14b19998fd6f7e4267c9ccfb6
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_a.img b/gbl/libgbl/testdata/android/vbmeta_v0_a.img
deleted file mode 100644
index c2baec8..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v0_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_b.boot.digest.txt
deleted file mode 100644
index a40f282..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0c69400ce9d8248185fbda667a71f5dc67d4066a01373a2ed78072a878e0a1de
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_b.digest.txt
deleted file mode 100644
index 48e63f9..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-3feb5ded4d560d850d7a13cd020ac4deb7d2825d49d2c1d57dda363d346a796ad68c023612759bf9cc126e0e966c554d2ce06f4207dcfa223b50ab2ec73ad199
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v0_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v0_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v0_b.img b/gbl/libgbl/testdata/android/vbmeta_v0_b.img
deleted file mode 100644
index da2f398..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v0_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_a.boot.digest.txt
deleted file mode 100644
index 285fd31..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-dd946c73d66bc155284aa63b7ba93da3d4dcf1db9e1d21eae317941d967d41bc
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_a.digest.txt
deleted file mode 100644
index 26d0d83..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-30320c1499e033b61f59f9532bf827378e4f2a6bec7adde69a2b776d6a410b0deb53c0a04e7688920e53f62c1a27eddb6850898cd03fc88205841b7f1d3b0781
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_a.img b/gbl/libgbl/testdata/android/vbmeta_v1_a.img
deleted file mode 100644
index bd9f7db..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v1_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_b.boot.digest.txt
deleted file mode 100644
index 8a35ceb..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-465b18c4c5d4ecebc263dccaaede64e9dca77a3fd041209f3ff1ee0db2bc932a
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_b.digest.txt
deleted file mode 100644
index 0f8110f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-dff89db9ae5068974109d8704c67e89804ccdbb975e8a796273045df317cb27dddae38a26fd6233ff19609729c9fb0650b39ce00aad0e17995a9feb0cfc94a69
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v1_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v1_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v1_b.img b/gbl/libgbl/testdata/android/vbmeta_v1_b.img
deleted file mode 100644
index e810499..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v1_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_a.boot.digest.txt
deleted file mode 100644
index 837b3e8..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-ffd15bfde9fbb434d17ecba7112887a4fffa766be5018d267bfcca8fd784d6ec
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_a.digest.txt
deleted file mode 100644
index 7b55cff..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-70d478f639a2cc50f200a82a004f2016d9331d6973b571384c8ae25d20e6d3bb1c6a2aa128f8dcaaf1de691cc90c76de5e6d956be173d3dd08d0a05418120a17
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_a.img b/gbl/libgbl/testdata/android/vbmeta_v2_a.img
deleted file mode 100644
index 06ebf69..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v2_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_b.boot.digest.txt
deleted file mode 100644
index 2212ed7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-fe903a60e9a6262c86ceadf55ed65eb0d3de7b1f3ada95633f3e3de04648c3b7
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_b.digest.txt
deleted file mode 100644
index ff6e3cc..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-eeda048001594baf5e8bc8767ad5fe2f16664f82868cbbae4e7c7de53b4b9eab3d1d3b3d7edd39d17955f6bb08a13e4d43d0e4086f7a0dd8b33975c550b33786
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v2_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v2_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v2_b.img b/gbl/libgbl/testdata/android/vbmeta_v2_b.img
deleted file mode 100644
index 26b489a..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v2_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.boot.digest.txt
deleted file mode 100644
index 2bf0f10..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-bea1c8a317ec59fd640755109f99aaf91b25d3e652f752145ac3431ed379ce82
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.digest.txt
deleted file mode 100644
index fbad95e..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-e47f6dcba0f95be52e75a2543aeb4be6dfc02182525a21f921e9c381f1762fb418292d3ec1cec9f2f7815e1d986d89b1009fb22627d75a62120e6e94b9f0cbe5
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.img b/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.img
deleted file mode 100644
index bf9a873..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.vendor_boot.digest.txt
deleted file mode 100644
index fbc54f5..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-c81fde8b7626fbe39e1529e7bc5588aa490cf631ab5a342f6a25de0b6a8ea968
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.boot.digest.txt
deleted file mode 100644
index 262fd66..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-dd27279d7059e549e106b2ea18b88d95d0455bebf8c3079db5a7fded720b42af
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.digest.txt
deleted file mode 100644
index b018df6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-91ed48de6a9cb9e788ef739b55f77a4c423445b08015b1e62a8f9c91d522c40a03c4483065319ecaa19fd562bc3d642642adad09ddc68d926b50be9a05658b18
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.img b/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.img
deleted file mode 100644
index 74931e3..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.vendor_boot.digest.txt
deleted file mode 100644
index 7408640..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-907248ca1c2b3ed11fa1147af8a34a71ec4e83f6254af17c6d031f804153ed9a
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.boot.digest.txt
deleted file mode 100644
index 0c01406..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-e95c88cb742b7a4e456b6618564793d5980d9f4a94a995c09922269620773818
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.digest.txt
deleted file mode 100644
index beb0e30..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-a74bd2b97f77e60029bbf72bd432dadab3bb355678200c610ebece4101bfda3f3d0190af0b05ceb2614beac96a6c1b386b65d6402b0b85fec37e47b88d89fa7f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.img b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.img
deleted file mode 100644
index b9deb72..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.init_boot.digest.txt
deleted file mode 100644
index ed24f4a..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0d843d8d54a0c551dad06319548365817bbb199fbc8c8a7b10cc07a53499e590
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.vendor_boot.digest.txt
deleted file mode 100644
index fbc54f5..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-c81fde8b7626fbe39e1529e7bc5588aa490cf631ab5a342f6a25de0b6a8ea968
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.boot.digest.txt
deleted file mode 100644
index d6c7373..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-420b5c1ca6f85ae1b532e22c2dc57356add25e4b30c06df144e40667c0134f89
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.digest.txt
deleted file mode 100644
index 7966a5f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0ed054b373033693f98dfd0a5ab64f3b21ba2625fa94148ec8cac265a2e5b8be28e940dba77abfe7afd516b7f385b6c5543d0bdb3710d6d394979ec8f499395d
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.img b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.img
deleted file mode 100644
index 69f18f9..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.init_boot.digest.txt
deleted file mode 100644
index eb408b9..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-010ad1c6aa987435bef2b5b65f8018c1ce5c10cc4681789ca928486852f03813
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.vendor_boot.digest.txt
deleted file mode 100644
index 7408640..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v3_init_boot_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-907248ca1c2b3ed11fa1147af8a34a71ec4e83f6254af17c6d031f804153ed9a
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.boot.digest.txt
deleted file mode 100644
index 2bf0f10..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-bea1c8a317ec59fd640755109f99aaf91b25d3e652f752145ac3431ed379ce82
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.digest.txt
deleted file mode 100644
index db120fc..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-5bd5cc04647fbe176dd12c68425bb7b8b417e7bdd9bb22d4cf31264e086d97ac8752220ada16c1c4159ecd3ff2bd6109051e3751ba152216a787247d40063eed
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.img b/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.img
deleted file mode 100644
index c6d4579..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.vendor_boot.digest.txt
deleted file mode 100644
index 0bb1af6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f368327144138f5736abb01dd976c8b7bf7af987aaf626de7612461e81cab955
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.boot.digest.txt
deleted file mode 100644
index 262fd66..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-dd27279d7059e549e106b2ea18b88d95d0455bebf8c3079db5a7fded720b42af
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.digest.txt
deleted file mode 100644
index 2fc6324..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-ac49facebda99d6f07c37ee61d7324024a5b1b090e5781a06dbd45c2ee144e61d1434be056ff2f54e19a422cc717b84ebf4ebf2d80b416ef6ec4441c78df6508
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.img b/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.img
deleted file mode 100644
index 6e53b17..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.vendor_boot.digest.txt
deleted file mode 100644
index 58243fd..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6b1ef1b1791351c7072cc16a6e9be876d88f4ad7744383f205e1be299202ecd8
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.boot.digest.txt
deleted file mode 100644
index 0c01406..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-e95c88cb742b7a4e456b6618564793d5980d9f4a94a995c09922269620773818
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.digest.txt
deleted file mode 100644
index 453655f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-16fcf1b827e38ac448a0bf5bfc6b7a08d78b52038c0710e1835f86df7ce8bbdcd97a1f12a2ef2d9da4c8c0bdf428b83b1ca0a869bf1146d7dc38f16e51ac5e37
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.img b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.img
deleted file mode 100644
index 918af13..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.init_boot.digest.txt
deleted file mode 100644
index ed24f4a..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0d843d8d54a0c551dad06319548365817bbb199fbc8c8a7b10cc07a53499e590
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.vendor_boot.digest.txt
deleted file mode 100644
index 0bb1af6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f368327144138f5736abb01dd976c8b7bf7af987aaf626de7612461e81cab955
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.boot.digest.txt
deleted file mode 100644
index d6c7373..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-420b5c1ca6f85ae1b532e22c2dc57356add25e4b30c06df144e40667c0134f89
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.digest.txt
deleted file mode 100644
index 4080c69..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-ac736aca587cda643af8a182532d92b5ab6fb7f1948264188902092a5b76536a50599deb16364528350df40a251ff3286eef4edb0c2630fff5bbb5eec2fc6a58
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.img b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.img
deleted file mode 100644
index 0015e33..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.init_boot.digest.txt
deleted file mode 100644
index eb408b9..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-010ad1c6aa987435bef2b5b65f8018c1ce5c10cc4681789ca928486852f03813
diff --git a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.vendor_boot.digest.txt
deleted file mode 100644
index 58243fd..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v3_v4_init_boot_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6b1ef1b1791351c7072cc16a6e9be876d88f4ad7744383f205e1be299202ecd8
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.boot.digest.txt
deleted file mode 100644
index 8cc8826..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-fe6845837f27613699770d58a19b2405c4b23c203fe1edb0133b30e3d496945c
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.digest.txt
deleted file mode 100644
index c09919d..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-450823eddf5bf1600790b612b24b32552d9454a1420188cdf7a279844431a3a2a82ecc367125d265c724066427993ffe2adc303782fb93850fef1cc10866b215
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.img
deleted file mode 100644
index 12f0ac8..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.vendor_boot.digest.txt
deleted file mode 100644
index 8c33e8a..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f9cad72ad63c87e97ca0ef89e00d5297b4731145a7916cf34cdcd6c03d68a0ca
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.boot.digest.txt
deleted file mode 100644
index c7fb6e2..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-54c83f6d25648f1628b9049978f05eaac878523e2ad9da50e80e4591f709e8db
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.digest.txt
deleted file mode 100644
index 0ee67db..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-7062df4c2e595c354a31e07ae33a627a0fdaae0bfd80b35ba569df0978165f7b4761184226f62efc479cff8fe85d032e2f5f9e7bced536dd5761ef054a0d8548
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.img b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.img
deleted file mode 100644
index 79c8c21..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.vendor_boot.digest.txt
deleted file mode 100644
index a2af6a3..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_dttable_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-1686ca796de1300d09238cbe1828d59405224b7e5dc913a653071734af6f01da
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.boot.digest.txt
deleted file mode 100644
index 17773dc..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0dd6574d0a2190d7fdf0c46875b600eb4eb276f77b334bb691a17d9495296b94
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.digest.txt
deleted file mode 100644
index bc8797e..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-9a53c58824b82faef92dc4ae09caea4ffd1532d7daff2a4def512852baed7598df572541d935d84b2f0f7a7372b7395b52291641dea122e43fa5d84325f594b1
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.img
deleted file mode 100644
index 72ee8a7..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.vendor_boot.digest.txt
deleted file mode 100644
index 0bb1af6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_gz_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f368327144138f5736abb01dd976c8b7bf7af987aaf626de7612461e81cab955
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.boot.digest.txt
deleted file mode 100644
index 1d0776b..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-7690d4dc0fa8bd49ae4ae26c346918117e7c86bc22ec9c99f922d6c192960e38
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.digest.txt
deleted file mode 100644
index 731caf0..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-5516b383bbdba4776e03e4e2029f487e24bc9d6b265210365c1f67ac8794eacf6f24fbacfa2019b386e99e5168839e0a380585c2417e0476042617a8dca61a37
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.img
deleted file mode 100644
index abdb92d..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.vendor_boot.digest.txt
deleted file mode 100644
index 0bb1af6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_lz4_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f368327144138f5736abb01dd976c8b7bf7af987aaf626de7612461e81cab955
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.boot.digest.txt
deleted file mode 100644
index 8cc8826..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-fe6845837f27613699770d58a19b2405c4b23c203fe1edb0133b30e3d496945c
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.digest.txt
deleted file mode 100644
index d3024e9..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-607d6b48a65b885ab7cd65045cefabc5f10920d9fe73e346765a586edb5acbb7cafcab2de30c1e4ede8f38d26456053212994a22ae1d1d786fd6c3acc55b083c
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.img
deleted file mode 100644
index 0ea7922..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.vendor_boot.digest.txt
deleted file mode 100644
index fbc54f5..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-c81fde8b7626fbe39e1529e7bc5588aa490cf631ab5a342f6a25de0b6a8ea968
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.boot.digest.txt
deleted file mode 100644
index c7fb6e2..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-54c83f6d25648f1628b9049978f05eaac878523e2ad9da50e80e4591f709e8db
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.digest.txt
deleted file mode 100644
index 9b3c900..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-7b0edd3640b9d0e0765dcb2eaf3aaa4464777cc017c4a28433fa2cb62860c441f601331bbb700102b7b1519714ef16b4f392f38a00913b282914ca3d41433e18
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.img b/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.img
deleted file mode 100644
index 961015e..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.vendor_boot.digest.txt
deleted file mode 100644
index 7408640..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-907248ca1c2b3ed11fa1147af8a34a71ec4e83f6254af17c6d031f804153ed9a
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.boot.digest.txt
deleted file mode 100644
index 86ddee3..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-ae41c9cf4f0ab6e7a6333d8e5c1283cfbbead4bcb9bad7013bbc5cd2cf313918
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.digest.txt
deleted file mode 100644
index d3d3ec1..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-c80674d0b5f695402a12bf0f0894277377dd75af29e928b90f151d4b6476e641993e354db80ee90597895537cd07bdacb193a3acdf0dcb72bad7e249a01063f9
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.img
deleted file mode 100644
index ac30442..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.init_boot.digest.txt
deleted file mode 100644
index ed24f4a..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0d843d8d54a0c551dad06319548365817bbb199fbc8c8a7b10cc07a53499e590
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.vendor_boot.digest.txt
deleted file mode 100644
index fbc54f5..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-c81fde8b7626fbe39e1529e7bc5588aa490cf631ab5a342f6a25de0b6a8ea968
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.boot.digest.txt
deleted file mode 100644
index 4132b5b..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-d339c452efb6a987dc227ce59f08346fe6b2e5b27bea15bb061e7f044327f238
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.digest.txt
deleted file mode 100644
index c3375a8..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-a2e4333bec295750074b5f3c9db38cd04ec0546be2be9dd2e02e375e67676aff5a3b5d0a1723e87e077ee483b38b662d46d9883a32b7b9799009272c149c7c72
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.img b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.img
deleted file mode 100644
index 4f2e9aa..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.init_boot.digest.txt
deleted file mode 100644
index eb408b9..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-010ad1c6aa987435bef2b5b65f8018c1ce5c10cc4681789ca928486852f03813
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.vendor_boot.digest.txt
deleted file mode 100644
index 7408640..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v3_init_boot_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-907248ca1c2b3ed11fa1147af8a34a71ec4e83f6254af17c6d031f804153ed9a
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.boot.digest.txt
deleted file mode 100644
index 8cc8826..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-fe6845837f27613699770d58a19b2405c4b23c203fe1edb0133b30e3d496945c
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.digest.txt
deleted file mode 100644
index cf49fee..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-4fa8c1c121566f80b8477510a6b14a568bb32e0bb8f9e62fddbd70b8e18fb2341f2aa9c0f1fd596afead41212f47d47a343640c5f32e2a6a72023cbad9287c6f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.img
deleted file mode 100644
index 639786e..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.vendor_boot.digest.txt
deleted file mode 100644
index 0bb1af6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f368327144138f5736abb01dd976c8b7bf7af987aaf626de7612461e81cab955
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.boot.digest.txt
deleted file mode 100644
index c7fb6e2..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-54c83f6d25648f1628b9049978f05eaac878523e2ad9da50e80e4591f709e8db
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.digest.txt
deleted file mode 100644
index 5404d8a..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-b8c8c2a543646d17142b7f30ec4a274033e18e578a6baa4b58a3799ba0e4ced193272029482695e231c56b6fcc52d2619a8a83c5f02b04d0c87ecb92d4f5f326
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.img b/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.img
deleted file mode 100644
index 831e48a..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.vendor_boot.digest.txt
deleted file mode 100644
index 58243fd..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6b1ef1b1791351c7072cc16a6e9be876d88f4ad7744383f205e1be299202ecd8
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.boot.digest.txt
deleted file mode 100644
index 86ddee3..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-ae41c9cf4f0ab6e7a6333d8e5c1283cfbbead4bcb9bad7013bbc5cd2cf313918
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.digest.txt
deleted file mode 100644
index 796ea72..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-55bb0c5ed400434d63b0a824ef31769008762ebb9186ef5e25e4351f360f808cb034fc7323f04469ed1e3a84aa983a942c8d405e6f52fd882198995a2899d4d5
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.dtb.digest.txt
deleted file mode 100644
index 8460aa7..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-74024f7c9577215434dba9b695c3501eb626f66b97c810ff5307912c7fac7938
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.dtbo.digest.txt
deleted file mode 100644
index 0013aed..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-18964fe84fd9214ae7d61c7f0d7d951412b6ce7f1c3e49a8f896a40da2ddde3f
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.img b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.img
deleted file mode 100644
index f91bc51..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.init_boot.digest.txt
deleted file mode 100644
index ed24f4a..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-0d843d8d54a0c551dad06319548365817bbb199fbc8c8a7b10cc07a53499e590
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt
deleted file mode 100644
index 0bb1af6..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_a.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-f368327144138f5736abb01dd976c8b7bf7af987aaf626de7612461e81cab955
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.boot.digest.txt
deleted file mode 100644
index 4132b5b..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-d339c452efb6a987dc227ce59f08346fe6b2e5b27bea15bb061e7f044327f238
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.digest.txt
deleted file mode 100644
index fff2f60..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-431f6394786c3883e9f93a2ca2a77ee9e976da7de69d781b91eae61742e8324cc019672b888150e648a36966f8eead415cd533555c92f3362ae3da09f586c301
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.dtb.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.dtb.digest.txt
deleted file mode 100644
index 22afb3f..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.dtb.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6227f3fbf15d3049f03c9829016372e1387cd07eb1b23bc8ae640545c0b3a398
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.dtbo.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.dtbo.digest.txt
deleted file mode 100644
index 74ca578..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.dtbo.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-8e3d69eba96fb6723bb4f29a1fa4dd3737bc352d1b3c05a7946778e685307fe4
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.img b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.img
deleted file mode 100644
index ef2bed2..0000000
Binary files a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.init_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.init_boot.digest.txt
deleted file mode 100644
index eb408b9..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.init_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-010ad1c6aa987435bef2b5b65f8018c1ce5c10cc4681789ca928486852f03813
diff --git a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.vendor_boot.digest.txt b/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.vendor_boot.digest.txt
deleted file mode 100644
index 58243fd..0000000
--- a/gbl/libgbl/testdata/android/vbmeta_v4_v4_init_boot_b.vendor_boot.digest.txt
+++ /dev/null
@@ -1 +0,0 @@
-6b1ef1b1791351c7072cc16a6e9be876d88f4ad7744383f205e1be299202ecd8
diff --git a/gbl/libgbl/testdata/android/vendor_boot_v3_a.img b/gbl/libgbl/testdata/android/vendor_boot_v3_a.img
deleted file mode 100644
index e55f783..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_boot_v3_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_boot_v3_b.img b/gbl/libgbl/testdata/android/vendor_boot_v3_b.img
deleted file mode 100644
index b6bb56b..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_boot_v3_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_boot_v4_a.img b/gbl/libgbl/testdata/android/vendor_boot_v4_a.img
deleted file mode 100644
index ded56ce..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_boot_v4_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_boot_v4_b.img b/gbl/libgbl/testdata/android/vendor_boot_v4_b.img
deleted file mode 100644
index 3186ba7..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_boot_v4_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_boot_v4_dttable_a.img b/gbl/libgbl/testdata/android/vendor_boot_v4_dttable_a.img
deleted file mode 100644
index 2ea1bfa..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_boot_v4_dttable_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_boot_v4_dttable_b.img b/gbl/libgbl/testdata/android/vendor_boot_v4_dttable_b.img
deleted file mode 100644
index 941024f..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_boot_v4_dttable_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_ramdisk_a.img b/gbl/libgbl/testdata/android/vendor_ramdisk_a.img
deleted file mode 100644
index de40d03..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_ramdisk_a.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/android/vendor_ramdisk_b.img b/gbl/libgbl/testdata/android/vendor_ramdisk_b.img
deleted file mode 100644
index f9e36df..0000000
Binary files a/gbl/libgbl/testdata/android/vendor_ramdisk_b.img and /dev/null differ
diff --git a/gbl/libgbl/testdata/cert_metadata.bin b/gbl/libgbl/testdata/cert_metadata.bin
deleted file mode 100644
index 58666a1..0000000
Binary files a/gbl/libgbl/testdata/cert_metadata.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.bad.bin b/gbl/libgbl/testdata/cert_permanent_attributes.bad.bin
deleted file mode 100644
index c3a78bc..0000000
Binary files a/gbl/libgbl/testdata/cert_permanent_attributes.bad.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.bad.hash b/gbl/libgbl/testdata/cert_permanent_attributes.bad.hash
deleted file mode 100644
index fc86fd3..0000000
--- a/gbl/libgbl/testdata/cert_permanent_attributes.bad.hash
+++ /dev/null
@@ -1 +0,0 @@
-#`-0U)~	joZc>MP
\ No newline at end of file
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.bin b/gbl/libgbl/testdata/cert_permanent_attributes.bin
deleted file mode 100644
index 51ab594..0000000
Binary files a/gbl/libgbl/testdata/cert_permanent_attributes.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.hash b/gbl/libgbl/testdata/cert_permanent_attributes.hash
deleted file mode 100644
index c70ca95..0000000
Binary files a/gbl/libgbl/testdata/cert_permanent_attributes.hash and /dev/null differ
diff --git a/gbl/libgbl/testdata/gen_test_data.py b/gbl/libgbl/testdata/gen_test_data.py
deleted file mode 100755
index 1c37d29..0000000
--- a/gbl/libgbl/testdata/gen_test_data.py
+++ /dev/null
@@ -1,821 +0,0 @@
-#!/usr/bin/env python3
-#
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-"""Generate test data files for libgbl tests"""
-
-import argparse
-import gzip
-import os
-import pathlib
-import random
-import re
-import shutil
-import subprocess
-import tempfile
-
-SCRIPT_DIR = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))
-AOSP_ROOT = SCRIPT_DIR.parents[4]
-GBL_ROOT = SCRIPT_DIR.parents[1]
-ANDROID_OUT = SCRIPT_DIR / "android"
-GPT_TOOL = GBL_ROOT / "tools" / "gen_gpt_disk.py"
-AVB_DIR = AOSP_ROOT / "external" / "avb"
-AVB_TOOL = AVB_DIR / "avbtool.py"
-MKBOOTIMG_TOOL = AOSP_ROOT / "tools" / "mkbootimg" / "mkbootimg.py"
-UNPACKBOOTIMG_TOOL = AOSP_ROOT / "tools" / "mkbootimg" / "unpack_bootimg.py"
-AVB_TEST_DATA_DIR = AVB_DIR / "test" / "data"
-DTC_TOOL = (
-    AOSP_ROOT / "prebuilts" / "kernel-build-tools" / "linux-x86" / "bin" / "dtc"
-)
-MKDTBOIMG_TOOL = (
-    AOSP_ROOT
-    / "prebuilts"
-    / "kernel-build-tools"
-    / "linux-x86"
-    / "bin"
-    / "mkdtboimg"
-)
-LZ4_TOOL = "lz4"
-SZ_KB = 1024
-
-# Manually downloaded from Android CI:
-# https://android-build.corp.google.com/build_explorer/branch/aosp_kernel-common-android-mainline
-GKI_BOOT_GZ = ANDROID_OUT / "gki_boot_gz.img"
-GKI_BOOT_LZ4 = ANDROID_OUT / "gki_boot_lz4.img"
-
-# RNG seed values. Keep the same seed value for a given file to ensure
-# reproducibility as much as possible; this will prevent adding a bunch of
-# unnecessary test binaries to the git history.
-RNG_SEED_SPARSE_TEST_RAW = 1
-RNG_SEED_ZIRCON = {"a": 2, "b": 3, "r": 4, "slotless": 5}
-RNG_SEED_ANDROID = {"a": 6, "b": 7}
-
-# AVB related constants.
-PSK = AVB_TEST_DATA_DIR / "testkey_cert_psk.pem"
-TEST_ROLLBACK_INDEX_LOCATION = 1
-TEST_ROLLBACK_INDEX = 2
-
-
-# A helper for writing bytes to a file at a given offset.
-def write_file(file, offset, data):
-    file.seek(offset, 0)
-    file.write(data)
-
-
-# Unpack kernel from boot image
-def unpack_boot(boot, into):
-    subprocess.run(
-        [
-            UNPACKBOOTIMG_TOOL,
-            "--boot_img", boot,
-            "--out", into,
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-
-
-def uncompress_lz4(archive, into):
-    subprocess.run(
-        [
-            LZ4_TOOL,
-            "-f",  # always override
-            "-d", archive,
-            into,
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-
-
-def uncompress_gz(archive, into):
-    with gzip.open(archive, "rb") as input, open(into, "wb") as output:
-        shutil.copyfileobj(input, output)
-
-
-# Unpack and uncompress GKI boot images
-def unpack_gkis():
-    with tempfile.TemporaryDirectory() as temp_dir:
-        temp_dir = pathlib.Path(temp_dir)
-
-        if shutil.which(LZ4_TOOL) is not None:
-            unpack_boot(GKI_BOOT_LZ4, temp_dir)
-            shutil.copyfile(temp_dir / "kernel",
-                            ANDROID_OUT / "gki_boot_lz4_kernel")
-            uncompress_lz4(ANDROID_OUT / "gki_boot_lz4_kernel",
-                           ANDROID_OUT / "gki_boot_lz4_kernel_uncompressed")
-        else:
-            print("Warning: lz4 tool isn't presented, skipping unpack lz4 gki boot")
-
-        unpack_boot(GKI_BOOT_GZ, temp_dir)
-        shutil.copyfile(temp_dir / "kernel",
-                        ANDROID_OUT / "gki_boot_gz_kernel")
-        uncompress_gz(ANDROID_OUT / "gki_boot_gz_kernel",
-                      ANDROID_OUT / "gki_boot_gz_kernel_uncompressed")
-
-
-# Generates sparse image for flashing test
-def gen_sparse_test_file():
-    out_file_raw = SCRIPT_DIR / "sparse_test_raw.bin"
-    random.seed(RNG_SEED_SPARSE_TEST_RAW)
-    with open(out_file_raw, "wb") as f:
-        # 4k filled with 0x78563412
-        write_file(f, 0, b"\x12\x34\x56\x78" * 1024)
-        # 8k file hole (will become dont-care with the "-s" option)
-        # 12k raw data
-        write_file(f, 12 * SZ_KB, random.randbytes(12 * SZ_KB))
-        # 8k filled with 0x78563412
-        write_file(f, 24 * SZ_KB, b"\x12\x34\x56\x78" * 1024 * 2)
-        # 12k raw data
-        write_file(f, 32 * SZ_KB, random.randbytes(12 * SZ_KB))
-        # 4k filled with 0x78563412
-        write_file(f, 44 * SZ_KB, b"\x12\x34\x56\x78" * 1024)
-        # 8k filled with 0xEFCDAB90
-        write_file(f, 48 * SZ_KB, b"\x90\xab\xcd\xef" * 1024 * 2)
-
-    # For now this requires that img2simg exists on $PATH.
-    # It can be built from an Android checkout via `m img2simg`; the resulting
-    # binary will be at out/host/linux-x86/bin/img2simg.
-    subprocess.run(
-        ["img2simg", "-s", out_file_raw, SCRIPT_DIR / "sparse_test.bin"]
-    )
-    subprocess.run(
-        [
-            "img2simg",
-            "-s",
-            out_file_raw,
-            SCRIPT_DIR / "sparse_test_blk1024.bin",
-            "1024",
-        ]
-    )
-
-
-def gen_dtb(input_dts, output_dtb):
-    subprocess.run(
-        [DTC_TOOL, "-I", "dts", "-O", "dtb", "-o", output_dtb, input_dts],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-
-
-def gen_android_test_dtb():
-    out_dir = ANDROID_OUT
-    # Generates base test device tree.
-    gen_dtb(out_dir / "device_tree.dts", out_dir / "device_tree.dtb")
-    gen_dtb(
-        out_dir / "device_tree_custom.dts", out_dir / "device_tree_custom.dtb"
-    )
-    # Generates dtb to be used inside boot/vendor_boot
-    subprocess.run(
-        [
-            MKDTBOIMG_TOOL,
-            "create",
-            out_dir / "dtb.img",
-            "--id=0x1",
-            "--rev=0x0",
-            out_dir / "device_tree.dtb",
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-
-    # Generates dtb_a/dtb_b
-    gen_dtb(out_dir / "device_tree_a.dts", out_dir / "device_tree_a.dtb")
-    gen_dtb(out_dir / "device_tree_b.dts", out_dir / "device_tree_b.dtb")
-    subprocess.run(
-        [
-            MKDTBOIMG_TOOL,
-            "create",
-            out_dir / "dtb_a.img",
-            "--id=0x1",
-            "--rev=0x0",
-            out_dir / "device_tree_a.dtb",
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-    subprocess.run(
-        [
-            MKDTBOIMG_TOOL,
-            "create",
-            out_dir / "dtb_b.img",
-            "--id=0x1",
-            "--rev=0x0",
-            out_dir / "device_tree_b.dtb",
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-
-    # Generates overlay
-    gen_dtb(out_dir / "overlay_a.dts", out_dir / "overlay_a.dtb")
-    gen_dtb(out_dir / "overlay_b.dts", out_dir / "overlay_b.dtb")
-
-    subprocess.run(
-        [
-            MKDTBOIMG_TOOL,
-            "create",
-            out_dir / "dtbo_a.img",
-            "--id=0x1",
-            "--rev=0x0",
-            out_dir / "overlay_a.dtb",
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-    subprocess.run(
-        [
-            MKDTBOIMG_TOOL,
-            "create",
-            out_dir / "dtbo_b.img",
-            "--id=0x1",
-            "--rev=0x0",
-            out_dir / "overlay_b.dtb",
-        ],
-        stderr=subprocess.STDOUT,
-        check=True,
-    )
-
-
-# Generate vbmeta data for a set of images.
-def gen_android_test_vbmeta(partition_file_pairs, out_vbmeta):
-    with tempfile.TemporaryDirectory() as temp_dir:
-        desc_args = []
-        temp_dir = pathlib.Path(temp_dir)
-        for i, (part, image_file) in enumerate(partition_file_pairs):
-            out = temp_dir / f"{i}.vbmeta_desc"
-            desc_args += ["--include_descriptors_from_image", out]
-            subprocess.run(
-                [
-                    AVB_TOOL,
-                    "add_hash_footer",
-                    "--image",
-                    image_file,
-                    "--partition_name",
-                    part,
-                    "--do_not_append_vbmeta_image",
-                    "--output_vbmeta_image",
-                    out,
-                    "--salt",
-                    "9f06406a750581266f21865d115e63b54db441bc0d614195c78c14451b5ecb8abb14d8cd88d816c4750545ef89cb348a3834815aac4fa359e8b02a740483d975",
-                    "--partition_size",
-                    "209715200",  # Randomly chosen large enough value.
-                ],
-                stderr=subprocess.STDOUT,
-                check=True,
-            )
-
-        subprocess.run(
-            [
-                AVB_TOOL,
-                "make_vbmeta_image",
-                "--output",
-                out_vbmeta,
-                "--key",
-                PSK,
-                "--algorithm",
-                "SHA512_RSA4096",
-                "--rollback_index",
-                f"{TEST_ROLLBACK_INDEX}",
-                "--rollback_index_location",
-                f"{TEST_ROLLBACK_INDEX_LOCATION}",
-            ]
-            + desc_args,
-            stderr=subprocess.STDOUT,
-            check=True,
-        )
-
-        # Generates vbmeta digest file
-        out_digest = out_vbmeta.with_suffix(".digest.txt")
-        digest = subprocess.run(
-            [
-                AVB_TOOL,
-                "calculate_vbmeta_digest",
-                "--image",
-                out_vbmeta,
-                "--hash_algorithm",
-                "sha512",
-            ],
-
-
-            check=True,
-            text=True,
-            capture_output=True,
-        )
-        out_digest.write_text(digest.stdout)
-
-        extract_vbmeta_digests(out_vbmeta)
-
-
-# Extract digests from vbmeta data
-def extract_vbmeta_digests(vbmeta):
-    # Get vbmeta digests
-    digests = (
-        re.split(
-            "\n|: ",
-            subprocess.run(
-                [
-                    AVB_TOOL,
-                    "print_partition_digests",
-                    "--image",
-                    vbmeta,
-                ],
-
-
-                check=True,
-                text=True,
-                capture_output=True,
-            )
-            .stdout
-        )
-    )
-    digests = {digests[i]: digests[i+1] for i in range(0, len(digests), 2) if digests[i] in [
-        "boot", "vendor_boot", "init_boot", "dtbo", "dtb"]}
-
-    for key, value in digests.items():
-        out_digest = vbmeta.with_suffix(".{}.digest.txt".format(key))
-        out_digest.write_text(value + "\n")
-
-
-def gen_android_test_images():
-    unpack_gkis()
-    gen_android_test_dtb()
-
-    with tempfile.TemporaryDirectory() as temp_dir:
-        temp_dir = pathlib.Path(temp_dir)
-        out_dir = ANDROID_OUT
-        out_dir.mkdir(parents=True, exist_ok=True)
-        for slot in ["a", "b"]:
-            random.seed(RNG_SEED_ANDROID[slot])
-            kernel = out_dir / f"kernel_{slot}.img"
-            kernel.write_bytes(random.randbytes(4 * SZ_KB))
-
-            generic_ramdisk = out_dir / f"generic_ramdisk_{slot}.img"
-            generic_ramdisk.write_bytes(random.randbytes(8 * SZ_KB))
-
-            vendor_ramdisk = out_dir / f"vendor_ramdisk_{slot}.img"
-            vendor_ramdisk.write_bytes(random.randbytes(12 * SZ_KB))
-
-            vendor_bootconfig = temp_dir / f"vendor_bootconfig_{slot}.img"
-            vendor_bootconfig.write_bytes(
-                b"""\
-androidboot.config_1=val_1
-androidboot.config_2=val_2
-"""
-            )
-
-            boot_cmdline = "cmd_key_1=cmd_val_1,cmd_key_2=cmd_val_2"
-            vendor_cmdline = "cmd_vendor_key_1=cmd_vendor_val_1,cmd_vendor_key_2=cmd_vendor_val_2"
-
-            # Generate v3, v4 boot image without ramdisk (usecase for init_boot)
-            common = [
-                MKBOOTIMG_TOOL,
-                "--kernel",
-                kernel,
-                "--cmdline",
-                boot_cmdline,
-                "--dtb",
-                out_dir / "device_tree.dtb",
-            ]
-            for i in [3, 4]:
-                out = out_dir / f"boot_no_ramdisk_v{i}_{slot}.img"
-                subprocess.run(
-                    common + ["--header_version", f"{i}", "-o", out],
-                    check=True,
-                    stderr=subprocess.STDOUT,
-                )
-
-            # Generates v0 - v4 boot image that contains generic ramdisk.
-            common += [
-                "--ramdisk",
-                generic_ramdisk,
-            ]
-            for i in range(0, 5):
-                out = out_dir / f"boot_v{i}_{slot}.img"
-                subprocess.run(
-                    common + ["--header_version", f"{i}", "-o", out],
-                    check=True,
-                    stderr=subprocess.STDOUT,
-                )
-
-            # Generate v4 boot images for gzip and lz4 kernel compression.
-            if slot == "a":
-                for compression in ['gz', 'lz4']:
-                    out = out_dir / f"boot_v4_{compression}_{slot}.img"
-                    # Replace kernel
-                    common[2] = out_dir / f"gki_boot_{compression}_kernel"
-
-                    subprocess.run(
-                        common + ["--header_version", "4", "-o", out],
-                        check=True,
-                        stderr=subprocess.STDOUT,
-                    )
-
-            # Generates init_boot
-            subprocess.run(
-                [
-                    MKBOOTIMG_TOOL,
-                    "-o",
-                    out_dir / f"init_boot_{slot}.img",
-                    "--ramdisk",
-                    generic_ramdisk,
-                    # init_boot uses fixed version 4.
-                    "--header_version",
-                    "4",
-                ],
-                check=True,
-                stderr=subprocess.STDOUT,
-            )
-
-            # Generates vendor_boot images
-            common = [
-                MKBOOTIMG_TOOL,
-                "--vendor_cmdline",
-                vendor_cmdline,
-                "--vendor_ramdisk",
-                vendor_ramdisk,
-                "--dtb",
-                out_dir / "device_tree.dtb",
-            ]
-            # Generates vendor_boot v3 (no bootconfig)
-            subprocess.run(
-                common
-                + [
-                    "--dtb",
-                    out_dir / "device_tree.dtb",
-                    "--vendor_boot",
-                    out_dir / f"vendor_boot_v3_{slot}.img",
-                    "--header_version",
-                    "3",
-                ],
-                stderr=subprocess.STDOUT,
-                check=True,
-            )
-            # Generates vendor_boot v4
-            subprocess.run(
-                common
-                + [
-                    "--dtb",
-                    out_dir / "device_tree.dtb",
-                    "--vendor_boot",
-                    out_dir / f"vendor_boot_v4_{slot}.img",
-                    "--vendor_bootconfig",
-                    vendor_bootconfig,
-                    "--header_version",
-                    "4",
-                ],
-                stderr=subprocess.STDOUT,
-                check=True,
-            )
-            # Generates vendor_boot v4 with dttable structure
-            subprocess.run(
-                common
-                + [
-                    "--dtb",
-                    out_dir / "dtb.img",
-                    "--vendor_boot",
-                    out_dir / f"vendor_boot_v4_dttable_{slot}.img",
-                    "--vendor_bootconfig",
-                    vendor_bootconfig,
-                    "--header_version",
-                    "4",
-                ],
-                stderr=subprocess.STDOUT,
-                check=True,
-            )
-
-            # Generates a vbmeta data for v0 - v2 setup
-            for i in [0, 1, 2]:
-                parts = [
-                    (f"boot", out_dir / f"boot_v{i}_{slot}.img"),
-                    ("dtbo", out_dir / f"dtbo_{slot}.img"),
-                    ("dtb", out_dir / f"dtb_{slot}.img"),
-                ]
-                gen_android_test_vbmeta(
-                    parts, out_dir / f"vbmeta_v{i}_{slot}.img"
-                )
-
-            # Generates different combinations of v3/v4 boot/vendor_boot/init_boot setup.
-            for use_init_boot in [True, False]:
-                for boot_ver in [3, 4]:
-                    if use_init_boot:
-                        boot = (
-                            out_dir / f"boot_no_ramdisk_v{boot_ver}_{slot}.img"
-                        )
-                    else:
-                        boot = out_dir / f"boot_v{boot_ver}_{slot}.img"
-
-                    for vendor_ver in [3, 4]:
-                        vendor_boot = (
-                            out_dir / f"vendor_boot_v{vendor_ver}_{slot}.img"
-                        )
-
-                        parts = [
-                            (f"boot", boot),
-                            (f"vendor_boot", vendor_boot),
-                            ("dtbo", out_dir / f"dtbo_{slot}.img"),
-                            ("dtb", out_dir / f"dtb_{slot}.img"),
-                        ]
-                        prefix = f"vbmeta_v{boot_ver}_v{vendor_ver}"
-                        if use_init_boot:
-                            vbmeta_out = prefix + f"_init_boot_{slot}.img"
-                            parts += [
-                                (
-                                    "init_boot",
-                                    out_dir / f"init_boot_{slot}.img",
-                                )
-                            ]
-                        else:
-                            vbmeta_out = prefix + f"_{slot}.img"
-
-                        gen_android_test_vbmeta(parts, out_dir / vbmeta_out)
-
-            # Generate v4 vbmeta image for vendor_boot with dttable structure
-            vbmeta_out = out_dir / \
-                f"vbmeta_v4_dttable_{slot}.img"
-            parts = [
-                (f"boot", out_dir /
-                    f"boot_v4_{slot}.img"),
-                (f"vendor_boot", out_dir /
-                    f"vendor_boot_v4_dttable_{slot}.img"),
-                ("dtbo", out_dir / f"dtbo_{slot}.img"),
-                ("dtb", out_dir / f"dtb_{slot}.img"),
-            ]
-            gen_android_test_vbmeta(parts, vbmeta_out)
-
-            # Generate v4 vbmeta images for both gzip and lz4 kernel compression.
-            if slot == "a":
-                for compression in ["gz", "lz4"]:
-                    vbmeta_out = out_dir / \
-                        f"vbmeta_v4_{compression}_{slot}.img"
-                    parts = [
-                        (f"boot", out_dir /
-                         f"boot_v4_{compression}_{slot}.img"),
-                        (f"vendor_boot", out_dir /
-                         f"vendor_boot_v4_{slot}.img"),
-                        ("dtbo", out_dir / f"dtbo_{slot}.img"),
-                        ("dtb", out_dir / f"dtb_{slot}.img"),
-                    ]
-                    gen_android_test_vbmeta(parts, vbmeta_out)
-
-
-def gen_zircon_test_images(zbi_tool):
-    if not zbi_tool:
-        print(
-            "Warning: ZBI tool not provided. Skip regenerating zircon test"
-            " images"
-        )
-        return
-
-    ATX_METADATA = AVB_TEST_DATA_DIR / "cert_metadata.bin"
-
-    with tempfile.TemporaryDirectory() as temp_dir:
-        for slot in ["a", "b", "r", "slotless"]:
-            temp_dir = pathlib.Path(temp_dir)
-            random.seed(RNG_SEED_ZIRCON[slot])
-            out_kernel_bin_file = temp_dir / f"zircon_{slot}.bin"
-            # The first 16 bytes are two u64 integers representing `entry` and
-            # `reserve_memory_size`.
-            # Set `entry` value to 2048 and `reserve_memory_size` to 1024.
-            kernel_bytes = int(2048).to_bytes(8, "little") + int(1024).to_bytes(
-                8, "little"
-            )
-            kernel_bytes += random.randbytes(1 * SZ_KB - 16)
-            out_kernel_bin_file.write_bytes(kernel_bytes)
-            out_zbi_file = SCRIPT_DIR / f"zircon_{slot}.zbi"
-            # Puts image in a zbi container.
-            subprocess.run(
-                [
-                    zbi_tool,
-                    "--output",
-                    out_zbi_file,
-                    "--type=KERNEL_X64",
-                    out_kernel_bin_file,
-                ]
-            )
-
-            # Generates vbmeta descriptor.
-            vbmeta_desc = f"{temp_dir}/zircon_{slot}.vbmeta.desc"
-            subprocess.run(
-                [
-                    AVB_TOOL,
-                    "add_hash_footer",
-                    "--image",
-                    out_zbi_file,
-                    "--partition_name",
-                    "zircon",
-                    "--do_not_append_vbmeta_image",
-                    "--output_vbmeta_image",
-                    vbmeta_desc,
-                    "--partition_size",
-                    "209715200",
-                ]
-            )
-            # Generates two cmdline ZBI items to add as property descriptors to
-            # vbmeta image for test.
-            vbmeta_prop_args = []
-            for i in range(2):
-                prop_zbi_payload = f"{temp_dir}/prop_zbi_payload_{i}.bin"
-                subprocess.run(
-                    [
-                        zbi_tool,
-                        "--output",
-                        prop_zbi_payload,
-                        "--type=CMDLINE",
-                        f"--entry=vb_prop_{i}=val",
-                    ]
-                )
-                vbmeta_prop_args += [
-                    "--prop_from_file",
-                    f"zbi_vb_prop_{i}:{prop_zbi_payload}",
-                ]
-                # Also adds a property where the key name does not starts with
-                # "zbi". The item should not be processed.
-                vbmeta_prop_args += [
-                    "--prop_from_file",
-                    f"vb_prop_{i}:{prop_zbi_payload}",
-                ]
-            # Generates vbmeta image
-            vbmeta_img = SCRIPT_DIR / f"vbmeta_{slot}.bin"
-            subprocess.run(
-                [
-                    AVB_TOOL,
-                    "make_vbmeta_image",
-                    "--output",
-                    vbmeta_img,
-                    "--key",
-                    PSK,
-                    "--algorithm",
-                    "SHA512_RSA4096",
-                    "--public_key_metadata",
-                    ATX_METADATA,
-                    "--include_descriptors_from_image",
-                    vbmeta_desc,
-                    "--rollback_index",
-                    f"{TEST_ROLLBACK_INDEX}",
-                    "--rollback_index_location",
-                    f"{TEST_ROLLBACK_INDEX_LOCATION}",
-                ]
-                + vbmeta_prop_args
-            )
-
-
-# Generates test data for A/B slot Manager writeback test
-def gen_writeback_test_bin():
-    subprocess.run(
-        [
-            GPT_TOOL,
-            SCRIPT_DIR / "writeback_test_disk.bin",
-            "64K",
-            "--partition=test_partition,4k,/dev/zero",
-        ],
-        check=True,
-    )
-
-
-def sha256_hash(path: pathlib.Path) -> bytes:
-    """Returns the SHA256 hash of the given file."""
-    hash_hex = (
-        subprocess.run(
-            ["sha256sum", path],
-            check=True,
-            capture_output=True,
-            text=True,
-        )
-        .stdout.split()[0]  # output is "<hash> <filename>".
-        .strip()
-    )
-    return bytes.fromhex(hash_hex)
-
-
-def gen_vbmeta():
-    """Creates the vbmeta keys and signs some images."""
-    # Use the test vbmeta keys from libavb.
-    for name in [
-        "testkey_rsa4096.pem",
-        "testkey_rsa4096_pub.pem",
-        "testkey_cert_psk.pem",
-        "cert_metadata.bin",
-        "cert_permanent_attributes.bin",
-    ]:
-        shutil.copyfile(AVB_TEST_DATA_DIR / name, SCRIPT_DIR / name)
-
-    # We need the permanent attribute SHA256 hash for libavb_cert callbacks.
-    hash_bytes = sha256_hash(SCRIPT_DIR / "cert_permanent_attributes.bin")
-    (SCRIPT_DIR / "cert_permanent_attributes.hash").write_bytes(hash_bytes)
-
-    # Also creates a corrupted version of the permanent attributes to test failure.
-    # This is a little bit of a pain but we don't have an easy way to do a SHA256 in Rust
-    # at the moment so we can't generate it on the fly.
-    bad_attrs = bytearray(
-        (SCRIPT_DIR / "cert_permanent_attributes.bin").read_bytes()
-    )
-    bad_attrs[4] ^= 0x01  # Bytes 0-3 = version, byte 4 starts the public key.
-    (SCRIPT_DIR / "cert_permanent_attributes.bad.bin").write_bytes(bad_attrs)
-    hash_bytes = sha256_hash(SCRIPT_DIR / "cert_permanent_attributes.bad.bin")
-    (SCRIPT_DIR / "cert_permanent_attributes.bad.hash").write_bytes(hash_bytes)
-
-    # Convert the public key to raw bytes for use in verification.
-    subprocess.run(
-        [
-            AVB_TOOL,
-            "extract_public_key",
-            "--key",
-            SCRIPT_DIR / "testkey_rsa4096_pub.pem",
-            "--output",
-            SCRIPT_DIR / "testkey_rsa4096_pub.bin",
-        ],
-        check=True,
-    )
-
-    with tempfile.TemporaryDirectory() as temp_dir:
-        temp_dir = pathlib.Path(temp_dir)
-
-        # Create the hash descriptor. We only need this temporarily until we add
-        # it into the final vbmeta image.
-        hash_descriptor_path = temp_dir / "hash_descriptor.bin"
-        subprocess.run(
-            [
-                AVB_TOOL,
-                "add_hash_footer",
-                "--dynamic_partition_size",
-                "--do_not_append_vbmeta_image",
-                "--partition_name",
-                "zircon_a",
-                "--image",
-                SCRIPT_DIR / "zircon_a.zbi",
-                "--output_vbmeta_image",
-                hash_descriptor_path,
-                "--salt",
-                "2000",
-            ],
-            check=True,
-        )
-
-        # Create the final signed vbmeta including the hash descriptor.
-        subprocess.run(
-            [
-                AVB_TOOL,
-                "make_vbmeta_image",
-                "--key",
-                SCRIPT_DIR / "testkey_rsa4096.pem",
-                "--algorithm",
-                "SHA512_RSA4096",
-                "--include_descriptors_from_image",
-                hash_descriptor_path,
-                "--output",
-                SCRIPT_DIR / "zircon_a.vbmeta",
-            ],
-            check=True,
-        )
-
-        # Also creates a vbmeta using the libavb_cert extension.
-        subprocess.run(
-            [
-                AVB_TOOL,
-                "make_vbmeta_image",
-                "--key",
-                SCRIPT_DIR / "testkey_cert_psk.pem",
-                "--public_key_metadata",
-                SCRIPT_DIR / "cert_metadata.bin",
-                "--algorithm",
-                "SHA512_RSA4096",
-                "--include_descriptors_from_image",
-                hash_descriptor_path,
-                "--output",
-                SCRIPT_DIR / "zircon_a.vbmeta.cert",
-            ]
-        )
-
-
-def _parse_args() -> argparse.Namespace:
-    parser = argparse.ArgumentParser(
-        description=__doc__,
-        formatter_class=argparse.RawDescriptionHelpFormatter,
-    )
-
-    parser.add_argument(
-        "--zbi_tool", default="", help="Path to the Fuchsia ZBI tool"
-    )
-
-    return parser.parse_args()
-
-
-if __name__ == "__main__":
-    args = _parse_args()
-    gen_writeback_test_bin()
-    gen_sparse_test_file()
-    gen_zircon_test_images(args.zbi_tool)
-    gen_vbmeta()
-    gen_android_test_images()
diff --git a/gbl/libgbl/testdata/sparse_test.bin b/gbl/libgbl/testdata/sparse_test.bin
deleted file mode 100644
index f6c1a39..0000000
Binary files a/gbl/libgbl/testdata/sparse_test.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/sparse_test_blk1024.bin b/gbl/libgbl/testdata/sparse_test_blk1024.bin
deleted file mode 100644
index c23fdf5..0000000
Binary files a/gbl/libgbl/testdata/sparse_test_blk1024.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/sparse_test_raw.bin b/gbl/libgbl/testdata/sparse_test_raw.bin
deleted file mode 100644
index 4ca95c7..0000000
Binary files a/gbl/libgbl/testdata/sparse_test_raw.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/testkey_cert_psk.pem b/gbl/libgbl/testdata/testkey_cert_psk.pem
deleted file mode 100644
index 71bfebf..0000000
--- a/gbl/libgbl/testdata/testkey_cert_psk.pem
+++ /dev/null
@@ -1,52 +0,0 @@
------BEGIN PRIVATE KEY-----
-MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQCy2mHwjC3ylCFF
-dzNkZPKOiZzrUiPawe8OFcTJOySMv0/P4fILDiZuhC1VLwMHquR6kQhvyP9ffeHl
-W3JHliiIFOcS71bxlO1aqVYFt3qF8A/qFVruLjpwh47+WEPfWnCEeX2i8RGpUFh/
-oc2Ey1Dv+BuoHpNUFm2HsJgTe/R1EXadmGfTthvaVfWXb9nW/67YkMEWbH5MZ6BY
-bPXVpA+AN0IoQm+emSj2Ipve0TTGxgX3VQDzA8aTYimAVB+HuOq6p/UxiJu5GCyI
-AhqLsVVHd1qnxCn6eGKcaRACfy6n0mWLn/UXgi2h5hhI3TFGpFSU5ZXB6TfDfYNe
-uzE8njYZloWVrbSy0IascNK9JnQy9/ySy8l5Fw67QByNz9DDCRJJLE78e1ss73Dr
-pjOafwtE6P+koRZe6SbE8NS2v1qiSSoCiBt6lgjOIMR9+KMp7vk8oLEfBBTMc4JR
-4hiZkxPW6j8PYTuiJDs8h7ItZ5awisabbE5URvDc5DscWSE8KbGMa8iXHMJK1Eam
-uko4EIQ/fod5BQ1vpJeS4vPAMqeKMufBHJUcuBkUi0au5Ux8lSNkU0591RfFfmUL
-AodIqtXX39yHMN7SQqQAfAibdcDWmujN9F/Js4OHCWuhj1q6VUhSEEEqtDeX01sH
-xlghCFg8lNO5GeDG5SDyGsdxY+iObQIDAQABAoICAEQwEkr9hr8HTrAHRCawffFt
-8c+d32GVsqhyEDaQP90RS0J8aCVi3bAg4I+rfsI7myRHiynjPcmQWsFw3d8BFq7b
-GUYUzdcI6n04Nj2zuBi8b7TVM3e/VDR22kOKL0ZGWsOG9ilbM1qT8UmnzI0mXtM+
-inzMO2tBqbyjzTcQeSDw6YIoCt2ifnf9ccastCbOEEEs3xDHiFdk4rMTx54OEILX
-jnd+7MNQrVc51qdap35pHPkxBU2hUOH7+MqeR+8cxxEm28poxMYKu1+XPbuoflTi
-4kM3/LErmJz9SUdKaeU9x801zOGLlg41hWiyPAksubqS1Ue6vLHhdmZ1g84Sm5j+
-lABJXRBnc1YG/nyJZlFvMhp7gCXVDYQ4nUT4y2Ozd7ip9BweBzVoXQSMvjWfQvvb
-fzqJS0dNKqMQQU78x+B1g8iNgL9PCCkEeFN1YZwkJQMfQLdv+fgP9GEHlE/zz1Sv
-lZNpve0CARWZUg0Nbw1w9fsbeezJpCntZMs4wVMS0Vyn9TmFAEielILmmW/tkUyR
-WpZI7l4AYX4Rzx+nnVVwrSO9UDqp+2aiOODXpL3RboFi8qbblZWvNy7/mSKSKxwv
-E7Z7a8qMcaFsOy7LKSsbheZNWyyhQlfe3yNeYKMDj3rFmooNpJd0hU2kqt1fZKQK
-SIyutcEHQFP/p1LP1X9ZAoIBAQDdNg0o3FdYySCYTc5N6T+SUai8FyOlUhXvh7wn
-m28QmC8YBafjUAPXQYJYKiKtyb1/34FSgaBS9kv5nNL5HYxr15HW7aVrFUV3kSnT
-2+yuRrzHiN4B0ZuHlaRHd/fSmuOADM8b/s+CaYeWSWq0qE54uDRSa541OSENxIAq
-9f83rNcg8JF/eYaJQ4bAHzDdjCPS+nSJFtfVmswyoLFZBEeBdyR7zyXPBcLKPSvc
-4BfBbnrrh+boUvw6hgijDopAQVvyzuDECuA7+0Nsx/7M4p0154kxqgmP/ixuamrF
-0Wdx/VOOeXMZ7pEN8hInr4XJ3QEWcxHDl7Yj2Pk8jzduCBQfAoIBAQDO+v9Ax3RH
-E2kw+ce6k1K/u37Foku4EgAMuAHPtlEX0HjbC7t67p8mdqFfOLe3Gka8EFvwpmbr
-af1fWijErCLxv+JtVsQuv2cr4aFBjs+F/NRaNtY4fS5732O7kGML8y1qtLXGi6qS
-bdsdTjhjA2s65tU/lE7g6vJEhAFUtTA9PPZxFQfIv6mFtW0yvdgZcdi3wH7s/NAX
-SVkgxPnBwUpLnJ+NvK6dRt6dxr1d5cp2ghWhryt3FOUVl60e0dbJrykOedl/rWF6
-C3fCQnyWQx8Yzq1Lk/CTfzHln9YIDkyYT0DD6ccNJ2OBECsP0+zMKMfPUBYu2vep
-w3Yh826Hm+vzAoIBAEKBOI2bSOtZdGI1qhuET2d3A2qg7keKmSutPCUQNuDfT/FB
-6gqOCMmTWVOWP1zONRmXoXKjpAatI4RE4KyidJALfD4Irl22RG9BBjk6ejqe66x1
-eoFDeiXWGFCgQbJgfJsHvtBk2BAWF/xX0CvGGelzP8+zqRnJNiXEeN/xmywq23Z8
-vNF9QLRNx9pExlUlB7QrNhPs+TCv3EowQ4FGpxTGNALA8VX/HmPc5i3+dUXjKDNd
-ZU9de5VArKIRAgF1ZOZnye1Gc8m0rb2rlvAUBT2qgXWb8EoJGWSMu9MDNL1xcsh3
-vOID9joiF9E0lN1ugyAzshiCqPC4D55kVD7RUPMCggEBAIzg/GHcIEHMbXm/WXmd
-kuIbvTLJv53+6ne9usXlQxbhd5EoUChhSIQGlNnaIfmH8gNJYzrOGBk94A5JsJwE
-yhgf0f834norHw8YGQklKgz5xJPO5Uo3si7wItLkePYGQ7BwZZVJNQVLrqsotWp3
-RkImIZmP2YxvfgyyiLFeTgIwf1ECznSON9VhYnz6CJ9xBOA1Lm8huIVREFAkohaF
-+Iq0hUkU1wkH1rgvMG872+2DpzOQphX8a9yhi10B2J8YEOrgdvDXUxSdv5rCZEhm
-UUEyU3OwszvBhHXVr/l1uh6lOuDeOvSyDaEoHxc72N4xF6b8zMyBj7bF6p87MM0u
-jI8CggEBAIzDR/EGdJEQJrm4ZFbBrWyxYzKQLCTQ3IpKVVzmaSEy6iXegsTfFbVz
-TgHMWh0lUBnokoFSQrPZ5fVng1+AfZOPRToBYLwjVM7mprsmnrjGevJK9VzejOrc
-O9NLOlnBL7lNUjDLl2vfzI3O9kwE0OKgfu/kjHNW4WtssQwexsu8kMLbd5sC1txI
-G4uHedf6AMwty1m4jLC0MAu40N/CGbyQMfQmAG1ozinFuKTUMgN5f3TjdKMdWx6u
-35hLzEgfvrNcu2/Awt6sdmfKPesbKrSBN/5I3NXfFbaI/4aUkjMKqTr2frDt6ZDJ
-PqPOQDQM7f0JPuFGA9kFRaKUQygQckw=
------END PRIVATE KEY-----
diff --git a/gbl/libgbl/testdata/testkey_rsa4096.pem b/gbl/libgbl/testdata/testkey_rsa4096.pem
deleted file mode 100644
index 26db5c3..0000000
--- a/gbl/libgbl/testdata/testkey_rsa4096.pem
+++ /dev/null
@@ -1,51 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIJKQIBAAKCAgEA2ASv49OEbH4NiT3CjNMSVeliyfEPXswWcqtEfCxlSpS1FisA
-uwbvEwdTTPlkuSh6G4SYiNhnpCP5p0vcSg/3OhiuVKgV/rCtrDXaO60nvK/o0y83
-NNZRK2xaJ9eWBq9ruIDK+jC0sYWzTaqqwxY0Grjnx/r5CXerl5PrRK7PILzwgBHb
-IwxHcblt1ntgR4cWVpO3wiqasEwBDDDYk4fw7W6LvjBb9qav3YB8RV6PkZNeRP64
-ggfuecq/MXNiWOPNxLzCER2hSr/+J32h9jWjXsrcVy8+8Mldhmr4r2an7c247aFf
-upuFGtUJrpROO8/LXMl5gPfMpkqoatjTMRH59gJjKhot0RpmGxZBvb33TcBK5SdJ
-X39Y4yct5clmDlI4Fjj7FutTP+b96aJeJVnYeUX/A0wmogBajsJRoRX5e/RcgZsY
-RzXYLQXprQ81dBWjjovMJ9p8XeT6BNMFC7o6sklFL0fHDUE/l4BNP8G1u3Bfpzev
-SCISRS71D4eS4oQB+RIPFBUkzomZ7rnEF3BwFeq+xmwfYrP0LRaH+1YeRauuMuRe
-ke1TZl697a3mEjkNg8noa2wtpe7EWmaujJfXDWxJx/XEkjGLCe4z2qk3tkkY+A5g
-Rcgzke8gVxC+eC2DJtbKYfkv4L8FMFJaEhwAp13MfC7FlYujO/BDLl7dANsCAwEA
-AQKCAgAWoL8P/WsktjuSwb5sY/vKtgzcHH1Ar942GsysuTXPDy686LpF3R8T/jNy
-n7k2UBAia8xSoWCR6BbRuHeV5oA+PLGeOpE7QaSfonB+yc+cy0x3Or3ssfqEsu/q
-toGHp75/8DXS6WE0K04x94u1rdC9b9sPrrGBlWCLGzqM0kbuJfyHXdd3n2SofAUO
-b5QRSgxD+2tHUpEroHqHnWJCaf4J0QegX45yktlfOYNK/PHLDQXV8ly/ejc32M4Y
-Tv7hUtOOJTuq8VCg9OWZm2Zo1QuM9XEJTPCp5l3+o5vzO6yhk2gotDvD32CdA+3k
-tLJRP54M1Sn+IXb1gGKN9rKAtGJbenWIPlNObhQgkbwG89Qd+5rfMXsiPv1Hl1tK
-+tqwjD82/H3/ElaaMnwHCpeoGSp95OblAoBjzjMP2KsbvKSdL8O/rf1c3uOw9+DF
-cth0SA8y3ZzI11gJtb2QMGUrCny5n4sPGGbc3x38NdLhwbkPKZy60OiT4g2kNpdY
-dIitmAML2otttiF4AJM6AraPk8YVzkPLTksoL3azPBya5lIoDI2H3QvTtSvpXkXP
-yKchsDSWYbdqfplqC/X0Djp2/Zd8jpN5I6+1aSmpTmbwx/JTllY1N89FRZLIdxoh
-2k81LPiXhE6uRbjioJUlbnEWIpY2y2N2Clmxpjh0/IcXd1XImQKCAQEA7Zai+yjj
-8xit24aO9Tf3mZBXBjSaDodjC2KS1yCcAIXp6S7aH0wZipyZpQjys3zaBQyMRYFG
-bQqIfVAa6inWyDoofbAJHMu5BVcHFBPZvSS5YhDjc8XZ5dqSCxzIz9opIqAbm+b4
-aEV/3A3Jki5Dy8y/5j21GAK4Y4mqQOYzne7bDGi3Hyu041MGM4qfIcIkS5N1eHW4
-sDZJh6+K5tuxN5TX3nDZSpm9luNH8mLGgKAZ15b1LqXAtM5ycoBY9Hv082suPPom
-O+r0ybdRX6nDSH8+11y2KiP2kdVIUHCGkwlqgrux5YZyjCZPwOvEPhzSoOS+vBiF
-UVXA8idnxNLk1QKCAQEA6MIihDSXx+350fWqhQ/3Qc6gA/t2C15JwJ9+uFWA+gjd
-c/hn5HcmnmBJN4R04nLG/aU9SQur87a4mnC/Mp9JIARjHlZ/WNT4U0sJyPEVRg5U
-Z9VajAucWwi0JyJYCO1EMMy68Jp8qlTriK/L7nbD86JJ5ASxjojiN/0psK/Pk60F
-Rr+shKPi3jRQ1BDjDtAxOfo4ctf/nFbUM4bY0FNPQMP7WesoSKU0NBCRR6d0d2tq
-YflMjIQHx+N74P5jEdSCHTVGQm+dj47pUt3lLPLWc0bX1G/GekwXP4NUsR/70Hsi
-bwxkNnK2TSGzkt2rcOnutP125rJu6WpV7SNrq9rm7wKCAQAfMROcnbWviKHqnDPQ
-hdR/2K9UJTvEhInASOS2UZWpi+s1rez9BuSjigOx4wbaAZ4t44PW7C3uyt84dHfU
-HkIQb3I5bg8ENMrJpK9NN33ykwuzkDwMSwFcZ+Gci97hSubzoMl/IkeiiN1MapL4
-GhLUgsD+3UMVL+Y9SymK8637IgyoCGdiND6/SXsa8SwLJo3VTjqx4eKpX7cvlSBL
-RrRxc50TmwUsAhsd4CDl9YnSATLjVvJBeYlfM2tbFPaYwl1aR8v+PWkfnK0efm60
-fHki33HEnGteBPKuGq4vwVYpn6bYGwQz+f6335/A2DMfZHFSpjVURHPcRcHbCMla
-0cUxAoIBAQC25eYNkO478mo+bBbEXJlkoqLmvjAyGrNFo48F9lpVH6Y0vNuWkXJN
-PUgLUhAu6RYotjGENqG17rz8zt/PPY9Ok2P3sOx8t00y1mIn/hlDZXs55FM0fOMu
-PZaiscAPs7HDzvyOmDah+fzi+ZD8H2M3DS2W+YE0iaeJa2vZJS2t02W0BGXiDI33
-IZDqMyLYvwwPjOnShJydEzXID4xLl0tNjzLxo3GSNA7jYqlmbtV8CXIc7rMSL6WV
-ktIDKKJcnmpn3TcKeX6MEjaSIT82pNOS3fY3PmXuL+CMzfw8+u77Eecq78fHaTiL
-P5JGM93F6mzi19EY0tmInUBMCWtQLcENAoIBAQCg0KaOkb8T36qzPrtgbfou0E2D
-ufdpL1ugmD4edOFKQB5fDFQhLnSEVSJq3KUg4kWsXapQdsBd6kLdxS+K6MQrLBzr
-4tf0c7UCF1AzWk6wXMExZ8mRb2RkGZYQB2DdyhFB3TPmnq9CW8JCq+6kxg/wkU4s
-vM4JXzgcqVoSf42QJl+B9waeWhg0BTWx01lal4ds88HvEKmE0ik5GwiDbr7EvDDw
-E6UbZtQcIoSTIIZDgYqVFfR2DAho3wXJRsOXh433lEJ8X7cCDzrngFbQnlKrpwML
-Xgm0SIUc+Nf5poMM3rfLFK77t/ob4w+5PwRKcoSniyAxrHd6bwykYA8Vuydv
------END RSA PRIVATE KEY-----
diff --git a/gbl/libgbl/testdata/testkey_rsa4096_pub.bin b/gbl/libgbl/testdata/testkey_rsa4096_pub.bin
deleted file mode 100644
index f2e8fbd..0000000
Binary files a/gbl/libgbl/testdata/testkey_rsa4096_pub.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/testkey_rsa4096_pub.pem b/gbl/libgbl/testdata/testkey_rsa4096_pub.pem
deleted file mode 100644
index efd7144..0000000
--- a/gbl/libgbl/testdata/testkey_rsa4096_pub.pem
+++ /dev/null
@@ -1,14 +0,0 @@
------BEGIN PUBLIC KEY-----
-MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA2ASv49OEbH4NiT3CjNMS
-VeliyfEPXswWcqtEfCxlSpS1FisAuwbvEwdTTPlkuSh6G4SYiNhnpCP5p0vcSg/3
-OhiuVKgV/rCtrDXaO60nvK/o0y83NNZRK2xaJ9eWBq9ruIDK+jC0sYWzTaqqwxY0
-Grjnx/r5CXerl5PrRK7PILzwgBHbIwxHcblt1ntgR4cWVpO3wiqasEwBDDDYk4fw
-7W6LvjBb9qav3YB8RV6PkZNeRP64ggfuecq/MXNiWOPNxLzCER2hSr/+J32h9jWj
-XsrcVy8+8Mldhmr4r2an7c247aFfupuFGtUJrpROO8/LXMl5gPfMpkqoatjTMRH5
-9gJjKhot0RpmGxZBvb33TcBK5SdJX39Y4yct5clmDlI4Fjj7FutTP+b96aJeJVnY
-eUX/A0wmogBajsJRoRX5e/RcgZsYRzXYLQXprQ81dBWjjovMJ9p8XeT6BNMFC7o6
-sklFL0fHDUE/l4BNP8G1u3BfpzevSCISRS71D4eS4oQB+RIPFBUkzomZ7rnEF3Bw
-Feq+xmwfYrP0LRaH+1YeRauuMuReke1TZl697a3mEjkNg8noa2wtpe7EWmaujJfX
-DWxJx/XEkjGLCe4z2qk3tkkY+A5gRcgzke8gVxC+eC2DJtbKYfkv4L8FMFJaEhwA
-p13MfC7FlYujO/BDLl7dANsCAwEAAQ==
------END PUBLIC KEY-----
diff --git a/gbl/libgbl/testdata/vbmeta_a.bin b/gbl/libgbl/testdata/vbmeta_a.bin
deleted file mode 100644
index fd2c81c..0000000
Binary files a/gbl/libgbl/testdata/vbmeta_a.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/vbmeta_b.bin b/gbl/libgbl/testdata/vbmeta_b.bin
deleted file mode 100644
index 079e385..0000000
Binary files a/gbl/libgbl/testdata/vbmeta_b.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/vbmeta_r.bin b/gbl/libgbl/testdata/vbmeta_r.bin
deleted file mode 100644
index d9a8f5f..0000000
Binary files a/gbl/libgbl/testdata/vbmeta_r.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/vbmeta_slotless.bin b/gbl/libgbl/testdata/vbmeta_slotless.bin
deleted file mode 100644
index 51c7677..0000000
Binary files a/gbl/libgbl/testdata/vbmeta_slotless.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/writeback_test_disk.bin b/gbl/libgbl/testdata/writeback_test_disk.bin
deleted file mode 100644
index 50cbc21..0000000
Binary files a/gbl/libgbl/testdata/writeback_test_disk.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_a.vbmeta b/gbl/libgbl/testdata/zircon_a.vbmeta
deleted file mode 100644
index f41a0c1..0000000
Binary files a/gbl/libgbl/testdata/zircon_a.vbmeta and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_a.vbmeta.cert b/gbl/libgbl/testdata/zircon_a.vbmeta.cert
deleted file mode 100644
index e34530e..0000000
Binary files a/gbl/libgbl/testdata/zircon_a.vbmeta.cert and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_a.zbi b/gbl/libgbl/testdata/zircon_a.zbi
deleted file mode 100644
index 1d5b735..0000000
Binary files a/gbl/libgbl/testdata/zircon_a.zbi and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_b.bin b/gbl/libgbl/testdata/zircon_b.bin
deleted file mode 100644
index fb38746..0000000
Binary files a/gbl/libgbl/testdata/zircon_b.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_b.zbi b/gbl/libgbl/testdata/zircon_b.zbi
deleted file mode 100644
index ff7877b..0000000
Binary files a/gbl/libgbl/testdata/zircon_b.zbi and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_r.bin b/gbl/libgbl/testdata/zircon_r.bin
deleted file mode 100644
index d7fd360..0000000
Binary files a/gbl/libgbl/testdata/zircon_r.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_r.zbi b/gbl/libgbl/testdata/zircon_r.zbi
deleted file mode 100644
index bd04d98..0000000
Binary files a/gbl/libgbl/testdata/zircon_r.zbi and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_slotless.zbi b/gbl/libgbl/testdata/zircon_slotless.zbi
deleted file mode 100644
index 6e83f65..0000000
Binary files a/gbl/libgbl/testdata/zircon_slotless.zbi and /dev/null differ
diff --git a/gbl/libgbl/tests/nostd.rs b/gbl/libgbl/tests/nostd.rs
deleted file mode 100644
index 157799b..0000000
--- a/gbl/libgbl/tests/nostd.rs
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This is a compilation-only test to ensure that libgbl can build against
-//! [no_std] code.
-//!
-//! This also provides a reference for the Rust hooks that a [no_std] user must
-//! provide in order to build against libgbl.
-
-#![no_main]
-#![no_std]
-
-// use core::panic::PanicInfo;
-
-use gbl as _;
-
-use buddy_system_allocator::LockedHeap;
-
-// Providing allocator to satisfy AVB dependency
-#[global_allocator]
-static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();
-
-static mut HEAP: [u8; 65536] = [0; 65536];
-
-// #[panic_handler]
-// fn panic(_: &PanicInfo) -> ! {
-//     loop {}
-// }
-
-/// main() entry point replacement required by [no_std].
-#[no_mangle]
-pub fn main() -> ! {
-    // SAFETY: Safe because `HEAP` is only used here and `entry` is only called once.
-    unsafe {
-        // Give the allocator some memory to allocate.
-        HEAP_ALLOCATOR.lock().init(HEAP.as_mut_ptr() as usize, HEAP.len());
-    }
-
-    panic!()
-}
diff --git a/gbl/libmisc/BUILD b/gbl/libmisc/BUILD
deleted file mode 100644
index c3af785..0000000
--- a/gbl/libmisc/BUILD
+++ /dev/null
@@ -1,38 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libmisc",
-    srcs = ["src/lib.rs"],
-    crate_name = "misc",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//liberror",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libmisc_test",
-    crate = ":libmisc",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
diff --git a/gbl/libmisc/src/lib.rs b/gbl/libmisc/src/lib.rs
deleted file mode 100644
index 208dd88..0000000
--- a/gbl/libmisc/src/lib.rs
+++ /dev/null
@@ -1,175 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides APIs to work with data structures inside Android misc partition.
-//!
-//! Reference code:
-//! https://cs.android.com/android/platform/superproject/main/+/main:bootable/recovery/bootloader_message/include/bootloader_message/bootloader_message.h
-//!
-//! TODO(b/329716686): Generate rust bindings for misc API from recovery to reuse the up to date
-//! implementation
-
-#![cfg_attr(not(test), no_std)]
-
-use core::ffi::CStr;
-
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout, Ref};
-
-use liberror::{Error, Result};
-
-/// Android boot modes type
-/// Usually obtained from BCB block of misc partition
-#[derive(PartialEq, Debug)]
-pub enum AndroidBootMode {
-    /// Boot normally using A/B slots.
-    Normal = 0,
-    /// Boot into recovery mode using A/B slots.
-    Recovery,
-    /// Stop in bootloader fastboot mode.
-    BootloaderBootOnce,
-}
-
-impl core::fmt::Display for AndroidBootMode {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        match *self {
-            AndroidBootMode::Normal => write!(f, "AndroidBootMode::Normal"),
-            AndroidBootMode::Recovery => write!(f, "AndroidBootMode::Recovery"),
-            AndroidBootMode::BootloaderBootOnce => write!(f, "AndroidBootMode::BootloaderBootOnce"),
-        }
-    }
-}
-
-/// BCB command field offset within BCB block.
-pub const COMMAND_FIELD_OFFSET: usize = 0;
-
-/// BCB command field size in bytes.
-pub const COMMAND_FIELD_SIZE: usize = 32;
-
-/// Android bootloader message structure that usually placed in the first block of misc partition
-///
-/// Reference code:
-/// https://cs.android.com/android/platform/superproject/main/+/95ec3cc1d879b92dd9db3bb4c4345c5fc812cdaa:bootable/recovery/bootloader_message/include/bootloader_message/bootloader_message.h;l=67
-#[repr(C, packed)]
-#[derive(IntoBytes, FromBytes, Immutable, KnownLayout, PartialEq, Copy, Clone, Debug)]
-pub struct BootloaderMessage {
-    command: [u8; COMMAND_FIELD_SIZE],
-    status: [u8; 32],
-    recovery: [u8; 768],
-    stage: [u8; 32],
-    reserved: [u8; 1184],
-}
-
-impl BootloaderMessage {
-    /// BCB size in bytes
-    pub const SIZE_BYTES: usize = 2048;
-
-    /// Extract BootloaderMessage reference from bytes
-    pub fn from_bytes_ref(buffer: &[u8]) -> Result<&BootloaderMessage> {
-        Ok(Ref::into_ref(
-            Ref::<_, BootloaderMessage>::new_from_prefix(buffer)
-                .ok_or(Error::BufferTooSmall(Some(core::mem::size_of::<BootloaderMessage>())))?
-                .0
-                .into(),
-        ))
-    }
-
-    /// Extract AndroidBootMode from BCB command field
-    pub fn boot_mode(&self) -> Result<AndroidBootMode> {
-        let command = CStr::from_bytes_until_nul(&self.command)
-            .map_err(|_| Error::Other(Some("Cannot read BCB command")))?
-            .to_str()
-            .map_err(|_| Error::InvalidInput)?;
-
-        match command {
-            "" => Ok(AndroidBootMode::Normal),
-            "boot-recovery" | "boot-fastboot" => Ok(AndroidBootMode::Recovery),
-            "bootonce-bootloader" => Ok(AndroidBootMode::BootloaderBootOnce),
-            _ => Err(Error::Other(Some("Wrong BCB command"))),
-        }
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use crate::AndroidBootMode;
-    use crate::BootloaderMessage;
-    use zerocopy::IntoBytes;
-
-    impl Default for BootloaderMessage {
-        fn default() -> Self {
-            BootloaderMessage {
-                command: [0; 32],
-                status: [0; 32],
-                recovery: [0; 768],
-                stage: [0; 32],
-                reserved: [0; 1184],
-            }
-        }
-    }
-
-    #[test]
-    fn test_bcb_empty_parsed_as_normal() {
-        let bcb = BootloaderMessage::default();
-
-        assert_eq!(
-            BootloaderMessage::from_bytes_ref(bcb.as_bytes()).unwrap().boot_mode().unwrap(),
-            AndroidBootMode::Normal
-        );
-    }
-
-    #[test]
-    fn test_bcb_with_wrong_command_failed() {
-        let command = "boot-wrong";
-        let mut bcb = BootloaderMessage::default();
-        bcb.command[..command.len()].copy_from_slice(command.as_bytes());
-
-        assert!(BootloaderMessage::from_bytes_ref(bcb.as_bytes()).unwrap().boot_mode().is_err());
-    }
-
-    #[test]
-    fn test_bcb_to_recovery_parsed() {
-        let command = "boot-recovery";
-        let mut bcb = BootloaderMessage::default();
-        bcb.command[..command.len()].copy_from_slice(command.as_bytes());
-
-        assert_eq!(
-            BootloaderMessage::from_bytes_ref(bcb.as_bytes()).unwrap().boot_mode().unwrap(),
-            AndroidBootMode::Recovery
-        );
-    }
-
-    #[test]
-    fn test_bcb_to_fastboot_parsed_as_recovery() {
-        let command = "boot-fastboot";
-        let mut bcb = BootloaderMessage::default();
-        bcb.command[..command.len()].copy_from_slice(command.as_bytes());
-
-        assert_eq!(
-            BootloaderMessage::from_bytes_ref(bcb.as_bytes()).unwrap().boot_mode().unwrap(),
-            AndroidBootMode::Recovery
-        );
-    }
-
-    #[test]
-    fn test_bcb_to_bootloader_once_parsed() {
-        let command = "bootonce-bootloader";
-        let mut bcb = BootloaderMessage::default();
-        bcb.command[..command.len()].copy_from_slice(command.as_bytes());
-
-        assert_eq!(
-            BootloaderMessage::from_bytes_ref(bcb.as_bytes()).unwrap().boot_mode().unwrap(),
-            AndroidBootMode::BootloaderBootOnce
-        );
-    }
-}
diff --git a/gbl/libsafemath/BUILD b/gbl/libsafemath/BUILD
deleted file mode 100644
index 8d2b61d..0000000
--- a/gbl/libsafemath/BUILD
+++ /dev/null
@@ -1,34 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-rust_library(
-    name = "libsafemath",
-    srcs = [
-        "src/lib.rs",
-    ],
-    crate_name = "safemath",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-)
-
-rust_test(
-    name = "libsafemath_test",
-    crate = ":libsafemath",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/libsafemath/Cargo.toml b/gbl/libsafemath/Cargo.toml
deleted file mode 100644
index 79a4588..0000000
--- a/gbl/libsafemath/Cargo.toml
+++ /dev/null
@@ -1,17 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-[package]
-name = "safemath"
-version = "0.1.0"
diff --git a/gbl/libsafemath/src/lib.rs b/gbl/libsafemath/src/lib.rs
deleted file mode 100644
index f7f4ed9..0000000
--- a/gbl/libsafemath/src/lib.rs
+++ /dev/null
@@ -1,519 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! # safemath library
-//!
-//! This library provides an API to safely work with unsigned integers. At a high level, all math
-//! operations are checked by default rather than having to remember to call specific `checked_*`
-//! functions, so that the burden is on the programmer if they want to perform unchecked math
-//! rather than the other way around:
-//!
-//! ```
-//! use safemath::SafeNum;
-//!
-//! let safe = SafeNum::from(0);
-//! let result = safe - 1;
-//! assert!(u32::try_from(result).is_err());
-//!
-//! let safe_chain = (SafeNum::from(BIG_NUMBER) * HUGE_NUMBER) / MAYBE_ZERO;
-//! // If any operation would have caused an overflow or division by zero,
-//! // the number is flagged and the lexical location is specified for logging.
-//! if safe_chain.has_error() {
-//!     eprintln!("safe_chain error = {:#?}", safe_chain);
-//! }
-//! ```
-//!
-//! In addition to checked-by-default arithmetic, the API exposed here support
-//! more natural usage than the `checked_*` functions by allowing chaining
-//! of operations without having to check the result at each step.
-//! This is similar to how floating-point `NaN` works - you can continue to use the
-//! value, but continued operations will just propagate `NaN`.
-//!
-//! ## Supported Operations
-//!
-//! ### Arithmetic
-//! The basic arithmetic operations are supported:
-//! addition, subtraction, multiplication, division, and remainder.
-//! The right hand side may be another SafeNum or any integer,
-//! and the result is always another SafeNum.
-//! If the operation would result in an overflow or division by zero,
-//! or if converting the right hand element to a `u64` would cause an error,
-//! the result is an error-tagged SafeNum that tracks the lexical origin of the error.
-//!
-//! ### Conversion from and to SafeNum
-//! SafeNums support conversion to and from all integer types.
-//! Conversion to SafeNum from signed integers and from usize and u128
-//! can fail, generating an error value that is then propagated.
-//! Conversion from SafeNum to all integers is only exposed via `try_from`
-//! in order to force the user to handle potential resultant errors.
-//!
-//! E.g.
-//! ```
-//! fn call_func(_: u32, _: u32) {
-//! }
-//!
-//! fn do_a_thing(a: SafeNum) -> Result<(), safemath::Error> {
-//!     call_func(16, a.try_into()?);
-//!     Ok(())
-//! }
-//! ```
-//!
-//! ### Comparison
-//! SafeNums can be checked for equality against each other.
-//! Valid numbers are equal to other numbers of the same magnitude.
-//! Errored SafeNums are only equal to themselves.
-//! Note that because errors propagate from their first introduction in an
-//! arithmetic chain this can lead to surprising results.
-//!
-//! E.g.
-//! ```
-//! let overflow = SafeNum::MAX + 1;
-//! let otherflow = SafeNum::MAX + 1;
-//!
-//! assert_ne!(overflow, otherflow);
-//! assert_eq!(overflow + otherflow, overflow);
-//! assert_eq!(otherflow + overflow, otherflow);
-//! ```
-//!
-//! Inequality comparison operators are deliberately not provided.
-//! By necessity they would have similar caveats to floating point comparisons,
-//! which are easy to use incorrectly and unintuitive to use correctly.
-//!
-//! The required alternative is to convert to a real integer type before comparing,
-//! forcing any errors upwards.
-//!
-//! E.g.
-//! ```
-//! impl From<safemath::Error> for &'static str {
-//!     fn from(_: safemath::Error) -> Self {
-//!         "checked arithmetic error"
-//!     }
-//! }
-//!
-//! fn my_op(a: SafeNum, b: SafeNum, c: SafeNum, d: SafeNum) -> Result<bool, &'static str> {
-//!     Ok(safemath::Primitive::try_from(a)? < b.try_into()?
-//!        && safemath::Primitive::try_from(c)? >= d.try_into()?)
-//! }
-//! ```
-//!
-//! ### Miscellaneous
-//! SafeNums also provide helper methods to round up or down
-//! to the nearest multiple of another number
-//! and helper predicate methods that indicate whether the SafeNum
-//! is valid or is tracking an error.
-//!
-//! Also provided are constants `SafeNum::MAX`, `SafeNum::MIN`, and `SafeNum::ZERO`.
-//!
-//! Warning: SafeNums can help prevent, isolate, and detect arithmetic overflow
-//!          but they are not a panacea. In particular, chains of different operations
-//!          are not guaranteed to be associative or commutative.
-//!
-//! E.g.
-//! ```
-//! let a = SafeNum::MAX - 1 + 1;
-//! let b = SafeNum::MAX + 1 - 1;
-//! assert_ne!(a, b);
-//! assert!(a.is_valid());
-//! assert!(b.has_error());
-//!
-//! let c = (SafeNum::MAX + 31) / 31;
-//! let d = SafeNum::MAX / 31 + 31 / 31;
-//! assert_ne!(c, d);
-//! assert!(c.has_error());
-//! assert!(d.is_valid());
-//! ```
-//!
-//! Note:    SafeNum arithmetic is much slower than arithmetic on integer primitives.
-//!          If you are concerned about performance, be sure to run benchmarks.
-
-#![cfg_attr(not(test), no_std)]
-
-use core::convert::TryFrom;
-use core::fmt;
-use core::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Sub, SubAssign};
-use core::panic::Location;
-
-/// The underlying primitive type used for [SafeNum] operations.
-pub type Primitive = u64;
-/// Safe math error type, which points to the location of the original failed operation.
-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
-pub struct Error(&'static Location<'static>);
-
-impl From<&'static Location<'static>> for Error {
-    fn from(loc: &'static Location<'static>) -> Self {
-        Self(loc)
-    }
-}
-
-impl From<Error> for &'static Location<'static> {
-    fn from(err: Error) -> Self {
-        err.0
-    }
-}
-
-impl From<core::num::TryFromIntError> for Error {
-    #[track_caller]
-    fn from(_err: core::num::TryFromIntError) -> Self {
-        Self(Location::caller())
-    }
-}
-
-/// Wraps a raw [Primitive] type for safe-by-default math. See module docs for info and usage.
-#[derive(Copy, Clone, PartialEq, Eq)]
-pub struct SafeNum(Result<Primitive, Error>);
-
-impl fmt::Debug for SafeNum {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self.0 {
-            Ok(val) => write!(f, "{}", val),
-            Err(location) => write!(f, "error at {}", location),
-        }
-    }
-}
-
-impl fmt::Display for Error {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.0.fmt(f)
-    }
-}
-
-impl SafeNum {
-    /// The maximum [SafeNum].
-    pub const MAX: SafeNum = SafeNum(Ok(u64::MAX));
-    /// The minimum [SafeNum].
-    pub const MIN: SafeNum = SafeNum(Ok(u64::MIN));
-    /// Zero as a [SafeNum].
-    pub const ZERO: SafeNum = SafeNum(Ok(0));
-
-    /// Round `self` down to the nearest multiple of `rhs`.
-    #[track_caller]
-    pub fn round_down<T>(self, rhs: T) -> Self
-    where
-        Self: Rem<T, Output = Self>,
-    {
-        self - (self % rhs)
-    }
-
-    /// Round `self` up to the nearest multiple of `rhs`.
-    #[track_caller]
-    pub fn round_up<T>(self, rhs: T) -> Self
-    where
-        Self: Add<T, Output = Self>,
-        T: Copy + Into<Self>,
-    {
-        ((self + rhs) - 1).round_down(rhs)
-    }
-
-    /// Returns whether self is the result of an operation that has errored.
-    pub const fn has_error(&self) -> bool {
-        self.0.is_err()
-    }
-
-    /// Returns whether self represents a valid, non-overflowed integer.
-    pub const fn is_valid(&self) -> bool {
-        self.0.is_ok()
-    }
-}
-
-macro_rules! try_conversion_func {
-    ($other_type:tt) => {
-        impl TryFrom<SafeNum> for $other_type {
-            type Error = Error;
-
-            #[track_caller]
-            fn try_from(val: SafeNum) -> Result<Self, Self::Error> {
-                Self::try_from(val.0?).ok().ok_or(Location::caller().into())
-            }
-        }
-    };
-}
-
-macro_rules! conversion_func {
-    ($from_type:tt) => {
-        impl From<$from_type> for SafeNum {
-            fn from(val: $from_type) -> SafeNum {
-                Self(Ok(val.into()))
-            }
-        }
-
-        try_conversion_func!($from_type);
-    };
-}
-
-macro_rules! conversion_func_maybe_error {
-    ($from_type:tt) => {
-        impl From<$from_type> for SafeNum {
-            #[track_caller]
-            fn from(val: $from_type) -> Self {
-                Self(Primitive::try_from(val).ok().ok_or(Location::caller().into()))
-            }
-        }
-
-        try_conversion_func!($from_type);
-    };
-}
-
-macro_rules! arithmetic_impl {
-    ($trait_name:ident, $op:ident, $assign_trait_name:ident, $assign_op:ident, $func:ident) => {
-        impl<T: Into<SafeNum>> $trait_name<T> for SafeNum {
-            type Output = Self;
-            #[track_caller]
-            fn $op(self, rhs: T) -> Self {
-                let rhs: Self = rhs.into();
-
-                match (self.0, rhs.0) {
-                    (Err(_), _) => self,
-                    (_, Err(_)) => rhs,
-                    (Ok(lhs), Ok(rhs)) => Self(lhs.$func(rhs).ok_or(Location::caller().into())),
-                }
-            }
-        }
-
-        impl<T> $assign_trait_name<T> for SafeNum
-        where
-            Self: $trait_name<T, Output = Self>,
-        {
-            #[track_caller]
-            fn $assign_op(&mut self, rhs: T) {
-                *self = self.$op(rhs)
-            }
-        }
-    };
-}
-
-conversion_func!(u8);
-conversion_func!(u16);
-conversion_func!(u32);
-conversion_func!(u64);
-conversion_func_maybe_error!(usize);
-conversion_func_maybe_error!(u128);
-conversion_func_maybe_error!(i8);
-conversion_func_maybe_error!(i16);
-conversion_func_maybe_error!(i32);
-conversion_func_maybe_error!(i64);
-conversion_func_maybe_error!(i128);
-conversion_func_maybe_error!(isize);
-arithmetic_impl!(Add, add, AddAssign, add_assign, checked_add);
-arithmetic_impl!(Sub, sub, SubAssign, sub_assign, checked_sub);
-arithmetic_impl!(Mul, mul, MulAssign, mul_assign, checked_mul);
-arithmetic_impl!(Div, div, DivAssign, div_assign, checked_div);
-arithmetic_impl!(Rem, rem, RemAssign, rem_assign, checked_rem);
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_addition() {
-        let a: SafeNum = 2100.into();
-        let b: SafeNum = 12.into();
-        assert_eq!(a + b, 2112.into());
-    }
-
-    #[test]
-    fn test_subtraction() {
-        let a: SafeNum = 667.into();
-        let b: SafeNum = 1.into();
-        assert_eq!(a - b, 666.into());
-    }
-
-    #[test]
-    fn test_multiplication() {
-        let a: SafeNum = 17.into();
-        let b: SafeNum = 3.into();
-        assert_eq!(a * b, 51.into());
-    }
-
-    #[test]
-    fn test_division() {
-        let a: SafeNum = 1066.into();
-        let b: SafeNum = 41.into();
-        assert_eq!(a / b, 26.into());
-    }
-
-    #[test]
-    fn test_remainder() {
-        let a: SafeNum = 613.into();
-        let b: SafeNum = 10.into();
-        assert_eq!(a % b, 3.into());
-    }
-
-    #[test]
-    fn test_addition_poison() {
-        let base: SafeNum = 2.into();
-        let poison = base + SafeNum::MAX;
-        assert!(u64::try_from(poison).is_err());
-
-        let a = poison - 1;
-        let b = poison - 2;
-
-        assert_eq!(a, poison);
-        assert_eq!(b, poison);
-    }
-
-    #[test]
-    fn test_subtraction_poison() {
-        let base: SafeNum = 2.into();
-        let poison = base - SafeNum::MAX;
-        assert!(u64::try_from(poison).is_err());
-
-        let a = poison + 1;
-        let b = poison + 2;
-
-        assert_eq!(a, poison);
-        assert_eq!(b, poison);
-    }
-
-    #[test]
-    fn test_multiplication_poison() {
-        let base: SafeNum = 2.into();
-        let poison = base * SafeNum::MAX;
-        assert!(u64::try_from(poison).is_err());
-
-        let a = poison / 2;
-        let b = poison / 4;
-
-        assert_eq!(a, poison);
-        assert_eq!(b, poison);
-    }
-
-    #[test]
-    fn test_division_poison() {
-        let base: SafeNum = 2.into();
-        let poison = base / 0;
-        assert!(u64::try_from(poison).is_err());
-
-        let a = poison * 2;
-        let b = poison * 4;
-
-        assert_eq!(a, poison);
-        assert_eq!(b, poison);
-    }
-
-    #[test]
-    fn test_remainder_poison() {
-        let base: SafeNum = 2.into();
-        let poison = base % 0;
-        assert!(u64::try_from(poison).is_err());
-
-        let a = poison * 2;
-        let b = poison * 4;
-
-        assert_eq!(a, poison);
-        assert_eq!(b, poison);
-    }
-
-    macro_rules! conversion_test {
-        ($name:ident) => {
-            mod $name {
-                use super::*;
-                use core::convert::TryInto;
-
-                #[test]
-                fn test_between_safenum() {
-                    let var: $name = 16;
-                    let sn: SafeNum = var.into();
-                    let res: $name = sn.try_into().unwrap();
-                    assert_eq!(var, res);
-                }
-
-                #[test]
-                fn test_arithmetic_safenum() {
-                    let primitive: $name = ((((0 + 11) * 11) / 3) % 32) - 3;
-                    let safe = ((((SafeNum::ZERO + $name::try_from(11u8).unwrap())
-                        * $name::try_from(11u8).unwrap())
-                        / $name::try_from(3u8).unwrap())
-                        % $name::try_from(32u8).unwrap())
-                        - $name::try_from(3u8).unwrap();
-                    assert_eq!($name::try_from(safe).unwrap(), primitive);
-                }
-            }
-        };
-    }
-
-    conversion_test!(u8);
-    conversion_test!(u16);
-    conversion_test!(u32);
-    conversion_test!(u64);
-    conversion_test!(u128);
-    conversion_test!(usize);
-    conversion_test!(i8);
-    conversion_test!(i16);
-    conversion_test!(i32);
-    conversion_test!(i64);
-    conversion_test!(i128);
-    conversion_test!(isize);
-
-    macro_rules! correctness_tests {
-        ($name:ident, $operation:ident, $assign_operation:ident) => {
-            mod $operation {
-                use super::*;
-                use core::ops::$name;
-
-                #[test]
-                fn test_correctness() {
-                    let normal = 300u64;
-                    let safe: SafeNum = normal.into();
-                    let rhs = 7u64;
-                    assert_eq!(
-                        u64::try_from(safe.$operation(rhs)).unwrap(),
-                        normal.$operation(rhs)
-                    );
-                }
-
-                #[test]
-                fn test_assign() {
-                    let mut var: SafeNum = 2112.into();
-                    let rhs = 666u64;
-                    let expect = var.$operation(rhs);
-                    var.$assign_operation(rhs);
-                    assert_eq!(var, expect);
-                }
-
-                #[test]
-                fn test_assign_poison() {
-                    let mut var = SafeNum::MIN - 1;
-                    let expected = var - 1;
-                    var.$assign_operation(2);
-                    // Poison saturates and doesn't perform additional changes
-                    assert_eq!(var, expected);
-                }
-            }
-        };
-    }
-
-    correctness_tests!(Add, add, add_assign);
-    correctness_tests!(Sub, sub, sub_assign);
-    correctness_tests!(Mul, mul, mul_assign);
-    correctness_tests!(Div, div, div_assign);
-    correctness_tests!(Rem, rem, rem_assign);
-
-    #[test]
-    fn test_round_down() {
-        let x: SafeNum = 255.into();
-        assert_eq!(x.round_down(32), 224.into());
-        assert_eq!((x + 1).round_down(64), 256.into());
-        assert_eq!(x.round_down(256), SafeNum::ZERO);
-        assert!(x.round_down(SafeNum::MIN).has_error());
-    }
-
-    #[test]
-    fn test_round_up() {
-        let x: SafeNum = 255.into();
-        assert_eq!(x.round_up(32), 256.into());
-        assert_eq!(x.round_up(51), x);
-        assert_eq!(SafeNum::ZERO.round_up(x), SafeNum::ZERO);
-        assert!(SafeNum::MAX.round_up(32).has_error());
-    }
-}
diff --git a/gbl/libstorage/BUILD b/gbl/libstorage/BUILD
deleted file mode 100644
index 02ff0b9..0000000
--- a/gbl/libstorage/BUILD
+++ /dev/null
@@ -1,53 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_doc_test", "rust_library", "rust_test")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-rust_library(
-    name = "libstorage",
-    srcs = [
-        "src/algorithm.rs",
-        "src/gpt.rs",
-        "src/lib.rs",
-        "src/ram_block.rs",
-    ],
-    crate_name = "gbl_storage",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@crc32fast",
-        "@gbl//libasync",
-        "@gbl//liberror",
-        "@gbl//libsafemath",
-        "@gbl//libutils",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libstorage_test",
-    compile_data = ["@gbl//libstorage/test:test_data"],
-    crate = ":libstorage",
-    rustc_flags = ANDROID_RUST_LINTS,
-)
-
-rust_doc_test(
-    name = "libstorage_doc_test",
-    crate = ":libstorage",
-)
diff --git a/gbl/libstorage/src/algorithm.rs b/gbl/libstorage/src/algorithm.rs
deleted file mode 100644
index bff273e..0000000
--- a/gbl/libstorage/src/algorithm.rs
+++ /dev/null
@@ -1,338 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    as_uninit, check_range, is_aligned, is_buffer_aligned, BlockInfo, BlockIo, SliceMaybeUninit,
-};
-use core::cmp::min;
-use liberror::Result;
-use libutils::aligned_subslice;
-use safemath::SafeNum;
-
-/// Reads from a range at block boundary to an aligned buffer.
-async fn read_aligned_all(
-    io: &mut impl BlockIo,
-    offset: u64,
-    out: &mut (impl SliceMaybeUninit + ?Sized),
-) -> Result<()> {
-    let blk_offset = check_range(io.info(), offset, out.as_ref())?.try_into()?;
-    Ok(io.read_blocks(blk_offset, out).await?)
-}
-
-/// Read with block-aligned offset and aligned buffer. Size don't need to be block aligned.
-///   |~~~~~~~~~read~~~~~~~~~|
-///   |---------|---------|---------|
-async fn read_aligned_offset_and_buffer(
-    io: &mut impl BlockIo,
-    offset: u64,
-    out: &mut (impl SliceMaybeUninit + ?Sized),
-    scratch: &mut [u8],
-) -> Result<()> {
-    let block_size = SafeNum::from(io.info().block_size);
-    debug_assert!(is_aligned(offset, block_size)?);
-    debug_assert!(is_buffer_aligned(out.as_ref(), io.info().alignment)?);
-
-    let aligned_read: usize = SafeNum::from(out.len()).round_down(block_size).try_into()?;
-
-    if aligned_read > 0 {
-        read_aligned_all(io, offset, out.get_mut(..aligned_read)?).await?;
-    }
-    let unaligned = out.get_mut(aligned_read..)?;
-    if unaligned.is_empty() {
-        return Ok(());
-    }
-    // Read unalinged part.
-    let block_scratch = &mut scratch[..block_size.try_into()?];
-    let aligned_offset = SafeNum::from(offset) + aligned_read;
-    read_aligned_all(io, aligned_offset.try_into()?, block_scratch).await?;
-    unaligned.clone_from_slice(as_uninit(&block_scratch[..unaligned.len()]));
-    Ok(())
-}
-
-/// Read with aligned buffer. Offset and size don't need to be block aligned.
-/// Case 1:
-///            |~~~~~~read~~~~~~~|
-///        |------------|------------|
-/// Case 2:
-///          |~~~read~~~|
-///        |---------------|--------------|
-async fn read_aligned_buffer(
-    io: &mut impl BlockIo,
-    offset: u64,
-    out: &mut (impl SliceMaybeUninit + ?Sized),
-    scratch: &mut [u8],
-) -> Result<()> {
-    debug_assert!(is_buffer_aligned(out.as_ref(), io.info().alignment)?);
-
-    if is_aligned(offset, io.info().block_size)? {
-        return read_aligned_offset_and_buffer(io, offset, out, scratch).await;
-    }
-    let offset = SafeNum::from(offset);
-    let aligned_start: u64 =
-        min(offset.round_up(io.info().block_size).try_into()?, (offset + out.len()).try_into()?);
-
-    let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
-    if aligned_relative_offset < out.len() {
-        if is_buffer_aligned(&out.get(aligned_relative_offset..)?, io.info().alignment)? {
-            // If new output address is aligned, read directly.
-            read_aligned_offset_and_buffer(
-                io,
-                aligned_start,
-                out.get_mut(aligned_relative_offset..)?,
-                scratch,
-            )
-            .await?;
-        } else {
-            // Otherwise read into `out` (assumed aligned) and memmove to the correct
-            // position
-            let read_len: usize =
-                (SafeNum::from(out.len()) - aligned_relative_offset).try_into()?;
-            read_aligned_offset_and_buffer(io, aligned_start, out.get_mut(..read_len)?, scratch)
-                .await?;
-            out.as_mut().copy_within(..read_len, aligned_relative_offset);
-        }
-    }
-
-    // Now read the unaligned part
-    let block_scratch = &mut scratch[..SafeNum::from(io.info().block_size).try_into()?];
-    let round_down_offset = offset.round_down(io.info().block_size);
-    read_aligned_all(io, round_down_offset.try_into()?, block_scratch).await?;
-    let offset_relative = offset - round_down_offset;
-    let unaligned = out.get_mut(..aligned_relative_offset)?;
-    unaligned.clone_from_slice(as_uninit(
-        &block_scratch
-            [offset_relative.try_into()?..(offset_relative + unaligned.len()).try_into()?],
-    ));
-    Ok(())
-}
-
-// Partition a scratch into two aligned parts: [u8; alignment()-1] and [u8; block_size())]
-// for handling block and buffer misalignment respecitvely.
-fn split_scratch<'a>(
-    info: BlockInfo,
-    scratch: &'a mut [u8],
-) -> Result<(&'a mut [u8], &'a mut [u8])> {
-    let (buffer_alignment, block_alignment) = aligned_subslice(scratch, info.alignment)?
-        .split_at_mut((SafeNum::from(info.alignment) - 1).try_into()?);
-    let block_alignment = aligned_subslice(block_alignment, info.alignment)?;
-    let block_alignment_scratch_size = match info.block_size {
-        1 => SafeNum::ZERO,
-        v => v.into(),
-    };
-    Ok((buffer_alignment, &mut block_alignment[..block_alignment_scratch_size.try_into()?]))
-}
-
-/// Read with no alignment requirement.
-pub async fn read_async(
-    io: &mut impl BlockIo,
-    offset: u64,
-    out: &mut (impl SliceMaybeUninit + ?Sized),
-    scratch: &mut [u8],
-) -> Result<()> {
-    let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(io.info(), scratch)?;
-
-    if is_buffer_aligned(out.as_ref(), io.info().alignment)? {
-        return read_aligned_buffer(io, offset, out, block_alignment_scratch).await;
-    }
-
-    // Buffer misalignment:
-    // Case 1:
-    //     |~~~~~~~~~~~~buffer~~~~~~~~~~~~|
-    //   |----------------------|---------------------|
-    //      io.info().alignment
-    //
-    // Case 2:
-    //    |~~~~~~buffer~~~~~|
-    //  |----------------------|---------------------|
-    //     io.info().alignment
-
-    let out_addr_value = SafeNum::from(out.as_mut().as_ptr() as usize);
-    let unaligned_read: usize =
-        min((out_addr_value.round_up(io.info().alignment) - out_addr_value).try_into()?, out.len());
-
-    // Read unaligned part
-    let unaligned_out = &mut buffer_alignment_scratch[..unaligned_read];
-    read_aligned_buffer(io, offset, unaligned_out, block_alignment_scratch).await?;
-    out.get_mut(..unaligned_read)?.clone_from_slice(as_uninit(unaligned_out));
-
-    if unaligned_read == out.len() {
-        return Ok(());
-    }
-    // Read aligned part
-    read_aligned_buffer(
-        io,
-        (SafeNum::from(offset) + unaligned_read).try_into()?,
-        out.get_mut(unaligned_read..)?,
-        block_alignment_scratch,
-    )
-    .await
-}
-
-/// Write bytes from aligned buffer to a block boundary range.
-async fn write_aligned_all(io: &mut impl BlockIo, offset: u64, data: &mut [u8]) -> Result<()> {
-    let blk_offset = check_range(io.info(), offset, data)?.try_into()?;
-    Ok(io.write_blocks(blk_offset, data).await?)
-}
-
-/// Write with block-aligned offset and aligned buffer. `data.len()` can be unaligned.
-///   |~~~~~~~~~size~~~~~~~~~|
-///   |---------|---------|---------|
-async fn write_aligned_offset_and_buffer(
-    io: &mut impl BlockIo,
-    offset: u64,
-    data: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    debug_assert!(is_aligned(offset, io.info().block_size)?);
-    debug_assert!(is_buffer_aligned(data, io.info().alignment)?);
-
-    let aligned_write: usize =
-        SafeNum::from(data.len()).round_down(io.info().block_size).try_into()?;
-    if aligned_write > 0 {
-        write_aligned_all(io, offset, &mut data[..aligned_write]).await?;
-    }
-    let unaligned = &data[aligned_write..];
-    if unaligned.len() == 0 {
-        return Ok(());
-    }
-
-    // Perform read-modify-write for the unaligned part
-    let unaligned_start: u64 = (SafeNum::from(offset) + aligned_write).try_into()?;
-    let block_scratch = &mut scratch[..SafeNum::from(io.info().block_size).try_into()?];
-    read_aligned_all(io, unaligned_start, block_scratch).await?;
-    block_scratch[..unaligned.len()].clone_from_slice(unaligned);
-    write_aligned_all(io, unaligned_start, block_scratch).await
-}
-
-// Rotates buffer to the left.
-fn rotate_left(slice: &mut [u8], sz: usize, scratch: &mut [u8]) {
-    scratch[..sz].clone_from_slice(&slice[..sz]);
-    slice.copy_within(sz.., 0);
-    let off = slice.len().checked_sub(sz).unwrap();
-    slice[off..].clone_from_slice(&scratch[..sz]);
-}
-
-// Rotates buffer to the right.
-fn rotate_right(slice: &mut [u8], sz: usize, scratch: &mut [u8]) {
-    let off = slice.len().checked_sub(sz).unwrap();
-    scratch[..sz].clone_from_slice(&slice[off..]);
-    slice.copy_within(..off, sz);
-    slice[..sz].clone_from_slice(&scratch[..sz]);
-}
-
-/// Write with aligned buffer. Offset and size don't need to be block aligned.
-/// Case 1:
-///            |~~~~~~write~~~~~~~|
-///        |------------|------------|
-/// Case 2:
-///          |~~~write~~~|
-///        |---------------|--------------|
-async fn write_aligned_buffer(
-    io: &mut impl BlockIo,
-    offset: u64,
-    data: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    debug_assert!(is_buffer_aligned(data, io.info().alignment)?);
-
-    let offset = SafeNum::from(offset);
-    if is_aligned(offset, io.info().block_size)? {
-        return write_aligned_offset_and_buffer(io, offset.try_into()?, data, scratch).await;
-    }
-
-    let aligned_start: u64 =
-        min(offset.round_up(io.info().block_size).try_into()?, (offset + data.len()).try_into()?);
-    let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
-    if aligned_relative_offset < data.len() {
-        if is_buffer_aligned(&data[aligned_relative_offset..], io.info().alignment)? {
-            // If new address is aligned, write directly.
-            write_aligned_offset_and_buffer(
-                io,
-                aligned_start,
-                &mut data[aligned_relative_offset..],
-                scratch,
-            )
-            .await?;
-        } else {
-            let write_len: usize =
-                (SafeNum::from(data.len()) - aligned_relative_offset).try_into()?;
-            // Swap the offset-aligned part to the beginning of the buffer (assumed aligned)
-            rotate_left(data, aligned_relative_offset, scratch);
-            let res =
-                write_aligned_offset_and_buffer(io, aligned_start, &mut data[..write_len], scratch)
-                    .await;
-            // Swap the two parts back before checking the result.
-            rotate_right(data, aligned_relative_offset, scratch);
-            res?;
-        }
-    }
-
-    // perform read-modify-write for the unaligned part.
-    let block_scratch = &mut scratch[..SafeNum::from(io.info().block_size).try_into()?];
-    let round_down_offset: u64 = offset.round_down(io.info().block_size).try_into()?;
-    read_aligned_all(io, round_down_offset, block_scratch).await?;
-    let offset_relative = offset - round_down_offset;
-    block_scratch
-        [offset_relative.try_into()?..(offset_relative + aligned_relative_offset).try_into()?]
-        .clone_from_slice(&data[..aligned_relative_offset]);
-    write_aligned_all(io, round_down_offset, block_scratch).await
-}
-
-/// Writes bytes to the block device.
-/// It does internal optimization that temporarily modifies `data` layout to minimize number of
-/// calls to `io.read_blocks()`/`io.write_blocks()` (down to O(1)).
-pub async fn write_async(
-    io: &mut impl BlockIo,
-    offset: u64,
-    data: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(io.info(), scratch)?;
-    if is_buffer_aligned(data, io.info().alignment)? {
-        return write_aligned_buffer(io, offset, data, block_alignment_scratch).await;
-    }
-
-    // Buffer misalignment:
-    // Case 1:
-    //     |~~~~~~~~~~~~buffer~~~~~~~~~~~~|
-    //   |----------------------|---------------------|
-    //      io.alignment()
-    //
-    // Case 2:
-    //    |~~~~~~buffer~~~~~|
-    //  |----------------------|---------------------|
-    //     io.alignment()
-
-    // Write unaligned part
-    let data_addr_value = SafeNum::from(data.as_ptr() as usize);
-    let unaligned_write: usize = min(
-        (data_addr_value.round_up(io.info().alignment) - data_addr_value).try_into()?,
-        data.len(),
-    );
-    let mut unaligned_data = &mut buffer_alignment_scratch[..unaligned_write];
-    unaligned_data.clone_from_slice(&data[..unaligned_write]);
-    write_aligned_buffer(io, offset, &mut unaligned_data, block_alignment_scratch).await?;
-    if unaligned_write == data.len() {
-        return Ok(());
-    }
-
-    // Write aligned part
-    write_aligned_buffer(
-        io,
-        (SafeNum::from(offset) + unaligned_write).try_into()?,
-        &mut data[unaligned_write..],
-        block_alignment_scratch,
-    )
-    .await
-}
diff --git a/gbl/libstorage/src/gpt.rs b/gbl/libstorage/src/gpt.rs
deleted file mode 100644
index 2f768ef..0000000
--- a/gbl/libstorage/src/gpt.rs
+++ /dev/null
@@ -1,1710 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{BlockIo, Disk, Result};
-use core::{
-    array::from_fn,
-    cmp::min,
-    convert::TryFrom,
-    default::Default,
-    fmt::{Debug, Formatter},
-    mem::size_of,
-    num::NonZeroU64,
-    ops::{Deref, DerefMut},
-    str::from_utf8,
-};
-use crc32fast::Hasher;
-use gbl_async::block_on;
-use liberror::{Error, GptError};
-use safemath::SafeNum;
-use zerocopy::{
-    ByteSlice, FromBytes, FromZeros, Immutable, IntoBytes, KnownLayout, Ref, SplitByteSlice,
-};
-
-/// Number of bytes in GUID.
-pub const GPT_GUID_LEN: usize = 16;
-/// The maximum number of UTF-16 characters in a GPT partition name, including termination.
-pub const GPT_NAME_LEN_U16: usize = 36;
-const GPT_NAME_LEN_U8: usize = 2 * GPT_GUID_LEN;
-
-/// The top-level GPT header.
-#[repr(C, packed)]
-#[derive(
-    Debug, Default, Copy, Clone, Immutable, IntoBytes, FromBytes, KnownLayout, PartialEq, Eq,
-)]
-pub struct GptHeader {
-    /// Magic bytes; must be [GPT_MAGIC].
-    pub magic: u64,
-    /// Header version.
-    pub revision: u32,
-    /// Header size in bytes.
-    pub size: u32,
-    /// CRC of the first `size` bytes, calculated with this field zeroed.
-    pub crc32: u32,
-    /// Reserved; must be set to 0.
-    pub reserved0: u32,
-    /// The on-disk block location of this header.
-    pub current: u64,
-    /// The on-disk block location of the other header.
-    pub backup: u64,
-    /// First usable block for partition contents.
-    pub first: u64,
-    /// Last usable block for partition contents (inclusive).
-    pub last: u64,
-    /// Disk GUID.
-    pub guid: [u8; GPT_GUID_LEN],
-    /// Starting block for the partition entries array.
-    pub entries: u64,
-    /// Number of partition entries.
-    pub entries_count: u32,
-    /// The size of each partition entry in bytes.
-    pub entries_size: u32,
-    /// CRC of the partition entries array.
-    pub entries_crc: u32,
-}
-
-impl GptHeader {
-    /// Casts a bytes slice into a mutable GptHeader structure.
-    pub fn from_bytes_mut(bytes: &mut [u8]) -> &mut GptHeader {
-        Ref::into_mut(Ref::<_, GptHeader>::new_from_prefix(bytes).unwrap().0)
-    }
-
-    /// Computes the actual crc32 value.
-    fn calculate_header_crc(&self) -> u32 {
-        let mut hasher = Hasher::new();
-        hasher.update(&self.as_bytes()[..GPT_CRC32_OFFSET]);
-        hasher.update(&[0u8; size_of::<u32>()]);
-        hasher.update(&self.as_bytes()[GPT_CRC32_OFFSET + size_of::<u32>()..]);
-        hasher.finalize()
-    }
-
-    /// Update the header crc32 value.
-    pub fn update_crc(&mut self) {
-        self.crc32 = self.calculate_header_crc();
-    }
-
-    /// Updates entries and header crc according to the given entries buffer.
-    fn update_entries_crc(&mut self, entries: &[u8]) {
-        let size = SafeNum::from(self.entries_count) * self.entries_size;
-        self.entries_crc = crc32(&entries[..size.try_into().unwrap()]);
-        self.update_crc();
-    }
-}
-
-/// Computes the number of blocks for the 128 partition entries reserved space in GPT.
-fn gpt_entries_blk(block_size: u64) -> Result<u64> {
-    let size = u64::try_from(GPT_MAX_NUM_ENTRIES_SIZE).unwrap();
-    match size % block_size {
-        0 => Ok(size / block_size),
-        _ => Err(Error::InvalidInput),
-    }
-}
-
-/// Checks a header against a block device.
-///
-/// # Args
-///
-/// * `io`: An implementation of [BlockIo],
-/// * `header`: The GPT header to verify.
-/// * `is_primary`: If the header is a primary header.
-fn check_header(io: &mut impl BlockIo, header: &GptHeader, is_primary: bool) -> Result<()> {
-    let num_blks = SafeNum::from(io.info().num_blocks);
-    let blk_sz = io.info().block_size;
-
-    // GPT spec requires that at least 128 entries worth of space be reserved.
-    let min_reserved_entries_blk = gpt_entries_blk(blk_sz)?;
-    // Minimum space needed: 2 * (header + entries) + MBR.
-    let min_disk_blks: u64 = ((min_reserved_entries_blk + 1) * 2 + 1).try_into().unwrap();
-    if min_disk_blks > u64::try_from(num_blks).unwrap() {
-        return Err(Error::GptError(GptError::DiskTooSmall));
-    }
-
-    if header.magic != GPT_MAGIC {
-        return Err(Error::GptError(GptError::IncorrectMagic(header.magic)));
-    }
-
-    if header.calculate_header_crc() != header.crc32 {
-        return Err(Error::GptError(GptError::IncorrectHeaderCrc));
-    }
-
-    if header.size != size_of::<GptHeader>().try_into().unwrap() {
-        return Err(Error::GptError(GptError::UnexpectedHeaderSize {
-            actual: header.size,
-            expect: size_of::<GptHeader>(),
-        }));
-    }
-
-    if header.entries_size != size_of::<GptEntry>().try_into().unwrap() {
-        return Err(Error::GptError(GptError::UnexpectedEntrySize {
-            actual: header.entries_size,
-            expect: size_of::<GptEntry>(),
-        }));
-    }
-
-    // Checks first/last usable block.
-    //
-    // Assuming maximum range where partition entries are adjacent to GPT headers.
-    //
-    // Should leave a minimum space for MBR + primary header + primary entries before.
-    let min_first: u64 = (min_reserved_entries_blk + 2).try_into().unwrap();
-    // Should leave a minimum space for secondary header + secondary entries space after.
-    let max_last: u64 = (num_blks - 1 - min_reserved_entries_blk - 1).try_into().unwrap();
-    if header.first > header.last + 1 || header.first < min_first || header.last > max_last {
-        return Err(Error::GptError(GptError::InvalidFirstLastUsableBlock {
-            first: header.first,
-            last: header.last,
-            range: (min_first, max_last),
-        }));
-    }
-
-    // Checks entries starting block.
-    if is_primary {
-        // For primary header, entries must be before first usable block and can hold up to
-        // `GPT_MAX_NUM_ENTRIES` entries
-        let right: u64 =
-            (SafeNum::from(header.first) - min_reserved_entries_blk).try_into().unwrap();
-        if !(header.entries >= 2 && header.entries <= right) {
-            return Err(Error::GptError(GptError::InvalidPrimaryEntriesStart {
-                value: header.entries,
-                expect_range: (2, right),
-            }));
-        }
-    } else {
-        // For secondary header, entries must be after last usable block and can hold up to
-        // `GPT_MAX_NUM_ENTRIES` entries.
-        if !(header.entries > header.last && header.entries <= max_last + 1) {
-            return Err(Error::GptError(GptError::InvalidSecondaryEntriesStart {
-                value: header.entries,
-                expect_range: (header.last + 1, max_last + 1),
-            }));
-        }
-    }
-
-    if header.entries_count > GPT_MAX_NUM_ENTRIES.try_into().unwrap() {
-        return Err(Error::GptError(GptError::NumberOfEntriesOverflow {
-            entries: header.entries_count,
-            max_allowed: GPT_MAX_NUM_ENTRIES,
-        }));
-    }
-
-    Ok(())
-}
-
-/// Verifies the given entries against a verifed GPT header.
-///
-/// # Args
-///
-/// * `header`: The verified GPT header corresponding to the entries.
-/// * `entries`: The buffer containing the entries.
-fn check_entries(header: &GptHeader, entries: &[u8]) -> Result<()> {
-    // Checks entries CRC.
-    assert!(header.entries_count <= GPT_MAX_NUM_ENTRIES.try_into().unwrap());
-    let entries_size: usize =
-        (SafeNum::from(header.entries_count) * GPT_ENTRY_SIZE).try_into().unwrap();
-    let entries = entries.get(..entries_size).ok_or(Error::GptError(GptError::EntriesTruncated))?;
-    if header.entries_crc != crc32(entries) {
-        return Err(Error::GptError(GptError::IncorrectEntriesCrc));
-    }
-
-    // Checks each entry.
-    let entries = Ref::<_, [GptEntry]>::new_slice(entries)
-        .ok_or(Error::GptError(GptError::EntriesTruncated))?
-        .into_slice();
-    let entries = &entries[..header.entries_count.try_into().unwrap()];
-    for (idx, ele) in entries.iter().take_while(|v| !v.is_null()).enumerate() {
-        // Error information uses 1-base partition index.
-        let idx = idx.checked_add(1).unwrap();
-        let (first, last) = (ele.first, ele.last);
-        if first > last + 1 || last > header.last || first < header.first {
-            return Err(Error::GptError(GptError::InvalidPartitionRange {
-                idx,
-                part_range: (first, last),
-                usable_range: (header.first, header.last),
-            }));
-        } else if ele.part_type == [0u8; GPT_GUID_LEN] {
-            return Err(Error::GptError(GptError::ZeroPartitionTypeGUID { idx }));
-        } else if ele.guid == [0u8; GPT_GUID_LEN] {
-            return Err(Error::GptError(GptError::ZeroPartitionUniqueGUID { idx }));
-        }
-    }
-
-    // Checks overlap between partition ranges.
-    // Sorts an index array because we don't want to modify input.
-    let mut sorted_indices: [u8; GPT_MAX_NUM_ENTRIES] = from_fn(|i| i.try_into().unwrap());
-    sorted_indices.sort_unstable_by_key(|v| match entries.get(usize::try_from(*v).unwrap()) {
-        Some(v) if !v.is_null() => v.first,
-        _ => u64::MAX,
-    });
-
-    let actual = entries.iter().position(|v| v.is_null()).unwrap_or(entries.len());
-    if actual > 1 {
-        for i in 0..actual - 1 {
-            let prev: usize = sorted_indices[i].try_into().unwrap();
-            let next: usize = sorted_indices[i + 1].try_into().unwrap();
-            if entries[prev].last >= entries[next].first {
-                return Err(Error::GptError(GptError::PartitionRangeOverlap {
-                    prev: (prev + 1, entries[prev].first, entries[prev].last),
-                    next: (next + 1, entries[next].first, entries[next].last),
-                }));
-            }
-        }
-    }
-
-    Ok(())
-}
-
-/// GptEntry is the partition entry data structure in the GPT.
-#[repr(C, packed)]
-#[derive(Debug, Copy, Clone, Immutable, IntoBytes, FromBytes, KnownLayout, PartialEq)]
-pub struct GptEntry {
-    /// Partition type GUID.
-    pub part_type: [u8; GPT_GUID_LEN],
-    /// Unique partition GUID.
-    pub guid: [u8; GPT_GUID_LEN],
-    /// First block.
-    pub first: u64,
-    /// Last block (inclusive).
-    pub last: u64,
-    /// Partition flags.
-    pub flags: u64,
-    /// Partition name in UTF-16.
-    pub name: [u16; GPT_NAME_LEN_U16],
-}
-
-impl GptEntry {
-    /// Return the partition entry size in blocks.
-    pub fn blocks(&self) -> Result<u64> {
-        // Must perform "+1" first before subtracting `self.first`. Otherwise if partition size is
-        // zero, where `self.first > self.last`, arithmetic will overflow.
-        u64::try_from(SafeNum::from(self.last) + 1 - self.first).map_err(Into::into)
-    }
-
-    /// Return whether this is a `NULL` entry. The first null entry marks the end of the partition
-    /// entries.
-    fn is_null(&self) -> bool {
-        self.first == 0 && self.last == 0
-    }
-
-    /// Decode the partition name into a string. A length N utf16 string can be at most 2N utf8
-    /// bytes. Therefore, a safe size of `buffer` is 2*GPT_NAME_LEN_U16 = 72.
-    pub fn name_to_str<'a>(&self, buffer: &'a mut [u8]) -> Result<&'a str> {
-        let mut index = 0;
-        for c in char::decode_utf16(self.name) {
-            match c.unwrap_or(char::REPLACEMENT_CHARACTER) {
-                '\0' => break,
-                c if c.len_utf8() <= buffer[index..].len() => {
-                    index += c.encode_utf8(&mut buffer[index..]).len()
-                }
-                _ => return Err(Error::InvalidInput), // Not enough space in `buffer`.
-            }
-        }
-        // SAFETY:
-        // _unchecked should be OK here since we wrote each utf8 byte ourselves,
-        // but it's just an optimization, checked version would be fine also.
-        unsafe { Ok(core::str::from_utf8_unchecked(&buffer[..index])) }
-    }
-
-    /// Checks if the partition name is the same as the given.
-    pub fn match_name(&self, part: &str) -> Result<bool> {
-        Ok(self.name_to_str(&mut [0u8; GPT_NAME_LEN_U16 * 2][..])? == part)
-    }
-}
-
-impl core::fmt::Display for GptEntry {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        // Format: partition name: "abc", [first, last]: [123, 456]
-        let mut name_conversion_buffer = [0u8; GPT_NAME_LEN_U16 * 2];
-        let name = self.name_to_str(&mut name_conversion_buffer).map_err(|_| core::fmt::Error)?;
-        // Note: The bracket around `{ self.first }` is for forcing a copy of the field because
-        // GptEntry is a packed structure.
-        write!(f, "partition: \"{}\", first: {}, last: {}", name, { self.first }, { self.last })
-    }
-}
-
-// core::mem::offset_of!(GptHeader, crc32) is unsatble feature and rejected by the compiler in our
-// settings. We pre-compute the value here.
-const GPT_CRC32_OFFSET: usize = 16;
-const GPT_ENTRY_SIZE: usize = size_of::<GptEntry>();
-const GPT_MAX_NUM_ENTRIES: usize = 128;
-const GPT_MAX_NUM_ENTRIES_SIZE: usize = GPT_MAX_NUM_ENTRIES * GPT_ENTRY_SIZE;
-/// GPT header magic bytes ("EFI PART" in ASCII).
-pub const GPT_MAGIC: u64 = 0x5452415020494645;
-
-enum HeaderType {
-    Primary,
-    Secondary,
-}
-
-/// `Partition` contains information about a GPT partition.
-#[derive(Debug, Copy, Clone, PartialEq)]
-pub struct Partition {
-    entry: GptEntry,
-    block_size: u64,
-    decoded_name: Option<([u8; GPT_NAME_LEN_U8], usize)>,
-}
-
-impl Partition {
-    /// Creates a new instance.
-    fn new(entry: GptEntry, block_size: u64) -> Self {
-        let mut buf = [0u8; GPT_NAME_LEN_U8];
-        let decoded_name = match entry.name_to_str(&mut buf[..]).ok().map(|v| v.len()) {
-            Some(len) => Some((buf, len)),
-            _ => None,
-        };
-        Self { entry, block_size, decoded_name }
-    }
-
-    /// Gets the decoded partition name.
-    pub fn name(&self) -> Option<&str> {
-        // Correct by construction. `from_utf8` should not fail.
-        self.decoded_name.as_ref().map(|(buf, sz)| from_utf8(&buf[..*sz]).unwrap())
-    }
-
-    /// Returns the partition size in bytes.
-    pub fn size(&self) -> Result<u64> {
-        u64::try_from(SafeNum::from(self.entry.blocks()?) * self.block_size).map_err(Error::from)
-    }
-
-    /// Returns the block size of this partition.
-    pub fn block_size(&self) -> u64 {
-        self.block_size
-    }
-
-    /// Returns the partition entry structure in the GPT header.
-    pub fn gpt_entry(&self) -> &GptEntry {
-        &self.entry
-    }
-
-    /// Returns the partition's absolute start/end offset in number of bytes.
-    pub fn absolute_range(&self) -> Result<(u64, u64)> {
-        let start = SafeNum::from(self.entry.first) * self.block_size;
-        let end = (SafeNum::from(self.entry.last) + 1) * self.block_size;
-        Ok((start.try_into()?, end.try_into()?))
-    }
-
-    /// Checks a given sub range and returns its absolute offset.
-    pub fn check_range(&self, off: u64, size: u64) -> Result<u64> {
-        let off = SafeNum::from(off);
-        let end: u64 = (off + size).try_into()?;
-        match end > self.size()? {
-            true => Err(Error::BadIndex(end as usize)),
-            _ => Ok((off + self.absolute_range()?.0).try_into()?),
-        }
-    }
-}
-
-/// `PartitionIterator` iterates all GPT partition entries.
-pub struct PartitionIterator<'a> {
-    entries: &'a [GptEntry],
-    block_size: u64,
-    idx: usize,
-}
-
-impl Iterator for PartitionIterator<'_> {
-    type Item = Partition;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        let res = self
-            .entries
-            .get(self.idx)
-            .filter(|v| !v.is_null())
-            .map(|v| Partition::new(*v, self.block_size))?;
-        self.idx += 1;
-        Some(res)
-    }
-}
-
-/// Contains result of GPT syncing/restoration.
-#[derive(Copy, Clone, PartialEq, Debug, Default)]
-pub enum GptSyncResult {
-    /// Both primary and secondary GPT are valid.
-    #[default]
-    BothValid,
-    /// Primary GPT is invalid and restored.
-    PrimaryRestored(Error),
-    /// Secondary GPT is invalid and restored.
-    SecondaryRestored(Error),
-    /// Neither primary or secondary GPT is valid.
-    NoValidGpt {
-        /// Primary GPT verify error.
-        primary: Error,
-        /// Secondary GPT verify error.
-        secondary: Error,
-    },
-}
-
-impl GptSyncResult {
-    /// Combined into a result
-    pub fn res(&self) -> Result<()> {
-        match self {
-            Self::NoValidGpt { primary: e, .. } => Err(*e),
-            _ => Ok(()),
-        }
-    }
-}
-
-impl core::fmt::Display for GptSyncResult {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        match self {
-            Self::BothValid => write!(f, "Found valid GPT."),
-            Self::PrimaryRestored(e) => write!(f, "Primary GPT restored due to {e:?}."),
-            Self::SecondaryRestored(e) => write!(f, "Secondary GPT restored due to {e:?}."),
-            Self::NoValidGpt { primary, secondary } => {
-                write!(f, "No valid GPT. primary: {primary:?}, secondary: {secondary:?}.")
-            }
-        }
-    }
-}
-
-/// A packed wrapper of `Option<NonZeroU64>`
-#[repr(C, packed)]
-#[derive(Debug, Copy, Clone, Immutable, IntoBytes, FromBytes, KnownLayout)]
-struct BlockSize(Option<NonZeroU64>);
-
-/// Represents the structure of a load buffer for loading/verifying/syncing up to N GPT entries.
-#[repr(C, packed)]
-#[derive(Debug, Copy, Clone, Immutable, IntoBytes, FromBytes)]
-pub struct GptLoadBufferN<const N: usize> {
-    // GPT doesn't care about block size. But it's easier to have it available for computing offset
-    // and size in bytes for partitions. It's also used as a flag for indicating whether a valid
-    // GPT is loaded.
-    block_size: BlockSize,
-    primary_header: GptHeader,
-    secondary_header: GptHeader,
-    primary_entries: [GptEntry; N],
-    secondary_entries: [GptEntry; N],
-}
-
-impl<const N: usize> Deref for GptLoadBufferN<N> {
-    type Target = [u8];
-
-    fn deref(&self) -> &Self::Target {
-        self.as_bytes()
-    }
-}
-
-impl<const N: usize> DerefMut for GptLoadBufferN<N> {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        self.as_bytes_mut()
-    }
-}
-
-/// Contains references corresponding to different GPT load entities parsed from a load buffer.
-///
-/// The structure is simply for organizing together the individual references of fields in
-/// `GptLoadBufferN` parsed from a raw buffer. Note that we can't parse a `Ref<B, GptLoadBufferN>`
-/// directly from a buffer because the number of entries (length of [GptEntry]) in this case needs
-/// to be computed at run time based on the buffer size.
-struct LoadBufferRef<B: ByteSlice> {
-    block_size: Ref<B, BlockSize>,
-    primary_header: Ref<B, GptHeader>,
-    secondary_header: Ref<B, GptHeader>,
-    primary_entries: Ref<B, [GptEntry]>,
-    secondary_entries: Ref<B, [GptEntry]>,
-}
-
-impl<B: SplitByteSlice> LoadBufferRef<B> {
-    fn from(buffer: B) -> Self {
-        let n = min(GPT_MAX_NUM_ENTRIES, max_supported_entries(&buffer[..]).unwrap());
-        let (block_size, rest) = Ref::new_from_prefix(buffer).unwrap();
-        let (primary_header, rest) = Ref::new_from_prefix(rest).unwrap();
-        let (secondary_header, rest) = Ref::new_from_prefix(rest).unwrap();
-        let (primary_entries, rest) = Ref::new_slice_from_prefix(rest, n).unwrap();
-        let (secondary_entries, _) = Ref::new_slice_from_prefix(rest, n).unwrap();
-        Self { block_size, primary_header, secondary_header, primary_entries, secondary_entries }
-    }
-
-    /// Unpacks into the secondary GPT header/entries
-    fn secondary(self) -> (Ref<B, GptHeader>, Ref<B, [GptEntry]>) {
-        (self.secondary_header, self.secondary_entries)
-    }
-}
-
-/// The minimum buffer size needed for creating a [Gpt] that can load `entries` number of
-/// partitions.
-///
-/// # Returns
-///
-/// * Returns Ok(size) on success.
-/// * Returns Err(Error::InvalidInput) if max_entries is greater than 128.
-pub fn gpt_buffer_size(entries: usize) -> Result<usize> {
-    match entries > GPT_MAX_NUM_ENTRIES {
-        true => Err(Error::InvalidInput),
-        _ => Ok(size_of::<GptLoadBufferN<0>>() + entries * GPT_ENTRY_SIZE * 2),
-    }
-}
-
-/// Computes the maximum number of entries that can be loaded if using the given buffer for [Gpt].
-fn max_supported_entries(buf: &[u8]) -> Result<usize> {
-    match buf.len() < size_of::<GptLoadBufferN<0>>() {
-        true => Err(Error::BufferTooSmall(Some(size_of::<GptLoadBufferN<0>>()))),
-        _ => Ok((buf.len() - size_of::<GptLoadBufferN<0>>()) / 2 / GPT_ENTRY_SIZE),
-    }
-}
-
-/// [Gpt] manages a buffer for loading, verifying and syncing GPT.
-pub struct Gpt<B> {
-    buffer: B,
-}
-
-impl<B: DerefMut<Target = [u8]>> Gpt<B> {
-    /// Create an uninitialized Gpt instance from a provided buffer.
-    ///
-    /// The created [Gpt] can then be used in `Disk::sync_gpt()` for loading, verifying and syncing
-    /// GPT on disk.
-    ///
-    /// # Args:
-    ///
-    /// * `buffer`: A buffer to use for loading, verifying and syncing primary and secondary GPT.
-    ///   The size of the buffer determines the maximum number of partition entries that can be
-    ///   loaded. If actual number of partitions, specified by `entries_count` in the GPT header,
-    ///   exceeds it, verification and sync will eventually fail with `Error::BufferTooSmall`.
-    ///   `gpt_buffer_size(num_entries)` can be used to compute the required size of buffer for
-    ///   loading a specific number of entries. Note that most tools and OS fix the `entries_count`
-    ///   value to the max 128 regardless of the actual number of partition entries used. Thus
-    ///   unless you have full control of GPT generation in your entire system where you can always
-    ///   ensure a smaller bound on it, it is recommended to always provide enough buffer for
-    ///   loading 128 entries.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok(Self) on success.
-    /// * Returns Err(Error::BufferTooSmall) if buffer is less than the minimum size.
-    pub fn new(mut buffer: B) -> Result<Self> {
-        max_supported_entries(&buffer[..])?;
-        LoadBufferRef::from(&mut buffer[..]).block_size.0 = None;
-        Ok(Self { buffer })
-    }
-
-    /// Returns the maximum allowed entries.
-    pub fn max_entries(&self) -> usize {
-        max_supported_entries(&self.buffer[..]).unwrap()
-    }
-
-    /// Creates an instance of `Gpt<&mut [u8]>` that borrows the internal GPT buffer.
-    pub fn as_borrowed(&mut self) -> Gpt<&mut [u8]> {
-        Gpt { buffer: &mut self.buffer[..] }
-    }
-
-    /// Returns an iterator to GPT partition entries.
-    ///
-    /// If the object does not contain a valid GPT, the method returns Error.
-    pub fn partition_iter(&self) -> Result<PartitionIterator> {
-        let block_size = self.check_valid()?;
-        let entries = LoadBufferRef::from(&self.buffer[..]).primary_entries.into_slice();
-        Ok(PartitionIterator { entries, idx: 0, block_size })
-    }
-
-    /// Checks if a read/write range into a GPT partition overflows and returns the range's absolute
-    /// offset in number of bytes.
-    pub fn check_range(&self, part_name: &str, offset: u64, size: usize) -> Result<u64> {
-        self.find_partition(part_name)?.check_range(offset, u64::try_from(size)?)
-    }
-
-    /// Return the list of GPT entries.
-    ///
-    /// If there is not a valid GPT, the method returns Error.
-    pub fn entries(&self) -> Result<&[GptEntry]> {
-        self.check_valid()?;
-        let entries = LoadBufferRef::from(&self.buffer[..]).primary_entries.into_slice();
-        let n = entries.iter().position(|v| v.is_null()).unwrap_or(entries.len());
-        Ok(&entries[..n])
-    }
-
-    /// Returns the total number of partitions.
-    pub fn num_partitions(&self) -> Result<usize> {
-        Ok(self.entries()?.len())
-    }
-
-    /// Gets the `idx`th partition.
-    pub fn get_partition(&self, idx: usize) -> Result<Partition> {
-        let block_size = self.check_valid()?;
-        let entry = *self.entries()?.get(idx).ok_or(Error::BadIndex(idx))?;
-        Ok(Partition::new(entry, block_size))
-    }
-
-    /// Returns the `Partition` for a partition.
-    ///
-    /// # Args
-    ///
-    /// * `part`: Name of the partition.
-    pub fn find_partition(&self, part: &str) -> Result<Partition> {
-        let block_size = self.check_valid()?;
-        for entry in self.entries()? {
-            let mut name_conversion_buffer = [0u8; GPT_NAME_LEN_U16 * 2];
-            if entry.name_to_str(&mut name_conversion_buffer)? != part {
-                continue;
-            }
-            return Ok(Partition::new(*entry, block_size));
-        }
-        Err(Error::NotFound)
-    }
-
-    /// Checks whether the Gpt has been initialized and returns the block size.
-    fn check_valid(&self) -> Result<u64> {
-        Ok(LoadBufferRef::from(&self.buffer[..]).block_size.0.ok_or(Error::InvalidState)?.get())
-    }
-
-    /// Helper function for loading and validating GPT header and entries.
-    async fn load_and_validate_gpt(
-        &mut self,
-        disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-        hdr_type: HeaderType,
-    ) -> Result<()> {
-        let blk_sz = disk.io().info().block_size;
-        let load = LoadBufferRef::from(&mut self.buffer[..]);
-        let (header_start, mut header, mut entries) = match hdr_type {
-            HeaderType::Primary => (blk_sz, load.primary_header, load.primary_entries),
-            HeaderType::Secondary => (
-                ((SafeNum::from(disk.io().info().num_blocks) - 1) * blk_sz).try_into()?,
-                load.secondary_header,
-                load.secondary_entries,
-            ),
-        };
-
-        // Loads the header
-        disk.read(header_start, Ref::bytes_mut(&mut header)).await?;
-        // Checks header.
-        check_header(disk.io(), &header, matches!(hdr_type, HeaderType::Primary))?;
-        // Loads the entries.
-        let entries_size = SafeNum::from(header.entries_count) * GPT_ENTRY_SIZE;
-        let entries_offset = SafeNum::from(header.entries) * blk_sz;
-        let out = entries.as_bytes_mut().get_mut(..entries_size.try_into().unwrap()).ok_or(
-            Error::BufferTooSmall(Some(
-                gpt_buffer_size(header.entries_count.try_into().unwrap()).unwrap(),
-            )),
-        )?;
-        disk.read(entries_offset.try_into().unwrap(), out).await?;
-        // Checks entries.
-        check_entries(&header, entries.as_bytes())
-    }
-
-    /// Loads and syncs GPT from a block device.
-    ///
-    /// * Returns Ok(sync_result) if disk IO is successful, where `sync_result` contains the GPT
-    ///   verification and restoration result,
-    /// * Returns Err() if disk IO encounters error.
-    pub(crate) async fn load_and_sync(
-        &mut self,
-        disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-    ) -> Result<GptSyncResult> {
-        let blk_sz = disk.io().info().block_size;
-        let nonzero_blk_sz = NonZeroU64::new(blk_sz).ok_or(Error::InvalidInput)?;
-        let total_blocks: SafeNum = disk.io().info().num_blocks.into();
-
-        let primary_header_blk = 1;
-        let primary_header_pos = blk_sz;
-        let secondary_header_blk = total_blocks - 1;
-
-        // Entries position for restoring.
-        let primary_entries_blk = 2;
-        let primary_entries_pos = SafeNum::from(primary_entries_blk) * blk_sz;
-        let primary_res = self.load_and_validate_gpt(disk, HeaderType::Primary).await;
-        let secondary_res = self.load_and_validate_gpt(disk, HeaderType::Secondary).await;
-
-        let LoadBufferRef {
-            mut block_size,
-            mut primary_header,
-            mut secondary_header,
-            mut primary_entries,
-            mut secondary_entries,
-        } = LoadBufferRef::from(&mut self.buffer[..]);
-        block_size.0 = None;
-        let primary_entries = primary_entries.as_bytes_mut();
-        let secondary_entries = secondary_entries.as_bytes_mut();
-        let sync_res = match (primary_res, secondary_res) {
-            (Err(primary), Err(secondary)) => GptSyncResult::NoValidGpt { primary, secondary },
-            (Ok(()), Ok(())) if is_consistent(&primary_header, &secondary_header) => {
-                GptSyncResult::BothValid
-            }
-            (Err(e), Ok(())) => {
-                // Restores to primary
-                primary_header.as_bytes_mut().clone_from_slice(secondary_header.as_bytes());
-                primary_entries.clone_from_slice(&secondary_entries);
-                primary_header.current = primary_header_blk;
-                primary_header.backup = secondary_header_blk.try_into()?;
-                primary_header.entries = primary_entries_blk;
-                primary_header.update_crc();
-
-                disk.write(primary_header_pos, primary_header.as_bytes_mut()).await?;
-                disk.write(primary_entries_pos.try_into()?, primary_entries).await?;
-                GptSyncResult::PrimaryRestored(e)
-            }
-            (Ok(()), v) => {
-                // Restores to secondary
-                let pos = secondary_header_blk * blk_sz;
-                let secondary_entries_pos = pos - GPT_MAX_NUM_ENTRIES_SIZE;
-                let secondary_entries_blk = secondary_entries_pos / blk_sz;
-
-                secondary_header.as_bytes_mut().clone_from_slice(primary_header.as_bytes());
-                secondary_entries.clone_from_slice(primary_entries);
-                secondary_header.current = secondary_header_blk.try_into()?;
-                secondary_header.backup = primary_header_blk;
-                secondary_header.entries = secondary_entries_blk.try_into()?;
-                secondary_header.update_crc();
-
-                disk.write(pos.try_into()?, secondary_header.as_bytes_mut()).await?;
-                disk.write(secondary_entries_pos.try_into()?, secondary_entries).await?;
-
-                GptSyncResult::SecondaryRestored(match v {
-                    Err(e) => e,
-                    _ => Error::GptError(GptError::DifferentFromPrimary),
-                })
-            }
-        };
-
-        block_size.0 = Some(nonzero_blk_sz);
-        Ok(sync_res)
-    }
-}
-
-/// Checks whether primary and secondary header
-fn is_consistent(primary: &GptHeader, secondary: &GptHeader) -> bool {
-    let mut expected_secondary = *primary;
-    expected_secondary.crc32 = secondary.crc32;
-    expected_secondary.current = secondary.current;
-    expected_secondary.backup = 1;
-    expected_secondary.entries = secondary.entries;
-    &expected_secondary == secondary
-}
-
-/// A [Gpt] that owns a `GptLoadBufferN<N>` and can load up to N partition entries.
-///
-/// Note: The size of this type increases with N and can be expensive to store on stack. It is
-/// typically intended for resource abundant environment such as test.
-pub type GptN<const N: usize> = Gpt<GptLoadBufferN<N>>;
-
-/// Creates an instance of GptN.
-pub fn new_gpt_n<const N: usize>() -> GptN<N> {
-    Gpt::new(GptLoadBufferN::<N>::new_zeroed()).unwrap()
-}
-
-/// A [Gpt] that owns a `GptLoadBufferN<128>` and can load the maximum 128 partition entries.
-///
-/// Note: The size of this type is approximately 34K and can be expensive to store on stack. It
-/// is typically intended for resource abundant environment such as test.
-pub type GptMax = GptN<GPT_MAX_NUM_ENTRIES>;
-
-/// Creates an instance of GptMax.
-pub fn new_gpt_max() -> GptMax {
-    new_gpt_n::<GPT_MAX_NUM_ENTRIES>()
-}
-
-/// Updates GPT on a block device.
-///
-/// # Args
-///
-/// * `io`: An implementation of [BlockIo]
-/// * `scratch`: Scratch buffer for unaligned read write.
-/// * `mbr_primary`: A buffer containing the MBR block, primary GPT header and entries.
-/// * `resize`: If set to true, the method updates the last partition to cover the rest of the
-///    storage.
-/// * `gpt`: The output [Gpt] to update.
-pub(crate) async fn update_gpt(
-    disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-    mbr_primary: &mut [u8],
-    resize: bool,
-    gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
-) -> Result<()> {
-    let blk_sz: usize = disk.io().info().block_size.try_into()?;
-    let (header, remain) = mbr_primary
-        .get_mut(blk_sz..)
-        .map(|v| v.split_at_mut_checked(blk_sz))
-        .flatten()
-        .ok_or(Error::BufferTooSmall(Some(blk_sz * 2)))?;
-    let header = Ref::into_mut(Ref::<_, GptHeader>::new_from_prefix(&mut header[..]).unwrap().0);
-
-    // Adjusts last usable block according to this device in case the GPT was generated for a
-    // different disk size. If this results in some partition being out of range, it will be
-    // caught during `check_header()`.
-    let entries_blk = SafeNum::from(GPT_MAX_NUM_ENTRIES_SIZE) / blk_sz;
-    // Reserves only secondary GPT header and entries.
-    let num_blks = SafeNum::from(disk.io().info().num_blocks);
-    header.last = (num_blks - entries_blk - 2).try_into().unwrap();
-    header.backup = (num_blks - 1).try_into().unwrap();
-    header.update_crc();
-
-    check_header(disk.io(), &header, true)?;
-    // Computes entries offset in bytes relative to `remain`
-    let entries_off: usize = ((SafeNum::from(header.entries) - 2) * blk_sz).try_into().unwrap();
-    let entries_size: usize =
-        (SafeNum::from(header.entries_count) * header.entries_size).try_into().unwrap();
-    let entries = remain
-        .get_mut(entries_off..)
-        .map(|v| v.get_mut(..entries_size))
-        .flatten()
-        .ok_or(Error::BufferTooSmall(Some(2 * blk_sz + entries_off + entries_size)))?;
-    check_entries(&header, entries)?;
-
-    if resize {
-        // Updates the last entry to cover the rest of the storage.
-        let gpt_entries =
-            Ref::<_, [GptEntry]>::new_slice(&mut entries[..]).unwrap().into_mut_slice();
-        gpt_entries.iter_mut().filter(|e| !e.is_null()).last().map(|v| v.last = header.last);
-        header.update_entries_crc(entries);
-        // Re-verifies everything.
-        check_header(disk.io(), &header, true).unwrap();
-        check_entries(&header, entries).unwrap();
-    }
-
-    disk.write(0, mbr_primary).await?;
-    disk.sync_gpt(gpt).await?.res()
-}
-
-/// Erases GPT if there is one on the device.
-pub(crate) async fn erase_gpt(
-    disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
-    gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
-) -> Result<()> {
-    match disk.sync_gpt(gpt).await?.res() {
-        Err(_) => Ok(()), // No valid GPT. Nothing to erase.
-        _ => {
-            let blk_sz = disk.block_info().block_size;
-            let mut load = LoadBufferRef::from(&mut gpt.buffer[..]);
-            let entries_size = SafeNum::from(load.primary_header.entries_count) * GPT_ENTRY_SIZE;
-            let scratch = load.primary_entries.as_bytes_mut();
-            // Invalidate GPT first.
-            load.block_size.0 = None;
-            // Erases primary header/entries.
-            let header = load.primary_header.current;
-            let entries = load.primary_header.entries;
-            disk.fill(header * blk_sz, blk_sz, 0, scratch).await?;
-            disk.fill(entries * blk_sz, entries_size.try_into().unwrap(), 0, scratch).await?;
-            // Erases secondary header/entries.
-            let header = load.secondary_header.current;
-            let entries = load.secondary_header.entries;
-            disk.fill(header * blk_sz, blk_sz, 0, scratch).await?;
-            disk.fill(entries * blk_sz, entries_size.try_into().unwrap(), 0, scratch).await?;
-            Ok(())
-        }
-    }
-}
-
-/// Computes the minimum blocks needed for creating a GPT.
-fn min_required_blocks(block_size: u64) -> Result<u64> {
-    // MBR + primary/secondary GPT header block + primary/secondary entries blocks.
-    Ok(1 + (1 + gpt_entries_blk(block_size)?) * 2)
-}
-
-/// `GptBuilder` provides API for modifying/creating GPT partition table on a disk.
-pub struct GptBuilder<D, G> {
-    disk: D,
-    gpt: G,
-}
-
-impl<D: Debug, G: Debug> Debug for GptBuilder<D, G> {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {
-        write!(f, "GptBuilder {{ disk: {:?}, gpt: {:?} }}", self.disk, self.gpt)
-    }
-}
-// Generic parameters:
-//
-// * T: The type that implement BlockIo.
-// * S: The type for the scratch buffer in `Self::disk`.
-// * B: The type for the GPT buffer in `Self::gpt`.
-// * D: The type for `Self::disk` which can dereference to a Disk<T, S>.
-// * G: The type for `Self::gpt` which can dereference to a Gpt<B>.
-impl<'a, T, S, B, D, G> GptBuilder<D, G>
-where
-    T: BlockIo,
-    S: DerefMut<Target = [u8]>,
-    B: DerefMut<Target = [u8]>,
-    D: DerefMut<Target = Disk<T, S>>,
-    G: DerefMut<Target = Gpt<B>>,
-{
-    /// Creates a new instance.
-    ///
-    /// The method always re-syncs the GPT. If `disk` does not contain a valid GPT, a new GPT is
-    /// started from scratch.
-    ///
-    /// The partition entries will always be sorted when writing back to disk by `Self::persist()`.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok((Self, true)) if an instance is created and the disk has a valid GPT.
-    /// * Returns Ok((Self, false)) if an instance is created but disk does not have a valid GPT.
-    /// * Returns Err() otherwise.
-    pub fn new(mut disk: D, mut gpt: G) -> Result<(Self, bool)> {
-        if disk.block_info().num_blocks < min_required_blocks(disk.block_info().block_size)? {
-            return Err(Error::GptError(GptError::DiskTooSmall));
-        }
-        let has_valid_gpt = block_on(disk.sync_gpt(&mut gpt))?.res().is_ok();
-        // Uses the buffer for secondary GPT header/entries as construction buffer, as it is not
-        // used by Gpt once loaded and synced.
-        let (mut header, mut entries) = LoadBufferRef::from(&mut gpt.buffer[..]).secondary();
-        if !has_valid_gpt {
-            header.as_bytes_mut().fill(0);
-            entries.as_bytes_mut().fill(0);
-            let entries_blk = gpt_entries_blk(disk.block_info().block_size).unwrap();
-            // Initializes a secondary header.
-            let num_blks = SafeNum::from(disk.block_info().num_blocks);
-            header.magic = GPT_MAGIC;
-            header.current = (num_blks - 1).try_into().unwrap();
-            header.backup = 1;
-            header.size = size_of::<GptHeader>().try_into().unwrap();
-            header.first = 1 + 1 + entries_blk; // MBR + GPT header blocks + entries block
-            header.last = (num_blks - 1 - entries_blk - 1).try_into().unwrap();
-            header.entries = (num_blks - 1 - entries_blk).try_into().unwrap();
-            header.entries_count = 0;
-            header.entries_size = size_of::<GptEntry>().try_into().unwrap();
-        }
-        // Normalizes `entries_count` to actual valid entries. Some GPT disk fixes `entry_count` to
-        // 128.
-        header.entries_count =
-            entries.iter().position(|v| v.is_null()).unwrap_or(entries.len()).try_into().unwrap();
-        entries.sort_unstable_by_key(|v| match v.is_null() {
-            true => u64::MAX,
-            _ => v.first,
-        });
-        Ok((Self { disk, gpt }, has_valid_gpt))
-    }
-
-    /// Removes a partition.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok(true) if found and removed.
-    /// * Returns Ok(false) if not found.
-    /// * Returns Err() otherwise.
-    pub fn remove(&mut self, part: &str) -> Result<bool> {
-        let (mut header, mut entries) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
-        let entries = &mut entries[..header.entries_count.try_into().unwrap()];
-        match entries.iter().position(|v| v.match_name(part).unwrap_or(false)) {
-            Some(n) => {
-                // Shift the elements behind forward.
-                entries[n..].rotate_left(1);
-                // Zeroizes the last element.
-                entries.last_mut().unwrap().as_bytes_mut().fill(0);
-                header.entries_count -= 1;
-                Ok(true)
-            }
-            _ => Ok(false),
-        }
-    }
-
-    /// Inserts a new partition before a partition.
-    ///
-    /// # Args
-    ///
-    /// * `idx`: Index of the partition to insert before. If index is out of range of valid entries,
-    ///   the partition will be inserted at the last.
-    /// * `name`: Name of the partition.
-    /// * `part_type`: Type GUID.
-    /// * `unique_guid`: Unique GUID.
-    /// * `flags`: Partition flag.
-    /// * `size`: If Some(_), specifies the size in number of bytes for the partition. The method
-    ///   will round it up to multiple of disk block size and check that there is enough space for
-    ///   the partition. If None, the method will insert the partition and consumes all the
-    ///   available space in between.
-    fn insert_before(
-        &mut self,
-        idx: usize,
-        name: &str,
-        part_type: [u8; GPT_GUID_LEN],
-        unique_guid: [u8; GPT_GUID_LEN],
-        flags: u64,
-        size: Option<u64>,
-    ) -> Result<()> {
-        let (mut header, mut entries) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
-        // Gets position to the first NULL entry.
-        let n = entries.iter().position(|v| v.is_null()).ok_or(Error::OutOfResources)?;
-        let entries = &mut entries[..n + 1];
-        // Caps `idx` to no more than the first NULL entry.
-        let idx = min(n, idx);
-        // Comptues the ending block index (non-inclusive) of the previous partition entry.
-        // Entries are guaranteed sorted in `Self::new()`.
-        let prev_end = match idx {
-            0 => header.first,
-            _ => entries[idx - 1].last + 1,
-        };
-        // Comptues the starting block index (inclusive) of the next partition entry.
-        let next_start = match idx == n {
-            true => header.last + 1,
-            _ => entries[idx].first,
-        };
-        // Computes the size in number of blocks
-        let blk_sz = self.disk.block_info().block_size;
-        let blocks: u64 = match size {
-            Some(v) => (SafeNum::from(v).round_up(blk_sz) / blk_sz).try_into()?,
-            _ => next_start - prev_end, // If not given, uses up all the gap space
-        };
-        // Checks if there is enough space.
-        if next_start - prev_end < blocks {
-            return Err(Error::OutOfResources);
-        }
-        // Inserts the new entry.
-        entries[idx..].rotate_right(1);
-        let entry = &mut entries[idx];
-        assert!(entry.is_null());
-        entry.part_type = part_type;
-        entry.guid = unique_guid;
-        entry.flags = flags;
-        entry.first = prev_end;
-        entry.last = prev_end + blocks - 1;
-        for (idx, ele) in name.encode_utf16().enumerate() {
-            match idx < GPT_NAME_LEN_U16 {
-                true => entry.name[idx] = ele,
-                _ => break,
-            }
-        }
-        header.entries_count += 1;
-        Ok(())
-    }
-
-    /// Adds a partition.
-    ///
-    /// # Args
-    ///
-    /// * `name`: Name of the partition.
-    /// * `part_type`: Type GUID.
-    /// * `unique_guid`: Unique GUID.
-    /// * `flags`: Partition flag.
-    /// * `size`: If Some(_), specifies the size in number of bytes for the partition. The method
-    ///   will round it up to multiple of disk block size and search for the first large enough
-    ///   space in the unused spae for putting the partition. If None, the method will add the
-    ///   partition at the last and have it consume all remaining usable disk space.
-    pub fn add(
-        &mut self,
-        name: &str,
-        part_type: [u8; GPT_GUID_LEN],
-        unique_guid: [u8; GPT_GUID_LEN],
-        flags: u64,
-        size: Option<u64>,
-    ) -> Result<()> {
-        let (header, _) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
-        let entry_count = usize::try_from(header.entries_count).unwrap();
-        let search_start = size.is_some().then_some(0).unwrap_or(entry_count);
-        for i in search_start..entry_count + 1 {
-            if self.insert_before(i, name, part_type, unique_guid, flags, size).is_ok() {
-                return Ok(());
-            }
-        }
-        Err(Error::OutOfResources)
-    }
-
-    /// Persists the constructed GPT table to the disk and syncs. The builder is consumed.
-    pub async fn persist(mut self) -> Result<()> {
-        let (mut header, mut entries) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
-        header.update_entries_crc(entries.as_bytes());
-        // Check validity. Should not fail if implementation is correct.
-        check_header(self.disk.io(), &header, false).unwrap();
-        check_entries(&header, entries.as_bytes()).unwrap();
-        let blk_sz = self.disk.block_info().block_size;
-        // Writes to secondary header/ entries
-        self.disk.write(header.current * blk_sz, header.as_bytes_mut()).await?;
-        self.disk.write(header.entries * blk_sz, entries.as_bytes_mut()).await?;
-        // Clears primary header magic
-        self.disk.write(blk_sz, &mut 0u64.to_be_bytes()).await?;
-        // Re-syncs GPT
-        self.disk.sync_gpt(&mut self.gpt).await?.res()
-    }
-}
-
-/// Helper for calculcating the Crc32.
-fn crc32(data: &[u8]) -> u32 {
-    let mut hasher = Hasher::new();
-    hasher.update(data);
-    hasher.finalize()
-}
-
-#[cfg(test)]
-pub(crate) mod test {
-    use super::*;
-    use crate::test::TestDisk;
-    use gbl_async::block_on;
-
-    /// A helper for creating a [TestDisk] from given data.
-    fn test_disk(data: impl AsRef<[u8]>) -> TestDisk {
-        // All tests cases use pre-generated GPT disk of 512 block size.
-        TestDisk::new_ram_alloc(512, 512, data.as_ref().to_vec()).unwrap()
-    }
-
-    /// A helper for creating a [TestDisk] from given data and a [Gpt] for 128 entries.
-    fn test_disk_and_gpt(data: impl AsRef<[u8]>) -> (TestDisk, GptMax) {
-        (test_disk(data), new_gpt_max())
-    }
-
-    #[test]
-    fn test_load_and_sync() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
-        block_on(dev.sync_gpt(&mut gpt)).unwrap();
-
-        assert_eq!(gpt.partition_iter().unwrap().count(), 2);
-        gpt.find_partition("boot_a").unwrap();
-        gpt.find_partition("boot_b").unwrap();
-        assert!(gpt.find_partition("boot_c").is_err());
-
-        // Creating a new [Gpt] using the same buffer should reset the valid state.
-        let gpt = Gpt::new(gpt.buffer).unwrap();
-        assert!(gpt.partition_iter().is_err());
-        assert!(gpt.find_partition("boot_a").is_err());
-        assert!(gpt.find_partition("boot_b").is_err());
-    }
-
-    #[test]
-    fn test_load_with_unaligned_buffer() {
-        #[repr(align(8))]
-        struct AlignedBuffer([u8; 34 * 1024]);
-        let mut buffer = AlignedBuffer([0u8; 34 * 1024]);
-        let buffer = &mut buffer.0[1..];
-        assert_ne!(buffer.as_ptr() as usize % 2, 0);
-        let mut disk = test_disk(include_bytes!("../test/gpt_test_1.bin"));
-        let mut gpt = Gpt::new(buffer).unwrap();
-        block_on(disk.sync_gpt(&mut gpt)).unwrap();
-    }
-
-    #[test]
-    fn test_gpt_buffer_too_small() {
-        assert!(Gpt::new(vec![0u8; size_of::<GptLoadBufferN<0>>() - 1]).is_err());
-    }
-
-    #[test]
-    fn test_gpt_buffer_not_enough_for_all_entries() {
-        let mut dev = test_disk(include_bytes!("../test/gpt_test_1.bin"));
-        let mut gpt = new_gpt_n::<127>();
-        assert_eq!(gpt.max_entries(), 127);
-        // Actual entries_count is 128 in the GPT.
-        assert!(block_on(dev.sync_gpt(&mut gpt)).unwrap().res().is_err());
-    }
-
-    #[test]
-    fn test_good_gpt_no_repair_write() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
-        assert_eq!(block_on(dev.sync_gpt(&mut gpt)).unwrap(), GptSyncResult::BothValid);
-    }
-
-    /// A helper for testing restoration of invalid primary/secondary header modified by caller.
-    fn test_gpt_sync_restore<'a>(
-        modify_primary: impl FnOnce(&mut GptHeader, Ref<&mut [u8], [GptEntry]>),
-        modify_secondary: impl FnOnce(&mut GptHeader, Ref<&mut [u8], [GptEntry]>),
-        expect_primary_err: Error,
-        expect_secondary_err: Error,
-    ) {
-        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
-
-        // Restores from secondary to primary.
-        let mut disk = disk_orig.to_vec();
-        let (header, entries) = (&mut disk[512..]).split_at_mut(512);
-        let mut header = GptHeader::from_bytes_mut(header);
-        modify_primary(&mut header, Ref::<_, [GptEntry]>::new_slice(entries).unwrap());
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        assert_ne!(dev.io().storage(), disk_orig);
-        let sync_res = block_on(dev.sync_gpt(&mut gpt)).unwrap();
-        assert_eq!(sync_res, GptSyncResult::PrimaryRestored(expect_primary_err));
-        assert_eq!(dev.io().storage(), disk_orig);
-
-        // Restores from primary to secondary.
-        let mut disk = disk_orig.to_vec();
-        let (entries, header) = (&mut disk[512..]).split_last_chunk_mut::<512>().unwrap();
-        let (_, entries) = entries.split_last_chunk_mut::<{ 512 * 32 }>().unwrap();
-        let mut header = GptHeader::from_bytes_mut(&mut header[..]);
-        modify_secondary(&mut header, Ref::<_, [GptEntry]>::new_slice(&mut entries[..]).unwrap());
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        assert_ne!(dev.io().storage(), disk_orig);
-        let sync_res = block_on(dev.sync_gpt(&mut gpt)).unwrap();
-        assert_eq!(sync_res, GptSyncResult::SecondaryRestored(expect_secondary_err));
-        assert_eq!(dev.io().storage(), disk_orig);
-    }
-
-    #[test]
-    fn test_sync_gpt_incorrect_magic() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.magic = 0x123456;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::IncorrectMagic(0x123456));
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_incorrect_crc() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.crc32 = !hdr.crc32;
-        }
-        let err = Error::GptError(GptError::IncorrectHeaderCrc);
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_unexpected_header_size() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.size += 1;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::UnexpectedHeaderSize { actual: 93, expect: 92 });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_unexpected_entry_size() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.entries_size += 1;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::UnexpectedEntrySize { actual: 129, expect: 128 });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_first_usable_gt_last() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.first = hdr.last;
-            hdr.last = hdr.first - 2;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::InvalidFirstLastUsableBlock {
-            first: 94,
-            last: 92,
-            range: (34, 94),
-        });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_first_usable_out_of_range() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.first = 33;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::InvalidFirstLastUsableBlock {
-            first: 33,
-            last: 94,
-            range: (34, 94),
-        });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_last_usable_out_of_range() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.last += 1;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::InvalidFirstLastUsableBlock {
-            first: 34,
-            last: 95,
-            range: (34, 94),
-        });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_primary_entries_out_of_range() {
-        test_gpt_sync_restore(
-            |hdr, _| {
-                hdr.entries = 1;
-                hdr.update_crc();
-            },
-            |hdr, _| {
-                hdr.entries = hdr.last;
-                hdr.update_crc();
-            },
-            Error::GptError(GptError::InvalidPrimaryEntriesStart {
-                value: 1,
-                expect_range: (2, 2),
-            }),
-            Error::GptError(GptError::InvalidSecondaryEntriesStart {
-                value: 94,
-                expect_range: (95, 95),
-            }),
-        );
-    }
-
-    #[test]
-    fn test_sync_gpt_incorrect_entry_crc() {
-        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
-            hdr.entries_crc = !hdr.entries_crc;
-            hdr.update_crc();
-        }
-        let err = Error::GptError(GptError::IncorrectEntriesCrc);
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_partition_range_overflow() {
-        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
-            entries[1].last = hdr.last + 1;
-            hdr.update_entries_crc(entries.as_bytes());
-        }
-        let err = Error::GptError(GptError::InvalidPartitionRange {
-            idx: 2,
-            part_range: (50, 95),
-            usable_range: (34, 94),
-        });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_invalid_partition_range() {
-        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
-            entries[1].first = entries[1].last;
-            entries[1].last = entries[1].first - 2;
-            hdr.update_entries_crc(entries.as_bytes());
-        }
-        let err = Error::GptError(GptError::InvalidPartitionRange {
-            idx: 2,
-            part_range: (73, 71),
-            usable_range: (34, 94),
-        });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_partition_overlap() {
-        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
-            entries[0].last = entries[1].first;
-            entries.swap(0, 1);
-            hdr.update_entries_crc(entries.as_bytes());
-        }
-        let err = Error::GptError(GptError::PartitionRangeOverlap {
-            prev: (2, 34, 50),
-            next: (1, 50, 73),
-        });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_zero_partition_type_guid() {
-        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
-            entries[1].part_type = [0u8; GPT_GUID_LEN];
-            hdr.update_entries_crc(entries.as_bytes());
-        }
-        let err = Error::GptError(GptError::ZeroPartitionTypeGUID { idx: 2 });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_sync_gpt_zero_partition_unique_guid() {
-        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
-            entries[1].guid = [0u8; GPT_GUID_LEN];
-            hdr.update_entries_crc(entries.as_bytes());
-        }
-        let err = Error::GptError(GptError::ZeroPartitionUniqueGUID { idx: 2 });
-        test_gpt_sync_restore(modify, modify, err, err);
-    }
-
-    #[test]
-    fn test_load_gpt_disk_primary_override_secondary() {
-        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
-        // Modifies secondary header.
-        let secondary_hdr = GptHeader::from_bytes_mut(disk.last_chunk_mut::<512>().unwrap());
-        secondary_hdr.revision = !secondary_hdr.revision;
-        secondary_hdr.update_crc();
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        assert_eq!(
-            block_on(dev.sync_gpt(&mut gpt)).unwrap(),
-            GptSyncResult::SecondaryRestored(Error::GptError(GptError::DifferentFromPrimary)),
-        );
-    }
-
-    #[test]
-    fn test_load_gpt_disk_too_small() {
-        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
-        let mut disk = disk_orig.to_vec();
-        // Resizes so that it's not enough to hold a full 128 maximum entries.
-        // MBR + (header + entries) * 2 - 1
-        disk.resize((1 + (32 + 1) * 2 - 1) * 512, 0);
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        let sync_res = block_on(dev.sync_gpt(&mut gpt)).unwrap();
-        let err = Error::GptError(GptError::DiskTooSmall);
-        assert_eq!(sync_res, GptSyncResult::NoValidGpt { primary: err, secondary: err });
-    }
-
-    #[test]
-    fn test_uninitialized_gpt() {
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        // Load a good GPT first.
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        assert_eq!(block_on(dev.sync_gpt(&mut gpt)).unwrap(), GptSyncResult::BothValid);
-        gpt.find_partition("boot_a").unwrap();
-        // Corrupt GPT.
-        block_on(dev.write(0, &mut vec![0u8; disk.len()])).unwrap();
-        assert!(block_on(dev.sync_gpt(&mut gpt)).unwrap().res().is_err());
-        assert!(gpt.find_partition("").is_err());
-    }
-
-    #[test]
-    fn test_update_gpt() {
-        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
-        let mut disk = disk_orig.to_vec();
-        // Erases all GPT headers.
-        disk[512..][..512].fill(0);
-        disk.last_chunk_mut::<512>().unwrap().fill(0);
-
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-
-        assert_ne!(dev.io().storage(), disk_orig);
-        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
-        block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)).unwrap();
-        assert_eq!(dev.io().storage(), disk_orig);
-    }
-
-    #[test]
-    fn test_update_gpt_has_existing_valid_secondary() {
-        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
-        let mut disk = disk_orig.to_vec();
-        // Erases all GPT headers.
-        disk[512..][..512].fill(0);
-        // Leaves a valid but different secondary GPT.
-        let secondary_hdr = GptHeader::from_bytes_mut(disk.last_chunk_mut::<512>().unwrap());
-        secondary_hdr.revision = !secondary_hdr.revision;
-        secondary_hdr.update_crc();
-
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-
-        assert_ne!(dev.io().storage(), disk_orig);
-        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
-        block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)).unwrap();
-        assert_eq!(dev.io().storage(), disk_orig);
-    }
-
-    #[test]
-    fn test_update_gpt_last_usable_adjusted() {
-        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
-        let mut disk = disk_orig.to_vec();
-        // Erases all GPT headers.
-        disk[512..][..512].fill(0);
-        disk.last_chunk_mut::<512>().unwrap().fill(0);
-        // Doubles the disk size.
-        disk.resize(disk_orig.len() * 2, 0);
-
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-
-        assert_ne!(dev.io().storage, disk_orig);
-        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
-        block_on(dev.update_gpt(&mut mbr_primary, true, &mut gpt)).unwrap();
-        let expected_last = (disk.len() - GPT_MAX_NUM_ENTRIES_SIZE - 512) / 512 - 1;
-
-        let (primary, secondary) = dev.io().storage().split_last_chunk_mut::<512>().unwrap();
-        let primary_hdr = GptHeader::from_bytes_mut(&mut primary[512..]);
-        let secondary_hdr = GptHeader::from_bytes_mut(secondary);
-        // Header's last usable block is updated.
-        assert_eq!({ primary_hdr.last }, expected_last.try_into().unwrap());
-        assert_eq!({ primary_hdr.backup }, (disk.len() / 512 - 1).try_into().unwrap());
-        assert_eq!({ secondary_hdr.last }, expected_last.try_into().unwrap());
-    }
-
-    #[test]
-    fn test_update_gpt_resize() {
-        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
-        let mut disk = disk_orig.to_vec();
-        // Erases all GPT headers.
-        disk[512..][..512].fill(0);
-        disk.last_chunk_mut::<512>().unwrap().fill(0);
-        // Doubles the disk size.
-        disk.resize(disk_orig.len() * 2, 0);
-
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-
-        assert_ne!(dev.io().storage, disk_orig);
-        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
-        block_on(dev.update_gpt(&mut mbr_primary, true, &mut gpt)).unwrap();
-        // Last entry is extended.
-        let expected_last = (disk.len() - GPT_MAX_NUM_ENTRIES_SIZE - 512) / 512 - 1;
-        assert_eq!({ gpt.entries().unwrap()[1].last }, expected_last.try_into().unwrap());
-    }
-
-    #[test]
-    fn test_update_gpt_new_partition_out_of_range() {
-        // `gpt_test_1.bin` has a 8k "boot_a" and a 12k "boot_b". Thus partitions space is 40
-        // blocks (512 bytes block size) and in total the GPT disk needs (40 + 1 + (33) * 2) = 107
-        // blocks.
-        let (mut dev, mut gpt) = test_disk_and_gpt(&vec![0u8; 106 * 512]);
-        let mut mbr_primary = include_bytes!("../test/gpt_test_1.bin")[..34 * 512].to_vec();
-        assert!(block_on(dev.update_gpt(&mut mbr_primary, true, &mut gpt)).is_err());
-    }
-
-    #[test]
-    fn test_update_gpt_buffer_truncated() {
-        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-
-        // Less than 1 MBR block.
-        assert_eq!(
-            block_on(dev.update_gpt(&mut disk[..511], false, &mut gpt)),
-            Err(Error::BufferTooSmall(Some(1024)))
-        );
-
-        // Less than MBR + GPT header.
-        assert_eq!(
-            block_on(dev.update_gpt(&mut disk[..1023], false, &mut gpt)),
-            Err(Error::BufferTooSmall(Some(1024)))
-        );
-
-        // Less than MBR + GPT header + entries.
-        assert_eq!(
-            block_on(dev.update_gpt(&mut disk[..34 * 512 - 1], false, &mut gpt)),
-            Err(Error::BufferTooSmall(Some(34 * 512)))
-        );
-    }
-
-    #[test]
-    fn test_update_gpt_check_header_fail() {
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        let mut mbr_primary = disk[..34 * 512].to_vec();
-        // Corrupts the first byte of the GPT header.
-        mbr_primary[512] = !mbr_primary[512];
-        assert_eq!(
-            block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)),
-            Err(Error::GptError(GptError::IncorrectMagic(0x54524150204946BA)))
-        );
-    }
-
-    #[test]
-    fn test_update_gpt_check_entries_fail() {
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        let mut mbr_primary = disk[..34 * 512].to_vec();
-        // Corrupts the first byte of the entries.
-        mbr_primary[1024] = !mbr_primary[1024];
-        assert_eq!(
-            block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)),
-            Err(Error::GptError(GptError::IncorrectEntriesCrc))
-        );
-    }
-
-    #[test]
-    fn test_erase_gpt_no_gpt() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(&[0u8; 1024 * 1024]);
-        block_on(dev.erase_gpt(&mut gpt)).unwrap();
-    }
-
-    #[test]
-    fn test_erase_gpt() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
-        block_on(dev.erase_gpt(&mut gpt)).unwrap();
-        const GPT_SECTOR: usize = 33 * 512;
-        assert_eq!(dev.io().storage[512..][..GPT_SECTOR], vec![0u8; GPT_SECTOR]);
-        assert_eq!(*dev.io().storage.last_chunk::<GPT_SECTOR>().unwrap(), *vec![0u8; GPT_SECTOR]);
-        assert!(matches!(
-            block_on(dev.sync_gpt(&mut gpt)).unwrap(),
-            GptSyncResult::NoValidGpt { .. }
-        ));
-    }
-
-    #[test]
-    fn test_zero_partition_size() {
-        let disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        assert_eq!(builder.remove("boot_a"), Ok(true));
-        assert_eq!(builder.remove("boot_b"), Ok(true));
-        builder.add("boot_b", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(0)).unwrap();
-        block_on(builder.persist()).unwrap();
-        assert_eq!(gpt.partition_iter().unwrap().next().unwrap().size().unwrap(), 0);
-    }
-
-    #[test]
-    fn test_sync_gpt_non_sorted_entries() {
-        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
-        let (header, entries) = disk[512..].split_at_mut(512);
-        let header = GptHeader::from_bytes_mut(header);
-        let mut entries = Ref::<_, [GptEntry]>::new_slice(entries).unwrap();
-        // Makes partition non-sorted.
-        entries.swap(0, 1);
-        header.update_entries_crc(entries.as_bytes());
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
-    }
-
-    #[test]
-    fn test_gpt_builder_initialize_gpt_if_no_valid_gpt() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(vec![0u8; 1024 * 1024]);
-        let (builder, valid) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        assert!(!valid);
-        block_on(builder.persist()).unwrap();
-        // A new GPT is created.
-        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
-        assert!(gpt.partition_iter().unwrap().next().is_none());
-    }
-
-    #[test]
-    fn test_gpt_builder_remove_partition() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
-        let (mut builder, valid) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        assert!(valid);
-        assert_eq!(builder.remove("boot_b"), Ok(true));
-        assert_eq!(builder.remove("non-existent"), Ok(false));
-        block_on(builder.persist()).unwrap();
-        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
-        let part_iter = gpt.partition_iter().unwrap();
-        assert_eq!(
-            part_iter.map(|v| v.name().unwrap().into()).collect::<Vec<String>>(),
-            ["boot_a"]
-        );
-    }
-
-    #[test]
-    fn test_gpt_builder_add_partition_find_first() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
-        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        assert!(builder.remove("boot_a").unwrap());
-        // Adds at the beginning.
-        builder.add("new_0", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
-        // Adds following "new_0"
-        builder.add("new_1", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1)).unwrap();
-        block_on(builder.persist()).unwrap();
-        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
-        assert_eq!(gpt.find_partition("new_0").unwrap().absolute_range().unwrap(), (17408, 18432));
-        assert_eq!(gpt.find_partition("new_1").unwrap().absolute_range().unwrap(), (18432, 18944));
-        assert_eq!(gpt.find_partition("boot_b").unwrap().absolute_range().unwrap(), (25600, 37888));
-    }
-
-    #[test]
-    fn test_gpt_builder_non_sorted_add_partition() {
-        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
-        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
-        let (header, entries) = disk[512..].split_at_mut(512);
-        let header = GptHeader::from_bytes_mut(header);
-        let mut entries = Ref::<_, [GptEntry]>::new_slice(entries).unwrap();
-        // Makes partition non-sorted.
-        entries.swap(0, 1);
-        header.update_entries_crc(entries.as_bytes());
-
-        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        // Adds following boot_b.
-        builder.add("new", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
-        block_on(builder.persist()).unwrap();
-        assert_eq!(gpt.find_partition("boot_a").unwrap().absolute_range().unwrap(), (17408, 25600));
-        assert_eq!(gpt.find_partition("boot_b").unwrap().absolute_range().unwrap(), (25600, 37888));
-        assert_eq!(gpt.find_partition("new").unwrap().absolute_range().unwrap(), (37888, 38912));
-    }
-
-    #[test]
-    fn test_gpt_builder_add_partition_append() {
-        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
-        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        assert!(builder.remove("boot_b").unwrap());
-        // Adds following "boot_a".
-        builder.add("new_0", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
-        // Consumes the rest of the space.
-        builder.add("new_1", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, None).unwrap();
-        block_on(builder.persist()).unwrap();
-        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
-        assert_eq!(gpt.find_partition("boot_a").unwrap().absolute_range().unwrap(), (17408, 25600));
-        assert_eq!(gpt.find_partition("new_0").unwrap().absolute_range().unwrap(), (25600, 26624));
-        assert_eq!(gpt.find_partition("new_1").unwrap().absolute_range().unwrap(), (26624, 48640));
-    }
-
-    #[test]
-    fn test_gpt_builder_not_enough_resource() {
-        // Create a Gpt that can only load 1 entry.
-        let mut gpt = new_gpt_n::<1>();
-        let mut dev = test_disk(vec![0u8; 64 * 1024]);
-        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
-        builder.add("new_0", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
-        assert!(builder.add("new_1", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, None).is_err());
-    }
-}
diff --git a/gbl/libstorage/src/lib.rs b/gbl/libstorage/src/lib.rs
deleted file mode 100644
index 1f4c8b7..0000000
--- a/gbl/libstorage/src/lib.rs
+++ /dev/null
@@ -1,940 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! The library provides APIs for reading/writing with block devices with arbitrary alignment,
-//! ranges and parsing and manipulation GPT.
-
-#![cfg_attr(not(test), no_std)]
-#![allow(async_fn_in_trait)]
-
-use core::{
-    cell::RefMut,
-    cmp::{max, min},
-    mem::{size_of_val, MaybeUninit},
-    ops::DerefMut,
-    slice::SliceIndex,
-};
-use liberror::{Error, Result};
-use libutils::aligned_subslice;
-use safemath::SafeNum;
-
-// Selective export of submodule types.
-mod gpt;
-pub use gpt::{
-    gpt_buffer_size, new_gpt_max, new_gpt_n, Gpt, GptBuilder, GptEntry, GptHeader, GptLoadBufferN,
-    GptMax, GptN, GptSyncResult, Partition, PartitionIterator, GPT_GUID_LEN, GPT_MAGIC,
-    GPT_NAME_LEN_U16,
-};
-
-mod algorithm;
-pub use algorithm::{read_async, write_async};
-
-pub mod ram_block;
-pub use ram_block::RamBlockIo;
-
-/// `BlockInfo` contains information for a block device.
-#[derive(Clone, Copy, Debug)]
-pub struct BlockInfo {
-    /// Native block size of the block device.
-    pub block_size: u64,
-    /// Total number of blocks of the block device.
-    pub num_blocks: u64,
-    /// The alignment requirement for IO buffers. For example, many block device drivers use DMA
-    /// for data transfer, which typically requires that the buffer address for DMA be aligned to
-    /// 16/32/64 bytes etc. If the block device has no alignment requirement, it can return 1.
-    pub alignment: u64,
-}
-
-impl BlockInfo {
-    /// Computes the total size in bytes of the block device.
-    pub fn total_size(&self) -> Result<u64> {
-        Ok((SafeNum::from(self.block_size) * self.num_blocks).try_into()?)
-    }
-}
-
-/// `BlockIo` provides interfaces for reading and writing block storage medium.
-///
-/// SAFETY:
-/// `read_blocks` method must guarantee `out` to be fully initialized on success. Otherwise error
-/// must be returned.
-/// This is necessary because unsafe code that uses BlockIo assumes `out` to be fully initialized to
-/// work with it as with `&mut [u8]`.
-pub unsafe trait BlockIo {
-    /// Returns the `BlockInfo` for this block device.
-    fn info(&mut self) -> BlockInfo;
-
-    /// Read blocks of data from the block device
-    ///
-    /// # Args
-    ///
-    /// * `blk_offset`: Offset in number of blocks.
-    ///
-    /// * `out`: Buffer to store the read data. Callers of this method ensure that it is
-    ///   aligned according to alignment() and `out.len()` is multiples of `block_size()`.
-    ///
-    /// # Returns
-    ///
-    /// Returns true if exactly out.len() number of bytes are read. Otherwise false.
-    async fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()>;
-
-    /// Write blocks of data to the block device
-    ///
-    /// # Args
-    ///
-    /// * `blk_offset`: Offset in number of blocks.
-    ///
-    /// * `data`: Data to write. Callers of this method ensure that it is aligned according to
-    ///   `alignment()` and `data.len()` is multiples of `block_size()`.
-    ///
-    /// # Returns
-    ///
-    /// Returns true if exactly data.len() number of bytes are written. Otherwise false.
-    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()>;
-}
-
-// SAFETY:
-// `read_blocks` method has same guaranties as `BlockIo` implementation of referenced type T.
-// Which guaranties `out` to be fully initialized on success.
-unsafe impl<T: DerefMut> BlockIo for T
-where
-    T::Target: BlockIo,
-{
-    fn info(&mut self) -> BlockInfo {
-        self.deref_mut().info()
-    }
-
-    async fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()> {
-        self.deref_mut().read_blocks(blk_offset, out).await
-    }
-
-    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        self.deref_mut().write_blocks(blk_offset, data).await
-    }
-}
-
-/// An implementation of `BlockIo` of where all required methods are `unimplemented!()`
-pub struct BlockIoNull {}
-
-// SAFETY:
-// `read_blocks` never succeeds since it is not implemented and will panic.
-unsafe impl BlockIo for BlockIoNull {
-    fn info(&mut self) -> BlockInfo {
-        unimplemented!();
-    }
-
-    async fn read_blocks(
-        &mut self,
-        _: u64,
-        _: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()> {
-        unimplemented!();
-    }
-
-    async fn write_blocks(&mut self, _: u64, _: &mut [u8]) -> Result<()> {
-        unimplemented!();
-    }
-}
-
-/// Check if `value` is aligned to (multiples of) `alignment`
-/// It can fail if the remainider calculation fails overflow check.
-pub fn is_aligned(value: impl Into<SafeNum>, alignment: impl Into<SafeNum>) -> Result<bool> {
-    Ok(u64::try_from(value.into() % alignment.into())? == 0)
-}
-
-/// Check if `buffer` address is aligned to `alignment`
-/// It can fail if the remainider calculation fails overflow check.
-pub fn is_buffer_aligned<T>(buffer: &[T], alignment: u64) -> Result<bool> {
-    is_aligned(buffer.as_ptr() as usize, alignment)
-}
-
-/// Check read/write range and calculate offset in number of blocks.
-fn check_range<T>(info: BlockInfo, offset: u64, buffer: &[T]) -> Result<SafeNum> {
-    let offset: SafeNum = offset.into();
-    let block_size: SafeNum = info.block_size.into();
-    debug_assert!(is_aligned(offset, block_size)?, "{:?}, {:?}", offset, block_size);
-    debug_assert!(is_aligned(size_of_val(buffer), block_size)?);
-    debug_assert!(is_buffer_aligned(buffer, info.alignment)?);
-    let blk_offset = offset / block_size;
-    let blk_count = SafeNum::from(size_of_val(buffer)) / block_size;
-    let end: u64 = (blk_offset + blk_count).try_into()?;
-    match end <= info.num_blocks {
-        true => Ok(blk_offset),
-        false => Err(Error::BadIndex(end as usize)),
-    }
-}
-
-/// Computes the required scratch size for initializing a [AsyncBlockDevice].
-pub fn scratch_size(io: &mut impl BlockIo) -> Result<usize> {
-    let info = io.info();
-    let block_alignment = match info.block_size {
-        1 => 0,
-        v => v,
-    };
-    Ok(((SafeNum::from(info.alignment) - 1) * 2 + block_alignment).try_into()?)
-}
-
-/// `Disk` contains a BlockIO and scratch buffer and provides APIs for reading/writing with
-/// arbitrary ranges and alignment.
-pub struct Disk<T, S> {
-    io: T,
-    scratch: S,
-}
-
-impl<T: BlockIo, S: DerefMut<Target = [u8]>> Disk<T, S> {
-    /// Creates a new instance with the given IO and scratch buffer.
-    ///
-    /// * The scratch buffer is internally used for handling partial block read/write and unaligned
-    ///   input/output user buffers.
-    ///
-    /// * The necessary size for the scratch buffer depends on `BlockInfo::alignment`,
-    ///   `BlockInfo::block_size`. It can be computed using the helper API `scratch_size()`. If the
-    ///   block device has no alignment requirement, i.e. both alignment and block size are 1, the
-    ///   total required scratch size is 0.
-    pub fn new(mut io: T, scratch: S) -> Result<Self> {
-        let sz = scratch_size(&mut io)?;
-        match scratch.len() < sz {
-            true => Err(Error::BufferTooSmall(Some(sz))),
-            _ => Ok(Self { io, scratch }),
-        }
-    }
-
-    /// Same as `Self::new()` but allocates the necessary scratch buffer.
-    ///
-    /// T must implement Extend<u8> and Default. It should typically be a vector like type.
-    ///
-    /// Allocation is done by extending T one element at a time. In most cases, we don't expect
-    /// block size or alignment to be large values and this is only done once. thus this should be
-    /// low cost. However if that is not the case, it is recommended to use `Self::new()` with
-    /// pre-allocated scratch buffer.
-    pub fn new_alloc_scratch(mut io: T) -> Result<Self>
-    where
-        S: Extend<u8> + Default,
-    {
-        let mut scratch = S::default();
-        // Extends the scratch buffer to the required size.
-        // Can call `extend_reserve()` first once it becomes stable.
-        (0..max(scratch.len(), scratch_size(&mut io)?) - scratch.len())
-            .for_each(|_| scratch.extend([0u8]));
-        Self::new(io, scratch)
-    }
-
-    /// Creates a `Disk<&mut T, &mut [u8]>` instance that borrows the internal fields.
-    pub fn as_borrowed(&mut self) -> Disk<&mut T, &mut [u8]> {
-        Disk::new(&mut self.io, &mut self.scratch[..]).unwrap()
-    }
-
-    /// Gets the [BlockInfo]
-    pub fn block_info(&mut self) -> BlockInfo {
-        self.io.info()
-    }
-
-    /// Gets the underlying BlockIo implementation.
-    pub fn io(&mut self) -> &mut T {
-        &mut self.io
-    }
-
-    /// Reads data from the block device.
-    ///
-    /// # Args
-    ///
-    /// * `offset`: Offset in number of bytes.
-    /// * `out`: Buffer to store the read data.
-    /// * Returns success when exactly `out.len()` number of bytes are read.
-    pub async fn read(
-        &mut self,
-        offset: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()> {
-        read_async(&mut self.io, offset, out, &mut self.scratch).await
-    }
-
-    /// Writes data to the device.
-    ///
-    /// # Args
-    ///
-    /// * `offset`: Offset in number of bytes.
-    /// * `data`: Data to write.
-    ///
-    /// # Returns
-    ///
-    /// * Returns success when exactly `data.len()` number of bytes are written.
-    pub async fn write(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
-        write_async(&mut self.io, offset, data, &mut self.scratch).await
-    }
-
-    /// Fills a disk range with the given byte value
-    ///
-    /// # Args
-    ///
-    /// * `offset`: Offset in number of bytes.
-    /// * `size`: Number of bytes to fill.
-    /// * `val`: Fill value.
-    /// * `scratch`: A scratch buffer that will be used for writing `val` in batches.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Err(Error::InvalidInput) if size of `scratch` is 0.
-    pub async fn fill(
-        &mut self,
-        mut offset: u64,
-        size: u64,
-        val: u8,
-        scratch: &mut [u8],
-    ) -> Result<()> {
-        if scratch.is_empty() {
-            return Err(Error::InvalidInput);
-        }
-        let blk_sz = usize::try_from(self.block_info().block_size)?;
-        // Optimizes by trying to get an aligned and multi-block-size buffer.
-        let buf = match aligned_subslice(scratch, self.block_info().alignment) {
-            Ok(v) => match v.len() / blk_sz {
-                b if b > 0 => &mut v[..b * blk_sz],
-                _ => v,
-            },
-            _ => scratch,
-        };
-        let sz = min(size, buf.len().try_into()?);
-        buf[..usize::try_from(sz).unwrap()].fill(val);
-        let end: u64 = (SafeNum::from(offset) + size).try_into()?;
-        while offset < end {
-            let to_write = min(sz, end - offset);
-            self.write(offset, &mut buf[..usize::try_from(to_write).unwrap()]).await?;
-            offset += to_write;
-        }
-        Ok(())
-    }
-
-    /// Loads and syncs GPT from a block device.
-    ///
-    /// The API validates and restores primary/secondary GPT header.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok(sync_result) if disk IO is successful, where `sync_result` contains the GPT
-    ///   verification and restoration result.
-    /// * Returns Err() if disk IO encounters errors.
-    pub async fn sync_gpt(
-        &mut self,
-        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
-    ) -> Result<GptSyncResult> {
-        gpt.load_and_sync(self).await
-    }
-
-    /// Updates GPT to the block device and sync primary and secondary GPT.
-    ///
-    /// # Args
-    ///
-    /// * `mbr_primary`: A buffer containing the MBR block, primary GPT header and entries.
-    /// * `resize`: If set to true, the method updates the last partition to cover the rest of the
-    ///    storage.
-    /// * `gpt`: The GPT to update.
-    ///
-    /// # Returns
-    ///
-    /// * Return `Ok(())` if new GPT is valid and device is updated and synced successfully.
-    pub async fn update_gpt(
-        &mut self,
-        mbr_primary: &mut [u8],
-        resize: bool,
-        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
-    ) -> Result<()> {
-        gpt::update_gpt(self, mbr_primary, resize, gpt).await
-    }
-
-    /// Erases GPT if the disk has one.
-    ///
-    /// The method will first perform a GPT sync and makes sure that all valid entries are wiped.
-    ///
-    /// # Args
-    ///
-    /// * `gpt`: An instance of GPT.
-    pub async fn erase_gpt(&mut self, gpt: &mut Gpt<impl DerefMut<Target = [u8]>>) -> Result<()> {
-        gpt::erase_gpt(self, gpt).await
-    }
-
-    /// Reads a GPT partition on a block device
-    ///
-    /// # Args
-    ///
-    /// * `gpt`: A `GptCache` initialized with `Self::sync_gpt()`.
-    /// * `part_name`: Name of the partition.
-    /// * `offset`: Offset in number of bytes into the partition.
-    /// * `out`: Buffer to store the read data.
-    ///
-    /// # Returns
-    ///
-    /// Returns success when exactly `out.len()` of bytes are read successfully.
-    pub async fn read_gpt_partition(
-        &mut self,
-        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
-        part_name: &str,
-        offset: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<()> {
-        let offset = gpt.check_range(part_name, offset, out.len())?;
-        self.read(offset, out).await
-    }
-
-    /// Writes a GPT partition on a block device.
-    ///
-    ///
-    /// # Args
-    ///
-    /// * `gpt`: A `GptCache` initialized with `Self::sync_gpt()`.
-    /// * `part_name`: Name of the partition.
-    /// * `offset`: Offset in number of bytes into the partition.
-    /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
-    ///
-    /// # Returns
-    ///
-    /// Returns success when exactly `data.len()` of bytes are written successfully.
-    pub async fn write_gpt_partition(
-        &mut self,
-        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
-        part_name: &str,
-        offset: u64,
-        data: &mut [u8],
-    ) -> Result<()> {
-        let offset = gpt.check_range(part_name, offset, data.len())?;
-        self.write(offset, data).await
-    }
-}
-
-impl<'a, T: BlockIo> Disk<RefMut<'a, T>, RefMut<'a, [u8]>> {
-    /// Converts a `RefMut<Disk<T, S>>` to `Disk<RefMut<T>, RefMut<[u8]>>`. The scratch buffer
-    /// generic type is eliminated in the return.
-    pub fn from_ref_mut(val: RefMut<'a, Disk<T, impl DerefMut<Target = [u8]>>>) -> Self {
-        let (io, scratch) = RefMut::map_split(val, |v| (&mut v.io, &mut v.scratch[..]));
-        Disk::new(io, scratch).unwrap()
-    }
-}
-
-impl<T, S> Disk<RamBlockIo<T>, S>
-where
-    T: DerefMut<Target = [u8]>,
-    S: DerefMut<Target = [u8]> + Extend<u8> + Default,
-{
-    /// Creates a new ram disk instance with allocated scratch buffer.
-    pub fn new_ram_alloc(block_size: u64, alignment: u64, storage: T) -> Result<Self> {
-        let ram_blk = RamBlockIo::new(block_size, alignment, storage);
-        Self::new_alloc_scratch(ram_blk)
-    }
-}
-
-/// Helper trait to implement common logic working with MaybeUninit slices.
-/// Implemented for [u8] and [MaybeUninit<u8>].
-///
-/// Read functions treats buffer as not initialized using this trait.
-// AsRef,AsMut implementation added here. Since it is not possible to implement trait from other
-// crate for trait in this trait. It is possible to implement other trait for `dyn` object of local
-// trait. But it introduces other issues with lifetime and casting boilerplate.
-//
-// Alternatively we considered using wrapper type, which works but requires `into()` call either on
-// function call. Or inside functions if they accept `impl Into<Wrapper>`.
-// Using traits seems to be cleaner and potentially more effective.
-pub trait SliceMaybeUninit {
-    /// Get `&[MaybeUninit<u8>]` representation
-    fn as_ref(&self) -> &[MaybeUninit<u8>];
-
-    // AsMut implementation
-    /// Get `&mut [MaybeUninit<u8>]` representation
-    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>];
-
-    /// Get slice length
-    fn len(&self) -> usize {
-        self.as_ref().len()
-    }
-
-    /// Returns reference to element or subslice, or Error if index is out of bounds
-    fn get<I>(&mut self, index: I) -> Result<&<I>::Output>
-    where
-        I: SliceIndex<[MaybeUninit<u8>]>,
-    {
-        self.as_ref().get(index).ok_or(Error::BufferTooSmall(None))
-    }
-
-    /// Returns mutable reference to element or subslice, or Error if index is out of bounds
-    fn get_mut<I>(&mut self, index: I) -> Result<&mut <I>::Output>
-    where
-        I: SliceIndex<[MaybeUninit<u8>]>,
-    {
-        self.as_mut().get_mut(index).ok_or(Error::BufferTooSmall(None))
-    }
-
-    /// Clone from slice
-    fn clone_from_slice(&mut self, src: &[u8]) {
-        self.as_mut().clone_from_slice(as_uninit(src))
-    }
-}
-
-impl SliceMaybeUninit for [u8] {
-    fn as_ref(&self) -> &[MaybeUninit<u8>] {
-        as_uninit(self)
-    }
-    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
-        as_uninit_mut(self)
-    }
-}
-
-impl SliceMaybeUninit for [MaybeUninit<u8>] {
-    fn as_ref(&self) -> &[MaybeUninit<u8>] {
-        self
-    }
-    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
-        self
-    }
-}
-
-/// Present initialized `&mut [u8]` buffer as `&mut [MaybeUninit<u8>]`
-pub fn as_uninit_mut(buf: &mut [u8]) -> &mut [MaybeUninit<u8>] {
-    // SAFETY:
-    // MaybeUninit<u8> has same size and alignment as u8.
-    // `data` is valid pointer to initialised u8 slice of size `buf.len()`
-    unsafe { core::slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut MaybeUninit<u8>, buf.len()) }
-}
-
-/// Present initialized `&mut [u8]` buffer as `&mut [MaybeUninit<u8>]`
-pub fn as_uninit(buf: &[u8]) -> &[MaybeUninit<u8>] {
-    // SAFETY:
-    // MaybeUninit<u8> has same size and alignment as u8.
-    // `data` is valid pointer to initialised u8 slice of size `buf.len()`
-    unsafe { core::slice::from_raw_parts(buf.as_ptr() as *const MaybeUninit<u8>, buf.len()) }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use gbl_async::block_on;
-    use safemath::SafeNum;
-
-    #[derive(Debug)]
-    struct TestCase {
-        rw_offset: u64,
-        rw_size: u64,
-        misalignment: u64,
-        alignment: u64,
-        block_size: u64,
-        storage_size: u64,
-    }
-
-    impl TestCase {
-        fn new(
-            rw_offset: u64,
-            rw_size: u64,
-            misalignment: u64,
-            alignment: u64,
-            block_size: u64,
-            storage_size: u64,
-        ) -> Self {
-            Self { rw_offset, rw_size, misalignment, alignment, block_size, storage_size }
-        }
-    }
-
-    // Helper object for allocating aligned buffer.
-    struct AlignedBuffer {
-        buffer: Vec<u8>,
-        alignment: u64,
-        size: u64,
-    }
-
-    impl AlignedBuffer {
-        pub fn new(alignment: u64, size: u64) -> Self {
-            let aligned_size = (SafeNum::from(size) + alignment).try_into().unwrap();
-            let buffer = vec![0u8; aligned_size];
-            Self { buffer, alignment, size }
-        }
-
-        pub fn get(&mut self) -> &mut [u8] {
-            let addr = SafeNum::from(self.buffer.as_ptr() as usize);
-            let aligned_start = addr.round_up(self.alignment) - addr;
-            &mut self.buffer
-                [aligned_start.try_into().unwrap()..(aligned_start + self.size).try_into().unwrap()]
-        }
-    }
-
-    /// Upper bound on the number of `read_blocks_async()/write_blocks_async()` calls by
-    /// `AsBlockDevice::read()` and `AsBlockDevice::write()`.
-    ///
-    /// * `fn read_aligned_all()`: At most 1 call to `read_blocks_async()`.
-    /// * `fn read_aligned_offset_and_buffer()`: At most 2 calls to `read_aligned_all()`.
-    /// * `fn read_aligned_buffer()`: At most 1 call to `read_aligned_offset_and_buffer()` plus 1
-    ///   call to `read_blocks_async()`.
-    /// * `fn read_async()`: At most 2 calls to `read_aligned_buffer()`.
-    ///
-    /// Analysis is similar for `fn write_async()`.
-    const READ_WRITE_BLOCKS_UPPER_BOUND: usize = 6;
-
-    // Type alias of the [Disk] type used by unittests.
-    pub(crate) type TestDisk = Disk<RamBlockIo<Vec<u8>>, Vec<u8>>;
-
-    fn read_test_helper(case: &TestCase) {
-        let data = (0..case.storage_size).map(|v| v as u8).collect::<Vec<_>>();
-        let mut disk = TestDisk::new_ram_alloc(case.alignment, case.block_size, data).unwrap();
-        // Make an aligned buffer. A misaligned version is created by taking a sub slice that
-        // starts at an unaligned offset. Because of this we need to allocate
-        // `case.misalignment` more to accommodate it.
-        let mut aligned_buf = AlignedBuffer::new(case.alignment, case.rw_size + case.misalignment);
-        let misalignment = usize::try_from(case.misalignment).unwrap();
-        let rw_sz = usize::try_from(case.rw_size).unwrap();
-        let out = &mut aligned_buf.get()[misalignment..][..rw_sz];
-        block_on(disk.read(case.rw_offset, out)).unwrap();
-        let rw_off = usize::try_from(case.rw_offset).unwrap();
-        assert_eq!(out, &disk.io().storage()[rw_off..][..rw_sz], "Failed. Test case {:?}", case);
-        assert!(disk.io().num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
-    }
-
-    fn write_test_helper(
-        case: &TestCase,
-        mut write_func: impl FnMut(&mut TestDisk, u64, &mut [u8]),
-    ) {
-        let data = (0..case.storage_size).map(|v| v as u8).collect::<Vec<_>>();
-        // Write a reverse version of the current data.
-        let rw_off = usize::try_from(case.rw_offset).unwrap();
-        let rw_sz = usize::try_from(case.rw_size).unwrap();
-        let mut expected = data[rw_off..][..rw_sz].to_vec();
-        expected.reverse();
-        let mut disk = TestDisk::new_ram_alloc(case.alignment, case.block_size, data).unwrap();
-        // Make an aligned buffer. A misaligned version is created by taking a sub slice that
-        // starts at an unaligned offset. Because of this we need to allocate
-        // `case.misalignment` more to accommodate it.
-        let mut aligned_buf = AlignedBuffer::new(case.alignment, case.rw_size + case.misalignment);
-        let misalignment = usize::try_from(case.misalignment).unwrap();
-        let data = &mut aligned_buf.get()[misalignment..][..rw_sz];
-        data.clone_from_slice(&expected);
-        write_func(&mut disk, case.rw_offset, data);
-        let written = &disk.io().storage()[rw_off..][..rw_sz];
-        assert_eq!(expected, written, "Failed. Test case {:?}", case);
-        // Check that input is not modified.
-        assert_eq!(expected, data, "Input is modified. Test case {:?}", case,);
-    }
-
-    macro_rules! read_write_test {
-        ($name:ident, $x0:expr, $x1:expr, $x2:expr, $x3:expr, $x4:expr, $x5:expr) => {
-            mod $name {
-                use super::*;
-
-                #[test]
-                fn read_test() {
-                    read_test_helper(&TestCase::new($x0, $x1, $x2, $x3, $x4, $x5));
-                }
-
-                #[test]
-                fn read_scaled_test() {
-                    // Scaled all parameters by double and test again.
-                    let (x0, x1, x2, x3, x4, x5) =
-                        (2 * $x0, 2 * $x1, 2 * $x2, 2 * $x3, 2 * $x4, 2 * $x5);
-                    read_test_helper(&TestCase::new(x0, x1, x2, x3, x4, x5));
-                }
-
-                // Input bytes slice is a mutable reference
-                #[test]
-                fn write_mut_test() {
-                    write_test_helper(
-                        &TestCase::new($x0, $x1, $x2, $x3, $x4, $x5),
-                        |blk, offset, data| {
-                            block_on(blk.write(offset, data)).unwrap();
-                            assert!(blk.io().num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                            assert!(blk.io().num_writes <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                        },
-                    );
-                }
-
-                #[test]
-                fn write_mut_scaled_test() {
-                    // Scaled all parameters by double and test again.
-                    let (x0, x1, x2, x3, x4, x5) =
-                        (2 * $x0, 2 * $x1, 2 * $x2, 2 * $x3, 2 * $x4, 2 * $x5);
-                    write_test_helper(
-                        &TestCase::new(x0, x1, x2, x3, x4, x5),
-                        |blk, offset, data| {
-                            block_on(blk.write(offset, data)).unwrap();
-                            assert!(blk.io().num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                            assert!(blk.io().num_writes <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                        },
-                    );
-                }
-            }
-        };
-    }
-
-    const BLOCK_SIZE: u64 = 512;
-    const ALIGNMENT: u64 = 64;
-    const STORAGE: u64 = BLOCK_SIZE * 32;
-
-    // Test cases for different scenarios of read/write windows w.r.t buffer/block alignmnet
-    // boundary.
-    // offset
-    //   |~~~~~~~~~~~~~size~~~~~~~~~~~~|
-    //   |---------|---------|---------|
-    read_write_test! {aligned_all, 0, STORAGE, 0, ALIGNMENT, BLOCK_SIZE, STORAGE
-    }
-
-    // offset
-    //   |~~~~~~~~~size~~~~~~~~~|
-    //   |---------|---------|---------|
-    read_write_test! {
-        aligned_offset_uanligned_size, 0, STORAGE - 1, 0, ALIGNMENT, BLOCK_SIZE, STORAGE
-    }
-    // offset
-    //   |~~size~~|
-    //   |---------|---------|---------|
-    read_write_test! {
-        aligned_offset_intra_block, 0, BLOCK_SIZE - 1, 0, ALIGNMENT, BLOCK_SIZE, STORAGE
-    }
-    //     offset
-    //       |~~~~~~~~~~~size~~~~~~~~~~|
-    //   |---------|---------|---------|
-    read_write_test! {
-        unaligned_offset_aligned_end, 1, STORAGE - 1, 0, ALIGNMENT, BLOCK_SIZE, STORAGE
-    }
-    //     offset
-    //       |~~~~~~~~~size~~~~~~~~|
-    //   |---------|---------|---------|
-    read_write_test! {unaligned_offset_len, 1, STORAGE - 2, 0, ALIGNMENT, BLOCK_SIZE, STORAGE
-    }
-    //     offset
-    //       |~~~size~~~|
-    //   |---------|---------|---------|
-    read_write_test! {
-        unaligned_offset_len_partial_cross_block, 1, BLOCK_SIZE, 0, ALIGNMENT, BLOCK_SIZE, STORAGE
-    }
-    //   offset
-    //     |~size~|
-    //   |---------|---------|---------|
-    read_write_test! {
-        ualigned_offset_len_partial_intra_block,
-        1,
-        BLOCK_SIZE - 2,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-
-    // Same sets of test cases but with an additional block added to `rw_offset`
-    read_write_test! {
-        aligned_all_extra_offset,
-        BLOCK_SIZE,
-        STORAGE,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-    read_write_test! {
-        aligned_offset_uanligned_size_extra_offset,
-        BLOCK_SIZE,
-        STORAGE - 1,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-    read_write_test! {
-        aligned_offset_intra_block_extra_offset,
-        BLOCK_SIZE,
-        BLOCK_SIZE - 1,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-    read_write_test! {
-        unaligned_offset_aligned_end_extra_offset,
-        BLOCK_SIZE + 1,
-        STORAGE - 1,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-    read_write_test! {
-        unaligned_offset_len_extra_offset,
-        BLOCK_SIZE + 1,
-        STORAGE - 2,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-    read_write_test! {
-        unaligned_offset_len_partial_cross_block_extra_offset,
-        BLOCK_SIZE + 1,
-        BLOCK_SIZE,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-    read_write_test! {
-        ualigned_offset_len_partial_intra_block_extra_offset,
-        BLOCK_SIZE + 1,
-        BLOCK_SIZE - 2,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE + BLOCK_SIZE
-    }
-
-    // Same sets of test cases but with unaligned output buffer {'misALIGNMENT` != 0}
-    read_write_test! {
-        aligned_all_unaligned_buffer,
-        0,
-        STORAGE,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        aligned_offset_uanligned_size_unaligned_buffer,
-        0,
-        STORAGE - 1,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        aligned_offset_intra_block_unaligned_buffer,
-        0,
-        BLOCK_SIZE - 1,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        unaligned_offset_aligned_end_unaligned_buffer,
-        1,
-        STORAGE - 1,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        unaligned_offset_len_unaligned_buffer,
-        1,
-        STORAGE - 2,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        unaligned_offset_len_partial_cross_block_unaligned_buffer,
-        1,
-        BLOCK_SIZE,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        ualigned_offset_len_partial_intra_block_unaligned_buffer,
-        1,
-        BLOCK_SIZE - 2,
-        1,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-
-    // Special cases where `rw_offset` is not block aligned but buffer aligned. This can
-    // trigger some internal optimization code path.
-    read_write_test! {
-        buffer_aligned_offset_and_len,
-        ALIGNMENT,
-        STORAGE - ALIGNMENT,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        buffer_aligned_offset,
-        ALIGNMENT,
-        STORAGE - ALIGNMENT - 1,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        buffer_aligned_offset_aligned_end,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-    read_write_test! {
-        buffer_aligned_offset_intra_block,
-        ALIGNMENT,
-        BLOCK_SIZE - ALIGNMENT - 1,
-        0,
-        ALIGNMENT,
-        BLOCK_SIZE,
-        STORAGE
-    }
-
-    #[test]
-    fn test_no_alignment_require_zero_size_scratch() {
-        let mut io = RamBlockIo::new(1, 1, vec![]);
-        assert_eq!(scratch_size(&mut io).unwrap(), 0);
-    }
-
-    #[test]
-    fn test_scratch_too_small() {
-        let mut io = RamBlockIo::new(512, 512, vec![]);
-        let scratch = vec![0u8; scratch_size(&mut io).unwrap() - 1];
-        assert!(TestDisk::new(io, scratch).is_err());
-    }
-
-    #[test]
-    fn test_read_overflow() {
-        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
-        assert!(block_on(disk.read(512, &mut vec![0u8; 1][..])).is_err());
-        assert!(block_on(disk.read(0, &mut vec![0u8; 513][..])).is_err());
-    }
-
-    #[test]
-    fn test_read_arithmetic_overflow() {
-        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
-        assert!(block_on(disk.read(u64::MAX, &mut vec![0u8; 1][..])).is_err());
-    }
-
-    #[test]
-    fn test_write_overflow() {
-        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
-        assert!(block_on(disk.write(512, &mut vec![0u8; 1])).is_err());
-        assert!(block_on(disk.write(0, &mut vec![0u8; 513])).is_err());
-    }
-
-    #[test]
-    fn test_write_arithmetic_overflow() {
-        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
-        assert!(block_on(disk.write(u64::MAX, &mut vec![0u8; 1])).is_err());
-    }
-}
diff --git a/gbl/libstorage/src/ram_block.rs b/gbl/libstorage/src/ram_block.rs
deleted file mode 100644
index 21e0a15..0000000
--- a/gbl/libstorage/src/ram_block.rs
+++ /dev/null
@@ -1,97 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides an implementation of [BlockIo] backed by RAM.
-
-use crate::{is_aligned, is_buffer_aligned, BlockInfo, BlockIo, SliceMaybeUninit};
-use core::ops::DerefMut;
-use gbl_async::yield_now;
-use liberror::Error;
-use safemath::SafeNum;
-
-/// `RamBlockIo` implements [BlockIo] backed by user provided buffer.
-pub struct RamBlockIo<T> {
-    /// The storage block size in bytes.
-    pub block_size: u64,
-    /// The storage access alignment in bytes.
-    pub alignment: u64,
-    /// The backing storage data.
-    pub storage: T,
-    /// The number of successful write calls.
-    pub num_writes: usize,
-    /// The number of successful read calls.
-    pub num_reads: usize,
-    /// Injected error to be returned by the next read/write IO.
-    pub error: Option<Error>,
-}
-
-impl<T: DerefMut<Target = [u8]>> RamBlockIo<T> {
-    /// Creates an new instance.
-    pub fn new(block_size: u64, alignment: u64, storage: T) -> Self {
-        assert_eq!(
-            storage.len() % usize::try_from(block_size).unwrap(),
-            0,
-            "storage size is not multiple of block size, {}, {}",
-            storage.len(),
-            block_size
-        );
-        Self { block_size, alignment, storage, num_writes: 0, num_reads: 0, error: None }
-    }
-
-    /// Gets the underlying ramdisk storage.
-    pub fn storage(&mut self) -> &mut [u8] {
-        &mut self.storage[..]
-    }
-
-    /// Checks injected error, simulates async waiting, checks read/write parameters and returns the
-    /// offset in number of bytes.
-    async fn checks(
-        &mut self,
-        blk_offset: u64,
-        buf: &(impl SliceMaybeUninit + ?Sized),
-    ) -> Result<usize, Error> {
-        assert!(is_buffer_aligned(buf.as_ref(), self.alignment).unwrap_or(false));
-        assert!(is_aligned(buf.len(), self.block_size).unwrap_or(false));
-        yield_now().await;
-        self.error.take().map(|e| Err(e)).unwrap_or(Ok(()))?;
-        Ok((SafeNum::from(blk_offset) * self.block_size).try_into().unwrap())
-    }
-}
-
-// SAFETY:
-// `read_blocks` clones `out.len()` bytes to output which initializes all elements in `out`
-unsafe impl<T: DerefMut<Target = [u8]>> BlockIo for RamBlockIo<T> {
-    fn info(&mut self) -> BlockInfo {
-        BlockInfo {
-            block_size: self.block_size,
-            num_blocks: u64::try_from(self.storage.len()).unwrap() / self.block_size,
-            alignment: self.alignment,
-        }
-    }
-
-    async fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut (impl SliceMaybeUninit + ?Sized),
-    ) -> Result<(), Error> {
-        let offset = self.checks(blk_offset, out).await?;
-        let out_len = out.len();
-        Ok(out.clone_from_slice(&self.storage[offset..][..out_len]))
-    }
-
-    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), Error> {
-        let offset = self.checks(blk_offset, &mut *data).await?;
-        Ok(self.storage[offset..][..data.len()].clone_from_slice(data))
-    }
-}
diff --git a/gbl/libstorage/test/BUILD b/gbl/libstorage/test/BUILD
deleted file mode 100644
index 9a74579..0000000
--- a/gbl/libstorage/test/BUILD
+++ /dev/null
@@ -1,31 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-filegroup(
-    name = "test_data",
-    srcs = [
-        ":boot_a.bin",
-        ":boot_b.bin",
-        ":gpt_test_1.bin",
-        ":gpt_test_2.bin",
-        ":vendor_boot_a.bin",
-        ":vendor_boot_b.bin",
-    ],
-)
diff --git a/gbl/libstorage/test/boot_a.bin b/gbl/libstorage/test/boot_a.bin
deleted file mode 100644
index 7220a5c..0000000
Binary files a/gbl/libstorage/test/boot_a.bin and /dev/null differ
diff --git a/gbl/libstorage/test/boot_b.bin b/gbl/libstorage/test/boot_b.bin
deleted file mode 100644
index d3cb44d..0000000
Binary files a/gbl/libstorage/test/boot_b.bin and /dev/null differ
diff --git a/gbl/libstorage/test/gen_gpt_test_bin.sh b/gbl/libstorage/test/gen_gpt_test_bin.sh
deleted file mode 100755
index bf9fe5c..0000000
--- a/gbl/libstorage/test/gen_gpt_test_bin.sh
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/bin/bash
-#
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-set -e
-
-readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
-
-BOOT_A_NAME="boot_a"
-BOOT_A_SIZE_KB="8"
-BOOT_A_PART_FILE="${SCRIPT_DIR}/${BOOT_A_NAME}.bin"
-
-BOOT_B_NAME="boot_b"
-BOOT_B_SIZE_KB="12"
-BOOT_B_PART_FILE="${SCRIPT_DIR}/${BOOT_B_NAME}.bin"
-
-dd if=/dev/urandom bs=1024 count=${BOOT_A_SIZE_KB} > ${BOOT_A_PART_FILE}
-dd if=/dev/urandom bs=1024 count=${BOOT_B_SIZE_KB} > ${BOOT_B_PART_FILE}
-
-python3 ${SCRIPT_DIR}/../../tools/gen_gpt_disk.py ${SCRIPT_DIR}/gpt_test_1.bin 64K \
-    --partition "${BOOT_A_NAME},${BOOT_A_SIZE_KB}k,${BOOT_A_PART_FILE}" \
-    --partition "${BOOT_B_NAME},${BOOT_B_SIZE_KB}k,${BOOT_B_PART_FILE}"
-
-
-VENDOR_BOOT_A_NAME="vendor_boot_a"
-VENDOR_BOOT_A_SIZE_KB="4"
-VENDOR_BOOT_A_PART_FILE="${SCRIPT_DIR}/${VENDOR_BOOT_A_NAME}.bin"
-
-VENDOR_BOOT_B_NAME="vendor_boot_b"
-VENDOR_BOOT_B_SIZE_KB="6"
-VENDOR_BOOT_B_PART_FILE="${SCRIPT_DIR}/${VENDOR_BOOT_B_NAME}.bin"
-
-dd if=/dev/urandom bs=1024 count=${VENDOR_BOOT_A_SIZE_KB} > ${VENDOR_BOOT_A_PART_FILE}
-dd if=/dev/urandom bs=1024 count=${VENDOR_BOOT_B_SIZE_KB} > ${VENDOR_BOOT_B_PART_FILE}
-
-python3 ${SCRIPT_DIR}/../../tools/gen_gpt_disk.py ${SCRIPT_DIR}/gpt_test_2.bin 128K \
-    --partition "${VENDOR_BOOT_A_NAME},${VENDOR_BOOT_A_SIZE_KB}k,${VENDOR_BOOT_A_PART_FILE}" \
-    --partition "${VENDOR_BOOT_B_NAME},${VENDOR_BOOT_B_SIZE_KB}k,${VENDOR_BOOT_B_PART_FILE}"
diff --git a/gbl/libstorage/test/gpt_test_1.bin b/gbl/libstorage/test/gpt_test_1.bin
deleted file mode 100644
index a0a7742..0000000
Binary files a/gbl/libstorage/test/gpt_test_1.bin and /dev/null differ
diff --git a/gbl/libstorage/test/gpt_test_2.bin b/gbl/libstorage/test/gpt_test_2.bin
deleted file mode 100644
index c124562..0000000
Binary files a/gbl/libstorage/test/gpt_test_2.bin and /dev/null differ
diff --git a/gbl/libstorage/test/vendor_boot_a.bin b/gbl/libstorage/test/vendor_boot_a.bin
deleted file mode 100644
index a0fdf7d..0000000
Binary files a/gbl/libstorage/test/vendor_boot_a.bin and /dev/null differ
diff --git a/gbl/libstorage/test/vendor_boot_b.bin b/gbl/libstorage/test/vendor_boot_b.bin
deleted file mode 100644
index 5acdaaa..0000000
Binary files a/gbl/libstorage/test/vendor_boot_b.bin and /dev/null differ
diff --git a/gbl/libutils/BUILD b/gbl/libutils/BUILD
deleted file mode 100644
index 7ab96ee..0000000
--- a/gbl/libutils/BUILD
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-rust_library(
-    name = "libutils",
-    srcs = [
-        "src/lib.rs",
-    ],
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-    deps = [
-        "@gbl//liberror",
-        "@gbl//libsafemath",
-    ],
-)
-
-rust_test(
-    name = "test",
-    crate = ":libutils",
-    rustc_flags = ANDROID_RUST_LINTS,
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/libutils/src/lib.rs b/gbl/libutils/src/lib.rs
deleted file mode 100644
index f0a7fca..0000000
--- a/gbl/libutils/src/lib.rs
+++ /dev/null
@@ -1,200 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Low-level utilities shared across multiple GBL libraries.
-
-#![cfg_attr(not(test), no_std)]
-
-use core::{cmp::min, str::from_utf8};
-use liberror::{Error, Result};
-use safemath::SafeNum;
-
-/// Returns the largest aligned subslice.
-///
-/// This function drops as many bytes as needed from the front of the given slice to ensure the
-/// result is properly-aligned. It does not truncate bytes from the end, so the resulting size may
-/// not be a multiple of `alignment`.
-///
-/// If the next `alignment` boundary would be directly following the last byte, this returns the
-/// 0-length slice at that alignment rather than an error, to match standard slicing behavior.
-///
-/// # Arguments
-/// * `bytes`: the byte slice to align
-/// * `alignment`: the desired starting alignment
-///
-/// # Returns
-/// * The subslice on success
-/// * [Error::ArithmeticOverflow] if `bytes` overflows when finding the next `alignment`
-/// * [Error::BufferTooSmall] if `bytes` is not large enough to reach the next `alignment`. The
-///   error will contain the size that would have been needed to reach `alignment`.
-pub fn aligned_subslice<T>(bytes: &mut [u8], alignment: T) -> Result<&mut [u8]>
-where
-    T: Copy + Into<SafeNum>,
-{
-    let addr = bytes.as_ptr() as usize;
-    let aligned_offset = (SafeNum::from(addr).round_up(alignment) - addr).try_into()?;
-    Ok(bytes.get_mut(aligned_offset..).ok_or(Error::BufferTooSmall(Some(aligned_offset)))?)
-}
-
-/// A helper for getting the offset of the first byte with and aligned address.
-///
-/// # Arguments
-/// * `bytes`: the byte slice
-/// * `alignment`: the desired starting alignment.
-///
-/// # Returns
-///
-/// * Returns Ok(offset) on success, Err() on integer overflow.
-pub fn aligned_offset<T>(buffer: &[u8], alignment: T) -> Result<usize>
-where
-    T: Copy + Into<SafeNum>,
-{
-    let addr = SafeNum::from(buffer.as_ptr() as usize);
-    (addr.round_up(alignment) - addr).try_into().map_err(From::from)
-}
-
-/// A helper data structure for writing formatted string to fixed size bytes array.
-#[derive(Debug)]
-pub struct FormattedBytes<T>(T, usize);
-
-impl<T: AsMut<[u8]> + AsRef<[u8]>> FormattedBytes<T> {
-    /// Create an instance.
-    pub fn new(buf: T) -> Self {
-        Self(buf, 0)
-    }
-
-    /// Get the size of content.
-    pub fn size(&self) -> usize {
-        self.1
-    }
-
-    /// Appends the given `bytes` to the contents.
-    ///
-    /// If `bytes` exceeds the remaining buffer space, any excess bytes are discarded.
-    ///
-    /// Returns the resulting contents.
-    pub fn append(&mut self, bytes: &[u8]) -> &mut [u8] {
-        let buf = &mut self.0.as_mut()[self.1..];
-        // Only write as much as the size of the bytes buffer. Additional write is silently
-        // ignored.
-        let to_write = min(buf.len(), bytes.len());
-        buf[..to_write].clone_from_slice(&bytes[..to_write]);
-        self.1 += to_write;
-        &mut self.0.as_mut()[..self.1]
-    }
-
-    /// Converts to string.
-    pub fn to_str(&self) -> &str {
-        from_utf8(&self.0.as_ref()[..self.1]).unwrap_or("")
-    }
-}
-
-impl<T: AsMut<[u8]> + AsRef<[u8]>> core::fmt::Write for FormattedBytes<T> {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        self.append(s.as_bytes());
-        Ok(())
-    }
-}
-
-/// A convenient macro that behaves similar to snprintf in C.
-///
-/// Panics if the written string is not UTF-8.
-#[macro_export]
-macro_rules! snprintf {
-    ( $arr:expr, $( $x:expr ),* ) => {
-        {
-            let mut bytes = $crate::FormattedBytes::new(&mut $arr[..]);
-            core::fmt::Write::write_fmt(&mut bytes, core::format_args!($($x,)*)).unwrap();
-            let size = bytes.size();
-            core::str::from_utf8(&$arr[..size]).unwrap()
-        }
-    };
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    // A byte array that's always at least 8-byte aligned for testing.
-    #[repr(align(8))]
-    struct AlignedBytes<const N: usize>([u8; N]);
-
-    #[test]
-    fn aligned_subslice_already_aligned() {
-        let mut bytes = AlignedBytes([0u8; 16]);
-        let bytes = &mut bytes.0;
-
-        // AlignedBytes is `align(8)`, so must be 1/2/4/8-aligned.
-        assert_eq!(aligned_subslice(bytes, 1).unwrap().as_ptr_range(), bytes.as_ptr_range());
-        assert_eq!(aligned_subslice(bytes, 2).unwrap().as_ptr_range(), bytes.as_ptr_range());
-        assert_eq!(aligned_subslice(bytes, 4).unwrap().as_ptr_range(), bytes.as_ptr_range());
-        assert_eq!(aligned_subslice(bytes, 8).unwrap().as_ptr_range(), bytes.as_ptr_range());
-    }
-
-    #[test]
-    fn aligned_subslice_unaligned() {
-        let mut bytes = AlignedBytes([0u8; 16]);
-        let bytes = &mut bytes.0;
-
-        // AlignedBytes is 8-aligned, so offsetting by <8 should snap to the next 8-alignment.
-        assert_eq!(
-            aligned_subslice(&mut bytes[1..], 8).unwrap().as_ptr_range(),
-            bytes[8..].as_ptr_range()
-        );
-        assert_eq!(
-            aligned_subslice(&mut bytes[4..], 8).unwrap().as_ptr_range(),
-            bytes[8..].as_ptr_range()
-        );
-        assert_eq!(
-            aligned_subslice(&mut bytes[7..], 8).unwrap().as_ptr_range(),
-            bytes[8..].as_ptr_range()
-        );
-    }
-
-    #[test]
-    fn aligned_subslice_empty_slice() {
-        let mut bytes = AlignedBytes([0u8; 16]);
-        let bytes = &mut bytes.0;
-
-        // If the next alignment is just past the input, return the empty slice.
-        assert_eq!(
-            aligned_subslice(&mut bytes[9..], 8).unwrap().as_ptr_range(),
-            bytes[16..].as_ptr_range()
-        );
-    }
-
-    #[test]
-    fn aligned_subslice_buffer_overflow() {
-        let mut bytes = AlignedBytes([0u8; 7]); // 7 bytes; can't reach the next 8-alignment.
-        let bytes = &mut bytes.0;
-
-        assert_eq!(aligned_subslice(&mut bytes[1..], 8), Err(Error::BufferTooSmall(Some(7))));
-        assert_eq!(aligned_subslice(&mut bytes[6..], 8), Err(Error::BufferTooSmall(Some(2))));
-    }
-
-    #[test]
-    fn aligned_subslice_alignment_overflow() {
-        let mut bytes = AlignedBytes([0u8; 16]);
-        let bytes = &mut bytes.0;
-
-        assert!(matches!(aligned_subslice(bytes, SafeNum::MAX), Err(Error::ArithmeticOverflow(_))));
-    }
-
-    #[test]
-    fn test_formatted_bytes() {
-        let mut bytes = [0u8; 4];
-        assert_eq!(snprintf!(bytes, "abcde"), "abcd");
-        assert_eq!(&bytes, b"abcd");
-    }
-}
diff --git a/gbl/readme.bzl b/gbl/readme.bzl
deleted file mode 100644
index 515a2ee..0000000
--- a/gbl/readme.bzl
+++ /dev/null
@@ -1,122 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""
-Action that verifies all EFI protocols used by GBL are explicitly listed in README.md
-"""
-
-load("@rules_rust//rust/private:providers.bzl", "CrateInfo")
-
-def _readme_test_rule_impl(ctx):
-    shell_script = """
-while [[ $# -gt 0 ]]; do
-  case $1 in
-    --in)
-      INPUT=$2
-      shift
-      shift
-      ;;
-    --out)
-      OUTPUT=$2
-      shift
-      shift
-      ;;
-    --readme)
-      README=$2
-      shift
-      shift
-      ;;
-    *)
-      echo "Unexpected argument: $1"
-      exit 1
-      ;;
-  esac
-done
-
-if [ ! -f $README ]; then
-  echo "README file doesn't exist: ${README}"
-  exit 1
-fi
-
-ALL_INPUTS=$(echo ${INPUT} | sed 's/,/ /g')
-
-# Look for protocols in the source code that do not exist in the documentation.
-# The protocol name we match on here is the Rust struct name.
-DOCLESS_PROTOCOLS=""
-PROTOCOLS=($(grep -hE 'impl ProtocolInfo for .* \\{' ${ALL_INPUTS} | awk '{print $4}' | sort))
-for P in ${PROTOCOLS[@]}
-do
-  grep -Lq $P ${README} || DOCLESS_PROTOCOLS+="\n\t$P"
-done
-
-if [ ! -z "${DOCLESS_PROTOCOLS}" ]; then
-  echo -e "Missing documentation for protocol(s):$DOCLESS_PROTOCOLS"
-  exit 1
-fi
-
-# Look for protocols in the documentation that are not in the source, to try to
-# prevent stale docs referring to protocols we are no longer using.
-# Here we're matching on words ending in "Protocol", except "Protocol" itself.
-UNUSED_PROTOCOLS=""
-README_PROTOCOLS=($(grep -P " ?[^ ]+Protocol$" ${README} | awk '{print $NF}' | sort | uniq))
-for P in ${README_PROTOCOLS[@]}
-do
-  grep -qhE "impl ProtocolInfo for $P" ${ALL_INPUTS} || UNUSED_PROTOCOLS+="\n\t$P"
-done
-
-if [ ! -z "${UNUSED_PROTOCOLS}" ]; then
-  echo -e "Unused protocol(s) found in documentation:$UNUSED_PROTOCOLS"
-  exit 1
-fi
-
-touch $OUTPUT
-"""
-
-    out_file = ctx.actions.declare_file("%s.script" % ctx.attr.name)
-    in_files = [s for d in ctx.attr.deps for s in d[CrateInfo].srcs.to_list()]
-    readme = ctx.attr.readme
-    args = ctx.actions.args()
-    args.add_joined(
-        "--in",
-        in_files,
-        join_with = ",",
-    )
-    args.add(
-        "--out",
-        out_file,
-    )
-    args.add(
-        "--readme",
-        readme[DefaultInfo].files.to_list()[0],
-    )
-    ctx.actions.run_shell(
-        inputs = in_files + readme[DefaultInfo].files.to_list(),
-        outputs = [out_file],
-        arguments = [args],
-        command = shell_script,
-    )
-    return [DefaultInfo(executable = out_file)]
-
-readme_test = rule(
-    implementation = _readme_test_rule_impl,
-    attrs = {
-        "deps": attr.label_list(
-            providers = [CrateInfo],
-        ),
-        "readme": attr.label(
-            allow_single_file = [".md"],
-        ),
-    },
-    test = True,
-)
diff --git a/gbl/rewrite_rust_project_path.py b/gbl/rewrite_rust_project_path.py
deleted file mode 100644
index 7513175..0000000
--- a/gbl/rewrite_rust_project_path.py
+++ /dev/null
@@ -1,72 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import json
-import os
-import logging
-import tempfile
-import shutil
-
-# To generate rust-project.json from bazel, run
-# bazel run @rules_rust//tools/rust_analyzer:gen_rust_project --norepository_disable_download @gbl//efi:main
-# However, this yields incorrect source path.
-# Your source file
-# /usr/local/google/home/zhangkelvin/uefi-gbl-mainline/bootable/libbootloader/gbl/efi/src/main.rs
-# would turn into
-# /usr/local/google/home/uefi-gbl-mainline/out/bazel/output_user_root/e14d642d361d598c63507c64a56ecbc7/execroot/_main/external/gbl/efi/src/main.rs
-# and this confuses the rust-analyzer. This script will resolve the right
-# source path for you by checking if any of the parent path is a symlink,
-# and resolve all symlinks to final destination.
-
-
-def traverse(obj: dict):
-  if isinstance(obj, dict):
-    for (key, val) in obj.items():
-      if key == "root_module" or key == "CARGO_MANIFEST_DIR":
-        obj[key] = os.path.realpath(val)
-        continue
-      elif key == "include_dirs" or key == "exclude_dirs":
-        obj[key] = [os.path.realpath(d) for d in val]
-        continue
-      elif key == "cfg" and isinstance(val, list):
-        obj[key] = [o for o in val if o != "test"]
-        continue
-      traverse(val)
-  elif isinstance(obj, list):
-    for item in obj:
-      traverse(item)
-
-
-def main(argv):
-  logging.basicConfig(level=logging.INFO)
-  rust_project_json_path = "rust-project.json"
-  if len(argv) == 2:
-    rust_project_json_path = argv[1]
-  rust_project_json_path = os.path.realpath(rust_project_json_path)
-  project_root_path = os.path.dirname(rust_project_json_path)
-  logging.info("Using %s as project root path", project_root_path)
-  with open(rust_project_json_path, "r") as fp:
-    data = json.load(fp)
-    traverse(data)
-
-  with tempfile.NamedTemporaryFile("w+", delete=False) as fp:
-    json.dump(data, fp.file, indent=True)
-    tmp_path = fp.name
-  shutil.move(tmp_path, rust_project_json_path)
-
-
-if __name__ == "__main__":
-  import sys
-
-  main(sys.argv)
diff --git a/gbl/rustfmt.toml b/gbl/rustfmt.toml
deleted file mode 100644
index cefaa42..0000000
--- a/gbl/rustfmt.toml
+++ /dev/null
@@ -1,5 +0,0 @@
-# Android Format Style
-
-edition = "2021"
-use_small_heuristics = "Max"
-newline_style = "Unix"
diff --git a/gbl/signtool/Android.bp b/gbl/signtool/Android.bp
new file mode 100644
index 0000000..fc638f4
--- /dev/null
+++ b/gbl/signtool/Android.bp
@@ -0,0 +1,38 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_android_kernel",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+python_binary_host {
+    name: "gblsigntool",
+    srcs: ["gblsigntool.py"],
+    libs: ["libavbtool"],
+}
+
+python_test_host {
+    name: "gblsigntool_test",
+    srcs: ["gblsigntool_test.py"],
+    data: [
+        ":gblsigntool_testdata",
+        ":gblsigntool",
+    ],
+}
+
+filegroup {
+    name: "gblsigntool_testdata",
+    srcs: ["testdata/**/*"],
+}
diff --git a/gbl/signtool/BUILD b/gbl/signtool/BUILD
new file mode 100644
index 0000000..debb970
--- /dev/null
+++ b/gbl/signtool/BUILD
@@ -0,0 +1,60 @@
+# Copyright (C) 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+load("@rules_pkg//pkg:mappings.bzl", "pkg_attributes", "pkg_files")
+load("@rules_python//python:defs.bzl", "py_binary", "py_test")
+
+py_binary(
+    name = "gblsigntool_py",
+    srcs = ["gblsigntool.py"],
+    main = "gblsigntool.py",
+    visibility = ["@gbl//efi:__subpackages__"],
+    deps = ["@avb//:libavbtool"],
+)
+
+filegroup(
+    name = "gblsigntool_zip",
+    srcs = [":gblsigntool_py"],
+    output_group = "python_zip_file",
+)
+
+genrule(
+    name = "gblsigntool_executable",
+    srcs = [":gblsigntool_zip"],
+    outs = ["gblsigntool"],
+    cmd = """
+cat -<<PRELUDE $(SRCS) > $(OUTS)
+#!/usr/bin/env python3
+PRELUDE
+    """,
+    executable = True,
+    visibility = ["//visibility:public"],
+)
+
+py_test(
+    name = "gblsigntool_test",
+    srcs = ["gblsigntool_test.py"],
+    data = [
+        ":gblsigntool_executable",
+        "//signtool/testdata",
+    ],
+    visibility = ["//visibility:public"],
+)
+
+pkg_files(
+    name = "gblsigntool_dist_files",
+    srcs = [":gblsigntool_executable"],
+    attributes = pkg_attributes(mode = "0755"),
+    visibility = ["//efi:__pkg__"],
+)
diff --git a/gbl/signtool/README.md b/gbl/signtool/README.md
new file mode 100644
index 0000000..792f0f5
--- /dev/null
+++ b/gbl/signtool/README.md
@@ -0,0 +1,3 @@
+GBL Signtool
+
+Commandline tool for signing GBL (Android bootloader) images.
diff --git a/gbl/signtool/gblsigntool.py b/gbl/signtool/gblsigntool.py
new file mode 100644
index 0000000..8ace5c5
--- /dev/null
+++ b/gbl/signtool/gblsigntool.py
@@ -0,0 +1,442 @@
+#!/usr/bin/env python3
+#
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+"""Signs GBL images."""
+
+from argparse import ArgumentParser
+import glob
+import hashlib
+import os
+import shlex
+import shutil
+import struct
+import tempfile
+
+from avbtool import (AvbFooter, AvbTool)
+
+
+# Source of truth is winnt.h
+IMAGE_DOS_SIGNATURE = 0x5A4D
+
+IMAGE_NT_SIGNATURE = 0x4550
+IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x010B
+IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x020B
+
+SIZEOF_IMAGE_DOS_HEADER = 64
+SIZEOF_IMAGE_PE_HEADER = 24
+
+OFFSET_E_LFANEW = 0x3C
+
+OFFSET_PE_NUMBER_OF_SECTIONS = 6
+OFFSET_PE_SIZE_OF_OPTIONAL_HEADER = 20
+
+OFFSET_OPTIONAL_HDR_SIZE_OF_HEADERS = 60
+OFFSET_OPTIONAL_HDR_CHECKSUM = 64
+OFFSET_OPTIONAL_HDR32_NUMBER_OF_RVA_AND_SIZES = 92
+OFFSET_OPTIONAL_HDR32_DATA_DIRECTORY = 96
+OFFSET_OPTIONAL_HDR64_NUMBER_OF_RVA_AND_SIZES = 108
+OFFSET_OPTIONAL_HDR64_DATA_DIRECTORY = 112
+
+OFFSET_SECTION_HEADER_SIZE_OF_RAW_DATA = 16
+OFFSET_SECTION_HEADER_POINTER_TO_RAW_DATA = 20
+
+CERTIFICATE_TABLE_IDX = 4
+
+
+def unpack_word(buf, off):
+  """Unpacks a little-endian 2-byte word."""
+  return struct.unpack_from('<H', buf, off)[0]
+
+
+def unpack_int(buf, off):
+  """Unpacks a little-endian 4-byte int."""
+  return struct.unpack_from('<I', buf, off)[0]
+
+
+class PEError(ValueError):
+  """PE file parsing related errors."""
+
+
+class DOSHeader:
+  """Helper class for DOS header."""
+
+  def __init__(self, buf):
+    self._buf = buf
+
+    if len(self._buf) < SIZEOF_IMAGE_DOS_HEADER:
+      raise PEError('Image size is too small for a DOS header')
+
+    magic = unpack_word(self._buf, 0)
+    if magic != IMAGE_DOS_SIGNATURE:
+      raise PEError(f'Unexpected DOS magic: 0x{magic:04X}')
+
+  def e_lfanew(self):
+    return unpack_word(self._buf, OFFSET_E_LFANEW)
+
+
+class PEHeader:
+  """Helper class for PE header."""
+
+  def __init__(self, buf):
+    self._buf = buf
+
+    if len(self._buf) < SIZEOF_IMAGE_PE_HEADER:
+      raise PEError('Image size is too small for a PE header')
+
+    magic = unpack_int(self._buf, 0)
+    if magic != IMAGE_NT_SIGNATURE:
+      raise PEError(f'Unexpected PE magic: 0x{magic:08X}')
+
+  def size_of_optional_header(self):
+    return unpack_word(self._buf, OFFSET_PE_SIZE_OF_OPTIONAL_HEADER)
+
+  def number_of_sections(self):
+    return unpack_word(self._buf, OFFSET_PE_NUMBER_OF_SECTIONS)
+
+
+class OptionalHeader:
+  """Helper class for PE32/PE32+ Optional header."""
+
+  def __init__(self, buf):
+    self._buf = buf
+
+    magic = unpack_word(self._buf, 0)
+    if magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC:
+      self._pe_plus = False
+    elif magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC:
+      self._pe_plus = True
+    else:
+      raise PEError(f'Unexpected PE Optional header magic: 0x{magic:04X}')
+
+  def number_of_data_entries(self):
+    if self._pe_plus:
+      offset = OFFSET_OPTIONAL_HDR64_NUMBER_OF_RVA_AND_SIZES
+    else:
+      offset = OFFSET_OPTIONAL_HDR32_NUMBER_OF_RVA_AND_SIZES
+    return unpack_int(self._buf, offset)
+
+  def data_entry_offset(self, idx):
+    if self._pe_plus:
+      return OFFSET_OPTIONAL_HDR64_DATA_DIRECTORY + idx * 8
+    else:
+      return OFFSET_OPTIONAL_HDR32_DATA_DIRECTORY + idx * 8
+
+  def data_entry(self, idx):
+    return struct.unpack_from('<II', self._buf, self.data_entry_offset(idx))
+
+  def size_of_headers(self):
+    return unpack_int(self._buf, OFFSET_OPTIONAL_HDR_SIZE_OF_HEADERS)
+
+
+class PEImage:
+  """PE file parser."""
+
+  def __init__(self, buf):
+    self._buf = bytearray(buf)
+
+    self._dos_header = DOSHeader(self._buf)
+    self._pe_header_offset = self._dos_header.e_lfanew()
+    self._optional_header_offset = (
+        self._pe_header_offset + SIZEOF_IMAGE_PE_HEADER
+    )
+    self._pe_header = PEHeader(self._buf[self._pe_header_offset :])
+    self._checksum_offset = (
+        self._optional_header_offset + OFFSET_OPTIONAL_HDR_CHECKSUM
+    )
+    self._section_headers_offset = (
+        self._optional_header_offset + self._pe_header.size_of_optional_header()
+    )
+    self._optional_header = OptionalHeader(
+        self._buf[self._optional_header_offset :]
+    )
+    if self._optional_header.number_of_data_entries() < 5:
+      raise PEError('PE Optional header data directories table is too small')
+
+  def erase_existing_win_certificates(self):
+    offset, size = self._optional_header.data_entry(CERTIFICATE_TABLE_IDX)
+    certificate_table_offset = (
+        self._optional_header_offset
+        + self._optional_header.data_entry_offset(CERTIFICATE_TABLE_IDX)
+    )
+    self._buf[certificate_table_offset : certificate_table_offset + 8] = (
+        8 * b'\x00'
+    )
+    if offset or size:
+      if offset > len(self._buf):
+        print('WARNING: certificate table offset is past EOF')
+        return
+      if offset + size != len(self._buf):
+        print('WARNING: removed junk data after the certificate table')
+      self._buf = self._buf[:offset]
+      print('Erased existing SecureBoot certificates')
+
+  def erase_checksum(self):
+    self._buf[self._checksum_offset : self._checksum_offset + 4] = 4 * b'\x00'
+
+  def get_avb_footer(self):
+    if len(self._buf) >= AvbFooter.SIZE:
+      try:
+        return AvbFooter(self._buf[-AvbFooter.SIZE :])
+      except (LookupError, struct.error):
+        pass
+    return None
+
+  def authenticode_digest(self):
+    data_directory_certificate_table_offset = (
+        self._optional_header_offset
+        + self._optional_header.data_entry_offset(CERTIFICATE_TABLE_IDX)
+    )
+    data_directory_certificate_table_end = (
+        self._optional_header_offset
+        + self._optional_header.data_entry_offset(CERTIFICATE_TABLE_IDX + 1)
+    )
+    regions = [
+        (0, self._checksum_offset),
+        (self._checksum_offset + 4, data_directory_certificate_table_offset),
+        (
+            data_directory_certificate_table_end,
+            self._optional_header.size_of_headers(),
+        ),
+    ]
+    for idx in range(self._pe_header.number_of_sections()):
+      off = self._section_headers_offset + idx * 40
+      size = unpack_int(self._buf, off + OFFSET_SECTION_HEADER_SIZE_OF_RAW_DATA)
+      data = unpack_int(
+          self._buf, off + OFFSET_SECTION_HEADER_POINTER_TO_RAW_DATA
+      )
+      regions.append((data, data + size))
+    regions.sort(key=lambda e: e[0])
+
+    # End junk
+    regions.append((regions[-1][1], len(self._buf)))
+
+    hasher = hashlib.sha256()
+    for begin, end in regions:
+      hasher.update(self._buf[begin:end])
+    return hasher.hexdigest()
+
+
+def gbl_info(args):
+  """Shows info about a GBL image."""
+  with open(args.gbl_image, 'rb') as gbl:
+    gbl_bytes = gbl.read()
+  gbl_image = PEImage(gbl_bytes)
+  gbl_image.erase_existing_win_certificates()
+  gbl_image.erase_checksum()
+  print('Authenticode digest (sha256):', gbl_image.authenticode_digest())
+
+  avb_footer = gbl_image.get_avb_footer()
+  if not avb_footer:
+    raise ValueError('No AVB footer found, image is unsigned')
+
+  with tempfile.TemporaryDirectory() as temp_dir:
+    gbl_efi = os.path.join(temp_dir, 'gbl.efi')
+    with open(gbl_efi, 'wb') as f:
+      f.write(gbl_image._buf)
+    gbl_image._buf = gbl_image._buf[: avb_footer.original_image_size]
+    print(
+        'Authenticode digest (without AVB footer):',
+        gbl_image.authenticode_digest(),
+    )
+    print('====VBMETA====')
+    AvbTool().run(['avbtool', 'info_image', '--image', gbl_efi])
+
+
+def gbl_sign_one(gbl_image, output, avbtool_args):
+  """Signs one GBL image."""
+  with open(gbl_image, 'rb') as gbl:
+    gbl_bytes = gbl.read()
+  gbl_image = PEImage(gbl_bytes)
+  gbl_image.erase_existing_win_certificates()
+  gbl_image.erase_checksum()
+  avb_footer = gbl_image.get_avb_footer()
+  if avb_footer:
+    gbl_image._buf = gbl_image._buf[: avb_footer.original_image_size]
+    print('Erased existing AVB footer')
+  digest = gbl_image.authenticode_digest()
+
+  with tempfile.TemporaryDirectory() as temp_dir:
+    gbl_efi = os.path.join(temp_dir, 'gbl.efi')
+    with open(gbl_efi, 'wb') as f:
+      f.write(gbl_image._buf)
+    avb_cmd = (
+        [
+            'avbtool',
+            'add_hash_footer',
+        ]
+        + avbtool_args
+        + [
+            '--image',
+            gbl_efi,
+            '--partition_name',
+            'gbl',
+            '--dynamic_partition_size',
+            '--prop',
+            f'authenticode:{digest}',
+        ]
+    )
+    print('avbtool command:', ' '.join(avb_cmd))
+    AvbTool().run(avb_cmd)
+    print(f'Authenticode digest (sha256): {digest}')
+    shutil.move(gbl_efi, output)
+    print(f'Signed image written to {output}')
+
+
+def gbl_sign(args):
+  """Signs a GBL image."""
+  gbl_sign_one(args.gbl_image, args.output, args.avbtool_args)
+
+
+def gbl_sign_archive(args):
+  """Signs a GBL image archive."""
+  with tempfile.TemporaryDirectory() as temp_dir:
+    unpack_dir = os.path.join(temp_dir, 'unpack')
+    shutil.unpack_archive(args.image_archive, unpack_dir)
+    signed_dir = os.path.join(temp_dir, 'signed')
+    os.mkdir(signed_dir)
+    for gbl_efi in glob.glob(os.path.join(unpack_dir, 'gbl*.efi')):
+      stem = os.path.basename(gbl_efi)
+      print(f'Found GBL image: {stem}')
+      gbl_sign_one(gbl_efi, os.path.join(signed_dir, stem), args.avbtool_args)
+      print('')
+
+    archive_name = shutil.make_archive(
+        os.path.join(temp_dir, 'signed_zip'), 'zip', signed_dir
+    )
+    shutil.move(archive_name, args.output)
+    print(f'Signed image archive written to {args.output}')
+
+
+def gbl_verify(args):
+  """Verifies a signed GBL image."""
+  with open(args.gbl_image, 'rb') as gbl:
+    gbl_bytes = gbl.read()
+  gbl_image = PEImage(gbl_bytes)
+  gbl_image.erase_existing_win_certificates()
+  gbl_image.erase_checksum()
+
+  with tempfile.TemporaryDirectory() as temp_dir:
+    gbl_efi = os.path.join(temp_dir, 'gbl.efi')
+    with open(gbl_efi, 'wb') as f:
+      f.write(gbl_image._buf)
+    avb_cmd = [
+        'avbtool',
+        'verify_image',
+        '--image',
+        gbl_efi,
+    ]
+    if args.key:
+      avb_cmd += ['--key', args.key]
+    AvbTool().run(avb_cmd)
+
+
+def gbl_remove(args):
+  """Removes signatures."""
+  with open(args.gbl_image, 'rb') as gbl:
+    gbl_bytes = gbl.read()
+  gbl_image = PEImage(gbl_bytes)
+  gbl_image.erase_existing_win_certificates()
+  gbl_image.erase_checksum()
+  avb_footer = gbl_image.get_avb_footer()
+  if avb_footer:
+    gbl_image._buf = gbl_image._buf[: avb_footer.original_image_size]
+    print('Erased existing AVB footer')
+  with open(args.output, 'wb') as f:
+    f.write(gbl_image._buf)
+
+
+def flatten_args(raw_args):
+  """Split and flatten nested args."""
+  args = []
+  for a in raw_args:
+    args.extend(shlex.split(a))
+  return args
+
+
+def main():
+  parser = ArgumentParser()
+  subcommands = parser.add_subparsers(required=True, title='subcommands')
+
+  info_command = subcommands.add_parser(
+      'info', help='show info about a GBL image'
+  )
+  info_command.add_argument(
+      'gbl_image', metavar='GBL_IMAGE', help='GBL EFI image'
+  )
+  info_command.set_defaults(func=gbl_info)
+
+  sign_command = subcommands.add_parser('sign', help='sign a GBL image')
+  sign_command.add_argument(
+      'gbl_image', metavar='GBL_IMAGE', help='GBL EFI image'
+  )
+  sign_command.add_argument(
+      '-o', '--output', required=True, help='output file name'
+  )
+  sign_command.add_argument(
+      '--avbtool_args',
+      default=[],
+      action='append',
+      help='signing args to pass to avbtool (can be specified multiple times)',
+  )
+  sign_command.set_defaults(func=gbl_sign)
+
+  sign_archive_command = subcommands.add_parser(
+      'sign_archive', help='sign a GBL image archive'
+  )
+  sign_archive_command.add_argument(
+      'image_archive', metavar='IMAGE_ARCHIVE', help='zip archive of GBL images'
+  )
+  sign_archive_command.add_argument(
+      '-o', '--output', required=True, help='output archive name'
+  )
+  sign_archive_command.add_argument(
+      '--avbtool_args',
+      default=[],
+      action='append',
+      help='signing args to pass to avbtool (can be specified multiple times)',
+  )
+  sign_archive_command.set_defaults(func=gbl_sign_archive)
+
+  verify_command = subcommands.add_parser(
+      'verify', help='verify a signed GBL image'
+  )
+  verify_command.add_argument(
+      'gbl_image', metavar='GBL_IMAGE', help='GBL EFI image'
+  )
+  verify_command.add_argument('--key', help='check public key')
+  verify_command.set_defaults(func=gbl_verify)
+
+  remove_command = subcommands.add_parser(
+      'remove', help='remove any signatures from a GBL image'
+  )
+  remove_command.add_argument(
+      'gbl_image', metavar='GBL_IMAGE', help='GBL EFI image'
+  )
+  remove_command.add_argument(
+      '-o', '--output', required=True, help='output file name'
+  )
+  remove_command.set_defaults(func=gbl_remove)
+
+  args = parser.parse_args()
+  if 'avbtool_args' in args:
+    args.avbtool_args = flatten_args(args.avbtool_args)
+
+  return args.func(args)
+
+
+if __name__ == '__main__':
+  main()
diff --git a/gbl/signtool/gblsigntool_test.py b/gbl/signtool/gblsigntool_test.py
new file mode 100644
index 0000000..8b00cd7
--- /dev/null
+++ b/gbl/signtool/gblsigntool_test.py
@@ -0,0 +1,148 @@
+#
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+
+from pathlib import Path
+import shutil
+import subprocess
+import sys
+import tempfile
+import unittest
+
+
+def GetResource(*args):
+  return Path(sys.argv[0]).absolute().parent.joinpath(*args)
+
+
+def Gblsigntool(*args):
+  return subprocess.run([GetResource('gblsigntool')] + list(args), check=True)
+
+
+TEST_KEY_PATH = GetResource('testdata', 'testkey_RSA4096.pem')
+TEST_PUBKEY_PATH = GetResource('testdata', 'testkey_RSA4096_pub.pem')
+
+# These are originally testkey-signed by another key, _not_ the above key.
+TEST_EFI_PATH = GetResource('testdata', 'gbl_aarch64_prod.efi')
+TEST_IMG_ZIP_PATH = GetResource('testdata', 'gbl-img-13454081.zip')
+
+
+class GblSigntoolTest(unittest.TestCase):
+
+  def testInfo_success(self):
+    Gblsigntool('info', TEST_EFI_PATH)
+
+  def testInfo_notPEImage_failure(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      regular_file = Path(temp_dir).joinpath('regular_file')
+      with open(regular_file, 'wb') as f:
+        f.write(b'blah' * 1000)
+      with self.assertRaises(subprocess.CalledProcessError):
+        Gblsigntool('info', regular_file)
+
+  def testInfo_unsigned_failure(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      unsigned_efi = Path(temp_dir).joinpath('unsigned.efi')
+      Gblsigntool('remove', TEST_EFI_PATH, '-o', unsigned_efi)
+      with self.assertRaises(subprocess.CalledProcessError):
+        Gblsigntool('info', unsigned_efi)
+
+  def testRemove_idempotent(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      unsigned_efi = Path(temp_dir).joinpath('unsigned.efi')
+      Gblsigntool('remove', TEST_EFI_PATH, '-o', unsigned_efi)
+      unsigned_twice_efi = Path(temp_dir).joinpath('unsigned_twice.efi')
+      Gblsigntool('remove', unsigned_efi, '-o', unsigned_twice_efi)
+      with open(unsigned_efi, 'rb') as f:
+        unsigned_bytes = f.read()
+      with open(unsigned_twice_efi, 'rb') as f:
+        unsigned_twice_bytes = f.read()
+      self.assertEqual(unsigned_bytes, unsigned_twice_bytes)
+
+  def testVerify_success(self):
+    Gblsigntool('verify', TEST_EFI_PATH)
+
+  def testVerify_pubkeyMismatch_failure(self):
+    with self.assertRaises(subprocess.CalledProcessError):
+      Gblsigntool('verify', TEST_EFI_PATH, '--key', TEST_PUBKEY_PATH)
+
+  def testVerify_notPEImage_failure(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      regular_file = Path(temp_dir).joinpath('regular_file')
+      with open(regular_file, 'wb') as f:
+        f.write(b'blah' * 1000)
+      with self.assertRaises(subprocess.CalledProcessError):
+        Gblsigntool('verify', regular_file)
+
+  def testVerify_unsigned_failure(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      unsigned_efi = Path(temp_dir).joinpath('unsigned.efi')
+      Gblsigntool('remove', TEST_EFI_PATH, '-o', unsigned_efi)
+      with self.assertRaises(subprocess.CalledProcessError):
+        Gblsigntool('verify', unsigned_efi)
+
+  def testSign_success(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      unsigned_efi = Path(temp_dir).joinpath('unsigned.efi')
+      Gblsigntool('remove', TEST_EFI_PATH, '-o', unsigned_efi)
+      signed_efi = Path(temp_dir).joinpath('signed.efi')
+      Gblsigntool(
+          'sign',
+          unsigned_efi,
+          '-o',
+          signed_efi,
+          '--avbtool_args',
+          f'--key "{TEST_KEY_PATH}" --algorithm SHA256_RSA4096',
+      )
+      Gblsigntool('verify', signed_efi, '--key', TEST_PUBKEY_PATH)
+
+  def testSign_resign_success(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      signed_efi = Path(temp_dir).joinpath('signed.efi')
+      Gblsigntool(
+          'sign',
+          TEST_EFI_PATH,
+          '-o',
+          signed_efi,
+          '--avbtool_args',
+          f'--key "{TEST_KEY_PATH}" --algorithm SHA256_RSA4096',
+      )
+      Gblsigntool('verify', signed_efi, '--key', TEST_PUBKEY_PATH)
+
+  def testSignArchive_success(self):
+    with tempfile.TemporaryDirectory() as temp_dir:
+      unpack_dir = Path(temp_dir).joinpath('unpack')
+      shutil.unpack_archive(TEST_IMG_ZIP_PATH, unpack_dir)
+      for efi in unpack_dir.glob('gbl*.efi'):
+        with self.assertRaises(subprocess.CalledProcessError):
+          Gblsigntool('verify', efi, '--key', TEST_PUBKEY_PATH)
+
+      signed_zip = Path(temp_dir).joinpath('signed.zip')
+      Gblsigntool(
+          'sign_archive',
+          TEST_IMG_ZIP_PATH,
+          '-o',
+          signed_zip,
+          '--avbtool_args',
+          f'--key "{TEST_KEY_PATH}" --algorithm SHA256_RSA4096',
+      )
+      unpack_signed_dir = Path(temp_dir).joinpath('unpack_signed')
+      shutil.unpack_archive(signed_zip, unpack_signed_dir)
+      for signed_efi in unpack_signed_dir.glob('gbl*.efi'):
+        Gblsigntool('verify', signed_efi, '--key', TEST_PUBKEY_PATH)
+
+
+if __name__ == '__main__':
+  unittest.main(verbosity=2)
diff --git a/gbl/libfdt/test/data/BUILD b/gbl/signtool/testdata/BUILD
similarity index 78%
rename from gbl/libfdt/test/data/BUILD
rename to gbl/signtool/testdata/BUILD
index 8012128..b9f8d38 100644
--- a/gbl/libfdt/test/data/BUILD
+++ b/gbl/signtool/testdata/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2024 The Android Open Source Project
+# Copyright (C) 2025 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -13,7 +13,7 @@
 # limitations under the License.
 
 filegroup(
-    name = "all",
-    srcs = glob(["**/*"]),
-    visibility = ["//visibility:public"],
+    name = "testdata",
+    srcs = glob(["**"]),
+    visibility = ["//signtool:__subpackages__"],
 )
diff --git a/gbl/signtool/testdata/gbl-img-13454081.zip b/gbl/signtool/testdata/gbl-img-13454081.zip
new file mode 100644
index 0000000..bdf5c2f
Binary files /dev/null and b/gbl/signtool/testdata/gbl-img-13454081.zip differ
diff --git a/gbl/signtool/testdata/gbl_aarch64_prod.efi b/gbl/signtool/testdata/gbl_aarch64_prod.efi
new file mode 100755
index 0000000..0943578
Binary files /dev/null and b/gbl/signtool/testdata/gbl_aarch64_prod.efi differ
diff --git a/gbl/signtool/testdata/testkey_RSA4096.pem b/gbl/signtool/testdata/testkey_RSA4096.pem
new file mode 100644
index 0000000..6d298d7
--- /dev/null
+++ b/gbl/signtool/testdata/testkey_RSA4096.pem
@@ -0,0 +1,51 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKQIBAAKCAgEAr4YJrivbilzwqQYeWQaTjE3utA8/PLC6MmGs4tlG904eB1QH
+X5B/9Cki8d5Hs3AbNu2L8ceqmMCzNyflyTDz74NaTIuOqgiej0rXQJN39wlfM3pZ
+i1gyaY+mxG1FVjWjMhCedzbDH5tFRdlIea+cHaqwOaG2Wp0sBsKyNr6A8G82LtX/
+XwZD07MiqN4/XPYkmI0vzj2l13p3pnKC1poh9FaAK7fNKjhhqZDksMQxbASG/puL
+iTNn1/B4f0u+6l8EO2yplRmnbifiYfmfHSCCWWzSdEofUrxisr0FvJdEqcwh2Qg8
+z2zWwKFvCZXwLQLw1rRH2iSV/Ztm3l+TqnUWfAyNl/BvlaL4lMqxjx97dmxQVd9h
+ILJ2UlZin1DkrWS3NlRJI8M6aQl9lGlWsE0CVI8Oa36U+6s3XoWQGhV9wWK/ZWva
+jlQ0qRm/EU3JPgsSYX+t/GkIEwOXh+Ms0DTIu1h9z9fWHJYVtmHkfdggG1JKgut9
+cUMnOYvAyh4xj+tJMQ3TCQ/+ynGJSpv7zvZ3JkoaebDni/qS2p6CGX4okaHkdZTt
+suHwJolkgyxrrbzuc6RMprWFFs8NGuVTXWCmU9Q9MNDilpDPY5TXrqT2XCx+ezpN
+Ihd08iSNMUxJ+lOFSz+JVNB5CPCIiTtooL+eYCKmWeptpoHxRcu2U/56aiUCAwEA
+AQKCAgALPyArKhG+354nAmaa5zY4kPzIykpPwfYoSMRqY6gtq/J2Hz76s1hThXhA
+/bBj8by4rAdhxlyqvXwuPk71sX6L3AOC8JVDVVqNjWrV7y0KZe4U7xPCPzQ5udPi
+darx721lxZVVx6tAgPMzGs1PSL6M0xVIGBHGZBhAVaTUJ6g8369d2GXsyYq6i5me
+ruDp/LaTFMbZpO8Vq7nzbxZtmEIxNQKw6m3JtQOi+Q8COYv+IxsgQMiz0ZiniDe8
+VlblDxIHGbsS++oTv5f8laFJnT3k63lfrKktpLcBQ2XU8+9ZHuSTUrkMxGlNPfrO
+py4UwEG8zB/nfR0kOxsgCAk+7JI0ZPDODmjiyxh1Zb4UKc0B/8qxcZ/iFUaE0+nB
+l+n3cdlySb35XKvipB4V9QAqyGnber5Onc/R7I0sZiWy2F86kh9o9AxLi/iVkenA
+E8AzNtpevXPx3BHlfk4XPLYkazTogAdD5WFIzm1yzju3V1ISV3Qhtp+7h9qbkOkR
+NyBfNLQt0GV97UdHwM00PPyOr2V0wr87lW27C1+Eg1sXH7T/VGnK+bokbbooNef0
+YswQwnjpLKPDNDnaBtOi3cEcZp0NNxv6kubpEyYMQKVfCSiSoheIB8UC9CxRl936
+8Fzpvdgq4ipnJEG+gWeQDP2TYKtY3JCBKxJZo1qMU6n42BuR2QKCAQEA2GO/jUME
+YuM4vNcXYA3JPj5/K2hG9DyWV3QrgRXQNBbXFGmfShgwO1464/nta7J6nxRaiC7F
+TaSjLbAg+j1JfW29bdxVhfwJgnm0jLqh6baYwS4vjJ56HFEiFdEg/v9jbfN7GzW/
+mruKhR9skqJS08xzDesRAl9KcFtePbnJlzve1YaRmW4V7wWb7zs87oDhJPzmSkOf
+XIaoey68Ml1eIfbDTySYslRprwPawg8JH1FeJXnTKfd1vLX87yLYHByi2JYyQQ3G
+uKkqQibaSzo8VjDYosyafpbPTRWefVmw/EDRart7VHSppSOOMS6QgBSCqfMZ6wLi
+h+iKUPYOpa7ISQKCAQEAz6dDGxLEfbeZN+9K3vOErp0/T9XQg0CpooGKhoLlrNC1
+IqAQSJeC68w4w16iQoZIZY637wLncPA07iDO1uCEAYvPf7kVciS3ZbAzd3kF/WKT
+bWQ9s/5UG/zjfXFRhM4xUKckCJdEsLe4cqWLgCSw0tY0ZbyNmr01mD2mgv2ZbJys
+2jqdfNzBPwPyVRl5konC2qY4U8StroTo+Xu5LhjliHyCdgAU58Xtlt2s/NQ/3x+c
+1K3M+h85e/MA61rN7Bkp4Oxf6YZDG2ZJfzeESeiEsNi3IiFGtKpkfN8GU/wXfNtc
+gLvJIvTq1JKo+urVod+zE7E1ckk1LE1dsJgI3c6q/QKCAQEAiq9rbkr8fbBphcZJ
+KfvL9gOyF4zupMxMAuLmmwXy+d+Fm4SSXbeg+fvLvJ9LBlJOerRdzZhERh31o2uV
+xywOdMAnv0iO25+MLL559BQNf6/SuUUznmlXk9x//wGYpzXhcO+y/95z3eTCw80/
+Fb/JXAtV1h7JOP7/w4Ebpm3zgOUTTUDBAlfm4Nl0dmA+DhI1ujIIGqK6eV+ojcKH
+RbRHh3cS+B9ZajnlvhC3XNasHxFUSKqKpwP9xqPQ5ycq4OGNkUi6Dq2YpnNtLRaf
+o8VANHF79uMxRV68oAfyGx6n6xRT45cjVR6sN7XRBT51yFDc6bVv8ApaS4bDV15M
+Ru39WQKCAQAdfte0V8UbSmH0JQRQiOyW1PUyRN+6VQwDbj0cACnZk0e3ZF8LwKGz
+Fq4VajLIGkTcUBpmU9ZGH4iVLonS0c9OXOqbbNHUBc0bH50f4kvsgv0H884j7ANM
+em5h2h/HKnasyyD+K2ZxZ5dGiac4C34mZJDKxq6ihS/AsTkesCED4XlYAi1ul/jH
+F6trVRQEsZbA8g1cMLqu6GgjT+Ss3JJ2AaGSW06c4WtvG4u/2fI8okPnncxY1uiW
+Z50A0UQgvi5JqamyBQUxNiVIcb1Ttjhq2k2hBnMBpJZjelZuxYcckBginQnj8kAM
+88wW4BZ6SMkqCejak/V+lnqxY9cWko2NAoIBAQCcsZQsU3pAZOICzAYSswXmbR3Q
+WgZFlZ/COLScGGUbK723S6aki7gKD7Cn93avFtgj4bfd3hf+b95MJK6cj7Vm7hif
+o/IrUWKg2dHvpknE20qREGlCxs9KZP82RbzZTRkqv2WUd5cIgcAxs3qL345fb/FZ
+jwzX65GlRsntp2c//6vxIwvsjG/hL2IL1Oe4Y0EkJ9rPRYZk7jUOZhI68gsfNy1z
+9FYT6gVM3FoUAtxuY43ZuC+EWf/W5zsjSgyo8cIFJSFAw6XzKusIu9FAvYXsDwG/
+/Mr30qPxb6JP9vMzm+a1Rs49clCfg4NsJ+ZK32Rs8E4Mu1aV8AHPXytssV3K
+-----END RSA PRIVATE KEY-----
diff --git a/gbl/signtool/testdata/testkey_RSA4096_pub.pem b/gbl/signtool/testdata/testkey_RSA4096_pub.pem
new file mode 100644
index 0000000..7a49b01
--- /dev/null
+++ b/gbl/signtool/testdata/testkey_RSA4096_pub.pem
@@ -0,0 +1,13 @@
+-----BEGIN RSA PUBLIC KEY-----
+MIICCgKCAgEAr4YJrivbilzwqQYeWQaTjE3utA8/PLC6MmGs4tlG904eB1QHX5B/
+9Cki8d5Hs3AbNu2L8ceqmMCzNyflyTDz74NaTIuOqgiej0rXQJN39wlfM3pZi1gy
+aY+mxG1FVjWjMhCedzbDH5tFRdlIea+cHaqwOaG2Wp0sBsKyNr6A8G82LtX/XwZD
+07MiqN4/XPYkmI0vzj2l13p3pnKC1poh9FaAK7fNKjhhqZDksMQxbASG/puLiTNn
+1/B4f0u+6l8EO2yplRmnbifiYfmfHSCCWWzSdEofUrxisr0FvJdEqcwh2Qg8z2zW
+wKFvCZXwLQLw1rRH2iSV/Ztm3l+TqnUWfAyNl/BvlaL4lMqxjx97dmxQVd9hILJ2
+UlZin1DkrWS3NlRJI8M6aQl9lGlWsE0CVI8Oa36U+6s3XoWQGhV9wWK/ZWvajlQ0
+qRm/EU3JPgsSYX+t/GkIEwOXh+Ms0DTIu1h9z9fWHJYVtmHkfdggG1JKgut9cUMn
+OYvAyh4xj+tJMQ3TCQ/+ynGJSpv7zvZ3JkoaebDni/qS2p6CGX4okaHkdZTtsuHw
+Jolkgyxrrbzuc6RMprWFFs8NGuVTXWCmU9Q9MNDilpDPY5TXrqT2XCx+ezpNIhd0
+8iSNMUxJ+lOFSz+JVNB5CPCIiTtooL+eYCKmWeptpoHxRcu2U/56aiUCAwEAAQ==
+-----END RSA PUBLIC KEY-----
diff --git a/gbl/libgbl/testdata/BUILD b/gbl/signtool/testkeys/BUILD
similarity index 70%
rename from gbl/libgbl/testdata/BUILD
rename to gbl/signtool/testkeys/BUILD
index b8ead03..401b964 100644
--- a/gbl/libgbl/testdata/BUILD
+++ b/gbl/signtool/testkeys/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2024 The Android Open Source Project
+# Copyright (C) 2025 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,13 +12,14 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-exports_files(glob(["**/*"]))
+filegroup(
+    name = "testkey_RSA4096",
+    srcs = ["testkey_RSA4096.pem"],
+    visibility = ["//visibility:public"],
+)
 
 filegroup(
-    name = "testdata",
-    srcs = glob(
-        ["**/*"],
-        exclude = [":gen_test_data.py"],
-    ),
+    name = "testkey_RSA4096_pub",
+    srcs = ["testkey_RSA4096_pub.pem"],
     visibility = ["//visibility:public"],
 )
diff --git a/gbl/signtool/testkeys/testkey_RSA4096.pem b/gbl/signtool/testkeys/testkey_RSA4096.pem
new file mode 100644
index 0000000..cefc588
--- /dev/null
+++ b/gbl/signtool/testkeys/testkey_RSA4096.pem
@@ -0,0 +1,51 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKAIBAAKCAgEAts4B72trxidFOHDRD8UlzCeb386o1inufajBL6gDdEGTBDMv
+gbm5K8iZxGXyiIqCLSPjfnoMzOY54kUS0A7sVbSRvEPD/y9iBC5cUhirs/q7JQBd
+3ElTkSgbKN+MPV4BdVoWZxuPFdOipUlSdu1zQ2LE/O5i/fBcvUzk8KQdJqIBmfVF
+yhGY/vbbGAMdwg+yXAKZpSFZW3SZW7ZJotfTCaCD6v/PN3MmZBcaEHpZUVutNyxj
+9HgwpmDwU6qM5xcw7YKtTLbZOP57dYGmHixOxtHv/XCVYHPPBjr/dKjw0bp6nFSi
+Ok2QvuaSsMMYaS2PDXkLSPGeed0Ose8XjR+skDT7lnqMuzm84OA30y4ApIm8RL0d
+brDFIpiqPXrnjzuYkmEju7aceYA/ZVnFHJiSD/in8LVnxgLOG1abWksu2zrceLUH
+3z35EujvZHR5pnwfUMO9TtAojw738fq9OCtsfTIog85LLeuHbwPjOAYMgfKo23o9
+vD1TZuzCyDEpjIZCVC07PWm58Q9jPxVoE+N+dyN89dp3CjZ81Zaxk3W0LljCWB+C
+aPBmF9X4c0biuFiWaCLDm7FXOIcebw4OPHWpWNxNEPo5cRQPKYhq3RcKouqRDPFs
+dMzzvJTtqfAFlkAiDcveaCgcRTuTkO0WSFzAsOPEDLyw4/gu9s3ggcqYt6ECAwEA
+AQKCAgADYibuDyJG9WJSHgCY6BqSjPuKb1cdBCM0sTv2ntImC6I98EMsGtjeV7uU
+riOd7aIvoFJ73GR6YiA5WQiPquK1SnbYTyuHGzHB6gMAdry4/ij1XCHwmOJBOCF1
+DqVS29z0bA+o4RfjT41bCG3xyIQtr7aS8nKo+IL56AzUdqAkFKNpkw0OL/L8Setn
+u3kzIV0zwmKk6EFWHc91FOe831MJzS47NNipV2zIaqxLWJKzbJpFOzb0JFRCWb4s
+TpZmKaM+C8vbSlwqbQeHUa2Lu/Y/DC2NlqZAIKfuNEc26eXPpuyRfPLwoppX9dk/
+vej+BjH9AzPqFHqXuYeAfqBZptfSc9dZOrhlZvdscUj1DPywYbXQ6xgxEpml8FA3
+8BGBVs2//ArYEuUqe7EAmU/n8MisOTv4Z1NPsZDTxrJPjFz8FYIi7i1SGU62S6in
+AvsMAK389yKQQUj3vPEnMZ4xqyT3kkAFTL3m46LjIjMe0u4xfmGHwDwj9eQa5wD1
+j4eZynSHgOExBDOA7nS935meCOR1BcyTKUuF7AfJbgzsLsw3don59KN5fyKnMuDZ
+zHZk/gyCrX6EdU0qcp4f3tUqrBHjuEUQMCPgUHarPbM2y27AnsMA1DO8yvemRsh8
+PEU06tJXQ8mrM0+vyuloYzelxGMQiLCBa1In+iio3LXLy/oWkQKCAQEA6s+64ioy
+mh3FTdFtf2Pg4GbGGnpOqCvORDnr8k2eIT5se1DHG1XtclAbttSIRQ0tjqfc9oP0
+/FAM+qosih1wit6h9yLF2BakdrZ3QuSholbQV5tFzdxSV3CqVvFw06MCQ1gCv0Xz
+NyIi81kLsZJ3BijRyTh6N0d9S+zI+qplmeRa+RLcVNBmpuM0oNlQUXT/YnN9CLRD
+TPhfjqL6tr190w/lzJL6o/Ynx6DI8JtSwikk1p61rwZ3NxHMCZYPT49qQRA4OdbX
+c9zWmVnuC/L8/FIDn8gpu2VFo2pHqjkpsVo+oFuqC2XxdO9TB7AxKz0D/FXgDyx2
++cRvozXfYpBccQKCAQEAx0zk8RMNOjw6Svniyik5ZW4/lvC0JskLhoaTRuFAonTk
+AF+a4awCS3xD7czWJsvhILhtWDZfcuyOjv9932rMjOtfJE6XuWvaHReOyVHNh5XY
+ZC1igSG8g5AHAWqOSI7xYPby5Da3C4TSsTE/+k08n650UBQyZRNosER2xD/Cqrct
+bV00EShRW7nP91PUlHhdzoPOXcanOccyVO2cP2wejZ2Nv92FKmMN/yCnWxQ/oebv
+IZgF/9y4sA7I9DyxugRlgjMAjZ0pvt9wY88A6F+Xk4MsZd3bvXgqNt8je+EYA0Y6
+WQTzPVSF3vMBijwv58rFrfxJDogqiMnAWWuhQ0JmMQKCAQEAsl7KoDNd7STgVJTa
+kQLWOKDZrBNs3OMp9Tnquk2r6aT501MxbNqBXWztIJ2iRpIUIWHywHDNET3eHixX
+WTOz4knsz0di8xuAI43IWtBC2IcKDQKurArJohK70v/lrV8OwQmCTLpeX2tXEXR7
+JZEVSWCIvEpizMtJqvtcUM5QD+8gDET/io4k7HF78RQjpz0xIyCHwqzs0vN542h6
++4ZGpqZU8mpUa2j6HvNMsTnMTCHlEgPOD/7hYLvsOvv69X0EQhiIHafOUv1XJ3bh
+FcKn2ySSDDaJPQlZNSHu/qgdu9PJ7xayvaXbHfEPKa/2KdpXxL+XTO+CEYnfJCQw
+ZTc0gQKCAQAQTMmsrdI3IRXja+yQfC6ljQ7GWYliYq7+oaMJ+QJARy8emLMiId9O
+LSuhF0+sfKA8/Nh0jn3f+FjweRTiYOm53MY7QfJGx/texb532KjmnerExrF3vjqc
+x/rKstxQMuCq/YeAArmVx5czxsNkxUxgAvSgWAaHHb9CK1dLVaumKrUcbLMFdDaz
+Oc84ezK3seB6M219XfHvV8tWBtjwlvcoveoJ9yQdA1zxsMn/OPi7VRfZt4VGF9dD
+DvKAhzZB8Hoc2+7/pgr0AXI/t35rguXyupe2/R4rsNhDBJzyVMaR/fxnq2/5ZCBO
+y7EkjSed3YetYyTWe2x/I4EHzzWxOo0BAoIBAHiB0eLupAcjSVMaG4jCBbpeY+Yc
+cagfuhsKCmhUETDCjn86zOjaJQlwsxgPww9Gho7aPDC6DftLJ9ORyV/pATDXmOPp
+vqkq3t97e3vA38u09idhu1a2hobxAsZY3NKB03JI4sxC3Kc306f9bjh6qm8b5ilr
+z3SBLFjBtZ4yF+rwIrcaonHLaxDiyMi7GVLGDfwh6OzcULi953s+osVC8hgXFgs7
+3rc+UAv9pBdvk7DL8WJHuXHKhCNVZZVBGynhPvtM9j/1vUDCsL1XKxpZFTU8nqHU
+ZJ5AMvLk2X3Txsa2WV+r39XmzOYIUnQrU+Rbf2U3UiobjFq7xTKDwOvh8nc=
+-----END RSA PRIVATE KEY-----
diff --git a/gbl/signtool/testkeys/testkey_RSA4096_pub.pem b/gbl/signtool/testkeys/testkey_RSA4096_pub.pem
new file mode 100644
index 0000000..0053349
--- /dev/null
+++ b/gbl/signtool/testkeys/testkey_RSA4096_pub.pem
@@ -0,0 +1,13 @@
+-----BEGIN RSA PUBLIC KEY-----
+MIICCgKCAgEAts4B72trxidFOHDRD8UlzCeb386o1inufajBL6gDdEGTBDMvgbm5
+K8iZxGXyiIqCLSPjfnoMzOY54kUS0A7sVbSRvEPD/y9iBC5cUhirs/q7JQBd3ElT
+kSgbKN+MPV4BdVoWZxuPFdOipUlSdu1zQ2LE/O5i/fBcvUzk8KQdJqIBmfVFyhGY
+/vbbGAMdwg+yXAKZpSFZW3SZW7ZJotfTCaCD6v/PN3MmZBcaEHpZUVutNyxj9Hgw
+pmDwU6qM5xcw7YKtTLbZOP57dYGmHixOxtHv/XCVYHPPBjr/dKjw0bp6nFSiOk2Q
+vuaSsMMYaS2PDXkLSPGeed0Ose8XjR+skDT7lnqMuzm84OA30y4ApIm8RL0dbrDF
+IpiqPXrnjzuYkmEju7aceYA/ZVnFHJiSD/in8LVnxgLOG1abWksu2zrceLUH3z35
+EujvZHR5pnwfUMO9TtAojw738fq9OCtsfTIog85LLeuHbwPjOAYMgfKo23o9vD1T
+ZuzCyDEpjIZCVC07PWm58Q9jPxVoE+N+dyN89dp3CjZ81Zaxk3W0LljCWB+CaPBm
+F9X4c0biuFiWaCLDm7FXOIcebw4OPHWpWNxNEPo5cRQPKYhq3RcKouqRDPFsdMzz
+vJTtqfAFlkAiDcveaCgcRTuTkO0WSFzAsOPEDLyw4/gu9s3ggcqYt6ECAwEAAQ==
+-----END RSA PUBLIC KEY-----
diff --git a/gbl/smoltcp/BUILD b/gbl/smoltcp/BUILD
deleted file mode 100644
index 7509dde..0000000
--- a/gbl/smoltcp/BUILD
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
diff --git a/gbl/smoltcp/BUILD.smoltcp.bazel b/gbl/smoltcp/BUILD.smoltcp.bazel
deleted file mode 100644
index e01f6a1..0000000
--- a/gbl/smoltcp/BUILD.smoltcp.bazel
+++ /dev/null
@@ -1,131 +0,0 @@
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-# Upstream smoltcp uses a custom script in the cargo build flow to generate a `config.rs`
-# containing a set of configurations. We don't use cargo. Thus we use a pre-generated
-# one.
-genrule(
-    name = "gen_config",
-    outs = ["src/config.rs"],
-    cmd = """cat <<EOT > $@
-    pub const IFACE_MAX_ADDR_COUNT: usize = 2;
-    pub const IFACE_MAX_MULTICAST_GROUP_COUNT: usize = 4;
-    pub const IFACE_MAX_SIXLOWPAN_ADDRESS_CONTEXT_COUNT: usize = 4;
-    pub const IFACE_NEIGHBOR_CACHE_COUNT: usize = 16;
-    pub const IFACE_MAX_ROUTE_COUNT: usize = 2;
-    pub const FRAGMENTATION_BUFFER_SIZE: usize = 1500;
-    pub const ASSEMBLER_MAX_SEGMENT_COUNT: usize = 4;
-    pub const REASSEMBLY_BUFFER_SIZE: usize = 1500;
-    pub const REASSEMBLY_BUFFER_COUNT: usize = 1;
-    pub const IPV6_HBH_MAX_OPTIONS: usize = 1;
-    pub const DNS_MAX_RESULT_COUNT: usize = 1;
-    pub const DNS_MAX_SERVER_COUNT: usize = 1;
-    pub const DNS_MAX_NAME_SIZE: usize = 255;
-    pub const RPL_RELATIONS_BUFFER_COUNT: usize = 16;
-    pub const RPL_PARENTS_BUFFER_COUNT: usize = 8;
-EOT
-    """,
-)
-
-# `smoltcp` depends on crate `heapless`, which is still in the process of being imported to Android
-# (or possibly abandoned http://ag/22200123). For now we use a custom implementation of the APIs as
-# a workaround.
-genrule(
-    name = "heapless_src",
-    srcs = ["@gbl//smoltcp:heapless.rs"],
-    outs = ["src/heapless.rs"],
-    cmd = "cp $(SRCS) $(OUTS)",
-)
-
-rust_library(
-    name = "heapless",
-    srcs = ["src/heapless.rs"],
-    crate_root = "src/heapless.rs",
-    edition = "2021",
-)
-
-# Add fixup.rs to build and use our own crate root that imports it.
-genrule(
-    name = "smoltcp_fixup",
-    srcs = [
-        "@gbl//smoltcp:fixup.rs",
-        "src/lib.rs",
-    ],
-    outs = [
-        "src/fixup.rs",
-        "src/crate_root.rs",
-    ],
-    cmd = """
-        IFS=" " read -a srcs <<< "$(SRCS)" && \
-        IFS=" " read -a outs <<< "$(OUTS)" && \
-        for index in $${!srcs[@]}; do cp $${srcs[$$index]} $${outs[$$index]}; done && \
-        echo "mod fixup;" >> $${outs[1]}
-""",
-)
-
-rust_library(
-    name = "smoltcp",
-    srcs = glob(
-        ["**/*.rs"],
-        exclude = ["src/lib.rs"],
-    ) + [
-        "src/config.rs",
-        "src/crate_root.rs",
-        "src/fixup.rs",
-    ],
-    crate_features = [
-        "medium-ethernet",
-        "proto-ipv4",
-        "proto-ipv6",
-        "socket",
-        "socket-tcp",
-        "socket-icmp",
-        "socket-udp",
-    ],
-    crate_root = "src/crate_root.rs",
-    data = [
-        ":gen_config",
-        ":heapless_src",
-        ":smoltcp_fixup",
-    ],
-    edition = "2021",
-    rustc_env = {
-        "OUT_DIR": ".",
-    },
-    rustc_flags = [
-        # Always compile this crate in release mode. Otherwise it is too slow.
-        "-O",
-        "-A",
-        "unused_imports",
-        "-A",
-        "dead_code",
-        "-A",
-        "unreachable_patterns",
-        "-A",
-        "unused_variables",
-    ],
-    deps = [
-        ":heapless",
-        "@bitflags",
-        "@byteorder",
-        "@cfg_if",
-        "@managed",
-    ],
-)
diff --git a/gbl/smoltcp/fixup.rs b/gbl/smoltcp/fixup.rs
deleted file mode 100644
index 8f005c9..0000000
--- a/gbl/smoltcp/fixup.rs
+++ /dev/null
@@ -1,52 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use core::fmt;
-use core::fmt::Debug;
-
-// smoltcp uses an old version of bitflag (1.0). The one imported at Android is newer and does not
-// provide Copy/Clone/Debug/PartialEq/Eq trait implementation by default. Thus we need to add the
-// implementation here.
-
-use crate::wire::{NdiscNeighborFlags, NdiscPrefixInfoFlags, NdiscRouterFlags};
-
-macro_rules! bitflags_trait {
-    ($name:ident) => {
-        impl Copy for $name {}
-
-        impl Clone for $name {
-            fn clone(&self) -> $name {
-                *self
-            }
-        }
-
-        impl Debug for $name {
-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-                Debug::fmt(&self.bits(), f)
-            }
-        }
-
-        impl PartialEq for $name {
-            fn eq(&self, other: &Self) -> bool {
-                PartialEq::eq(&self.bits(), &other.bits())
-            }
-        }
-
-        impl Eq for $name {}
-    };
-}
-
-bitflags_trait! {NdiscNeighborFlags}
-bitflags_trait! {NdiscRouterFlags}
-bitflags_trait! {NdiscPrefixInfoFlags}
diff --git a/gbl/smoltcp/heapless.rs b/gbl/smoltcp/heapless.rs
deleted file mode 100644
index 63c0aba..0000000
--- a/gbl/smoltcp/heapless.rs
+++ /dev/null
@@ -1,112 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Selective implementation of APIs from crate `heapless` 0.8.0 using alloc.
-//! https://docs.rs/heapless/0.8.0/heapless/index.html
-//!
-//! The smoltcp crate depends on crate heapless. At the time this is written, the crate is either
-//! still in the process of being imported to Android or abandoned. Since we only use them in the
-//! EFI build which has alloc, we use a naive implementation of the needed APIs using heap
-//! allocation as a workaround for now.
-
-#![no_std]
-#![no_main]
-
-use core::ops::{Deref, DerefMut};
-
-extern crate alloc;
-use alloc::collections::BTreeMap;
-use alloc::vec::Vec as AllocVec;
-
-/// `heapless::Vec`
-#[derive(Debug, PartialEq, Eq, Clone)]
-pub struct Vec<T, const N: usize>(AllocVec<T>);
-
-impl<T, const N: usize> Vec<T, N> {
-    pub fn new() -> Self {
-        Self(AllocVec::new())
-    }
-
-    pub fn capacity(&self) -> usize {
-        N
-    }
-
-    pub fn push(&mut self, item: T) -> Result<(), T> {
-        match self.0.len() < N {
-            true => {
-                self.0.push(item);
-                Ok(())
-            }
-            _ => Err(item),
-        }
-    }
-}
-
-impl<T, const N: usize> Deref for Vec<T, N> {
-    type Target = AllocVec<T>;
-
-    fn deref(&self) -> &Self::Target {
-        &self.0
-    }
-}
-
-impl<T, const N: usize> DerefMut for Vec<T, N> {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.0
-    }
-}
-
-impl<'a, T, const N: usize> IntoIterator for &'a Vec<T, N> {
-    type Item = &'a T;
-    type IntoIter = core::slice::Iter<'a, T>;
-
-    fn into_iter(self) -> Self::IntoIter {
-        self.0.iter()
-    }
-}
-
-/// `heapless::LinearMap`
-#[derive(Debug, PartialEq, Eq, Clone)]
-pub struct LinearMap<K, V, const N: usize>(BTreeMap<K, V>);
-
-impl<K: core::cmp::Ord, V, const N: usize> LinearMap<K, V, N> {
-    pub fn new() -> Self {
-        Self(BTreeMap::new())
-    }
-
-    pub fn capacity(&self) -> usize {
-        N
-    }
-
-    pub fn insert(&mut self, key: K, value: V) -> Result<Option<V>, (K, V)> {
-        match self.0.len() < N {
-            true => Ok(self.0.insert(key, value)),
-            _ => Err((key, value)),
-        }
-    }
-}
-
-impl<K, V, const N: usize> Deref for LinearMap<K, V, N> {
-    type Target = BTreeMap<K, V>;
-
-    fn deref(&self) -> &Self::Target {
-        &self.0
-    }
-}
-
-impl<K, V, const N: usize> DerefMut for LinearMap<K, V, N> {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.0
-    }
-}
diff --git a/gbl/tests/BUILD b/gbl/tests/BUILD
deleted file mode 100644
index ab0cf8a..0000000
--- a/gbl/tests/BUILD
+++ /dev/null
@@ -1,57 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@gbl//toolchain:build_and_run_tests.bzl", "build_and_run_tests")
-
-test_suite(
-    name = "tests",
-    tests = [
-        ":build_and_run_tests",
-        # Doc tests does not work for `build_and_run_tests` because it accesses
-        # `../rules_rust/util/process_wrapper` and its path can't be correctly provided as test
-        # data.
-        "@gbl//libstorage:libstorage_doc_test",
-    ],
-)
-
-build_and_run_tests(
-    name = "build_and_run_tests",
-    # We need to re-specify the runtime data needed by tests.
-    data = ["@gbl//libgbl/testdata"],
-    tests = [
-        "@gbl//:readme_test",
-        "@gbl//efi:test",
-        "@gbl//libabr:libabr_test",
-        "@gbl//libasync:cyclic_executor_test",
-        "@gbl//libasync:libasync_test",
-        "@gbl//libbootimg:libbootimg_test",
-        "@gbl//libbootparams:test",
-        "@gbl//libc:libc_c_test",
-        "@gbl//libc:libc_test",
-        "@gbl//libdttable:libdttable_test",
-        "@gbl//libefi:libefi_test",
-        "@gbl//libefi:mocks_test",
-        "@gbl//libefi_types:libefi_types_test",
-        "@gbl//libelf:relocation_test",
-        "@gbl//liberror:liberror_test",
-        "@gbl//libfastboot:libfastboot_test",
-        "@gbl//libfdt:libfdt_test",
-        "@gbl//libgbl:libgbl_test",
-        "@gbl//libmisc:libmisc_test",
-        "@gbl//libsafemath:libsafemath_test",
-        "@gbl//libstorage:libstorage_test",
-        "@gbl//libutils:test",
-        "@zbi//:zbi_test",
-    ],
-)
diff --git a/gbl/tests/noop.sh b/gbl/tests/noop.sh
deleted file mode 100755
index f84cab4..0000000
--- a/gbl/tests/noop.sh
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/bin/bash
-#
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# This is a noop script used by `build_and_run_tests` rule.
-
-exit 0
diff --git a/gbl/toolchain/BUILD b/gbl/toolchain/BUILD
deleted file mode 100644
index 40ac1b0..0000000
--- a/gbl/toolchain/BUILD
+++ /dev/null
@@ -1,528 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@bazel_skylib//rules:common_settings.bzl", "bool_setting")
-load(
-    "@gbl_llvm_prebuilts//:info.bzl",
-    "LINUX_SYSROOT_INCLUDES",
-    "LLVM_PREBUILTS_CPP_INCLUDE",
-    "LLVM_PREBUILTS_C_INCLUDE",
-    "gbl_llvm_tool_path",
-)
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen_toolchain")
-load(
-    "@rules_rust//rust:toolchain.bzl",
-    "rust_stdlib_filegroup",
-    "rust_toolchain",
-    "rustfmt_toolchain",
-)
-load(
-    ":gbl_toolchain.bzl",
-    "build_with_no_rust_sysroot",
-    "gbl_clang_cc_toolchain",
-    "prebuilt_binary",
-)
-
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-# The following constraint/settings will be used in our newly defined
-# toolchains, so that they only get selected by bazel when we configure
-# to build GBL.
-constraint_setting(name = "firmware_image_type")
-
-constraint_value(
-    name = "uefi",
-    constraint_setting = ":firmware_image_type",
-)
-
-constraint_value(
-    name = "elf",
-    constraint_setting = ":firmware_image_type",
-)
-
-host_x86_64_constraint_values = [
-    "@platforms//os:linux",
-    "@platforms//cpu:x86_64",
-]
-
-uefi_x86_64_constraint_values = [
-    ":uefi",
-    "@platforms//os:none",
-    "@platforms//cpu:x86_64",
-]
-
-uefi_x86_32_constraint_values = [
-    ":uefi",
-    "@platforms//os:none",
-    "@platforms//cpu:x86_32",
-]
-
-uefi_aarch64_constraint_values = [
-    ":uefi",
-    "@platforms//os:none",
-    "@platforms//cpu:aarch64",
-]
-
-elf_riscv64_constraint_values = [
-    ":elf",
-    "@platforms//os:none",
-    "@platforms//cpu:riscv64",
-]
-
-config_setting(
-    name = "gbl_rust_host_x86_64",
-    constraint_values = host_x86_64_constraint_values,
-)
-
-config_setting(
-    name = "gbl_rust_uefi_x86_64",
-    constraint_values = uefi_x86_64_constraint_values,
-)
-
-config_setting(
-    name = "gbl_rust_uefi_x86_32",
-    constraint_values = uefi_x86_32_constraint_values,
-)
-
-config_setting(
-    name = "gbl_rust_uefi_aarch64",
-    constraint_values = uefi_aarch64_constraint_values,
-)
-
-config_setting(
-    name = "gbl_rust_elf_riscv64",
-    constraint_values = elf_riscv64_constraint_values,
-)
-
-# The following will be passed to "bazel build --platform=<>" argument to
-# configure building for specific architecture and image type.
-platform(
-    name = "gbl_uefi_x86_64",
-    constraint_values = uefi_x86_64_constraint_values,
-)
-
-platform(
-    name = "gbl_uefi_x86_32",
-    constraint_values = uefi_x86_32_constraint_values,
-)
-
-platform(
-    name = "gbl_uefi_aarch64",
-    constraint_values = uefi_aarch64_constraint_values,
-)
-
-platform(
-    name = "gbl_elf_riscv64",
-    constraint_values = elf_riscv64_constraint_values,
-)
-
-bool_setting(
-    name = "rust_no_sysroot",
-    build_setting_default = False,
-    visibility = ["//visibility:public"],
-)
-
-config_setting(
-    name = "rust_no_sysroot_true",
-    flag_values = {":rust_no_sysroot": "True"},
-)
-
-# Linux host LLVM toolchain.
-# The toolchain is mainly used for building/linking host tools, i.e. bindgen pre-processing
-gbl_clang_cc_toolchain(
-    name = "x86_64-unknown-linux-gnu",
-    # Host LLVM toolchain has additional C++ stdlib.
-    builtin_includes = [
-        LLVM_PREBUILTS_CPP_INCLUDE,  # C++ headers must come first.
-        LLVM_PREBUILTS_C_INCLUDE,
-    ] + LINUX_SYSROOT_INCLUDES,
-    ld_flags = [
-        "-stdlib=libc++",
-        "-static-libstdc++",
-    ],
-    target_cpu = "x86_64",
-    target_system_triple = "x86_64-unknown-linux-gnu",
-)
-
-toolchain(
-    name = "x86_64-unknown-linux-gnu_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_compatible_with = [
-        "@platforms//os:linux",
-        "@platforms//cpu:x86_64",
-    ],
-    toolchain = ":x86_64-unknown-linux-gnu",
-    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
-)
-
-# The following defines LLVM C++ toolchains for UEFI/ELF targets. They are mostly used for the
-# final step of linking Rust executables, but may also be used for compiling mixed C/C++ code.
-
-cc_flags_common = [
-    "-ffreestanding",
-    "-fno-common",
-    "-fno-exceptions",
-    "-fno-rtti",
-    # Enable optimization otherwise software AVB hash will be too slow.
-    "-O3",
-]
-
-# x86_64 UEFI targets
-gbl_clang_cc_toolchain(
-    name = "x86_64_uefi_clang_cc_toolchain",
-    cc_flags = cc_flags_common + [
-        # Adding this prevents the compiler from generating mmx, sse instructions such as
-        # "movsd (%esp),%xmm0" which likely isn't enabled during the bootloader stage and causes
-        # crash as a result.
-        "-mgeneral-regs-only",
-    ],
-    target_cpu = "x86_64",
-    target_system_triple = "x86_64-unknown-windows-msvc",
-)
-
-toolchain(
-    name = "x86_64_uefi_clang",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_compatible_with = uefi_x86_64_constraint_values,
-    toolchain = ":x86_64_uefi_clang_cc_toolchain",
-    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
-)
-
-# x86_32 UEFI targets
-gbl_clang_cc_toolchain(
-    name = "x86_32_uefi_clang_cc_toolchain",
-    cc_flags = cc_flags_common + [
-        "-m32",
-        # Adding this prevents the compiler from generating mmx, sse instructions such as
-        # "movsd (%esp),%xmm0" which likely isn't enabled during the bootloader stage and causes
-        # crash as a result.
-        "-march=i686",
-    ],
-    # Safe Exception Handlers is not applicable to EFI systems.
-    ld_flags = ["/SAFESEH:no"],
-    target_cpu = "x86_32",
-    target_system_triple = "i686-unknown-windows-gnu",
-)
-
-toolchain(
-    name = "x86_32_uefi_clang",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_compatible_with = uefi_x86_32_constraint_values,
-    toolchain = ":x86_32_uefi_clang_cc_toolchain",
-    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
-)
-
-# aarch64 UEFI targets
-gbl_clang_cc_toolchain(
-    name = "aarch64_uefi_clang_cc_toolchain",
-    cc_flags = cc_flags_common,
-    target_cpu = "aarch64",
-    target_system_triple = "aarch64-windows-msvc",
-)
-
-toolchain(
-    name = "aarch64_uefi_clang",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_compatible_with = uefi_aarch64_constraint_values,
-    toolchain = ":aarch64_uefi_clang_cc_toolchain",
-    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
-)
-
-# riscv64 ELF targets
-gbl_clang_cc_toolchain(
-    name = "riscv64_elf_clang_cc_toolchain",
-    cc_flags = cc_flags_common + ["-fpie"],
-    target_cpu = "riscv64",
-    target_system_triple = "riscv64-unknown-linux",
-)
-
-toolchain(
-    name = "riscv64_elf_clang",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_compatible_with = elf_riscv64_constraint_values,
-    toolchain = ":riscv64_elf_clang_cc_toolchain",
-    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
-)
-
-# Rust toolchains
-
-# An empty rust std file group used as placeholder when building rust sysroot.
-rust_stdlib_filegroup(
-    name = "rust_stdlib_empty",
-    srcs = [],
-)
-
-# A rule for building sysroot from source.
-build_with_no_rust_sysroot(
-    name = "rust_sysroot_source_build",
-    deps = [
-        "@rust_prebuilts//:liballoc",
-        "@rust_prebuilts//:libcompiler_builtins",
-        "@rust_prebuilts//:libcore",
-    ],
-)
-
-rust_stdlib_filegroup(
-    name = "rust_std_source_build",
-    srcs = [":rust_sysroot_source_build"],
-)
-
-common_lint_opts = [
-    "-A",
-    "deprecated",
-    # external/rust/crates/spin doesn't pass this lint check and there is not a way to make an
-    # exemption. Disable it until upstream is fixed or we figure out a workaround.
-    #"-D",
-    #"unsafe_op_in_unsafe_fn",
-    "-D",
-    "warnings",
-    "-D",
-    "clippy::undocumented_unsafe_blocks",
-    "-D",
-    "clippy::too-many-arguments",
-]
-
-# Linux x86_64 Host toolchain
-rust_toolchain(
-    name = "x86_64_unknown_linux_gnu",
-    allocator_library = None,
-    binary_ext = "",
-    default_edition = "2021",
-    dylib_ext = ".so",
-    exec_triple = "x86_64-unknown-linux-gnu",
-    global_allocator_library = None,
-    rust_doc = "@rust_prebuilts//:bin/rustdoc",
-    rust_std = "@rust_prebuilts//:prebuilt_stdlibs",
-    rustc = "@rust_prebuilts//:bin/rustc",
-    staticlib_ext = ".a",
-    stdlib_linkflags = [],
-    target_triple = "x86_64-unknown-linux-gnu",
-)
-
-toolchain(
-    name = "x86_64_unknown_linux_gnu_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_settings = [":gbl_rust_host_x86_64"],
-    toolchain = ":x86_64_unknown_linux_gnu",
-    toolchain_type = "@rules_rust//rust:toolchain",
-)
-
-# x86_64 UEFI toolchain
-rust_toolchain(
-    name = "x86_64-unknown-uefi",
-    allocator_library = None,
-    binary_ext = ".efi",
-    default_edition = "2021",
-    dylib_ext = ".so",
-    exec_triple = "x86_64-unknown-linux-gnu",
-    extra_rustc_flags = common_lint_opts + [
-        # The linker options generated by rustc assumes `lld` as the linker. For windows platforms,
-        # the lld args style is different than that of clang++, i.e. for library search path, lld
-        # uses "/L<path>" while clang++ uses "-L<path>". Thus we need to use lld directly instead
-        # of `clang++`.
-        "--codegen=linker={}".format(gbl_llvm_tool_path("lld")),
-        # Disable default sysroot. We'll pass sysroot explicitly via the `rust_std` field below.
-        "--sysroot",
-        "/dev/null",
-    ],
-    global_allocator_library = None,
-    rust_doc = "@rust_prebuilts//:bin/rustdoc",
-    rust_std = "@rust_prebuilts//:x86_64-unknown-uefi_prebuilt_stdlibs",
-    rustc = "@rust_prebuilts//:bin/rustc",
-    staticlib_ext = ".a",
-    stdlib_linkflags = [],
-    target_triple = "x86_64-unknown-uefi",
-)
-
-toolchain(
-    name = "x86_64-unknown-uefi_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_settings = [":gbl_rust_uefi_x86_64"],
-    toolchain = ":x86_64-unknown-uefi",
-    toolchain_type = "@rules_rust//rust:toolchain",
-)
-
-# i686 UEFI toolchain
-rust_toolchain(
-    name = "i686-unknown-uefi",
-    allocator_library = None,
-    binary_ext = ".efi",
-    default_edition = "2021",
-    dylib_ext = ".so",
-    exec_triple = "x86_64-unknown-linux-gnu",
-    extra_rustc_flags = common_lint_opts + [
-        "--codegen=linker={}".format(gbl_llvm_tool_path("lld")),
-        # Disable default sysroot. We'll pass sysroot explicitly via the `rust_std` field below.
-        "--sysroot",
-        "/dev/null",
-    ],
-    global_allocator_library = None,
-    rust_doc = "@rust_prebuilts//:bin/rustdoc",
-    # Need to use our own sysroot because we have a custom patch that needs to be applied for std
-    # in order to enable compiler builtin for chkstk(), alloca(). Once the fix is upstreamed, we
-    # can use the prebuilt.
-    rust_std = select({
-        ":rust_no_sysroot_true": ":rust_stdlib_empty",
-        "//conditions:default": ":rust_std_source_build",
-    }),
-    #rust_std = "@rust_prebuilts//:i686-unknown-uefi_prebuilt_stdlibs",
-    rustc = "@rust_prebuilts//:bin/rustc",
-    staticlib_ext = ".a",
-    stdlib_linkflags = [],
-    target_triple = "i686-unknown-uefi",
-)
-
-toolchain(
-    name = "i686-unknown-uefi_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_settings = [":gbl_rust_uefi_x86_32"],
-    toolchain = ":i686-unknown-uefi",
-    toolchain_type = "@rules_rust//rust:toolchain",
-)
-
-# aarch64 UEFI toolchain
-rust_toolchain(
-    name = "aarch64-unknown-uefi",
-    allocator_library = None,
-    binary_ext = ".efi",
-    default_edition = "2021",
-    dylib_ext = ".so",
-    exec_triple = "x86_64-unknown-linux-gnu",
-    extra_rustc_flags = common_lint_opts + [
-        "--codegen=linker={}".format(gbl_llvm_tool_path("lld")),
-        # Disable default sysroot. We'll pass sysroot explicitly via the `rust_std` field below.
-        "--sysroot",
-        "/dev/null",
-    ],
-    global_allocator_library = None,
-    rust_doc = "@rust_prebuilts//:bin/rustdoc",
-    rust_std = "@rust_prebuilts//:aarch64-unknown-uefi_prebuilt_stdlibs",
-    rustc = "@rust_prebuilts//:bin/rustc",
-    staticlib_ext = ".a",
-    stdlib_linkflags = [],
-    target_triple = "aarch64-unknown-uefi",
-)
-
-toolchain(
-    name = "aarch64-unknown-uefi_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_settings = [":gbl_rust_uefi_aarch64"],
-    toolchain = ":aarch64-unknown-uefi",
-    toolchain_type = "@rules_rust//rust:toolchain",
-)
-
-# riscv64 PIE ELF toolchain
-rust_toolchain(
-    name = "riscv64gc-unknown-none-pie_elf",
-    allocator_library = None,
-    binary_ext = "",
-    default_edition = "2021",
-    dylib_ext = ".so",
-    exec_triple = "x86_64-unknown-linux-gnu",
-    extra_rustc_flags = common_lint_opts + [
-        "--codegen=linker={}".format(gbl_llvm_tool_path("lld")),
-        # Disable default sysroot. We'll pass sysroot explicitly via the `rust_std` field below.
-        "--sysroot",
-        "/dev/null",
-    ],
-    global_allocator_library = None,
-    rust_doc = "@rust_prebuilts//:bin/rustdoc",
-    # Need to use our own built sysroot because we are using a custom spec below.
-    rust_std = select({
-        ":rust_no_sysroot_true": ":rust_stdlib_empty",
-        "//conditions:default": ":rust_std_source_build",
-    }),
-    rustc = "@rust_prebuilts//:bin/rustc",
-    staticlib_ext = ".a",
-    stdlib_linkflags = [],
-    # The custom spec is based on builtin target "riscv64gc-unknown-none-elf" but with the
-    # following changes for enabling PIE:
-    #
-    #   1. "relocation-model" config entry changed from "static" to "pic".
-    #   2. Added "position-independent-executables": true.
-    #
-    # The original spec can be obtained by:
-    #
-    #   rustc +nightly -Z unstable-options --print target-spec-json \
-    #     --target riscv64gc-unknown-none-elf
-    target_json = """
-                {
-                    "arch": "riscv64",
-                    "code-model": "medium",
-                    "cpu": "generic-rv64",
-                    "data-layout": "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128",
-                    "eh-frame-header": false,
-                    "emit-debug-gdb-scripts": false,
-                    "features": "+m,+a,+f,+d,+c",
-                    "is-builtin": false,
-                    "linker": "rust-lld",
-                    "linker-flavor": "ld.lld",
-                    "llvm-abiname": "lp64d",
-                    "llvm-target": "riscv64-unknown-linux",
-                    "max-atomic-width": 64,
-                    "os": "none",
-                    "panic-strategy": "abort",
-                    "relocation-model": "pic",
-                    "position-independent-executables": true,
-                    "supported-sanitizers": [
-                        "kernel-address"
-                    ],
-                    "target-pointer-width": "64"
-                }
-""",
-)
-
-toolchain(
-    name = "riscv64gc-unknown-none-pie_elf_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    target_settings = ["@gbl//toolchain:gbl_rust_elf_riscv64"],
-    toolchain = ":riscv64gc-unknown-none-pie_elf",
-    toolchain_type = "@rules_rust//rust:toolchain",
-)
-
-# rustfmt toolchain
-rustfmt_toolchain(
-    name = "rustfmt",
-    rustfmt = "@rust_prebuilts//:bin/rustfmt",
-)
-
-toolchain(
-    name = "rustfmt_toolchain",
-    exec_compatible_with = ["@platforms//os:linux"],
-    toolchain = ":rustfmt",
-    toolchain_type = "@rules_rust//rust/rustfmt:toolchain_type",
-)
-
-# Rust bindgen toolchain
-
-prebuilt_binary(
-    name = "bindgen_prebuilt",
-    bin = "@bindgen//:bindgen",
-)
-
-rust_bindgen_toolchain(
-    name = "bindgen_toolchain_impl",
-    bindgen = ":bindgen_prebuilt",
-    clang = "@gbl_llvm_prebuilts//:clang-bin",
-    libclang = "@gbl_llvm_prebuilts//:libclang",
-    libstdcxx = "@gbl_llvm_prebuilts//:libc++",
-)
-
-toolchain(
-    name = "bindgen_toolchain",
-    toolchain = "bindgen_toolchain_impl",
-    toolchain_type = "@rules_rust//bindgen:toolchain_type",
-)
diff --git a/gbl/toolchain/BUILD.android_rust_prebuilts.bazel b/gbl/toolchain/BUILD.android_rust_prebuilts.bazel
deleted file mode 100644
index b6beffc..0000000
--- a/gbl/toolchain/BUILD.android_rust_prebuilts.bazel
+++ /dev/null
@@ -1,123 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_stdlib_filegroup")
-
-package(default_visibility = ["//visibility:public"])
-
-exports_files(["bin/*"])
-
-filegroup(
-    name = "binaries",
-    srcs = glob([
-        "bin/*",
-        "lib/*",
-        "lib64/*",
-    ]),
-)
-
-# sysroot prebuilts for x86_64_unknown-linux-gnu
-rust_stdlib_filegroup(
-    name = "prebuilt_stdlibs",
-    srcs = glob(["lib/rustlib/x86_64-unknown-linux-gnu/lib/*"]),
-)
-
-# sysroot prebuilts for aarch64_unknown-uefi
-rust_stdlib_filegroup(
-    name = "aarch64-unknown-uefi_prebuilt_stdlibs",
-    srcs = glob(["lib/rustlib/aarch64-unknown-uefi/lib/*"]),
-)
-
-# sysroot prebuilts for x86_64-unknown-uefi
-rust_stdlib_filegroup(
-    name = "x86_64-unknown-uefi_prebuilt_stdlibs",
-    srcs = glob(["lib/rustlib/x86_64-unknown-uefi/lib/*"]),
-)
-
-# sysroot prebuilts for i686-unknown-uefi
-rust_stdlib_filegroup(
-    name = "i686-unknown-uefi_prebuilt_stdlibs",
-    srcs = glob(["lib/rustlib/i686-unknown-uefi/lib/*"]),
-)
-
-rust_library(
-    name = "liballoc",
-    srcs = glob(["src/stdlibs/library/alloc/src/**/*.rs"]),
-    compile_data = glob(["src/stdlibs/library/alloc/src/**/*.md"]),
-    crate_name = "alloc",
-    edition = "2021",
-    deps = [
-        "libcompiler_builtins",
-        "libcore",
-    ],
-)
-
-COMPILER_BUILTIN_X86_SRC = "src/stdlibs/vendor/compiler_builtins/src/x86.rs"
-
-COMPILER_BUILTIN_X86_PATCH = "@gbl//patches:rust-libcompiler-builtins-enable-chkstk-on-uefi.patch"
-
-# Apply patches to x86 to enable the compiler built-in for chkstk(), alloca() function.
-# TODO(b/337114254): Remove this patch once upstream is fixed.
-genrule(
-    name = "x86_uefi_chkstk_patch",
-    srcs = [
-        COMPILER_BUILTIN_X86_SRC,
-        COMPILER_BUILTIN_X86_PATCH,
-    ],
-    # Bazel does not let us override the same x86.rs. But module name needs to be the same. Thus we
-    # output as "x86/mod.rs" instead.
-    outs = ["src/stdlibs/vendor/compiler_builtins/src/x86/mod.rs"],
-    cmd = " cp $(location {}) $(OUTS) && patch -u -f $(OUTS) $(location {})"
-        .format(COMPILER_BUILTIN_X86_SRC, COMPILER_BUILTIN_X86_PATCH),
-)
-
-rust_library(
-    name = "libcompiler_builtins",
-    srcs = glob(
-        [
-            "src/stdlibs/vendor/compiler_builtins/src/**/*.rs",
-            "src/stdlibs/vendor/compiler_builtins/libm/src/**/*.rs",
-        ],
-    ),
-    compile_data = glob(["src/stdlibs/vendor/compiler_builtins/src/**/*.md"]),
-    crate_features = [
-        "compiler-builtins",
-        "core",
-        "default",
-        "mem",
-    ],
-    crate_name = "compiler_builtins",
-    edition = "2021",
-    rustc_flags = ["--cap-lints=allow"],
-    deps = ["libcore"],
-)
-
-rust_library(
-    name = "libcore",
-    srcs = glob([
-        "src/stdlibs/library/core/src/**/*.rs",
-        "src/stdlibs/library/stdarch/crates/core_arch/src/**/*.rs",
-        "src/stdlibs/library/portable-simd/crates/core_simd/src/**/*.rs",
-    ]),
-    compile_data = glob([
-        "src/stdlibs/library/core/src/**/*.md",
-        "src/stdlibs/library/core/primitive_docs/*.md",
-        "src/stdlibs/library/stdarch/crates/core_arch/src/**/*.md",
-        "src/stdlibs/library/portable-simd/crates/core_simd/src/**/*.md",
-    ]),
-    crate_features = ["stdsimd"],
-    crate_name = "core",
-    edition = "2021",
-    rustc_flags = ["--cap-lints=allow"],
-)
diff --git a/gbl/toolchain/build_and_run_tests.bzl b/gbl/toolchain/build_and_run_tests.bzl
deleted file mode 100644
index d03413e..0000000
--- a/gbl/toolchain/build_and_run_tests.bzl
+++ /dev/null
@@ -1,89 +0,0 @@
-# Copyright (C) 2025 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""
-This file defines `build_and_run_tests` rule
-"""
-
-load("@rules_shell//shell:sh_test.bzl", "sh_test")
-
-def _build_and_run_impl(ctx):
-    # Executable file from the attribute.
-    executable = ctx.executable.executable
-
-    # Output log file.
-    logfile = ctx.actions.declare_file("%s.txt" % ctx.attr.name)
-
-    ctx.actions.run_shell(
-        inputs = [executable] + ctx.files.data,
-        outputs = [logfile],
-        progress_message = "Running test %s" % executable.short_path,
-        command = """\
-        BIN="%s" && \
-        OUT="%s" && \
-        ($BIN > $OUT || \
-        if [ $? == 0 ]; then
-            true
-        else
-            echo "\n%s failed." && cat $OUT && false
-        fi)
-""" % (executable.path, logfile.path, executable.short_path),
-    )
-
-    return [DefaultInfo(files = depset([logfile]))]
-
-build_and_run = rule(
-    implementation = _build_and_run_impl,
-    attrs = {
-        "executable": attr.label(
-            executable = True,
-            cfg = "exec",
-            allow_files = True,
-            mandatory = True,
-        ),
-        "data": attr.label_list(
-            allow_files = True,
-            allow_empty = True,
-        ),
-    },
-)
-
-# TODO(b/382503065): This is a temporary workaround due to presubmit infra not blocking on test
-# failures and only on build failures. Removed once the issue is solved.
-def build_and_run_tests(name, tests, data):
-    """Create an `sh_test` target that run a set of unittests during build time.
-
-    Args:
-        name (String): name of the rust_library target.
-        tests (List of strings): List of test target.
-        data (List of strings): Runtime data needed by the tests.
-    """
-
-    all_tests = []
-    for idx, test in enumerate(tests):
-        subtest_name = "{}_subtest_{}".format(name, idx)
-        build_and_run(
-            name = subtest_name,
-            testonly = True,
-            executable = test,
-            data = data,
-        )
-
-        all_tests.append(":{}".format(subtest_name))
-
-    sh_test(
-        name = name,
-        srcs = ["@gbl//tests:noop.sh"],
-        data = all_tests,
-    )
diff --git a/gbl/toolchain/gbl_toolchain.bzl b/gbl/toolchain/gbl_toolchain.bzl
deleted file mode 100644
index 41167da..0000000
--- a/gbl/toolchain/gbl_toolchain.bzl
+++ /dev/null
@@ -1,300 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""
-This file contains rules for defininig GBL toolchains.
-"""
-
-load(
-    "@bazel_tools//tools/cpp:cc_toolchain_config_lib.bzl",
-    "action_config",
-    "flag_group",
-    "flag_set",
-    "tool",
-    "tool_path",
-)
-load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE", "gbl_llvm_tool_path")
-load("@rules_cc//cc:action_names.bzl", "ACTION_NAMES", "ALL_CPP_COMPILE_ACTION_NAMES")
-
-def _flag_set(flags):
-    """Convert a list of compile/link flags to a flag_set type."""
-    return flag_set(
-        flag_groups = [
-            flag_group(
-                flags = flags,
-            ),
-        ],
-    )
-
-def _gbl_clang_cc_toolchain_config_impl(ctx):
-    """Implementation for rule _gbl_clang_cc_toolchain_config()"""
-    builtin_includes = ctx.attr.builtin_includes or [LLVM_PREBUILTS_C_INCLUDE]
-    common_compile_flagset = [
-        _flag_set([
-            "--target={}".format(ctx.attr.target_system_triple),
-            "-nostdinc",
-            "-no-canonical-prefixes",
-            "-Werror",
-            "-Wall",
-        ] + ["-I{}".format(inc) for inc in builtin_includes] + ctx.attr.cc_flags),
-    ]
-    return cc_common.create_cc_toolchain_config_info(
-        ctx = ctx,
-        cxx_builtin_include_directories = builtin_includes,
-        toolchain_identifier = "{}_id".format(ctx.attr.cc_toolchain_name),
-        host_system_name = "local",
-        target_system_name = ctx.attr.target_system_triple,
-        target_cpu = ctx.attr.target_cpu,
-        target_libc = "unknown",
-        compiler = "clang",
-        abi_version = "unknown",
-        abi_libc_version = "unknown",
-        action_configs = [
-            action_config(
-                action_name = action_name,
-                enabled = True,
-                tools = [tool(path = gbl_llvm_tool_path("clang++"))],
-                flag_sets = common_compile_flagset,
-            )
-            for action_name in ALL_CPP_COMPILE_ACTION_NAMES +
-                               [ACTION_NAMES.assemble, ACTION_NAMES.preprocess_assemble]
-        ] + [
-            action_config(
-                action_name = ACTION_NAMES.c_compile,
-                enabled = True,
-                tools = [tool(path = gbl_llvm_tool_path("clang"))],
-                flag_sets = common_compile_flagset,
-            ),
-        ] + [
-            action_config(
-                action_name = ACTION_NAMES.cpp_link_executable,
-                enabled = True,
-                tools = [tool(path = gbl_llvm_tool_path("clang++"))],
-                flag_sets = [_flag_set(ctx.attr.ld_flags)] if ctx.attr.ld_flags else [],
-            ),
-        ],
-        tool_paths = [
-            tool_path(
-                name = "ld",
-                path = gbl_llvm_tool_path("clang++"),
-            ),
-            tool_path(
-                name = "ar",
-                path = gbl_llvm_tool_path("llvm-ar"),
-            ),
-            tool_path(
-                name = "cpp",
-                path = gbl_llvm_tool_path("clang++"),
-            ),
-            tool_path(
-                name = "gcc",
-                path = gbl_llvm_tool_path("clang"),
-            ),
-            tool_path(
-                name = "gcov",
-                path = gbl_llvm_tool_path("llvm-cov"),
-            ),
-            tool_path(
-                name = "nm",
-                path = gbl_llvm_tool_path("llvm-nm"),
-            ),
-            tool_path(
-                name = "objdump",
-                path = gbl_llvm_tool_path("llvm-objdump"),
-            ),
-            tool_path(
-                name = "strip",
-                path = gbl_llvm_tool_path("llvm-strip"),
-            ),
-        ],
-    )
-
-_gbl_clang_cc_toolchain_config = rule(
-    implementation = _gbl_clang_cc_toolchain_config_impl,
-    attrs = {
-        "cc_toolchain_name": attr.string(),
-        "target_cpu": attr.string(),
-        "target_system_triple": attr.string(),
-        "cc_flags": attr.string_list(),
-        "ld_flags": attr.string_list(),
-        "builtin_includes": attr.string_list(),
-    },
-    provides = [CcToolchainConfigInfo],
-)
-
-def gbl_clang_cc_toolchain(
-        name,
-        target_cpu,
-        target_system_triple,
-        cc_flags = None,
-        ld_flags = None,
-        builtin_includes = None):
-    """Configure a clang based cc_toolchain().
-
-    Args:
-        name (String): Name of the target.
-        target_cpu (string): Target CPU.
-        target_system_triple (string): LLVM-style target system triple.
-        cc_flags (List): clang compile flags.
-        ld_flags (List): clang link flags
-        builtin_includes (List): Override the default list of builtin include dirs.
-    """
-    config_name = "_{}_config".format(name)
-    _gbl_clang_cc_toolchain_config(
-        name = config_name,
-        cc_toolchain_name = name,
-        target_cpu = target_cpu,
-        target_system_triple = target_system_triple,
-        cc_flags = cc_flags,
-        ld_flags = ld_flags,
-        builtin_includes = builtin_includes,
-    )
-
-    empty_filegroup = "_empty_{}".format(name)
-    native.filegroup(name = empty_filegroup)
-    empty_filegroup_target = ":{}".format(empty_filegroup)
-
-    native.cc_toolchain(
-        name = name,
-        toolchain_identifier = name,
-        toolchain_config = ":{}".format(config_name),
-        all_files = empty_filegroup_target,
-        compiler_files = empty_filegroup_target,
-        dwp_files = empty_filegroup_target,
-        linker_files = empty_filegroup_target,
-        objcopy_files = empty_filegroup_target,
-        strip_files = empty_filegroup_target,
-        supports_param_files = 0,
-    )
-
-def _prebuilt_binary_impl(ctx):
-    """Generate a wrapper executable type target that simply symlinks to a given executable binary.
-
-    This is for rules that only accept executable type target but not binary file directly.
-    i.e. `rust_bindgen_toolchain`
-    """
-    out = ctx.actions.declare_file(ctx.label.name)
-    ctx.actions.symlink(
-        output = out,
-        target_file = ctx.executable.bin,
-    )
-    return [DefaultInfo(files = depset([out]), executable = out)]
-
-prebuilt_binary = rule(
-    implementation = _prebuilt_binary_impl,
-    executable = True,
-    attrs = {
-        "bin": attr.label(allow_single_file = True, executable = True, cfg = "exec"),
-    },
-)
-
-# A transition rule that emits the `@gbl//toolchain:rust_no_sysroot_true` setting.
-def _no_sysroot_transition_impl(_, __):
-    return {"@gbl//toolchain:rust_no_sysroot": True}
-
-_no_sysroot_transition = transition(
-    implementation = _no_sysroot_transition_impl,
-    inputs = [],
-    outputs = ["@gbl//toolchain:rust_no_sysroot"],
-)
-
-# A rule implementation that simply forwards dependencies from attribute `deps` and generates
-# symlinks to their output files.
-def _forward_and_symlink(ctx):
-    outs = []
-    for file in ctx.files.deps:
-        # Append the label name to the file name but keep the same extension. i.e.
-        # "<file>.<extension>" -> "<file>_<label>.<extension>"
-        stem = file.basename.removesuffix(".{}".format(file.extension))
-        out = ctx.actions.declare_file("{}_{}.{}".format(stem, ctx.label.name, file.extension))
-        ctx.actions.symlink(output = out, target_file = file)
-        outs.append(out)
-    return [DefaultInfo(files = depset(outs))]
-
-# A rule for building rust targets with the `@gbl//toolchain:rust_no_sysroot_true` setting.
-build_with_no_rust_sysroot = rule(
-    implementation = _forward_and_symlink,
-    cfg = _no_sysroot_transition,
-    attrs = {
-        # Mandatory attribute for rules with transition.
-        "_allowlist_function_transition": attr.label(
-            default = Label("@bazel_tools//tools/allowlists/function_transition_allowlist"),
-        ),
-        "deps": attr.label_list(allow_files = True, mandatory = True),
-    },
-)
-
-# A transition rule that emits the "--platforms=<attr.platform>" option.
-def _platform_transition_impl(_, attr):
-    return {"//command_line_option:platforms": attr.platform}
-
-_platform_transition = transition(
-    implementation = _platform_transition_impl,
-    inputs = [],
-    outputs = ["//command_line_option:platforms"],
-)
-
-build_with_platform = rule(
-    implementation = _forward_and_symlink,
-    cfg = _platform_transition,
-    attrs = {
-        # Mandatory attribute for rules with transition.
-        "_allowlist_function_transition": attr.label(
-            default = Label("@bazel_tools//tools/allowlists/function_transition_allowlist"),
-        ),
-        "platform": attr.string(mandatory = True),
-        "deps": attr.label_list(allow_files = True, mandatory = True),
-    },
-)
-
-# This rule creates symlink for a static library in both Linux/GNU and MSVC naming styles so that
-# rust linker is able to find it when building for them.
-#
-# When flag "-Clink-arg=-l<libname>" is passed to rustc, for Linux/GNU target platforms, the linker
-# looks for library named "lib<libname>.a", for MSVC target plaforms (i.e. UEFI), the linker looks
-# for library named "<libname>.lib". When bazel builds a cc_library target, it always outputs the
-# Linux/GNU naming style and therefore fails linking when building for UEFI targets.
-def _link_static_cc_library_impl(ctx):
-    # Put an underscore so that we don't need to deal with potential "lib" prefix from user
-    # provided name.
-    libname = "_{}".format(ctx.label.name)
-
-    # Create symlink for both naming styles.
-    out_msvc_style = ctx.actions.declare_file("{}.lib".format(libname))
-    ctx.actions.symlink(output = out_msvc_style, target_file = ctx.files.cc_library[0])
-    out_linux_style = ctx.actions.declare_file("lib{}.a".format(libname))
-    ctx.actions.symlink(output = out_linux_style, target_file = ctx.files.cc_library[0])
-
-    # Construct and return a `CcInfo` for this rule that includes the library to link, so that
-    # other rust_library/cc_library can depend directly on this target.
-    library_to_link = cc_common.create_library_to_link(
-        actions = ctx.actions,
-        # Either is fine, since both yield the same linker option by Bazel.
-        static_library = out_linux_style,
-    )
-    linking_input = cc_common.create_linker_input(
-        owner = ctx.label,
-        libraries = depset([library_to_link]),
-        # Make sure both symlinks are generated.
-        additional_inputs = depset([out_msvc_style, out_linux_style]),
-    )
-    linking_context = cc_common.create_linking_context(linker_inputs = depset([linking_input]))
-    return [CcInfo(linking_context = linking_context)]
-
-link_static_cc_library = rule(
-    implementation = _link_static_cc_library_impl,
-    attrs = {
-        "cc_library": attr.label(),  # The cc_library() target for the static library.
-    },
-)
diff --git a/gbl/toolchain/gbl_workspace_util.bzl b/gbl/toolchain/gbl_workspace_util.bzl
deleted file mode 100644
index d14853a..0000000
--- a/gbl/toolchain/gbl_workspace_util.bzl
+++ /dev/null
@@ -1,199 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""
-This file contains rules and logic to initialize GBL workspace.
-"""
-
-def _abs_path(repo_ctx, path):
-    return repo_ctx.execute(["readlink", "-f", path]).stdout.strip("\n")
-
-def _dir_of(repo_ctx, path):
-    return repo_ctx.execute(["dirname", _abs_path(repo_ctx, path)]).stdout.strip("\n")
-
-def _gbl_llvm_prebuilts_impl(repo_ctx):
-    """Implementation for gbl_llvm_prebuilts
-
-    The repository rule sets up a repo for hosting LLVM distribution and Linux sysroot. They can
-    be provided manually via the `GBL_LLVM_PREBUILTS` and `GBL_LINUX_SYSROOT` environment
-    variables. If they don't exist, the top-level workspace needs to define them in repo
-    `@llvm_linux_x86_64_prebuilts` and `@linux_x86_64_sysroot` respectively.
-
-    Only Linux x86_64 platform is supported.
-    """
-    prebuilts = repo_ctx.os.environ.get("GBL_LLVM_PREBUILTS")
-    if prebuilts:
-        repo_ctx.symlink(prebuilts, "llvm-linux-x86")
-    else:
-        path = _dir_of(repo_ctx, repo_ctx.path(Label("@llvm_linux_x86_64_prebuilts//:BUILD.bazel")))
-        repo_ctx.symlink(path, "llvm-linux-x86")
-
-    # Linux host toolchain additionally needs a sysroot
-    linux_glibc = repo_ctx.os.environ.get("GBL_LINUX_SYSROOT")
-    if linux_glibc:
-        repo_ctx.symlink(linux_glibc, "linux_glibc")
-    else:
-        path = _dir_of(repo_ctx, repo_ctx.path(Label("@linux_x86_64_sysroot//:BUILD.bazel")))
-        repo_ctx.symlink(path, "linux_glibc")
-
-    # Get the bin directory so that we can access other LLVM tools by path.
-    gbl_llvm_bin_dir = _abs_path(repo_ctx, "llvm-linux-x86/bin")
-
-    # Create a info.bzl file in the assembled repo to export header/library/tool paths.
-    info_bzl_content = """
-def gbl_llvm_tool_path(tool_name):
-    return "{}/" + tool_name
-""".format(gbl_llvm_bin_dir)
-
-    # Get the builtin include directories.
-    clang = _abs_path(repo_ctx, "llvm-linux-x86/bin/clang")
-    llvm_resource_dir = repo_ctx.execute([clang, "--print-resource-dir"]).stdout.strip("\n")
-    info_bzl_content += """
-LLVM_PREBUILTS_C_INCLUDE = "{}"
-LLVM_PREBUILTS_CPP_INCLUDE = "{}"
-""".format(
-        "{}/include".format(llvm_resource_dir),
-        _abs_path(repo_ctx, "llvm-linux-x86/include/c++/v1"),
-    )
-
-    # Linux sysroot headers
-    sysroot_includes = [
-        _abs_path(repo_ctx, "linux_glibc/sysroot/usr/include"),
-        _abs_path(repo_ctx, "linux_glibc/sysroot/usr/include/x86_64-linux-gnu"),
-    ]
-    info_bzl_content += """
-LINUX_SYSROOT_INCLUDES = [{}]
-""".format(",".join(["\"{}\"".format(inc) for inc in sysroot_includes]))
-
-    repo_ctx.file("info.bzl", info_bzl_content)
-
-    # The following files are needed for defining bindgen toolchain, we symlink them out to the
-    # top level directory in case the the distribution repo has its own BUILD file which blocks
-    # direct access.
-    repo_ctx.symlink("llvm-linux-x86/bin/clang", "clang")
-
-    # In some prebuilt versions, "libc++.so" is a symlink to "libc++.so.1" etc. We need to use the
-    # same name as the actual library file name in cc_import(). Otherwise it complains it can't
-    # find the shared object.
-    libcpp_sharelib_path = _abs_path(repo_ctx, "llvm-linux-x86/lib/libc++.so")
-    libcpp_base_name = repo_ctx.execute(["basename", libcpp_sharelib_path]).stdout.strip("\n")
-    repo_ctx.symlink(libcpp_sharelib_path, libcpp_base_name)
-
-    # Do the same for libclang.so in case it's a symlink.
-    libclang_sharelib_path = _abs_path(repo_ctx, "llvm-linux-x86/lib/libclang.so")
-    libclang_basename = repo_ctx.execute(["basename", libclang_sharelib_path]).stdout.strip("\n")
-    repo_ctx.symlink(libclang_sharelib_path, libclang_basename)
-
-    # Add a BUILD file to make it a package
-    repo_ctx.file("BUILD", """
-package(
-    default_visibility = ["//visibility:public"],
-)
-
-exports_files(glob(["**/*"]))
-
-sh_binary(
-    name = "clang-bin",
-    srcs = [":clang"],
-)
-
-cc_import(
-    name = "libc++",
-    shared_library = ":{}",
-)
-
-cc_import(
-    name = "libclang",
-    shared_library = ":{}",
-)
-""".format(libcpp_base_name, libclang_basename))
-
-gbl_llvm_prebuilts = repository_rule(
-    implementation = _gbl_llvm_prebuilts_impl,
-    local = True,
-    environ = ["GBL_LLVM_PREBUILTS", "GBL_LINUX_SYSROOT"],
-)
-
-# The current rust version used by GBL. This needs to be manually updated when new version of
-# prebuilts is uploaded to https://android.googlesource.com/platform/prebuilts/rust/
-GBL_RUST_VERSION = "1.83.0"
-
-def _android_rust_prebuilts_impl(repo_ctx):
-    """Assemble a rust toolchain repo from the Android rust prebuilts repo.
-
-    The Android rust prebuilts repo is expected to be from
-    https://android.googlesource.com/platform/prebuilts/rust/.
-
-    Attributes:
-        path (String): Relative path to the Android rust prebuilts repo.
-        build_file (Label): Label of the build file to use.
-    """
-
-    # We only support linux x86 platform.
-    path = repo_ctx.workspace_root.get_child(repo_ctx.attr.path).get_child("linux-x86")
-
-    # Symlink everything into the assembled repo.
-    path = path.get_child(GBL_RUST_VERSION)
-    for entry in path.readdir():
-        # Ignore native BUILD file as we'll use override from `ctx.attr.build_file` instead.
-        if entry.basename == "BUILD" or entry.basename == "BUILD.bazel":
-            continue
-        repo_ctx.symlink(entry.realpath, entry.basename)
-
-    # Symlink the provided build file
-    repo_ctx.symlink(repo_ctx.attr.build_file, "BUILD")
-
-android_rust_prebuilts = repository_rule(
-    implementation = _android_rust_prebuilts_impl,
-    attrs = {
-        "path": attr.string(mandatory = True),
-        "build_file": attr.label(mandatory = True),
-    },
-)
-
-# This should match upstream Android defaults at
-# https://cs.android.com/android/platform/superproject/main/+/main:build/soong/rust/config/lints.go.
-#
-# We can't add these to the global flags in //toolchain:common_lint_opts
-# because it breaks some third-party packages which don't use these lints.
-# The global options also come later on the commandline so can't be overriden
-# by a package.
-#
-# Instead we add these to `rustc_flags` for all our modules explicitly.
-ANDROID_RUST_LINTS = [
-    "-A",
-    "deprecated",
-    "-A",
-    "unknown_lints",
-    "-D",
-    "missing-docs",
-    "-D",
-    "warnings",
-    "-D",
-    "unsafe_op_in_unsafe_fn",
-    "-A",
-    "clippy::disallowed_names",
-    "-A",
-    "clippy::type-complexity",
-    "-A",
-    "clippy::unnecessary_fallible_conversions",
-    "-A",
-    "clippy::unnecessary-wraps",
-    "-A",
-    "clippy::unusual-byte-groupings",
-    "-A",
-    "clippy::upper-case-acronyms",
-    "-D",
-    "clippy::undocumented_unsafe_blocks",
-]
diff --git a/gbl/tools/gen_gpt_disk.py b/gbl/tools/gen_gpt_disk.py
deleted file mode 100755
index 883880d..0000000
--- a/gbl/tools/gen_gpt_disk.py
+++ /dev/null
@@ -1,196 +0,0 @@
-#!/usr/bin/env python3
-#
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-"""Generate a GPT disk
-
-Example:
-
-The following command creates a 16mb disk file gpt.bin with two partitions:
-
-  1) "boot_a" of size 4096KB, with data initialized from "file_a",
-  2) "boot_b" of size 8192KB, with data initialized to zeroes.
-
-    gen_gpt_disk.py ./gpt.bin 16M
-        --partition "boot_a,4096K,<path to file_a>" \
-        --partition "boot_b,8192K,"
-
-All GUIDs will be non-deterministic for reproducibility.
-"""
-
-import argparse
-import os
-import pathlib
-import shutil
-import sys
-import subprocess
-import tempfile
-
-GPT_BLOCK_SIZE = 512
-
-# Some GPT libraries may expect a valid GUID here, these are just pre-generated
-# valid GUIDs for reproducibility.
-DISK_GUID = "b116114b-b6ae-4186-8231-b35104cb4c9e"
-PARTITION_GUIDS = [
-    "36bc51fd-c3d6-4109-a2ac-35bddd757e2a",
-    "42aaac2e-37e3-43ba-9930-42dfa96e6334",
-    "bdadfeca-879c-43e9-8f0d-8ef7da29b5e7",
-    "8d5b90b2-0d65-476b-8691-94f74fcac271",
-    "dafe682f-3f2b-4472-a1b8-a0f217701909",
-    "7097fd78-f559-461e-bb9b-db176a8169d8",
-    "c03dd176-117b-4e65-8205-37ebec007c1a",
-    "6d9159db-9b9e-4906-8fa4-31f5ffaef50e",
-    "4cdfda9f-23aa-4b27-9fea-24bb08238135",
-    "2a0a3df9-e8ef-4627-b4ce-ef1e847924f4",
-    "3c9b64f9-c659-4e5d-9d25-72028c46e6b8",
-    "95f142f9-d1f3-41ad-96dc-b969ee8242a1",
-    "5181811b-e836-4e66-bfe2-91aa86da515f",
-    "f2dbad77-38ac-43de-b4c7-2f7432d2339e",
-    "fc172d2c-f735-49a5-8be0-a475d0fc5be9",
-    "5ad48195-8e26-4496-a7e2-669028db2dce",
-    "f49a6965-8168-4c0c-8102-7b64a8176c25",
-    "be495262-5d9b-4fcb-9240-d9e84b195abe",
-    "c5ab3a8d-f898-420f-9039-a7445760fb0f",
-    "bc79912b-44bf-4ed8-8320-796ba47714d1",
-]
-
-
-def parse_args():
-    parser = argparse.ArgumentParser()
-    parser.add_argument("out", help="output file")
-    parser.add_argument(
-        "disk_size", type=str, help="disk size of the image. i.e. 64k, 1M etc"
-    )
-    parser.add_argument(
-        "--partition",
-        type=str,
-        action="append",
-        help="specifies a partition. Format should be"
-        "--partition=<part name>,<size>,<file name>",
-    )
-    return parser.parse_args()
-
-
-def parse_size_str(size_str: str) -> int:
-    """Parse size string into integer, taking into account unit.
-
-    Example:
-        2M, 2m -> 2*1024*1024
-        2K, 2k -> 2*1024
-        512 -> 512
-    """
-    size_str = size_str.lower()
-    if size_str.endswith("m"):
-        return int(size_str[:-1]) * 1024 * 1024
-    if size_str.endswith("k"):
-        return int(size_str[:-1]) * 1024
-    return int(size_str)
-
-
-def _append(src_file: str, offset: int, size: int, dst_file: str):
-    """Append a portion of a file to the end of another file
-
-    Args:
-        src_file: path to the source file
-        offset: offset in the source file
-        size: number of bytes to append
-        dst_file: destination file
-
-    Returns:
-        number of bytes actually copied.
-    """
-    with open(src_file, "rb") as src_f:
-        src_f.seek(offset, 0)
-        data = src_f.read(size)
-        if len(data) != size:
-            raise ValueError(f"Want {size} bytes from {src_file}, but got {len(data)}.")
-        with open(dst_file, "ab") as dst_f:
-            dst_f.write(data)
-    return size
-
-
-def main() -> int:
-    args = parse_args()
-    with tempfile.TemporaryDirectory() as temp_dir:
-        temp_disk = pathlib.Path(temp_dir) / "temp_disk"
-
-        disk_size = parse_size_str(args.disk_size)
-        temp_disk.write_bytes(disk_size * b"\x00")
-
-        part_start = 34 * GPT_BLOCK_SIZE  # MBR + GPT header + entries
-        partition_info = []
-        sgdisk_command = [
-            "sgdisk",
-            str(temp_disk),
-            "--clear",
-            "--set-alignment",
-            "1",
-            "--disk-guid",
-            DISK_GUID,
-        ]
-
-        for i, part in enumerate(args.partition, start=1):
-            name, size, file = part.split(",")
-            if not size:
-                raise ValueError("Must provide a size")
-            size = parse_size_str(size)
-
-            sgdisk_command += [
-                "--new",
-                f"{i}:{part_start // GPT_BLOCK_SIZE}:{(part_start + size) // GPT_BLOCK_SIZE - 1}",
-                "--partition-guid",
-                f"{i}:{PARTITION_GUIDS[i]}",
-                "--change-name",
-                f"{i}:{name}",
-            ]
-
-            partition_info.append((name, part_start, size, file))
-            part_start += size
-
-        res = subprocess.run(sgdisk_command, check=True, text=True)
-
-        # Create the final disk with partition content
-        dest_file = pathlib.Path(args.out)
-        dest_file.write_bytes(0 * b"\x00")
-        append_offset = 0
-        for name, start, size, file in partition_info:
-            end = start + size
-            # Fill gap
-            append_offset += _append(
-                str(temp_disk), append_offset, start - append_offset, args.out
-            )
-
-            # Copy over file
-            if file:
-                file_size = os.path.getsize(file)
-                if file_size > size:
-                    raise ValueError(f"{file} too large for {name}")
-                append_offset += _append(file, 0, file_size, args.out)
-
-            # If partition size greater than file size, copy the remaining
-            # partition content from `temp_disk` (zeroes)
-            append_offset += _append(
-                str(temp_disk), append_offset, end - append_offset, args.out
-            )
-
-        # Copy the remaining disk from `temp_disk` (zeroes + back up header/entries)
-        append_offset += _append(
-            str(temp_disk), append_offset, disk_size - append_offset, args.out
-        )
-
-    return 0
-
-
-if __name__ == "__main__":
-    sys.exit(main())
diff --git a/vts/Android.bp b/vts/Android.bp
index b21d87d..caecc9f 100644
--- a/vts/Android.bp
+++ b/vts/Android.bp
@@ -31,16 +31,3 @@ cc_test {
     ],
     require_root: true,
 }
-
-cc_test {
-    name: "VtsGblTest",
-    srcs: ["VtsGblTest.cpp"],
-    shared_libs: ["libbase"],
-    static_libs: ["libgmock"],
-    test_suites: [
-        "vts",
-    ],
-    test_options: {
-        vsr_min_shipping_api_level: 202504,
-    },
-}
diff --git a/vts/VtsGblTest.cpp b/vts/VtsGblTest.cpp
deleted file mode 100644
index d4a69e7..0000000
--- a/vts/VtsGblTest.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/file.h>
-#include <android-base/parseint.h>
-#include <android-base/properties.h>
-#include <android-base/strings.h>
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-class VtsGblTest : public testing::Test {};
-
-TEST_F(VtsGblTest, TestRunningProp) {
-  // TODO: Check assumptions. feature flag or API level?
-  const int32_t gbl_version =
-      android::base::GetIntProperty("ro.boot.gbl.version", -1);
-  const std::string build_number =
-      android::base::GetProperty("ro.boot.gbl.build_number", "");
-
-  if (gbl_version == -1) {
-    GTEST_SKIP() << "Device not booted with GBL";
-  }
-
-  GTEST_LOG_(INFO) << "GBL version: " << gbl_version;
-  GTEST_LOG_(INFO) << "GBL build_number: " << build_number;
-
-  if (android::base::StartsWith(build_number, "eng.")) {
-    GTEST_LOG_(WARNING) << "GBL is a local eng build";
-  }
-  ASSERT_THAT(build_number, testing::MatchesRegex("P?[0-9]+"))
-      << "Invalid build ID";
-  if (build_number[0] == 'P') {
-    GTEST_LOG_(INFO) << "GBL appears to be a presubmit build";
-  } else {
-    uint64_t build_incremental = 0;
-    EXPECT_TRUE(android::base::ParseUint(build_number, &build_incremental))
-        << "Failed to parse build id";
-    // TODO: Update this number after build script is updated to embed build id
-    // in artifact
-    // EXPECT_GE(build_incremental, 12345678)
-    //     << "GBL build number should be at least ...";
-  }
-}
```

