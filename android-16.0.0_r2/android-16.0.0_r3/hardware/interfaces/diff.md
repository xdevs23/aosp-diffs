```diff
diff --git a/atrace/OWNERS b/atrace/OWNERS
index d76ffa6d08..3434a2ecd6 100644
--- a/atrace/OWNERS
+++ b/atrace/OWNERS
@@ -1,3 +1,2 @@
 # Bug component: 837454
 
-wvw@google.com
diff --git a/audio/aidl/android/hardware/audio/core/IModule.aidl b/audio/aidl/android/hardware/audio/core/IModule.aidl
index 3c5f7f69a9..8803d3f575 100644
--- a/audio/aidl/android/hardware/audio/core/IModule.aidl
+++ b/audio/aidl/android/hardware/audio/core/IModule.aidl
@@ -851,6 +851,8 @@ interface IModule {
      * @throws EX_ILLEGAL_ARGUMENT If the device port config can not be found by the ID,
      *                             or the effect reference is invalid.
      * @throws EX_UNSUPPORTED_OPERATION If the module does not support device port effects.
+     * @throws EX_NULL_POINTER As an alternative to `EX_ILLEGAL_ARGUMENT` when the effect reference
+     *                         is null (depending on the implementation backend).
      */
     void addDeviceEffect(int portConfigId, in IEffect effect);
 
@@ -865,6 +867,8 @@ interface IModule {
      *                             or the effect reference is invalid, or the effect is
      *                             not currently applied to the port config.
      * @throws EX_UNSUPPORTED_OPERATION If the module does not support device port effects.
+     * @throws EX_NULL_POINTER As an alternative to `EX_ILLEGAL_ARGUMENT` when the effect reference
+     *                         is null (depending on the implementation backend).
      */
     void removeDeviceEffect(int portConfigId, in IEffect effect);
 
diff --git a/audio/aidl/android/hardware/audio/core/IStreamCommon.aidl b/audio/aidl/android/hardware/audio/core/IStreamCommon.aidl
index 543d9e266b..46d92a8d08 100644
--- a/audio/aidl/android/hardware/audio/core/IStreamCommon.aidl
+++ b/audio/aidl/android/hardware/audio/core/IStreamCommon.aidl
@@ -125,6 +125,8 @@ interface IStreamCommon {
      * @throws EX_ILLEGAL_ARGUMENT If the effect reference is invalid.
      * @throws EX_ILLEGAL_STATE If the stream is closed.
      * @throws EX_UNSUPPORTED_OPERATION If the module does not support audio effects.
+     * @throws EX_NULL_POINTER As an alternative to `EX_ILLEGAL_ARGUMENT` when the effect reference
+     *                         is null (depending on the implementation backend).
      */
     void addEffect(in IEffect effect);
 
@@ -138,6 +140,8 @@ interface IStreamCommon {
      *                             not currently applied to the stream.
      * @throws EX_ILLEGAL_STATE If the stream is closed.
      * @throws EX_UNSUPPORTED_OPERATION If the module does not support audio effects.
+     * @throws EX_NULL_POINTER As an alternative to `EX_ILLEGAL_ARGUMENT` when the effect reference
+     *                         is null (depending on the implementation backend).
      */
     void removeEffect(in IEffect effect);
 }
diff --git a/audio/aidl/common/include/Utils.h b/audio/aidl/common/include/Utils.h
index dc411ff255..ea2d5129ab 100644
--- a/audio/aidl/common/include/Utils.h
+++ b/audio/aidl/common/include/Utils.h
@@ -52,6 +52,13 @@ namespace aidl::android::hardware::audio::common {
 // TODO: b/275135031 - move this string to AIDL interfaces.
 static constexpr char kDumpFromAudioServerArgument[] = "dump_from_audioserver";
 
+inline bool hasArgument(const char** args, uint32_t numArgs, const char* arg) {
+    for (uint32_t i = 0; i < numArgs; ++i) {
+        if (strcmp(args[i], arg) == 0) return true;
+    }
+    return false;
+}
+
 // Some values are reserved for use by the system code only.
 // HALs must not accept or emit values outside from the provided list.
 constexpr std::array<::aidl::android::media::audio::common::AudioMode, 5> kValidAudioModes = {
diff --git a/audio/aidl/default/Android.bp b/audio/aidl/default/Android.bp
index a9ecdc242b..48c1fefcf5 100644
--- a/audio/aidl/default/Android.bp
+++ b/audio/aidl/default/Android.bp
@@ -367,3 +367,13 @@ prebuilt_etc {
     sub_dir: "vintf",
     installable: false,
 }
+
+prebuilt_etc {
+    name: "audio_effects_config.xml",
+    src: "audio_effects_config.xml",
+    vendor: true,
+    enabled: select(soong_config_variable("hardware_interfaces_audio", "use_default_audio_effects_config"), {
+        true: true,
+        default: false,
+    }),
+}
diff --git a/audio/aidl/default/EffectConfig.cpp b/audio/aidl/default/EffectConfig.cpp
index fa12056f55..0d883acd76 100644
--- a/audio/aidl/default/EffectConfig.cpp
+++ b/audio/aidl/default/EffectConfig.cpp
@@ -311,6 +311,7 @@ bool EffectConfig::findUuid(const std::pair<std::string, struct EffectLibraries>
     V("downmix", Downmix)                                  \
     V("dynamics_processing", DynamicsProcessing)           \
     V("equalizer", Equalizer)                              \
+    V("eraser", Eraser)                                    \
     V("extensioneffect", Extension)                        \
     V("haptic_generator", HapticGenerator)                 \
     V("loudness_enhancer", LoudnessEnhancer)               \
diff --git a/audio/aidl/default/Module.cpp b/audio/aidl/default/Module.cpp
index aa624ff0ee..a3ce20476b 100644
--- a/audio/aidl/default/Module.cpp
+++ b/audio/aidl/default/Module.cpp
@@ -623,11 +623,21 @@ ndk::ScopedAStatus Module::updateStreamsConnectedState(const AudioPatch& oldPatc
 }
 
 binder_status_t Module::dump(int fd, const char** args, uint32_t numArgs) {
+    if (::aidl::android::hardware::audio::common::hasArgument(
+                args, numArgs,
+                ::aidl::android::hardware::audio::common::kDumpFromAudioServerArgument)) {
+        std::ostringstream s;
+        s << mType;
+        // Not needed in the case of a dedicated module dump.
+        dprintf(fd, "\n[Module %s] ", s.str().c_str());
+    }
+    dprintf(fd, "Stream dumps:\n");
     for (const auto& portConfig : getConfig().portConfigs) {
         if (portConfig.ext.getTag() == AudioPortExt::Tag::mix) {
             getStreams().dump(portConfig.id, fd, args, numArgs);
         }
     }
+    dprintf(fd, "\n");
     return STATUS_OK;
 }
 
diff --git a/audio/aidl/default/ModulePrimary.cpp b/audio/aidl/default/ModulePrimary.cpp
index 6cb92519a3..6648068c93 100644
--- a/audio/aidl/default/ModulePrimary.cpp
+++ b/audio/aidl/default/ModulePrimary.cpp
@@ -114,14 +114,14 @@ ndk::ScopedAStatus ModulePrimary::createMmapBuffer(const AudioPortConfig& portCo
     }
     desc->sharedMemory.fd = ndk::ScopedFileDescriptor(fd);
     desc->sharedMemory.size = bufferSizeBytes;
-    desc->burstSizeFrames = bufferSizeFrames / 2;
-    desc->flags = 0;
+    desc->burstSizeFrames = bufferSizeFrames / 4;
+    desc->flags = 1 << MmapBufferDescriptor::FLAG_INDEX_APPLICATION_SHAREABLE;
     LOG(DEBUG) << __func__ << ": " << desc->toString();
     return ndk::ScopedAStatus::ok();
 }
 
 int32_t ModulePrimary::getNominalLatencyMs(const AudioPortConfig& portConfig) {
-    static constexpr int32_t kLowLatencyMs = 5;
+    static constexpr int32_t kLowLatencyMs = 10;
     // 85 ms is chosen considering 4096 frames @ 48 kHz. This is the value which allows
     // the virtual Android device implementation to pass CTS. Hardware implementations
     // should have significantly lower latency.
diff --git a/audio/aidl/default/Stream.cpp b/audio/aidl/default/Stream.cpp
index 873fc48534..a6c444c76f 100644
--- a/audio/aidl/default/Stream.cpp
+++ b/audio/aidl/default/Stream.cpp
@@ -572,7 +572,7 @@ StreamOutWorkerLogic::Status StreamOutWorkerLogic::cycle() {
                         if (asyncCallback == nullptr ||
                             mState != StreamDescriptor::State::DRAIN_PAUSED) {
                             mState = StreamDescriptor::State::PAUSED;
-                        } else {
+                        } else if (mDrainState != DrainState::EN_SENT) {
                             mState = StreamDescriptor::State::TRANSFER_PAUSED;
                         }
                     } else if (mState == StreamDescriptor::State::IDLE ||
diff --git a/audio/aidl/default/XsdcConversion.cpp b/audio/aidl/default/XsdcConversion.cpp
index 584590362a..1a5f7f3c9d 100644
--- a/audio/aidl/default/XsdcConversion.cpp
+++ b/audio/aidl/default/XsdcConversion.cpp
@@ -25,6 +25,7 @@
 
 #include <aidl/android/media/audio/common/AudioPort.h>
 #include <aidl/android/media/audio/common/AudioPortConfig.h>
+#include <aidl/android/media/audio/common/AudioProductStrategyType.h>
 #include <media/AidlConversionCppNdk.h>
 #include <media/TypeConverter.h>
 #include <media/convert.h>
@@ -59,6 +60,7 @@ using aidl::android::media::audio::common::AudioPortConfig;
 using aidl::android::media::audio::common::AudioPortDeviceExt;
 using aidl::android::media::audio::common::AudioPortExt;
 using aidl::android::media::audio::common::AudioPortMixExt;
+using aidl::android::media::audio::common::AudioProductStrategyType;
 using aidl::android::media::audio::common::AudioProfile;
 using aidl::android::media::audio::common::AudioSource;
 using aidl::android::media::audio::common::AudioStreamType;
@@ -817,21 +819,20 @@ ConversionResult<AudioHalVolumeCurve::CurvePoint> convertCurvePointToAidl(
     return aidlCurvePoint;
 }
 
-/**
- * The hard coded id must be in sync with policy.h definition of legacy strategy ids.
- */
 std::unordered_map<std::string, int> getLegacyProductStrategyMap() {
 #define STRATEGY_ENTRY(name, id) {"STRATEGY_" #name, static_cast<int>(id)}
 
-        return {STRATEGY_ENTRY(MEDIA, 5),
-                STRATEGY_ENTRY(PHONE, 0),
-                STRATEGY_ENTRY(SONIFICATION, 1),
-                STRATEGY_ENTRY(SONIFICATION_RESPECTFUL, 4),
-                STRATEGY_ENTRY(DTMF, 6),
-                STRATEGY_ENTRY(ENFORCED_AUDIBLE, 2),
-                STRATEGY_ENTRY(CALL_ASSISTANT, 7),
-                STRATEGY_ENTRY(TRANSMITTED_THROUGH_SPEAKER,8),
-                STRATEGY_ENTRY(ACCESSIBILITY, 3)};
+    return {STRATEGY_ENTRY(MEDIA, AudioProductStrategyType::MEDIA),
+            STRATEGY_ENTRY(PHONE, AudioProductStrategyType::PHONE),
+            STRATEGY_ENTRY(SONIFICATION, AudioProductStrategyType::SONIFICATION),
+            STRATEGY_ENTRY(SONIFICATION_RESPECTFUL,
+                           AudioProductStrategyType::SONIFICATION_RESPECTFUL),
+            STRATEGY_ENTRY(DTMF, AudioProductStrategyType::DTMF),
+            STRATEGY_ENTRY(ENFORCED_AUDIBLE, AudioProductStrategyType::ENFORCED_AUDIBLE),
+            STRATEGY_ENTRY(CALL_ASSISTANT, AudioProductStrategyType::SYS_RESERVED_CALL_ASSISTANT),
+            STRATEGY_ENTRY(TRANSMITTED_THROUGH_SPEAKER,
+                           AudioProductStrategyType::TRANSMITTED_THROUGH_SPEAKER),
+            STRATEGY_ENTRY(ACCESSIBILITY, AudioProductStrategyType::ACCESSIBILITY)};
 #undef STRATEGY_ENTRY
 }
 
diff --git a/audio/aidl/default/apex/com.android.hardware.audio/Android.bp b/audio/aidl/default/apex/com.android.hardware.audio/Android.bp
index 8fa429a3c0..510fee5f84 100644
--- a/audio/aidl/default/apex/com.android.hardware.audio/Android.bp
+++ b/audio/aidl/default/apex/com.android.hardware.audio/Android.bp
@@ -31,6 +31,7 @@ apex {
         "libdynamicsprocessingaidl",
         "libenvreverbsw",
         "libequalizersw",
+        "liberaser",
         "libextensioneffect",
         "libhapticgeneratoraidl",
         "libloudnessenhanceraidl",
@@ -47,6 +48,8 @@ apex {
         "android.hardware.audio.service-aidl.example.rc",
         "android.hardware.audio.service-aidl.xml",
         "android.hardware.bluetooth.audio.xml",
+        "audio_eraser_classifier_model",
+        "audio_eraser_separator_model",
     ],
     required: [
         "aidl_audio_set_configurations_bfbs",
diff --git a/audio/aidl/default/audio_effects.mk b/audio/aidl/default/audio_effects.mk
new file mode 100644
index 0000000000..0b2e4da2de
--- /dev/null
+++ b/audio/aidl/default/audio_effects.mk
@@ -0,0 +1,18 @@
+#
+# Copyright (C) 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+PRODUCT_PACKAGES += audio_effects_config.xml
+$(call soong_config_set_bool,hardware_interfaces_audio,use_default_audio_effects_config,true)
\ No newline at end of file
diff --git a/audio/aidl/default/audio_effects_config.xml b/audio/aidl/default/audio_effects_config.xml
index 2e860d89fc..d9ac0e5d60 100644
--- a/audio/aidl/default/audio_effects_config.xml
+++ b/audio/aidl/default/audio_effects_config.xml
@@ -36,7 +36,7 @@
         <library name="downmix" path="libdownmixaidl.so"/>
         <library name="dynamics_processing" path="libdynamicsprocessingaidl.so"/>
         <library name="equalizersw" path="libequalizersw.so"/>
-        <library name="erasersw" path="liberasersw.so"/>
+        <library name="eraser" path="liberaser.so"/>
         <library name="haptic_generator" path="libhapticgeneratoraidl.so"/>
         <library name="loudness_enhancer" path="libloudnessenhanceraidl.so"/>
         <library name="nssw" path="libnssw.so"/>
@@ -76,7 +76,7 @@
         <effect name="bassboost" library="bundle" uuid="8631f300-72e2-11df-b57e-0002a5d5c51b"/>
         <effect name="downmix" library="downmix" uuid="93f04452-e4fe-41cc-91f9-e475b6d1d69f"/>
         <effect name="dynamics_processing" library="dynamics_processing" uuid="e0e6539b-1781-7261-676f-6d7573696340"/>
-        <effect name="eraser" library="erasersw" uuid="fa81ab46-588b-11ed-9b6a-0242ac120002"/>
+        <effect name="eraser" library="eraser" uuid="fa81ad26-588b-11ed-9b6a-0242ac120002"/>
         <effect name="haptic_generator" library="haptic_generator" uuid="97c4acd1-8b82-4f2f-832e-c2fe5d7a9931"/>
         <effect name="loudness_enhancer" library="loudness_enhancer" uuid="fa415329-2034-4bea-b5dc-5b381c8d1e2c"/>
         <effect name="reverb_env_aux" library="reverb" uuid="4a387fc0-8ab3-11df-8bad-0002a5d5c51b"/>
diff --git a/audio/aidl/default/bluetooth/DevicePortProxy.cpp b/audio/aidl/default/bluetooth/DevicePortProxy.cpp
index d772c20090..7651a5f1f0 100644
--- a/audio/aidl/default/bluetooth/DevicePortProxy.cpp
+++ b/audio/aidl/default/bluetooth/DevicePortProxy.cpp
@@ -30,6 +30,7 @@ using aidl::android::hardware::bluetooth::audio::AudioConfiguration;
 using aidl::android::hardware::bluetooth::audio::BluetoothAudioSessionControl;
 using aidl::android::hardware::bluetooth::audio::BluetoothAudioStatus;
 using aidl::android::hardware::bluetooth::audio::ChannelMode;
+using aidl::android::hardware::bluetooth::audio::LatencyMode;
 using aidl::android::hardware::bluetooth::audio::PcmConfiguration;
 using aidl::android::hardware::bluetooth::audio::PortStatusCallbacks;
 using aidl::android::hardware::bluetooth::audio::PresentationPosition;
@@ -66,10 +67,11 @@ std::ostream& operator<<(std::ostream& os, const BluetoothStreamState& state) {
     }
 }
 
-BluetoothAudioPortAidl::BluetoothAudioPortAidl()
+BluetoothAudioPortAidl::BluetoothAudioPortAidl(std::optional<bool> supportsLowLatency)
     : mCookie(::aidl::android::hardware::bluetooth::audio::kObserversCookieUndefined),
       mState(BluetoothStreamState::DISABLED),
-      mSessionType(SessionType::UNKNOWN) {}
+      mSessionType(SessionType::UNKNOWN),
+      mSupportsLowLatency(supportsLowLatency) {}
 
 BluetoothAudioPortAidl::~BluetoothAudioPortAidl() {
     unregisterPort();
@@ -91,10 +93,14 @@ bool BluetoothAudioPortAidl::registerPort(const AudioDeviceDescription& descript
     auto session_changed_cb = [port = this](uint16_t cookie) {
         port->sessionChangedHandler(cookie);
     };
-    // TODO: Add audio_config_changed_cb
+    auto low_latency_allowed_cb = [port = this](uint16_t cookie, bool allowed) {
+        port->lowLatencyAllowedHandler(cookie, allowed);
+    };
+
     PortStatusCallbacks cbacks = {
             .control_result_cb_ = control_result_cb,
             .session_changed_cb_ = session_changed_cb,
+            .low_latency_mode_allowed_cb_ = low_latency_allowed_cb,
     };
     mCookie = BluetoothAudioSessionControl::RegisterControlResultCback(mSessionType, cbacks);
     auto isOk = (mCookie != ::aidl::android::hardware::bluetooth::audio::kObserversCookieUndefined);
@@ -107,6 +113,8 @@ bool BluetoothAudioPortAidl::registerPort(const AudioDeviceDescription& descript
 }
 
 bool BluetoothAudioPortAidl::initSessionType(const AudioDeviceDescription& description) {
+    ::aidl::android::hardware::bluetooth::audio::SessionType fallbackSessionType =
+            SessionType::UNKNOWN;
     if (description.connection == AudioDeviceDescription::CONNECTION_BT_A2DP &&
         (description.type == AudioDeviceType::OUT_DEVICE ||
          description.type == AudioDeviceType::OUT_HEADPHONE ||
@@ -125,11 +133,13 @@ bool BluetoothAudioPortAidl::initSessionType(const AudioDeviceDescription& descr
         LOG(VERBOSE) << __func__ << ": device=AUDIO_DEVICE_OUT_BLE_HEADSET (MEDIA/VOICE) ("
                      << description.toString() << ")";
         mSessionType = SessionType::LE_AUDIO_SOFTWARE_ENCODING_DATAPATH;
+        fallbackSessionType = SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH;
     } else if (description.connection == AudioDeviceDescription::CONNECTION_BT_LE &&
                description.type == AudioDeviceType::OUT_SPEAKER) {
         LOG(VERBOSE) << __func__ << ": device=AUDIO_DEVICE_OUT_BLE_SPEAKER (MEDIA) ("
                      << description.toString() << ")";
         mSessionType = SessionType::LE_AUDIO_SOFTWARE_ENCODING_DATAPATH;
+        fallbackSessionType = SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH;
     } else if (description.connection == AudioDeviceDescription::CONNECTION_BT_LE &&
                description.type == AudioDeviceType::IN_HEADSET) {
         LOG(VERBOSE) << __func__ << ": device=AUDIO_DEVICE_IN_BLE_HEADSET (VOICE) ("
@@ -146,6 +156,19 @@ bool BluetoothAudioPortAidl::initSessionType(const AudioDeviceDescription& descr
     }
 
     if (!BluetoothAudioSessionControl::IsSessionReady(mSessionType)) {
+        if (fallbackSessionType != SessionType::UNKNOWN) {
+            LOG(WARNING) << __func__
+                         << ": Retry fallback session_type=" << toString(fallbackSessionType)
+                         << " for session_type=" << toString(mSessionType);
+            if (BluetoothAudioSessionControl::IsSessionReady(fallbackSessionType, false)) {
+                mSessionType = fallbackSessionType;
+                return true;
+            } else {
+                LOG(ERROR) << __func__
+                           << ": fallback session_type=" << toString(fallbackSessionType)
+                           << " is not ready";
+            }
+        }
         LOG(ERROR) << __func__ << ": device=" << description.toString()
                    << ", session_type=" << toString(mSessionType) << " is not ready";
         return false;
@@ -155,7 +178,7 @@ bool BluetoothAudioPortAidl::initSessionType(const AudioDeviceDescription& descr
 
 void BluetoothAudioPortAidl::unregisterPort() {
     if (!inUse()) {
-        LOG(WARNING) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(WARNING) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return;
     }
     BluetoothAudioSessionControl::UnregisterControlResultCback(mSessionType, mCookie);
@@ -171,65 +194,77 @@ void BluetoothAudioPortAidl::controlResultHandler(uint16_t cookie,
         return;
     }
     if (mCookie != cookie) {
-        LOG(ERROR) << "control_result_cb: proxy of device port (cookie="
-                   << StringPrintf("%#hx", cookie) << ") is corrupted";
+        LOG(ERROR) << "control_result_cb: proxy of device port is corrupted "
+                   << "cookie=" << StringPrintf("%#hx", cookie) << ", expected "
+                   << StringPrintf("%#hx", mCookie);
         return;
     }
     BluetoothStreamState previous_state = mState;
-    LOG(INFO) << "control_result_cb:" << debugMessage() << ", previous_state=" << previous_state
-              << ", status=" << toString(status);
-
+    ::android::base::LogSeverity severity = ::android::base::FATAL;
     switch (previous_state) {
         case BluetoothStreamState::STARTED:
             /* Only Suspend signal can be send in STARTED state*/
             if (status == BluetoothAudioStatus::RECONFIGURATION ||
                 status == BluetoothAudioStatus::SUCCESS) {
                 mState = BluetoothStreamState::STANDBY;
+                severity = ::android::base::INFO;
             } else {
-                LOG(WARNING) << StringPrintf(
-                        "control_result_cb: status=%s failure for session_type= %s, cookie=%#hx, "
-                        "previous_state=%#hhx",
-                        toString(status).c_str(), toString(mSessionType).c_str(), mCookie,
-                        previous_state);
+                severity = ::android::base::WARNING;
             }
             break;
         case BluetoothStreamState::STARTING:
             if (status == BluetoothAudioStatus::SUCCESS) {
                 mState = BluetoothStreamState::STARTED;
+                severity = ::android::base::INFO;
             } else {
                 // Set to standby since the stack may be busy switching between outputs
-                LOG(WARNING) << StringPrintf(
-                        "control_result_cb: status=%s failure for session_type= %s, cookie=%#hx, "
-                        "previous_state=%#hhx",
-                        toString(status).c_str(), toString(mSessionType).c_str(), mCookie,
-                        previous_state);
                 mState = BluetoothStreamState::STANDBY;
+                severity = ::android::base::WARNING;
             }
             break;
         case BluetoothStreamState::SUSPENDING:
             if (status == BluetoothAudioStatus::SUCCESS) {
                 mState = BluetoothStreamState::STANDBY;
+                severity = ::android::base::INFO;
             } else {
-                // It will be failed if the headset is disconnecting, and set to disable
+                // Will fail if the headset is disconnecting, so set to disable
                 // to wait for re-init again
-                LOG(WARNING) << StringPrintf(
-                        "control_result_cb: status=%s failure for session_type= %s, cookie=%#hx, "
-                        "previous_state=%#hhx",
-                        toString(status).c_str(), toString(mSessionType).c_str(), mCookie,
-                        previous_state);
                 mState = BluetoothStreamState::DISABLED;
+                severity = ::android::base::WARNING;
             }
             break;
         default:
-            LOG(ERROR) << "control_result_cb: unexpected previous_state="
-                       << StringPrintf(
-                                  "control_result_cb: status=%s failure for session_type= %s, "
-                                  "cookie=%#hx, previous_state=%#hhx",
-                                  toString(status).c_str(), toString(mSessionType).c_str(), mCookie,
-                                  previous_state);
-            return;
+            severity = ::android::base::ERROR;
+    }
+    if (previous_state != mState) {
+        LOG(severity) << "control_result_cb" << debugMessage() << ", status=" << toString(status)
+                      << ", " << previous_state << " -> " << mState;
+    } else {
+        LOG(severity) << "control_result_cb" << debugMessage() << ", status=" << toString(status)
+                      << ", " << previous_state;
+    }
+    if (severity != ::android::base::ERROR) {
+        mInternalCv.notify_all();
+    }
+}
+
+void BluetoothAudioPortAidl::lowLatencyAllowedHandler(uint16_t cookie, bool allowed) {
+    if (mCookie != cookie) {
+        LOG(ERROR) << "low_latency_allowed_cb: proxy of device port (cookie="
+                   << StringPrintf("%#hx", cookie) << ") is corrupted";
+        return;
+    }
+    LOG(INFO) << "low_latency_allowed_cb:" << debugMessage() << ", allowed=" << allowed;
+    std::vector<LatencyMode> latency_modes;
+    if (!getRecommendedLatencyModes(&latency_modes)) return;
+    std::shared_ptr<BluetoothAudioPortCallbacks> callbacks;
+    {
+        std::lock_guard guard(mCvMutex);
+        callbacks = mCallbacks;
+    }
+    if (callbacks) {
+        callbacks->onRecommendedLatencyModeChanged(latency_modes);
     }
-    mInternalCv.notify_all();
 }
 
 void BluetoothAudioPortAidl::sessionChangedHandler(uint16_t cookie) {
@@ -239,14 +274,15 @@ void BluetoothAudioPortAidl::sessionChangedHandler(uint16_t cookie) {
         return;
     }
     if (mCookie != cookie) {
-        LOG(ERROR) << "session_changed_cb: proxy of device port (cookie="
-                   << StringPrintf("%#hx", cookie) << ") is corrupted";
+        LOG(ERROR) << "session_changed_cb: proxy of device port is corrupted "
+                   << "cookie=" << StringPrintf("%#hx", cookie) << ", expected "
+                   << StringPrintf("%#hx", mCookie);
         return;
     }
     BluetoothStreamState previous_state = mState;
-    LOG(VERBOSE) << "session_changed_cb:" << debugMessage()
-                 << ", previous_state=" << previous_state;
     mState = BluetoothStreamState::DISABLED;
+    LOG(DEBUG) << "session_changed_cb" << debugMessage() << ", " << previous_state << " -> "
+               << mState;
     mInternalCv.notify_all();
 }
 
@@ -256,14 +292,14 @@ bool BluetoothAudioPortAidl::inUse() const {
 
 bool BluetoothAudioPortAidl::getPreferredDataIntervalUs(size_t& interval_us) const {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
 
     const AudioConfiguration& hal_audio_cfg =
             BluetoothAudioSessionControl::GetAudioConfig(mSessionType);
     if (hal_audio_cfg.getTag() != AudioConfiguration::pcmConfig) {
-        LOG(ERROR) << __func__ << ": unsupported audio cfg tag";
+        LOG(ERROR) << __func__ << debugMessage() << ": unsupported audio cfg tag";
         return false;
     }
 
@@ -271,22 +307,41 @@ bool BluetoothAudioPortAidl::getPreferredDataIntervalUs(size_t& interval_us) con
     return true;
 }
 
+bool BluetoothAudioPortAidl::getRecommendedLatencyModes(std::vector<LatencyMode>* latency_modes) {
+    if (!inUse()) {
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
+        return false;
+    }
+    *latency_modes = BluetoothAudioSessionControl::GetSupportedLatencyModes(mSessionType);
+    LOG(INFO) << __func__ << debugMessage() << ": "
+              << ::android::internal::ToString(*latency_modes);
+    {
+        std::lock_guard guard(mCvMutex);
+        mSupportsLowLatency = std::find(latency_modes->begin(), latency_modes->end(),
+                                        LatencyMode::LOW_LATENCY) != latency_modes->end();
+    }
+    return true;
+}
+
 bool BluetoothAudioPortAidl::loadAudioConfig(PcmConfiguration& audio_cfg) {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
 
     const AudioConfiguration& hal_audio_cfg =
             BluetoothAudioSessionControl::GetAudioConfig(mSessionType);
     if (hal_audio_cfg.getTag() != AudioConfiguration::pcmConfig) {
-        LOG(ERROR) << __func__ << ": unsupported audio cfg tag";
+        LOG(ERROR) << __func__ << debugMessage()
+                   << ": unsupported audio cfg tag: " << toString(hal_audio_cfg.getTag());
         return false;
     }
     audio_cfg = hal_audio_cfg.get<AudioConfiguration::pcmConfig>();
-    LOG(VERBOSE) << __func__ << debugMessage() << ", state*=" << getState() << ", PcmConfig=["
+    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState() << ", PcmConfig=["
                  << audio_cfg.toString() << "]";
     if (audio_cfg.channelMode == ChannelMode::UNKNOWN) {
+        LOG(ERROR) << __func__ << debugMessage()
+                   << ": unsupported channel mode: " << toString(audio_cfg.channelMode);
         return false;
     }
     return true;
@@ -298,180 +353,178 @@ bool BluetoothAudioPortAidlOut::loadAudioConfig(PcmConfiguration& audio_cfg) {
     if (audio_cfg.channelMode == ChannelMode::MONO && audio_cfg.bitsPerSample == 16) {
         mIsStereoToMono = true;
         audio_cfg.channelMode = ChannelMode::STEREO;
-        LOG(INFO) << __func__ << ": force channels = to be AUDIO_CHANNEL_OUT_STEREO";
+        LOG(INFO) << __func__ << debugMessage()
+                  << ": force channels = to be AUDIO_CHANNEL_OUT_STEREO";
     }
     return true;
 }
 
 bool BluetoothAudioPortAidl::standby() {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
     std::lock_guard guard(mCvMutex);
-    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState() << " request";
+    BluetoothStreamState previous_state = mState;
+    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << mState << " request";
     if (mState == BluetoothStreamState::DISABLED) {
         mState = BluetoothStreamState::STANDBY;
-        LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState() << " done";
+        LOG(INFO) << __func__ << debugMessage() << ", " << previous_state << " -> " << mState;
         return true;
     }
     return false;
 }
 
-bool BluetoothAudioPortAidl::condWaitState(BluetoothStreamState state) {
+bool BluetoothAudioPortAidl::condWaitState(std::unique_lock<std::mutex>* lock) {
     const auto waitTime = std::chrono::milliseconds(kMaxWaitingTimeMs);
-    std::unique_lock lock(mCvMutex);
-    base::ScopedLockAssertion lock_assertion(mCvMutex);
-    switch (state) {
-        case BluetoothStreamState::STARTING: {
-            LOG(VERBOSE) << __func__ << debugMessage() << " waiting for STARTED";
-            mInternalCv.wait_for(lock, waitTime, [this] {
-                base::ScopedLockAssertion lock_assertion(mCvMutex);
-                return mState != BluetoothStreamState::STARTING;
-            });
-            return mState == BluetoothStreamState::STARTED;
-        }
-        case BluetoothStreamState::SUSPENDING: {
-            LOG(VERBOSE) << __func__ << debugMessage() << " waiting for SUSPENDED";
-            mInternalCv.wait_for(lock, waitTime, [this] {
-                base::ScopedLockAssertion lock_assertion(mCvMutex);
-                return mState != BluetoothStreamState::SUSPENDING;
-            });
-            return mState == BluetoothStreamState::STANDBY;
-        }
-        default:
-            LOG(WARNING) << __func__ << debugMessage() << " waiting for KNOWN";
-            return false;
-    }
+    const auto state = mState;
+    if (state == BluetoothStreamState::STARTING || state == BluetoothStreamState::SUSPENDING) {
+        LOG(DEBUG) << __func__ << debugMessage() << " waiting to change from " << state;
+        mInternalCv.wait_for(*lock, waitTime, [this, state] {
+            base::ScopedLockAssertion lock_assertion(mCvMutex);
+            return mState != state;
+        });
+        const bool expected =
+                mState == (state == BluetoothStreamState::STARTING ? BluetoothStreamState::STARTED
+                                                                   : BluetoothStreamState::STANDBY);
+        LOG(expected ? INFO : WARNING)
+                << __func__ << debugMessage() << ", " << state << " -> " << mState;
+        return expected;
+    }
+    LOG(ERROR) << __func__ << debugMessage() << " called to wait when in " << state;
     return false;
 }
 
 bool BluetoothAudioPortAidl::start() {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
-    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState()
-                 << ", mono=" << (mIsStereoToMono ? "true" : "false") << " request";
 
+    bool retval = false;
     {
         std::unique_lock lock(mCvMutex);
         base::ScopedLockAssertion lock_assertion(mCvMutex);
+        LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << mState
+                     << ", mono=" << (mIsStereoToMono ? "true" : "false") << " request";
         if (mState == BluetoothStreamState::STARTED) {
             return true;  // nop, return
+        } else if (mState == BluetoothStreamState::DISABLED) {
+            return false; // avoid logspam when called from `transfer`
         } else if (mState == BluetoothStreamState::SUSPENDING ||
                    mState == BluetoothStreamState::STARTING) {
             /* If port is in transient state, give some time to respond */
-            auto state_ = mState;
-            lock.unlock();
-            if (!condWaitState(state_)) {
-                LOG(ERROR) << __func__ << debugMessage() << ", state=" << getState() << " failure";
+            if (!condWaitState(&lock)) {
+                LOG(ERROR) << __func__ << debugMessage() << ", state=" << mState << " failure";
                 return false;
             }
         }
-    }
-
-    bool retval = false;
-    {
-        std::unique_lock lock(mCvMutex);
-        base::ScopedLockAssertion lock_assertion(mCvMutex);
         if (mState == BluetoothStreamState::STARTED) {
             retval = true;
         } else if (mState == BluetoothStreamState::STANDBY) {
+            if (!mSupportsLowLatency.has_value()) {
+                std::vector<LatencyMode> latency_modes;
+                getRecommendedLatencyModes(&latency_modes);
+            }
+            const bool low_latency = mSupportsLowLatency.value_or(false);
             mState = BluetoothStreamState::STARTING;
             lock.unlock();
-            if (BluetoothAudioSessionControl::StartStream(mSessionType)) {
-                retval = condWaitState(BluetoothStreamState::STARTING);
+            const bool startSuccess =
+                    BluetoothAudioSessionControl::StartStream(mSessionType, low_latency);
+            lock.lock();
+            if (startSuccess && mState == BluetoothStreamState::STARTING) {
+                retval = condWaitState(&lock);
+            } else if (startSuccess && mState == BluetoothStreamState::STARTED) {
+                retval = true;
             } else {
-                LOG(ERROR) << __func__ << debugMessage() << ", state=" << getState()
-                           << " Hal fails";
+                // !startSuccess => no session instance
+                const BluetoothStreamState newState = startSuccess ? BluetoothStreamState::STANDBY
+                                                                   : BluetoothStreamState::DISABLED;
+                LOG(ERROR) << __func__ << debugMessage() << ", startSuccess=" << startSuccess
+                           << ", state=" << mState << " -> " << newState;
+                mState = newState;
             }
         }
+        if (retval) {
+            LOG(INFO) << __func__ << debugMessage() << ", state=" << mState
+                      << ", mono=" << (mIsStereoToMono ? "true" : "false") << " done";
+        } else {
+            LOG(ERROR) << __func__ << debugMessage() << ", state=" << mState << " failure";
+        }
     }
-
-    if (retval) {
-        LOG(INFO) << __func__ << debugMessage() << ", state=" << getState()
-                  << ", mono=" << (mIsStereoToMono ? "true" : "false") << " done";
-    } else {
-        LOG(ERROR) << __func__ << debugMessage() << ", state=" << getState() << " failure";
-    }
-
     return retval;  // false if any failure like timeout
 }
 
 bool BluetoothAudioPortAidl::suspend() {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
-    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState() << " request";
 
+    bool retval = false;
     {
         std::unique_lock lock(mCvMutex);
         base::ScopedLockAssertion lock_assertion(mCvMutex);
+        LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << mState << " request";
         if (mState == BluetoothStreamState::STANDBY) {
             return true;  // nop, return
         } else if (mState == BluetoothStreamState::SUSPENDING ||
                    mState == BluetoothStreamState::STARTING) {
             /* If port is in transient state, give some time to respond */
-            auto state_ = mState;
-            lock.unlock();
-            if (!condWaitState(state_)) {
-                LOG(ERROR) << __func__ << debugMessage() << ", state=" << getState() << " failure";
+            if (!condWaitState(&lock)) {
+                LOG(ERROR) << __func__ << debugMessage() << ", state=" << mState << " failure";
                 return false;
             }
         }
-    }
-
-    bool retval = false;
-    {
-        std::unique_lock lock(mCvMutex);
-        base::ScopedLockAssertion lock_assertion(mCvMutex);
         if (mState == BluetoothStreamState::STANDBY) {
             retval = true;
         } else if (mState == BluetoothStreamState::STARTED) {
             mState = BluetoothStreamState::SUSPENDING;
             lock.unlock();
-            if (BluetoothAudioSessionControl::SuspendStream(mSessionType)) {
-                retval = condWaitState(BluetoothStreamState::SUSPENDING);
+            const bool suspendSuccess = BluetoothAudioSessionControl::SuspendStream(mSessionType);
+            lock.lock();
+            if (suspendSuccess && mState == BluetoothStreamState::SUSPENDING) {
+                retval = condWaitState(&lock);
+            } else if (suspendSuccess && mState == BluetoothStreamState::STANDBY) {
+                retval = true;
             } else {
-                LOG(ERROR) << __func__ << debugMessage() << ", state=" << getState()
-                           << " failure to suspend stream";
+                LOG(ERROR) << __func__ << debugMessage() << ", suspendSuccess=" << suspendSuccess
+                           << ", state=" << mState << " -> DISABLED";
+                mState = BluetoothStreamState::DISABLED;
             }
         }
+        if (retval) {
+            LOG(INFO) << __func__ << debugMessage() << ", state=" << mState << " done";
+        } else {
+            LOG(ERROR) << __func__ << debugMessage() << ", state=" << mState << " failure";
+        }
     }
-
-    if (retval) {
-        LOG(INFO) << __func__ << debugMessage() << ", state=" << getState() << " done";
-    } else {
-        LOG(ERROR) << __func__ << debugMessage() << ", state=" << getState() << " failure";
-    }
-
     return retval;  // false if any failure like timeout
 }
 
 void BluetoothAudioPortAidl::stop() {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return;
     }
     std::lock_guard guard(mCvMutex);
-    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState() << " request";
+    BluetoothStreamState previous_state = mState;
+    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << mState << " request";
     if (mState != BluetoothStreamState::DISABLED) {
         BluetoothAudioSessionControl::StopStream(mSessionType);
         mState = BluetoothStreamState::DISABLED;
+        LOG(INFO) << __func__ << debugMessage() << ", " << previous_state << " -> " << mState;
     }
-    LOG(VERBOSE) << __func__ << debugMessage() << ", state=" << getState() << " done";
 }
 
 size_t BluetoothAudioPortAidlOut::writeData(const void* buffer, size_t bytes) const {
     if (!buffer) {
-        LOG(ERROR) << __func__ << ": bad input arg";
+        LOG(ERROR) << __func__ << debugMessage() << ": bad input arg";
         return 0;
     }
 
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return 0;
     }
 
@@ -491,14 +544,25 @@ size_t BluetoothAudioPortAidlOut::writeData(const void* buffer, size_t bytes) co
     return totalWrite * 2;
 }
 
+bool BluetoothAudioPortAidlOut::setLatencyMode(
+        ::aidl::android::hardware::bluetooth::audio::LatencyMode latency_mode) {
+    if (!inUse()) {
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
+        return false;
+    }
+    LOG(INFO) << __func__ << debugMessage() << ": " << toString(latency_mode);
+    BluetoothAudioSessionControl::SetLatencyMode(mSessionType, latency_mode);
+    return true;
+}
+
 size_t BluetoothAudioPortAidlIn::readData(void* buffer, size_t bytes) const {
     if (!buffer) {
-        LOG(ERROR) << __func__ << ": bad input arg";
+        LOG(ERROR) << __func__ << debugMessage() << ": bad input arg";
         return 0;
     }
 
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return 0;
     }
 
@@ -508,7 +572,7 @@ size_t BluetoothAudioPortAidlIn::readData(void* buffer, size_t bytes) const {
 bool BluetoothAudioPortAidl::getPresentationPosition(
         PresentationPosition& presentation_position) const {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
     bool retval = BluetoothAudioSessionControl::GetPresentationPosition(mSessionType,
@@ -521,7 +585,7 @@ bool BluetoothAudioPortAidl::getPresentationPosition(
 
 bool BluetoothAudioPortAidl::updateSourceMetadata(const SourceMetadata& source_metadata) const {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
     LOG(DEBUG) << __func__ << debugMessage() << ", state=" << getState() << ", "
@@ -532,7 +596,7 @@ bool BluetoothAudioPortAidl::updateSourceMetadata(const SourceMetadata& source_m
 
 bool BluetoothAudioPortAidl::updateSinkMetadata(const SinkMetadata& sink_metadata) const {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
     LOG(DEBUG) << __func__ << debugMessage() << ", state=" << getState() << ", "
@@ -542,21 +606,27 @@ bool BluetoothAudioPortAidl::updateSinkMetadata(const SinkMetadata& sink_metadat
 }
 
 BluetoothStreamState BluetoothAudioPortAidl::getState() const {
+    std::lock_guard guard(mCvMutex);
     return mState;
 }
 
 bool BluetoothAudioPortAidl::setState(BluetoothStreamState state) {
     if (!inUse()) {
-        LOG(ERROR) << __func__ << ": BluetoothAudioPortAidl is not in use";
+        LOG(ERROR) << __func__ << debugMessage() << ": BluetoothAudioPortAidl is not in use";
         return false;
     }
     std::lock_guard guard(mCvMutex);
-    LOG(DEBUG) << __func__ << ": BluetoothAudioPortAidl old state = " << mState
-               << " new state = " << state;
+    LOG(INFO) << __func__ << debugMessage() << ": " << mState << " -> " << state;
     mState = state;
     return true;
 }
 
+void BluetoothAudioPortAidl::setCallbacks(
+        const std::shared_ptr<BluetoothAudioPortCallbacks>& callbacks) {
+    std::lock_guard l(mCvMutex);
+    mCallbacks = callbacks;
+}
+
 bool BluetoothAudioPortAidl::isA2dp() const {
     return mSessionType == SessionType::A2DP_SOFTWARE_ENCODING_DATAPATH ||
            mSessionType == SessionType::A2DP_HARDWARE_OFFLOAD_ENCODING_DATAPATH;
@@ -575,4 +645,8 @@ std::string BluetoothAudioPortAidl::debugMessage() const {
     return StringPrintf(": session_type=%s, cookie=%#hx", toString(mSessionType).c_str(), mCookie);
 }
 
+std::string BluetoothAudioPortAidl::getSessionNameForDebug() const {
+    return toString(mSessionType);
+}
+
 }  // namespace android::bluetooth::audio::aidl
diff --git a/audio/aidl/default/bluetooth/ModuleBluetooth.cpp b/audio/aidl/default/bluetooth/ModuleBluetooth.cpp
index 8c381cd89a..fbfaa8d25e 100644
--- a/audio/aidl/default/bluetooth/ModuleBluetooth.cpp
+++ b/audio/aidl/default/bluetooth/ModuleBluetooth.cpp
@@ -165,6 +165,12 @@ ndk::ScopedAStatus ModuleBluetooth::setAudioPortConfig(const AudioPortConfig& in
     return Module::setAudioPortConfigImpl(in_requested, fillConfig, out_suggested, _aidl_return);
 }
 
+ndk::ScopedAStatus ModuleBluetooth::supportsVariableLatency(bool* _aidl_return) {
+    LOG(DEBUG) << __func__ << ": " << getType();
+    *_aidl_return = true;
+    return ndk::ScopedAStatus::ok();
+}
+
 ndk::ScopedAStatus ModuleBluetooth::checkAudioPatchEndpointsMatch(
         const std::vector<AudioPortConfig*>& sources, const std::vector<AudioPortConfig*>& sinks) {
     // Both sources and sinks must be non-empty, this is guaranteed by 'setAudioPatch'.
@@ -279,6 +285,18 @@ int32_t ModuleBluetooth::getNominalLatencyMs(const AudioPortConfig& portConfig)
     return Module::getNominalLatencyMs(portConfig);
 }
 
+binder_status_t ModuleBluetooth::dump(int fd, const char** args, uint32_t numArgs) {
+    if (!::aidl::android::hardware::audio::common::hasArgument(
+                args, numArgs,
+                ::aidl::android::hardware::audio::common::kDumpFromAudioServerArgument)) {
+        // Streams are dumped as part of audio flinger threads dump,
+        // no need for a separate dump since the module itself does not
+        // have anything interesting.
+        Module::dump(fd, args, numArgs);
+    }
+    return ::android::OK;
+}
+
 ndk::ScopedAStatus ModuleBluetooth::createProxy(const AudioPort& audioPort, int32_t instancePortId,
                                                 CachedProxy& proxy) {
     const bool isInput = audioPort.flags.getTag() == AudioIoFlags::input;
diff --git a/audio/aidl/default/bluetooth/StreamBluetooth.cpp b/audio/aidl/default/bluetooth/StreamBluetooth.cpp
index 77ce121e9a..4dbfb9a747 100644
--- a/audio/aidl/default/bluetooth/StreamBluetooth.cpp
+++ b/audio/aidl/default/bluetooth/StreamBluetooth.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <inttypes.h>
 #include <algorithm>
 
 #define LOG_TAG "AHAL_StreamBluetooth"
@@ -27,6 +28,7 @@ using aidl::android::hardware::audio::common::SinkMetadata;
 using aidl::android::hardware::audio::common::SourceMetadata;
 using aidl::android::hardware::audio::core::VendorParameter;
 using aidl::android::hardware::bluetooth::audio::ChannelMode;
+using aidl::android::hardware::bluetooth::audio::LatencyMode;
 using aidl::android::hardware::bluetooth::audio::PcmConfiguration;
 using aidl::android::hardware::bluetooth::audio::PresentationPosition;
 using aidl::android::media::audio::common::AudioChannelLayout;
@@ -35,6 +37,7 @@ using aidl::android::media::audio::common::AudioDevice;
 using aidl::android::media::audio::common::AudioDeviceAddress;
 using aidl::android::media::audio::common::AudioFormatDescription;
 using aidl::android::media::audio::common::AudioFormatType;
+using aidl::android::media::audio::common::AudioLatencyMode;
 using aidl::android::media::audio::common::AudioOffloadInfo;
 using aidl::android::media::audio::common::MicrophoneDynamicInfo;
 using aidl::android::media::audio::common::MicrophoneInfo;
@@ -50,6 +53,54 @@ constexpr int kBluetoothDefaultOutputBufferMs = 10;
 // constexpr int kBluetoothSpatializerOutputBufferMs = 10;
 constexpr int kBluetoothDefaultRemoteDelayMs = 200;
 
+namespace {
+
+LatencyMode audio2bt_LatencyMode(AudioLatencyMode mode) {
+    switch (mode) {
+        case AudioLatencyMode::FREE:
+            return LatencyMode::FREE;
+        case AudioLatencyMode::LOW:
+            return LatencyMode::LOW_LATENCY;
+        case AudioLatencyMode::DYNAMIC_SPATIAL_AUDIO_SOFTWARE:
+            return LatencyMode::DYNAMIC_SPATIAL_AUDIO_SOFTWARE;
+        case AudioLatencyMode::DYNAMIC_SPATIAL_AUDIO_HARDWARE:
+            return LatencyMode::DYNAMIC_SPATIAL_AUDIO_HARDWARE;
+    }
+    return LatencyMode::UNKNOWN;
+}
+
+std::optional<AudioLatencyMode> bt2audio_LatencyMode(LatencyMode mode) {
+    switch (mode) {
+        case LatencyMode::UNKNOWN:
+            return std::nullopt;
+        case LatencyMode::FREE:
+            return AudioLatencyMode::FREE;
+        case LatencyMode::LOW_LATENCY:
+            return AudioLatencyMode::LOW;
+        case LatencyMode::DYNAMIC_SPATIAL_AUDIO_SOFTWARE:
+            return AudioLatencyMode::DYNAMIC_SPATIAL_AUDIO_SOFTWARE;
+        case LatencyMode::DYNAMIC_SPATIAL_AUDIO_HARDWARE:
+            return AudioLatencyMode::DYNAMIC_SPATIAL_AUDIO_HARDWARE;
+    }
+    return std::nullopt;
+}
+
+std::vector<AudioLatencyMode> bt2audio_LatencyModes(const std::vector<LatencyMode>& modes) {
+    std::vector<AudioLatencyMode> result;
+    for (const auto m : modes) {
+        if (const auto alm = bt2audio_LatencyMode(m); alm.has_value()) {
+            result.push_back(*alm);
+        }
+    }
+    return result;
+}
+
+}  // namespace
+
+void PortCallbacksHandler::onRecommendedLatencyModeChanged(const std::vector<LatencyMode>& modes) {
+    mStreamCallback->onRecommendedLatencyModeChanged(bt2audio_LatencyModes(modes));
+}
+
 StreamBluetooth::StreamBluetooth(StreamContext* context, const Metadata& metadata,
                                  ModuleBluetooth::BtProfileHandles&& btHandles,
                                  const std::shared_ptr<BluetoothAudioPortAidl>& btDeviceProxy,
@@ -64,7 +115,15 @@ StreamBluetooth::StreamBluetooth(StreamContext* context, const Metadata& metadat
                                        : (mIsInput ? kBluetoothDefaultInputBufferMs
                                                    : kBluetoothDefaultOutputBufferMs) *
                                                  1000),
-      mBtDeviceProxy(btDeviceProxy) {}
+      mCallbacksHandler(new PortCallbacksHandler(getContext().getOutEventCallback())),
+      mBtDeviceProxy(btDeviceProxy) {
+    if (mBtDeviceProxy != nullptr) {
+        mSessionTypeName = mBtDeviceProxy->getSessionNameForDebug();
+        if (mCallbacksHandler->hasCallback()) {
+            mBtDeviceProxy->setCallbacks(mCallbacksHandler);
+        }
+    }
+}
 
 StreamBluetooth::~StreamBluetooth() {
     cleanupWorker();
@@ -97,15 +156,16 @@ StreamBluetooth::~StreamBluetooth() {
 ::android::status_t StreamBluetooth::transfer(void* buffer, size_t frameCount,
                                               size_t* actualFrameCount, int32_t* latencyMs) {
     std::lock_guard guard(mLock);
-    *actualFrameCount = 0;
-    *latencyMs = StreamDescriptor::LATENCY_UNKNOWN;
-    if (mBtDeviceProxy == nullptr || mBtDeviceProxy->getState() == BluetoothStreamState::DISABLED) {
-        // The BT session is turned down, silently ignore write.
+    if (!mEnabled) {
+        *actualFrameCount = frameCount;
+        *latencyMs = kBluetoothDefaultRemoteDelayMs;
+        usleep((float)(frameCount * 1000000) / (float)getContext().getSampleRate());
         return ::android::OK;
     }
-    if (!mBtDeviceProxy->start()) {
-        LOG(WARNING) << __func__ << ": state= " << mBtDeviceProxy->getState()
-                     << " failed to start, will retry";
+    *actualFrameCount = 0;
+    *latencyMs = StreamDescriptor::LATENCY_UNKNOWN;
+    if (mBtDeviceProxy == nullptr || !mBtDeviceProxy->start()) {
+        // The BT session is turned down.
         return ::android::OK;
     }
     *latencyMs = 0;
@@ -161,9 +221,7 @@ bool StreamBluetooth::checkConfigParams(const PcmConfiguration& pcmConfig,
 ndk::ScopedAStatus StreamBluetooth::prepareToClose() {
     std::lock_guard guard(mLock);
     if (mBtDeviceProxy != nullptr) {
-        if (mBtDeviceProxy->getState() != BluetoothStreamState::DISABLED) {
-            mBtDeviceProxy->stop();
-        }
+        mBtDeviceProxy->stop();
     }
     return ndk::ScopedAStatus::ok();
 }
@@ -176,6 +234,9 @@ ndk::ScopedAStatus StreamBluetooth::prepareToClose() {
 
 ::android::status_t StreamBluetooth::start() {
     std::lock_guard guard(mLock);
+    if (!mEnabled) {
+        return ::android::OK;
+    }
     if (mBtDeviceProxy != nullptr) mBtDeviceProxy->start();
     return ::android::OK;
 }
@@ -228,10 +289,53 @@ ndk::ScopedAStatus StreamBluetooth::bluetoothParametersUpdated() {
             LOG(DEBUG) << __func__ << ": applyParam failed";
             return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
         }
+        mEnabled = (mBtDeviceProxy->isA2dp() && enableA2dp) ||
+                   (mBtDeviceProxy->isLeAudio() && enableLe);
+        LOG(INFO) << __func__ << ": mEnabled: " << mEnabled;
+    }
+    return ndk::ScopedAStatus::ok();
+}
+
+ndk::ScopedAStatus StreamBluetooth::getRecommendedLatencyModes(
+        std::vector<AudioLatencyMode>* _aidl_return) {
+    LOG(DEBUG) << __func__;
+    std::vector<LatencyMode> modes;
+    std::lock_guard guard(mLock);
+    if (!mBtDeviceProxy || !mBtDeviceProxy->getRecommendedLatencyModes(&modes)) {
+        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);
     }
+    *_aidl_return = bt2audio_LatencyModes(modes);
     return ndk::ScopedAStatus::ok();
 }
 
+ndk::ScopedAStatus StreamBluetooth::setLatencyMode(AudioLatencyMode in_mode) {
+    LOG(DEBUG) << __func__ << ": " << toString(in_mode);
+    std::lock_guard guard(mLock);
+    if (mBtDeviceProxy != nullptr) {
+        return mBtDeviceProxy->setLatencyMode(audio2bt_LatencyMode(in_mode))
+                       ? ndk::ScopedAStatus::ok()
+                       : ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
+    }
+    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);
+}
+
+void StreamBluetooth::dump(int fd, const char** args, uint32_t numArgs) {
+    const int indent = 4;
+    if (::aidl::android::hardware::audio::common::hasArgument(
+                args, numArgs,
+                ::aidl::android::hardware::audio::common::kDumpFromAudioServerArgument)) {
+        // Just provide the frames count.
+        dprintf(fd, "%*sFrames transferred: %" PRId64 "\n", indent, "",
+                getContext().getFrameCount());
+        return;
+    }
+    dprintf(fd, "%*sI/O handle %d:\n", indent, "", getContext().getMixPortHandle());
+    dprintf(fd, "%*sFrames transferred: %" PRId64 "\n", indent + 2, "",
+            getContext().getFrameCount());
+    dprintf(fd, "%*sSession type: %s\n", indent + 2, "", mSessionTypeName.c_str());
+    dprintf(fd, "%*sSample rate: %d\n", indent + 2, "", getContext().getSampleRate());
+}
+
 // static
 int32_t StreamInBluetooth::getNominalLatencyMs(size_t dataIntervalUs) {
     if (dataIntervalUs == 0) dataIntervalUs = kBluetoothDefaultInputBufferMs * 1000LL;
@@ -253,6 +357,11 @@ ndk::ScopedAStatus StreamInBluetooth::getActiveMicrophones(
     return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
 }
 
+binder_status_t StreamInBluetooth::dump(int fd, const char** args, uint32_t numArgs) {
+    StreamBluetooth::dump(fd, args, numArgs);
+    return ::android::OK;
+}
+
 // static
 int32_t StreamOutBluetooth::getNominalLatencyMs(size_t dataIntervalUs) {
     if (dataIntervalUs == 0) dataIntervalUs = kBluetoothDefaultOutputBufferMs * 1000LL;
@@ -269,4 +378,18 @@ StreamOutBluetooth::StreamOutBluetooth(StreamContext&& context,
       StreamBluetooth(&mContextInstance, sourceMetadata, std::move(btProfileHandles), btDeviceProxy,
                       pcmConfig) {}
 
+ndk::ScopedAStatus StreamOutBluetooth::getRecommendedLatencyModes(
+        std::vector<AudioLatencyMode>* _aidl_return) {
+    return StreamBluetooth::getRecommendedLatencyModes(_aidl_return);
+}
+
+ndk::ScopedAStatus StreamOutBluetooth::setLatencyMode(AudioLatencyMode in_mode) {
+    return StreamBluetooth::setLatencyMode(in_mode);
+}
+
+binder_status_t StreamOutBluetooth::dump(int fd, const char** args, uint32_t numArgs) {
+    StreamBluetooth::dump(fd, args, numArgs);
+    return ::android::OK;
+}
+
 }  // namespace aidl::android::hardware::audio::core
diff --git a/audio/aidl/default/include/core-impl/DevicePortProxy.h b/audio/aidl/default/include/core-impl/DevicePortProxy.h
index ccb23bbe5b..2fc1cf6ce0 100644
--- a/audio/aidl/default/include/core-impl/DevicePortProxy.h
+++ b/audio/aidl/default/include/core-impl/DevicePortProxy.h
@@ -18,12 +18,14 @@
 
 #include <condition_variable>
 #include <mutex>
+#include <vector>
 
 #include <android-base/thread_annotations.h>
 
 #include <aidl/android/hardware/audio/common/SinkMetadata.h>
 #include <aidl/android/hardware/audio/common/SourceMetadata.h>
 #include <aidl/android/hardware/bluetooth/audio/BluetoothAudioStatus.h>
+#include <aidl/android/hardware/bluetooth/audio/LatencyMode.h>
 #include <aidl/android/hardware/bluetooth/audio/PcmConfiguration.h>
 #include <aidl/android/hardware/bluetooth/audio/PresentationPosition.h>
 #include <aidl/android/hardware/bluetooth/audio/SessionType.h>
@@ -42,6 +44,13 @@ enum class BluetoothStreamState : uint8_t {
 
 std::ostream& operator<<(std::ostream& os, const BluetoothStreamState& state);
 
+class BluetoothAudioPortCallbacks {
+  public:
+    virtual ~BluetoothAudioPortCallbacks() = default;
+    virtual void onRecommendedLatencyModeChanged(
+            const std::vector<::aidl::android::hardware::bluetooth::audio::LatencyMode>&) = 0;
+};
+
 /**
  * Proxy for Bluetooth Audio HW Module to communicate with Bluetooth Audio
  * Session Control. All methods are not thread safe, so users must acquire a
@@ -50,7 +59,6 @@ std::ostream& operator<<(std::ostream& os, const BluetoothStreamState& state);
  */
 class BluetoothAudioPort {
   public:
-    BluetoothAudioPort() = default;
     virtual ~BluetoothAudioPort() = default;
 
     /**
@@ -87,7 +95,8 @@ class BluetoothAudioPort {
     virtual bool standby() = 0;
 
     /**
-     * Called by Audio framework / HAL to start the stream
+     * Called by Audio framework / HAL to start the stream. Starts the BT session stream with
+     * low latency when it is supported.
      */
     virtual bool start() = 0;
 
@@ -113,18 +122,14 @@ class BluetoothAudioPort {
      * source has been changed.
      */
     virtual bool updateSourceMetadata(
-            const ::aidl::android::hardware::audio::common::SourceMetadata&) const {
-        return false;
-    }
+            const ::aidl::android::hardware::audio::common::SourceMetadata&) const = 0;
 
     /**
      * Called by the Audio framework / HAL when the metadata of the stream's
      * sink has been changed.
      */
     virtual bool updateSinkMetadata(
-            const ::aidl::android::hardware::audio::common::SinkMetadata&) const {
-        return false;
-    }
+            const ::aidl::android::hardware::audio::common::SinkMetadata&) const = 0;
 
     /**
      * Return the current BluetoothStreamState
@@ -145,11 +150,24 @@ class BluetoothAudioPort {
     virtual size_t writeData(const void*, size_t) const { return 0; }
 
     virtual size_t readData(void*, size_t) const { return 0; }
+
+    virtual bool setLatencyMode(::aidl::android::hardware::bluetooth::audio::LatencyMode) {
+        return false;
+    }
+
+    virtual bool getRecommendedLatencyModes(
+            std::vector<::aidl::android::hardware::bluetooth::audio::LatencyMode>*) {
+        return false;
+    }
+
+    virtual void setCallbacks(const std::shared_ptr<BluetoothAudioPortCallbacks>&) = 0;
+
+    virtual std::string getSessionNameForDebug() const = 0;
 };
 
 class BluetoothAudioPortAidl : public BluetoothAudioPort {
   public:
-    BluetoothAudioPortAidl();
+    explicit BluetoothAudioPortAidl(std::optional<bool> supportsLowLatency);
     virtual ~BluetoothAudioPortAidl();
 
     bool registerPort(const ::aidl::android::media::audio::common::AudioDeviceDescription&
@@ -176,9 +194,8 @@ class BluetoothAudioPortAidl : public BluetoothAudioPort {
 
     /**
      * Return the current BluetoothStreamState
-     * Note: This method is used for logging, does not lock, so value returned may not be latest
      */
-    BluetoothStreamState getState() const override NO_THREAD_SAFETY_ANALYSIS;
+    BluetoothStreamState getState() const override;
 
     bool setState(BluetoothStreamState state) override;
 
@@ -188,12 +205,22 @@ class BluetoothAudioPortAidl : public BluetoothAudioPort {
 
     bool getPreferredDataIntervalUs(size_t& interval_us) const override;
 
+    bool getRecommendedLatencyModes(
+            std::vector<::aidl::android::hardware::bluetooth::audio::LatencyMode>* latencyModes)
+            override;
+
+    void setCallbacks(const std::shared_ptr<BluetoothAudioPortCallbacks>& callbacks) override;
+
+    std::string getSessionNameForDebug() const override;
+
   protected:
     uint16_t mCookie;
     BluetoothStreamState mState GUARDED_BY(mCvMutex);
     ::aidl::android::hardware::bluetooth::audio::SessionType mSessionType;
     // WR to support Mono: True if fetching Stereo and mixing into Mono
     bool mIsStereoToMono = false;
+    std::shared_ptr<BluetoothAudioPortCallbacks> mCallbacks GUARDED_BY(mCvMutex);
+    std::optional<bool> mSupportsLowLatency GUARDED_BY(mCvMutex);
 
     bool inUse() const;
 
@@ -211,25 +238,31 @@ class BluetoothAudioPortAidl : public BluetoothAudioPort {
     bool initSessionType(
             const ::aidl::android::media::audio::common::AudioDeviceDescription& description);
 
-    bool condWaitState(BluetoothStreamState state);
+    bool condWaitState(std::unique_lock<std::mutex>* lock) REQUIRES(mCvMutex);
 
     void controlResultHandler(
             uint16_t cookie,
             const ::aidl::android::hardware::bluetooth::audio::BluetoothAudioStatus& status);
+    void lowLatencyAllowedHandler(uint16_t cookie, bool allowed);
     void sessionChangedHandler(uint16_t cookie);
 };
 
 class BluetoothAudioPortAidlOut : public BluetoothAudioPortAidl {
   public:
+    BluetoothAudioPortAidlOut() : BluetoothAudioPortAidl(std::nullopt /*supportsLowLatency*/) {}
     bool loadAudioConfig(
             ::aidl::android::hardware::bluetooth::audio::PcmConfiguration& audio_cfg) override;
 
     // The audio data path to the Bluetooth stack (Software encoding)
     size_t writeData(const void* buffer, size_t bytes) const override;
+
+    bool setLatencyMode(
+            ::aidl::android::hardware::bluetooth::audio::LatencyMode latency_mode) override;
 };
 
 class BluetoothAudioPortAidlIn : public BluetoothAudioPortAidl {
   public:
+    BluetoothAudioPortAidlIn() : BluetoothAudioPortAidl(false /*supportsLowLatency*/) {}
     // The audio data path from the Bluetooth stack (Software decoded)
     size_t readData(void* buffer, size_t bytes) const override;
 };
diff --git a/audio/aidl/default/include/core-impl/ModuleBluetooth.h b/audio/aidl/default/include/core-impl/ModuleBluetooth.h
index 4e68d72668..3fffe69b24 100644
--- a/audio/aidl/default/include/core-impl/ModuleBluetooth.h
+++ b/audio/aidl/default/include/core-impl/ModuleBluetooth.h
@@ -53,6 +53,8 @@ class ModuleBluetooth final : public Module {
             ::aidl::android::media::audio::common::AudioPortConfig* out_suggested,
             bool* _aidl_return) override;
 
+    ndk::ScopedAStatus supportsVariableLatency(bool* _aidl_return) override;
+
     ndk::ScopedAStatus checkAudioPatchEndpointsMatch(
             const std::vector<::aidl::android::media::audio::common::AudioPortConfig*>& sources,
             const std::vector<::aidl::android::media::audio::common::AudioPortConfig*>& sinks)
@@ -78,6 +80,8 @@ class ModuleBluetooth final : public Module {
     int32_t getNominalLatencyMs(
             const ::aidl::android::media::audio::common::AudioPortConfig& portConfig) override;
 
+    binder_status_t dump(int fd, const char** args, uint32_t numArgs) override;
+
     ndk::ScopedAStatus createProxy(
             const ::aidl::android::media::audio::common::AudioPort& audioPort,
             int32_t instancePortId, CachedProxy& proxy);
diff --git a/audio/aidl/default/include/core-impl/StreamBluetooth.h b/audio/aidl/default/include/core-impl/StreamBluetooth.h
index 2bdd6b259f..648c685ac1 100644
--- a/audio/aidl/default/include/core-impl/StreamBluetooth.h
+++ b/audio/aidl/default/include/core-impl/StreamBluetooth.h
@@ -29,6 +29,19 @@
 
 namespace aidl::android::hardware::audio::core {
 
+class PortCallbacksHandler : public ::android::bluetooth::audio::aidl::BluetoothAudioPortCallbacks {
+  public:
+    explicit PortCallbacksHandler(std::shared_ptr<IStreamOutEventCallback> streamCallback)
+        : mStreamCallback(streamCallback) {}
+    bool hasCallback() const { return mStreamCallback != nullptr; }
+    void onRecommendedLatencyModeChanged(
+            const std::vector<::aidl::android::hardware::bluetooth::audio::LatencyMode>& modes)
+            override;
+
+  private:
+    std::shared_ptr<IStreamOutEventCallback> mStreamCallback;
+};
+
 class StreamBluetooth : public StreamCommonImpl {
   public:
     static bool checkConfigParams(
@@ -59,16 +72,27 @@ class StreamBluetooth : public StreamCommonImpl {
     ndk::ScopedAStatus prepareToClose() override;
     ndk::ScopedAStatus bluetoothParametersUpdated() override;
 
+  protected:
+    ndk::ScopedAStatus getRecommendedLatencyModes(
+            std::vector<::aidl::android::media::audio::common::AudioLatencyMode>* _aidl_return);
+    ndk::ScopedAStatus setLatencyMode(
+            ::aidl::android::media::audio::common::AudioLatencyMode in_mode);
+
+    void dump(int fd, const char** args, uint32_t numArgs);
+
   private:
     const size_t mFrameSizeBytes;
     const bool mIsInput;
     const std::weak_ptr<IBluetoothA2dp> mBluetoothA2dp;
     const std::weak_ptr<IBluetoothLe> mBluetoothLe;
     const size_t mPreferredDataIntervalUs;
+    std::shared_ptr<PortCallbacksHandler> mCallbacksHandler;
+    std::string mSessionTypeName;
     mutable std::mutex mLock;
     // The lock is also used to serialize calls to the proxy.
     std::shared_ptr<::android::bluetooth::audio::aidl::BluetoothAudioPortAidl> mBtDeviceProxy
             GUARDED_BY(mLock);  // proxy may be null if the stream is not connected to a device
+    bool mEnabled GUARDED_BY(mLock) = true;
 };
 
 class StreamInBluetooth final : public StreamIn, public StreamBluetooth {
@@ -91,6 +115,8 @@ class StreamInBluetooth final : public StreamIn, public StreamBluetooth {
     ndk::ScopedAStatus getActiveMicrophones(
             std::vector<::aidl::android::media::audio::common::MicrophoneDynamicInfo>* _aidl_return)
             override;
+
+    binder_status_t dump(int fd, const char** args, uint32_t numArgs) override;
 };
 
 class StreamOutBluetooth final : public StreamOut, public StreamBluetooth {
@@ -111,6 +137,14 @@ class StreamOutBluetooth final : public StreamOut, public StreamBluetooth {
 
   private:
     void onClose(StreamDescriptor::State) override { defaultOnClose(); }
+
+    ndk::ScopedAStatus getRecommendedLatencyModes(
+            std::vector<::aidl::android::media::audio::common::AudioLatencyMode>* _aidl_return)
+            override;
+    ndk::ScopedAStatus setLatencyMode(
+            ::aidl::android::media::audio::common::AudioLatencyMode in_mode) override;
+
+    binder_status_t dump(int fd, const char** args, uint32_t numArgs) override;
 };
 
 }  // namespace aidl::android::hardware::audio::core
diff --git a/audio/aidl/default/include/core-impl/StreamRemoteSubmix.h b/audio/aidl/default/include/core-impl/StreamRemoteSubmix.h
index 28a446a6ac..67bdd5577e 100644
--- a/audio/aidl/default/include/core-impl/StreamRemoteSubmix.h
+++ b/audio/aidl/default/include/core-impl/StreamRemoteSubmix.h
@@ -47,30 +47,26 @@ class StreamRemoteSubmix : public StreamCommonImpl {
     ndk::ScopedAStatus prepareToClose() override;
 
   private:
-    long getDelayInUsForFrameCount(size_t frameCount);
+    long getDurationInUsForFrameCount(size_t frameCount) const;
     size_t getStreamPipeSizeInFrames();
     ::android::status_t outWrite(void* buffer, size_t frameCount, size_t* actualFrameCount);
     ::android::status_t inRead(void* buffer, size_t frameCount, size_t* actualFrameCount);
 
     const ::aidl::android::media::audio::common::AudioDeviceAddress mDeviceAddress;
     const bool mIsInput;
-    r_submix::AudioConfig mStreamConfig;
+    const r_submix::AudioConfig mStreamConfig;
+    const int mReadAttemptSleepUs;
     std::shared_ptr<r_submix::SubmixRoute> mCurrentRoute = nullptr;
 
     // Limit for the number of error log entries to avoid spamming the logs.
     static constexpr int kMaxErrorLogs = 5;
-    // The duration of kMaxReadFailureAttempts * READ_ATTEMPT_SLEEP_MS must be strictly inferior
-    // to the duration of a record buffer at the current record sample rate (of the device, not of
-    // the recording itself). Here we have: 3 * 5ms = 15ms < 1024 frames * 1000 / 48000 = 21.333ms
-    static constexpr int kMaxReadFailureAttempts = 3;
-    // 5ms between two read attempts when pipe is empty
-    static constexpr int kReadAttemptSleepUs = 5000;
 
     int64_t mStartTimeNs = 0;
     long mFramesSinceStart = 0;
     int mReadErrorCount = 0;
     int mReadFailureCount = 0;
     int mWriteShutdownCount = 0;
+    bool mSkipNextTransfer = false;
 };
 
 class StreamInRemoteSubmix final : public StreamIn, public deprecated::StreamSwitcher {
diff --git a/audio/aidl/default/r_submix/ModuleRemoteSubmix.cpp b/audio/aidl/default/r_submix/ModuleRemoteSubmix.cpp
index b44f37b293..b542f187f6 100644
--- a/audio/aidl/default/r_submix/ModuleRemoteSubmix.cpp
+++ b/audio/aidl/default/r_submix/ModuleRemoteSubmix.cpp
@@ -170,7 +170,8 @@ ndk::ScopedAStatus ModuleRemoteSubmix::onMasterVolumeChanged(float __unused) {
 int32_t ModuleRemoteSubmix::getNominalLatencyMs(const AudioPortConfig&) {
     // See the note on kDefaultPipePeriodCount.
     static constexpr int32_t kMaxLatencyMs =
-            (r_submix::kDefaultPipeSizeInFrames * 1000) / r_submix::kDefaultSampleRateHz;
+            (r_submix::kDefaultPipeSizeInFrames * MILLIS_PER_SECOND) /
+            r_submix::kDefaultSampleRateHz;
     static constexpr int32_t kMinLatencyMs = kMaxLatencyMs / r_submix::kDefaultPipePeriodCount;
     return kMinLatencyMs;
 }
diff --git a/audio/aidl/default/r_submix/StreamRemoteSubmix.cpp b/audio/aidl/default/r_submix/StreamRemoteSubmix.cpp
index cc3c644c03..db3ba89a3a 100644
--- a/audio/aidl/default/r_submix/StreamRemoteSubmix.cpp
+++ b/audio/aidl/default/r_submix/StreamRemoteSubmix.cpp
@@ -40,12 +40,13 @@ StreamRemoteSubmix::StreamRemoteSubmix(StreamContext* context, const Metadata& m
                                        const AudioDeviceAddress& deviceAddress)
     : StreamCommonImpl(context, metadata),
       mDeviceAddress(deviceAddress),
-      mIsInput(isInput(metadata)) {
-    mStreamConfig.frameSize = context->getFrameSize();
-    mStreamConfig.format = context->getFormat();
-    mStreamConfig.channelLayout = context->getChannelLayout();
-    mStreamConfig.sampleRate = context->getSampleRate();
-}
+      mIsInput(isInput(metadata)),
+      mStreamConfig{.sampleRate = context->getSampleRate(),
+                    .format = context->getFormat(),
+                    .channelLayout = context->getChannelLayout(),
+                    .frameSize = context->getFrameSize(),
+                    .frameCount = context->getBufferSizeInFrames()},
+      mReadAttemptSleepUs(getDurationInUsForFrameCount(r_submix::kReadAttemptSleepFrames)) {}
 
 StreamRemoteSubmix::~StreamRemoteSubmix() {
     cleanupWorker();
@@ -137,29 +138,40 @@ void StreamRemoteSubmix::shutdown() {
 
 ::android::status_t StreamRemoteSubmix::transfer(void* buffer, size_t frameCount,
                                                  size_t* actualFrameCount, int32_t* latencyMs) {
-    *latencyMs = getDelayInUsForFrameCount(getStreamPipeSizeInFrames()) / 1000;
+    *latencyMs = getDurationInUsForFrameCount(getStreamPipeSizeInFrames()) / 1000;
     LOG(VERBOSE) << __func__ << ": Latency " << *latencyMs << "ms";
     mCurrentRoute->exitStandby(mIsInput);
-    ::android::status_t status = mIsInput ? inRead(buffer, frameCount, actualFrameCount)
-                                          : outWrite(buffer, frameCount, actualFrameCount);
-    if ((status != ::android::OK && mIsInput) ||
-        ((status != ::android::OK && status != ::android::DEAD_OBJECT) && !mIsInput)) {
-        return status;
+    ::android::status_t status = ::android::OK;
+    if (!mSkipNextTransfer) {
+        status = mIsInput ? inRead(buffer, frameCount, actualFrameCount)
+                          : outWrite(buffer, frameCount, actualFrameCount);
+        if ((status != ::android::OK && mIsInput) ||
+            ((status != ::android::OK && status != ::android::DEAD_OBJECT) && !mIsInput)) {
+            return status;
+        }
+    } else {
+        LOG(VERBOSE) << __func__ << ": Skipping transfer";
+        if (mIsInput) memset(buffer, 0, mStreamConfig.frameSize * frameCount);
+        *actualFrameCount = frameCount;
     }
     mFramesSinceStart += *actualFrameCount;
-    if (!mIsInput && status != ::android::DEAD_OBJECT) return ::android::OK;
+    if (mSkipNextTransfer || (!mIsInput && status != ::android::DEAD_OBJECT)) {
+        mSkipNextTransfer = false;
+        return ::android::OK;
+    }
     // Input streams always need to block, output streams need to block when there is no sink.
     // When the sink exists, more sophisticated blocking algorithm is implemented by MonoPipe.
-    const long bufferDurationUs =
-            (*actualFrameCount) * MICROS_PER_SECOND / mContext.getSampleRate();
+    const long bufferDurationUs = getDurationInUsForFrameCount(*actualFrameCount);
     const auto totalDurationUs = (::android::uptimeNanos() - mStartTimeNs) / NANOS_PER_MICROSECOND;
-    const long totalOffsetUs =
-            mFramesSinceStart * MICROS_PER_SECOND / mContext.getSampleRate() - totalDurationUs;
+    const long totalOffsetUs = getDurationInUsForFrameCount(mFramesSinceStart) - totalDurationUs;
     LOG(VERBOSE) << __func__ << ": totalOffsetUs " << totalOffsetUs;
     if (totalOffsetUs > 0) {
-        const long sleepTimeUs = std::min(totalOffsetUs, bufferDurationUs);
+        const long sleepTimeUs = std::max(0L, std::min(totalOffsetUs, bufferDurationUs));
         LOG(VERBOSE) << __func__ << ": sleeping for " << sleepTimeUs << " us";
         usleep(sleepTimeUs);
+    } else if (totalOffsetUs <= -(bufferDurationUs / 2)) {
+        LOG(VERBOSE) << __func__ << ": skipping next transfer";
+        mSkipNextTransfer = true;
     }
     return ::android::OK;
 }
@@ -182,7 +194,7 @@ void StreamRemoteSubmix::shutdown() {
     return ::android::OK;
 }
 
-long StreamRemoteSubmix::getDelayInUsForFrameCount(size_t frameCount) {
+long StreamRemoteSubmix::getDurationInUsForFrameCount(size_t frameCount) const {
     return frameCount * MICROS_PER_SECOND / mStreamConfig.sampleRate;
 }
 
@@ -269,6 +281,13 @@ size_t StreamRemoteSubmix::getStreamPipeSizeInFrames() {
 
 ::android::status_t StreamRemoteSubmix::inRead(void* buffer, size_t frameCount,
                                                size_t* actualFrameCount) {
+    // Try to wait as long as possible for the audio duration, but leave some time for the call to
+    // 'transfer' to complete. 'mReadAttemptSleepUs' is a good constant for this purpose because it
+    // is by definition "strictly inferior" to the typical buffer duration.
+    const long durationUs =
+            std::max(0L, getDurationInUsForFrameCount(frameCount) - mReadAttemptSleepUs * 2);
+    const int64_t deadlineTimeNs = ::android::uptimeNanos() + durationUs * NANOS_PER_MICROSECOND;
+
     // in any case, it is emulated that data for the entire buffer was available
     memset(buffer, 0, mStreamConfig.frameSize * frameCount);
     *actualFrameCount = frameCount;
@@ -300,12 +319,6 @@ size_t StreamRemoteSubmix::getStreamPipeSizeInFrames() {
     char* buff = (char*)buffer;
     size_t actuallyRead = 0;
     long remainingFrames = frameCount;
-    // Try to wait as long as possible for the audio duration, but leave some time for the call to
-    // 'transfer' to complete. 'kReadAttemptSleepUs' is a good constant for this purpose because it
-    // is by definition "strictly inferior" to the typical buffer duration.
-    const long durationUs =
-            std::max(0L, getDelayInUsForFrameCount(frameCount) - kReadAttemptSleepUs);
-    const int64_t deadlineTimeNs = ::android::uptimeNanos() + durationUs * NANOS_PER_MICROSECOND;
     while (remainingFrames > 0) {
         ssize_t framesRead = source->read(buff, remainingFrames);
         LOG(VERBOSE) << __func__ << ": frames read " << framesRead;
@@ -319,12 +332,12 @@ size_t StreamRemoteSubmix::getStreamPipeSizeInFrames() {
         if (::android::uptimeNanos() >= deadlineTimeNs) break;
         if (framesRead <= 0) {
             LOG(VERBOSE) << __func__ << ": read returned " << framesRead
-                         << ", read failure, sleeping for " << kReadAttemptSleepUs << " us";
-            usleep(kReadAttemptSleepUs);
+                         << ", read failure, sleeping for " << mReadAttemptSleepUs << " us";
+            usleep(mReadAttemptSleepUs);
         }
     }
     if (actuallyRead < frameCount) {
-        if (++mReadFailureCount < kMaxReadFailureAttempts) {
+        if (++mReadFailureCount < r_submix::kMaxReadFailureAttempts) {
             LOG(WARNING) << __func__ << ": read " << actuallyRead << " vs. requested " << frameCount
                          << " (not all errors will be logged)";
         }
diff --git a/audio/aidl/default/r_submix/SubmixRoute.h b/audio/aidl/default/r_submix/SubmixRoute.h
index 5425f12e17..bec7644cf6 100644
--- a/audio/aidl/default/r_submix/SubmixRoute.h
+++ b/audio/aidl/default/r_submix/SubmixRoute.h
@@ -44,9 +44,19 @@ static constexpr int kDefaultSampleRateHz = 48000;
 // read from the sink. The maximum latency of the device is the size of the MonoPipe's buffer
 // the minimum latency is the MonoPipe buffer size divided by this value.
 static constexpr int kDefaultPipePeriodCount = 4;
+static constexpr int kDefaultPipePeriodSizeFrames = 1024;
 // Size at the default sample rate
 // NOTE: This value will be rounded up to the nearest power of 2 by MonoPipe.
-static constexpr int kDefaultPipeSizeInFrames = 1024 * kDefaultPipePeriodCount;
+static constexpr int kDefaultPipeSizeInFrames =
+        kDefaultPipePeriodSizeFrames * kDefaultPipePeriodCount;
+// The duration of kMaxReadFailureAttempts * kReadAttemptSleepUs must be strictly inferior to the
+// duration of a record buffer (kDefaultPipePeriodSizeFrames) at the current record sample rate (of
+// the device, not of the recording itself). Here we have: 3 * 240 = 720 < 1024 frames
+static constexpr int kMaxReadFailureAttempts = 3;
+static constexpr int kReadAttemptSleepFrames = 240;
+static_assert(kMaxReadFailureAttempts * kReadAttemptSleepFrames * 7 <
+                      kDefaultPipePeriodSizeFrames * 5,
+              "Duration of attempts * sleep must be significantly less than the period size");
 
 // Configuration of the audio stream.
 struct AudioConfig {
diff --git a/audio/aidl/default/stub/StreamMmapStub.cpp b/audio/aidl/default/stub/StreamMmapStub.cpp
index f48aea4260..4b9cbc0ae4 100644
--- a/audio/aidl/default/stub/StreamMmapStub.cpp
+++ b/audio/aidl/default/stub/StreamMmapStub.cpp
@@ -118,7 +118,7 @@ DriverMmapStubImpl::DriverMmapStubImpl(const StreamContext& context)
     return ::android::OK;
 }
 
-::android::status_t DriverMmapStubImpl::transfer(void*, size_t, size_t*, int32_t*) {
+::android::status_t DriverMmapStubImpl::transfer(void*, size_t frameCount, size_t*, int32_t*) {
     // Do not call into DriverStubImpl::transfer
     if (!mIsInitialized) {
         LOG(FATAL) << __func__ << ": must not happen for an uninitialized driver";
@@ -126,6 +126,10 @@ DriverMmapStubImpl::DriverMmapStubImpl(const StreamContext& context)
     if (mIsStandby) {
         LOG(FATAL) << __func__ << ": must not happen while in standby";
     }
+    if (frameCount != 0) {
+        LOG(ERROR) << __func__ << ": burst value size must be 0 for MMAP";
+        return ::android::BAD_VALUE;
+    }
     RETURN_STATUS_IF_ERROR(startWorkerIfNeeded());
     mDspWorker.resume();
     return ::android::OK;
@@ -194,7 +198,7 @@ void DriverMmapStubImpl::shutdown() {
         std::lock_guard l(mState.lock);
         *position = mState.mmapPos;
     }
-    const size_t latencyFrames = mBufferSizeFrames / 2;
+    const size_t latencyFrames = mBufferSizeFrames / 4;
     if (position->frames != StreamDescriptor::Position::UNKNOWN) {
         position->frames += latencyFrames;
     }
@@ -268,8 +272,8 @@ ndk::ScopedAStatus StreamMmapStub::createMmapBuffer(MmapBufferDescriptor* desc)
     }
     desc->sharedMemory.fd = mSharedMemoryFd.dup();
     desc->sharedMemory.size = bufferSizeBytes;
-    desc->burstSizeFrames = bufferSizeFrames / 2;
-    desc->flags = 0;
+    desc->burstSizeFrames = bufferSizeFrames / 4;
+    desc->flags = 1 << MmapBufferDescriptor::FLAG_INDEX_APPLICATION_SHAREABLE;
     LOG(DEBUG) << __func__ << ": " << desc->toString();
     return ndk::ScopedAStatus::ok();
 }
diff --git a/audio/aidl/vts/EffectHelper.h b/audio/aidl/vts/EffectHelper.h
index e334ee902b..b934399443 100644
--- a/audio/aidl/vts/EffectHelper.h
+++ b/audio/aidl/vts/EffectHelper.h
@@ -88,7 +88,7 @@ static constexpr float kMaxAudioSampleValue = 1;
 static constexpr int kNPointFFT = 16384;
 static constexpr int kSamplingFrequency = 44100;
 static constexpr int kDefaultChannelLayout = AudioChannelLayout::LAYOUT_STEREO;
-static constexpr float kLn10Div20 = -0.11512925f;  // -ln(10)/20
+static constexpr float kLn10Div20 = 0.11512925f;  // ln(10)/20
 
 class EffectHelper {
   public:
@@ -596,6 +596,10 @@ class EffectHelper {
         }
     }
 
+    constexpr float dBToAmplitude(float dB, float fullScaleDb) {
+        return std::exp((dB - fullScaleDb) * kLn10Div20);
+    }
+
     constexpr float dBToAmplitude(float dB) { return std::exp(dB * kLn10Div20); }
 
     static int getHalVersion(const std::shared_ptr<IEffect>& effect) {
diff --git a/audio/aidl/vts/ModuleConfig.cpp b/audio/aidl/vts/ModuleConfig.cpp
index 7d4cc7016e..27f3b8e6c3 100644
--- a/audio/aidl/vts/ModuleConfig.cpp
+++ b/audio/aidl/vts/ModuleConfig.cpp
@@ -182,8 +182,17 @@ std::vector<AudioPort> ModuleConfig::getNonBlockingMixPorts(bool connectedOnly,
 
 std::vector<AudioPort> ModuleConfig::getOffloadMixPorts(bool connectedOnly, bool singlePort) const {
     return findMixPorts(false /*isInput*/, connectedOnly, singlePort, [&](const AudioPort& port) {
-        return isBitPositionFlagSet(port.flags.get<AudioIoFlags::Tag::output>(),
-                                    AudioOutputFlags::COMPRESS_OFFLOAD);
+        if (isBitPositionFlagSet(port.flags.get<AudioIoFlags::Tag::output>(),
+                                 AudioOutputFlags::COMPRESS_OFFLOAD)) {
+            // Check if the port supports non-PCM formats. If it's only PCM, then
+            // it's a "PCM Offload" port and it may not support features needed
+            // for playing compressed formats.
+            for (const auto& profile : port.profiles) {
+                if (!profile.format.encoding.empty()) return true;
+            }
+            return false;
+        }
+        return false;
     });
 }
 
@@ -194,18 +203,18 @@ std::vector<AudioPort> ModuleConfig::getPrimaryMixPorts(bool connectedOnly, bool
     });
 }
 
-std::vector<AudioPort> ModuleConfig::getMmapOutMixPorts(bool connectedOnly, bool singlePort) const {
-    return findMixPorts(false /*isInput*/, connectedOnly, singlePort, [&](const AudioPort& port) {
-        return isBitPositionFlagSet(port.flags.get<AudioIoFlags::Tag::output>(),
-                                    AudioOutputFlags::MMAP_NOIRQ);
-    });
-}
-
-std::vector<AudioPort> ModuleConfig::getMmapInMixPorts(bool connectedOnly, bool singlePort) const {
-    return findMixPorts(true /*isInput*/, connectedOnly, singlePort, [&](const AudioPort& port) {
+std::vector<AudioPort> ModuleConfig::getMmapMixPorts(bool isInput, bool connectedOnly,
+                                                     bool singlePort) const {
+    static const auto inputFlagMatcher = [&](const AudioPort& port) {
         return isBitPositionFlagSet(port.flags.get<AudioIoFlags::Tag::input>(),
                                     AudioInputFlags::MMAP_NOIRQ);
-    });
+    };
+    static const auto outputFlagMatcher = [&](const AudioPort& port) {
+        return isBitPositionFlagSet(port.flags.get<AudioIoFlags::Tag::output>(),
+                                    AudioOutputFlags::MMAP_NOIRQ);
+    };
+    return isInput ? findMixPorts(isInput, connectedOnly, singlePort, inputFlagMatcher)
+                   : findMixPorts(isInput, connectedOnly, singlePort, outputFlagMatcher);
 }
 
 std::vector<AudioPort> ModuleConfig::getRemoteSubmixPorts(bool isInput, bool singlePort) const {
diff --git a/audio/aidl/vts/ModuleConfig.h b/audio/aidl/vts/ModuleConfig.h
index d45ccda960..c431e2202d 100644
--- a/audio/aidl/vts/ModuleConfig.h
+++ b/audio/aidl/vts/ModuleConfig.h
@@ -75,12 +75,20 @@ class ModuleConfig {
     std::vector<aidl::android::media::audio::common::AudioPort> getPrimaryMixPorts(
             bool connectedOnly /*Permanently attached and connected external devices*/,
             bool singlePort) const;
-    std::vector<aidl::android::media::audio::common::AudioPort> getMmapOutMixPorts(
+    std::vector<aidl::android::media::audio::common::AudioPort> getMmapMixPorts(
+            bool isInput,
             bool connectedOnly /*Permanently attached and connected external devices*/,
             bool singlePort) const;
+    std::vector<aidl::android::media::audio::common::AudioPort> getMmapOutMixPorts(
+            bool connectedOnly /*Permanently attached and connected external devices*/,
+            bool singlePort) const {
+        return getMmapMixPorts(false /*isInput*/, connectedOnly, singlePort);
+    }
     std::vector<aidl::android::media::audio::common::AudioPort> getMmapInMixPorts(
             bool connectedOnly /*Permanently attached and connected external devices*/,
-            bool singlePort) const;
+            bool singlePort) const {
+        return getMmapMixPorts(true /*isInput*/, connectedOnly, singlePort);
+    }
     std::vector<aidl::android::media::audio::common::AudioPort> getRemoteSubmixPorts(
             bool isInput, bool singlePort) const;
 
@@ -118,26 +126,26 @@ class ModuleConfig {
     }
     std::vector<aidl::android::media::audio::common::AudioPortConfig> getPortConfigsForMixPorts()
             const {
-        auto inputs =
-                generateAudioMixPortConfigs(getInputMixPorts(false /*connectedOnly*/), true, false);
+        auto inputs = generateAudioMixPortConfigs(getInputMixPorts(false /*connectedOnly*/),
+                                                  true /*isInput*/, false /*singleProfile*/);
         auto outputs = generateAudioMixPortConfigs(getOutputMixPorts(false /*connectedOnly*/),
-                                                   false, false);
+                                                   false /*isInput*/, false /*singleProfile*/);
         inputs.insert(inputs.end(), outputs.begin(), outputs.end());
         return inputs;
     }
     std::vector<aidl::android::media::audio::common::AudioPortConfig> getPortConfigsForMixPorts(
             bool isInput) const {
         return generateAudioMixPortConfigs(getMixPorts(isInput, false /*connectedOnly*/), isInput,
-                                           false);
+                                           false /*singleProfile*/);
     }
     std::vector<aidl::android::media::audio::common::AudioPortConfig> getPortConfigsForMixPorts(
             bool isInput, const aidl::android::media::audio::common::AudioPort& port) const {
-        return generateAudioMixPortConfigs({port}, isInput, false);
+        return generateAudioMixPortConfigs({port}, isInput, false /*singleProfile*/);
     }
     std::optional<aidl::android::media::audio::common::AudioPortConfig> getSingleConfigForMixPort(
             bool isInput) const {
         const auto config = generateAudioMixPortConfigs(
-                getMixPorts(isInput, false /*connectedOnly*/), isInput, true);
+                getMixPorts(isInput, false /*connectedOnly*/), isInput, true /*singleProfile*/);
         if (!config.empty()) {
             return *config.begin();
         }
@@ -145,7 +153,7 @@ class ModuleConfig {
     }
     std::optional<aidl::android::media::audio::common::AudioPortConfig> getSingleConfigForMixPort(
             bool isInput, const aidl::android::media::audio::common::AudioPort& port) const {
-        const auto config = generateAudioMixPortConfigs({port}, isInput, true);
+        const auto config = generateAudioMixPortConfigs({port}, isInput, true /*singleProfile*/);
         if (!config.empty()) {
             return *config.begin();
         }
diff --git a/audio/aidl/vts/VtsHalAudioCoreModuleTargetTest.cpp b/audio/aidl/vts/VtsHalAudioCoreModuleTargetTest.cpp
index 2c692f5db8..7b470a21f8 100644
--- a/audio/aidl/vts/VtsHalAudioCoreModuleTargetTest.cpp
+++ b/audio/aidl/vts/VtsHalAudioCoreModuleTargetTest.cpp
@@ -48,6 +48,7 @@
 #include <aidl/android/media/audio/common/AudioOutputFlags.h>
 #include <android-base/chrono_utils.h>
 #include <android/binder_enums.h>
+#include <audio_utils/Statistics.h>
 #include <error/expected_utils.h>
 #include <fmq/AidlMessageQueue.h>
 
@@ -215,7 +216,7 @@ AudioPort GenerateUniqueDeviceAddress(const AudioPort& port) {
                         0xfc00, 0x0123, 0x4567, 0x89ab, 0xcdef, 0, 0, ++nextId & 0xffff});
                 break;
             case Tag::alsa:
-                address = AudioDeviceAddress::make<Tag::alsa>(std::vector<int32_t>{1, ++nextId});
+                address = AudioDeviceAddress::make<Tag::alsa>(std::vector<int32_t>{127, ++nextId});
                 break;
         }
     }
@@ -862,23 +863,33 @@ class MmapSharedMemory {
 
 struct StreamEventReceiver {
     virtual ~StreamEventReceiver() = default;
-    enum class Event { None, DrainReady, Error, TransferReady };
+    enum class Event : int { None = 0, DrainReady = 1, Error = 2, TransferReady = 4 };
     virtual std::tuple<int, Event> getLastEvent() const = 0;
     virtual std::tuple<int, Event> waitForEvent(int clientEventSeq) = 0;
     static constexpr int kEventSeqInit = -1;
 };
 std::string toString(StreamEventReceiver::Event event) {
-    switch (event) {
-        case StreamEventReceiver::Event::None:
-            return "None";
-        case StreamEventReceiver::Event::DrainReady:
-            return "DrainReady";
-        case StreamEventReceiver::Event::Error:
-            return "Error";
-        case StreamEventReceiver::Event::TransferReady:
-            return "TransferReady";
+    if (event == StreamEventReceiver::Event::None) return "None";
+    std::string result;
+    for (auto e : {StreamEventReceiver::Event::DrainReady, StreamEventReceiver::Event::Error,
+                   StreamEventReceiver::Event::TransferReady}) {
+        if (static_cast<int>(event) & static_cast<int>(e)) {
+            if (!result.empty()) result.append("|");
+            switch (e) {
+                case StreamEventReceiver::Event::DrainReady:
+                    result.append("DrainReady");
+                    break;
+                case StreamEventReceiver::Event::Error:
+                    result.append("Error");
+                    break;
+                case StreamEventReceiver::Event::TransferReady:
+                    result.append("TransferReady");
+                    break;
+                default:;  // Should not happen
+            }
+        }
     }
-    return std::to_string(static_cast<int32_t>(event));
+    return result;
 }
 
 // Note: we use a reference wrapper, not a pointer, because methods of std::*list
@@ -910,17 +921,23 @@ struct Dag : public std::forward_list<DagNode<T>> {
 };
 
 // Transition to the next state happens either due to a command from the client,
-// or after an event received from the server.
-using TransitionTrigger = std::variant<StreamDescriptor::Command, StreamEventReceiver::Event>;
+// or after an event received from the server. It can also be an integer amount of
+// nanoseconds to sleep.
+using TransitionTrigger =
+        std::variant<StreamDescriptor::Command, StreamEventReceiver::Event, int64_t>;
 std::string toString(const TransitionTrigger& trigger) {
     if (std::holds_alternative<StreamDescriptor::Command>(trigger)) {
         return std::string("'")
                 .append(toString(std::get<StreamDescriptor::Command>(trigger).getTag()))
                 .append("' command");
+    } else if (std::holds_alternative<StreamEventReceiver::Event>(trigger)) {
+        return std::string("'")
+                .append(toString(std::get<StreamEventReceiver::Event>(trigger)))
+                .append("' event");
     }
-    return std::string("'")
-            .append(toString(std::get<StreamEventReceiver::Event>(trigger)))
-            .append("' event");
+    return std::string("sleep for ")
+            .append(std::to_string(std::get<int64_t>(trigger)))
+            .append(" ns");
 }
 
 struct StateSequence {
@@ -1079,6 +1096,7 @@ class StreamCommonLogic : public StreamLogic {
                    << mConfig.toString();
         return "";
     }
+    const std::vector<int64_t>& getBurstOccurrences() const { return mBurstOccurrences; }
     const std::vector<int8_t>& getData() const { return mData; }
     void fillData(int8_t filler) { std::fill(mData.begin(), mData.end(), filler); }
     void loadData(std::ifstream& is, size_t* size) {
@@ -1092,9 +1110,9 @@ class StreamCommonLogic : public StreamLogic {
             expEvent != nullptr) {
             auto [eventSeq, event] = mEventReceiver->waitForEvent(mLastEventSeq);
             mLastEventSeq = eventSeq;
-            if (event != *expEvent) {
+            if ((static_cast<int>(event) & static_cast<int>(*expEvent)) == 0) {
                 // TODO: Make available as an error so it can be displayed by GTest
-                LOG(ERROR) << __func__ << ": expected event " << toString(*expEvent) << ", got "
+                LOG(ERROR) << __func__ << ": expected event(s) " << toString(*expEvent) << ", got "
                            << toString(event);
                 return {};
             }
@@ -1102,9 +1120,15 @@ class StreamCommonLogic : public StreamLogic {
             // via 'getStatus'.
             return StreamDescriptor::Command::make<StreamDescriptor::Command::Tag::getStatus>(
                     Void{});
+        } else if (int64_t* sleepNs = std::get_if<int64_t>(&trigger); sleepNs != nullptr) {
+            LOG(INFO) << __func__ << ": sleeping for " << *sleepNs << " ns";
+            std::this_thread::sleep_for(std::chrono::nanoseconds(*sleepNs));
+            return StreamDescriptor::Command::make<StreamDescriptor::Command::Tag::getStatus>(
+                    Void{});
         }
         return std::get<StreamDescriptor::Command>(trigger);
     }
+    void registerBurstNow() { mBurstOccurrences.push_back(::android::uptimeNanos()); }
     bool readDataFromMQ(size_t readCount) {
         std::vector<int8_t> data(readCount);
         if (mDataMQ->read(data.data(), readCount)) {
@@ -1151,6 +1175,7 @@ class StreamCommonLogic : public StreamLogic {
     StreamContext::DataMQ* mDataMQ;
     MmapSharedMemory mMmap;
     std::vector<int8_t> mData;
+    std::vector<int64_t> mBurstOccurrences;
     StreamLogicDriver* const mDriver;
     StreamEventReceiver* const mEventReceiver;
     int mLastEventSeq = StreamEventReceiver::kEventSeqInit;
@@ -1167,7 +1192,8 @@ class StreamReaderLogic : public StreamCommonLogic {
         : StreamCommonLogic(context, driver, stream, eventReceiver),
           mMmapBurstSizeFrames(context.getMmapBurstSizeFrames()) {}
     // Should only be called after the worker has joined.
-    const std::vector<int8_t>& getData() const { return StreamCommonLogic::getData(); }
+    using StreamCommonLogic::getBurstOccurrences;
+    using StreamCommonLogic::getData;
 
   protected:
     Status cycle() override {
@@ -1182,6 +1208,11 @@ class StreamReaderLogic : public StreamCommonLogic {
             LOG(ERROR) << __func__ << ": no next command";
             return Status::ABORT;
         }
+        if (isMmapped() && command.getTag() == StreamDescriptor::Command::Tag::burst &&
+            command.get<StreamDescriptor::Command::Tag::burst>() > 0) {
+            // The value of a valid 'burst' command for MMap must be '0'.
+            command.get<StreamDescriptor::Command::Tag::burst>() = 0;
+        }
         LOG(DEBUG) << "Writing command: " << command.toString();
         if (!getCommandMQ()->writeBlocking(&command, 1)) {
             LOG(ERROR) << __func__ << ": writing of command into MQ failed";
@@ -1245,6 +1276,7 @@ class StreamReaderLogic : public StreamCommonLogic {
         }  // readCount == 0
     checkAcceptedReply:
         if (acceptedReply) {
+            if (command.getTag() == StreamDescriptor::Command::Tag::burst) registerBurstNow();
             return updateMmapSharedMemoryIfNeeded(reply.state) ? Status::CONTINUE : Status::ABORT;
         }
         LOG(ERROR) << __func__ << ": unacceptable reply: " << reply.toString();
@@ -1261,7 +1293,8 @@ class StreamWriterLogic : public StreamCommonLogic {
                       StreamWorkerMethods* stream, StreamEventReceiver* eventReceiver)
         : StreamCommonLogic(context, driver, stream, eventReceiver) {}
     // Should only be called after the worker has joined.
-    const std::vector<int8_t>& getData() const { return StreamCommonLogic::getData(); }
+    using StreamCommonLogic::getBurstOccurrences;
+    using StreamCommonLogic::getData;
 
   protected:
     std::string init() override {
@@ -1325,6 +1358,11 @@ class StreamWriterLogic : public StreamCommonLogic {
             if (isMmapped() ? !writeDataToMmap() : !writeDataToMQ()) {
                 return Status::ABORT;
             }
+            if (isMmapped()) {
+                // The value of the 'burst' command for MMap must be '0'.
+                command.get<StreamDescriptor::Command::Tag::burst>() = 0;
+            }
+            registerBurstNow();
         }
         LOG(DEBUG) << "Writing command: " << command.toString();
         if (!getCommandMQ()->writeBlocking(&command, 1)) {
@@ -1460,6 +1498,9 @@ struct IOTraits {
     static constexpr bool is_input = std::is_same_v<T, IStreamIn>;
     static constexpr const char* directionStr = is_input ? "input" : "output";
     using Worker = std::conditional_t<is_input, StreamReader, StreamWriter>;
+    using IoFlags = std::conditional_t<is_input, AudioInputFlags, AudioOutputFlags>;
+    static constexpr AudioIoFlags::Tag flagTag =
+            is_input ? AudioIoFlags::Tag::input : AudioIoFlags::Tag::output;
 };
 
 template <typename Stream>
@@ -1512,6 +1553,7 @@ class WithStream : public StreamWorkerMethods {
     Stream* get() const { return mStream.get(); }
     const StreamContext* getContext() const { return mContext ? &(mContext.value()) : nullptr; }
     StreamEventReceiver* getEventReceiver() { return mStreamCallback->getEventReceiver(); }
+    int32_t getInterfaceVersion() const { return mInterfaceVersion; }
     std::shared_ptr<Stream> getSharedPointer() const { return mStream; }
     const AudioPortConfig& getPortConfig() const { return mPortConfig.get(); }
     int32_t getPortId() const { return mPortConfig.getId(); }
@@ -2173,9 +2215,7 @@ TEST_P(AudioCoreModule, SetAudioPortConfigInvalidPortAudioGain) {
 TEST_P(AudioCoreModule, TryConnectMissingDevice) {
     // Limit checks to connection types that are known to be detectable by HAL implementations.
     static const std::set<std::string> kCheckedConnectionTypes{
-            AudioDeviceDescription::CONNECTION_HDMI, AudioDeviceDescription::CONNECTION_HDMI_ARC,
-            AudioDeviceDescription::CONNECTION_HDMI_EARC, AudioDeviceDescription::CONNECTION_IP_V4,
-            AudioDeviceDescription::CONNECTION_USB};
+            AudioDeviceDescription::CONNECTION_IP_V4, AudioDeviceDescription::CONNECTION_USB};
     ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());
     std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();
     if (ports.empty()) {
@@ -2643,14 +2683,18 @@ TEST_P(AudioCoreModule, SetVendorParameters) {
 
 // See b/262930731. In the absence of offloaded effect implementations,
 // currently we can only pass a nullptr, and the HAL module must either reject
-// it as an invalid argument, or say that offloaded effects are not supported.
+// it as an invalid/null argument, or say that offloaded effects are not supported.
 TEST_P(AudioCoreModule, AddRemoveEffectInvalidArguments) {
-    ndk::ScopedAStatus addEffectStatus = module->addDeviceEffect(-1, nullptr);
-    ndk::ScopedAStatus removeEffectStatus = module->removeDeviceEffect(-1, nullptr);
-    if (addEffectStatus.getExceptionCode() != EX_UNSUPPORTED_OPERATION) {
-        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, addEffectStatus.getExceptionCode());
-        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, removeEffectStatus.getExceptionCode());
-    } else if (removeEffectStatus.getExceptionCode() != EX_UNSUPPORTED_OPERATION) {
+    const binder_exception_t addException = module->addDeviceEffect(-1, nullptr).getExceptionCode();
+    const binder_exception_t removeException =
+            module->removeDeviceEffect(-1, nullptr).getExceptionCode();
+    EXPECT_EQ(addException, removeException);
+    if (addException != EX_UNSUPPORTED_OPERATION) {
+        EXPECT_TRUE(addException == EX_ILLEGAL_ARGUMENT || addException == EX_NULL_POINTER)
+                << "unexpected addException: " << addException;
+        EXPECT_TRUE(removeException == EX_ILLEGAL_ARGUMENT || removeException == EX_NULL_POINTER)
+                << "unexpected removeException: " << removeException;
+    } else if (removeException != EX_UNSUPPORTED_OPERATION) {
         GTEST_FAIL() << "addDeviceEffect and removeDeviceEffect must be either supported or "
                      << "not supported together";
     } else {
@@ -2662,8 +2706,15 @@ TEST_P(AudioCoreModule, AddRemoveEffectInvalidArguments) {
     for (const auto& config : configs) {
         WithAudioPortConfig portConfig(config);
         ASSERT_NO_FATAL_FAILURE(portConfig.SetUp(module.get()));
-        EXPECT_STATUS(EX_ILLEGAL_ARGUMENT, module->addDeviceEffect(portConfig.getId(), nullptr));
-        EXPECT_STATUS(EX_ILLEGAL_ARGUMENT, module->removeDeviceEffect(portConfig.getId(), nullptr));
+        const binder_exception_t addException =
+                module->addDeviceEffect(portConfig.getId(), nullptr).getExceptionCode();
+        const binder_exception_t removeException =
+                module->removeDeviceEffect(portConfig.getId(), nullptr).getExceptionCode();
+        EXPECT_EQ(addException, removeException);
+        EXPECT_TRUE(addException == EX_ILLEGAL_ARGUMENT || addException == EX_NULL_POINTER)
+                << "unexpected addException: " << addException;
+        EXPECT_TRUE(removeException == EX_ILLEGAL_ARGUMENT || removeException == EX_NULL_POINTER)
+                << "unexpected removeException: " << removeException;
     }
 }
 
@@ -3238,6 +3289,7 @@ class StreamFixture {
     Stream* getStream() const { return mStream->get(); }
     const StreamContext* getStreamContext() const { return mStream->getContext(); }
     StreamEventReceiver* getStreamEventReceiver() { return mStream->getEventReceiver(); }
+    int32_t getStreamInterfaceVersion() const { return mStream->getInterfaceVersion(); }
     std::shared_ptr<Stream> getStreamSharedPointer() const { return mStream->getSharedPointer(); }
     StreamWorkerMethods* getStreamWorkerMethods() const { return mStream.get(); }
     const std::string& skipTestReason() const { return mSkipTestReason; }
@@ -3447,9 +3499,12 @@ class StreamLogicDefaultDriver : public StreamLogicDriver {
 // Defined later together with state transition sequences.
 std::shared_ptr<StateSequence> makeBurstCommands(bool isSync, size_t burstCount = 10,
                                                  bool standbyInputWhenDone = false);
+std::shared_ptr<StateSequence> makeSyncOutBurstStandbyCommands(size_t burstCount, size_t cycleCount,
+                                                               int interCycleSleepNs);
 
 // Certain types of ports can not be used without special preconditions.
-static bool skipStreamIoTestForMixPortConfig(const AudioPortConfig& portConfig) {
+static bool skipStreamIoTestForMixPortConfig(const AudioPortConfig& portConfig,
+                                             int32_t aidlVersion) {
     return (portConfig.flags.value().getTag() == AudioIoFlags::input &&
             isAnyBitPositionFlagSet(portConfig.flags.value().template get<AudioIoFlags::input>(),
                                     {AudioInputFlags::VOIP_TX, AudioInputFlags::HW_HOTWORD,
@@ -3459,7 +3514,7 @@ static bool skipStreamIoTestForMixPortConfig(const AudioPortConfig& portConfig)
                                      {AudioOutputFlags::VOIP_RX, AudioOutputFlags::INCALL_MUSIC}) ||
              (isBitPositionFlagSet(portConfig.flags.value().template get<AudioIoFlags::output>(),
                                    AudioOutputFlags::COMPRESS_OFFLOAD) &&
-              !getMediaFileInfoForConfig(portConfig))));
+              (aidlVersion <= kAidlVersion3 || !getMediaFileInfoForConfig(portConfig)))));
 }
 
 // Certain types of devices can not be used without special preconditions.
@@ -3509,14 +3564,10 @@ class StreamFixtureWithWorker {
         ASSERT_NO_FATAL_FAILURE(JoinWorkerAfterBurstCommands(validatePosition));
     }
 
-    void StartWorkerToSendBurstCommands(size_t burstCount = 10, bool standbyInputWhenDone = false) {
-        if (!IOTraits<Stream>::is_input) {
-            ASSERT_FALSE(standbyInputWhenDone) << "Only supported for input";
-        }
+    void StartWorkerWithStateSequence(std::shared_ptr<StateSequence> seq) {
         const StreamContext* context = mStream->getStreamContext();
         mWorkerDriver = std::make_unique<StreamLogicDefaultDriver>(
-                makeBurstCommands(mIsSync, burstCount, standbyInputWhenDone),
-                context->getFrameSizeBytes(), context->isMmapped());
+                seq, context->getFrameSizeBytes(), context->isMmapped());
         mWorker = std::make_unique<typename IOTraits<Stream>::Worker>(
                 *context, mWorkerDriver.get(), mStream->getStreamWorkerMethods(),
                 mStream->getStreamEventReceiver());
@@ -3524,6 +3575,22 @@ class StreamFixtureWithWorker {
         ASSERT_TRUE(mWorker->start());
     }
 
+    void StartWorkerToSendBurstCommands(size_t burstCount = 10, bool standbyInputWhenDone = false) {
+        if (!IOTraits<Stream>::is_input) {
+            ASSERT_FALSE(standbyInputWhenDone) << "standbyInputWhenDone only supported for input";
+        }
+        ASSERT_NO_FATAL_FAILURE(StartWorkerWithStateSequence(
+                makeBurstCommands(mIsSync, burstCount, standbyInputWhenDone)));
+    }
+
+    void StartOutWorkerForBurstStandbyCycle(size_t burstCount, size_t cycleCount,
+                                            int interCycleSleepNs) {
+        ASSERT_FALSE(IOTraits<Stream>::is_input) << "Only supported for output";
+        ASSERT_TRUE(mIsSync) << "Only supported for synchronous I/O";
+        ASSERT_NO_FATAL_FAILURE(StartWorkerWithStateSequence(
+                makeSyncOutBurstStandbyCommands(burstCount, cycleCount, interCycleSleepNs)));
+    }
+
     void JoinWorkerAfterBurstCommands(bool validatePosition = true,
                                       bool callPrepareToClose = true) {
         if (callPrepareToClose) {
@@ -3542,12 +3609,14 @@ class StreamFixtureWithWorker {
             EXPECT_FALSE(mWorkerDriver->hasHardwareRetrogradePosition());
         }
         mLastData = mWorker->getData();
+        mBurstOccurrences = mWorker->getBurstOccurrences();
         mWorker.reset();
         mWorkerDriver.reset();
     }
 
     void TeardownPatch() { mStream->TeardownPatch(); }
 
+    const std::vector<int64_t>& getBurstOccurrences() const { return mBurstOccurrences; }
     const AudioDevice& getDevice() const { return mStream->getDevice(); }
     const AudioPortConfig& getDevicePortConfig() const { return mStream->getDevicePortConfig(); }
     const std::vector<int8_t>& getLastData() const { return mLastData; }
@@ -3559,7 +3628,8 @@ class StreamFixtureWithWorker {
 
   private:
     void MaybeSetSkipTestReason() {
-        if (skipStreamIoTestForMixPortConfig(mStream->getPortConfig())) {
+        if (skipStreamIoTestForMixPortConfig(mStream->getPortConfig(),
+                                             mStream->getStreamInterfaceVersion())) {
             mSkipTestReason = "Mix port config is not supported for stream I/O tests";
         }
         if (skipStreamIoTestForStream(mStream->getStreamContext(),
@@ -3574,6 +3644,7 @@ class StreamFixtureWithWorker {
     std::unique_ptr<StreamLogicDefaultDriver> mWorkerDriver;
     std::unique_ptr<typename IOTraits<Stream>::Worker> mWorker;
     std::vector<int8_t> mLastData;
+    std::vector<int64_t> mBurstOccurrences;
 };
 
 template <typename Stream>
@@ -3730,11 +3801,40 @@ class AudioStream : public AudioCoreModule {
     }
 
     void SendInvalidCommand() {
-        const auto portConfig = moduleConfig->getSingleConfigForMixPort(IOTraits<Stream>::is_input);
-        if (!portConfig.has_value()) {
+        // Since the processing of the 'burst' command is different for MMAP and non-MMAP
+        // streams, test them separately.
+        bool hasAtLeastOnePort = false;
+        {
+            auto ports =
+                    moduleConfig->getMixPorts(IOTraits<Stream>::is_input, true /*connectedOnly*/);
+            auto portIt = std::find_if(ports.begin(), ports.end(), [&](const AudioPort& port) {
+                return !isBitPositionFlagSet(port.flags.get<IOTraits<Stream>::flagTag>(),
+                                             IOTraits<Stream>::IoFlags::MMAP_NOIRQ);
+            });
+            if (portIt != ports.end()) {
+                const auto portConfig = moduleConfig->getSingleConfigForMixPort(
+                        IOTraits<Stream>::is_input, *portIt);
+                if (portConfig.has_value()) {
+                    hasAtLeastOnePort = true;
+                    EXPECT_NO_FATAL_FAILURE(SendInvalidCommandImpl(portConfig.value()));
+                }
+            }
+        }
+        {
+            auto ports = moduleConfig->getMmapMixPorts(IOTraits<Stream>::is_input,
+                                                       true /*connectedOnly*/, true /*singlePort*/);
+            if (!ports.empty()) {
+                const auto portConfig = moduleConfig->getSingleConfigForMixPort(
+                        IOTraits<Stream>::is_input, *ports.begin());
+                if (portConfig.has_value()) {
+                    hasAtLeastOnePort = true;
+                    EXPECT_NO_FATAL_FAILURE(SendInvalidCommandImpl(portConfig.value()));
+                }
+            }
+        }
+        if (!hasAtLeastOnePort) {
             GTEST_SKIP() << "No mix port for attached devices";
         }
-        EXPECT_NO_FATAL_FAILURE(SendInvalidCommandImpl(portConfig.value()));
     }
 
     void UpdateHwAvSyncId() {
@@ -3836,7 +3936,7 @@ class AudioStream : public AudioCoreModule {
 
     // See b/262930731. In the absence of offloaded effect implementations,
     // currently we can only pass a nullptr, and the HAL module must either reject
-    // it as an invalid argument, or say that offloaded effects are not supported.
+    // it as an invalid/null argument, or say that offloaded effects are not supported.
     void AddRemoveEffectInvalidArguments() {
         constexpr bool connectedOnly = true;
         const auto ports = moduleConfig->getMixPorts(IOTraits<Stream>::is_input, connectedOnly);
@@ -3855,13 +3955,19 @@ class AudioStream : public AudioCoreModule {
             std::shared_ptr<IStreamCommon> streamCommon;
             ASSERT_IS_OK(stream.getStream()->getStreamCommon(&streamCommon));
             ASSERT_NE(nullptr, streamCommon);
-            ndk::ScopedAStatus addEffectStatus = streamCommon->addEffect(nullptr);
-            ndk::ScopedAStatus removeEffectStatus = streamCommon->removeEffect(nullptr);
-            if (addEffectStatus.getExceptionCode() != EX_UNSUPPORTED_OPERATION) {
-                EXPECT_EQ(EX_ILLEGAL_ARGUMENT, addEffectStatus.getExceptionCode());
-                EXPECT_EQ(EX_ILLEGAL_ARGUMENT, removeEffectStatus.getExceptionCode());
+            const binder_exception_t addException =
+                    streamCommon->addEffect(nullptr).getExceptionCode();
+            const binder_exception_t removeException =
+                    streamCommon->removeEffect(nullptr).getExceptionCode();
+            EXPECT_EQ(addException, removeException);
+            if (addException != EX_UNSUPPORTED_OPERATION) {
+                EXPECT_TRUE(addException == EX_ILLEGAL_ARGUMENT || addException == EX_NULL_POINTER)
+                        << "unexpected addException: " << addException;
+                EXPECT_TRUE(removeException == EX_ILLEGAL_ARGUMENT ||
+                            removeException == EX_NULL_POINTER)
+                        << "unexpected removeException: " << removeException;
                 atLeastOneSupports = true;
-            } else if (removeEffectStatus.getExceptionCode() != EX_UNSUPPORTED_OPERATION) {
+            } else if (removeException != EX_UNSUPPORTED_OPERATION) {
                 ADD_FAILURE() << "addEffect and removeEffect must be either supported or "
                               << "not supported together";
                 atLeastOneSupports = true;
@@ -4276,8 +4382,10 @@ TEST_P(AudioStreamOut, PlaybackRate) {
     EXPECT_LE(factors.minSpeed, factors.maxSpeed);
     EXPECT_LE(factors.minPitch, factors.maxPitch);
     EXPECT_LE(factors.minSpeed, 1.0f);
+    EXPECT_GE(factors.minSpeed, 0);
     EXPECT_GE(factors.maxSpeed, 1.0f);
     EXPECT_LE(factors.minPitch, 1.0f);
+    EXPECT_GE(factors.minPitch, 0);
     EXPECT_GE(factors.maxPitch, 1.0f);
     constexpr auto tsDefault = AudioPlaybackRate::TimestretchMode::DEFAULT;
     constexpr auto tsVoice = AudioPlaybackRate::TimestretchMode::VOICE;
@@ -4312,8 +4420,18 @@ TEST_P(AudioStreamOut, PlaybackRate) {
             // is "mute".
             AudioPlaybackRate{factors.maxSpeed * 2, factors.maxPitch * 2, tsDefault, fbMute},
             AudioPlaybackRate{factors.minSpeed / 2, factors.minPitch / 2, tsDefault, fbMute},
+            AudioPlaybackRate{-factors.maxSpeed, -factors.maxPitch, tsDefault, fbMute},
+            AudioPlaybackRate{-factors.minSpeed, -factors.minPitch, tsDefault, fbMute},
+            AudioPlaybackRate{std::numeric_limits<float>::infinity(),
+                              std::numeric_limits<float>::infinity(), tsDefault, fbMute},
+            AudioPlaybackRate{NAN, NAN, tsDefault, fbMute},
             AudioPlaybackRate{factors.maxSpeed * 2, factors.maxPitch * 2, tsVoice, fbMute},
             AudioPlaybackRate{factors.minSpeed / 2, factors.minPitch / 2, tsVoice, fbMute},
+            AudioPlaybackRate{-factors.maxSpeed, -factors.maxPitch, tsVoice, fbMute},
+            AudioPlaybackRate{-factors.minSpeed, -factors.minPitch, tsVoice, fbMute},
+            AudioPlaybackRate{std::numeric_limits<float>::infinity(),
+                              std::numeric_limits<float>::infinity(), tsVoice, fbMute},
+            AudioPlaybackRate{NAN, NAN, tsVoice, fbMute},
     };
     bool atLeastOneSupports = false;
     for (const auto& port : offloadMixPorts) {
@@ -4321,6 +4439,14 @@ TEST_P(AudioStreamOut, PlaybackRate) {
         ASSERT_TRUE(portConfig.has_value()) << "No profiles specified for output mix port";
         WithStream<IStreamOut> stream(portConfig.value());
         ASSERT_NO_FATAL_FAILURE(stream.SetUp(module.get(), kDefaultLargeBufferSizeFrames));
+        if (stream.getInterfaceVersion() >= kAidlVersion3) {
+            AudioPlaybackRate playbackRate;
+            status = stream.get()->getPlaybackRateParameters(&playbackRate);
+            if (status.getExceptionCode() != EX_UNSUPPORTED_OPERATION) {
+                EXPECT_NE(playbackRate.speed, 0);
+                EXPECT_NE(playbackRate.pitch, 0);
+            }
+        }
         bool isSupported = false;
         EXPECT_NO_FATAL_FAILURE(TestAccessors<AudioPlaybackRate>(
                 stream.get(), &IStreamOut::getPlaybackRateParameters,
@@ -4453,7 +4579,7 @@ class AudioStreamIo : public AudioCoreModuleBase,
             ASSERT_TRUE(port.has_value());
             SCOPED_TRACE(port->toString());
             SCOPED_TRACE(portConfig.toString());
-            if (skipStreamIoTestForMixPortConfig(portConfig)) continue;
+            if (skipStreamIoTestForMixPortConfig(portConfig, aidlVersion)) continue;
             const bool isNonBlocking =
                     IOTraits<Stream>::is_input
                             ? false
@@ -5088,6 +5214,179 @@ static const NamedCommandSequence kDrainEarlyOffloadSeq =
                         StreamTypeFilter::OFFLOAD, makeDrainEarlyOffloadCommands(),
                         true /*validatePositionIncrease*/);
 
+// DRAINING_en ->(onDrainReady) DRAINING_en_sent ->(burst) DRAINING_en_sent
+//   ->(onTransferReady) DRAINING
+//   ->(onDrainReady)    IDLE | TRANSFERRING
+std::shared_ptr<StateSequence> makeDrainEarlyAddSecondClipOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node lastDraining = d->makeFinalNode(State::DRAINING);
+    StateDag::Node lastIdle = d->makeFinalNode(State::IDLE);
+    StateDag::Node lastTransferring = d->makeFinalNode(State::TRANSFERRING);
+    // Wait for onTransferReady or the second onDrainReady event.
+    // Somewhat counter intuitive that onTransferReady leaves the stream in the DRAINING state
+    // (it is still draining the first clip, but at the same time accepting data for the next one).
+    StateDag::Node continueDraining = d->makeNode(
+            State::DRAINING,
+            static_cast<StreamEventReceiver::Event>(static_cast<int>(kDrainReadyEvent) |
+                                                    static_cast<int>(kTransferReadyEvent)),
+            lastDraining, lastIdle, lastTransferring);
+    StateDag::Node secondClip = d->makeNode(State::DRAINING, kBurstCommand, continueDraining);
+    // The first onDrainReady event.
+    StateDag::Node draining = d->makeNode(State::DRAINING, kDrainReadyEvent, secondClip);
+    StateDag::Node drain = d->makeNode(State::ACTIVE, kDrainOutEarlyCommand, draining);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyAddSecondClipOffloadSeq = std::make_tuple(
+        std::string("DrainEarlyAddSecondClip"), kAidlVersion3, "aosp.clipTransitionSupport", 0,
+        StreamTypeFilter::OFFLOAD, makeDrainEarlyAddSecondClipOffloadCommands(),
+        true /*validatePositionIncrease*/);
+
+// DRAINING_en ->(burst) TRANSFERRING | IDLE
+std::shared_ptr<StateSequence> makeDrainEarlyCancelOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node lastIdle = d->makeFinalNode(State::IDLE);
+    StateDag::Node lastTransferring = d->makeFinalNode(State::TRANSFERRING);
+    // Cancel draining by sending the burst command before the first onDrainReady event.
+    StateDag::Node draining =
+            d->makeNode(State::DRAINING, kBurstCommand, lastIdle, lastTransferring);
+    StateDag::Node drain = d->makeNode(State::ACTIVE, kDrainOutEarlyCommand, draining);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyCancelOffloadSeq =
+        std::make_tuple(std::string("DrainEarlyCancel"), kAidlVersion3,
+                        "aosp.clipTransitionSupport", 0, StreamTypeFilter::OFFLOAD,
+                        makeDrainEarlyOffloadCommands(), true /*validatePositionIncrease*/);
+
+//  DRAINING_en ->(pause) DRAIN_PAUSED_en ->(start) DRAINING_en -> same as DrainEarlyOffload
+std::shared_ptr<StateSequence> makeDrainEarlyPauseBeforeNotifOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node lastIdle = d->makeFinalNode(State::IDLE);
+    StateDag::Node lastTransferring = d->makeFinalNode(State::TRANSFERRING);
+    // The second onDrainReady event.
+    StateDag::Node continueDraining =
+            d->makeNode(State::DRAINING, kDrainReadyEvent, lastIdle, lastTransferring);
+    // Pause draining by sending the pause command before the first onDrainReady event.
+    StateDag::Node drain = d->makeNodes({std::make_pair(State::ACTIVE, kDrainOutEarlyCommand),
+                                         std::make_pair(State::DRAINING, kPauseCommand),
+                                         std::make_pair(State::DRAIN_PAUSED, kStartCommand),
+                                         // The first onDrainReady event.
+                                         std::make_pair(State::DRAINING, kDrainReadyEvent)},
+                                        continueDraining);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyPauseBeforeNotifOffloadSeq = std::make_tuple(
+        std::string("DrainEarlyPauseBeforeNotif"), kAidlVersion3, "aosp.clipTransitionSupport", 0,
+        StreamTypeFilter::OFFLOAD, makeDrainEarlyPauseBeforeNotifOffloadCommands(),
+        true /*validatePositionIncrease*/);
+
+// DRAINING_en ->(pause) DRAIN_PAUSED_en ->(burst) TRANSFER_PAUSED
+std::shared_ptr<StateSequence> makeDrainEarlyPauseBeforeNotifCancelOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node drain = d->makeNodes(
+            {std::make_pair(State::ACTIVE, kDrainOutEarlyCommand),
+             std::make_pair(State::DRAINING, kPauseCommand),
+             // Pause draining by sending the pause command before the first onDrainReady event.
+             std::make_pair(State::DRAIN_PAUSED, kBurstCommand)},
+            State::TRANSFER_PAUSED);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyPauseBeforeNotifCancelOffloadSeq = std::make_tuple(
+        std::string("DrainEarlyPauseBeforeNotifCancel"), kAidlVersion3,
+        "aosp.clipTransitionSupport", 0, StreamTypeFilter::OFFLOAD,
+        makeDrainEarlyPauseBeforeNotifCancelOffloadCommands(), true /*validatePositionIncrease*/);
+
+// DRAINING_en ->(pause) DRAIN_PAUSED_en ->(flush) IDLE
+std::shared_ptr<StateSequence> makeDrainEarlyPauseBeforeNotifFlushOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node drain = d->makeNodes(
+            {std::make_pair(State::ACTIVE, kDrainOutEarlyCommand),
+             std::make_pair(State::DRAINING, kPauseCommand),
+             // Cancel draining by sending the flush command before the first onDrainReady event.
+             std::make_pair(State::DRAIN_PAUSED, kFlushCommand)},
+            State::IDLE);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyPauseBeforeNotifFlushOffloadSeq = std::make_tuple(
+        std::string("DrainEarlyPauseBeforeNotifFlush"), kAidlVersion3, "aosp.clipTransitionSupport",
+        0, StreamTypeFilter::OFFLOAD, makeDrainEarlyPauseBeforeNotifFlushOffloadCommands(),
+        true /*validatePositionIncrease*/);
+
+// DRAINING_en ->(onDrainReady) DRAINING_en_sent ->(pause) DRAIN_PAUSED_en_sent ->(flush) IDLE
+std::shared_ptr<StateSequence> makeDrainEarlyPauseAfterNotifFlushOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node drain = d->makeNodes(
+            {std::make_pair(State::ACTIVE, kDrainOutEarlyCommand),
+             std::make_pair(State::DRAINING, kDrainReadyEvent),
+             std::make_pair(State::DRAINING, kPauseCommand),
+             // Cancel draining by sending the flush command after the first onDrainReady event.
+             std::make_pair(State::DRAIN_PAUSED, kFlushCommand)},
+            State::IDLE);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyPauseAfterNotifFlushOffloadSeq = std::make_tuple(
+        std::string("DrainEarlyPauseAfterNotifFlush"), kAidlVersion3, "aosp.clipTransitionSupport",
+        0, StreamTypeFilter::OFFLOAD, makeDrainEarlyPauseAfterNotifFlushOffloadCommands(),
+        true /*validatePositionIncrease*/);
+
+// DRAINING_en ->(onDrainReady) DRAINING_en_sent ->(pause) DRAIN_PAUSED_en_sent ->(burst)
+//   DRAIN_PAUSED_en_sent ->(start) DRAINING_en_sent ->(onDrainReady) IDLE | TRANSFERRING
+std::shared_ptr<StateSequence> makeDrainEarlyPauseAfterReadyOffloadCommands() {
+    using State = StreamDescriptor::State;
+    auto d = std::make_unique<StateDag>();
+    StateDag::Node lastIdle = d->makeFinalNode(State::IDLE);
+    StateDag::Node lastTransferring = d->makeFinalNode(State::TRANSFERRING);
+    // The second onDrainReady event.
+    StateDag::Node continueDraining =
+            d->makeNode(State::DRAINING, kDrainReadyEvent, lastIdle, lastTransferring);
+    StateDag::Node drain = d->makeNodes(
+            {std::make_pair(State::ACTIVE, kDrainOutEarlyCommand),
+             std::make_pair(State::DRAINING, kDrainReadyEvent),
+             std::make_pair(State::DRAINING, kPauseCommand),
+             std::make_pair(State::DRAIN_PAUSED, kBurstCommand),
+             // Burst commands sent in the 'en_sent' sub-state must not affect the state.
+             std::make_pair(State::DRAIN_PAUSED, kStartCommand)},
+            continueDraining);
+    StateDag::Node active = makeAsyncBurstCommands(d.get(), 10, drain);
+    StateDag::Node idle = d->makeNode(State::IDLE, kBurstCommand, active);
+    idle.children().push_back(d->makeNode(State::TRANSFERRING, kTransferReadyEvent, active));
+    d->makeNode(State::STANDBY, kStartCommand, idle);
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+static const NamedCommandSequence kDrainEarlyPauseAfterReadyOffloadSeq = std::make_tuple(
+        std::string("DrainEarlyPauseAfterReady"), kAidlVersion3, "aosp.clipTransitionSupport", 0,
+        StreamTypeFilter::OFFLOAD, makeDrainEarlyPauseAfterReadyOffloadCommands(),
+        true /*validatePositionIncrease*/);
+
 std::shared_ptr<StateSequence> makeDrainPauseOutCommands(bool isSync) {
     using State = StreamDescriptor::State;
     auto d = std::make_unique<StateDag>();
@@ -5334,7 +5633,13 @@ INSTANTIATE_TEST_SUITE_P(
                                          kStandbyOutSyncSeq, kStandbyOutAsyncSeq, kPauseOutSyncSeq,
                                          kPauseOutAsyncSeq, kFlushOutSyncSeq, kFlushOutAsyncSeq,
                                          kDrainPauseFlushOutSyncSeq, kDrainPauseFlushOutAsyncSeq,
-                                         kDrainEarlyOffloadSeq),
+                                         kDrainEarlyOffloadSeq, kDrainEarlyAddSecondClipOffloadSeq,
+                                         kDrainEarlyCancelOffloadSeq,
+                                         kDrainEarlyPauseBeforeNotifOffloadSeq,
+                                         kDrainEarlyPauseBeforeNotifCancelOffloadSeq,
+                                         kDrainEarlyPauseBeforeNotifFlushOffloadSeq,
+                                         kDrainEarlyPauseAfterNotifFlushOffloadSeq,
+                                         kDrainEarlyPauseAfterReadyOffloadSeq),
                          testing::Values(false, true)),
         GetStreamIoTestName);
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(AudioStreamIoOut);
@@ -5344,6 +5649,27 @@ INSTANTIATE_TEST_SUITE_P(AudioPatchTest, AudioModulePatch,
                          android::PrintInstanceNameToString);
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(AudioModulePatch);
 
+std::shared_ptr<StateSequence> makeSyncOutBurstStandbyCommands(size_t burstCount, size_t cycleCount,
+                                                               int interCycleSleepNs) {
+    using State = StreamDescriptor::State;
+    using NodeRef = std::reference_wrapper<DagNode<StateTransitionFrom>>;
+    auto d = std::make_unique<StateDag>();
+    // Note: the DAG is built in a reverse order, starting from the final node.
+    NodeRef prevCycle(d->makeFinalNode(State::STANDBY));
+    for (size_t i = 0; i < cycleCount; ++i) {
+        StateDag::Node standby = d->makeNodes({std::make_pair(State::ACTIVE, kPauseCommand),
+                                               std::make_pair(State::PAUSED, kFlushCommand),
+                                               std::make_pair(State::IDLE, kStandbyCommand),
+                                               std::make_pair(State::STANDBY, interCycleSleepNs)},
+                                              prevCycle.get());
+        StateDag::Node idle =
+                d->makeNode(State::IDLE, kBurstCommand,
+                            d->makeNodes(State::ACTIVE, kBurstCommand, burstCount, standby));
+        prevCycle = NodeRef(d->makeNode(State::STANDBY, kStartCommand, idle));
+    }
+    return std::make_shared<StateSequenceFollower>(std::move(d));
+}
+
 static std::vector<std::string> getRemoteSubmixModuleInstance() {
     auto instances = android::getAidlHalInstanceNames(IModule::descriptor);
     for (auto instance : instances) {
@@ -5393,6 +5719,12 @@ class WithRemoteSubmix {
                 mStream.StartWorkerToSendBurstCommands(burstCount, standbyInputWhenDone));
     }
 
+    void StartOutWorkerForBurstStandbyCycle(size_t burstCount, size_t cycleCount,
+                                            int interCycleSleepNs) {
+        ASSERT_NO_FATAL_FAILURE(mStream.StartOutWorkerForBurstStandbyCycle(burstCount, cycleCount,
+                                                                           interCycleSleepNs));
+    }
+
     void JoinWorkerAfterBurstCommands(bool callPrepareToCloseBeforeJoin) {
         ASSERT_NO_FATAL_FAILURE(mStream.JoinWorkerAfterBurstCommands(
                 true /*validatePositionIncrease*/, callPrepareToCloseBeforeJoin));
@@ -5414,6 +5746,15 @@ class WithRemoteSubmix {
     }
 
     std::optional<AudioDeviceAddress> getAudioDeviceAddress() const { return mAddress; }
+    std::vector<int64_t> getBurstIntervals() const {
+        const auto& occurrences = mStream.getBurstOccurrences();
+        if (occurrences.empty()) return {};
+        std::vector<int64_t> result;
+        for (size_t i = 0; i < occurrences.size() - 1; ++i) {
+            result.push_back(occurrences[i + 1] - occurrences[i]);
+        }
+        return result;
+    }
     const AudioPortConfig& getDevicePortConfig() const { return mStream.getDevicePortConfig(); }
     int8_t getLastBurstIteration() const { return mStream.getLastData()[0]; }
     const AudioPortConfig& getPortConfig() const { return mStream.getPortConfig(); }
@@ -5426,11 +5767,21 @@ class WithRemoteSubmix {
 
 class AudioModuleRemoteSubmix : public AudioCoreModule {
   public:
+    static constexpr const auto kStreamStartOffset = std::chrono::nanoseconds(100ms);
+    static constexpr const int kBurstCount = 50;
+    static constexpr const int kBurstCountTolerance = 2;
+    static constexpr const double kBurstInputIntervalsAlpha = .999;
+    // Output bursts are regulated by MonoPipe and exhibit shorter interval times at start.
+    static constexpr const double kBurstOutputIntervalsAlpha = .99;
+    static constexpr const int kIntervalsMeanTolerance = std::chrono::nanoseconds(2ms).count();
+    static constexpr const auto kIntervalsStdDevTolerance = std::chrono::nanoseconds(5ms).count();
+
     void SetUp() override {
         // Turn off "debug" which enables connections simulation. Since devices of the remote
         // submix module are virtual, there is no need for simulation.
         ASSERT_NO_FATAL_FAILURE(SetUpImpl(GetParam(), false /*setUpDebug*/));
-        if (int32_t version; module->getInterfaceVersion(&version).isOk() && version < 2) {
+        if (int32_t version;
+            module->getInterfaceVersion(&version).isOk() && version < kAidlVersion2) {
             GTEST_SKIP() << "V1 uses a deprecated remote submix device type encoding";
         }
         ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());
@@ -5441,35 +5792,68 @@ class AudioModuleRemoteSubmix : public AudioCoreModule {
         streamOut.reset();
     }
 
-    void CreateOutputStream() {
-        streamOut = std::make_unique<WithRemoteSubmix<IStreamOut>>();
-        ASSERT_NO_FATAL_FAILURE(streamOut->SetUp(module.get(), moduleConfig.get()));
-        // Note: any issue with connection attempts is considered as a problem.
-        ASSERT_EQ("", streamOut->skipTestReason());
-        ASSERT_TRUE(streamOut->getAudioDeviceAddress().has_value());
+    void CreateInputStream(const std::optional<AudioDeviceAddress>& address = std::nullopt) {
+        CreateStream<IStreamIn, IStreamOut>(streamIn, streamOut, address);
     }
 
-    void CreateInputStream(const std::optional<AudioDeviceAddress>& address = std::nullopt) {
-        if (address.has_value()) {
-            streamIn = std::make_unique<WithRemoteSubmix<IStreamIn>>(address.value());
-        } else {
-            ASSERT_TRUE(streamOut->getAudioDeviceAddress().has_value());
-            streamIn = std::make_unique<WithRemoteSubmix<IStreamIn>>(
-                    streamOut->getAudioDeviceAddress().value());
+    void CreateOutputStream(const std::optional<AudioDeviceAddress>& address = std::nullopt) {
+        CreateStream<IStreamOut, IStreamIn>(streamOut, streamIn, address);
+    }
+
+    void VerifyBurstIntervalsUniformity() {
+        ::android::audio_utils::Statistics<double> inputIntervals(kBurstInputIntervalsAlpha),
+            outputIntervals(kBurstOutputIntervalsAlpha);
+        for (const auto a : streamIn->getBurstIntervals()) {
+            inputIntervals.add(a);
         }
-        ASSERT_NO_FATAL_FAILURE(streamIn->SetUp(module.get(), moduleConfig.get()));
-        ASSERT_EQ("", streamIn->skipTestReason());
-        auto inAddress = streamIn->getAudioDeviceAddress();
-        ASSERT_TRUE(inAddress.has_value());
+        for (const auto a : streamOut->getBurstIntervals()) {
+            outputIntervals.add(a);
+        }
+        EXPECT_NEAR(inputIntervals.getN(), outputIntervals.getN(), kBurstCountTolerance)
+                << "input intervals: "
+                << ::android::internal::ToString(streamIn->getBurstIntervals())
+                << ", output intervals: "
+                << ::android::internal::ToString(streamOut->getBurstIntervals());
+        EXPECT_NEAR(inputIntervals.getMean(), outputIntervals.getMean(),
+                    kIntervalsMeanTolerance)
+                << "input intervals: "
+                << ::android::internal::ToString(streamIn->getBurstIntervals())
+                << ", output intervals: "
+                << ::android::internal::ToString(streamOut->getBurstIntervals());
+        EXPECT_LT(inputIntervals.getStdDev(), kIntervalsStdDevTolerance)
+                << ::android::internal::ToString(streamIn->getBurstIntervals());
+        EXPECT_LT(outputIntervals.getStdDev(), kIntervalsStdDevTolerance)
+                << ::android::internal::ToString(streamOut->getBurstIntervals());
+    }
+
+  private:
+    template <class ThisStream, class OtherStream>
+    void CreateStream(std::unique_ptr<WithRemoteSubmix<ThisStream>>& thisStream,
+                      std::unique_ptr<WithRemoteSubmix<OtherStream>>& otherStream,
+                      const std::optional<AudioDeviceAddress>& address) {
+        std::optional<AudioDeviceAddress> requestedAddress;
         if (address.has_value()) {
-            if (address.value() != AudioDeviceAddress{}) {
-                ASSERT_EQ(address.value(), inAddress.value());
-            }
+            requestedAddress = address;
+        } else if (otherStream) {
+            ASSERT_TRUE(otherStream->getAudioDeviceAddress().has_value());
+            requestedAddress = otherStream->getAudioDeviceAddress().value();
+        }
+        if (requestedAddress.has_value()) {
+            thisStream = std::make_unique<WithRemoteSubmix<ThisStream>>(requestedAddress.value());
         } else {
-            ASSERT_EQ(streamOut->getAudioDeviceAddress().value(), inAddress.value());
+            thisStream = std::make_unique<WithRemoteSubmix<ThisStream>>();
+        }
+        ASSERT_NO_FATAL_FAILURE(thisStream->SetUp(module.get(), moduleConfig.get()));
+        // Note: any issue with connection attempts is considered as a problem.
+        ASSERT_EQ("", thisStream->skipTestReason());
+        const auto actualAddress = thisStream->getAudioDeviceAddress();
+        ASSERT_TRUE(actualAddress.has_value());
+        if (requestedAddress.has_value() && requestedAddress.value() != AudioDeviceAddress{}) {
+            ASSERT_EQ(requestedAddress.value(), actualAddress.value());
         }
     }
 
+  public:
     std::unique_ptr<WithRemoteSubmix<IStreamOut>> streamOut;
     std::unique_ptr<WithRemoteSubmix<IStreamIn>> streamIn;
 };
@@ -5511,9 +5895,10 @@ TEST_P(AudioModuleRemoteSubmix, BlockedOutputUnblocksOnClose) {
 }
 
 TEST_P(AudioModuleRemoteSubmix, OutputBlocksUntilInputStarts) {
+    // Create and start output stream before creating the input side.
     ASSERT_NO_FATAL_FAILURE(CreateOutputStream());
-    ASSERT_NO_FATAL_FAILURE(CreateInputStream());
     ASSERT_NO_FATAL_FAILURE(streamOut->StartWorkerToSendBurstCommands());
+    ASSERT_NO_FATAL_FAILURE(CreateInputStream());
     // Read the head of the pipe and check that it starts with the first output burst, that is,
     // the contents of the very first write has not been superseded due to pipe overflow.
     // The burstCount is '0' because the very first burst is used to exit from the 'IDLE' state,
@@ -5561,6 +5946,68 @@ TEST_P(AudioModuleRemoteSubmix, OpenInputMultipleTimes) {
             streamOut->JoinWorkerAfterBurstCommands(false /*callPrepareToCloseBeforeJoin*/));
 }
 
+// Create and start output, then input.
+TEST_P(AudioModuleRemoteSubmix, BurstIntervalsUniformity) {
+    ASSERT_NO_FATAL_FAILURE(CreateOutputStream());
+    // Start writing into the output stream.
+    ASSERT_NO_FATAL_FAILURE(streamOut->StartWorkerToSendBurstCommands(kBurstCount));
+    // Keep writing for some time before starting reads.
+    std::this_thread::sleep_for(kStreamStartOffset);
+    ASSERT_NO_FATAL_FAILURE(CreateInputStream());
+    ASSERT_NO_FATAL_FAILURE(streamIn->SendBurstCommands(
+            false /*callPrepareToCloseBeforeJoin*/, kBurstCount, true /*standbyInputWhenDone*/));
+    ASSERT_NO_FATAL_FAILURE(
+            streamOut->JoinWorkerAfterBurstCommands(false /*callPrepareToCloseBeforeJoin*/));
+    EXPECT_NO_FATAL_FAILURE(VerifyBurstIntervalsUniformity());
+}
+
+// Create and start input, then output.
+TEST_P(AudioModuleRemoteSubmix, BurstIntervalsUniformity2) {
+    ASSERT_NO_FATAL_FAILURE(CreateInputStream());
+    // Start reading from the input stream.
+    ASSERT_NO_FATAL_FAILURE(
+            streamIn->StartWorkerToSendBurstCommands(kBurstCount, true /*standbyInputWhenDone*/));
+    // Keep reading some time before starting writes.
+    std::this_thread::sleep_for(kStreamStartOffset);
+    ASSERT_NO_FATAL_FAILURE(CreateOutputStream());
+    ASSERT_NO_FATAL_FAILURE(
+            streamOut->SendBurstCommands(false /*callPrepareToCloseBeforeJoin*/, kBurstCount));
+    ASSERT_NO_FATAL_FAILURE(
+            streamIn->JoinWorkerAfterBurstCommands(false /*callPrepareToCloseBeforeJoin*/));
+    EXPECT_NO_FATAL_FAILURE(VerifyBurstIntervalsUniformity());
+}
+
+// Output goes through a number of transferring/standby cycles
+TEST_P(AudioModuleRemoteSubmix, BurstIntervalsUniformityOutputStandbyCycle) {
+    ASSERT_NO_FATAL_FAILURE(CreateInputStream());
+    // Since there are several cycles of transfer/standby, use more bursts.
+    constexpr const int kInputBurstCount = kBurstCount * 2;
+    // Start reading from the input stream.
+    ASSERT_NO_FATAL_FAILURE(streamIn->StartWorkerToSendBurstCommands(
+            kInputBurstCount, true /*standbyInputWhenDone*/));
+    std::this_thread::sleep_for(kStreamStartOffset);
+    ASSERT_NO_FATAL_FAILURE(CreateOutputStream());
+    constexpr const int kCycleCount = 3;
+    // Since output stream has gaps, account for them by reducing the bursts count used for writing
+    // by 75%.
+    constexpr const int kWriteCycleBurstCount = (kInputBurstCount * 3 / 4) / kCycleCount;
+    ASSERT_NO_FATAL_FAILURE(streamOut->StartOutWorkerForBurstStandbyCycle(
+            kWriteCycleBurstCount, kCycleCount, kStreamStartOffset.count()));
+    ASSERT_NO_FATAL_FAILURE(
+            streamOut->JoinWorkerAfterBurstCommands(false /*callPrepareToCloseBeforeJoin*/));
+    ASSERT_NO_FATAL_FAILURE(
+            streamIn->JoinWorkerAfterBurstCommands(false /*callPrepareToCloseBeforeJoin*/));
+    // Verify input intervals only.
+    ::android::audio_utils::Statistics<double> inputIntervals(kBurstInputIntervalsAlpha);
+    for (const auto a : streamIn->getBurstIntervals()) {
+        inputIntervals.add(a);
+    }
+    EXPECT_NEAR(inputIntervals.getN(), kInputBurstCount, kBurstCountTolerance)
+            << ::android::internal::ToString(streamIn->getBurstIntervals());
+    EXPECT_LT(inputIntervals.getStdDev(), kIntervalsStdDevTolerance)
+            << ::android::internal::ToString(streamIn->getBurstIntervals());
+}
+
 INSTANTIATE_TEST_SUITE_P(AudioModuleRemoteSubmixTest, AudioModuleRemoteSubmix,
                          ::testing::ValuesIn(getRemoteSubmixModuleInstance()));
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(AudioModuleRemoteSubmix);
diff --git a/audio/aidl/vts/VtsHalAudioEffectTargetTest.cpp b/audio/aidl/vts/VtsHalAudioEffectTargetTest.cpp
index 5b78981d86..98a7f06be1 100644
--- a/audio/aidl/vts/VtsHalAudioEffectTargetTest.cpp
+++ b/audio/aidl/vts/VtsHalAudioEffectTargetTest.cpp
@@ -72,8 +72,9 @@ class AudioEffectTest : public testing::TestWithParam<EffectTestParam>, public E
             mEffect.reset();
         }
     }
-
-    static const long kInputFrameCount = 0x100, kOutputFrameCount = 0x100;
+    // Ensuring frame count keeps input clip duration above 10 ms, as
+    // preprocessing effect tests pass only for durations exceeding 10 ms.
+    static const long kInputFrameCount = 512, kOutputFrameCount = 512;
     std::shared_ptr<IFactory> mFactory;
     std::shared_ptr<IEffect> mEffect;
     Descriptor mDescriptor;
@@ -242,7 +243,7 @@ TEST_P(AudioEffectTest, IdleStateAfterReset) {
     ASSERT_NO_FATAL_FAILURE(destroy(mFactory, mEffect));
 }
 
-// An effect instance transfer to INIT after IEffect.ASSERT_NO_FATAL_FAILURE(close().
+// An effect instance transfer to INIT after close.
 TEST_P(AudioEffectTest, InitStateAfterClose) {
     ASSERT_NO_FATAL_FAILURE(create(mFactory, mEffect, mDescriptor));
     ASSERT_NO_FATAL_FAILURE(open(mEffect));
diff --git a/audio/aidl/vts/VtsHalDynamicsProcessingTest.cpp b/audio/aidl/vts/VtsHalDynamicsProcessingTest.cpp
index 8f98959679..95f407c0b6 100644
--- a/audio/aidl/vts/VtsHalDynamicsProcessingTest.cpp
+++ b/audio/aidl/vts/VtsHalDynamicsProcessingTest.cpp
@@ -118,19 +118,49 @@ class DynamicsProcessingTestHelper : public EffectHelper {
 
     bool isAllParamsValid();
 
-    void setParamsAndProcess(std::vector<float>& input, std::vector<float>& output);
-
-    float calculateDb(const std::vector<float>& input, size_t startSamplePos);
+    float calculateDb(const std::vector<float>& input, size_t startSamplePos, size_t endSamplePos);
 
     void getMagnitudeValue(const std::vector<float>& output, std::vector<float>& bufferMag);
 
     void checkInputAndOutputEquality(const std::vector<float>& outputMag);
 
     void setUpDataTest(const std::vector<int>& testFrequencies, float fullScaleSineDb);
+
     void tearDownDataTest();
 
-    void createChannelConfig();
+    void createChannelConfig(bool isEnabled);
+
+    struct PreEqConfigs {
+        std::vector<DynamicsProcessing::EqBandConfig> configs;
+    };
+
+    struct PostEqConfigs {
+        std::vector<DynamicsProcessing::EqBandConfig> configs;
+    };
 
+    void applyConfig(const PreEqConfigs& configs, bool isChannelConfigEnabled);
+    void applyConfig(const PostEqConfigs& configs, bool isChannelConfigEnabled);
+    void applyConfig(const std::vector<DynamicsProcessing::MbcBandConfig>& configs,
+                     bool isChannelConfigEnabled);
+    void applyConfig(const std::vector<DynamicsProcessing::LimiterConfig>& configs,
+                     [[maybe_unused]] bool isChannelConfigEnabled);
+    void applyConfig(const std::vector<DynamicsProcessing::InputGain>& configs,
+                     [[maybe_unused]] bool isChannelConfigEnabled);
+
+    template <typename ConfigType>
+    void setParamsAndProcess(ConfigType& configs, std::vector<float>& output,
+                             bool isChannelConfigEnabled = true);
+
+    template <typename ConfigType>
+        requires(std::is_same_v<ConfigType, DynamicsProcessing::LimiterConfig>) ||
+                (std::is_same_v<ConfigType, DynamicsProcessing::MbcBandConfig>)
+    void testAndValidateReleaseTimeOutput(std::vector<ConfigType>& configs, float thresholdDb,
+                                          bool isEffectEngaged);
+    template <typename ConfigType>
+        requires(std::is_same_v<ConfigType, DynamicsProcessing::LimiterConfig>) ||
+                (std::is_same_v<ConfigType, DynamicsProcessing::MbcBandConfig>)
+    void testAndValidateAttackTimeOutput(std::vector<ConfigType>& configs, float thresholdDb,
+                                         bool isEffectEngaged);
     // enqueue test parameters
     void addEngineConfig(const DynamicsProcessing::EngineArchitecture& cfg);
     void addPreEqChannelConfig(const std::vector<DynamicsProcessing::ChannelConfig>& cfg);
@@ -147,6 +177,7 @@ class DynamicsProcessingTestHelper : public EffectHelper {
     static constexpr int kSamplingFrequency = 44100;
     static constexpr int kFrameCount = 2048;
     static constexpr int kInputFrequency = 1000;
+    static constexpr int kDefaultCutOffFrequency = 2000;
     static constexpr size_t kStartIndex = 15 * kSamplingFrequency / 1000;  // skip 15ms
     static constexpr float kToleranceDb = 0.5;
     static constexpr int kNPointFFT = 1024;
@@ -196,12 +227,15 @@ class DynamicsProcessingTestHelper : public EffectHelper {
     const int32_t mChannelLayout;
     const int mChannelCount;
 
-    void CleanUp() {
+    template <typename ConfigType>
+    void cleanUpConfigs(std::vector<ConfigType>& configs) {
         mTags.clear();
         mPreEqChannelEnable.clear();
         mPostEqChannelEnable.clear();
         mMbcChannelEnable.clear();
         mLimiterChannelEnable.clear();
+        mChannelConfig.clear();
+        configs.clear();
     }
 };
 
@@ -429,19 +463,11 @@ bool DynamicsProcessingTestHelper::isAllParamsValid() {
 // This function calculates power for both and mono and stereo data as the total power for
 // interleaved multichannel data can be calculated by treating it as a continuous mono input.
 float DynamicsProcessingTestHelper::calculateDb(const std::vector<float>& input,
-                                                size_t startSamplePos = 0) {
+                                                size_t startSamplePos = 0,
+                                                size_t endSamplePos = 0) {
+    size_t sampleCount = (endSamplePos == 0 ? input.size() : endSamplePos) - startSamplePos;
     return audio_utils_compute_power_mono(input.data() + startSamplePos, AUDIO_FORMAT_PCM_FLOAT,
-                                          input.size() - startSamplePos);
-}
-
-void DynamicsProcessingTestHelper::setParamsAndProcess(std::vector<float>& input,
-                                                       std::vector<float>& output) {
-    ASSERT_NO_FATAL_FAILURE(SetAndGetDynamicsProcessingParameters());
-    if (isAllParamsValid()) {
-        ASSERT_NO_FATAL_FAILURE(
-                processAndWriteToOutput(input, output, mEffect, &mOpenEffectReturn));
-        ASSERT_GT(output.size(), kStartIndex);
-    }
+                                          sampleCount);
 }
 
 void DynamicsProcessingTestHelper::getMagnitudeValue(const std::vector<float>& output,
@@ -477,9 +503,210 @@ void DynamicsProcessingTestHelper::tearDownDataTest() {
     ASSERT_NO_FATAL_FAILURE(TearDownDynamicsProcessingEffect());
 }
 
-void DynamicsProcessingTestHelper::createChannelConfig() {
+void DynamicsProcessingTestHelper::createChannelConfig(bool isEnabled) {
     for (int i = 0; i < mChannelCount; i++) {
-        mChannelConfig.push_back(DynamicsProcessing::ChannelConfig(i, true));
+        mChannelConfig.push_back(DynamicsProcessing::ChannelConfig(i, isEnabled));
+    }
+}
+
+void DynamicsProcessingTestHelper::applyConfig(const PreEqConfigs& configs,
+                                               bool isChannelConfigEnabled = true) {
+    createChannelConfig(isChannelConfigEnabled);
+    mEngineConfigPreset.preEqStage.bandCount = configs.configs.size();
+    addEngineConfig(mEngineConfigPreset);
+    addPreEqChannelConfig(mChannelConfig);
+    addPreEqBandConfigs(configs.configs);
+}
+
+void DynamicsProcessingTestHelper::applyConfig(const PostEqConfigs& configs,
+                                               bool isChannelConfigEnabled = true) {
+    createChannelConfig(isChannelConfigEnabled);
+    mEngineConfigPreset.postEqStage.bandCount = configs.configs.size();
+    addEngineConfig(mEngineConfigPreset);
+    addPostEqChannelConfig(mChannelConfig);
+    addPostEqBandConfigs(configs.configs);
+}
+
+void DynamicsProcessingTestHelper::applyConfig(
+        const std::vector<DynamicsProcessing::MbcBandConfig>& configs,
+        bool isChannelConfigEnabled = true) {
+    createChannelConfig(isChannelConfigEnabled);
+    mEngineConfigPreset.mbcStage.bandCount = configs.size();
+    addEngineConfig(mEngineConfigPreset);
+    addMbcChannelConfig(mChannelConfig);
+    addMbcBandConfigs(configs);
+}
+
+void DynamicsProcessingTestHelper::applyConfig(
+        const std::vector<DynamicsProcessing::LimiterConfig>& configs,
+        [[maybe_unused]] bool isChannelConfigEnabled = true) {
+    addEngineConfig(mEngineConfigPreset);
+    addLimiterConfig(configs);
+}
+
+void DynamicsProcessingTestHelper::applyConfig(
+        const std::vector<DynamicsProcessing::InputGain>& configs,
+        [[maybe_unused]] bool isChannelConfigEnabled = true) {
+    addInputGain(configs);
+}
+
+template <typename ConfigType>
+void DynamicsProcessingTestHelper::setParamsAndProcess(ConfigType& configs,
+                                                       std::vector<float>& output,
+                                                       bool isChannelConfigEnabled) {
+    applyConfig(configs, isChannelConfigEnabled);
+    ASSERT_NO_FATAL_FAILURE(SetAndGetDynamicsProcessingParameters());
+    if (isAllParamsValid()) {
+        ASSERT_NO_FATAL_FAILURE(
+                processAndWriteToOutput(mInput, output, mEffect, &mOpenEffectReturn));
+        ASSERT_GT(output.size(), kStartIndex);
+    }
+}
+
+void fillLimiterConfig(std::vector<DynamicsProcessing::LimiterConfig>& limiterConfigList,
+                       int channelIndex, bool enable, int linkGroup, float attackTime,
+                       float releaseTime, float ratio, float threshold, float postGain) {
+    DynamicsProcessing::LimiterConfig cfg;
+    cfg.channel = channelIndex;
+    cfg.enable = enable;
+    cfg.linkGroup = linkGroup;
+    cfg.attackTimeMs = attackTime;
+    cfg.releaseTimeMs = releaseTime;
+    cfg.ratio = ratio;
+    cfg.thresholdDb = threshold;
+    cfg.postGainDb = postGain;
+    limiterConfigList.push_back(cfg);
+}
+
+DynamicsProcessing::MbcBandConfig createMbcBandConfig(int channel, int band, float cutoffFreqHz,
+                                                      float attackTimeMs, float releaseTimeMs,
+                                                      float ratio, float thresholdDb,
+                                                      float kneeWidthDb, float noiseGate,
+                                                      float expanderRatio, float preGainDb,
+                                                      float postGainDb) {
+    return DynamicsProcessing::MbcBandConfig{.channel = channel,
+                                             .band = band,
+                                             .enable = true,
+                                             .cutoffFrequencyHz = cutoffFreqHz,
+                                             .attackTimeMs = attackTimeMs,
+                                             .releaseTimeMs = releaseTimeMs,
+                                             .ratio = ratio,
+                                             .thresholdDb = thresholdDb,
+                                             .kneeWidthDb = kneeWidthDb,
+                                             .noiseGateThresholdDb = noiseGate,
+                                             .expanderRatio = expanderRatio,
+                                             .preGainDb = preGainDb,
+                                             .postGainDb = postGainDb};
+}
+
+void fillMbcBandConfig(std::vector<DynamicsProcessing::MbcBandConfig>& cfgs, int channelIndex,
+                       float threshold, float ratio, float noiseGate, float expanderRatio,
+                       int bandIndex, int cutoffFreqHz, float preGain, float postGain,
+                       float attackTime = 0, float releaseTime = 0, float kneewidth = 0) {
+    cfgs.push_back(createMbcBandConfig(channelIndex, bandIndex, static_cast<float>(cutoffFreqHz),
+                                       attackTime, releaseTime, ratio, threshold, kneewidth,
+                                       noiseGate, expanderRatio, preGain, postGain));
+}
+
+template <typename ConfigType>
+    requires(std::is_same_v<ConfigType, DynamicsProcessing::LimiterConfig>) ||
+            (std::is_same_v<ConfigType, DynamicsProcessing::MbcBandConfig>)
+void DynamicsProcessingTestHelper::testAndValidateReleaseTimeOutput(
+        std::vector<ConfigType>& configs, float thresholdDb, bool isEffectEngaged) {
+    for (size_t i = mInput.size() / 2; i < mInput.size(); i++) {
+        mInput[i] = mInput[i] / 2;
+    }
+    float firstHalfDb = calculateDb(mInput, 0, mInput.size() / 2);
+    float secondHalfDb = calculateDb(mInput, mInput.size() / 2, mInput.size());
+    mInputDb = calculateDb(mInput, 0, mInput.size());
+    float referenceDb;
+    if (isEffectEngaged) {
+        ASSERT_TRUE(thresholdDb < firstHalfDb && thresholdDb >= secondHalfDb)
+                << "Threshold level: " << thresholdDb << "First half level: " << firstHalfDb
+                << "Second half level: " << secondHalfDb;
+        referenceDb = FLT_MAX;
+    } else {
+        ASSERT_TRUE(thresholdDb > firstHalfDb && thresholdDb > secondHalfDb)
+                << "Threshold level: " << thresholdDb << "First half level: " << firstHalfDb
+                << "Second half level: " << secondHalfDb;
+        referenceDb = mInputDb;
+    }
+    std::vector<float> output(mInput.size());
+    std::vector<float> testReleaseTimeMsValues = {0, 10, 20, 30, 40, 50};
+    for (float releaseTimeMs : testReleaseTimeMsValues) {
+        cleanUpConfigs(configs);
+        for (int i = 0; i < mChannelCount; i++) {
+            if constexpr (std::is_same_v<ConfigType, DynamicsProcessing::LimiterConfig>) {
+                fillLimiterConfig(configs, i /*channel*/, true /*enable*/, 0 /*linkGroup*/,
+                                  0 /*attackTime*/, releaseTimeMs, 4 /*compression ratio*/,
+                                  thresholdDb, 0 /*postGain*/);
+            } else {
+                fillMbcBandConfig(configs, i /*channel*/, thresholdDb, 4 /*compressor ratio*/,
+                                  0 /*Noise gate dB*/, 1 /*expander ratio*/, 0 /*band index*/,
+                                  kDefaultCutOffFrequency /*cutoffFrequency*/, 0 /*preGain*/,
+                                  0 /*postGain*/, 0 /*attackTime*/, releaseTimeMs);
+            }
+        }
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(configs, output));
+        if (!isAllParamsValid()) {
+            continue;
+        }
+        float outputDb = calculateDb(output, kStartIndex);
+        if (isEffectEngaged) {
+            /*Release time determines how quickly the compressor returns to normal after the
+             * input falls below the threshold. As the release time increases, it takes longer
+             * for the compressor to stop compressing, resulting in a decrease in output
+             * decibels as the release time increases*/
+            ASSERT_LT(outputDb, referenceDb) << "Release Time: " << releaseTimeMs;
+            referenceDb = outputDb;
+        } else {
+            // No change in the outputdB when the limiter is not enganged
+            EXPECT_NEAR(outputDb, referenceDb, kToleranceDb) << "Release Time: " << releaseTimeMs;
+        }
+    }
+}
+
+template <typename ConfigType>
+    requires(std::is_same_v<ConfigType, DynamicsProcessing::LimiterConfig>) ||
+            (std::is_same_v<ConfigType, DynamicsProcessing::MbcBandConfig>)
+void DynamicsProcessingTestHelper::testAndValidateAttackTimeOutput(std::vector<ConfigType>& configs,
+                                                                   float thresholdDb,
+                                                                   bool isEffectEngaged) {
+    float referenceDb;
+    if (isEffectEngaged) {
+        ASSERT_GT(mInputDb, thresholdDb);
+        referenceDb = -FLT_MAX;
+    } else {
+        ASSERT_LE(mInputDb, thresholdDb);
+        referenceDb = mInputDb;
+    }
+    std::vector<float> output(mInput.size());
+    std::vector<float> testAttackTimeMsValues = {0, 10, 20, 30, 40, 50};
+    for (float attackTimeMs : testAttackTimeMsValues) {
+        cleanUpConfigs(configs);
+        for (int i = 0; i < mChannelCount; i++) {
+            if constexpr (std::is_same_v<ConfigType, DynamicsProcessing::LimiterConfig>) {
+                fillLimiterConfig(configs, i /*channel*/, true /*enable*/, 0 /*linkGroup*/,
+                                  attackTimeMs /*attackTime*/, 0 /*releaseTime*/,
+                                  4 /*compression ratio*/, thresholdDb, 0 /*postGain*/);
+            } else {
+                fillMbcBandConfig(configs, i /*channel*/, thresholdDb, 4 /*compressor ratio*/,
+                                  0 /*Noise gate dB*/, 1 /*expander ratio*/, 0 /*band index*/,
+                                  kDefaultCutOffFrequency /*cutoffFrequency*/, 0 /*preGain*/,
+                                  0 /*postGain*/, attackTimeMs /*attackTime*/, 0 /*releaseTime*/);
+            }
+        }
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(configs, output));
+        if (!isAllParamsValid()) {
+            continue;
+        }
+        float outputDb = calculateDb(output, kStartIndex);
+        if (isEffectEngaged) {
+            ASSERT_GT(outputDb, referenceDb) << "AttackTime: " << attackTimeMs;
+            referenceDb = outputDb;
+        } else {
+            EXPECT_NEAR(outputDb, referenceDb, kToleranceDb) << "AttackTime: " << attackTimeMs;
+        }
     }
 }
 
@@ -558,42 +785,6 @@ void DynamicsProcessingTestHelper::addInputGain(
     mTags.push_back({DynamicsProcessing::inputGain, dp});
 }
 
-void fillLimiterConfig(std::vector<DynamicsProcessing::LimiterConfig>& limiterConfigList,
-                       int channelIndex, bool enable, int linkGroup, float attackTime,
-                       float releaseTime, float ratio, float threshold, float postGain) {
-    DynamicsProcessing::LimiterConfig cfg;
-    cfg.channel = channelIndex;
-    cfg.enable = enable;
-    cfg.linkGroup = linkGroup;
-    cfg.attackTimeMs = attackTime;
-    cfg.releaseTimeMs = releaseTime;
-    cfg.ratio = ratio;
-    cfg.thresholdDb = threshold;
-    cfg.postGainDb = postGain;
-    limiterConfigList.push_back(cfg);
-}
-
-DynamicsProcessing::MbcBandConfig createMbcBandConfig(int channel, int band, float cutoffFreqHz,
-                                                      float attackTimeMs, float releaseTimeMs,
-                                                      float ratio, float thresholdDb,
-                                                      float kneeWidthDb, float noiseGate,
-                                                      float expanderRatio, float preGainDb,
-                                                      float postGainDb) {
-    return DynamicsProcessing::MbcBandConfig{.channel = channel,
-                                             .band = band,
-                                             .enable = true,
-                                             .cutoffFrequencyHz = cutoffFreqHz,
-                                             .attackTimeMs = attackTimeMs,
-                                             .releaseTimeMs = releaseTimeMs,
-                                             .ratio = ratio,
-                                             .thresholdDb = thresholdDb,
-                                             .kneeWidthDb = kneeWidthDb,
-                                             .noiseGateThresholdDb = noiseGate,
-                                             .expanderRatio = expanderRatio,
-                                             .preGainDb = preGainDb,
-                                             .postGainDb = postGainDb};
-}
-
 DynamicsProcessing::EqBandConfig creatEqBandConfig(int channel, int band, float cutOffFreqHz,
                                                    float gainDb, bool enable) {
     return DynamicsProcessing::EqBandConfig{.channel = channel,
@@ -729,24 +920,18 @@ class DynamicsProcessingInputGainDataTest
 
     void TearDown() override { ASSERT_NO_FATAL_FAILURE(tearDownDataTest()); }
 
-    void cleanUpInputGainConfig() {
-        CleanUp();
-        mInputGain.clear();
-    }
-
     std::vector<DynamicsProcessing::InputGain> mInputGain;
 };
 
 TEST_P(DynamicsProcessingInputGainDataTest, SetAndGetInputGain) {
     std::vector<float> gainDbValues = {-85, -40, 0, 40, 85};
     for (float gainDb : gainDbValues) {
-        cleanUpInputGainConfig();
+        cleanUpConfigs(mInputGain);
         for (int i = 0; i < mChannelCount; i++) {
             mInputGain.push_back(DynamicsProcessing::InputGain(i, gainDb));
         }
         std::vector<float> output(mInput.size());
-        addInputGain(mInputGain);
-        EXPECT_NO_FATAL_FAILURE(setParamsAndProcess(mInput, output));
+        EXPECT_NO_FATAL_FAILURE(setParamsAndProcess(mInputGain, output));
         if (!isAllParamsValid()) {
             continue;
         }
@@ -807,13 +992,11 @@ class DynamicsProcessingTestLimiterConfig
 
     void TearDown() override { TearDownDynamicsProcessingEffect(); }
 
-    DynamicsProcessing::LimiterConfig mCfg;
     std::vector<DynamicsProcessing::LimiterConfig> mLimiterConfigList;
 };
 
 TEST_P(DynamicsProcessingTestLimiterConfig, SetAndGetLimiterConfig) {
-    addEngineConfig(mEngineConfigPreset);
-    addLimiterConfig(mLimiterConfigList);
+    applyConfig(mLimiterConfigList);
     ASSERT_NO_FATAL_FAILURE(SetAndGetDynamicsProcessingParameters());
 }
 
@@ -869,16 +1052,8 @@ class DynamicsProcessingLimiterConfigDataTest
         ratio = inputOverThreshold / outputOverThreshold;
     }
 
-    void setLimiterParamsAndProcess(std::vector<float>& input, std::vector<float>& output,
-                                    bool isEngineLimiterEnabled = true) {
-        mEngineConfigPreset.limiterInUse = isEngineLimiterEnabled;
-        addEngineConfig(mEngineConfigPreset);
-        addLimiterConfig(mLimiterConfigList);
-        EXPECT_NO_FATAL_FAILURE(setParamsAndProcess(input, output));
-    }
-
     void testEnableDisableConfiguration(bool isLimiterEnabled, bool isEngineLimiterEnabled) {
-        cleanUpLimiterConfig();
+        cleanUpConfigs(mLimiterConfigList);
         std::vector<float> output(mInput.size());
         for (int i = 0; i < mChannelCount; i++) {
             // Set non-default values
@@ -886,7 +1061,7 @@ class DynamicsProcessingLimiterConfigDataTest
                               5 /*attack time*/, 5 /*release time*/, 10 /*ratio*/,
                               -20 /*threshold*/, 5 /*postgain*/);
         }
-        ASSERT_NO_FATAL_FAILURE(setLimiterParamsAndProcess(mInput, output, isEngineLimiterEnabled));
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mLimiterConfigList, output));
         float outputdB = calculateDb(output, kStartIndex);
         if (isAllParamsValid()) {
             if (isLimiterEnabled && isEngineLimiterEnabled) {
@@ -898,10 +1073,6 @@ class DynamicsProcessingLimiterConfigDataTest
         }
     }
 
-    void cleanUpLimiterConfig() {
-        CleanUp();
-        mLimiterConfigList.clear();
-    }
     static constexpr float kDefaultLinkerGroup = 3;
     static constexpr float kDefaultAttackTime = 0;
     static constexpr float kDefaultReleaseTime = 0;
@@ -911,6 +1082,7 @@ class DynamicsProcessingLimiterConfigDataTest
     static constexpr float kLimiterTestToleranceDb = 0.05;
     static constexpr float kMinDifferenceDb = 5;
     const std::vector<bool> kEnableValues = {true, false, true};
+    const std::vector<float> kReleaseTimeMsValues = {0, 10, 20, 30, 40, 50};
     std::vector<DynamicsProcessing::LimiterConfig> mLimiterConfigList;
     int mBufferSize;
 };
@@ -920,12 +1092,12 @@ TEST_P(DynamicsProcessingLimiterConfigDataTest, IncreasingThresholdDb) {
     std::vector<float> output(mInput.size());
     float previousThreshold = -FLT_MAX;
     for (float threshold : thresholdValues) {
-        cleanUpLimiterConfig();
+        cleanUpConfigs(mLimiterConfigList);
         for (int i = 0; i < mChannelCount; i++) {
             fillLimiterConfig(mLimiterConfigList, i, true, kDefaultLinkerGroup, kDefaultAttackTime,
                               kDefaultReleaseTime, kDefaultRatio, threshold, kDefaultPostGain);
         }
-        ASSERT_NO_FATAL_FAILURE(setLimiterParamsAndProcess(mInput, output));
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mLimiterConfigList, output));
         if (!isAllParamsValid()) {
             continue;
         }
@@ -946,12 +1118,12 @@ TEST_P(DynamicsProcessingLimiterConfigDataTest, IncreasingRatio) {
     std::vector<float> output(mInput.size());
     float previousRatio = 0;
     for (float ratio : ratioValues) {
-        cleanUpLimiterConfig();
+        cleanUpConfigs(mLimiterConfigList);
         for (int i = 0; i < mChannelCount; i++) {
             fillLimiterConfig(mLimiterConfigList, i, true, kDefaultLinkerGroup, kDefaultAttackTime,
                               kDefaultReleaseTime, ratio, kDefaultThreshold, kDefaultPostGain);
         }
-        ASSERT_NO_FATAL_FAILURE(setLimiterParamsAndProcess(mInput, output));
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mLimiterConfigList, output));
         if (!isAllParamsValid()) {
             continue;
         }
@@ -972,16 +1144,17 @@ TEST_P(DynamicsProcessingLimiterConfigDataTest, IncreasingPostGain) {
     std::vector<float> postGainDbValues = {-85, -40, 0, 40, 85};
     std::vector<float> output(mInput.size());
     for (float postGainDb : postGainDbValues) {
-        cleanUpLimiterConfig();
-        ASSERT_NO_FATAL_FAILURE(generateSineWave(kInputFrequency, mInput, dBToAmplitude(postGainDb),
-                                                 kSamplingFrequency, mChannelLayout));
+        cleanUpConfigs(mLimiterConfigList);
+        ASSERT_NO_FATAL_FAILURE(generateSineWave(kInputFrequency, mInput,
+                                                 dBToAmplitude(-postGainDb), kSamplingFrequency,
+                                                 mChannelLayout));
         mInputDb = calculateDb(mInput);
         EXPECT_NEAR(mInputDb, kSineFullScaleDb - postGainDb, kLimiterTestToleranceDb);
         for (int i = 0; i < mChannelCount; i++) {
             fillLimiterConfig(mLimiterConfigList, i, true, kDefaultLinkerGroup, kDefaultAttackTime,
                               kDefaultReleaseTime, 1, kDefaultThreshold, postGainDb);
         }
-        ASSERT_NO_FATAL_FAILURE(setLimiterParamsAndProcess(mInput, output));
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mLimiterConfigList, output));
         if (!isAllParamsValid()) {
             continue;
         }
@@ -1000,11 +1173,39 @@ TEST_P(DynamicsProcessingLimiterConfigDataTest, LimiterEnableDisable) {
 
 TEST_P(DynamicsProcessingLimiterConfigDataTest, LimiterEnableDisableViaEngine) {
     for (bool isEngineLimiterEnabled : kEnableValues) {
+        mEngineConfigPreset.limiterInUse = isEngineLimiterEnabled;
         ASSERT_NO_FATAL_FAILURE(
                 testEnableDisableConfiguration(true /*Limiter Enabled*/, isEngineLimiterEnabled));
     }
 }
 
+TEST_P(DynamicsProcessingLimiterConfigDataTest, LimiterReleaseTime) {
+    // Using a threshold dB value that compresses only the first half of the input.
+    float thresholdDb = -7;
+    ASSERT_NO_FATAL_FAILURE(
+            testAndValidateReleaseTimeOutput(mLimiterConfigList, thresholdDb, true));
+}
+
+TEST_P(DynamicsProcessingLimiterConfigDataTest, LimiterNotEngagedReleaseTimeTest) {
+    // Using threshold value such that limiter does not engage with the input
+    float thresholdDb = -1;
+    ASSERT_NO_FATAL_FAILURE(
+            testAndValidateReleaseTimeOutput(mLimiterConfigList, thresholdDb, false));
+}
+
+TEST_P(DynamicsProcessingLimiterConfigDataTest, LimiterAttackTime) {
+    // Using a threshold dB value that compresses the input.
+    float thresholdDb = -10;
+    ASSERT_NO_FATAL_FAILURE(testAndValidateAttackTimeOutput(mLimiterConfigList, thresholdDb, true));
+}
+
+TEST_P(DynamicsProcessingLimiterConfigDataTest, LimiterNotEngagedAttackTime) {
+    // Using threshold value such that limiter does not engage with the input
+    float thresholdDb = -1;
+    ASSERT_NO_FATAL_FAILURE(
+            testAndValidateAttackTimeOutput(mLimiterConfigList, thresholdDb, false));
+}
+
 INSTANTIATE_TEST_SUITE_P(DynamicsProcessingTest, DynamicsProcessingLimiterConfigDataTest,
                          testing::ValuesIn(EffectFactoryHelper::getAllEffectDescriptors(
                                  IFactory::descriptor, getEffectTypeUuidDynamicsProcessing())),
@@ -1056,7 +1257,7 @@ class DynamicsProcessingLimiterLinkerDataTest : public DynamicsProcessingLimiter
                               kDefaultReleaseTime, ratio, threshold, kDefaultPostGain);
         }
 
-        ASSERT_NO_FATAL_FAILURE(setLimiterParamsAndProcess(mInput, output));
+        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mLimiterConfigList, output));
 
         if (!isAllParamsValid()) {
             GTEST_SKIP() << "Invalid parameters. Skipping the test\n";
@@ -1218,30 +1419,15 @@ class DynamicsProcessingTestEqBandConfig : public ::testing::TestWithParam<EqBan
 };
 
 TEST_P(DynamicsProcessingTestEqBandConfig, SetAndGetPreEqBandConfig) {
-    mEngineConfigPreset.preEqStage.bandCount = mCfgs.size();
-    addEngineConfig(mEngineConfigPreset);
-    std::vector<DynamicsProcessing::ChannelConfig> cfgs(mChannelCount);
-    for (int i = 0; i < mChannelCount; i++) {
-        cfgs[i].channel = i;
-        cfgs[i].enable = true;
-    }
-    addPreEqChannelConfig(cfgs);
-    addPreEqBandConfigs(mCfgs);
+    PreEqConfigs preEqConfigs{mCfgs};
+    applyConfig(preEqConfigs);
     ASSERT_NO_FATAL_FAILURE(SetAndGetDynamicsProcessingParameters());
 }
 
 TEST_P(DynamicsProcessingTestEqBandConfig, SetAndGetPostEqBandConfig) {
     SKIP_TEST_IF_VERSION_UNSUPPORTED(mEffect, kMinDataTestHalVersion);
-
-    mEngineConfigPreset.postEqStage.bandCount = mCfgs.size();
-    addEngineConfig(mEngineConfigPreset);
-    std::vector<DynamicsProcessing::ChannelConfig> cfgs(mChannelCount);
-    for (int i = 0; i < mChannelCount; i++) {
-        cfgs[i].channel = i;
-        cfgs[i].enable = true;
-    }
-    addPostEqChannelConfig(cfgs);
-    addPostEqBandConfigs(mCfgs);
+    PostEqConfigs postEqConfigs{mCfgs};
+    applyConfig(postEqConfigs);
     ASSERT_NO_FATAL_FAILURE(SetAndGetDynamicsProcessingParameters());
 }
 
@@ -1332,20 +1518,6 @@ class DynamicsProcessingEqBandConfigDataTest
 
     void TearDown() override { ASSERT_NO_FATAL_FAILURE(tearDownDataTest()); }
 
-    void addEqParam(bool isPreEq) {
-        createChannelConfig();
-        auto stage = isPreEq ? mEngineConfigPreset.preEqStage : mEngineConfigPreset.postEqStage;
-        stage.bandCount = mCfgs.size();
-        addEngineConfig(mEngineConfigPreset);
-        isPreEq ? addPreEqChannelConfig(mChannelConfig) : addPostEqChannelConfig(mChannelConfig);
-        isPreEq ? addPreEqBandConfigs(mCfgs) : addPostEqBandConfigs(mCfgs);
-    }
-
-    void setEqParamAndProcess(std::vector<float>& output, bool isPreEq) {
-        addEqParam(isPreEq);
-        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mInput, output));
-    }
-
     void fillEqBandConfig(std::vector<DynamicsProcessing::EqBandConfig>& cfgs, int channelIndex,
                           int bandIndex, int cutOffFreqHz, float gainDb, bool enable) {
         cfgs.push_back(creatEqBandConfig(channelIndex, bandIndex, static_cast<float>(cutOffFreqHz),
@@ -1353,10 +1525,10 @@ class DynamicsProcessingEqBandConfigDataTest
     }
 
     void validateOutput(const std::vector<float>& output, float gainDb, size_t bandIndex,
-                        bool enable) {
+                        bool enable, bool isStageEnabled) {
         std::vector<float> outputMag(mBinOffsets.size());
         EXPECT_NO_FATAL_FAILURE(getMagnitudeValue(output, outputMag));
-        if (gainDb == 0 || !enable) {
+        if (gainDb == 0 || !enable || !isStageEnabled) {
             EXPECT_NO_FATAL_FAILURE(checkInputAndOutputEquality(outputMag));
         } else if (gainDb > 0) {
             // For positive gain, current band's magnitude is greater than the other band's
@@ -1368,7 +1540,8 @@ class DynamicsProcessingEqBandConfigDataTest
         }
     }
 
-    void analyseMultiBandOutput(float gainDb, bool isPreEq, bool enable = true) {
+    void analyseMultiBandOutput(float gainDb, bool isPreEq, bool enable = true,
+                                bool isStageEnabled = true) {
         std::vector<float> output(mInput.size());
         roundToFreqCenteredToFftBin(mMultitoneTestFrequencies, mBinOffsets, kBinWidth);
         // Set Equalizer values for two bands
@@ -1377,21 +1550,21 @@ class DynamicsProcessingEqBandConfigDataTest
                 fillEqBandConfig(mCfgs, channelIndex, i, kCutoffFreqHz[i], gainDb, enable);
                 fillEqBandConfig(mCfgs, channelIndex, i ^ 1, kCutoffFreqHz[i ^ 1], 0, enable);
             }
-            ASSERT_NO_FATAL_FAILURE(setEqParamAndProcess(output, isPreEq));
+            if (isPreEq) {
+                PreEqConfigs preEqConfigs{mCfgs};
+                ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(preEqConfigs, output, isStageEnabled));
+            } else {
+                PostEqConfigs postEqConfigs{mCfgs};
+                ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(postEqConfigs, output, isStageEnabled));
+            }
 
             if (isAllParamsValid()) {
-                ASSERT_NO_FATAL_FAILURE(validateOutput(output, gainDb, i, enable));
+                ASSERT_NO_FATAL_FAILURE(validateOutput(output, gainDb, i, enable, isStageEnabled));
             }
-            cleanUpEqConfig();
+            cleanUpConfigs(mCfgs);
         }
     }
 
-    void cleanUpEqConfig() {
-        CleanUp();
-        mCfgs.clear();
-        mChannelConfig.clear();
-    }
-
     const std::vector<float> kTestGainDbValues = {-200, -100, 0, 100, 200};
     std::vector<DynamicsProcessing::EqBandConfig> mCfgs;
 };
@@ -1399,9 +1572,9 @@ class DynamicsProcessingEqBandConfigDataTest
 TEST_P(DynamicsProcessingEqBandConfigDataTest, IncreasingPreEqGain) {
     for (float gainDb : kTestGainDbValues) {
         ASSERT_NO_FATAL_FAILURE(generateSineWave(mMultitoneTestFrequencies, mInput,
-                                                 dBToAmplitude(gainDb), kSamplingFrequency,
+                                                 dBToAmplitude(-gainDb), kSamplingFrequency,
                                                  mChannelLayout));
-        cleanUpEqConfig();
+        cleanUpConfigs(mCfgs);
         ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(gainDb, true /*pre-equalizer*/));
     }
 }
@@ -1409,9 +1582,9 @@ TEST_P(DynamicsProcessingEqBandConfigDataTest, IncreasingPreEqGain) {
 TEST_P(DynamicsProcessingEqBandConfigDataTest, IncreasingPostEqGain) {
     for (float gainDb : kTestGainDbValues) {
         ASSERT_NO_FATAL_FAILURE(generateSineWave(mMultitoneTestFrequencies, mInput,
-                                                 dBToAmplitude(gainDb), kSamplingFrequency,
+                                                 dBToAmplitude(-gainDb), kSamplingFrequency,
                                                  mChannelLayout));
-        cleanUpEqConfig();
+        cleanUpConfigs(mCfgs);
         ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(gainDb, false /*post-equalizer*/));
     }
 }
@@ -1426,6 +1599,20 @@ TEST_P(DynamicsProcessingEqBandConfigDataTest, PostEqEnableDisable) {
                                                    false /*disable equalizer*/));
 }
 
+TEST_P(DynamicsProcessingEqBandConfigDataTest, PreEqStageEnableDisable) {
+    for (bool isStageEnabled : testing::Bool()) {
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(10 /*gain dB*/, true /*pre-equalizer*/,
+                                                       true /*enable equalizer*/, isStageEnabled));
+    }
+}
+
+TEST_P(DynamicsProcessingEqBandConfigDataTest, PostEqStageEnableDisable) {
+    for (bool isStageEnabled : testing::Bool()) {
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(10 /*gain dB*/, false /*post-equalizer*/,
+                                                       true /*enable equalizer*/, isStageEnabled));
+    }
+}
+
 INSTANTIATE_TEST_SUITE_P(DynamicsProcessingTest, DynamicsProcessingEqBandConfigDataTest,
                          testing::ValuesIn(EffectFactoryHelper::getAllEffectDescriptors(
                                  IFactory::descriptor, getEffectTypeUuidDynamicsProcessing())),
@@ -1511,15 +1698,7 @@ class DynamicsProcessingTestMbcBandConfig
 };
 
 TEST_P(DynamicsProcessingTestMbcBandConfig, SetAndGetMbcBandConfig) {
-    mEngineConfigPreset.mbcStage.bandCount = mCfgs.size();
-    addEngineConfig(mEngineConfigPreset);
-    std::vector<DynamicsProcessing::ChannelConfig> cfgs(mChannelCount);
-    for (int i = 0; i < mChannelCount; i++) {
-        cfgs[i].channel = i;
-        cfgs[i].enable = true;
-    }
-    addMbcChannelConfig(cfgs);
-    addMbcBandConfigs(mCfgs);
+    applyConfig(mCfgs);
     ASSERT_NO_FATAL_FAILURE(SetAndGetDynamicsProcessingParameters());
 }
 
@@ -1560,29 +1739,10 @@ class DynamicsProcessingMbcBandConfigDataTest
 
     void TearDown() override { ASSERT_NO_FATAL_FAILURE(tearDownDataTest()); }
 
-    void setMbcParamsAndProcess(std::vector<float>& output) {
-        createChannelConfig();
-        mEngineConfigPreset.mbcStage.bandCount = mCfgs.size();
-        addEngineConfig(mEngineConfigPreset);
-        addMbcChannelConfig(mChannelConfig);
-        addMbcBandConfigs(mCfgs);
-        ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mInput, output));
-    }
-
-    void fillMbcBandConfig(std::vector<DynamicsProcessing::MbcBandConfig>& cfgs, int channelIndex,
-                           float threshold, float ratio, float noiseGate, float expanderRatio,
-                           int bandIndex, int cutoffFreqHz, float preGain, float postGain) {
-        cfgs.push_back(createMbcBandConfig(channelIndex, bandIndex,
-                                           static_cast<float>(cutoffFreqHz), kDefaultAttackTime,
-                                           kDefaultReleaseTime, ratio, threshold, kDefaultKneeWidth,
-                                           noiseGate, expanderRatio, preGain, postGain));
-    }
-
-    void validateOutput(const std::vector<float>& output, float threshold, float ratio,
-                        size_t bandIndex) {
+    void validateOutput(const std::vector<float>& output, size_t bandIndex, bool checkEquality) {
         std::vector<float> outputMag(mBinOffsets.size());
         EXPECT_NO_FATAL_FAILURE(getMagnitudeValue(output, outputMag));
-        if (threshold >= mInputDb || ratio == 1) {
+        if (checkEquality) {
             EXPECT_NO_FATAL_FAILURE(checkInputAndOutputEquality(outputMag));
         } else {
             // Current band's magnitude is less than the other band's magnitude
@@ -1590,63 +1750,107 @@ class DynamicsProcessingMbcBandConfigDataTest
         }
     }
 
-    void analyseMultiBandOutput(float threshold, float ratio) {
+    void analyseMultiBandOutput(float thresholdDb, float ratio, float noiseGateDb,
+                                float expanderRatio, bool isStageEnabled = true) {
         std::vector<float> output(mInput.size());
         roundToFreqCenteredToFftBin(mMultitoneTestFrequencies, mBinOffsets, kBinWidth);
-        // Set MBC values for two bands
+
         for (size_t i = 0; i < kCutoffFreqHz.size(); i++) {
             for (int channelIndex = 0; channelIndex < mChannelCount; channelIndex++) {
-                fillMbcBandConfig(mCfgs, channelIndex, threshold, ratio, kDefaultNoiseGateDb,
-                                  kDefaultExpanderRatio, i, kCutoffFreqHz[i], kDefaultPreGainDb,
+                // Set MBC values for the current band
+                fillMbcBandConfig(mCfgs, channelIndex, thresholdDb, ratio, noiseGateDb,
+                                  expanderRatio, i, kCutoffFreqHz[i], kDefaultPreGainDb,
                                   kDefaultPostGainDb);
+
+                // Set MBC values for the other band
                 fillMbcBandConfig(mCfgs, channelIndex, kDefaultThresholdDb, kDefaultRatio,
                                   kDefaultNoiseGateDb, kDefaultExpanderRatio, i ^ 1,
                                   kCutoffFreqHz[i ^ 1], kDefaultPreGainDb, kDefaultPostGainDb);
             }
-            ASSERT_NO_FATAL_FAILURE(setMbcParamsAndProcess(output));
+            ASSERT_NO_FATAL_FAILURE(setParamsAndProcess(mCfgs, output, isStageEnabled));
 
             if (isAllParamsValid()) {
-                ASSERT_NO_FATAL_FAILURE(validateOutput(output, threshold, ratio, i));
+                bool checkEquality = ((noiseGateDb <= mInputDb || expanderRatio == 1) &&
+                                      (thresholdDb >= mInputDb || ratio == 1)) ||
+                                     !isStageEnabled;
+                ASSERT_NO_FATAL_FAILURE(validateOutput(output, i, checkEquality));
             }
-            cleanUpMbcConfig();
+            cleanUpConfigs(mCfgs);
         }
     }
 
-    void cleanUpMbcConfig() {
-        CleanUp();
-        mCfgs.clear();
-        mChannelConfig.clear();
+    void computeAndValidateCompressionRatios(const std::vector<float>& inputDbValues,
+                                             const std::vector<float>& outputDbValues,
+                                             float expectedRatio) {
+        std::vector<float> compressionRatios;
+        for (size_t i = 0; i < outputDbValues.size() - 1; i += 2) {
+            ASSERT_NE(outputDbValues[i + 1] - outputDbValues[i], 0);
+            compressionRatios.push_back((inputDbValues[i + 1] - inputDbValues[i]) /
+                                        (outputDbValues[i + 1] - outputDbValues[i]));
+        }
+        // For soft compression,
+        // The compression ratio increases with increase in the input signal level in range
+        //      [threshold - kneewidth/2, threshold + kneewidth/2].
+        // The compression ratio remains same for inputs greater than threshold + kneewidth/2.
+        for (size_t i = 0; i < compressionRatios.size() - 1; ++i) {
+            EXPECT_GT(compressionRatios[i + 1], compressionRatios[i]);
+        }
+        EXPECT_NEAR(compressionRatios[compressionRatios.size() - 1], expectedRatio,
+                    kRatioTolerance);
     }
 
     static constexpr float kDefaultPostGainDb = 0;
     static constexpr float kDefaultPreGainDb = 0;
-    static constexpr float kDefaultAttackTime = 0;
-    static constexpr float kDefaultReleaseTime = 0;
-    static constexpr float kDefaultKneeWidth = 0;
     static constexpr float kDefaultThresholdDb = 0;
     static constexpr float kDefaultNoiseGateDb = -10;
     static constexpr float kDefaultExpanderRatio = 1;
     static constexpr float kDefaultRatio = 1;
+    static constexpr float kRatioTolerance = 0.5;
+    const std::vector<float> kMBCReleaseTimeMsValues = {0, 10, 20, 30, 40, 50};
     std::vector<DynamicsProcessing::MbcBandConfig> mCfgs;
 };
 
 TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingThreshold) {
     float ratio = 20;
-    std::vector<float> thresholdValues = {-200, -100, 0, 100, 200};
+    std::vector<float> thresholdDbValues = {-200, -100, 0, 100, 200};
 
-    for (float threshold : thresholdValues) {
-        cleanUpMbcConfig();
-        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(threshold, ratio));
+    for (float thresholdDb : thresholdDbValues) {
+        cleanUpConfigs(mCfgs);
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(thresholdDb, ratio, kDefaultNoiseGateDb,
+                                                       kDefaultExpanderRatio));
     }
 }
 
 TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingRatio) {
-    float threshold = -20;
+    float thresholdDb = -20;
     std::vector<float> ratioValues = {1, 10, 20, 30, 40, 50};
 
     for (float ratio : ratioValues) {
-        cleanUpMbcConfig();
-        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(threshold, ratio));
+        cleanUpConfigs(mCfgs);
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(thresholdDb, ratio, kDefaultNoiseGateDb,
+                                                       kDefaultExpanderRatio));
+    }
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingNoiseGate) {
+    float expanderRatio = 20;
+    std::vector<float> noiseGateDbValues = {-200, -100, 0, 100, 200};
+
+    for (float noiseGateDb : noiseGateDbValues) {
+        cleanUpConfigs(mCfgs);
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(kDefaultThresholdDb, kDefaultRatio,
+                                                       noiseGateDb, expanderRatio));
+    }
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingExpanderRatio) {
+    float noiseGateDb = -3;
+    std::vector<float> expanderRatioValues = {1, 10, 20, 30, 40, 50};
+
+    for (float expanderRatio : expanderRatioValues) {
+        cleanUpConfigs(mCfgs);
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(kDefaultThresholdDb, kDefaultRatio,
+                                                       noiseGateDb, expanderRatio));
     }
 }
 
@@ -1655,17 +1859,17 @@ TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingPostGain) {
     std::vector<float> output(mInput.size());
     for (float postGainDb : postGainDbValues) {
         ASSERT_NO_FATAL_FAILURE(generateSineWave(mMultitoneTestFrequencies, mInput,
-                                                 dBToAmplitude(postGainDb), kSamplingFrequency,
+                                                 dBToAmplitude(-postGainDb), kSamplingFrequency,
                                                  mChannelLayout));
         mInputDb = calculateDb(mInput);
         EXPECT_NEAR(mInputDb, kSineMultitoneFullScaleDb - postGainDb, kToleranceDb);
-        cleanUpMbcConfig();
+        cleanUpConfigs(mCfgs);
         for (int i = 0; i < mChannelCount; i++) {
             fillMbcBandConfig(mCfgs, i, kDefaultThresholdDb, kDefaultRatio, kDefaultNoiseGateDb,
-                              kDefaultExpanderRatio, 0 /*band index*/, 2000 /*cutoffFrequency*/,
+                              kDefaultExpanderRatio, 0 /*band index*/, kDefaultCutOffFrequency,
                               kDefaultPreGainDb, postGainDb);
         }
-        EXPECT_NO_FATAL_FAILURE(setMbcParamsAndProcess(output));
+        EXPECT_NO_FATAL_FAILURE(setParamsAndProcess(mCfgs, output));
         if (!isAllParamsValid()) {
             continue;
         }
@@ -1703,13 +1907,13 @@ TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingPreGain) {
             } else {
                 expectedOutputDb = mInputDb;
             }
-            cleanUpMbcConfig();
+            cleanUpConfigs(mCfgs);
             for (int i = 0; i < mChannelCount; i++) {
                 fillMbcBandConfig(mCfgs, i, thresholdDb, ratio /*compressor ratio*/, noiseGateDb,
                                   ratio /*expander ratio*/, 0 /*band index*/,
-                                  2000 /*cutoffFrequency*/, preGainDb, kDefaultPostGainDb);
+                                  kDefaultCutOffFrequency, preGainDb, kDefaultPostGainDb);
             }
-            EXPECT_NO_FATAL_FAILURE(setMbcParamsAndProcess(output));
+            EXPECT_NO_FATAL_FAILURE(setParamsAndProcess(mCfgs, output));
             if (!isAllParamsValid()) {
                 continue;
             }
@@ -1720,6 +1924,85 @@ TEST_P(DynamicsProcessingMbcBandConfigDataTest, IncreasingPreGain) {
     }
 }
 
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, MBCReleaseTime) {
+    // Using a threshold dB value that compresses only the first half of the input
+    float thresholdDb = -7;
+    ASSERT_NO_FATAL_FAILURE(testAndValidateReleaseTimeOutput(mCfgs, thresholdDb, true));
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, MBCNotEngagedReleaseTime) {
+    // Using threshold value such that MBC does not engage with the input
+    float thresholdDb = -1;
+    ASSERT_NO_FATAL_FAILURE(testAndValidateReleaseTimeOutput(mCfgs, thresholdDb, false));
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, kneewidthTest) {
+    std::vector<float> output(mInput.size());
+    const float thresholdDb = -10;
+    const float ratio = 8;
+    std::vector<float> kneewidthDbValues = {20, 40, 60, 80, 100};
+
+    for (float kneewidthDb : kneewidthDbValues) {
+        // Define the lower, midpoint, and upper dB thresholds for soft knee compression region
+        float lower = thresholdDb - kneewidthDb / 2;
+        float mid = thresholdDb;
+        float upper = thresholdDb + kneewidthDb / 2;
+        // Define a set of input dB values placed around the soft knee region to compute expected
+        // compression.
+        std::vector<float> inputDbValues = {lower, lower + 1, mid, mid + 1, upper, upper + 1};
+        std::vector<float> outputDbValues;
+
+        for (float inputDb : inputDbValues) {
+            cleanUpConfigs(mCfgs);
+            ASSERT_NO_FATAL_FAILURE(
+                    generateSineWave(mMultitoneTestFrequencies, mInput,
+                                     dBToAmplitude(inputDb, kSineMultitoneFullScaleDb),
+                                     kSamplingFrequency, mChannelLayout));
+            EXPECT_NEAR(inputDb, calculateDb(mInput), kToleranceDb);
+            for (int i = 0; i < mChannelCount; i++) {
+                fillMbcBandConfig(mCfgs, i, thresholdDb, ratio /*compressor ratio*/,
+                                  kDefaultExpanderRatio, kDefaultExpanderRatio, 0 /*band index*/,
+                                  kDefaultCutOffFrequency, kDefaultPreGainDb, kDefaultPostGainDb, 0,
+                                  0, kneewidthDb);
+            }
+            EXPECT_NO_FATAL_FAILURE(setParamsAndProcess(mCfgs, output));
+            if (!isAllParamsValid()) {
+                FAIL() << "Invalid MBC parameters. Skip output dB calculation and further "
+                          "processing.";
+            }
+            outputDbValues.push_back(calculateDb(output, kStartIndex));
+        }
+        if (inputDbValues.size() != outputDbValues.size()) {
+            FAIL() << "inputDbValues and outputDbValues sizes are not same. Skipping output "
+                      "validation.";
+        }
+        ASSERT_NO_FATAL_FAILURE(
+                computeAndValidateCompressionRatios(inputDbValues, outputDbValues, ratio));
+    }
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, MBCAttackTime) {
+    // Using a threshold dB value that compresses the input
+    float thresholdDb = -10;
+    ASSERT_NO_FATAL_FAILURE(testAndValidateAttackTimeOutput(mCfgs, thresholdDb, true));
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, MBCNotEngagedAttackTime) {
+    // Using threshold value such that MBC does not engage with the input
+    float thresholdDb = -1;
+    ASSERT_NO_FATAL_FAILURE(testAndValidateAttackTimeOutput(mCfgs, thresholdDb, false));
+}
+
+TEST_P(DynamicsProcessingMbcBandConfigDataTest, StageEnableDisableMBC) {
+    const float threshold = -20;
+    const float ratio = 10;
+    for (bool isMbcStageEnabled : testing::Bool()) {
+        cleanUpConfigs(mCfgs);
+        ASSERT_NO_FATAL_FAILURE(analyseMultiBandOutput(threshold, ratio, kDefaultNoiseGateDb,
+                                                       kDefaultExpanderRatio, isMbcStageEnabled));
+    }
+}
+
 INSTANTIATE_TEST_SUITE_P(DynamicsProcessingTest, DynamicsProcessingMbcBandConfigDataTest,
                          testing::ValuesIn(EffectFactoryHelper::getAllEffectDescriptors(
                                  IFactory::descriptor, getEffectTypeUuidDynamicsProcessing())),
diff --git a/audio/aidl/vts/VtsHalEqualizerTargetTest.cpp b/audio/aidl/vts/VtsHalEqualizerTargetTest.cpp
index 86177fc059..30bf59a8a9 100644
--- a/audio/aidl/vts/VtsHalEqualizerTargetTest.cpp
+++ b/audio/aidl/vts/VtsHalEqualizerTargetTest.cpp
@@ -48,8 +48,8 @@ using android::hardware::audio::common::testing::detail::TestExecutionTracer;
  */
 
 enum ParamName { PARAM_INSTANCE_NAME, PARAM_PRESET, PARAM_BAND_LEVEL };
-using EqualizerTestParam = std::tuple<std::pair<std::shared_ptr<IFactory>, Descriptor>, int,
-                                      std::vector<Equalizer::BandLevel>>;
+using EqualizerParamTestParam = std::tuple<std::pair<std::shared_ptr<IFactory>, Descriptor>, int,
+                                           std::vector<Equalizer::BandLevel>>;
 
 /*
 Testing parameter range, assuming the parameter supported by effect is in this range.
@@ -73,11 +73,17 @@ class EqualizerTestHelper : public EffectHelper {
         ASSERT_NE(nullptr, mFactory);
         ASSERT_NO_FATAL_FAILURE(create(mFactory, mEffect, mDescriptor));
 
+        AudioChannelLayout inputLayout = AudioChannelLayout::make<AudioChannelLayout::layoutMask>(
+                AudioChannelLayout::LAYOUT_MONO);
+        AudioChannelLayout outputLayout = inputLayout;
+
         Parameter::Common common = createParamCommon(
-                0 /* session */, 1 /* ioHandle */, 44100 /* iSampleRate */, 44100 /* oSampleRate */,
-                kInputFrameCount /* iFrameCount */, kOutputFrameCount /* oFrameCount */);
+                0 /* session */, 1 /* ioHandle */, kSamplingFrequency /* iSampleRate */,
+                kSamplingFrequency /* oSampleRate */, kInputFrameCount /* iFrameCount */,
+                kOutputFrameCount /* oFrameCount */, inputLayout, outputLayout);
         ASSERT_NO_FATAL_FAILURE(open(mEffect, common, std::nullopt, &mOpenEffectReturn, EX_NONE));
         ASSERT_NE(nullptr, mEffect);
+        mVersion = EffectFactoryHelper::getHalVersion(mFactory);
     }
 
     void TearDownEqualizer() {
@@ -168,10 +174,11 @@ class EqualizerTestHelper : public EffectHelper {
                 {Equalizer::bandLevels, Equalizer::make<Equalizer::bandLevels>(bandLevels)});
     }
 
-    static const long kInputFrameCount = 0x100, kOutputFrameCount = 0x100;
+    static const long kInputFrameCount = 0x10000, kOutputFrameCount = 0x10000;
     const std::shared_ptr<IFactory> mFactory;
     const int mPresetIndex;
     const std::vector<Equalizer::BandLevel> mBandLevel;
+    int mVersion = 0;
     std::shared_ptr<IEffect> mEffect;
     IEffect::OpenEffectReturn mOpenEffectReturn;
 
@@ -180,7 +187,7 @@ class EqualizerTestHelper : public EffectHelper {
     void CleanUp() { mTags.clear(); }
 };
 
-class EqualizerParamTest : public ::testing::TestWithParam<EqualizerTestParam>,
+class EqualizerParamTest : public ::testing::TestWithParam<EqualizerParamTestParam>,
                            public EqualizerTestHelper {
   public:
     EqualizerParamTest()
@@ -199,9 +206,174 @@ TEST_P(EqualizerParamTest, SetAndGetParams) {
     ASSERT_NO_FATAL_FAILURE(SetAndGetEqualizerParameters());
 }
 
+using EqualizerDataTestParam = std::pair<std::shared_ptr<IFactory>, Descriptor>;
+
+class EqualizerDataTest : public ::testing::TestWithParam<EqualizerDataTestParam>,
+                          public EqualizerTestHelper {
+  public:
+    EqualizerDataTest()
+        : EqualizerTestHelper(GetParam()),
+          mInputBuffer(kInputFrameCount),
+          mOutputBuffer(kOutputFrameCount) {}
+
+    template <Equalizer::Tag TagValue>
+    auto getEqualizerParam() {
+        Parameter getParam;
+        Equalizer::Id eqId = Equalizer::Id::make<Equalizer::Id::commonTag>(TagValue);
+        Parameter::Id id = Parameter::Id::make<Parameter::Id::equalizerTag>(eqId);
+        EXPECT_STATUS(EX_NONE, mEffect->getParameter(id, &getParam));
+        return getParam.get<Parameter::specific>()
+                .get<Parameter::Specific::equalizer>()
+                .get<TagValue>();  // Attempting to use the Tag type
+    }
+
+    void SetUp() override {
+        ASSERT_NO_FATAL_FAILURE(SetUpEqualizer());
+        SKIP_TEST_IF_DATA_UNSUPPORTED(mDescriptor.common.flags);
+        mBandLevels = getEqualizerParam<Equalizer::bandLevels>();
+
+        auto centerFrequencies = getEqualizerParam<Equalizer::centerFreqMh>();
+        ASSERT_EQ(centerFrequencies.size(), mBandLevels.size());
+        // convert center frequencies into Hz unit
+        for (auto& freq : centerFrequencies) {
+            freq = freq / 1000;
+        }
+
+        mBinOffsets.resize(centerFrequencies.size());
+        mOutputMag.resize(mBinOffsets.size());
+
+        roundToFreqCenteredToFftBin(centerFrequencies, mBinOffsets, kBinWidth);
+
+        ASSERT_NO_FATAL_FAILURE(generateSineWave(centerFrequencies, mInputBuffer, 1.0,
+                                                 kSamplingFrequency,
+                                                 AudioChannelLayout::LAYOUT_MONO));
+    }
+
+    void TearDown() override { ASSERT_NO_FATAL_FAILURE(TearDownEqualizer()); }
+
+    static constexpr float kBinWidth = (float)kSamplingFrequency / kNPointFFT;
+    std::vector<float> mInputBuffer;
+    std::vector<float> mOutputBuffer;
+    std::vector<Equalizer::BandLevel> mBandLevels;
+    std::vector<int> mBinOffsets;
+    std::vector<float> mOutputMag;
+};
+
+TEST_P(EqualizerDataTest, testBandLevels) {
+    auto bandFrequencies = getEqualizerParam<Equalizer::bandFrequencies>();
+    ASSERT_EQ(bandFrequencies.size(), mBandLevels.size());
+
+    std::vector<Equalizer::BandLevel> testBandLevelMb(mBandLevels.size());
+    for (size_t i = 0; i < testBandLevelMb.size(); i++) {
+        testBandLevelMb[i] = {static_cast<int>(i), 0};
+    }
+
+    constexpr float kScalingFactor = 3.0;
+    std::vector<int> testlevelMbValues = {-1500, -1000, -500, 500, 1000, 1500};
+    size_t centerBandIndex = mBandLevels.size() / 2;
+
+    for (int levelMb : testlevelMbValues) {
+        for (size_t i = 0; i < mBandLevels.size(); i++) {
+            // set bandLevel
+            testBandLevelMb[i] = {static_cast<int>(i), levelMb};
+            Parameter::Specific specific =
+                    Parameter::Specific::make<Parameter::Specific::equalizer>(
+                            Equalizer::make<Equalizer::bandLevels>(testBandLevelMb));
+            Parameter expectParam = Parameter::make<Parameter::specific>(specific);
+            EXPECT_STATUS(EX_NONE, mEffect->setParameter(expectParam))
+                    << expectParam.toString() << "\n"
+                    << mDescriptor.toString();
+
+            ASSERT_NO_FATAL_FAILURE(processAndWriteToOutput(mInputBuffer, mOutputBuffer, mEffect,
+                                                            &mOpenEffectReturn, mVersion));
+
+            EXPECT_NO_FATAL_FAILURE(
+                    calculateMagnitudeMono(mOutputMag, mOutputBuffer, mBinOffsets, kNPointFFT));
+
+            size_t referenceBandIndex = (i == centerBandIndex) ? 0 : centerBandIndex;
+
+            if (levelMb > 0) {
+                EXPECT_GE(mOutputMag[i] - mOutputMag[referenceBandIndex], levelMb)
+                        << "Output magnitude difference from reference band should be greater than "
+                           "or equal to set levelMb value ("
+                        << levelMb << " mB)";
+            } else {
+                EXPECT_LT(mOutputMag[i] - mOutputMag[referenceBandIndex],
+                          (float)levelMb / kScalingFactor)
+                        << "Output magnitude difference from reference band should be lesser than "
+                           "set levelMb value / scaling factor ("
+                        << levelMb << " mB / " << kScalingFactor << ") in case of negative gain";
+            }
+            testBandLevelMb[i] = {static_cast<int>(i), 0};
+        }
+    }
+}
+
+TEST_P(EqualizerDataTest, testPresets) {
+    constexpr float kToleranceDb = 1.0;
+    constexpr int kCustomPresetIndex = -1;
+
+    auto presets = getEqualizerParam<Equalizer::presets>();
+
+    std::vector<float> inputMag(mBinOffsets.size());
+    EXPECT_NO_FATAL_FAILURE(
+            calculateMagnitudeMono(inputMag, mInputBuffer, mBinOffsets, kNPointFFT));
+
+    for (auto preset : presets) {
+        // Skip for 'Custom' preset value as it is currently not supported
+        if (preset.index == kCustomPresetIndex) {
+            continue;
+        }
+        // set preset
+        Parameter::Specific specific = Parameter::Specific::make<Parameter::Specific::equalizer>(
+                Equalizer::make<Equalizer::preset>(static_cast<int>(preset.index)));
+        Parameter expectParam = Parameter::make<Parameter::specific>(specific);
+        EXPECT_STATUS(EX_NONE, mEffect->setParameter(expectParam)) << expectParam.toString() << "\n"
+                                                                   << mDescriptor.toString();
+
+        ASSERT_NO_FATAL_FAILURE(processAndWriteToOutput(mInputBuffer, mOutputBuffer, mEffect,
+                                                        &mOpenEffectReturn, mVersion));
+
+        EXPECT_NO_FATAL_FAILURE(
+                calculateMagnitudeMono(mOutputMag, mOutputBuffer, mBinOffsets, kNPointFFT));
+
+        // get band levels
+        mBandLevels = getEqualizerParam<Equalizer::bandLevels>();
+
+        for (size_t i = 1; i < mBandLevels.size(); i++) {
+            int expectedAdjacentBandLevelMbDiff =
+                    (mBandLevels[i].levelMb - mBandLevels[i - 1].levelMb);
+
+            ASSERT_NE(inputMag[i], 0);
+            if (i == 1) {
+                ASSERT_NE(inputMag[i - 1], 0);
+            }
+            float actualAdjacentBandGainDbDiff = 20 * (log10(mOutputMag[i] / inputMag[i]) -
+                                                       log10(mOutputMag[i - 1] / inputMag[i - 1]));
+
+            if (expectedAdjacentBandLevelMbDiff == 0) {
+                EXPECT_LT(abs(actualAdjacentBandGainDbDiff), kToleranceDb)
+                        << "For eq preset : " << preset.name << "(" << preset.index << ")"
+                        << ", between bands " << i << " and " << i - 1
+                        << ", expected relative gain is less than kToleranceDb, got relative gain "
+                           ": "
+                        << actualAdjacentBandGainDbDiff;
+            } else {
+                EXPECT_GT(expectedAdjacentBandLevelMbDiff * actualAdjacentBandGainDbDiff, 0)
+                        << "For eq preset : " << preset.name << "(" << preset.index << ")"
+                        << ", between bands " << i << " and " << i - 1
+                        << ", expected relative gain and seen relative magnitude difference are of "
+                           "opposite signs. Expected relative gain : "
+                        << expectedAdjacentBandLevelMbDiff
+                        << ", seen magnitude difference : " << actualAdjacentBandGainDbDiff;
+            }
+        }
+    }
+}
+
 std::vector<std::pair<std::shared_ptr<IFactory>, Descriptor>> kDescPair;
 INSTANTIATE_TEST_SUITE_P(
-        EqualizerParamTest, EqualizerParamTest,
+        EqualizerTest, EqualizerParamTest,
         ::testing::Combine(
                 testing::ValuesIn(kDescPair = EffectFactoryHelper::getAllEffectDescriptors(
                                           IFactory::descriptor, getEffectTypeUuidEqualizer())),
@@ -228,6 +400,20 @@ INSTANTIATE_TEST_SUITE_P(
         });
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(EqualizerParamTest);
 
+INSTANTIATE_TEST_SUITE_P(EqualizerTest, EqualizerDataTest,
+                         testing::ValuesIn(kDescPair = EffectFactoryHelper::getAllEffectDescriptors(
+                                                   IFactory::descriptor,
+                                                   getEffectTypeUuidEqualizer())),
+                         [](const testing::TestParamInfo<EqualizerDataTest::ParamType>& info) {
+                             auto descriptor = (info.param).second;
+                             std::string name = getPrefix(descriptor);
+                             std::replace_if(
+                                     name.begin(), name.end(),
+                                     [](const char c) { return !std::isalnum(c); }, '_');
+                             return name;
+                         });
+GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(EqualizerDataTest);
+
 int main(int argc, char** argv) {
     ::testing::InitGoogleTest(&argc, argv);
     ::testing::UnitTest::GetInstance()->listeners().Append(new TestExecutionTracer());
diff --git a/audio/core/all-versions/vts/functional/AudioPrimaryHidlHalTest.h b/audio/core/all-versions/vts/functional/AudioPrimaryHidlHalTest.h
index fabe2d29a2..0368d283d5 100644
--- a/audio/core/all-versions/vts/functional/AudioPrimaryHidlHalTest.h
+++ b/audio/core/all-versions/vts/functional/AudioPrimaryHidlHalTest.h
@@ -36,6 +36,7 @@
 
 #include <android-base/expected.h>
 #include <android-base/logging.h>
+#include <android-base/stringify.h>
 #include <system/audio_config.h>
 
 // clang-format off
@@ -186,10 +187,6 @@ class HidlTest : public ::testing::Test {
 ////////////////////////// Audio policy configuration ////////////////////////
 //////////////////////////////////////////////////////////////////////////////
 
-// Stringify the argument.
-#define QUOTE(x) #x
-#define STRINGIFY(x) QUOTE(x)
-
 static constexpr char kConfigFileName[] = "audio_policy_configuration.xml";
 
 // Cached policy config after parsing for faster test startup
diff --git a/audio/core/all-versions/vts/functional/tests/generators_tests.cpp b/audio/core/all-versions/vts/functional/tests/generators_tests.cpp
index 76bf93e2d7..221f66d0c5 100644
--- a/audio/core/all-versions/vts/functional/tests/generators_tests.cpp
+++ b/audio/core/all-versions/vts/functional/tests/generators_tests.cpp
@@ -19,6 +19,7 @@
 #include <vector>
 
 #include <android-base/macros.h>
+#include <android-base/stringify.h>
 #include <gtest/gtest.h>
 #define LOG_TAG "Generators_Test"
 #include <log/log.h>
@@ -40,10 +41,6 @@ using namespace ::android::audio::policy::configuration::CPP_VERSION;
 }
 #endif
 
-// Stringify the argument.
-#define QUOTE(x) #x
-#define STRINGIFY(x) QUOTE(x)
-
 struct PolicyConfigManager {
     static PolicyConfigManager& getInstance() {
         static PolicyConfigManager instance;
diff --git a/audio/effect/all-versions/vts/functional/ValidateAudioEffectsConfiguration.cpp b/audio/effect/all-versions/vts/functional/ValidateAudioEffectsConfiguration.cpp
index f2516349d4..d1327a2128 100644
--- a/audio/effect/all-versions/vts/functional/ValidateAudioEffectsConfiguration.cpp
+++ b/audio/effect/all-versions/vts/functional/ValidateAudioEffectsConfiguration.cpp
@@ -23,15 +23,12 @@
 #include PATH(android/hardware/audio/effect/FILE_VERSION/IEffectsFactory.h)
 // clang-format on
 
+#include <android-base/stringify.h>
 #include <gtest/gtest.h>
 #include <hidl/ServiceManagement.h>
 
 #include "utility/ValidateXml.h"
 
-// Stringify the argument.
-#define QUOTE(x) #x
-#define STRINGIFY(x) QUOTE(x)
-
 TEST(CheckConfig, audioEffectsConfigurationValidation) {
     RecordProperty("description",
                    "Verify that the effects configuration file is valid according to the schema");
diff --git a/audio/policy/1.0/xml/api/current.txt b/audio/policy/1.0/xml/api/current.txt
index 19a8123376..de2469cd21 100644
--- a/audio/policy/1.0/xml/api/current.txt
+++ b/audio/policy/1.0/xml/api/current.txt
@@ -197,6 +197,7 @@ package audio.policy.V1_0 {
     enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_ALARM;
     enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_ASSISTANT;
     enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_BLUETOOTH_SCO;
+    enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_CALL_ASSISTANT;
     enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_DEFAULT;
     enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_DTMF;
     enum_constant public static final audio.policy.V1_0.Stream AUDIO_STREAM_ENFORCED_AUDIBLE;
diff --git a/audio/policy/1.0/xml/audio_policy_engine_configuration.xsd b/audio/policy/1.0/xml/audio_policy_engine_configuration.xsd
index 2b86049ff4..3c66c64179 100644
--- a/audio/policy/1.0/xml/audio_policy_engine_configuration.xsd
+++ b/audio/policy/1.0/xml/audio_policy_engine_configuration.xsd
@@ -316,6 +316,7 @@
             <xs:enumeration value="AUDIO_STREAM_TTS"/>
             <xs:enumeration value="AUDIO_STREAM_ACCESSIBILITY"/>
             <xs:enumeration value="AUDIO_STREAM_ASSISTANT"/>
+            <xs:enumeration value="AUDIO_STREAM_CALL_ASSISTANT"/>
         </xs:restriction>
     </xs:simpleType>
 
diff --git a/automotive/audiocontrol/1.0/Android.bp b/automotive/audiocontrol/1.0/Android.bp
deleted file mode 100644
index 53ed78b950..0000000000
--- a/automotive/audiocontrol/1.0/Android.bp
+++ /dev/null
@@ -1,27 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.automotive.audiocontrol@1.0",
-    root: "android.hardware",
-    srcs: [
-        "types.hal",
-        "IAudioControl.hal",
-    ],
-    interfaces: [
-        "android.hidl.base@1.0",
-    ],
-    gen_java: true,
-    apex_available: [
-        "//apex_available:platform",
-        "com.android.car.framework",
-    ],
-}
diff --git a/automotive/audiocontrol/1.0/IAudioControl.hal b/automotive/audiocontrol/1.0/IAudioControl.hal
deleted file mode 100644
index 2e7ef75380..0000000000
--- a/automotive/audiocontrol/1.0/IAudioControl.hal
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.automotive.audiocontrol@1.0;
-
-
-/**
- * Interacts with the car's audio subsystem to manage audio sources and volumes
- */
-interface IAudioControl {
-
-    /**
-     * Called at startup once per context to get the mapping from ContextNumber to
-     * busAddress. This lets the car tell the framework to which physical output stream
-     * each context should be routed.
-     *
-     * For every context, a valid bus number (0 - num busses-1) must be returned. If an
-     * unrecognized contextNumber is encountered, then -1 shall be returned.
-     *
-     * Deprecated: usage of this API and car_volume_groups.xml has been replaced with
-     * car_audio_configuration.xml. If using car_audio_configuration.xml, then the framework
-     * will not call this method. If it doesn't, then it will load car_volume_groups.xml and
-     * call this method.
-     */
-    getBusForContext(ContextNumber contextNumber)
-        generates (int32_t busNumber);
-
-
-    /**
-     * Control the right/left balance setting of the car speakers.
-     *
-     * This is intended to shift the speaker volume toward the right (+) or left (-) side of
-     * the car. 0.0 means "centered". +1.0 means fully right. -1.0 means fully left.
-     *
-     * A value outside the range -1 to 1 must be clamped by the implementation to the -1 to 1
-     * range.
-     */
-    oneway setBalanceTowardRight(float value);
-
-
-    /**
-     * Control the fore/aft fade setting of the car speakers.
-     *
-     * This is intended to shift the speaker volume toward the front (+) or back (-) of the car.
-     * 0.0 means "centered". +1.0 means fully forward. -1.0 means fully rearward.
-     *
-     * A value outside the range -1 to 1 must be clamped by the implementation to the -1 to 1
-     * range.
-     */
-    oneway setFadeTowardFront(float value);
-};
-
diff --git a/automotive/audiocontrol/1.0/default/Android.bp b/automotive/audiocontrol/1.0/default/Android.bp
deleted file mode 100644
index 7180a70774..0000000000
--- a/automotive/audiocontrol/1.0/default/Android.bp
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright (C) 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//       http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_binary {
-    name: "android.hardware.automotive.audiocontrol@1.0-service",
-    defaults: ["hidl_defaults"],
-    vendor: true,
-    relative_install_path: "hw",
-    srcs: [
-        "AudioControl.cpp",
-        "service.cpp",
-    ],
-    init_rc: ["android.hardware.automotive.audiocontrol@1.0-service.rc"],
-
-    shared_libs: [
-        "android.hardware.automotive.audiocontrol@1.0",
-        "libhidlbase",
-        "liblog",
-        "libutils",
-    ],
-    vintf_fragments: ["audiocontrol_manifest.xml"],
-}
-
-filegroup {
-    name: "audiocontrolV1.0_source",
-    srcs: [
-        "AudioControl.cpp",
-    ],
-}
-
-cc_library_headers {
-    name: "audiocontrolV1.0_header",
-    host_supported: true,
-    export_include_dirs: ["."],
-}
diff --git a/automotive/audiocontrol/1.0/default/AudioControl.cpp b/automotive/audiocontrol/1.0/default/AudioControl.cpp
deleted file mode 100644
index c96580e160..0000000000
--- a/automotive/audiocontrol/1.0/default/AudioControl.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-#include "AudioControl.h"
-
-#include <hidl/HidlTransportSupport.h>
-#include <log/log.h>
-
-
-namespace android {
-namespace hardware {
-namespace automotive {
-namespace audiocontrol {
-namespace V1_0 {
-namespace implementation {
-
-
-// This is the static map we're using to associate a ContextNumber with a
-// bus number from the audio_policy_configuration.xml setup.  Every valid context needs
-// to be mapped to a bus address that actually exists in the platforms configuration.
-#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*a))  // Would be nice if this were common...
-static int sContextToBusMap[] = {
-    -1,     // INVALID
-     0,     // MUSIC_CONTEXT
-     1,     // NAVIGATION_CONTEXT
-     2,     // VOICE_COMMAND_CONTEXT
-     3,     // CALL_RING_CONTEXT
-     4,     // CALL_CONTEXT
-     5,     // ALARM_CONTEXT
-     6,     // NOTIFICATION_CONTEXT
-     7,     // SYSTEM_SOUND_CONTEXT
-};
-static const unsigned sContextMapSize = ARRAY_SIZE(sContextToBusMap);
-static const unsigned sContextCount = sContextMapSize - 1;  // Less one for the INVALID entry
-static const unsigned sContextNumberMax = sContextCount;    // contextNumber is counted from 1
-
-
-AudioControl::AudioControl() {
-};
-
-
-Return<int32_t> AudioControl::getBusForContext(ContextNumber ctxt) {
-    unsigned contextNumber = static_cast<unsigned>(ctxt);
-    if (contextNumber > sContextNumberMax) {
-        ALOGE("Unexpected context number %d (max expected is %d)", contextNumber, sContextCount);
-        return -1;
-    } else {
-        return sContextToBusMap[contextNumber];
-    }
-}
-
-
-Return<void> AudioControl::setBalanceTowardRight(float value) {
-    // For completeness, lets bounds check the input...
-    if ((value > 1.0f) || (value < -1.0f)) {
-        ALOGE("Balance value out of range -1 to 1 at %0.2f", value);
-    } else {
-        // Just log in this default mock implementation
-        ALOGI("Balance set to %0.2f", value);
-    }
-    return Void();
-}
-
-
-Return<void> AudioControl::setFadeTowardFront(float value) {
-    // For completeness, lets bounds check the input...
-    if ((value > 1.0f) || (value < -1.0f)) {
-        ALOGE("Fader value out of range -1 to 1 at %0.2f", value);
-    } else {
-        // Just log in this default mock implementation
-        ALOGI("Fader set to %0.2f", value);
-    }
-    return Void();
-}
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace audiocontrol
-}  // namespace automotive
-}  // namespace hardware
-}  // namespace android
diff --git a/automotive/audiocontrol/1.0/default/AudioControl.h b/automotive/audiocontrol/1.0/default/AudioControl.h
deleted file mode 100644
index 37f43c6942..0000000000
--- a/automotive/audiocontrol/1.0/default/AudioControl.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef ANDROID_HARDWARE_AUTOMOTIVE_AUDIOCONTROL_V1_0_AUDIOCONTROL_H
-#define ANDROID_HARDWARE_AUTOMOTIVE_AUDIOCONTROL_V1_0_AUDIOCONTROL_H
-
-#include <android/hardware/automotive/audiocontrol/1.0/IAudioControl.h>
-#include <hidl/MQDescriptor.h>
-#include <hidl/Status.h>
-
-namespace android {
-namespace hardware {
-namespace automotive {
-namespace audiocontrol {
-namespace V1_0 {
-namespace implementation {
-
-using ::android::hardware::hidl_array;
-using ::android::hardware::hidl_memory;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::sp;
-
-struct AudioControl : public IAudioControl {
-public:
-    // Methods from ::android::hardware::automotive::audiocontrol::V1_0::IAudioControl follow.
-    Return<int32_t> getBusForContext(ContextNumber contextNumber) override;
-    Return<void> setBalanceTowardRight(float value) override;
-    Return<void> setFadeTowardFront(float value) override;
-
-    // Implementation details
-    AudioControl();
-};
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace audiocontrol
-}  // namespace automotive
-}  // namespace hardware
-}  // namespace android
-
-#endif  // ANDROID_HARDWARE_AUTOMOTIVE_AUDIOCONTROL_V1_0_AUDIOCONTROL_H
diff --git a/automotive/audiocontrol/1.0/default/android.hardware.automotive.audiocontrol@1.0-service.rc b/automotive/audiocontrol/1.0/default/android.hardware.automotive.audiocontrol@1.0-service.rc
deleted file mode 100644
index c02db08523..0000000000
--- a/automotive/audiocontrol/1.0/default/android.hardware.automotive.audiocontrol@1.0-service.rc
+++ /dev/null
@@ -1,4 +0,0 @@
-service vendor.audiocontrol-hal-1.0 /vendor/bin/hw/android.hardware.automotive.audiocontrol@1.0-service
-    class hal
-    user audioserver
-    group system
diff --git a/automotive/audiocontrol/1.0/default/audiocontrol_manifest.xml b/automotive/audiocontrol/1.0/default/audiocontrol_manifest.xml
deleted file mode 100644
index 0981eb71ad..0000000000
--- a/automotive/audiocontrol/1.0/default/audiocontrol_manifest.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<manifest version="1.0" type="device">
-    <hal format="hidl">
-        <name>android.hardware.automotive.audiocontrol</name>
-        <transport>hwbinder</transport>
-        <version>1.0</version>
-        <interface>
-            <name>IAudioControl</name>
-            <instance>default</instance>
-        </interface>
-    </hal>
-</manifest>
\ No newline at end of file
diff --git a/automotive/audiocontrol/1.0/default/service.cpp b/automotive/audiocontrol/1.0/default/service.cpp
deleted file mode 100644
index a033fd909f..0000000000
--- a/automotive/audiocontrol/1.0/default/service.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <unistd.h>
-
-#include <hidl/HidlTransportSupport.h>
-#include <log/log.h>
-#include <utils/Errors.h>
-#include <utils/StrongPointer.h>
-
-#include "AudioControl.h"
-
-
-// libhidl:
-using android::hardware::configureRpcThreadpool;
-using android::hardware::joinRpcThreadpool;
-
-// Generated HIDL files
-using android::hardware::automotive::audiocontrol::V1_0::IAudioControl;
-
-// The namespace in which all our implementation code lives
-using namespace android::hardware::automotive::audiocontrol::V1_0::implementation;
-using namespace android;
-
-
-// Main service entry point
-int main() {
-    // Create an instance of our service class
-    android::sp<IAudioControl> service = new AudioControl();
-    configureRpcThreadpool(1, true /*callerWillJoin*/);
-
-    if (service->registerAsService() != OK) {
-        ALOGE("registerAsService failed");
-        return 1;
-    }
-
-    // Join (forever) the thread pool we created for the service above
-    joinRpcThreadpool();
-
-    // We don't ever actually expect to return, so return an error if we do get here
-    return 2;
-}
\ No newline at end of file
diff --git a/automotive/audiocontrol/1.0/default/test/fuzzer/Android.bp b/automotive/audiocontrol/1.0/default/test/fuzzer/Android.bp
deleted file mode 100644
index d63695d95e..0000000000
--- a/automotive/audiocontrol/1.0/default/test/fuzzer/Android.bp
+++ /dev/null
@@ -1,61 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- *****************************************************************************
- * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
- */
-
-package {
-    default_team: "trendy_team_aaos_framework",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_fuzz {
-    name: "audiocontrolV1.0_fuzzer",
-    host_supported: true,
-    srcs: [
-        "audiocontrolV1.0_fuzzer.cpp",
-        ":audiocontrolV1.0_source",
-    ],
-    header_libs: [
-        "audiocontrolV1.0_header",
-    ],
-    shared_libs: [
-        "android.hardware.automotive.audiocontrol@1.0",
-        "libhidlbase",
-        "liblog",
-        "libutils",
-    ],
-    fuzz_config: {
-        cc: [
-            "android-media-fuzzing-reports@google.com",
-        ],
-        componentid: 533764,
-        hotlists: [
-            "4593311",
-        ],
-        description: "The fuzzer targets the APIs of android.hardware.automotive.audiocontrol@1.0-service binary",
-        vector: "local_privileges_required",
-        service_privilege: "privileged",
-        users: "multi_user",
-        fuzzed_code_usage: "shipped",
-    },
-}
diff --git a/automotive/audiocontrol/1.0/default/test/fuzzer/audiocontrolV1.0_fuzzer.cpp b/automotive/audiocontrol/1.0/default/test/fuzzer/audiocontrolV1.0_fuzzer.cpp
deleted file mode 100644
index 268df08f94..0000000000
--- a/automotive/audiocontrol/1.0/default/test/fuzzer/audiocontrolV1.0_fuzzer.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- *****************************************************************************
- * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
- */
-#include <AudioControl.h>
-#include <fuzzer/FuzzedDataProvider.h>
-
-using ::android::sp;
-using ::android::hardware::automotive::audiocontrol::V1_0::ContextNumber;
-using ::android::hardware::automotive::audiocontrol::V1_0::implementation::AudioControl;
-
-namespace android::hardware::automotive::audiocontrol::V1_0::implementation::fuzzer {
-extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
-    if (size < 1) {
-        return 0;
-    }
-    if (sp<AudioControl> audioControl = new AudioControl(); audioControl != nullptr) {
-        FuzzedDataProvider fdp = FuzzedDataProvider(data, size);
-        ContextNumber contextNumber = static_cast<ContextNumber>(fdp.ConsumeIntegral<uint32_t>());
-        audioControl->getBusForContext(contextNumber);
-        audioControl->setBalanceTowardRight(fdp.ConsumeFloatingPoint<float>());
-        audioControl->setFadeTowardFront(fdp.ConsumeFloatingPoint<float>());
-    }
-    return 0;
-}
-}  // namespace android::hardware::automotive::audiocontrol::V1_0::implementation::fuzzer
diff --git a/automotive/audiocontrol/1.0/types.hal b/automotive/audiocontrol/1.0/types.hal
deleted file mode 100644
index 04d8d358c4..0000000000
--- a/automotive/audiocontrol/1.0/types.hal
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.automotive.audiocontrol@1.0;
-
-
-/**
- * Predefined flags to identifying audio contexts
- */
-enum ContextNumber : uint32_t {
-    INVALID = 0,    /* Shouldn't be used */
-
-    // Sounds from Android (counting from 1 coincidentally lets us match AudioAttributes usages)
-    MUSIC,          /* Music playback */
-    NAVIGATION,     /* Navigation directions */
-    VOICE_COMMAND,  /* Voice command session */
-    CALL_RING,      /* Voice call ringing */
-    CALL,           /* Voice call */
-    ALARM,          /* Alarm sound from Android */
-    NOTIFICATION,   /* Notifications */
-    SYSTEM_SOUND,   /* User interaction sounds (button clicks, etc) */
-};
diff --git a/automotive/audiocontrol/1.0/vts/functional/Android.bp b/automotive/audiocontrol/1.0/vts/functional/Android.bp
deleted file mode 100644
index 9dcb600d26..0000000000
--- a/automotive/audiocontrol/1.0/vts/functional/Android.bp
+++ /dev/null
@@ -1,43 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_automotive",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalAudioControlV1_0TargetTest",
-    team: "trendy_team_aaos_audio_triage",
-    srcs: [
-        "VtsHalAudioControlV1_0TargetTest.cpp",
-    ],
-    defaults: [
-        "VtsHalTargetTestDefaults",
-    ],
-    static_libs: [
-        "android.hardware.automotive.audiocontrol@1.0",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/automotive/audiocontrol/1.0/vts/functional/OWNERS b/automotive/audiocontrol/1.0/vts/functional/OWNERS
deleted file mode 100644
index fb422db4c7..0000000000
--- a/automotive/audiocontrol/1.0/vts/functional/OWNERS
+++ /dev/null
@@ -1,2 +0,0 @@
-# Bug component: 162915
-zhaomingyin@google.com
diff --git a/automotive/audiocontrol/1.0/vts/functional/VtsHalAudioControlV1_0TargetTest.cpp b/automotive/audiocontrol/1.0/vts/functional/VtsHalAudioControlV1_0TargetTest.cpp
deleted file mode 100644
index 982cf2c358..0000000000
--- a/automotive/audiocontrol/1.0/vts/functional/VtsHalAudioControlV1_0TargetTest.cpp
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "VtsHalAudioControlTest"
-
-#include <stdio.h>
-#include <string.h>
-
-#include <hidl/HidlTransportSupport.h>
-#include <hwbinder/ProcessState.h>
-#include <log/log.h>
-#include <utils/Errors.h>
-#include <utils/StrongPointer.h>
-
-#include <android/hardware/automotive/audiocontrol/1.0/IAudioControl.h>
-#include <android/hardware/automotive/audiocontrol/1.0/types.h>
-#include <android/log.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-using namespace ::android::hardware::automotive::audiocontrol::V1_0;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::hidl_enum_range;
-using ::android::hardware::hidl_handle;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::sp;
-
-// The main test class for the automotive AudioControl HAL
-class CarAudioControlHidlTest : public ::testing::TestWithParam<std::string> {
-  public:
-    virtual void SetUp() override {
-        // Make sure we can connect to the driver
-        pAudioControl = IAudioControl::getService(GetParam());
-        ASSERT_NE(pAudioControl.get(), nullptr);
-    }
-
-    virtual void TearDown() override {}
-
-   protected:
-    sp<IAudioControl> pAudioControl;  // Every test needs access to the service
-};
-
-//
-// Tests start here...
-//
-
-/*
- * Fader exercise test.  Note that only a subjective observer could determine if the
- * fader actually works.  The only thing we can do is exercise the HAL and if the HAL crashes,
- * we _might_ get a test failure if that breaks the connection to the driver.
- */
-TEST_P(CarAudioControlHidlTest, FaderExercise) {
-    ALOGI("Fader exercise test (silent)");
-
-    // Set the fader all the way to the back
-    pAudioControl->setFadeTowardFront(-1.0f);
-
-    // Set the fader all the way to the front
-    pAudioControl->setFadeTowardFront(1.0f);
-
-    // Set the fader part way toward the back
-    pAudioControl->setFadeTowardFront(-0.333f);
-
-    // Set the fader to a out of bounds value (driver should clamp)
-    pAudioControl->setFadeTowardFront(99999.9f);
-
-    // Set the fader back to the middle
-    pAudioControl->setFadeTowardFront(0.0f);
-}
-
-/*
- * Balance exercise test.
- */
-TEST_P(CarAudioControlHidlTest, BalanceExercise) {
-    ALOGI("Balance exercise test (silent)");
-
-    // Set the balance all the way to the left
-    pAudioControl->setBalanceTowardRight(-1.0f);
-
-    // Set the balance all the way to the right
-    pAudioControl->setBalanceTowardRight(1.0f);
-
-    // Set the balance part way toward the left
-    pAudioControl->setBalanceTowardRight(-0.333f);
-
-    // Set the balance to a out of bounds value (driver should clamp)
-    pAudioControl->setBalanceTowardRight(99999.9f);
-
-    // Set the balance back to the middle
-    pAudioControl->setBalanceTowardRight(0.0f);
-}
-
-/*
- * Context mapping test.
- */
-TEST_P(CarAudioControlHidlTest, ContextMapping) {
-    ALOGI("Context mapping test");
-
-    int bus = -1;
-
-    // For each defined context, query the driver for the BUS on which it should be delivered
-    for (const auto& ctxt : hidl_enum_range<ContextNumber>()) {
-         bus = pAudioControl->getBusForContext(ctxt);
-
-         if (ctxt == ContextNumber::INVALID) {
-             // Invalid context should never be mapped to a bus
-             EXPECT_EQ(bus, -1);
-         } else {
-             EXPECT_GE(bus, 0);
-             // TODO:  Consider enumerating the devices on the actual audio hal to validate the
-             // bus IDs.  This would introduce an dependency on the audio HAL, however.  Would that
-             // even work while Android is up and running?
-         }
-    }
-
-    // Try asking about an invalid context one beyond the last defined to see that it gets back a -1
-    int contextRange = std::distance(hidl_enum_range<ContextNumber>().begin(),
-                                     hidl_enum_range<ContextNumber>().end());
-    bus = pAudioControl->getBusForContext((ContextNumber)contextRange);
-    EXPECT_EQ(bus, -1);
-
-    // Try asking about an invalid context WAY out of range to see that it gets back a -1
-    bus = pAudioControl->getBusForContext((ContextNumber)~0);
-    EXPECT_EQ(bus, -1);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(CarAudioControlHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, CarAudioControlHidlTest,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IAudioControl::descriptor)),
-        android::hardware::PrintInstanceNameToString);
\ No newline at end of file
diff --git a/automotive/audiocontrol/2.0/Android.bp b/automotive/audiocontrol/2.0/Android.bp
deleted file mode 100644
index 413cf48e93..0000000000
--- a/automotive/audiocontrol/2.0/Android.bp
+++ /dev/null
@@ -1,31 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.automotive.audiocontrol@2.0",
-    root: "android.hardware",
-    srcs: [
-        "types.hal",
-        "IAudioControl.hal",
-        "ICloseHandle.hal",
-        "IFocusListener.hal",
-    ],
-    interfaces: [
-        "android.hardware.audio.common@6.0",
-        "android.hidl.base@1.0",
-        "android.hidl.safe_union@1.0",
-    ],
-    gen_java: true,
-    apex_available: [
-        "//apex_available:platform",
-        "com.android.car.framework",
-    ],
-}
diff --git a/automotive/audiocontrol/2.0/IAudioControl.hal b/automotive/audiocontrol/2.0/IAudioControl.hal
deleted file mode 100644
index 1073498f61..0000000000
--- a/automotive/audiocontrol/2.0/IAudioControl.hal
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.automotive.audiocontrol@2.0;
-
-import ICloseHandle;
-import IFocusListener;
-import android.hardware.audio.common@6.0::AudioUsage;
-
-/**
- * Interacts with the car's audio subsystem to manage audio sources and volumes
- */
-interface IAudioControl {
-    /**
-     * Registers focus listener to be used by HAL for requesting and abandoning audio focus.
-     *
-     * It is expected that there will only ever be a single focus listener registered. If the
-     * observer dies, the HAL implementation must unregister observer automatically. If called when
-     * a listener is already registered, the existing one should be unregistered and replaced with
-     * the new listener.
-     *
-     * @param listener the listener interface
-     * @return closeHandle A handle to unregister observer.
-     */
-    registerFocusListener(IFocusListener listener) generates (ICloseHandle closeHandle);
-
-    /**
-     * Notifies HAL of changes in audio focus status for focuses requested or abandoned by the HAL.
-     *
-     * This will be called in response to IFocusListener's requestAudioFocus and
-     * abandonAudioFocus, as well as part of any change in focus being held by the HAL due focus
-     * request from other activities or services.
-     *
-     * The HAL is not required to wait for an callback of AUDIOFOCUS_GAIN before playing audio, nor
-     * is it required to stop playing audio in the event of a AUDIOFOCUS_LOSS callback is received.
-     *
-     * @param usage The audio usage associated with the focus change {@code AttributeUsage}
-     * @param zoneId The identifier for the audio zone that the HAL is playing the stream in
-     * @param focusChange the AudioFocusChange that has occurred
-     */
-    oneway onAudioFocusChange(bitfield<AudioUsage> usage, int32_t zoneId,
-        bitfield<AudioFocusChange> focusChange);
-
-    /**
-     * Control the right/left balance setting of the car speakers.
-     *
-     * This is intended to shift the speaker volume toward the right (+) or left (-) side of
-     * the car. 0.0 means "centered". +1.0 means fully right. -1.0 means fully left.
-     *
-     * A value outside the range -1 to 1 must be clamped by the implementation to the -1 to 1
-     * range.
-     */
-    oneway setBalanceTowardRight(float value);
-
-    /**
-     * Control the fore/aft fade setting of the car speakers.
-     *
-     * This is intended to shift the speaker volume toward the front (+) or back (-) of the car.
-     * 0.0 means "centered". +1.0 means fully forward. -1.0 means fully rearward.
-     *
-     * A value outside the range -1 to 1 must be clamped by the implementation to the -1 to 1
-     * range.
-     */
-    oneway setFadeTowardFront(float value);
-};
diff --git a/automotive/audiocontrol/2.0/ICloseHandle.hal b/automotive/audiocontrol/2.0/ICloseHandle.hal
deleted file mode 100644
index 537af6d635..0000000000
--- a/automotive/audiocontrol/2.0/ICloseHandle.hal
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.automotive.audiocontrol@2.0;
-
-/**
- * Represents a generic close handle to remove a callback that doesn't need
- * active interface.
- *
- * When close() is called OR when the interface is released, the underlying
- * resources must be freed.
- */
-interface ICloseHandle {
-    /**
-     * Closes the handle.
-     *
-     * The call must not fail and must be issued by the client at most once.
-     * Otherwise, the server must ignore subsequent calls.
-     */
-    close();
-};
diff --git a/automotive/audiocontrol/2.0/IFocusListener.hal b/automotive/audiocontrol/2.0/IFocusListener.hal
deleted file mode 100644
index 4fd5ef0425..0000000000
--- a/automotive/audiocontrol/2.0/IFocusListener.hal
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.automotive.audiocontrol@2.0;
-
-import android.hardware.audio.common@6.0::AudioUsage;
-
-/**
- * Callback interface for audio focus listener.
- *
- * For typical configuration, the listener the car audio service.
- */
-interface IFocusListener {
-    /**
-     * Called whenever HAL is requesting focus as it is starting to play audio of a given usage in a
-     * specified zone.
-     *
-     * In response, IAudioControl#onAudioFocusChange will be called with focusChange status. This
-     * interaction is oneway to avoid blocking HAL so that it is not required to wait for a response
-     * before playing audio.
-     *
-     * @param usage The audio usage associated with the focus request {@code AttributeUsage}
-     * @param zoneId The identifier for the audio zone where the HAL is requesting focus
-     * @param focusGain The AudioFocusChange associated with this request. Should be one of the
-     * following: GAIN, GAIN_TRANSIENT, GAIN_TRANSIENT_MAY_DUCK, GAIN_TRANSIENT_EXCLUSIVE.
-     */
-    oneway requestAudioFocus(bitfield<AudioUsage> usage, int32_t zoneId,
-        bitfield<AudioFocusChange> focusGain);
-
-    /**
-     * Called whenever HAL is abandoning focus as it is finished playing audio of a given usage in a
-     * specific zone.
-     *
-     * In response, IAudioControl#onAudioFocusChange will be called with focusChange status. This
-     * interaction is oneway to avoid blocking HAL so that it is not required to wait for a response
-     * before stopping audio playback.
-     *
-     * @param usage The audio usage for which the HAL is abandoning focus {@code AttributeUsage}
-     * @param zoneId The identifier for the audio zone that the HAL abandoning focus
-     */
-    oneway abandonAudioFocus(bitfield<AudioUsage> usage, int32_t zoneId);
-};
diff --git a/automotive/audiocontrol/2.0/default/Android.bp b/automotive/audiocontrol/2.0/default/Android.bp
deleted file mode 100644
index 1b8cef723d..0000000000
--- a/automotive/audiocontrol/2.0/default/Android.bp
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright (C) 2020 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//       http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_binary {
-    name: "android.hardware.automotive.audiocontrol@2.0-service",
-    defaults: ["hidl_defaults"],
-    vendor: true,
-    relative_install_path: "hw",
-    srcs: [
-        "AudioControl.cpp",
-        "service.cpp",
-        "CloseHandle.cpp",
-    ],
-    init_rc: ["android.hardware.automotive.audiocontrol@2.0-service.rc"],
-
-    shared_libs: [
-        "android.hardware.automotive.audiocontrol@2.0",
-        "libbase",
-        "libhidlbase",
-        "liblog",
-        "libutils",
-    ],
-    vintf_fragments: ["audiocontrol2_manifest.xml"],
-    cflags: [
-        "-O0",
-        "-g",
-    ],
-}
diff --git a/automotive/audiocontrol/2.0/default/AudioControl.cpp b/automotive/audiocontrol/2.0/default/AudioControl.cpp
deleted file mode 100644
index b7c11cdf07..0000000000
--- a/automotive/audiocontrol/2.0/default/AudioControl.cpp
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "AudioControl.h"
-
-#include <stdio.h>
-
-#include <android-base/logging.h>
-#include <android-base/parseint.h>
-#include <android-base/strings.h>
-
-#include <hidl/HidlTransportSupport.h>
-#include <hwbinder/IPCThreadState.h>
-#include <private/android_filesystem_config.h>
-
-#include "CloseHandle.h"
-
-namespace android::hardware::automotive::audiocontrol::V2_0::implementation {
-
-using ::android::base::EqualsIgnoreCase;
-using ::android::hardware::hidl_handle;
-using ::android::hardware::hidl_string;
-
-static const float kLowerBound = -1.0f;
-static const float kUpperBound = 1.0f;
-
-AudioControl::AudioControl() {}
-
-Return<sp<ICloseHandle>> AudioControl::registerFocusListener(const sp<IFocusListener>& listener) {
-    LOG(DEBUG) << "registering focus listener";
-    sp<ICloseHandle> closeHandle(nullptr);
-
-    if (listener) {
-        mFocusListener = listener;
-
-        closeHandle = new CloseHandle([this, listener]() {
-            if (mFocusListener == listener) {
-                mFocusListener = nullptr;
-            }
-        });
-    } else {
-        LOG(ERROR) << "Unexpected nullptr for listener resulting in no-op.";
-    }
-
-    return closeHandle;
-}
-
-Return<void> AudioControl::setBalanceTowardRight(float value) {
-    if (isValidValue(value)) {
-        // Just log in this default mock implementation
-        LOG(INFO) << "Balance set to " << value;
-    } else {
-        LOG(ERROR) << "Balance value out of range -1 to 1 at " << value;
-    }
-    return Void();
-}
-
-Return<void> AudioControl::setFadeTowardFront(float value) {
-    if (isValidValue(value)) {
-        // Just log in this default mock implementation
-        LOG(INFO) << "Fader set to " << value;
-    } else {
-        LOG(ERROR) << "Fader value out of range -1 to 1 at " << value;
-    }
-    return Void();
-}
-
-bool AudioControl::isValidValue(float value) {
-    return (value > kLowerBound) && (value < kUpperBound);
-}
-
-Return<void> AudioControl::onAudioFocusChange(hidl_bitfield<AudioUsage> usage, int zoneId,
-                                              hidl_bitfield<AudioFocusChange> focusChange) {
-    LOG(INFO) << "Focus changed: " << static_cast<int>(focusChange) << " for usage "
-              << static_cast<int>(usage) << " in zone " << zoneId;
-    return Void();
-}
-
-Return<void> AudioControl::debug(const hidl_handle& fd, const hidl_vec<hidl_string>& options) {
-    if (fd.getNativeHandle() == nullptr || fd->numFds == 0) {
-        LOG(ERROR) << "Invalid parameters passed to debug()";
-        return Void();
-    }
-
-    cmdDump(fd->data[0], options);
-    return Void();
-}
-
-void AudioControl::cmdDump(int fd, const hidl_vec<hidl_string>& options) {
-    if (options.size() == 0) {
-        dump(fd);
-        return;
-    }
-
-    std::string option = options[0];
-    if (EqualsIgnoreCase(option, "--help")) {
-        cmdHelp(fd);
-    } else if (EqualsIgnoreCase(option, "--request")) {
-        cmdRequestFocus(fd, options);
-    } else if (EqualsIgnoreCase(option, "--abandon")) {
-        cmdAbandonFocus(fd, options);
-    } else {
-        dprintf(fd, "Invalid option: %s\n", option.c_str());
-    }
-}
-
-void AudioControl::dump(int fd) {
-    if (mFocusListener == nullptr) {
-        dprintf(fd, "No focus listener registered\n");
-    } else {
-        dprintf(fd, "Focus listener registered\n");
-    }
-}
-
-void AudioControl::cmdHelp(int fd) const {
-    dprintf(fd, "Usage: \n\n");
-    dprintf(fd, "[no args]: dumps focus listener status\n");
-    dprintf(fd, "--help: shows this help\n");
-    dprintf(fd,
-            "--request <USAGE> <ZONE_ID> <FOCUS_GAIN>: requests audio focus for specified "
-            "usage (int), audio zone ID (int), and focus gain type (int)\n");
-    dprintf(fd,
-            "--abandon <USAGE> <ZONE_ID>: abandons audio focus for specified usage (int) and "
-            "audio zone ID (int)\n");
-}
-
-void AudioControl::cmdRequestFocus(int fd, const hidl_vec<hidl_string>& options) {
-    if (!checkCallerHasWritePermissions(fd) || !checkArgumentsSize(fd, options, 3)) return;
-
-    hidl_bitfield<AudioUsage> usage;
-    if (!safelyParseInt(options[1], &usage)) {
-        dprintf(fd, "Non-integer usage provided with request: %s\n", options[1].c_str());
-        return;
-    }
-    int zoneId;
-    if (!safelyParseInt(options[2], &zoneId)) {
-        dprintf(fd, "Non-integer zoneId provided with request: %s\n", options[2].c_str());
-        return;
-    }
-    hidl_bitfield<AudioFocusChange> focusGain;
-    if (!safelyParseInt(options[3], &focusGain)) {
-        dprintf(fd, "Non-integer focusGain provided with request: %s\n", options[3].c_str());
-        return;
-    }
-
-    if (mFocusListener == nullptr) {
-        dprintf(fd, "Unable to request focus - no focus listener registered\n");
-        return;
-    }
-
-    mFocusListener->requestAudioFocus(usage, zoneId, focusGain);
-    dprintf(fd, "Requested focus for usage %d, zoneId %d, and focusGain %d\n", usage, zoneId,
-            focusGain);
-}
-
-void AudioControl::cmdAbandonFocus(int fd, const hidl_vec<hidl_string>& options) {
-    if (!checkCallerHasWritePermissions(fd) || !checkArgumentsSize(fd, options, 2)) return;
-
-    hidl_bitfield<AudioUsage> usage;
-    if (!safelyParseInt(options[1], &usage)) {
-        dprintf(fd, "Non-integer usage provided with abandon: %s\n", options[1].c_str());
-        return;
-    }
-    int zoneId;
-    if (!safelyParseInt(options[2], &zoneId)) {
-        dprintf(fd, "Non-integer zoneId provided with abandon: %s\n", options[2].c_str());
-        return;
-    }
-
-    if (mFocusListener == nullptr) {
-        dprintf(fd, "Unable to abandon focus - no focus listener registered\n");
-        return;
-    }
-
-    mFocusListener->abandonAudioFocus(usage, zoneId);
-    dprintf(fd, "Abandoned focus for usage %d and zoneId %d\n", usage, zoneId);
-}
-
-bool AudioControl::checkCallerHasWritePermissions(int fd) {
-    // Double check that's only called by root - it should be be blocked at the HIDL debug() level,
-    // but it doesn't hurt to make sure...
-    if (hardware::IPCThreadState::self()->getCallingUid() != AID_ROOT) {
-        dprintf(fd, "Must be root\n");
-        return false;
-    }
-    return true;
-}
-
-bool AudioControl::checkArgumentsSize(int fd, const hidl_vec<hidl_string>& options,
-                                      size_t expectedSize) {
-    // options includes the command, so reducing size by one
-    size_t size = options.size() - 1;
-    if (size == expectedSize) {
-        return true;
-    }
-    dprintf(fd, "Invalid number of arguments: required %zu, got %zu\n", expectedSize, size);
-    return false;
-}
-
-bool AudioControl::safelyParseInt(std::string s, int* out) {
-    if (!android::base::ParseInt(s, out)) {
-        return false;
-    }
-    return true;
-}
-
-}  // namespace android::hardware::automotive::audiocontrol::V2_0::implementation
diff --git a/automotive/audiocontrol/2.0/default/AudioControl.h b/automotive/audiocontrol/2.0/default/AudioControl.h
deleted file mode 100644
index d66458ec05..0000000000
--- a/automotive/audiocontrol/2.0/default/AudioControl.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_HARDWARE_AUTOMOTIVE_AUDIOCONTROL_V2_0_AUDIOCONTROL_H
-#define ANDROID_HARDWARE_AUTOMOTIVE_AUDIOCONTROL_V2_0_AUDIOCONTROL_H
-
-#include <android/hardware/audio/common/6.0/types.h>
-#include <android/hardware/automotive/audiocontrol/2.0/IAudioControl.h>
-#include <android/hardware/automotive/audiocontrol/2.0/ICloseHandle.h>
-#include <hidl/MQDescriptor.h>
-#include <hidl/Status.h>
-
-using android::hardware::audio::common::V6_0::AudioUsage;
-
-namespace android::hardware::automotive::audiocontrol::V2_0::implementation {
-
-class AudioControl : public IAudioControl {
-  public:
-    // Methods from ::android::hardware::automotive::audiocontrol::V2_0::IAudioControl follow.
-    Return<sp<ICloseHandle>> registerFocusListener(const sp<IFocusListener>& listener);
-    Return<void> onAudioFocusChange(hidl_bitfield<AudioUsage> usage, int zoneId,
-                                    hidl_bitfield<AudioFocusChange> focusChange);
-    Return<void> setBalanceTowardRight(float value) override;
-    Return<void> setFadeTowardFront(float value) override;
-    Return<void> debug(const hidl_handle& fd, const hidl_vec<hidl_string>& options) override;
-
-    // Implementation details
-    AudioControl();
-
-  private:
-    sp<IFocusListener> mFocusListener;
-
-    static bool checkArgumentsSize(int fd, const hidl_vec<hidl_string>& options, size_t minSize);
-    static bool checkCallerHasWritePermissions(int fd);
-    static bool isValidValue(float value);
-    static bool safelyParseInt(std::string s, int* out);
-
-    void cmdDump(int fd, const hidl_vec<hidl_string>& options);
-    void cmdHelp(int fd) const;
-    void cmdRequestFocus(int fd, const hidl_vec<hidl_string>& options);
-    void cmdAbandonFocus(int fd, const hidl_vec<hidl_string>& options);
-    void dump(int fd);
-};
-
-}  // namespace android::hardware::automotive::audiocontrol::V2_0::implementation
-
-#endif  // ANDROID_HARDWARE_AUTOMOTIVE_AUDIOCONTROL_V2_0_AUDIOCONTROL_H
diff --git a/automotive/audiocontrol/2.0/default/CloseHandle.cpp b/automotive/audiocontrol/2.0/default/CloseHandle.cpp
deleted file mode 100644
index bc47931535..0000000000
--- a/automotive/audiocontrol/2.0/default/CloseHandle.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "CloseHandle.h"
-
-namespace android::hardware::automotive::audiocontrol::V2_0::implementation {
-
-CloseHandle::CloseHandle(Callback callback) : mCallback(callback) {}
-
-CloseHandle::~CloseHandle() {
-    close();
-}
-
-Return<void> CloseHandle::close() {
-    const auto wasClosed = mIsClosed.exchange(true);
-    if (wasClosed) return {};
-
-    if (mCallback) mCallback();
-    return {};
-}
-
-}  // namespace android::hardware::automotive::audiocontrol::V2_0::implementation
diff --git a/automotive/audiocontrol/2.0/default/CloseHandle.h b/automotive/audiocontrol/2.0/default/CloseHandle.h
deleted file mode 100644
index 6caf0bfa7e..0000000000
--- a/automotive/audiocontrol/2.0/default/CloseHandle.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <android-base/macros.h>
-#include <android/hardware/automotive/audiocontrol/2.0/ICloseHandle.h>
-
-namespace android::hardware::automotive::audiocontrol::V2_0::implementation {
-
-/** Generic ICloseHandle implementation ignoring double-close events. */
-class CloseHandle : public ICloseHandle {
-  public:
-    using Callback = std::function<void()>;
-
-    /**
-     * Create a handle with a callback.
-     *
-     * The callback is guaranteed to be called exactly once.
-     *
-     * \param callback Called on the first close() call, or on destruction of the handle
-     */
-    CloseHandle(Callback callback = nullptr);
-    virtual ~CloseHandle();
-
-    Return<void> close() override;
-
-  private:
-    const Callback mCallback;
-    std::atomic<bool> mIsClosed = false;
-
-    DISALLOW_COPY_AND_ASSIGN(CloseHandle);
-};
-
-}  // namespace android::hardware::automotive::audiocontrol::V2_0::implementation
diff --git a/automotive/audiocontrol/2.0/default/android.hardware.automotive.audiocontrol@2.0-service.rc b/automotive/audiocontrol/2.0/default/android.hardware.automotive.audiocontrol@2.0-service.rc
deleted file mode 100644
index 81c9be4460..0000000000
--- a/automotive/audiocontrol/2.0/default/android.hardware.automotive.audiocontrol@2.0-service.rc
+++ /dev/null
@@ -1,4 +0,0 @@
-service vendor.audiocontrol-hal-2.0 /vendor/bin/hw/android.hardware.automotive.audiocontrol@2.0-service
-    class hal
-    user audioserver
-    group system
diff --git a/automotive/audiocontrol/2.0/default/audiocontrol2_manifest.xml b/automotive/audiocontrol/2.0/default/audiocontrol2_manifest.xml
deleted file mode 100644
index 42d23ed62e..0000000000
--- a/automotive/audiocontrol/2.0/default/audiocontrol2_manifest.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<manifest version="1.0" type="device">
-    <hal format="hidl">
-        <name>android.hardware.automotive.audiocontrol</name>
-        <transport>hwbinder</transport>
-        <version>2.0</version>
-        <interface>
-            <name>IAudioControl</name>
-            <instance>default</instance>
-        </interface>
-    </hal>
-</manifest>
\ No newline at end of file
diff --git a/automotive/audiocontrol/2.0/default/service.cpp b/automotive/audiocontrol/2.0/default/service.cpp
deleted file mode 100644
index dcc46c31aa..0000000000
--- a/automotive/audiocontrol/2.0/default/service.cpp
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <unistd.h>
-
-#include <android-base/logging.h>
-#include <hidl/HidlTransportSupport.h>
-#include <utils/Errors.h>
-#include <utils/StrongPointer.h>
-
-#include "AudioControl.h"
-
-// libhidl:
-using android::hardware::configureRpcThreadpool;
-using android::hardware::joinRpcThreadpool;
-
-// Generated HIDL files
-using android::hardware::automotive::audiocontrol::V2_0::IAudioControl;
-
-// The namespace in which all our implementation code lives
-using namespace android::hardware::automotive::audiocontrol::V2_0::implementation;
-using namespace android;
-
-// Main service entry point
-int main() {
-    // Create an instance of our service class
-    android::sp<IAudioControl> service = new AudioControl();
-    configureRpcThreadpool(1, true /*callerWillJoin*/);
-
-    if (service->registerAsService() != OK) {
-        LOG(ERROR) << "registerAsService failed";
-        return 1;
-    }
-
-    // Join (forever) the thread pool we created for the service above
-    joinRpcThreadpool();
-
-    // We don't ever actually expect to return, so return an error if we do get here
-    return 2;
-}
\ No newline at end of file
diff --git a/automotive/audiocontrol/2.0/vts/functional/Android.bp b/automotive/audiocontrol/2.0/vts/functional/Android.bp
deleted file mode 100644
index 7499bc4a12..0000000000
--- a/automotive/audiocontrol/2.0/vts/functional/Android.bp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// Copyright (C) 2020 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_automotive",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalAudioControlV2_0TargetTest",
-    team: "trendy_team_aaos_audio_triage",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["VtsHalAudioControlV2_0TargetTest.cpp"],
-    static_libs: [
-        "android.hardware.automotive.audiocontrol@2.0",
-        "libgmock",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/automotive/audiocontrol/2.0/vts/functional/OWNERS b/automotive/audiocontrol/2.0/vts/functional/OWNERS
deleted file mode 100644
index fb422db4c7..0000000000
--- a/automotive/audiocontrol/2.0/vts/functional/OWNERS
+++ /dev/null
@@ -1,2 +0,0 @@
-# Bug component: 162915
-zhaomingyin@google.com
diff --git a/automotive/audiocontrol/2.0/vts/functional/VtsHalAudioControlV2_0TargetTest.cpp b/automotive/audiocontrol/2.0/vts/functional/VtsHalAudioControlV2_0TargetTest.cpp
deleted file mode 100644
index fa351430e3..0000000000
--- a/automotive/audiocontrol/2.0/vts/functional/VtsHalAudioControlV2_0TargetTest.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "VtsHalAudioControlTest"
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-
-#include <stdio.h>
-#include <string.h>
-
-#include <hidl/HidlTransportSupport.h>
-#include <hwbinder/ProcessState.h>
-#include <log/log.h>
-#include <utils/Errors.h>
-#include <utils/StrongPointer.h>
-
-#include <android/hardware/audio/common/6.0/types.h>
-#include <android/hardware/automotive/audiocontrol/2.0/IAudioControl.h>
-#include <android/hardware/automotive/audiocontrol/2.0/types.h>
-#include <android/log.h>
-
-using namespace ::android::hardware::automotive::audiocontrol::V2_0;
-using ::android::sp;
-using ::android::hardware::hidl_bitfield;
-using ::android::hardware::hidl_enum_range;
-using ::android::hardware::hidl_handle;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::audio::common::V6_0::AudioUsage;
-
-// The main test class for the automotive AudioControl HAL
-class CarAudioControlHidlTest : public testing::TestWithParam<std::string> {
-  public:
-    virtual void SetUp() override {
-        // Make sure we can connect to the driver
-        pAudioControl = IAudioControl::getService(GetParam());
-        ASSERT_NE(pAudioControl.get(), nullptr);
-    }
-
-    virtual void TearDown() override {}
-
-  protected:
-    sp<IAudioControl> pAudioControl;  // Every test needs access to the service
-};
-
-//
-// Tests start here...
-//
-
-/*
- * Fader exercise test.  Note that only a subjective observer could determine if the
- * fader actually works.  The only thing we can do is exercise the HAL and if the HAL crashes,
- * we _might_ get a test failure if that breaks the connection to the driver.
- */
-TEST_P(CarAudioControlHidlTest, FaderExercise) {
-    ALOGI("Fader exercise test (silent)");
-
-    // Set the fader all the way to the back
-    pAudioControl->setFadeTowardFront(-1.0f);
-
-    // Set the fader all the way to the front
-    pAudioControl->setFadeTowardFront(1.0f);
-
-    // Set the fader part way toward the back
-    pAudioControl->setFadeTowardFront(-0.333f);
-
-    // Set the fader to a out of bounds value (driver should clamp)
-    pAudioControl->setFadeTowardFront(99999.9f);
-
-    // Set the fader back to the middle
-    pAudioControl->setFadeTowardFront(0.0f);
-}
-
-/*
- * Balance exercise test.
- */
-TEST_P(CarAudioControlHidlTest, BalanceExercise) {
-    ALOGI("Balance exercise test (silent)");
-
-    // Set the balance all the way to the left
-    pAudioControl->setBalanceTowardRight(-1.0f);
-
-    // Set the balance all the way to the right
-    pAudioControl->setBalanceTowardRight(1.0f);
-
-    // Set the balance part way toward the left
-    pAudioControl->setBalanceTowardRight(-0.333f);
-
-    // Set the balance to a out of bounds value (driver should clamp)
-    pAudioControl->setBalanceTowardRight(99999.9f);
-
-    // Set the balance back to the middle
-    pAudioControl->setBalanceTowardRight(0.0f);
-}
-
-struct FocusListenerMock : public IFocusListener {
-    MOCK_METHOD(Return<void>, requestAudioFocus,
-                (hidl_bitfield<AudioUsage> usage, int zoneId,
-                 hidl_bitfield<AudioFocusChange> focusGain));
-    MOCK_METHOD(Return<void>, abandonAudioFocus, (hidl_bitfield<AudioUsage> usage, int zoneId));
-};
-
-/*
- * Test focus listener registration.
- *
- * Verifies that:
- * - registerFocusListener succeeds;
- * - registering a second listener succeeds in replacing the first;
- * - closing handle does not crash;
- */
-TEST_P(CarAudioControlHidlTest, FocusListenerRegistration) {
-    ALOGI("Focus listener test");
-
-    sp<FocusListenerMock> listener = new FocusListenerMock();
-
-    auto hidlResult = pAudioControl->registerFocusListener(listener);
-    ASSERT_TRUE(hidlResult.isOk());
-
-    sp<FocusListenerMock> listener2 = new FocusListenerMock();
-
-    auto hidlResult2 = pAudioControl->registerFocusListener(listener2);
-    ASSERT_TRUE(hidlResult2.isOk());
-
-    const sp<ICloseHandle>& closeHandle = hidlResult2;
-    closeHandle->close();
-};
-
-TEST_P(CarAudioControlHidlTest, FocusChangeExercise) {
-    ALOGI("Focus Change test");
-
-    pAudioControl->onAudioFocusChange(AudioUsage::MEDIA | 0, 0,
-                                      AudioFocusChange::GAIN_TRANSIENT | 0);
-};
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(CarAudioControlHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, CarAudioControlHidlTest,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IAudioControl::descriptor)),
-        android::hardware::PrintInstanceNameToString);
\ No newline at end of file
diff --git a/automotive/can/1.0/vts/functional/OWNERS b/automotive/can/1.0/vts/functional/OWNERS
index 85257a3537..0f249b049e 100644
--- a/automotive/can/1.0/vts/functional/OWNERS
+++ b/automotive/can/1.0/vts/functional/OWNERS
@@ -1,3 +1,2 @@
 # Bug component: 533426
-twasilczyk@google.com
 chrisweir@google.com
diff --git a/automotive/can/OWNERS b/automotive/can/OWNERS
index b738dac662..bc3ac95fda 100644
--- a/automotive/can/OWNERS
+++ b/automotive/can/OWNERS
@@ -1,2 +1 @@
 chrisweir@google.com
-twasilczyk@google.com
diff --git a/automotive/can/aidl/vts/functional/OWNERS b/automotive/can/aidl/vts/functional/OWNERS
index 85257a3537..0f249b049e 100644
--- a/automotive/can/aidl/vts/functional/OWNERS
+++ b/automotive/can/aidl/vts/functional/OWNERS
@@ -1,3 +1,2 @@
 # Bug component: 533426
-twasilczyk@google.com
 chrisweir@google.com
diff --git a/automotive/evs/1.1/vts/functional/VtsHalEvsV1_1TargetTest.cpp b/automotive/evs/1.1/vts/functional/VtsHalEvsV1_1TargetTest.cpp
index ff7f41c119..3d27d08ae9 100644
--- a/automotive/evs/1.1/vts/functional/VtsHalEvsV1_1TargetTest.cpp
+++ b/automotive/evs/1.1/vts/functional/VtsHalEvsV1_1TargetTest.cpp
@@ -662,7 +662,7 @@ TEST_P(EvsHidlTest, CameraToDisplayRoundTrip) {
             ASSERT_GT(height, 0);
 
             android::ui::DisplayState* pState = (android::ui::DisplayState*)state.data();
-            ASSERT_NE(pState->layerStack, android::ui::INVALID_LAYER_STACK);
+            ASSERT_NE(pState->layerStack, android::ui::UNASSIGNED_LAYER_STACK);
         });
 
         bool isLogicalCam = false;
diff --git a/automotive/evs/aidl/Android.bp b/automotive/evs/aidl/Android.bp
index 8983ae4ca1..f293f07138 100644
--- a/automotive/evs/aidl/Android.bp
+++ b/automotive/evs/aidl/Android.bp
@@ -55,14 +55,14 @@ aidl_interface {
             version: "1",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
         {
             version: "2",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
 
diff --git a/automotive/evs/aidl/vts/VtsHalEvsTargetTest.cpp b/automotive/evs/aidl/vts/VtsHalEvsTargetTest.cpp
index dc78ed607f..aad5478bbc 100644
--- a/automotive/evs/aidl/vts/VtsHalEvsTargetTest.cpp
+++ b/automotive/evs/aidl/vts/VtsHalEvsTargetTest.cpp
@@ -1736,6 +1736,13 @@ TEST_P(EvsAidlTest, CameraUseStreamConfigToDisplay) {
 
     // Test each reported camera
     for (auto&& cam : mCameraInfo) {
+        bool isLogicalCam = false;
+        auto devices = getPhysicalCameraIds(cam.id, isLogicalCam);
+        if (mIsHwModule && isLogicalCam) {
+            LOG(INFO) << "Skip a logical device, " << cam.id << " for HW target.";
+            continue;
+        }
+
         // Request exclusive access to the EVS display
         std::shared_ptr<IEvsDisplay> pDisplay;
         ASSERT_TRUE(mEnumerator->openDisplay(targetDisplayId, &pDisplay).isOk());
diff --git a/automotive/vehicle/2.0/default/Android.bp b/automotive/vehicle/2.0/default/Android.bp
index 05f2294ed4..a2c377be0e 100644
--- a/automotive/vehicle/2.0/default/Android.bp
+++ b/automotive/vehicle/2.0/default/Android.bp
@@ -294,7 +294,7 @@ cc_fuzz {
     fuzz_config: {
         cc: [
             "ericjeong@google.com",
-            "shanyu@google.com",
+            "tylertrephan@google.com",
         ],
         componentid: 533764,
         hotlists: [
diff --git a/automotive/vehicle/OWNERS b/automotive/vehicle/OWNERS
index 066af9a299..fdd08dd3c9 100644
--- a/automotive/vehicle/OWNERS
+++ b/automotive/vehicle/OWNERS
@@ -1,6 +1,2 @@
 ericjeong@google.com
-shanyu@google.com
-
-# Property definition
-per-file aidl_property/** = tylertrephan@google.com
-per-file aidl/generated_lib/** = tylertrephan@google.com
+tylertrephan@google.com
diff --git a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/GetValueResult.aidl b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/GetValueResult.aidl
index 208c882d9f..4b01b15d6c 100644
--- a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/GetValueResult.aidl
+++ b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/GetValueResult.aidl
@@ -29,6 +29,8 @@ parcelable GetValueResult {
     // fails and prop should be ignored.
     StatusCode status = StatusCode.OK;
     // Contains the property value if status is OK. Must be null if status is
-    // not OK.
+    // not OK. To prevent confusion, if a property not in available status,
+    // GetValueResult.status should be used to represent this instead of
+    // VehiclePropValue.status.
     @nullable VehiclePropValue prop;
 }
diff --git a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/IVehicleCallback.aidl b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/IVehicleCallback.aidl
index 7230d09028..1c885db6d0 100644
--- a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/IVehicleCallback.aidl
+++ b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/IVehicleCallback.aidl
@@ -68,6 +68,11 @@ interface IVehicleCallback {
      * arguments) or when the {@link IVehicle#setValues} method was called and
      * the actual change needs to be reported.
      *
+     * This should also be used to deliver property status change events. E.g.
+     * when the property becomes unavailable or error for reading, a
+     * {@code VehiclePropValue} with non-okay status and empty value should be
+     * delivered.
+     *
      * @param propValues The updated property values wrapped in an object.
      *    If the properties fit within binder limitation, they would be in
      *    {@code propValues.payloads}, otherwise, they would be in a shared
diff --git a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehicleAreaConfig.aidl b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehicleAreaConfig.aidl
index cb1b94b575..f2cda32e85 100644
--- a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehicleAreaConfig.aidl
+++ b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehicleAreaConfig.aidl
@@ -265,7 +265,8 @@ parcelable VehicleAreaConfig {
      *
      * If this is not {@code null}. The VHAL implementation must implement
      * {@code getMinMaxSupportedValue}, {@code getSupportedValuesLists},
-     * {@code subscribeSupportedValueChange} for the [propId, areaId].
+     * {@code subscribeSupportedValueChange}, {@code unsubscribeSupportedValueChange} for the
+     * [propId, areaId].
      *
      * This should be non-null if the VHAL implementation wants to expose
      * min/max supported value or supported values list that may change dynamically. For example,
diff --git a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropValue.aidl b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropValue.aidl
index c78c6358c0..135482b63e 100644
--- a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropValue.aidl
+++ b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropValue.aidl
@@ -40,7 +40,20 @@ parcelable VehiclePropValue {
     /** Property identifier */
     int prop;
 
-    /** Status of the property */
+    /**
+     * Status of the property for reading.
+     *
+     * For read/write property, this may also apply for writing but not
+     * guaranteed, e.g. the property might be available for read but not
+     * available for writing. In such case, status is AVAILABLE and the value
+     * field contains valid information.
+     *
+     * NOTE: There is currently no way for a client to monitor the write status for a read/write or
+     * write property. The client only knows if the property is available for writing when it tries
+     * to set the value (via the StatusCode).
+     *
+     * NOTE: If the status is not AVAILABLE, the value field must be ignored.
+     */
     VehiclePropertyStatus status = VehiclePropertyStatus.AVAILABLE;
 
     RawPropValues value;
diff --git a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropertyStatus.aidl b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropertyStatus.aidl
index 4b1dcdb6af..7f71d96743 100644
--- a/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropertyStatus.aidl
+++ b/automotive/vehicle/aidl/android/hardware/automotive/vehicle/VehiclePropertyStatus.aidl
@@ -16,8 +16,25 @@
 
 package android.hardware.automotive.vehicle;
 
+/**
+ * Error codes used in vehicle HAL interface. System defined error codes will have the range from
+ * 0x0000 to 0xffff and vendor error codes will have the range from 0x0001 to 0xffff. The error code
+ * is formatted as [VENDOR_ERROR] << 16 | [SYSTEM_ERROR]. A vendor error code of 0 indicates vendor
+ * code not set.
+ */
+
 /**
  * Property status is a dynamic value that may change based on the vehicle state.
+ *
+ * System defined status will have the range from 0x0000 to 0xffff and vendor status will have the
+ * range from 0x0001 to 0xffff. The status is formatted as [VENDOR_STATUS] << 16 | [SYSTEM_STATUS].
+ * A vendor status code of 0 indicates vendor status is not set.
+ *
+ * The vendor status is only exposed through property events caused by subscriptions.
+ *
+ * For get property results, VehiclePropertyStatus should always be AVAILABLE. If the property
+ * is not in an available status, GetValueResult.status should be set to an appropriate error
+ * code.
  */
 @VintfStability
 @Backing(type="int")
diff --git a/automotive/vehicle/aidl/emu_metadata/android.hardware.automotive.vehicle-types-meta.json b/automotive/vehicle/aidl/emu_metadata/android.hardware.automotive.vehicle-types-meta.json
index e7c03ad947..2b81f23acd 100644
--- a/automotive/vehicle/aidl/emu_metadata/android.hardware.automotive.vehicle-types-meta.json
+++ b/automotive/vehicle/aidl/emu_metadata/android.hardware.automotive.vehicle-types-meta.json
@@ -168,7 +168,7 @@
             {
                 "name": "Reports wheel ticks",
                 "value": 290521862,
-                "description": "Reports wheel ticks\nThe first element in the vector is a reset count.  A reset indicates previous tick counts are not comparable with this and future ones.  Some sort of discontinuity in tick counting has occurred.\nThe next four elements represent ticks for individual wheels in the following order: front left, front right, rear right, rear left.  All tick counts are cumulative.  Tick counts increment when the vehicle moves forward, and decrement when vehicles moves in reverse.  The ticks should be reset to 0 when the vehicle is started by the user.\nint64Values[0] = reset count int64Values[1] = front left ticks int64Values[2] = front right ticks int64Values[3] = rear right ticks int64Values[4] = rear left ticks\nconfigArray is used to indicate the micrometers-per-wheel-tick value and which wheels are supported.  configArray is set as follows:\nconfigArray[0], bits [0:3] = supported wheels. Uses enum Wheel. For example, if all wheels are supported, then configArray[0] = VehicleAreaWheel::LEFT_FRONT | VehicleAreaWheel::RIGHT_FRONT | VehicleAreaWheel::LEFT_REAR | VehicleAreaWheel::RIGHT_REAR configArray[1] = micrometers per front left wheel tick configArray[2] = micrometers per front right wheel tick configArray[3] = micrometers per rear right wheel tick configArray[4] = micrometers per rear left wheel tick\nNOTE:  If a wheel is not supported, its value shall always be set to 0.\nVehiclePropValue.timestamp must be correctly filled in."
+                "description": "Reports wheel ticks\nThe first element in the vector is a reset count. A reset indicates previous tick counts are not comparable with this and future ones - some sort of discontinuity in tick counting has occurred. Conversely, tick measurements must be comparable if their corresponding reset count is the same. This value must be a monotonically increasing value where each time a reset happens, the value increases by 1.\nThe next four elements represent ticks for individual wheels in the following order: front left, front right, rear right, rear left. All tick counts are cumulative. Tick counts increment when the vehicle moves forward, and decrement when vehicles moves in reverse. The ticks should be reset to 0 when the vehicle is started by the user.\nint64Values[0] = reset count int64Values[1] = front left ticks int64Values[2] = front right ticks int64Values[3] = rear right ticks int64Values[4] = rear left ticks\nconfigArray is used to indicate the micrometers-per-wheel-tick value and which wheels are supported. configArray is set as follows:\nconfigArray[0], bits [0:3] = supported wheels. Uses enum Wheel. For example, if all wheels are supported, then configArray[0] = VehicleAreaWheel::LEFT_FRONT | VehicleAreaWheel::RIGHT_FRONT | VehicleAreaWheel::LEFT_REAR | VehicleAreaWheel::RIGHT_REAR configArray[1] = micrometers per front left wheel tick configArray[2] = micrometers per front right wheel tick configArray[3] = micrometers per rear right wheel tick configArray[4] = micrometers per rear left wheel tick\nNOTE: If a wheel is not supported, its value shall always be set to 0.\nVehiclePropValue.timestamp must be correctly filled in."
             },
             {
                 "name": "Fuel level in milliliters",
@@ -830,7 +830,7 @@
             {
                 "name": "Headrest angle move",
                 "value": 356518808,
-                "description": "Headrest angle move\nThe maxInt32Value and minInt32Value in each VehicleAreaConfig must be defined. All integers between minInt32Value and maxInt32Value must be supported.\nThe minInt32Value represents the maximum movement speed of the seat's headrest while moving into a shallow position.\nThe maxInt32Value represents the maximum movement speed of the seat's headrest while moving into an upright\/forward position.\nLarger absolute values, either positive or negative, indicate a faster movement speed. Once the seat's headrest reaches the positional limit, the value must reset to 0. If SEAT_HEADREST_ANGLE_MOVE's value is currently 0, then that means there is no movement currently occurring.\nIf {@code HasSupportedValueInfo} for a specific area ID is not {@code null}: {@code HasSupportedValueInfo#hasMinSupportedValue} and {@code HasSupportedValueInfo#hasMaxSupportedValue} must be {@code true} for the area ID. {@code MinMaxSupportedValueResult#minSupportedValue} has the same meaning as minInt32Value. {@code MinMaxSupportedValueResult#maxSupportedValue} has the same meaning as maxInt32Value. All integers between minSupportedValue and maxSupportedValue must be supported. At boot, minInt32Value is equal to minSupportedValue, maxInt32Value is equal to maxSupportedValue.\nThis property is not in any particular unit but in a specified range of relative movement speeds.\nThis property is defined as VehiclePropertyAccess.READ_WRITE, but OEMs have the option to implement it as VehiclePropertyAccess.READ only."
+                "description": "Headrest angle move\nThe maxInt32Value and minInt32Value in each VehicleAreaConfig must be defined. All integers between minInt32Value and maxInt32Value must be supported.\nThe minInt32Value represents the maximum movement speed of the seat's headrest while reclining.\nThe maxInt32Value represents the maximum movement speed of the seat's headrest while moving into an upright\/forward position.\nLarger absolute values, either positive or negative, indicate a faster movement speed. Once the seat's headrest reaches the positional limit, the value must reset to 0. If SEAT_HEADREST_ANGLE_MOVE's value is currently 0, then that means there is no movement currently occurring.\nIf {@code HasSupportedValueInfo} for a specific area ID is not {@code null}: {@code HasSupportedValueInfo#hasMinSupportedValue} and {@code HasSupportedValueInfo#hasMaxSupportedValue} must be {@code true} for the area ID. {@code MinMaxSupportedValueResult#minSupportedValue} has the same meaning as minInt32Value. {@code MinMaxSupportedValueResult#maxSupportedValue} has the same meaning as maxInt32Value. All integers between minSupportedValue and maxSupportedValue must be supported. At boot, minInt32Value is equal to minSupportedValue, maxInt32Value is equal to maxSupportedValue.\nThis property is not in any particular unit but in a specified range of relative movement speeds.\nThis property is defined as VehiclePropertyAccess.READ_WRITE, but OEMs have the option to implement it as VehiclePropertyAccess.READ only."
             },
             {
                 "name": "Headrest fore\/aft position",
@@ -921,7 +921,7 @@
             {
                 "name": "Window Position",
                 "value": 322964416,
-                "description": "Window Position\nThe maxInt32Value and minInt32Value in each VehicleAreaConfig must be defined.\nAll integers between minInt32Value and maxInt32Value must be supported.\nThe minInt32Value indicates the window is closed\/fully open out of plane. If the window cannot open out of plane, then minInt32Value is the position of the window when fully closed and must be 0. If the window can open out of plane, the minInt32Value indicates the window is fully open in its position out of plane and will be a negative value. See the example below for a more detailed explanation.\nThe maxInt32Value indicates the window is fully open.\nValues in between minInt32Value and maxInt32Value indicate a transition state between the closed\/fully open out-of-plane and fully open positions.\nThis property is not in any particular unit but in a specified range of relative positions.\nFor example, this is how the property should work for a window that can move out of plane: For a window that may open out of plane (i.e. vent mode of sunroof) this parameter will work with negative values as follows: Max = sunroof completely open 0 = sunroof closed. Min = sunroof vent completely open\nNote that in this mode, 0 indicates the window is closed.\nIf {@code HasSupportedValueInfo} for a specific area ID is not {@code null}: {@code HasSupportedValueInfo#hasMinSupportedValue} and {@code HasSupportedValueInfo#hasMaxSupportedValue} must be {@code true} for the area ID. {@code MinMaxSupportedValueResult#minSupportedValue} has the same meaning as minInt32Value. {@code MinMaxSupportedValueResult#maxSupportedValue} has the same meaning as maxInt32Value. All integers between minSupportedValue and maxSupportedValue must be supported. At boot, minInt32Value is equal to minSupportedValue, maxInt32Value is equal to maxSupportedValue.\nThis property is defined as VehiclePropertyAccess.READ_WRITE, but OEMs have the option to implement it as VehiclePropertyAccess.READ only."
+                "description": "Window Position\nThe maxInt32Value and minInt32Value in each VehicleAreaConfig must be defined.\nAll integers between minInt32Value and maxInt32Value must be supported.\nThe minInt32Value indicates the window is closed\/fully open out of plane. If the window cannot open out of plane, then minInt32Value is the position of the window when fully closed and must be 0. If the window can open out of plane, the minInt32Value indicates the window is fully open in its position out of plane and will be a negative value. See the example below for a more detailed explanation.\nThe maxInt32Value indicates the window is fully open.\nValues in between minInt32Value and maxInt32Value indicate a transition state between the closed\/fully open out-of-plane and fully open positions.\nThis property is not in any particular unit but in a specified range of relative positions.\nFor example, this is how the property should work for a window that can move out of plane: For a window that may open out of plane (i.e. vent mode of sunroof) this parameter will work with negative values as follows: Max = sunroof completely open 0 = sunroof closed. Min = sunroof vent completely vented\nNote that in all modes, 0 indicates the window is closed.\nIf {@code HasSupportedValueInfo} for a specific area ID is not {@code null}: {@code HasSupportedValueInfo#hasMinSupportedValue} and {@code HasSupportedValueInfo#hasMaxSupportedValue} must be {@code true} for the area ID. {@code MinMaxSupportedValueResult#minSupportedValue} has the same meaning as minInt32Value. {@code MinMaxSupportedValueResult#maxSupportedValue} has the same meaning as maxInt32Value. All integers between minSupportedValue and maxSupportedValue must be supported. At boot, minInt32Value is equal to minSupportedValue, maxInt32Value is equal to maxSupportedValue.\nThis property is defined as VehiclePropertyAccess.READ_WRITE, but OEMs have the option to implement it as VehiclePropertyAccess.READ only."
             },
             {
                 "name": "Window Move",
@@ -1344,7 +1344,7 @@
             {
                 "name": "EV_CHARGE_PERCENT_LIMIT",
                 "value": 291508032,
-                "description": "Indicates the maximum charge percent threshold set by the user\nReturns a float value from 0 to 100.\nconfigArray is used to specify the valid values at boot time. For example, if the vehicle supports the following charge percent limit values: [20, 40, 60, 80, 100] then the configArray should be {20, 40, 60, 80, 100} If the configArray is empty then all values from 0 to 100 must be valid.\nIf {@code HasSupportedValueInfo} for the global area ID (0) is not {@code null}, {@code HasSupportedValueInfo#hasSupportedValuesList} must be {@code true}. {@code SupportedValuesListResult#supportedValuesList} specifies the valid maximum charge percent threshold options at the current moment. At boot, configArray content must match the supported values list.\nIf the valid values may change dynamically, {@code HasSupportedValueInfo#hasSupportedValuesList} must be {@code true} and {@code SupportedValuesListResult#supportedValuesList} must be implemented.\nThis property is defined as VehiclePropertyAccess.READ_WRITE, but OEMs have the option to implement it as VehiclePropertyAccess.READ only."
+                "description": "Indicates the maximum charge percent threshold set by the user\nReturns a float value from 0 to 100.\nconfigArray is optional. If not empty, it is used to specify the valid values at boot time. For example, if the vehicle supports the following charge percent limit values: [20, 40, 60, 80, 100] then the configArray should be {20, 40, 60, 80, 100}.\nIf the configArray is empty then all values from 0 to 100 must be valid.\nIf {@code HasSupportedValueInfo} for the global area ID (0) is not {@code null} and if {@code HasSupportedValueInfo#hasSupportedValuesList} is {@code true}, {@code SupportedValuesListResult#supportedValuesList} specifies the valid maximum charge percent threshold options at the current moment. If {@code HasSupportedValueInfo#hasSupportedValuesList} is {@code false}, all values from 0 to 100 must be valid. At boot, if not empty, configArray content must match the supported values list.\nIf the valid values may change dynamically, {@code HasSupportedValueInfo#hasSupportedValuesList} must be {@code true} and {@code SupportedValuesListResult#supportedValuesList} must be implemented.\nThis property is defined as VehiclePropertyAccess.READ_WRITE, but OEMs have the option to implement it as VehiclePropertyAccess.READ only."
             },
             {
                 "name": "Charging state of the car",
diff --git a/automotive/vehicle/aidl/generated_lib/3/cpp/VersionForVehicleProperty.h b/automotive/vehicle/aidl/generated_lib/3/cpp/VersionForVehicleProperty.h
index 0d242737d1..5a31a2bfae 100644
--- a/automotive/vehicle/aidl/generated_lib/3/cpp/VersionForVehicleProperty.h
+++ b/automotive/vehicle/aidl/generated_lib/3/cpp/VersionForVehicleProperty.h
@@ -39,140 +39,140 @@ namespace automotive {
 namespace vehicle {
 
 std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
-        {VehicleProperty::INFO_VIN, 2},
-        {VehicleProperty::INFO_MAKE, 2},
-        {VehicleProperty::INFO_MODEL, 2},
-        {VehicleProperty::INFO_MODEL_YEAR, 2},
-        {VehicleProperty::INFO_FUEL_CAPACITY, 2},
-        {VehicleProperty::INFO_FUEL_TYPE, 2},
-        {VehicleProperty::INFO_EV_BATTERY_CAPACITY, 2},
-        {VehicleProperty::INFO_EV_CONNECTOR_TYPE, 2},
-        {VehicleProperty::INFO_FUEL_DOOR_LOCATION, 2},
-        {VehicleProperty::INFO_EV_PORT_LOCATION, 2},
-        {VehicleProperty::INFO_DRIVER_SEAT, 2},
-        {VehicleProperty::INFO_EXTERIOR_DIMENSIONS, 2},
-        {VehicleProperty::INFO_MULTI_EV_PORT_LOCATIONS, 2},
-        {VehicleProperty::PERF_ODOMETER, 2},
-        {VehicleProperty::PERF_VEHICLE_SPEED, 2},
-        {VehicleProperty::PERF_VEHICLE_SPEED_DISPLAY, 2},
-        {VehicleProperty::PERF_STEERING_ANGLE, 2},
-        {VehicleProperty::PERF_REAR_STEERING_ANGLE, 2},
-        {VehicleProperty::ENGINE_COOLANT_TEMP, 2},
-        {VehicleProperty::ENGINE_OIL_LEVEL, 2},
-        {VehicleProperty::ENGINE_OIL_TEMP, 2},
-        {VehicleProperty::ENGINE_RPM, 2},
-        {VehicleProperty::WHEEL_TICK, 2},
-        {VehicleProperty::FUEL_LEVEL, 2},
-        {VehicleProperty::FUEL_DOOR_OPEN, 2},
-        {VehicleProperty::EV_BATTERY_LEVEL, 2},
+        {VehicleProperty::INFO_VIN, 1},
+        {VehicleProperty::INFO_MAKE, 1},
+        {VehicleProperty::INFO_MODEL, 1},
+        {VehicleProperty::INFO_MODEL_YEAR, 1},
+        {VehicleProperty::INFO_FUEL_CAPACITY, 1},
+        {VehicleProperty::INFO_FUEL_TYPE, 1},
+        {VehicleProperty::INFO_EV_BATTERY_CAPACITY, 1},
+        {VehicleProperty::INFO_EV_CONNECTOR_TYPE, 1},
+        {VehicleProperty::INFO_FUEL_DOOR_LOCATION, 1},
+        {VehicleProperty::INFO_EV_PORT_LOCATION, 1},
+        {VehicleProperty::INFO_DRIVER_SEAT, 1},
+        {VehicleProperty::INFO_EXTERIOR_DIMENSIONS, 1},
+        {VehicleProperty::INFO_MULTI_EV_PORT_LOCATIONS, 1},
+        {VehicleProperty::PERF_ODOMETER, 1},
+        {VehicleProperty::PERF_VEHICLE_SPEED, 1},
+        {VehicleProperty::PERF_VEHICLE_SPEED_DISPLAY, 1},
+        {VehicleProperty::PERF_STEERING_ANGLE, 1},
+        {VehicleProperty::PERF_REAR_STEERING_ANGLE, 1},
+        {VehicleProperty::ENGINE_COOLANT_TEMP, 1},
+        {VehicleProperty::ENGINE_OIL_LEVEL, 1},
+        {VehicleProperty::ENGINE_OIL_TEMP, 1},
+        {VehicleProperty::ENGINE_RPM, 1},
+        {VehicleProperty::WHEEL_TICK, 1},
+        {VehicleProperty::FUEL_LEVEL, 1},
+        {VehicleProperty::FUEL_DOOR_OPEN, 1},
+        {VehicleProperty::EV_BATTERY_LEVEL, 1},
         {VehicleProperty::EV_CURRENT_BATTERY_CAPACITY, 2},
-        {VehicleProperty::EV_CHARGE_PORT_OPEN, 2},
-        {VehicleProperty::EV_CHARGE_PORT_CONNECTED, 2},
-        {VehicleProperty::EV_BATTERY_INSTANTANEOUS_CHARGE_RATE, 2},
-        {VehicleProperty::RANGE_REMAINING, 2},
+        {VehicleProperty::EV_CHARGE_PORT_OPEN, 1},
+        {VehicleProperty::EV_CHARGE_PORT_CONNECTED, 1},
+        {VehicleProperty::EV_BATTERY_INSTANTANEOUS_CHARGE_RATE, 1},
+        {VehicleProperty::RANGE_REMAINING, 1},
         {VehicleProperty::EV_BATTERY_AVERAGE_TEMPERATURE, 3},
-        {VehicleProperty::TIRE_PRESSURE, 2},
-        {VehicleProperty::CRITICALLY_LOW_TIRE_PRESSURE, 2},
+        {VehicleProperty::TIRE_PRESSURE, 1},
+        {VehicleProperty::CRITICALLY_LOW_TIRE_PRESSURE, 1},
         {VehicleProperty::ENGINE_IDLE_AUTO_STOP_ENABLED, 2},
         {VehicleProperty::IMPACT_DETECTED, 3},
-        {VehicleProperty::GEAR_SELECTION, 2},
-        {VehicleProperty::CURRENT_GEAR, 2},
-        {VehicleProperty::PARKING_BRAKE_ON, 2},
-        {VehicleProperty::PARKING_BRAKE_AUTO_APPLY, 2},
+        {VehicleProperty::GEAR_SELECTION, 1},
+        {VehicleProperty::CURRENT_GEAR, 1},
+        {VehicleProperty::PARKING_BRAKE_ON, 1},
+        {VehicleProperty::PARKING_BRAKE_AUTO_APPLY, 1},
         {VehicleProperty::EV_BRAKE_REGENERATION_LEVEL, 2},
-        {VehicleProperty::FUEL_LEVEL_LOW, 2},
-        {VehicleProperty::NIGHT_MODE, 2},
-        {VehicleProperty::TURN_SIGNAL_STATE, 2},
-        {VehicleProperty::IGNITION_STATE, 2},
-        {VehicleProperty::ABS_ACTIVE, 2},
-        {VehicleProperty::TRACTION_CONTROL_ACTIVE, 2},
+        {VehicleProperty::FUEL_LEVEL_LOW, 1},
+        {VehicleProperty::NIGHT_MODE, 1},
+        {VehicleProperty::TURN_SIGNAL_STATE, 1},
+        {VehicleProperty::IGNITION_STATE, 1},
+        {VehicleProperty::ABS_ACTIVE, 1},
+        {VehicleProperty::TRACTION_CONTROL_ACTIVE, 1},
         {VehicleProperty::EV_STOPPING_MODE, 2},
         {VehicleProperty::ELECTRONIC_STABILITY_CONTROL_ENABLED, 3},
         {VehicleProperty::ELECTRONIC_STABILITY_CONTROL_STATE, 3},
-        {VehicleProperty::HVAC_FAN_SPEED, 2},
-        {VehicleProperty::HVAC_FAN_DIRECTION, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_CURRENT, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_SET, 2},
-        {VehicleProperty::HVAC_DEFROSTER, 2},
-        {VehicleProperty::HVAC_AC_ON, 2},
-        {VehicleProperty::HVAC_MAX_AC_ON, 2},
-        {VehicleProperty::HVAC_MAX_DEFROST_ON, 2},
-        {VehicleProperty::HVAC_RECIRC_ON, 2},
-        {VehicleProperty::HVAC_DUAL_ON, 2},
-        {VehicleProperty::HVAC_AUTO_ON, 2},
-        {VehicleProperty::HVAC_SEAT_TEMPERATURE, 2},
-        {VehicleProperty::HVAC_SIDE_MIRROR_HEAT, 2},
-        {VehicleProperty::HVAC_STEERING_WHEEL_HEAT, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_DISPLAY_UNITS, 2},
-        {VehicleProperty::HVAC_ACTUAL_FAN_SPEED_RPM, 2},
-        {VehicleProperty::HVAC_POWER_ON, 2},
-        {VehicleProperty::HVAC_FAN_DIRECTION_AVAILABLE, 2},
-        {VehicleProperty::HVAC_AUTO_RECIRC_ON, 2},
-        {VehicleProperty::HVAC_SEAT_VENTILATION, 2},
-        {VehicleProperty::HVAC_ELECTRIC_DEFROSTER_ON, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_VALUE_SUGGESTION, 2},
-        {VehicleProperty::DISTANCE_DISPLAY_UNITS, 2},
-        {VehicleProperty::FUEL_VOLUME_DISPLAY_UNITS, 2},
-        {VehicleProperty::TIRE_PRESSURE_DISPLAY_UNITS, 2},
-        {VehicleProperty::EV_BATTERY_DISPLAY_UNITS, 2},
-        {VehicleProperty::FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME, 2},
-        {VehicleProperty::VEHICLE_SPEED_DISPLAY_UNITS, 2},
-        {VehicleProperty::EXTERNAL_CAR_TIME, 2},
-        {VehicleProperty::ANDROID_EPOCH_TIME, 2},
-        {VehicleProperty::STORAGE_ENCRYPTION_BINDING_SEED, 2},
-        {VehicleProperty::ENV_OUTSIDE_TEMPERATURE, 2},
-        {VehicleProperty::AP_POWER_STATE_REQ, 2},
-        {VehicleProperty::AP_POWER_STATE_REPORT, 2},
-        {VehicleProperty::AP_POWER_BOOTUP_REASON, 2},
-        {VehicleProperty::DISPLAY_BRIGHTNESS, 2},
+        {VehicleProperty::HVAC_FAN_SPEED, 1},
+        {VehicleProperty::HVAC_FAN_DIRECTION, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_CURRENT, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_SET, 1},
+        {VehicleProperty::HVAC_DEFROSTER, 1},
+        {VehicleProperty::HVAC_AC_ON, 1},
+        {VehicleProperty::HVAC_MAX_AC_ON, 1},
+        {VehicleProperty::HVAC_MAX_DEFROST_ON, 1},
+        {VehicleProperty::HVAC_RECIRC_ON, 1},
+        {VehicleProperty::HVAC_DUAL_ON, 1},
+        {VehicleProperty::HVAC_AUTO_ON, 1},
+        {VehicleProperty::HVAC_SEAT_TEMPERATURE, 1},
+        {VehicleProperty::HVAC_SIDE_MIRROR_HEAT, 1},
+        {VehicleProperty::HVAC_STEERING_WHEEL_HEAT, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_DISPLAY_UNITS, 1},
+        {VehicleProperty::HVAC_ACTUAL_FAN_SPEED_RPM, 1},
+        {VehicleProperty::HVAC_POWER_ON, 1},
+        {VehicleProperty::HVAC_FAN_DIRECTION_AVAILABLE, 1},
+        {VehicleProperty::HVAC_AUTO_RECIRC_ON, 1},
+        {VehicleProperty::HVAC_SEAT_VENTILATION, 1},
+        {VehicleProperty::HVAC_ELECTRIC_DEFROSTER_ON, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_VALUE_SUGGESTION, 1},
+        {VehicleProperty::DISTANCE_DISPLAY_UNITS, 1},
+        {VehicleProperty::FUEL_VOLUME_DISPLAY_UNITS, 1},
+        {VehicleProperty::TIRE_PRESSURE_DISPLAY_UNITS, 1},
+        {VehicleProperty::EV_BATTERY_DISPLAY_UNITS, 1},
+        {VehicleProperty::FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME, 1},
+        {VehicleProperty::VEHICLE_SPEED_DISPLAY_UNITS, 1},
+        {VehicleProperty::EXTERNAL_CAR_TIME, 1},
+        {VehicleProperty::ANDROID_EPOCH_TIME, 1},
+        {VehicleProperty::STORAGE_ENCRYPTION_BINDING_SEED, 1},
+        {VehicleProperty::ENV_OUTSIDE_TEMPERATURE, 1},
+        {VehicleProperty::AP_POWER_STATE_REQ, 1},
+        {VehicleProperty::AP_POWER_STATE_REPORT, 1},
+        {VehicleProperty::AP_POWER_BOOTUP_REASON, 1},
+        {VehicleProperty::DISPLAY_BRIGHTNESS, 1},
         {VehicleProperty::PER_DISPLAY_BRIGHTNESS, 2},
         {VehicleProperty::VALET_MODE_ENABLED, 3},
         {VehicleProperty::HEAD_UP_DISPLAY_ENABLED, 3},
-        {VehicleProperty::HW_KEY_INPUT, 2},
+        {VehicleProperty::HW_KEY_INPUT, 1},
         {VehicleProperty::HW_KEY_INPUT_V2, 2},
         {VehicleProperty::HW_MOTION_INPUT, 2},
-        {VehicleProperty::HW_ROTARY_INPUT, 2},
-        {VehicleProperty::HW_CUSTOM_INPUT, 2},
-        {VehicleProperty::DOOR_POS, 2},
-        {VehicleProperty::DOOR_MOVE, 2},
-        {VehicleProperty::DOOR_LOCK, 2},
+        {VehicleProperty::HW_ROTARY_INPUT, 1},
+        {VehicleProperty::HW_CUSTOM_INPUT, 1},
+        {VehicleProperty::DOOR_POS, 1},
+        {VehicleProperty::DOOR_MOVE, 1},
+        {VehicleProperty::DOOR_LOCK, 1},
         {VehicleProperty::DOOR_CHILD_LOCK_ENABLED, 2},
-        {VehicleProperty::MIRROR_Z_POS, 2},
-        {VehicleProperty::MIRROR_Z_MOVE, 2},
-        {VehicleProperty::MIRROR_Y_POS, 2},
-        {VehicleProperty::MIRROR_Y_MOVE, 2},
-        {VehicleProperty::MIRROR_LOCK, 2},
-        {VehicleProperty::MIRROR_FOLD, 2},
+        {VehicleProperty::MIRROR_Z_POS, 1},
+        {VehicleProperty::MIRROR_Z_MOVE, 1},
+        {VehicleProperty::MIRROR_Y_POS, 1},
+        {VehicleProperty::MIRROR_Y_MOVE, 1},
+        {VehicleProperty::MIRROR_LOCK, 1},
+        {VehicleProperty::MIRROR_FOLD, 1},
         {VehicleProperty::MIRROR_AUTO_FOLD_ENABLED, 2},
         {VehicleProperty::MIRROR_AUTO_TILT_ENABLED, 2},
-        {VehicleProperty::SEAT_MEMORY_SELECT, 2},
-        {VehicleProperty::SEAT_MEMORY_SET, 2},
-        {VehicleProperty::SEAT_BELT_BUCKLED, 2},
-        {VehicleProperty::SEAT_BELT_HEIGHT_POS, 2},
-        {VehicleProperty::SEAT_BELT_HEIGHT_MOVE, 2},
-        {VehicleProperty::SEAT_FORE_AFT_POS, 2},
-        {VehicleProperty::SEAT_FORE_AFT_MOVE, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_1_POS, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_1_MOVE, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_2_POS, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_2_MOVE, 2},
-        {VehicleProperty::SEAT_HEIGHT_POS, 2},
-        {VehicleProperty::SEAT_HEIGHT_MOVE, 2},
-        {VehicleProperty::SEAT_DEPTH_POS, 2},
-        {VehicleProperty::SEAT_DEPTH_MOVE, 2},
-        {VehicleProperty::SEAT_TILT_POS, 2},
-        {VehicleProperty::SEAT_TILT_MOVE, 2},
-        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_POS, 2},
-        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_MOVE, 2},
-        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_POS, 2},
-        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_MOVE, 2},
-        {VehicleProperty::SEAT_HEADREST_HEIGHT_POS, 2},
+        {VehicleProperty::SEAT_MEMORY_SELECT, 1},
+        {VehicleProperty::SEAT_MEMORY_SET, 1},
+        {VehicleProperty::SEAT_BELT_BUCKLED, 1},
+        {VehicleProperty::SEAT_BELT_HEIGHT_POS, 1},
+        {VehicleProperty::SEAT_BELT_HEIGHT_MOVE, 1},
+        {VehicleProperty::SEAT_FORE_AFT_POS, 1},
+        {VehicleProperty::SEAT_FORE_AFT_MOVE, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_1_POS, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_1_MOVE, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_1_POS, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_1_MOVE, 1},
+        {VehicleProperty::SEAT_HEIGHT_POS, 1},
+        {VehicleProperty::SEAT_HEIGHT_MOVE, 1},
+        {VehicleProperty::SEAT_DEPTH_POS, 1},
+        {VehicleProperty::SEAT_DEPTH_MOVE, 1},
+        {VehicleProperty::SEAT_TILT_POS, 1},
+        {VehicleProperty::SEAT_TILT_MOVE, 1},
+        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_POS, 1},
+        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_MOVE, 1},
+        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_POS, 1},
+        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_MOVE, 1},
+        {VehicleProperty::SEAT_HEADREST_HEIGHT_POS, 1},
         {VehicleProperty::SEAT_HEADREST_HEIGHT_POS_V2, 2},
-        {VehicleProperty::SEAT_HEADREST_HEIGHT_MOVE, 2},
-        {VehicleProperty::SEAT_HEADREST_ANGLE_POS, 2},
-        {VehicleProperty::SEAT_HEADREST_ANGLE_MOVE, 2},
-        {VehicleProperty::SEAT_HEADREST_FORE_AFT_POS, 2},
-        {VehicleProperty::SEAT_HEADREST_FORE_AFT_MOVE, 2},
+        {VehicleProperty::SEAT_HEADREST_HEIGHT_MOVE, 1},
+        {VehicleProperty::SEAT_HEADREST_ANGLE_POS, 1},
+        {VehicleProperty::SEAT_HEADREST_ANGLE_MOVE, 1},
+        {VehicleProperty::SEAT_HEADREST_FORE_AFT_POS, 1},
+        {VehicleProperty::SEAT_HEADREST_FORE_AFT_MOVE, 1},
         {VehicleProperty::SEAT_FOOTWELL_LIGHTS_STATE, 2},
         {VehicleProperty::SEAT_FOOTWELL_LIGHTS_SWITCH, 2},
         {VehicleProperty::SEAT_EASY_ACCESS_ENABLED, 2},
@@ -184,10 +184,10 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::SEAT_LUMBAR_VERTICAL_MOVE, 2},
         {VehicleProperty::SEAT_WALK_IN_POS, 2},
         {VehicleProperty::SEAT_BELT_PRETENSIONER_DEPLOYED, 3},
-        {VehicleProperty::SEAT_OCCUPANCY, 2},
-        {VehicleProperty::WINDOW_POS, 2},
-        {VehicleProperty::WINDOW_MOVE, 2},
-        {VehicleProperty::WINDOW_LOCK, 2},
+        {VehicleProperty::SEAT_OCCUPANCY, 1},
+        {VehicleProperty::WINDOW_POS, 1},
+        {VehicleProperty::WINDOW_MOVE, 1},
+        {VehicleProperty::WINDOW_LOCK, 1},
         {VehicleProperty::WINDSHIELD_WIPERS_PERIOD, 2},
         {VehicleProperty::WINDSHIELD_WIPERS_STATE, 2},
         {VehicleProperty::WINDSHIELD_WIPERS_SWITCH, 2},
@@ -200,7 +200,7 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::STEERING_WHEEL_EASY_ACCESS_ENABLED, 2},
         {VehicleProperty::GLOVE_BOX_DOOR_POS, 2},
         {VehicleProperty::GLOVE_BOX_LOCKED, 2},
-        {VehicleProperty::VEHICLE_MAP_SERVICE, 2},
+        {VehicleProperty::VEHICLE_MAP_SERVICE, 1},
         {VehicleProperty::LOCATION_CHARACTERIZATION, 2},
         {VehicleProperty::ULTRASONICS_SENSOR_POSITION, 3},
         {VehicleProperty::ULTRASONICS_SENSOR_ORIENTATION, 3},
@@ -208,57 +208,57 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::ULTRASONICS_SENSOR_DETECTION_RANGE, 3},
         {VehicleProperty::ULTRASONICS_SENSOR_SUPPORTED_RANGES, 3},
         {VehicleProperty::ULTRASONICS_SENSOR_MEASURED_DISTANCE, 3},
-        {VehicleProperty::OBD2_LIVE_FRAME, 2},
-        {VehicleProperty::OBD2_FREEZE_FRAME, 2},
-        {VehicleProperty::OBD2_FREEZE_FRAME_INFO, 2},
-        {VehicleProperty::OBD2_FREEZE_FRAME_CLEAR, 2},
-        {VehicleProperty::HEADLIGHTS_STATE, 2},
-        {VehicleProperty::HIGH_BEAM_LIGHTS_STATE, 2},
-        {VehicleProperty::FOG_LIGHTS_STATE, 2},
-        {VehicleProperty::HAZARD_LIGHTS_STATE, 2},
-        {VehicleProperty::HEADLIGHTS_SWITCH, 2},
-        {VehicleProperty::HIGH_BEAM_LIGHTS_SWITCH, 2},
-        {VehicleProperty::FOG_LIGHTS_SWITCH, 2},
-        {VehicleProperty::HAZARD_LIGHTS_SWITCH, 2},
-        {VehicleProperty::CABIN_LIGHTS_STATE, 2},
-        {VehicleProperty::CABIN_LIGHTS_SWITCH, 2},
-        {VehicleProperty::READING_LIGHTS_STATE, 2},
-        {VehicleProperty::READING_LIGHTS_SWITCH, 2},
+        {VehicleProperty::OBD2_LIVE_FRAME, 1},
+        {VehicleProperty::OBD2_FREEZE_FRAME, 1},
+        {VehicleProperty::OBD2_FREEZE_FRAME_INFO, 1},
+        {VehicleProperty::OBD2_FREEZE_FRAME_CLEAR, 1},
+        {VehicleProperty::HEADLIGHTS_STATE, 1},
+        {VehicleProperty::HIGH_BEAM_LIGHTS_STATE, 1},
+        {VehicleProperty::FOG_LIGHTS_STATE, 1},
+        {VehicleProperty::HAZARD_LIGHTS_STATE, 1},
+        {VehicleProperty::HEADLIGHTS_SWITCH, 1},
+        {VehicleProperty::HIGH_BEAM_LIGHTS_SWITCH, 1},
+        {VehicleProperty::FOG_LIGHTS_SWITCH, 1},
+        {VehicleProperty::HAZARD_LIGHTS_SWITCH, 1},
+        {VehicleProperty::CABIN_LIGHTS_STATE, 1},
+        {VehicleProperty::CABIN_LIGHTS_SWITCH, 1},
+        {VehicleProperty::READING_LIGHTS_STATE, 1},
+        {VehicleProperty::READING_LIGHTS_SWITCH, 1},
         {VehicleProperty::STEERING_WHEEL_LIGHTS_STATE, 2},
         {VehicleProperty::STEERING_WHEEL_LIGHTS_SWITCH, 2},
-        {VehicleProperty::SUPPORT_CUSTOMIZE_VENDOR_PERMISSION, 2},
-        {VehicleProperty::DISABLED_OPTIONAL_FEATURES, 2},
-        {VehicleProperty::INITIAL_USER_INFO, 2},
-        {VehicleProperty::SWITCH_USER, 2},
-        {VehicleProperty::CREATE_USER, 2},
-        {VehicleProperty::REMOVE_USER, 2},
-        {VehicleProperty::USER_IDENTIFICATION_ASSOCIATION, 2},
-        {VehicleProperty::EVS_SERVICE_REQUEST, 2},
-        {VehicleProperty::POWER_POLICY_REQ, 2},
-        {VehicleProperty::POWER_POLICY_GROUP_REQ, 2},
-        {VehicleProperty::CURRENT_POWER_POLICY, 2},
-        {VehicleProperty::WATCHDOG_ALIVE, 2},
-        {VehicleProperty::WATCHDOG_TERMINATED_PROCESS, 2},
-        {VehicleProperty::VHAL_HEARTBEAT, 2},
-        {VehicleProperty::CLUSTER_SWITCH_UI, 2},
-        {VehicleProperty::CLUSTER_DISPLAY_STATE, 2},
-        {VehicleProperty::CLUSTER_REPORT_STATE, 2},
-        {VehicleProperty::CLUSTER_REQUEST_DISPLAY, 2},
-        {VehicleProperty::CLUSTER_NAVIGATION_STATE, 2},
-        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_TYPE, 2},
-        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_STATUS, 2},
-        {VehicleProperty::FRONT_FOG_LIGHTS_STATE, 2},
-        {VehicleProperty::FRONT_FOG_LIGHTS_SWITCH, 2},
-        {VehicleProperty::REAR_FOG_LIGHTS_STATE, 2},
-        {VehicleProperty::REAR_FOG_LIGHTS_SWITCH, 2},
-        {VehicleProperty::EV_CHARGE_CURRENT_DRAW_LIMIT, 2},
-        {VehicleProperty::EV_CHARGE_PERCENT_LIMIT, 2},
-        {VehicleProperty::EV_CHARGE_STATE, 2},
-        {VehicleProperty::EV_CHARGE_SWITCH, 2},
-        {VehicleProperty::EV_CHARGE_TIME_REMAINING, 2},
-        {VehicleProperty::EV_REGENERATIVE_BRAKING_STATE, 2},
-        {VehicleProperty::TRAILER_PRESENT, 2},
-        {VehicleProperty::VEHICLE_CURB_WEIGHT, 2},
+        {VehicleProperty::SUPPORT_CUSTOMIZE_VENDOR_PERMISSION, 1},
+        {VehicleProperty::DISABLED_OPTIONAL_FEATURES, 1},
+        {VehicleProperty::INITIAL_USER_INFO, 1},
+        {VehicleProperty::SWITCH_USER, 1},
+        {VehicleProperty::CREATE_USER, 1},
+        {VehicleProperty::REMOVE_USER, 1},
+        {VehicleProperty::USER_IDENTIFICATION_ASSOCIATION, 1},
+        {VehicleProperty::EVS_SERVICE_REQUEST, 1},
+        {VehicleProperty::POWER_POLICY_REQ, 1},
+        {VehicleProperty::POWER_POLICY_GROUP_REQ, 1},
+        {VehicleProperty::CURRENT_POWER_POLICY, 1},
+        {VehicleProperty::WATCHDOG_ALIVE, 1},
+        {VehicleProperty::WATCHDOG_TERMINATED_PROCESS, 1},
+        {VehicleProperty::VHAL_HEARTBEAT, 1},
+        {VehicleProperty::CLUSTER_SWITCH_UI, 1},
+        {VehicleProperty::CLUSTER_DISPLAY_STATE, 1},
+        {VehicleProperty::CLUSTER_REPORT_STATE, 1},
+        {VehicleProperty::CLUSTER_REQUEST_DISPLAY, 1},
+        {VehicleProperty::CLUSTER_NAVIGATION_STATE, 1},
+        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_TYPE, 1},
+        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_STATUS, 1},
+        {VehicleProperty::FRONT_FOG_LIGHTS_STATE, 1},
+        {VehicleProperty::FRONT_FOG_LIGHTS_SWITCH, 1},
+        {VehicleProperty::REAR_FOG_LIGHTS_STATE, 1},
+        {VehicleProperty::REAR_FOG_LIGHTS_SWITCH, 1},
+        {VehicleProperty::EV_CHARGE_CURRENT_DRAW_LIMIT, 1},
+        {VehicleProperty::EV_CHARGE_PERCENT_LIMIT, 1},
+        {VehicleProperty::EV_CHARGE_STATE, 1},
+        {VehicleProperty::EV_CHARGE_SWITCH, 1},
+        {VehicleProperty::EV_CHARGE_TIME_REMAINING, 1},
+        {VehicleProperty::EV_REGENERATIVE_BRAKING_STATE, 1},
+        {VehicleProperty::TRAILER_PRESENT, 1},
+        {VehicleProperty::VEHICLE_CURB_WEIGHT, 1},
         {VehicleProperty::GENERAL_SAFETY_REGULATION_COMPLIANCE_REQUIREMENT, 2},
         {VehicleProperty::SUPPORTED_PROPERTY_IDS, 2},
         {VehicleProperty::SHUTDOWN_REQUEST, 2},
diff --git a/automotive/vehicle/aidl/generated_lib/4/cpp/AnnotationsForVehicleProperty.h b/automotive/vehicle/aidl/generated_lib/4/cpp/AnnotationsForVehicleProperty.h
index 5b6048a59d..575989ebc8 100644
--- a/automotive/vehicle/aidl/generated_lib/4/cpp/AnnotationsForVehicleProperty.h
+++ b/automotive/vehicle/aidl/generated_lib/4/cpp/AnnotationsForVehicleProperty.h
@@ -258,7 +258,7 @@ std::unordered_map<VehicleProperty, std::unordered_set<std::string>>
         {VehicleProperty::REAR_FOG_LIGHTS_STATE, {"access", "change_mode", "data_enum", "require_supported_values_list", "version"}},
         {VehicleProperty::REAR_FOG_LIGHTS_SWITCH, {"access", "change_mode", "data_enum", "require_supported_values_list", "version"}},
         {VehicleProperty::EV_CHARGE_CURRENT_DRAW_LIMIT, {"access", "change_mode", "unit", "version"}},
-        {VehicleProperty::EV_CHARGE_PERCENT_LIMIT, {"access", "change_mode", "legacy_supported_values_in_config", "require_supported_values_list", "version"}},
+        {VehicleProperty::EV_CHARGE_PERCENT_LIMIT, {"access", "change_mode", "legacy_supported_values_in_config", "version"}},
         {VehicleProperty::EV_CHARGE_STATE, {"access", "change_mode", "data_enum", "require_supported_values_list", "version"}},
         {VehicleProperty::EV_CHARGE_SWITCH, {"access", "change_mode", "version"}},
         {VehicleProperty::EV_CHARGE_TIME_REMAINING, {"access", "change_mode", "unit", "version"}},
diff --git a/automotive/vehicle/aidl/generated_lib/4/cpp/VersionForVehicleProperty.h b/automotive/vehicle/aidl/generated_lib/4/cpp/VersionForVehicleProperty.h
index ff69759c48..cba1c44894 100644
--- a/automotive/vehicle/aidl/generated_lib/4/cpp/VersionForVehicleProperty.h
+++ b/automotive/vehicle/aidl/generated_lib/4/cpp/VersionForVehicleProperty.h
@@ -30,44 +30,44 @@
 
 namespace aidl::android::hardware::automotive::vehicle {
 std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
-        {VehicleProperty::INFO_VIN, 2},
-        {VehicleProperty::INFO_MAKE, 2},
-        {VehicleProperty::INFO_MODEL, 2},
-        {VehicleProperty::INFO_MODEL_YEAR, 2},
-        {VehicleProperty::INFO_FUEL_CAPACITY, 2},
-        {VehicleProperty::INFO_FUEL_TYPE, 2},
-        {VehicleProperty::INFO_EV_BATTERY_CAPACITY, 2},
-        {VehicleProperty::INFO_EV_CONNECTOR_TYPE, 2},
-        {VehicleProperty::INFO_FUEL_DOOR_LOCATION, 2},
-        {VehicleProperty::INFO_EV_PORT_LOCATION, 2},
-        {VehicleProperty::INFO_DRIVER_SEAT, 2},
-        {VehicleProperty::INFO_EXTERIOR_DIMENSIONS, 2},
-        {VehicleProperty::INFO_MULTI_EV_PORT_LOCATIONS, 2},
+        {VehicleProperty::INFO_VIN, 1},
+        {VehicleProperty::INFO_MAKE, 1},
+        {VehicleProperty::INFO_MODEL, 1},
+        {VehicleProperty::INFO_MODEL_YEAR, 1},
+        {VehicleProperty::INFO_FUEL_CAPACITY, 1},
+        {VehicleProperty::INFO_FUEL_TYPE, 1},
+        {VehicleProperty::INFO_EV_BATTERY_CAPACITY, 1},
+        {VehicleProperty::INFO_EV_CONNECTOR_TYPE, 1},
+        {VehicleProperty::INFO_FUEL_DOOR_LOCATION, 1},
+        {VehicleProperty::INFO_EV_PORT_LOCATION, 1},
+        {VehicleProperty::INFO_DRIVER_SEAT, 1},
+        {VehicleProperty::INFO_EXTERIOR_DIMENSIONS, 1},
+        {VehicleProperty::INFO_MULTI_EV_PORT_LOCATIONS, 1},
         {VehicleProperty::INFO_MODEL_TRIM, 4},
         {VehicleProperty::INFO_VEHICLE_SIZE_CLASS, 4},
-        {VehicleProperty::PERF_ODOMETER, 2},
-        {VehicleProperty::PERF_VEHICLE_SPEED, 2},
-        {VehicleProperty::PERF_VEHICLE_SPEED_DISPLAY, 2},
-        {VehicleProperty::PERF_STEERING_ANGLE, 2},
-        {VehicleProperty::PERF_REAR_STEERING_ANGLE, 2},
+        {VehicleProperty::PERF_ODOMETER, 1},
+        {VehicleProperty::PERF_VEHICLE_SPEED, 1},
+        {VehicleProperty::PERF_VEHICLE_SPEED_DISPLAY, 1},
+        {VehicleProperty::PERF_STEERING_ANGLE, 1},
+        {VehicleProperty::PERF_REAR_STEERING_ANGLE, 1},
         {VehicleProperty::INSTANTANEOUS_FUEL_ECONOMY, 4},
         {VehicleProperty::INSTANTANEOUS_EV_EFFICIENCY, 4},
-        {VehicleProperty::ENGINE_COOLANT_TEMP, 2},
-        {VehicleProperty::ENGINE_OIL_LEVEL, 2},
-        {VehicleProperty::ENGINE_OIL_TEMP, 2},
-        {VehicleProperty::ENGINE_RPM, 2},
-        {VehicleProperty::WHEEL_TICK, 2},
-        {VehicleProperty::FUEL_LEVEL, 2},
-        {VehicleProperty::FUEL_DOOR_OPEN, 2},
-        {VehicleProperty::EV_BATTERY_LEVEL, 2},
+        {VehicleProperty::ENGINE_COOLANT_TEMP, 1},
+        {VehicleProperty::ENGINE_OIL_LEVEL, 1},
+        {VehicleProperty::ENGINE_OIL_TEMP, 1},
+        {VehicleProperty::ENGINE_RPM, 1},
+        {VehicleProperty::WHEEL_TICK, 1},
+        {VehicleProperty::FUEL_LEVEL, 1},
+        {VehicleProperty::FUEL_DOOR_OPEN, 1},
+        {VehicleProperty::EV_BATTERY_LEVEL, 1},
         {VehicleProperty::EV_CURRENT_BATTERY_CAPACITY, 2},
-        {VehicleProperty::EV_CHARGE_PORT_OPEN, 2},
-        {VehicleProperty::EV_CHARGE_PORT_CONNECTED, 2},
-        {VehicleProperty::EV_BATTERY_INSTANTANEOUS_CHARGE_RATE, 2},
-        {VehicleProperty::RANGE_REMAINING, 2},
+        {VehicleProperty::EV_CHARGE_PORT_OPEN, 1},
+        {VehicleProperty::EV_CHARGE_PORT_CONNECTED, 1},
+        {VehicleProperty::EV_BATTERY_INSTANTANEOUS_CHARGE_RATE, 1},
+        {VehicleProperty::RANGE_REMAINING, 1},
         {VehicleProperty::EV_BATTERY_AVERAGE_TEMPERATURE, 3},
-        {VehicleProperty::TIRE_PRESSURE, 2},
-        {VehicleProperty::CRITICALLY_LOW_TIRE_PRESSURE, 2},
+        {VehicleProperty::TIRE_PRESSURE, 1},
+        {VehicleProperty::CRITICALLY_LOW_TIRE_PRESSURE, 1},
         {VehicleProperty::ACCELERATOR_PEDAL_COMPRESSION_PERCENTAGE, 4},
         {VehicleProperty::BRAKE_PEDAL_COMPRESSION_PERCENTAGE, 4},
         {VehicleProperty::BRAKE_PAD_WEAR_PERCENTAGE, 4},
@@ -76,106 +76,106 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::ENGINE_IDLE_AUTO_STOP_ENABLED, 2},
         {VehicleProperty::IMPACT_DETECTED, 3},
         {VehicleProperty::VEHICLE_HORN_ENGAGED, 4},
-        {VehicleProperty::GEAR_SELECTION, 2},
-        {VehicleProperty::CURRENT_GEAR, 2},
-        {VehicleProperty::PARKING_BRAKE_ON, 2},
-        {VehicleProperty::PARKING_BRAKE_AUTO_APPLY, 2},
+        {VehicleProperty::GEAR_SELECTION, 1},
+        {VehicleProperty::CURRENT_GEAR, 1},
+        {VehicleProperty::PARKING_BRAKE_ON, 1},
+        {VehicleProperty::PARKING_BRAKE_AUTO_APPLY, 1},
         {VehicleProperty::EV_BRAKE_REGENERATION_LEVEL, 2},
-        {VehicleProperty::FUEL_LEVEL_LOW, 2},
-        {VehicleProperty::NIGHT_MODE, 2},
-        {VehicleProperty::TURN_SIGNAL_STATE, 2},
-        {VehicleProperty::IGNITION_STATE, 2},
-        {VehicleProperty::ABS_ACTIVE, 2},
-        {VehicleProperty::TRACTION_CONTROL_ACTIVE, 2},
+        {VehicleProperty::FUEL_LEVEL_LOW, 1},
+        {VehicleProperty::NIGHT_MODE, 1},
+        {VehicleProperty::TURN_SIGNAL_STATE, 1},
+        {VehicleProperty::IGNITION_STATE, 1},
+        {VehicleProperty::ABS_ACTIVE, 1},
+        {VehicleProperty::TRACTION_CONTROL_ACTIVE, 1},
         {VehicleProperty::EV_STOPPING_MODE, 2},
         {VehicleProperty::ELECTRONIC_STABILITY_CONTROL_ENABLED, 3},
         {VehicleProperty::ELECTRONIC_STABILITY_CONTROL_STATE, 3},
         {VehicleProperty::TURN_SIGNAL_LIGHT_STATE, 4},
         {VehicleProperty::TURN_SIGNAL_SWITCH, 4},
-        {VehicleProperty::HVAC_FAN_SPEED, 2},
-        {VehicleProperty::HVAC_FAN_DIRECTION, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_CURRENT, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_SET, 2},
-        {VehicleProperty::HVAC_DEFROSTER, 2},
-        {VehicleProperty::HVAC_AC_ON, 2},
-        {VehicleProperty::HVAC_MAX_AC_ON, 2},
-        {VehicleProperty::HVAC_MAX_DEFROST_ON, 2},
-        {VehicleProperty::HVAC_RECIRC_ON, 2},
-        {VehicleProperty::HVAC_DUAL_ON, 2},
-        {VehicleProperty::HVAC_AUTO_ON, 2},
-        {VehicleProperty::HVAC_SEAT_TEMPERATURE, 2},
-        {VehicleProperty::HVAC_SIDE_MIRROR_HEAT, 2},
-        {VehicleProperty::HVAC_STEERING_WHEEL_HEAT, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_DISPLAY_UNITS, 2},
-        {VehicleProperty::HVAC_ACTUAL_FAN_SPEED_RPM, 2},
-        {VehicleProperty::HVAC_POWER_ON, 2},
-        {VehicleProperty::HVAC_FAN_DIRECTION_AVAILABLE, 2},
-        {VehicleProperty::HVAC_AUTO_RECIRC_ON, 2},
-        {VehicleProperty::HVAC_SEAT_VENTILATION, 2},
-        {VehicleProperty::HVAC_ELECTRIC_DEFROSTER_ON, 2},
-        {VehicleProperty::HVAC_TEMPERATURE_VALUE_SUGGESTION, 2},
-        {VehicleProperty::DISTANCE_DISPLAY_UNITS, 2},
-        {VehicleProperty::FUEL_VOLUME_DISPLAY_UNITS, 2},
-        {VehicleProperty::TIRE_PRESSURE_DISPLAY_UNITS, 2},
-        {VehicleProperty::EV_BATTERY_DISPLAY_UNITS, 2},
-        {VehicleProperty::FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME, 2},
-        {VehicleProperty::VEHICLE_SPEED_DISPLAY_UNITS, 2},
-        {VehicleProperty::EXTERNAL_CAR_TIME, 2},
-        {VehicleProperty::ANDROID_EPOCH_TIME, 2},
-        {VehicleProperty::STORAGE_ENCRYPTION_BINDING_SEED, 2},
-        {VehicleProperty::ENV_OUTSIDE_TEMPERATURE, 2},
-        {VehicleProperty::AP_POWER_STATE_REQ, 2},
-        {VehicleProperty::AP_POWER_STATE_REPORT, 2},
-        {VehicleProperty::AP_POWER_BOOTUP_REASON, 2},
-        {VehicleProperty::DISPLAY_BRIGHTNESS, 2},
+        {VehicleProperty::HVAC_FAN_SPEED, 1},
+        {VehicleProperty::HVAC_FAN_DIRECTION, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_CURRENT, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_SET, 1},
+        {VehicleProperty::HVAC_DEFROSTER, 1},
+        {VehicleProperty::HVAC_AC_ON, 1},
+        {VehicleProperty::HVAC_MAX_AC_ON, 1},
+        {VehicleProperty::HVAC_MAX_DEFROST_ON, 1},
+        {VehicleProperty::HVAC_RECIRC_ON, 1},
+        {VehicleProperty::HVAC_DUAL_ON, 1},
+        {VehicleProperty::HVAC_AUTO_ON, 1},
+        {VehicleProperty::HVAC_SEAT_TEMPERATURE, 1},
+        {VehicleProperty::HVAC_SIDE_MIRROR_HEAT, 1},
+        {VehicleProperty::HVAC_STEERING_WHEEL_HEAT, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_DISPLAY_UNITS, 1},
+        {VehicleProperty::HVAC_ACTUAL_FAN_SPEED_RPM, 1},
+        {VehicleProperty::HVAC_POWER_ON, 1},
+        {VehicleProperty::HVAC_FAN_DIRECTION_AVAILABLE, 1},
+        {VehicleProperty::HVAC_AUTO_RECIRC_ON, 1},
+        {VehicleProperty::HVAC_SEAT_VENTILATION, 1},
+        {VehicleProperty::HVAC_ELECTRIC_DEFROSTER_ON, 1},
+        {VehicleProperty::HVAC_TEMPERATURE_VALUE_SUGGESTION, 1},
+        {VehicleProperty::DISTANCE_DISPLAY_UNITS, 1},
+        {VehicleProperty::FUEL_VOLUME_DISPLAY_UNITS, 1},
+        {VehicleProperty::TIRE_PRESSURE_DISPLAY_UNITS, 1},
+        {VehicleProperty::EV_BATTERY_DISPLAY_UNITS, 1},
+        {VehicleProperty::FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME, 1},
+        {VehicleProperty::VEHICLE_SPEED_DISPLAY_UNITS, 1},
+        {VehicleProperty::EXTERNAL_CAR_TIME, 1},
+        {VehicleProperty::ANDROID_EPOCH_TIME, 1},
+        {VehicleProperty::STORAGE_ENCRYPTION_BINDING_SEED, 1},
+        {VehicleProperty::ENV_OUTSIDE_TEMPERATURE, 1},
+        {VehicleProperty::AP_POWER_STATE_REQ, 1},
+        {VehicleProperty::AP_POWER_STATE_REPORT, 1},
+        {VehicleProperty::AP_POWER_BOOTUP_REASON, 1},
+        {VehicleProperty::DISPLAY_BRIGHTNESS, 1},
         {VehicleProperty::PER_DISPLAY_BRIGHTNESS, 2},
         {VehicleProperty::VALET_MODE_ENABLED, 3},
         {VehicleProperty::HEAD_UP_DISPLAY_ENABLED, 3},
-        {VehicleProperty::HW_KEY_INPUT, 2},
+        {VehicleProperty::HW_KEY_INPUT, 1},
         {VehicleProperty::HW_KEY_INPUT_V2, 2},
         {VehicleProperty::HW_MOTION_INPUT, 2},
-        {VehicleProperty::HW_ROTARY_INPUT, 2},
-        {VehicleProperty::HW_CUSTOM_INPUT, 2},
-        {VehicleProperty::DOOR_POS, 2},
-        {VehicleProperty::DOOR_MOVE, 2},
-        {VehicleProperty::DOOR_LOCK, 2},
+        {VehicleProperty::HW_ROTARY_INPUT, 1},
+        {VehicleProperty::HW_CUSTOM_INPUT, 1},
+        {VehicleProperty::DOOR_POS, 1},
+        {VehicleProperty::DOOR_MOVE, 1},
+        {VehicleProperty::DOOR_LOCK, 1},
         {VehicleProperty::DOOR_CHILD_LOCK_ENABLED, 2},
-        {VehicleProperty::MIRROR_Z_POS, 2},
-        {VehicleProperty::MIRROR_Z_MOVE, 2},
-        {VehicleProperty::MIRROR_Y_POS, 2},
-        {VehicleProperty::MIRROR_Y_MOVE, 2},
-        {VehicleProperty::MIRROR_LOCK, 2},
-        {VehicleProperty::MIRROR_FOLD, 2},
+        {VehicleProperty::MIRROR_Z_POS, 1},
+        {VehicleProperty::MIRROR_Z_MOVE, 1},
+        {VehicleProperty::MIRROR_Y_POS, 1},
+        {VehicleProperty::MIRROR_Y_MOVE, 1},
+        {VehicleProperty::MIRROR_LOCK, 1},
+        {VehicleProperty::MIRROR_FOLD, 1},
         {VehicleProperty::MIRROR_AUTO_FOLD_ENABLED, 2},
         {VehicleProperty::MIRROR_AUTO_TILT_ENABLED, 2},
-        {VehicleProperty::SEAT_MEMORY_SELECT, 2},
-        {VehicleProperty::SEAT_MEMORY_SET, 2},
-        {VehicleProperty::SEAT_BELT_BUCKLED, 2},
-        {VehicleProperty::SEAT_BELT_HEIGHT_POS, 2},
-        {VehicleProperty::SEAT_BELT_HEIGHT_MOVE, 2},
-        {VehicleProperty::SEAT_FORE_AFT_POS, 2},
-        {VehicleProperty::SEAT_FORE_AFT_MOVE, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_1_POS, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_1_MOVE, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_2_POS, 2},
-        {VehicleProperty::SEAT_BACKREST_ANGLE_2_MOVE, 2},
-        {VehicleProperty::SEAT_HEIGHT_POS, 2},
-        {VehicleProperty::SEAT_HEIGHT_MOVE, 2},
-        {VehicleProperty::SEAT_DEPTH_POS, 2},
-        {VehicleProperty::SEAT_DEPTH_MOVE, 2},
-        {VehicleProperty::SEAT_TILT_POS, 2},
-        {VehicleProperty::SEAT_TILT_MOVE, 2},
-        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_POS, 2},
-        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_MOVE, 2},
-        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_POS, 2},
-        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_MOVE, 2},
-        {VehicleProperty::SEAT_HEADREST_HEIGHT_POS, 2},
+        {VehicleProperty::SEAT_MEMORY_SELECT, 1},
+        {VehicleProperty::SEAT_MEMORY_SET, 1},
+        {VehicleProperty::SEAT_BELT_BUCKLED, 1},
+        {VehicleProperty::SEAT_BELT_HEIGHT_POS, 1},
+        {VehicleProperty::SEAT_BELT_HEIGHT_MOVE, 1},
+        {VehicleProperty::SEAT_FORE_AFT_POS, 1},
+        {VehicleProperty::SEAT_FORE_AFT_MOVE, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_1_POS, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_1_MOVE, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_2_POS, 1},
+        {VehicleProperty::SEAT_BACKREST_ANGLE_2_MOVE, 1},
+        {VehicleProperty::SEAT_HEIGHT_POS, 1},
+        {VehicleProperty::SEAT_HEIGHT_MOVE, 1},
+        {VehicleProperty::SEAT_DEPTH_POS, 1},
+        {VehicleProperty::SEAT_DEPTH_MOVE, 1},
+        {VehicleProperty::SEAT_TILT_POS, 1},
+        {VehicleProperty::SEAT_TILT_MOVE, 1},
+        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_POS, 1},
+        {VehicleProperty::SEAT_LUMBAR_FORE_AFT_MOVE, 1},
+        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_POS, 1},
+        {VehicleProperty::SEAT_LUMBAR_SIDE_SUPPORT_MOVE, 1},
+        {VehicleProperty::SEAT_HEADREST_HEIGHT_POS, 1},
         {VehicleProperty::SEAT_HEADREST_HEIGHT_POS_V2, 2},
-        {VehicleProperty::SEAT_HEADREST_HEIGHT_MOVE, 2},
-        {VehicleProperty::SEAT_HEADREST_ANGLE_POS, 2},
-        {VehicleProperty::SEAT_HEADREST_ANGLE_MOVE, 2},
-        {VehicleProperty::SEAT_HEADREST_FORE_AFT_POS, 2},
-        {VehicleProperty::SEAT_HEADREST_FORE_AFT_MOVE, 2},
+        {VehicleProperty::SEAT_HEADREST_HEIGHT_MOVE, 1},
+        {VehicleProperty::SEAT_HEADREST_ANGLE_POS, 1},
+        {VehicleProperty::SEAT_HEADREST_ANGLE_MOVE, 1},
+        {VehicleProperty::SEAT_HEADREST_FORE_AFT_POS, 1},
+        {VehicleProperty::SEAT_HEADREST_FORE_AFT_MOVE, 1},
         {VehicleProperty::SEAT_FOOTWELL_LIGHTS_STATE, 2},
         {VehicleProperty::SEAT_FOOTWELL_LIGHTS_SWITCH, 2},
         {VehicleProperty::SEAT_EASY_ACCESS_ENABLED, 2},
@@ -187,10 +187,10 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::SEAT_LUMBAR_VERTICAL_MOVE, 2},
         {VehicleProperty::SEAT_WALK_IN_POS, 2},
         {VehicleProperty::SEAT_BELT_PRETENSIONER_DEPLOYED, 3},
-        {VehicleProperty::SEAT_OCCUPANCY, 2},
-        {VehicleProperty::WINDOW_POS, 2},
-        {VehicleProperty::WINDOW_MOVE, 2},
-        {VehicleProperty::WINDOW_LOCK, 2},
+        {VehicleProperty::SEAT_OCCUPANCY, 1},
+        {VehicleProperty::WINDOW_POS, 1},
+        {VehicleProperty::WINDOW_MOVE, 1},
+        {VehicleProperty::WINDOW_LOCK, 1},
         {VehicleProperty::WINDSHIELD_WIPERS_PERIOD, 2},
         {VehicleProperty::WINDSHIELD_WIPERS_STATE, 2},
         {VehicleProperty::WINDSHIELD_WIPERS_SWITCH, 2},
@@ -203,7 +203,7 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::STEERING_WHEEL_EASY_ACCESS_ENABLED, 2},
         {VehicleProperty::GLOVE_BOX_DOOR_POS, 2},
         {VehicleProperty::GLOVE_BOX_LOCKED, 2},
-        {VehicleProperty::VEHICLE_MAP_SERVICE, 2},
+        {VehicleProperty::VEHICLE_MAP_SERVICE, 1},
         {VehicleProperty::LOCATION_CHARACTERIZATION, 2},
         {VehicleProperty::ULTRASONICS_SENSOR_POSITION, 3},
         {VehicleProperty::ULTRASONICS_SENSOR_ORIENTATION, 3},
@@ -211,57 +211,57 @@ std::unordered_map<VehicleProperty, int32_t> VersionForVehicleProperty = {
         {VehicleProperty::ULTRASONICS_SENSOR_DETECTION_RANGE, 3},
         {VehicleProperty::ULTRASONICS_SENSOR_SUPPORTED_RANGES, 3},
         {VehicleProperty::ULTRASONICS_SENSOR_MEASURED_DISTANCE, 3},
-        {VehicleProperty::OBD2_LIVE_FRAME, 2},
-        {VehicleProperty::OBD2_FREEZE_FRAME, 2},
-        {VehicleProperty::OBD2_FREEZE_FRAME_INFO, 2},
-        {VehicleProperty::OBD2_FREEZE_FRAME_CLEAR, 2},
-        {VehicleProperty::HEADLIGHTS_STATE, 2},
-        {VehicleProperty::HIGH_BEAM_LIGHTS_STATE, 2},
-        {VehicleProperty::FOG_LIGHTS_STATE, 2},
-        {VehicleProperty::HAZARD_LIGHTS_STATE, 2},
-        {VehicleProperty::HEADLIGHTS_SWITCH, 2},
-        {VehicleProperty::HIGH_BEAM_LIGHTS_SWITCH, 2},
-        {VehicleProperty::FOG_LIGHTS_SWITCH, 2},
-        {VehicleProperty::HAZARD_LIGHTS_SWITCH, 2},
-        {VehicleProperty::CABIN_LIGHTS_STATE, 2},
-        {VehicleProperty::CABIN_LIGHTS_SWITCH, 2},
-        {VehicleProperty::READING_LIGHTS_STATE, 2},
-        {VehicleProperty::READING_LIGHTS_SWITCH, 2},
+        {VehicleProperty::OBD2_LIVE_FRAME, 1},
+        {VehicleProperty::OBD2_FREEZE_FRAME, 1},
+        {VehicleProperty::OBD2_FREEZE_FRAME_INFO, 1},
+        {VehicleProperty::OBD2_FREEZE_FRAME_CLEAR, 1},
+        {VehicleProperty::HEADLIGHTS_STATE, 1},
+        {VehicleProperty::HIGH_BEAM_LIGHTS_STATE, 1},
+        {VehicleProperty::FOG_LIGHTS_STATE, 1},
+        {VehicleProperty::HAZARD_LIGHTS_STATE, 1},
+        {VehicleProperty::HEADLIGHTS_SWITCH, 1},
+        {VehicleProperty::HIGH_BEAM_LIGHTS_SWITCH, 1},
+        {VehicleProperty::FOG_LIGHTS_SWITCH, 1},
+        {VehicleProperty::HAZARD_LIGHTS_SWITCH, 1},
+        {VehicleProperty::CABIN_LIGHTS_STATE, 1},
+        {VehicleProperty::CABIN_LIGHTS_SWITCH, 1},
+        {VehicleProperty::READING_LIGHTS_STATE, 1},
+        {VehicleProperty::READING_LIGHTS_SWITCH, 1},
         {VehicleProperty::STEERING_WHEEL_LIGHTS_STATE, 2},
         {VehicleProperty::STEERING_WHEEL_LIGHTS_SWITCH, 2},
-        {VehicleProperty::SUPPORT_CUSTOMIZE_VENDOR_PERMISSION, 2},
-        {VehicleProperty::DISABLED_OPTIONAL_FEATURES, 2},
-        {VehicleProperty::INITIAL_USER_INFO, 2},
-        {VehicleProperty::SWITCH_USER, 2},
-        {VehicleProperty::CREATE_USER, 2},
-        {VehicleProperty::REMOVE_USER, 2},
-        {VehicleProperty::USER_IDENTIFICATION_ASSOCIATION, 2},
-        {VehicleProperty::EVS_SERVICE_REQUEST, 2},
-        {VehicleProperty::POWER_POLICY_REQ, 2},
-        {VehicleProperty::POWER_POLICY_GROUP_REQ, 2},
-        {VehicleProperty::CURRENT_POWER_POLICY, 2},
-        {VehicleProperty::WATCHDOG_ALIVE, 2},
-        {VehicleProperty::WATCHDOG_TERMINATED_PROCESS, 2},
-        {VehicleProperty::VHAL_HEARTBEAT, 2},
-        {VehicleProperty::CLUSTER_SWITCH_UI, 2},
-        {VehicleProperty::CLUSTER_DISPLAY_STATE, 2},
-        {VehicleProperty::CLUSTER_REPORT_STATE, 2},
-        {VehicleProperty::CLUSTER_REQUEST_DISPLAY, 2},
-        {VehicleProperty::CLUSTER_NAVIGATION_STATE, 2},
-        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_TYPE, 2},
-        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_STATUS, 2},
-        {VehicleProperty::FRONT_FOG_LIGHTS_STATE, 2},
-        {VehicleProperty::FRONT_FOG_LIGHTS_SWITCH, 2},
-        {VehicleProperty::REAR_FOG_LIGHTS_STATE, 2},
-        {VehicleProperty::REAR_FOG_LIGHTS_SWITCH, 2},
-        {VehicleProperty::EV_CHARGE_CURRENT_DRAW_LIMIT, 2},
-        {VehicleProperty::EV_CHARGE_PERCENT_LIMIT, 2},
-        {VehicleProperty::EV_CHARGE_STATE, 2},
-        {VehicleProperty::EV_CHARGE_SWITCH, 2},
-        {VehicleProperty::EV_CHARGE_TIME_REMAINING, 2},
-        {VehicleProperty::EV_REGENERATIVE_BRAKING_STATE, 2},
-        {VehicleProperty::TRAILER_PRESENT, 2},
-        {VehicleProperty::VEHICLE_CURB_WEIGHT, 2},
+        {VehicleProperty::SUPPORT_CUSTOMIZE_VENDOR_PERMISSION, 1},
+        {VehicleProperty::DISABLED_OPTIONAL_FEATURES, 1},
+        {VehicleProperty::INITIAL_USER_INFO, 1},
+        {VehicleProperty::SWITCH_USER, 1},
+        {VehicleProperty::CREATE_USER, 1},
+        {VehicleProperty::REMOVE_USER, 1},
+        {VehicleProperty::USER_IDENTIFICATION_ASSOCIATION, 1},
+        {VehicleProperty::EVS_SERVICE_REQUEST, 1},
+        {VehicleProperty::POWER_POLICY_REQ, 1},
+        {VehicleProperty::POWER_POLICY_GROUP_REQ, 1},
+        {VehicleProperty::CURRENT_POWER_POLICY, 1},
+        {VehicleProperty::WATCHDOG_ALIVE, 1},
+        {VehicleProperty::WATCHDOG_TERMINATED_PROCESS, 1},
+        {VehicleProperty::VHAL_HEARTBEAT, 1},
+        {VehicleProperty::CLUSTER_SWITCH_UI, 1},
+        {VehicleProperty::CLUSTER_DISPLAY_STATE, 1},
+        {VehicleProperty::CLUSTER_REPORT_STATE, 1},
+        {VehicleProperty::CLUSTER_REQUEST_DISPLAY, 1},
+        {VehicleProperty::CLUSTER_NAVIGATION_STATE, 1},
+        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_TYPE, 1},
+        {VehicleProperty::ELECTRONIC_TOLL_COLLECTION_CARD_STATUS, 1},
+        {VehicleProperty::FRONT_FOG_LIGHTS_STATE, 1},
+        {VehicleProperty::FRONT_FOG_LIGHTS_SWITCH, 1},
+        {VehicleProperty::REAR_FOG_LIGHTS_STATE, 1},
+        {VehicleProperty::REAR_FOG_LIGHTS_SWITCH, 1},
+        {VehicleProperty::EV_CHARGE_CURRENT_DRAW_LIMIT, 1},
+        {VehicleProperty::EV_CHARGE_PERCENT_LIMIT, 1},
+        {VehicleProperty::EV_CHARGE_STATE, 1},
+        {VehicleProperty::EV_CHARGE_SWITCH, 1},
+        {VehicleProperty::EV_CHARGE_TIME_REMAINING, 1},
+        {VehicleProperty::EV_REGENERATIVE_BRAKING_STATE, 1},
+        {VehicleProperty::TRAILER_PRESENT, 1},
+        {VehicleProperty::VEHICLE_CURB_WEIGHT, 1},
         {VehicleProperty::GENERAL_SAFETY_REGULATION_COMPLIANCE_REQUIREMENT, 2},
         {VehicleProperty::SUPPORTED_PROPERTY_IDS, 2},
         {VehicleProperty::SHUTDOWN_REQUEST, 2},
diff --git a/automotive/vehicle/aidl/generated_lib/4/java/AnnotationsForVehicleProperty.java b/automotive/vehicle/aidl/generated_lib/4/java/AnnotationsForVehicleProperty.java
index 07f55b145e..d78650c2a8 100644
--- a/automotive/vehicle/aidl/generated_lib/4/java/AnnotationsForVehicleProperty.java
+++ b/automotive/vehicle/aidl/generated_lib/4/java/AnnotationsForVehicleProperty.java
@@ -255,7 +255,7 @@ public final class AnnotationsForVehicleProperty {
         Map.entry(VehicleProperty.REAR_FOG_LIGHTS_STATE, Set.of("access", "change_mode", "data_enum", "require_supported_values_list", "version")),
         Map.entry(VehicleProperty.REAR_FOG_LIGHTS_SWITCH, Set.of("access", "change_mode", "data_enum", "require_supported_values_list", "version")),
         Map.entry(VehicleProperty.EV_CHARGE_CURRENT_DRAW_LIMIT, Set.of("access", "change_mode", "unit", "version")),
-        Map.entry(VehicleProperty.EV_CHARGE_PERCENT_LIMIT, Set.of("access", "change_mode", "legacy_supported_values_in_config", "require_supported_values_list", "version")),
+        Map.entry(VehicleProperty.EV_CHARGE_PERCENT_LIMIT, Set.of("access", "change_mode", "legacy_supported_values_in_config", "version")),
         Map.entry(VehicleProperty.EV_CHARGE_STATE, Set.of("access", "change_mode", "data_enum", "require_supported_values_list", "version")),
         Map.entry(VehicleProperty.EV_CHARGE_SWITCH, Set.of("access", "change_mode", "version")),
         Map.entry(VehicleProperty.EV_CHARGE_TIME_REMAINING, Set.of("access", "change_mode", "unit", "version")),
diff --git a/automotive/vehicle/aidl/impl/3/README.md b/automotive/vehicle/aidl/impl/3/README.md
index bf80122905..ff2e42144b 100644
--- a/automotive/vehicle/aidl/impl/3/README.md
+++ b/automotive/vehicle/aidl/impl/3/README.md
@@ -1,8 +1,12 @@
-# AIDL VHAL libraries and reference implementation.
+# AIDL VHAL V3 libraries and reference implementation.
 ---
 
-This directory stores the libraries useful for implementing vendor AIDL VHAL.
-This directory also stores a reference fake implementation for AIDL VHAL.
+NOTE: This is an outdated version. Please see
+`hardware/interfaces/automotive/vehicle/aidl/impl/current` for the latest
+version.
+
+This directory stores the libraries useful for implementing vendor AIDL VHAL V3.
+This directory also stores a reference fake implementation for AIDL VHAL V3.
 
 ## default_config
 
diff --git a/automotive/vehicle/aidl/impl/current/README.md b/automotive/vehicle/aidl/impl/current/README.md
index 2cd3a3eb5b..0d15eeec13 100644
--- a/automotive/vehicle/aidl/impl/current/README.md
+++ b/automotive/vehicle/aidl/impl/current/README.md
@@ -1,8 +1,8 @@
-# AIDL VHAL libraries and reference implementation.
+# AIDL VHAL V4 libraries and reference implementation.
 ---
 
-This directory stores the libraries useful for implementing vendor AIDL VHAL.
-This directory also stores a reference fake implementation for AIDL VHAL.
+This directory stores the libraries useful for implementing vendor AIDL VHAL V4.
+This directory also stores a reference fake implementation for AIDL VHAL V4.
 
 ## default_config
 
@@ -24,6 +24,25 @@ vehicle.
 
 Stores code for GRPC based VHAL implementation.
 
+The GRPC based VHAL implementation delegates most of the VHAL logic to a VHAL
+proxy server running remotely. For example, the server may run in a separate
+Android (maybe not AAOS) VM or a non-Android machine running in the same
+ethernet.
+
+This is used in AAOS cuttlefish, where the VHAL proxy server is running on the
+host machine with AAOS running in a VM.
+
+The GRPC VHAL uses `DefaultVehicleHal`, but with a special
+`IVehicleHardware` implementation: `GRPCVehicleHardware`. The
+`GRPCVehicleHardware` is a thin proxy layer that forwards all requests to a
+GRPC server (`GRPCVehicleProxyServer`).
+
+The supported communication channels between GRPC VHAL and the GRPC Vehicle
+proxy server are Ethernet or Vsock.
+
+Note that VHAL must be ready early on during the boot so the communciation
+channel setup step must happen very early before VHAL registers itself.
+
 ## hardware
 
 Defines an interface `IVehicleHardware.h` which vendor must implement for
@@ -46,7 +65,7 @@ implementations (including reference VHAL). Vendor VHAL implementation could
 use this library, along with their own implementation for `IVehicleHardware`
 interface.
 
-Also defines a binary `android.hardware.automotive.vehicle@V3-default-service`
+Also defines a binary `android.hardware.automotive.vehicle@V4-default-service`
 which is the reference VHAL implementation. It implements `IVehicle.aidl`
 interface. It uses `DefaultVehicleHal`, along with `FakeVehicleHardware`
 (in fake_impl). It simulates the vehicle bus interaction by using an
diff --git a/automotive/vehicle/aidl/impl/current/default_config/config/README.md b/automotive/vehicle/aidl/impl/current/default_config/config/README.md
index 6e82de5773..4ca6c7fb32 100644
--- a/automotive/vehicle/aidl/impl/current/default_config/config/README.md
+++ b/automotive/vehicle/aidl/impl/current/default_config/config/README.md
@@ -14,7 +14,7 @@ actual JSON file and will be ignored by the parser)
 ```
 {
     // (number) The version for the JSON schema.
-    "apiVersion": 1,
+    "apiVersion": 2,
     // (non-empty array of objects) The property configuration list.
     //
     // Each object is a configuration for one property.
@@ -75,6 +75,23 @@ actual JSON file and will be ignored by the parser)
                     "minFloatValue": 1,
                     // (optional number/string) The maximum float value.
                     "maxFloatValue": 10,
+                    // (optional boolean since Android 15) Whether variable
+                    // update rate is supported for continuous property.
+                    "supportVariableUpdateRate": true,
+                    // (optional since Android 15) If specified, then this
+                    // [propId, areaId] supports the getSupportedValuesLists
+                    // and getMinMaxSupportedValue API.
+                    "hasSupportedValueInfo": {
+                        // (optional boolean) Whether this [propId, areaId]
+                        // specifies supported values list. Default to false.
+                        "hasSupportedValuesList": true,
+                        // (optional boolean) Whether this [propId, areaId]
+                        // specifies min supported value. Default to false.
+                        "hasMinSupportedValue": true,
+                        // (optional boolean) Whether this [propId, areaId]
+                        // specifies max supported value. Default to false.
+                        "hasMaxSupportedValue": true
+                    },
                     // (optional object) The default value for this area.
                     // Uses the same format as the "defaultValue" field for
                     // property object. If specified, this overwrite the global
@@ -92,6 +109,78 @@ actual JSON file and will be ignored by the parser)
 }
 ```
 
+## API Version
+
+The JSON file contains an `apiVersion` field which specified the schema version.
+This field is useful for the JSON parser to decide how to parse the file. A
+new-version parser is always capable of parsing an older version config file,
+but not the other way around. For example, the latest VHAL config version
+supported by the config parser used in the reference VHAL is V2, but a V1 config
+file is still accepted.
+
+New fields may be supported by each Android release (see the comment in the
+schema). The parser used in the reference VHAL ignores all unknown fields, so
+specifying unsupported fields will not cause error, but will be ignored.
+
+A new api version usually introduces a backward-incompatible schema change.
+Supporting a new field typically does not require a new api version.
+
+### Version 1
+
+This is the base config version introduced at Android 13.
+
+### Version 2
+
+This is introduced at Android 16.
+
+#### Default areaId config at property level
+
+In this version, we allow per-areaId config to be specified at the per-property
+level to be the default config for all areaIds. For example, for the following
+config:
+
+```
+{
+    "apiVersion": 2,
+    "properties": [
+        {
+            "property": "VehicleProperty::SEAT_BELT_BUCKLED",
+            "defaultValue": {
+                "int32Values": [
+                    0
+                ]
+            },
+            "areas": [
+                {
+                    "areaId": "Constants::SEAT_1_LEFT",
+                    "defaultValue": {
+                        "int32Values": [
+                            1
+                        ]
+                    }
+                },
+                {
+                    "areaId": "Constants::SEAT_1_RIGHT"
+                },
+                {
+                    "areaId": "Constants::SEAT_2_LEFT"
+                },
+                {
+                    "areaId": "Constants::SEAT_2_RIGHT"
+                },
+                {
+                    "areaId": "Constants::SEAT_2_CENTER"
+                }
+            ]
+        }
+     ]
+}
+```
+
+This means that all areaIds for SEAT_BELT_BUCKLED has the default value 0,
+except for SEAT_1_LEFT, which has the default value 1.
+
+
 ## JSON Number-type Field Values
 
 For number type field values, they can either be defined as a numeric number,
diff --git a/automotive/vehicle/aidl/impl/current/fake_impl/hardware/src/FakeVehicleHardware.cpp b/automotive/vehicle/aidl/impl/current/fake_impl/hardware/src/FakeVehicleHardware.cpp
index be909c5d74..35b2a49e49 100644
--- a/automotive/vehicle/aidl/impl/current/fake_impl/hardware/src/FakeVehicleHardware.cpp
+++ b/automotive/vehicle/aidl/impl/current/fake_impl/hardware/src/FakeVehicleHardware.cpp
@@ -2092,7 +2092,7 @@ std::string FakeVehicleHardware::dumpSetMinMaxValue(const std::vector<std::strin
 
     triggerSupportedValueChange(propId, areaId);
     return StringPrintf("Min/Max supported value for propId: %s, areaId: %s set\n",
-                        maybeInfo->propIdStr.c_str(), maybeInfo->propIdStr.c_str());
+                        maybeInfo->propIdStr.c_str(), maybeInfo->areaIdStr.c_str());
 }
 
 std::string FakeVehicleHardware::dumpSetSupportedValues(const std::vector<std::string>& options) {
@@ -2136,7 +2136,7 @@ std::string FakeVehicleHardware::dumpSetSupportedValues(const std::vector<std::s
     }
     triggerSupportedValueChange(maybeInfo->propId, maybeInfo->areaId);
     return StringPrintf("Supported values list for propId: %s, areaId: %s set\n",
-                        maybeInfo->propIdStr.c_str(), maybeInfo->propIdStr.c_str());
+                        maybeInfo->propIdStr.c_str(), maybeInfo->areaIdStr.c_str());
 }
 
 void FakeVehicleHardware::triggerSupportedValueChange(int32_t propId, int32_t areaId) {
diff --git a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.cpp b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.cpp
index e64c6961ac..ead6fecc2a 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.cpp
+++ b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.cpp
@@ -38,6 +38,7 @@ using ::grpc::Status;
 namespace {
 
 constexpr size_t MAX_RETRY_COUNT = 5;
+constexpr int32_t RECONNECT_SLEEP_MS = 100;
 
 std::shared_ptr<ChannelCredentials> getChannelCredentials() {
     return InsecureChannelCredentials();
@@ -68,8 +69,13 @@ std::vector<AidlResultType> convertSupportedValueProtoResultToAidlResults(
 GRPCVehicleHardware::GRPCVehicleHardware(std::string service_addr)
     : mServiceAddr(std::move(service_addr)),
       mGrpcChannel(CreateChannel(mServiceAddr, getChannelCredentials())),
-      mGrpcStub(proto::VehicleServer::NewStub(mGrpcChannel)),
-      mValuePollingThread([this] { ValuePollingLoop(); }) {}
+      mGrpcStub(proto::VehicleServer::NewStub(mGrpcChannel)) {
+    // Do not init the thread using initialization list because the thread might use some local
+    // variables that are declared after the thread, which might not be initialized yet when the
+    // thread starts.
+    mValuePollingThread = std::thread([this] { ValuePollingLoop(); });
+    mSupportedValuesChangeThread = std::thread([this] { SupportedValuesChangeLoop(); });
+}
 
 // Only used for unit testing.
 GRPCVehicleHardware::GRPCVehicleHardware(std::unique_ptr<proto::VehicleServer::StubInterface> stub,
@@ -77,18 +83,32 @@ GRPCVehicleHardware::GRPCVehicleHardware(std::unique_ptr<proto::VehicleServer::S
     : mServiceAddr(""), mGrpcChannel(nullptr), mGrpcStub(std::move(stub)) {
     if (startValuePollingLoop) {
         mValuePollingThread = std::thread([this] { ValuePollingLoop(); });
+        mSupportedValuesChangeThread = std::thread([this] { SupportedValuesChangeLoop(); });
     }
 }
 
 GRPCVehicleHardware::~GRPCVehicleHardware() {
+    LOG(INFO) << __func__;
     {
         std::lock_guard lck(mShutdownMutex);
         mShuttingDownFlag.store(true);
+        LOG(INFO) << __func__ << ": Cancelling all active stream contexts";
+        for (ClientContext* context : mStreamContexts) {
+            context->TryCancel();
+        }
+        mStreamContexts.clear();
     }
-    mShutdownCV.notify_all();
+    LOG(INFO) << __func__ << ": Waiting for value polling thread to join";
     if (mValuePollingThread.joinable()) {
         mValuePollingThread.join();
     }
+    LOG(INFO)
+            << __func__
+            << ": Value polling thread joined, waiting for supported values change thread to join";
+    if (mSupportedValuesChangeThread.joinable()) {
+        mSupportedValuesChangeThread.join();
+    }
+    LOG(INFO) << __func__ << ": Supported values change thread joined";
 }
 
 std::vector<aidlvhal::VehiclePropConfig> GRPCVehicleHardware::getAllPropertyConfigs() const {
@@ -287,6 +307,16 @@ void GRPCVehicleHardware::registerOnPropertySetErrorEvent(
     mOnSetErr = std::move(callback);
 }
 
+void GRPCVehicleHardware::registerSupportedValueChangeCallback(
+        std::unique_ptr<const SupportedValueChangeCallback> callback) {
+    std::lock_guard lck(mCallbackMutex);
+    if (mOnSupportedValueChange) {
+        LOG(ERROR) << __func__ << " must only be called once.";
+        return;
+    }
+    mOnSupportedValueChange = std::move(callback);
+}
+
 DumpResult GRPCVehicleHardware::dump(const std::vector<std::string>& options) {
     ClientContext context;
     proto::DumpOptions protoDumpOptions;
@@ -378,20 +408,23 @@ bool GRPCVehicleHardware::waitForConnected(std::chrono::milliseconds waitTime) {
 void GRPCVehicleHardware::ValuePollingLoop() {
     while (!mShuttingDownFlag.load()) {
         pollValue();
-        // try to reconnect
+        // Check the flag again to avoid the 100ms wait if we are shutting down.
+        if (mShuttingDownFlag.load()) {
+            return;
+        }
+        // try to reconnect after a short sleep.
+        LOG(WARNING) << __func__ << ": GRPC Value Streaming disconnect, reconnect after "
+                     << RECONNECT_SLEEP_MS << "ms";
+        std::this_thread::sleep_for(std::chrono::milliseconds(RECONNECT_SLEEP_MS));
     }
 }
 
 void GRPCVehicleHardware::pollValue() {
     ClientContext context;
-
-    bool rpc_stopped{false};
-    std::thread shuttingdown_watcher([this, &rpc_stopped, &context]() {
-        std::unique_lock<std::mutex> lck(mShutdownMutex);
-        mShutdownCV.wait(
-                lck, [this, &rpc_stopped]() { return rpc_stopped || mShuttingDownFlag.load(); });
-        context.TryCancel();
-    });
+    {
+        std::lock_guard lck(mShutdownMutex);
+        mStreamContexts.insert(&context);
+    }
 
     auto value_stream = mGrpcStub->StartPropertyValuesStream(&context, ::google::protobuf::Empty());
     LOG(INFO) << __func__ << ": GRPC Value Streaming Started";
@@ -424,14 +457,70 @@ void GRPCVehicleHardware::pollValue() {
 
     {
         std::lock_guard lck(mShutdownMutex);
-        rpc_stopped = true;
+        mStreamContexts.erase(&context);
+    }
+
+    auto grpc_status = value_stream->Finish();
+    // never reach here until connection lost
+    LOG(ERROR) << __func__ << ": GRPC Value Streaming Failed: " << grpc_status.error_message();
+}
+
+void GRPCVehicleHardware::SupportedValuesChangeLoop() {
+    while (!mShuttingDownFlag.load()) {
+        auto status = pollSupportedValuesChange();
+        if (status.error_code() == grpc::StatusCode::UNIMPLEMENTED) {
+            LOG(WARNING)
+                    << __func__
+                    << ": GRPC vhal proxy server does not implement StartSupportedValuesChange, "
+                       "supported values change will never happen";
+            break;
+        }
+        if (mShuttingDownFlag.load()) {
+            return;
+        }
+        // try to reconnect after a short sleep.
+        LOG(WARNING) << __func__ << ": GRPC Value Streaming disconnect, reconnect after "
+                     << RECONNECT_SLEEP_MS << "ms";
+        std::this_thread::sleep_for(std::chrono::milliseconds(RECONNECT_SLEEP_MS));
+    }
+}
+
+Status GRPCVehicleHardware::pollSupportedValuesChange() {
+    ClientContext context;
+    {
+        std::lock_guard lck(mShutdownMutex);
+        mStreamContexts.insert(&context);
+    }
+
+    auto value_stream =
+            mGrpcStub->StartSupportedValuesChangeStream(&context, ::google::protobuf::Empty());
+    LOG(INFO) << __func__ << ": GRPC Value Streaming Started";
+    proto::SupportedValuesChange supportedValuesChange;
+    while (!mShuttingDownFlag.load() && value_stream->Read(&supportedValuesChange)) {
+        std::vector<PropIdAreaId> propIdAreaIds;
+        for (const auto protoPropIdAreaId : supportedValuesChange.prop_id_area_ids()) {
+            PropIdAreaId propIdAreaId = {};
+            proto_msg_converter::protoToAidl(protoPropIdAreaId, &propIdAreaId);
+            propIdAreaIds.push_back(std::move(propIdAreaId));
+        }
+        if (propIdAreaIds.empty()) {
+            continue;
+        }
+        std::shared_lock lck(mCallbackMutex);
+        if (mOnSupportedValueChange) {
+            (*mOnSupportedValueChange)(propIdAreaIds);
+        }
+    }
+
+    {
+        std::lock_guard lck(mShutdownMutex);
+        mStreamContexts.erase(&context);
     }
-    mShutdownCV.notify_all();
-    shuttingdown_watcher.join();
 
     auto grpc_status = value_stream->Finish();
     // never reach here until connection lost
     LOG(ERROR) << __func__ << ": GRPC Value Streaming Failed: " << grpc_status.error_message();
+    return grpc_status;
 }
 
 std::vector<aidlvhal::MinMaxSupportedValueResult> GRPCVehicleHardware::getMinMaxSupportedValues(
diff --git a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.h b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.h
index 7fc3d79690..9128acd462 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.h
+++ b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleHardware.h
@@ -31,6 +31,7 @@
 #include <chrono>
 #include <condition_variable>
 #include <memory>
+#include <set>
 #include <shared_mutex>
 #include <string>
 #include <thread>
@@ -82,6 +83,12 @@ class GRPCVehicleHardware : public IVehicleHardware {
     void registerOnPropertySetErrorEvent(
             std::unique_ptr<const PropertySetErrorCallback> callback) override;
 
+    // Register a callback that would be called when the min/max supported value or supported
+    // values list change dynamically for propertyID returned from
+    // getPropertyIdsThatImplementGetSupportedValue
+    void registerSupportedValueChangeCallback(
+            std::unique_ptr<const SupportedValueChangeCallback> callback) override;
+
     // Update the sample rate for the [propId, areaId] pair.
     aidlvhal::StatusCode updateSampleRate(int32_t propId, int32_t areaId,
                                           float sampleRate) override;
@@ -109,12 +116,15 @@ class GRPCVehicleHardware : public IVehicleHardware {
     std::shared_ptr<::grpc::Channel> mGrpcChannel;
     std::unique_ptr<proto::VehicleServer::StubInterface> mGrpcStub;
     std::thread mValuePollingThread;
+    std::thread mSupportedValuesChangeThread;
 
     std::unique_ptr<const PropertySetErrorCallback> mOnSetErr;
+    std::unique_ptr<const SupportedValueChangeCallback> mOnSupportedValueChange;
 
     std::mutex mShutdownMutex;
-    std::condition_variable mShutdownCV;
     std::atomic<bool> mShuttingDownFlag{false};
+    // Stores the ClientContexts for active streams. This is stored so that we may cancel them.
+    std::set<::grpc::ClientContext*> mStreamContexts GUARDED_BY(mShutdownMutex);
 
     mutable std::mutex mLatestUpdateTimestampsMutex;
 
@@ -130,6 +140,8 @@ class GRPCVehicleHardware : public IVehicleHardware {
 
     void ValuePollingLoop();
     void pollValue();
+    void SupportedValuesChangeLoop();
+    ::grpc::Status pollSupportedValuesChange();
 
     aidlvhal::StatusCode getValuesWithRetry(const std::vector<aidlvhal::GetValueRequest>& requests,
                                             std::vector<aidlvhal::GetValueResult>* results,
diff --git a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.cpp b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.cpp
index f216683af7..8f46f71d61 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.cpp
+++ b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.cpp
@@ -56,7 +56,9 @@ void aidlResultsToProtoResults(const AidlResultType& aidlResults, ProtoResultTyp
 }
 }  // namespace
 
-std::atomic<uint64_t> GrpcVehicleProxyServer::ConnectionDescriptor::connection_id_counter_{0};
+template <typename ValueType>
+std::atomic<uint64_t>
+        GrpcVehicleProxyServer::ConnectionDescriptor<ValueType>::connection_id_counter_{0};
 
 GrpcVehicleProxyServer::GrpcVehicleProxyServer(std::string serverAddr,
                                                std::unique_ptr<IVehicleHardware>&& hardware)
@@ -70,6 +72,11 @@ GrpcVehicleProxyServer::GrpcVehicleProxyServer(std::vector<std::string> serverAd
                     [this](std::vector<aidlvhal::VehiclePropValue> values) {
                         OnVehiclePropChange(values);
                     }));
+    mHardware->registerSupportedValueChangeCallback(
+            std::make_unique<const IVehicleHardware::SupportedValueChangeCallback>(
+                    [this](std::vector<PropIdAreaId> propIdAreaIds) {
+                        OnSupportedValuesChange(propIdAreaIds);
+                    }));
 }
 
 ::grpc::Status GrpcVehicleProxyServer::GetAllPropertyConfig(
@@ -253,7 +260,7 @@ GrpcVehicleProxyServer::GrpcVehicleProxyServer(std::vector<std::string> serverAd
 ::grpc::Status GrpcVehicleProxyServer::StartPropertyValuesStream(
         ::grpc::ServerContext* context, const ::google::protobuf::Empty* request,
         ::grpc::ServerWriter<proto::VehiclePropValues>* stream) {
-    auto conn = std::make_shared<ConnectionDescriptor>(stream);
+    auto conn = std::make_shared<ConnectionDescriptor<proto::VehiclePropValues>>(stream);
     {
         std::lock_guard lck(mConnectionMutex);
         mValueStreamingConnections.push_back(conn);
@@ -283,17 +290,47 @@ GrpcVehicleProxyServer::GrpcVehicleProxyServer(std::vector<std::string> serverAd
     return ::grpc::Status::OK;
 }
 
+::grpc::Status GrpcVehicleProxyServer::StartSupportedValuesChangeStream(
+        ::grpc::ServerContext* context, const ::google::protobuf::Empty* request,
+        ::grpc::ServerWriter<proto::SupportedValuesChange>* stream) {
+    auto conn = std::make_shared<ConnectionDescriptor<proto::SupportedValuesChange>>(stream);
+    {
+        std::lock_guard lck(mConnectionMutex);
+        mSupportedValuesChangeConnections.push_back(conn);
+    }
+    conn->Wait();
+    LOG(ERROR) << __func__ << ": Stream lost, ID : " << conn->ID();
+    return ::grpc::Status(::grpc::StatusCode::ABORTED, "Connection lost.");
+}
+
 void GrpcVehicleProxyServer::OnVehiclePropChange(
         const std::vector<aidlvhal::VehiclePropValue>& values) {
-    std::unordered_set<uint64_t> brokenConn;
     proto::VehiclePropValues protoValues;
     for (const auto& value : values) {
         auto* protoValuePtr = protoValues.add_values();
         proto_msg_converter::aidlToProto(value, protoValuePtr);
     }
+    writeToStream(mValueStreamingConnections, protoValues);
+}
+
+void GrpcVehicleProxyServer::OnSupportedValuesChange(
+        const std::vector<PropIdAreaId>& propIdAreaIds) {
+    proto::SupportedValuesChange protoValues;
+    for (const auto& propIdAreaId : propIdAreaIds) {
+        auto* protoValuePtr = protoValues.add_prop_id_area_ids();
+        proto_msg_converter::aidlToProto(propIdAreaId, protoValuePtr);
+    }
+    writeToStream(mSupportedValuesChangeConnections, protoValues);
+}
+
+template <typename ValueType>
+void GrpcVehicleProxyServer::writeToStream(
+        std::vector<std::shared_ptr<ConnectionDescriptor<ValueType>>>& connections,
+        const ValueType& protoValues) {
+    std::unordered_set<uint64_t> brokenConn;
     {
         std::shared_lock read_lock(mConnectionMutex);
-        for (auto& connection : mValueStreamingConnections) {
+        for (auto& connection : connections) {
             auto writeOK = connection->Write(protoValues);
             if (!writeOK) {
                 LOG(ERROR) << __func__
@@ -306,12 +343,11 @@ void GrpcVehicleProxyServer::OnVehiclePropChange(
         return;
     }
     std::unique_lock write_lock(mConnectionMutex);
-    mValueStreamingConnections.erase(
-            std::remove_if(mValueStreamingConnections.begin(), mValueStreamingConnections.end(),
-                           [&brokenConn](const auto& conn) {
-                               return brokenConn.find(conn->ID()) != brokenConn.end();
-                           }),
-            mValueStreamingConnections.end());
+    connections.erase(std::remove_if(connections.begin(), connections.end(),
+                                     [&brokenConn](const auto& conn) {
+                                         return brokenConn.find(conn->ID()) != brokenConn.end();
+                                     }),
+                      connections.end());
 }
 
 GrpcVehicleProxyServer& GrpcVehicleProxyServer::Start() {
@@ -331,10 +367,17 @@ GrpcVehicleProxyServer& GrpcVehicleProxyServer::Start() {
 }
 
 GrpcVehicleProxyServer& GrpcVehicleProxyServer::Shutdown() {
+    LOG(INFO) << __func__ << ": Start shutting down GrpcVehicleProxyServer";
     std::shared_lock read_lock(mConnectionMutex);
+    LOG(INFO) << __func__ << ": Waiting for value stream connection to shutdown";
     for (auto& conn : mValueStreamingConnections) {
         conn->Shutdown();
     }
+    LOG(INFO) << __func__ << ": Waiting for supported values change stream connection to shutdown";
+    for (auto& conn : mSupportedValuesChangeConnections) {
+        conn->Shutdown();
+    }
+    LOG(INFO) << __func__ << ": Requesting server to shutdown";
     if (mServer) {
         mServer->Shutdown();
     }
@@ -342,17 +385,21 @@ GrpcVehicleProxyServer& GrpcVehicleProxyServer::Shutdown() {
 }
 
 void GrpcVehicleProxyServer::Wait() {
+    LOG(INFO) << __func__ << ": Waiting for server to shutdown";
     if (mServer) {
         mServer->Wait();
     }
+    LOG(INFO) << __func__ << ": Server shutdown complete";
     mServer.reset();
 }
 
-GrpcVehicleProxyServer::ConnectionDescriptor::~ConnectionDescriptor() {
+template <typename ValueType>
+GrpcVehicleProxyServer::ConnectionDescriptor<ValueType>::~ConnectionDescriptor() {
     Shutdown();
 }
 
-bool GrpcVehicleProxyServer::ConnectionDescriptor::Write(const proto::VehiclePropValues& values) {
+template <typename ValueType>
+bool GrpcVehicleProxyServer::ConnectionDescriptor<ValueType>::Write(const ValueType& values) {
     if (!mStream) {
         LOG(ERROR) << __func__ << ": Empty stream. ID: " << ID();
         Shutdown();
@@ -370,12 +417,14 @@ bool GrpcVehicleProxyServer::ConnectionDescriptor::Write(const proto::VehiclePro
     return false;
 }
 
-void GrpcVehicleProxyServer::ConnectionDescriptor::Wait() {
+template <typename ValueType>
+void GrpcVehicleProxyServer::ConnectionDescriptor<ValueType>::Wait() {
     std::unique_lock lck(*mMtx);
     mCV->wait(lck, [this] { return mShutdownFlag; });
 }
 
-void GrpcVehicleProxyServer::ConnectionDescriptor::Shutdown() {
+template <typename ValueType>
+void GrpcVehicleProxyServer::ConnectionDescriptor<ValueType>::Shutdown() {
     {
         std::lock_guard lck(*mMtx);
         mShutdownFlag = true;
diff --git a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.h b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.h
index eb261ca00b..923af76926 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.h
+++ b/automotive/vehicle/aidl/impl/current/grpc/GRPCVehicleProxyServer.h
@@ -85,6 +85,10 @@ class GrpcVehicleProxyServer : public proto::VehicleServer::Service {
                                            const proto::GetSupportedValuesListsRequest* requests,
                                            proto::GetSupportedValuesListsResult* results) override;
 
+    ::grpc::Status StartSupportedValuesChangeStream(
+            ::grpc::ServerContext* context, const ::google::protobuf::Empty* request,
+            ::grpc::ServerWriter<proto::SupportedValuesChange>* stream) override;
+
     GrpcVehicleProxyServer& Start();
 
     GrpcVehicleProxyServer& Shutdown();
@@ -94,9 +98,12 @@ class GrpcVehicleProxyServer : public proto::VehicleServer::Service {
   private:
     void OnVehiclePropChange(const std::vector<aidlvhal::VehiclePropValue>& values);
 
+    void OnSupportedValuesChange(const std::vector<PropIdAreaId>& propIdAreaIds);
+
     // We keep long-lasting connection for streaming the prop values.
+    template <typename ValueType>
     struct ConnectionDescriptor {
-        explicit ConnectionDescriptor(::grpc::ServerWriter<proto::VehiclePropValues>* stream)
+        explicit ConnectionDescriptor(::grpc::ServerWriter<ValueType>* stream)
             : mStream(stream),
               mConnectionID(connection_id_counter_.fetch_add(1) + 1),
               mMtx(std::make_unique<std::mutex>()),
@@ -111,14 +118,14 @@ class GrpcVehicleProxyServer : public proto::VehicleServer::Service {
 
         uint64_t ID() const { return mConnectionID; }
 
-        bool Write(const proto::VehiclePropValues& values);
+        bool Write(const ValueType& values);
 
         void Wait();
 
         void Shutdown();
 
       private:
-        ::grpc::ServerWriter<proto::VehiclePropValues>* mStream;
+        ::grpc::ServerWriter<ValueType>* mStream;
         uint64_t mConnectionID{0};
         std::unique_ptr<std::mutex> mMtx;
         std::unique_ptr<std::condition_variable> mCV;
@@ -132,7 +139,14 @@ class GrpcVehicleProxyServer : public proto::VehicleServer::Service {
     std::unique_ptr<IVehicleHardware> mHardware;
 
     std::shared_mutex mConnectionMutex;
-    std::vector<std::shared_ptr<ConnectionDescriptor>> mValueStreamingConnections;
+    std::vector<std::shared_ptr<ConnectionDescriptor<proto::VehiclePropValues>>>
+            mValueStreamingConnections;
+    std::vector<std::shared_ptr<ConnectionDescriptor<proto::SupportedValuesChange>>>
+            mSupportedValuesChangeConnections;
+
+    template <typename ValueType>
+    void writeToStream(std::vector<std::shared_ptr<ConnectionDescriptor<ValueType>>>& connections,
+                       const ValueType& protoValues);
 
     static constexpr auto kHardwareOpTimeout = std::chrono::seconds(1);
 };
diff --git a/automotive/vehicle/aidl/impl/current/grpc/proto/VehicleServer.proto b/automotive/vehicle/aidl/impl/current/grpc/proto/VehicleServer.proto
index 3364ed74f4..023170db8f 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/proto/VehicleServer.proto
+++ b/automotive/vehicle/aidl/impl/current/grpc/proto/VehicleServer.proto
@@ -23,6 +23,7 @@ import "android/hardware/automotive/vehicle/DumpResult.proto";
 import "android/hardware/automotive/vehicle/GetMinMaxSupportedValuesTypes.proto";
 import "android/hardware/automotive/vehicle/GetSupportedValuesListsTypes.proto";
 import "android/hardware/automotive/vehicle/SubscribeRequest.proto";
+import "android/hardware/automotive/vehicle/SupportedValuesChange.proto";
 import "android/hardware/automotive/vehicle/StatusCode.proto";
 import "android/hardware/automotive/vehicle/UnsubscribeRequest.proto";
 import "android/hardware/automotive/vehicle/VehiclePropConfig.proto";
@@ -54,4 +55,7 @@ service VehicleServer {
 
     rpc GetSupportedValuesLists(GetSupportedValuesListsRequest)
             returns (GetSupportedValuesListsResult) {}
+
+    rpc StartSupportedValuesChangeStream(google.protobuf.Empty)
+            returns (stream SupportedValuesChange) {}
 }
diff --git a/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleHardwareUnitTest.cpp b/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleHardwareUnitTest.cpp
index 343e5b2f96..bdcaf9388f 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleHardwareUnitTest.cpp
+++ b/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleHardwareUnitTest.cpp
@@ -40,6 +40,7 @@ using ::testing::SaveArg;
 using ::testing::SetArgPointee;
 using ::testing::SizeIs;
 
+using ::grpc::Status;
 using ::grpc::testing::MockClientReader;
 
 using proto::MockVehicleServerStub;
@@ -62,6 +63,8 @@ class GRPCVehicleHardwareUnitTest : public ::testing::Test {
     // Access GRPCVehicleHardware private method.
     void pollValue() { mHardware->pollValue(); }
 
+    Status pollSupportedValuesChange() { return mHardware->pollSupportedValuesChange(); }
+
     void startValuePollingLoop(std::unique_ptr<proto::VehicleServer::StubInterface> stub) {
         mHardware = std::unique_ptr<GRPCVehicleHardware>(
                 new GRPCVehicleHardware(std::move(stub), /*startValuePollingLoop=*/true));
@@ -277,13 +280,14 @@ TEST_F(GRPCVehicleHardwareUnitTest, TestPollValueIgnoreOutdatedValue) {
 TEST_F(GRPCVehicleHardwareUnitTest, TestValuePollingLoop) {
     int64_t testTimestamp = 12345;
     int32_t testPropId = 54321;
+    int32_t testAreaId = 123;
     auto stub = std::make_unique<NiceMock<MockVehicleServerStub>>();
 
     // This will be converted to a unique_ptr in StartPropertyValuesStream. The ownership is passed
     // there.
-    auto clientReader = new MockClientReader<proto::VehiclePropValues>();
-    EXPECT_CALL(*stub, StartPropertyValuesStreamRaw(_, _)).WillOnce(Return(clientReader));
-    EXPECT_CALL(*clientReader, Read(_))
+    auto valueReader = new MockClientReader<proto::VehiclePropValues>();
+    EXPECT_CALL(*stub, StartPropertyValuesStreamRaw(_, _)).WillOnce(Return(valueReader));
+    EXPECT_CALL(*valueReader, Read(_))
             .WillRepeatedly([testTimestamp, testPropId](proto::VehiclePropValues* values) {
                 // Sleep for 10ms and always return the same property event.
                 std::this_thread::sleep_for(std::chrono::milliseconds(10));
@@ -293,7 +297,22 @@ TEST_F(GRPCVehicleHardwareUnitTest, TestValuePollingLoop) {
                 value->set_prop(testPropId);
                 return true;
             });
-    EXPECT_CALL(*clientReader, Finish()).WillOnce(Return(::grpc::Status::OK));
+    EXPECT_CALL(*valueReader, Finish()).WillOnce(Return(::grpc::Status::OK));
+
+    auto supportedValuesChangeReader = new MockClientReader<proto::SupportedValuesChange>();
+    EXPECT_CALL(*stub, StartSupportedValuesChangeStreamRaw(_, _))
+            .WillOnce(Return(supportedValuesChangeReader));
+    EXPECT_CALL(*supportedValuesChangeReader, Read(_))
+            .WillRepeatedly([testPropId, testAreaId](proto::SupportedValuesChange* values) {
+                // Sleep for 10ms and always return the same SupportedValuesChange
+                std::this_thread::sleep_for(std::chrono::milliseconds(10));
+                values->Clear();
+                auto value = values->add_prop_id_area_ids();
+                value->set_prop_id(testPropId);
+                value->set_area_id(testAreaId);
+                return true;
+            });
+    EXPECT_CALL(*supportedValuesChangeReader, Finish()).WillOnce(Return(::grpc::Status::OK));
 
     startValuePollingLoop(std::move(stub));
 
@@ -303,6 +322,74 @@ TEST_F(GRPCVehicleHardwareUnitTest, TestValuePollingLoop) {
     mHardware.reset();
 }
 
+TEST_F(GRPCVehicleHardwareUnitTest, TestPollSupportedValuesChange) {
+    int32_t testPropId = 1234;
+    int32_t testAreaId = 4321;
+
+    // This will be converted to a unique_ptr in StartPropertyValuesStream. The ownership is passed
+    // there.
+    auto clientReader = new MockClientReader<proto::SupportedValuesChange>();
+    EXPECT_CALL(*mGrpcStub, StartSupportedValuesChangeStreamRaw(_, _))
+            .WillOnce(Return(clientReader));
+    EXPECT_CALL(*clientReader, Read(_))
+            .WillOnce(
+                    [testPropId, testAreaId](proto::SupportedValuesChange* supportedValuesChange) {
+                        supportedValuesChange->Clear();
+                        auto propIdAreaId = supportedValuesChange->add_prop_id_area_ids();
+                        propIdAreaId->set_prop_id(testPropId);
+                        propIdAreaId->set_area_id(testAreaId);
+                        return true;
+                    })
+            .WillOnce(Return(false));
+    EXPECT_CALL(*clientReader, Finish()).WillOnce(Return(grpc::Status::OK));
+
+    std::vector<PropIdAreaId> updatedPropIdAreaIds;
+
+    mHardware->registerSupportedValueChangeCallback(
+            std::make_unique<GRPCVehicleHardware::SupportedValueChangeCallback>(
+                    [&updatedPropIdAreaIds](const std::vector<PropIdAreaId>& propIdAreaIds) {
+                        for (const auto& propIdAreaId : propIdAreaIds) {
+                            updatedPropIdAreaIds.push_back(propIdAreaId);
+                        }
+                    }));
+
+    auto status = pollSupportedValuesChange();
+
+    ASSERT_TRUE(status.ok()) << "Status error: " << status.error_message();
+    ASSERT_THAT(updatedPropIdAreaIds, SizeIs(1));
+    EXPECT_EQ(updatedPropIdAreaIds[0].propId, testPropId);
+    EXPECT_EQ(updatedPropIdAreaIds[0].areaId, testAreaId);
+}
+
+TEST_F(GRPCVehicleHardwareUnitTest, TestPollSupportedValuesChange_NotImplemented) {
+    int32_t testPropId = 1234;
+    int32_t testAreaId = 4321;
+    auto status = grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
+
+    // This will be converted to a unique_ptr in StartPropertyValuesStream. The ownership is passed
+    // there.
+    auto clientReader = new MockClientReader<proto::SupportedValuesChange>();
+    EXPECT_CALL(*mGrpcStub, StartSupportedValuesChangeStreamRaw(_, _))
+            .WillOnce(Return(clientReader));
+    EXPECT_CALL(*clientReader, Read(_)).WillOnce(Return(false));
+    EXPECT_CALL(*clientReader, Finish()).WillOnce(Return(status));
+
+    std::vector<PropIdAreaId> updatedPropIdAreaIds;
+
+    mHardware->registerSupportedValueChangeCallback(
+            std::make_unique<GRPCVehicleHardware::SupportedValueChangeCallback>(
+                    [&updatedPropIdAreaIds](const std::vector<PropIdAreaId>& propIdAreaIds) {
+                        for (const auto& propIdAreaId : propIdAreaIds) {
+                            updatedPropIdAreaIds.push_back(propIdAreaId);
+                        }
+                    }));
+
+    auto gotStatus = pollSupportedValuesChange();
+
+    ASSERT_FALSE(status.ok()) << "Status must not be okay";
+    ASSERT_EQ(status.error_code(), grpc::StatusCode::UNIMPLEMENTED);
+}
+
 TEST_F(GRPCVehicleHardwareUnitTest, TestGetValues) {
     int64_t testRequestId = 1234;
     int32_t testPropId = 4321;
diff --git a/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleProxyServerUnitTest.cpp b/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleProxyServerUnitTest.cpp
index c07c62929b..0ed5e66330 100644
--- a/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleProxyServerUnitTest.cpp
+++ b/automotive/vehicle/aidl/impl/current/grpc/test/GRPCVehicleProxyServerUnitTest.cpp
@@ -52,6 +52,17 @@ class VehicleHardwareForTest : public IVehicleHardware {
         }
     }
 
+    void registerSupportedValueChangeCallback(
+            std::unique_ptr<const SupportedValueChangeCallback> callback) override {
+        mOnSupportedValuesChange = std::move(callback);
+    }
+
+    void onSupportedValuesChange(std::vector<PropIdAreaId> propIdAreaIds) {
+        if (mOnSupportedValuesChange) {
+            (*mOnSupportedValuesChange)(propIdAreaIds);
+        }
+    }
+
     // Functions that we do not care.
     std::vector<aidlvhal::VehiclePropConfig> getAllPropertyConfigs() const override { return {}; }
 
@@ -76,6 +87,7 @@ class VehicleHardwareForTest : public IVehicleHardware {
 
   private:
     std::unique_ptr<const PropertyChangeCallback> mOnProp;
+    std::unique_ptr<const SupportedValueChangeCallback> mOnSupportedValuesChange;
 };
 
 class MockVehicleHardware : public IVehicleHardware {
@@ -176,6 +188,65 @@ TEST(GRPCVehicleProxyServerUnitTest, ClientConnectDisconnect) {
     vehicleServer->Shutdown().Wait();
 }
 
+TEST(GRPCVehicleProxyServerUnitTest, RegisterSupportedValuesChange) {
+    int32_t testPropId1 = 123;
+    int32_t testAreaId1 = 234;
+    int32_t testPropId2 = 345;
+    int32_t testAreaId2 = 456;
+
+    auto testHardware = std::make_unique<VehicleHardwareForTest>();
+    // HACK: manipulate the underlying hardware via raw pointer for testing.
+    auto* testHardwareRaw = testHardware.get();
+    auto vehicleServer =
+            std::make_unique<GrpcVehicleProxyServer>(kFakeServerAddr, std::move(testHardware));
+    vehicleServer->Start();
+
+    constexpr auto kWaitForConnectionMaxTime = std::chrono::seconds(5);
+    constexpr auto kWaitForStreamStartTime = std::chrono::seconds(1);
+    constexpr auto kWaitForUpdateDeliveryTime = std::chrono::seconds(1);
+
+    std::vector<PropIdAreaId> changedPropIdAreaIds;
+    std::mutex m;
+    std::condition_variable cv;
+    auto vehicleHardware1 = std::make_unique<GRPCVehicleHardware>(kFakeServerAddr);
+    vehicleHardware1->registerSupportedValueChangeCallback(
+            std::make_unique<const IVehicleHardware::SupportedValueChangeCallback>(
+                    [&changedPropIdAreaIds, &m, &cv](std::vector<PropIdAreaId> propIdAreaIds) {
+                        {
+                            std::lock_guard lk(m);
+                            changedPropIdAreaIds = propIdAreaIds;
+                        }
+                        cv.notify_one();
+                    }));
+
+    EXPECT_TRUE(vehicleHardware1->waitForConnected(kWaitForConnectionMaxTime));
+    std::this_thread::sleep_for(kWaitForStreamStartTime);
+
+    testHardwareRaw->onSupportedValuesChange({PropIdAreaId{
+                                                      .propId = testPropId1,
+                                                      .areaId = testAreaId1,
+                                              },
+                                              PropIdAreaId{
+                                                      .propId = testPropId2,
+                                                      .areaId = testAreaId2,
+                                              }});
+
+    {
+        std::unique_lock lk(m);
+        cv.wait_for(lk, std::chrono::seconds(1),
+                    [&changedPropIdAreaIds] { return !changedPropIdAreaIds.empty(); });
+    }
+
+    // Must make sure we always stop the server even if the test failed.
+    vehicleServer->Shutdown().Wait();
+
+    {
+        std::unique_lock lk(m);
+        ASSERT_FALSE(changedPropIdAreaIds.empty())
+                << "Not received onSupportedValuesChange event before timeout";
+    }
+}
+
 TEST(GRPCVehicleProxyServerUnitTest, Subscribe) {
     auto mockHardware = std::make_unique<MockVehicleHardware>();
     // We make sure this is alive inside the function scope.
diff --git a/automotive/vehicle/aidl/impl/current/proto/Android.bp b/automotive/vehicle/aidl/impl/current/proto/Android.bp
index b12288b115..ebdff6b8c4 100644
--- a/automotive/vehicle/aidl/impl/current/proto/Android.bp
+++ b/automotive/vehicle/aidl/impl/current/proto/Android.bp
@@ -57,6 +57,7 @@ genrule {
         "android/hardware/automotive/vehicle/VehiclePropValueRequest.pb.h",
         "android/hardware/automotive/vehicle/SubscribeOptions.pb.h",
         "android/hardware/automotive/vehicle/SubscribeRequest.pb.h",
+        "android/hardware/automotive/vehicle/SupportedValuesChange.pb.h",
         "android/hardware/automotive/vehicle/UnsubscribeRequest.pb.h",
     ],
 }
@@ -89,6 +90,7 @@ genrule {
         "android/hardware/automotive/vehicle/VehiclePropValueRequest.pb.cc",
         "android/hardware/automotive/vehicle/SubscribeOptions.pb.cc",
         "android/hardware/automotive/vehicle/SubscribeRequest.pb.cc",
+        "android/hardware/automotive/vehicle/SupportedValuesChange.pb.cc",
         "android/hardware/automotive/vehicle/UnsubscribeRequest.pb.cc",
     ],
 }
diff --git a/wifi/supplicant/1.0/vts/functional/VtsHalWifiSupplicantP2pV1_0TargetTest.cpp b/automotive/vehicle/aidl/impl/current/proto/android/hardware/automotive/vehicle/SupportedValuesChange.proto
similarity index 67%
rename from wifi/supplicant/1.0/vts/functional/VtsHalWifiSupplicantP2pV1_0TargetTest.cpp
rename to automotive/vehicle/aidl/impl/current/proto/android/hardware/automotive/vehicle/SupportedValuesChange.proto
index b2bdaf1b40..9ad9610c76 100644
--- a/wifi/supplicant/1.0/vts/functional/VtsHalWifiSupplicantP2pV1_0TargetTest.cpp
+++ b/automotive/vehicle/aidl/impl/current/proto/android/hardware/automotive/vehicle/SupportedValuesChange.proto
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,12 @@
  * limitations under the License.
  */
 
-#include <VtsCoreUtil.h>
-#include "supplicant_hidl_test_utils.h"
+syntax = "proto3";
 
-int main(int argc, char** argv) {
-    ::testing::InitGoogleTest(&argc, argv);
-    return RUN_ALL_TESTS();
-}
+package android.hardware.automotive.vehicle.proto;
+
+import "android/hardware/automotive/vehicle/PropIdAreaId.proto";
+
+message SupportedValuesChange {
+    repeated PropIdAreaId prop_id_area_ids = 1;
+};
diff --git a/automotive/vehicle/aidl/rust_impl/README.md b/automotive/vehicle/aidl/rust_impl/README.md
index 33f996b3e0..5a7853e032 100644
--- a/automotive/vehicle/aidl/rust_impl/README.md
+++ b/automotive/vehicle/aidl/rust_impl/README.md
@@ -1,6 +1,6 @@
-# Rust Skeleton VHAL implementation.
+# Rust Skeleton VHAL V3 implementation.
 
-WARNING: This is not a reference VHAL implementation and does not contain
+WARNING: This is not a reference VHAL V3 implementation and does not contain
 any actual implementation.
 
 This folder contains a skeleton VHAL implementation in Rust to demonstrate
diff --git a/automotive/vehicle/aidl_property/android/hardware/automotive/vehicle/VehicleProperty.aidl b/automotive/vehicle/aidl_property/android/hardware/automotive/vehicle/VehicleProperty.aidl
index cf9ea10da4..cd64afbe6d 100644
--- a/automotive/vehicle/aidl_property/android/hardware/automotive/vehicle/VehicleProperty.aidl
+++ b/automotive/vehicle/aidl_property/android/hardware/automotive/vehicle/VehicleProperty.aidl
@@ -98,7 +98,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     INFO_VIN = 0x0100 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -109,7 +109,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     INFO_MAKE = 0x0101 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -120,7 +120,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     INFO_MODEL = 0x0102 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -130,7 +130,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.YEAR
-     * @version 2
+     * @version 1
      */
     INFO_MODEL_YEAR = 0x0103 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -145,7 +145,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.MILLILITER
-     * @version 2
+     * @version 1
      */
     INFO_FUEL_CAPACITY = 0x0104 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -165,7 +165,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @data_enum FuelType
-     * @version 2
+     * @version 1
      */
     INFO_FUEL_TYPE = 0x0105 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -181,7 +181,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.WATT_HOUR
-     * @version 2
+     * @version 1
      */
     INFO_EV_BATTERY_CAPACITY = 0x0106 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -194,7 +194,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @data_enum EvConnectorType
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     INFO_EV_CONNECTOR_TYPE = 0x0107 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -209,7 +209,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @data_enum PortLocationType
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     INFO_FUEL_DOOR_LOCATION = 0x0108 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -224,7 +224,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @data_enum PortLocationType
-     * @version 2
+     * @version 1
      */
     INFO_EV_PORT_LOCATION = 0x0109 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -235,7 +235,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @data_enum VehicleAreaSeat
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     INFO_DRIVER_SEAT = 0x010A + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -254,7 +254,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.MILLIMETER
-     * @version 2
+     * @version 1
      */
     INFO_EXTERIOR_DIMENSIONS = 0x010B + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -273,7 +273,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @data_enum PortLocationType
-     * @version 2
+     * @version 1
      */
     INFO_MULTI_EV_PORT_LOCATIONS = 0x010C + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -322,7 +322,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.KILOMETER
-     * @version 2
+     * @version 1
      */
     PERF_ODOMETER = 0x0204 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -338,7 +338,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.METER_PER_SEC
-     * @version 2
+     * @version 1
      */
     PERF_VEHICLE_SPEED = 0x0207 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -351,7 +351,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.METER_PER_SEC
-     * @version 2
+     * @version 1
      */
     PERF_VEHICLE_SPEED_DISPLAY = 0x0208 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -367,7 +367,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.DEGREES
-     * @version 2
+     * @version 1
      */
     PERF_STEERING_ANGLE = 0x0209 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -383,7 +383,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.DEGREES
-     * @version 2
+     * @version 1
      */
     PERF_REAR_STEERING_ANGLE = 0x0210 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -425,7 +425,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.CELSIUS
-     * @version 2
+     * @version 1
      */
     ENGINE_COOLANT_TEMP = 0x0301 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -443,7 +443,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleOilLevel
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     ENGINE_OIL_LEVEL = 0x0303 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -453,7 +453,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.CELSIUS
-     * @version 2
+     * @version 1
      */
     ENGINE_OIL_TEMP = 0x0304 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -463,22 +463,23 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.RPM
-     * @version 2
+     * @version 1
      */
     ENGINE_RPM = 0x0305 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
     /**
      * Reports wheel ticks
      *
-     * The first element in the vector is a reset count.  A reset indicates
-     * previous tick counts are not comparable with this and future ones.  Some
-     * sort of discontinuity in tick counting has occurred.
+     * The first element in the vector is a reset count. A reset indicates previous tick counts are
+     * not comparable with this and future ones - some sort of discontinuity in tick counting has
+     * occurred. Conversely, tick measurements must be comparable if their corresponding reset count
+     * is the same. This value must be a monotonically increasing value where each time a reset
+     * happens, the value increases by 1.
      *
-     * The next four elements represent ticks for individual wheels in the
-     * following order: front left, front right, rear right, rear left.  All
-     * tick counts are cumulative.  Tick counts increment when the vehicle
-     * moves forward, and decrement when vehicles moves in reverse.  The ticks
-     * should be reset to 0 when the vehicle is started by the user.
+     * The next four elements represent ticks for individual wheels in the following order: front
+     * left, front right, rear right, rear left. All tick counts are cumulative. Tick counts
+     * increment when the vehicle moves forward, and decrement when vehicles moves in reverse.
+     * The ticks should be reset to 0 when the vehicle is started by the user.
      *
      *  int64Values[0] = reset count
      *  int64Values[1] = front left ticks
@@ -486,8 +487,8 @@ enum VehicleProperty {
      *  int64Values[3] = rear right ticks
      *  int64Values[4] = rear left ticks
      *
-     * configArray is used to indicate the micrometers-per-wheel-tick value and
-     * which wheels are supported.  configArray is set as follows:
+     * configArray is used to indicate the micrometers-per-wheel-tick value and which wheels are
+     * supported. configArray is set as follows:
      *
      *  configArray[0], bits [0:3] = supported wheels. Uses enum Wheel. For example, if all wheels
      *    are supported, then configArray[0] = VehicleAreaWheel::LEFT_FRONT
@@ -498,13 +499,13 @@ enum VehicleProperty {
      *  configArray[3] = micrometers per rear right wheel tick
      *  configArray[4] = micrometers per rear left wheel tick
      *
-     * NOTE:  If a wheel is not supported, its value shall always be set to 0.
+     * NOTE: If a wheel is not supported, its value shall always be set to 0.
      *
      * VehiclePropValue.timestamp must be correctly filled in.
      *
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     WHEEL_TICK = 0x0306 + 0x10000000 + 0x01000000
             + 0x00510000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT64_VEC
@@ -521,7 +522,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.MILLILITER
-     * @version 2
+     * @version 1
      */
     FUEL_LEVEL = 0x0307 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -539,7 +540,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     FUEL_DOOR_OPEN = 0x0308 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -553,7 +554,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.WATT_HOUR
-     * @version 2
+     * @version 1
      */
     EV_BATTERY_LEVEL = 0x0309 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -585,7 +586,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_PORT_OPEN = 0x030A + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -597,7 +598,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_PORT_CONNECTED = 0x030B + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -610,7 +611,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.MILLIWATTS
-     * @version 2
+     * @version 1
      */
     EV_BATTERY_INSTANTANEOUS_CHARGE_RATE = 0x030C + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -629,7 +630,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.METER
-     * @version 2
+     * @version 1
      */
     RANGE_REMAINING = 0x0308 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -690,7 +691,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
      * @unit VehicleUnit.KILOPASCAL
-     * @version 2
+     * @version 1
      */
     TIRE_PRESSURE = 0x0309 + 0x10000000 + 0x07000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WHEEL,VehiclePropertyType:FLOAT
@@ -706,7 +707,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.KILOPASCAL
-     * @version 2
+     * @version 1
      */
     CRITICALLY_LOW_TIRE_PRESSURE = 0x030A + 0x10000000 + 0x07000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WHEEL,VehiclePropertyType:FLOAT
@@ -899,7 +900,7 @@ enum VehicleProperty {
      * @data_enum VehicleGear
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     GEAR_SELECTION = 0x0400 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -934,7 +935,7 @@ enum VehicleProperty {
      * @data_enum VehicleGear
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     CURRENT_GEAR = 0x0401 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -946,7 +947,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     PARKING_BRAKE_ON = 0x0402 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -964,7 +965,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     PARKING_BRAKE_AUTO_APPLY = 0x0403 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -1019,7 +1020,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     FUEL_LEVEL_LOW = 0x0405 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -1032,7 +1033,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     NIGHT_MODE = 0x0407 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -1047,7 +1048,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleTurnSignal
-     * @version 2
+     * @version 1
      */
     TURN_SIGNAL_STATE = 0x0408 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -1065,7 +1066,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleIgnitionState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     IGNITION_STATE = 0x0409 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -1078,7 +1079,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     ABS_ACTIVE = 0x040A + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -1091,7 +1092,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     TRACTION_CONTROL_ACTIVE = 0x040B + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -1312,7 +1313,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     HVAC_FAN_SPEED = 0x0500 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -1333,7 +1334,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleHvacFanDirection
-     * @version 2
+     * @version 1
      */
     HVAC_FAN_DIRECTION = 0x0501 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -1343,7 +1344,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.CELSIUS
-     * @version 2
+     * @version 1
      */
     HVAC_TEMPERATURE_CURRENT = 0x0502 + 0x10000000 + 0x05000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:FLOAT
@@ -1419,7 +1420,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.CELSIUS
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     HVAC_TEMPERATURE_SET = 0x0503 + 0x10000000 + 0x05000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:FLOAT
@@ -1432,7 +1433,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_DEFROSTER = 0x0504 + 0x10000000 + 0x03000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WINDOW,VehiclePropertyType:BOOLEAN
@@ -1445,7 +1446,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_AC_ON = 0x0505 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1463,7 +1464,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_MAX_AC_ON = 0x0506 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1487,7 +1488,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_MAX_DEFROST_ON = 0x0507 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1505,7 +1506,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_RECIRC_ON = 0x0508 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1545,7 +1546,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_DUAL_ON = 0x0509 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1568,7 +1569,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_AUTO_ON = 0x050A + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1603,7 +1604,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     HVAC_SEAT_TEMPERATURE = 0x050B + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -1639,7 +1640,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     HVAC_SIDE_MIRROR_HEAT = 0x050C + 0x10000000 + 0x04000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:MIRROR,VehiclePropertyType:INT32
@@ -1674,7 +1675,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     HVAC_STEERING_WHEEL_HEAT = 0x050D + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -1712,7 +1713,7 @@ enum VehicleProperty {
      * @data_enum VehicleUnit
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     HVAC_TEMPERATURE_DISPLAY_UNITS = 0x050E + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -1721,7 +1722,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_ACTUAL_FAN_SPEED_RPM = 0x050F + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -1768,7 +1769,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_POWER_ON = 0x0510 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1792,7 +1793,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleHvacFanDirection
      * @data_enum_bit_flags
-     * @version 2
+     * @version 1
      */
     HVAC_FAN_DIRECTION_AVAILABLE = 0x0511 + 0x10000000 + 0x05000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32_VEC
@@ -1809,7 +1810,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_AUTO_RECIRC_ON = 0x0512 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -1848,7 +1849,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     HVAC_SEAT_VENTILATION = 0x0513 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -1861,7 +1862,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HVAC_ELECTRIC_DEFROSTER_ON = 0x0514 + 0x10000000 + 0x03000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WINDOW,VehiclePropertyType:BOOLEAN
@@ -1917,7 +1918,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     HVAC_TEMPERATURE_VALUE_SUGGESTION = 0x0515 + 0x10000000 + 0x01000000
             + 0x00610000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT_VEC
@@ -1953,7 +1954,7 @@ enum VehicleProperty {
      * @data_enum VehicleUnit
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     DISTANCE_DISPLAY_UNITS = 0x0600 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -1988,7 +1989,7 @@ enum VehicleProperty {
      * @data_enum VehicleUnit
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     FUEL_VOLUME_DISPLAY_UNITS = 0x0601 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -2024,7 +2025,7 @@ enum VehicleProperty {
      * @data_enum VehicleUnit
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     TIRE_PRESSURE_DISPLAY_UNITS = 0x0602 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -2060,7 +2061,7 @@ enum VehicleProperty {
      * @data_enum VehicleUnit
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     EV_BATTERY_DISPLAY_UNITS = 0x0603 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -2077,7 +2078,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME = 0x0604 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -2112,7 +2113,7 @@ enum VehicleProperty {
      * @data_enum VehicleUnit
      * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     VEHICLE_SPEED_DISPLAY_UNITS = 0x0605 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -2157,7 +2158,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.MILLI_SECS
-     * @version 2
+     * @version 1
      */
     EXTERNAL_CAR_TIME = 0x0608 + 0x10000000 // VehiclePropertyGroup:SYSTEM
             + 0x01000000 // VehicleArea:GLOBAL
@@ -2187,7 +2188,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
      * @unit VehicleUnit.MILLI_SECS
-     * @version 2
+     * @version 1
      */
     ANDROID_EPOCH_TIME = 0x0606 + 0x10000000 + 0x01000000
             + 0x00500000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT64
@@ -2202,7 +2203,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     STORAGE_ENCRYPTION_BINDING_SEED = 0x0607 + 0x10000000 + 0x01000000
             + 0x00700000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BYTES
@@ -2217,7 +2218,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.CELSIUS
-     * @version 2
+     * @version 1
      */
     ENV_OUTSIDE_TEMPERATURE = 0x0703 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -2242,7 +2243,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     AP_POWER_STATE_REQ = 0x0A00 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -2257,7 +2258,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     AP_POWER_STATE_REPORT = 0x0A01 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -2272,7 +2273,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     AP_POWER_BOOTUP_REASON = 0x0A02 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -2300,7 +2301,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     DISPLAY_BRIGHTNESS = 0x0A03 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -2390,7 +2391,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HW_KEY_INPUT = 0x0A10 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -2470,7 +2471,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @data_enum RotaryInputType
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HW_ROTARY_INPUT = 0x0A20 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -2494,7 +2495,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @data_enum CustomInputType
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     HW_CUSTOM_INPUT = 0X0A30 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -2551,7 +2552,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     DOOR_POS = 0x0B00 + 0x10000000 + 0x06000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:DOOR,VehiclePropertyType:INT32
@@ -2588,7 +2589,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     DOOR_MOVE = 0x0B01 + 0x10000000 + 0x06000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:DOOR,VehiclePropertyType:INT32
@@ -2603,7 +2604,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     DOOR_LOCK = 0x0B02 + 0x10000000 + 0x06000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:DOOR,VehiclePropertyType:BOOLEAN
@@ -2661,7 +2662,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     MIRROR_Z_POS = 0x0B40 + 0x10000000 + 0x04000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:MIRROR,VehiclePropertyType:INT32
@@ -2699,7 +2700,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     MIRROR_Z_MOVE = 0x0B41 + 0x10000000 + 0x04000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:MIRROR,VehiclePropertyType:INT32
@@ -2740,7 +2741,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     MIRROR_Y_POS = 0x0B42 + 0x10000000 + 0x04000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:MIRROR,VehiclePropertyType:INT32
@@ -2777,7 +2778,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     MIRROR_Y_MOVE = 0x0B43 + 0x10000000 + 0x04000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:MIRROR,VehiclePropertyType:INT32
@@ -2792,7 +2793,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     MIRROR_LOCK = 0x0B44 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -2807,7 +2808,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     MIRROR_FOLD = 0x0B45 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -2875,7 +2876,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_MEMORY_SELECT = 0x0B80 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -2901,7 +2902,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_MEMORY_SET = 0x0B81 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -2919,7 +2920,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     SEAT_BELT_BUCKLED = 0x0B82 + 0x10000000 + 0x05000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:BOOLEAN
@@ -2957,7 +2958,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_BELT_HEIGHT_POS = 0x0B83 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -2997,7 +2998,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_BELT_HEIGHT_MOVE = 0x0B84 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3034,7 +3035,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_FORE_AFT_POS = 0x0B85 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3073,7 +3074,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_FORE_AFT_MOVE = 0x0B86 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3114,7 +3115,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_BACKREST_ANGLE_1_POS = 0x0B87 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3153,7 +3154,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_BACKREST_ANGLE_1_MOVE = 0x0B88 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3196,7 +3197,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_BACKREST_ANGLE_2_POS = 0x0B89 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3235,7 +3236,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_BACKREST_ANGLE_2_MOVE = 0x0B8A + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3271,7 +3272,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEIGHT_POS = 0x0B8B + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3308,7 +3309,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEIGHT_MOVE = 0x0B8C + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3348,7 +3349,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_DEPTH_POS = 0x0B8D + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3386,7 +3387,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_DEPTH_MOVE = 0x0B8E + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3425,7 +3426,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_TILT_POS = 0x0B8F + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3464,7 +3465,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_TILT_MOVE = 0x0B90 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3501,7 +3502,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_LUMBAR_FORE_AFT_POS = 0x0B91 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3541,7 +3542,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_LUMBAR_FORE_AFT_MOVE = 0x0B92 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3578,7 +3579,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_LUMBAR_SIDE_SUPPORT_POS = 0x0B93 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3618,7 +3619,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_LUMBAR_SIDE_SUPPORT_MOVE = 0x0B94 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3639,7 +3640,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     SEAT_HEADREST_HEIGHT_POS = 0x0B95 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -3719,7 +3720,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEADREST_HEIGHT_MOVE = 0x0B96 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3754,7 +3755,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEADREST_ANGLE_POS = 0x0B97 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3764,8 +3765,8 @@ enum VehicleProperty {
      * The maxInt32Value and minInt32Value in each VehicleAreaConfig must be defined. All integers
      * between minInt32Value and maxInt32Value must be supported.
      *
-     * The minInt32Value represents the maximum movement speed of the seat's headrest while moving
-     * into a shallow position.
+     * The minInt32Value represents the maximum movement speed of the seat's headrest while
+     * reclining.
      *
      * The maxInt32Value represents the maximum movement speed of the seat's headrest while moving
      * into an upright/forward position.
@@ -3794,7 +3795,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEADREST_ANGLE_MOVE = 0x0B98 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3829,7 +3830,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEADREST_FORE_AFT_POS = 0x0B99 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -3869,7 +3870,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     SEAT_HEADREST_FORE_AFT_MOVE = 0x0B9A + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -4221,7 +4222,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleSeatOccupancyState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     SEAT_OCCUPANCY = 0x0BB0 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -4250,9 +4251,9 @@ enum VehicleProperty {
      *  parameter will work with negative values as follows:
      *    Max = sunroof completely open
      *    0 = sunroof closed.
-     *    Min = sunroof vent completely open
+     *    Min = sunroof vent completely vented
      *
-     *    Note that in this mode, 0 indicates the window is closed.
+     *    Note that in all modes, 0 indicates the window is closed.
      *
      * If {@code HasSupportedValueInfo} for a specific area ID is not {@code null}:
      * {@code HasSupportedValueInfo#hasMinSupportedValue} and
@@ -4270,7 +4271,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     WINDOW_POS = 0x0BC0 + 0x10000000 + 0x03000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WINDOW,VehiclePropertyType:INT32
@@ -4324,7 +4325,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @require_min_max_supported_value
-     * @version 2
+     * @version 1
      */
     WINDOW_MOVE = 0x0BC1 + 0x10000000 + 0x03000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WINDOW,VehiclePropertyType:INT32
@@ -4339,7 +4340,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     WINDOW_LOCK = 0x0BC4 + 0x10000000 + 0x03000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:WINDOW,VehiclePropertyType:BOOLEAN
@@ -4706,7 +4707,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     VEHICLE_MAP_SERVICE = 0x0C00 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -4947,7 +4948,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     OBD2_LIVE_FRAME = 0x0D00 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -4974,7 +4975,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     OBD2_FREEZE_FRAME = 0x0D01 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -4992,7 +4993,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     OBD2_FREEZE_FRAME_INFO = 0x0D02 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5015,7 +5016,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     OBD2_FREEZE_FRAME_CLEAR = 0x0D03 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5035,7 +5036,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     HEADLIGHTS_STATE = 0x0E00 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5055,7 +5056,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     HIGH_BEAM_LIGHTS_STATE = 0x0E01 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5091,7 +5092,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     FOG_LIGHTS_STATE = 0x0E02 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5111,7 +5112,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     HAZARD_LIGHTS_STATE = 0x0E03 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5135,7 +5136,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     HEADLIGHTS_SWITCH = 0x0E10 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5159,7 +5160,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     HIGH_BEAM_LIGHTS_SWITCH = 0x0E11 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5199,7 +5200,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     FOG_LIGHTS_SWITCH = 0x0E12 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5223,7 +5224,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     HAZARD_LIGHTS_SWITCH = 0x0E13 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5243,7 +5244,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     CABIN_LIGHTS_STATE = 0x0F01 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5270,7 +5271,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     CABIN_LIGHTS_SWITCH = 0x0F02 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5290,7 +5291,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     READING_LIGHTS_STATE = 0x0F03 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -5317,7 +5318,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     READING_LIGHTS_SWITCH = 0x0F04 + 0x10000000 + 0x05000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:SEAT,VehiclePropertyType:INT32
@@ -5404,7 +5405,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     SUPPORT_CUSTOMIZE_VENDOR_PERMISSION = 0x0F05 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -5421,7 +5422,7 @@ enum VehicleProperty {
      * ex) "com.android.car.user.CarUserNoticeService,storage_monitoring"
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     DISABLED_OPTIONAL_FEATURES = 0x0F06 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -5472,7 +5473,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     INITIAL_USER_INFO = 0x0F07 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5639,7 +5640,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     SWITCH_USER = 0x0F08 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5686,7 +5687,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     CREATE_USER = 0x0F09 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5722,7 +5723,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     REMOVE_USER = 0x0F0A + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5798,7 +5799,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     USER_IDENTIFICATION_ASSOCIATION = 0x0F0B + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5818,7 +5819,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     EVS_SERVICE_REQUEST = 0x0F10 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -5836,7 +5837,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     POWER_POLICY_REQ = 0x0F21 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -5856,7 +5857,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     POWER_POLICY_GROUP_REQ = 0x0F22 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -5869,7 +5870,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
-     * @version 2
+     * @version 1
      */
     CURRENT_POWER_POLICY = 0x0F23 + 0x10000000 + 0x01000000
             + 0x00100000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:STRING
@@ -5881,7 +5882,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     WATCHDOG_ALIVE = 0x0F31 + 0x10000000 + 0x01000000
             + 0x00500000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT64
@@ -5893,7 +5894,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     WATCHDOG_TERMINATED_PROCESS = 0x0F32 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5909,7 +5910,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     VHAL_HEARTBEAT = 0x0F33 + 0x10000000 + 0x01000000
             + 0x00500000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT64
@@ -5923,7 +5924,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     CLUSTER_SWITCH_UI = 0x0F34 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -5948,7 +5949,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     CLUSTER_DISPLAY_STATE = 0x0F35 + 0x10000000 + 0x01000000
             + 0x00410000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32_VEC
@@ -5984,7 +5985,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     CLUSTER_REPORT_STATE = 0x0F36 + 0x10000000 + 0x01000000
             + 0x00e00000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:MIXED
@@ -5999,7 +6000,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     CLUSTER_REQUEST_DISPLAY = 0x0F37 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6010,7 +6011,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.WRITE
-     * @version 2
+     * @version 1
      */
     CLUSTER_NAVIGATION_STATE = 0x0F38 + 0x10000000 + 0x01000000
             + 0x00700000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BYTES
@@ -6032,7 +6033,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum ElectronicTollCollectionCardType
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     ELECTRONIC_TOLL_COLLECTION_CARD_TYPE = 0x0F39 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6055,7 +6056,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum ElectronicTollCollectionCardStatus
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     ELECTRONIC_TOLL_COLLECTION_CARD_STATUS = 0x0F3A + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6077,7 +6078,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     FRONT_FOG_LIGHTS_STATE = 0x0F3B + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6104,7 +6105,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     FRONT_FOG_LIGHTS_SWITCH = 0x0F3C + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6127,7 +6128,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     REAR_FOG_LIGHTS_STATE = 0x0F3D + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6154,7 +6155,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum VehicleLightSwitch
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     REAR_FOG_LIGHTS_SWITCH = 0x0F3E + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6184,7 +6185,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.AMPERE
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_CURRENT_DRAW_LIMIT = 0x0F3F + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -6194,17 +6195,20 @@ enum VehicleProperty {
      *
      * Returns a float value from 0 to 100.
      *
-     * configArray is used to specify the valid values at boot time.
+     * configArray is optional. If not empty, it is used to specify the valid values at boot time.
      *   For example, if the vehicle supports the following charge percent limit values:
      *     [20, 40, 60, 80, 100]
-     *   then the configArray should be {20, 40, 60, 80, 100}
+     *   then the configArray should be {20, 40, 60, 80, 100}.
+     *
      * If the configArray is empty then all values from 0 to 100 must be valid.
      *
-     * If {@code HasSupportedValueInfo} for the global area ID (0) is not {@code null},
-     * {@code HasSupportedValueInfo#hasSupportedValuesList} must be {@code true}.
+     * If {@code HasSupportedValueInfo} for the global area ID (0) is not {@code null} and
+     * if {@code HasSupportedValueInfo#hasSupportedValuesList} is {@code true},
      * {@code SupportedValuesListResult#supportedValuesList} specifies the
      * valid maximum charge percent threshold options at the current moment.
-     * At boot, configArray content must match the supported values list.
+     * If {@code HasSupportedValueInfo#hasSupportedValuesList} is {@code false}, all values from
+     * 0 to 100 must be valid.
+     * At boot, if not empty, configArray content must match the supported values list.
      *
      * If the valid values may change dynamically,
      * {@code HasSupportedValueInfo#hasSupportedValuesList} must be {@code true} and
@@ -6216,9 +6220,8 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @require_supported_values_list
      * @legacy_supported_values_in_config
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_PERCENT_LIMIT = 0x0F40 + 0x10000000 + 0x01000000
             + 0x00600000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:FLOAT
@@ -6243,7 +6246,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum EvChargeState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_STATE = 0x0F41 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6260,7 +6263,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.ON_CHANGE
      * @access VehiclePropertyAccess.READ_WRITE
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_SWITCH = 0x0F42 + 0x10000000 + 0x01000000
             + 0x00200000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:BOOLEAN
@@ -6273,7 +6276,7 @@ enum VehicleProperty {
      * @change_mode VehiclePropertyChangeMode.CONTINUOUS
      * @access VehiclePropertyAccess.READ
      * @unit VehicleUnit.SECS
-     * @version 2
+     * @version 1
      */
     EV_CHARGE_TIME_REMAINING = 0x0F43 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6298,7 +6301,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum EvRegenerativeBrakingState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     EV_REGENERATIVE_BRAKING_STATE = 0x0F44 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6319,7 +6322,7 @@ enum VehicleProperty {
      * @access VehiclePropertyAccess.READ
      * @data_enum TrailerState
      * @require_supported_values_list
-     * @version 2
+     * @version 1
      */
     TRAILER_PRESENT = 0x0F45 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
@@ -6342,7 +6345,7 @@ enum VehicleProperty {
      *
      * @change_mode VehiclePropertyChangeMode.STATIC
      * @access VehiclePropertyAccess.READ
-     * @version 2
+     * @version 1
      */
     VEHICLE_CURB_WEIGHT = 0x0F46 + 0x10000000 + 0x01000000
             + 0x00400000, // VehiclePropertyGroup:SYSTEM,VehicleArea:GLOBAL,VehiclePropertyType:INT32
diff --git a/automotive/vehicle/vts/OWNERS b/automotive/vehicle/vts/OWNERS
index 0f88eecdaf..b910204e8e 100644
--- a/automotive/vehicle/vts/OWNERS
+++ b/automotive/vehicle/vts/OWNERS
@@ -1,3 +1,2 @@
 # Bug component: 533426
-shanyu@google.com
 tylertrephan@google.com
diff --git a/biometrics/OWNERS b/biometrics/OWNERS
index a0a5e51846..2b680dd9f7 100644
--- a/biometrics/OWNERS
+++ b/biometrics/OWNERS
@@ -2,7 +2,6 @@
 
 include platform/frameworks/base:/services/core/java/com/android/server/biometrics/OWNERS
 
-jeffpu@google.com
 jbolinger@google.com
 joshmccloskey@google.com
 diyab@google.com
diff --git a/biometrics/common/config/Config.cpp b/biometrics/common/config/Config.cpp
index 49f7cc8551..5ef2d294b8 100644
--- a/biometrics/common/config/Config.cpp
+++ b/biometrics/common/config/Config.cpp
@@ -79,7 +79,7 @@ ConfigValue Config::parseIntVec(const std::string& value) {
 }
 
 void Config::init() {
-    LOG(INFO) << "calling init()";
+    LOG(INFO) << getSubTag() << "calling init()";
     int len = 0;
     Config::Data* pd = getConfigData(&len);
     for (int i = 0; i < len; i++) {
@@ -96,7 +96,7 @@ bool Config::setParam(const std::string& name, const std::string& value) {
         LOG(FATAL) << "ERROR: setParam unknown config name " << name;
         return false;
     }
-    LOG(INFO) << "setParam name=" << name << "=" << value;
+    LOG(INFO) << getSubTag() << "setParam name=" << name << "=" << value;
 
     it->second.value = (this->*(it->second.parser))(value);
 
@@ -132,7 +132,7 @@ ConfigValue Config::getDefault(const std::string& name) {
 }
 
 bool Config::setInternal(const std::string& name, const ConfigValue& val) {
-    LOG(INFO) << "Config::set " << name << " to " << toString(val);
+    LOG(INFO) << getSubTag() << "Config::set " << name << " to " << toString(val);
     bool res = false;
     auto& data = mMap[name];
 
diff --git a/biometrics/common/config/include/config/Config.h b/biometrics/common/config/include/config/Config.h
index b1affdc435..ca0dfd3a88 100644
--- a/biometrics/common/config/include/config/Config.h
+++ b/biometrics/common/config/include/config/Config.h
@@ -114,6 +114,7 @@ class Config {
         }
         return os.str();
     }
+    virtual std::string getSubTag() { return "Config "; }
 
     ConfigValue parseBool(const std::string& value);
     ConfigValue parseString(const std::string& name);
diff --git a/biometrics/common/util/include/util/Util.h b/biometrics/common/util/include/util/Util.h
index 078669d385..d03c1a93aa 100644
--- a/biometrics/common/util/include/util/Util.h
+++ b/biometrics/common/util/include/util/Util.h
@@ -100,7 +100,7 @@ class Util {
     //
     static bool parseEnrollmentCaptureSingle(const std::string& str,
                                              std::vector<std::vector<int32_t>>& res) {
-        std::vector<int32_t> defaultAcquiredInfo = {1};
+        std::vector<int32_t> defaultAcquiredInfo = {0};
         bool aborted = true;
 
         do {
diff --git a/biometrics/face/aidl/android/hardware/biometrics/face/ISession.aidl b/biometrics/face/aidl/android/hardware/biometrics/face/ISession.aidl
index 0dbf0522f0..ebb1080589 100644
--- a/biometrics/face/aidl/android/hardware/biometrics/face/ISession.aidl
+++ b/biometrics/face/aidl/android/hardware/biometrics/face/ISession.aidl
@@ -450,7 +450,7 @@ interface ISession {
      * HardwareAuthToken is valid. See ISession#generateChallenge. If any of the above checks fail,
      * the framework must be notified using ISessionCallback#onError with Error::UNABLE_TO_PROCESS.
      *
-     * During enrollment, the HAL may notify the framework via ISessionCallback#onAcquired with
+     * During enrollment, the HAL may notify the framework via ISessionCallback#onEnrollmentFrame with
      * messages that may be used to guide the user. This callback can be invoked multiple times if
      * necessary. Similarly, the framework may be notified of enrollment progress changes via
      * ISessionCallback#onEnrollmentProgress. Once the framework is notified that there are 0
@@ -466,7 +466,7 @@ interface ISession {
      *   - ISessionCallback#onEnrollmentProgress(enrollmentId, remaining=0)
      *
      * Other applicable callbacks:
-     *   - ISessionCallback#onAcquired
+     *   - ISessionCallback#onEnrollmentFrame
      *
      * @param FaceEnrollOptions See {@link FaceEnrollOptions} for more detail.
      * @return ICancellationSignal An object that can be used by the framework to cancel this
diff --git a/biometrics/face/aidl/default/FaceConfig.h b/biometrics/face/aidl/default/FaceConfig.h
index 64b62e002d..a1c516c4d4 100644
--- a/biometrics/face/aidl/default/FaceConfig.h
+++ b/biometrics/face/aidl/default/FaceConfig.h
@@ -22,6 +22,7 @@ namespace aidl::android::hardware::biometrics::face {
 
 class FaceConfig : public Config {
     Config::Data* getConfigData(int* size) override;
+    std::string getSubTag() { return "Face "; }
 };
 
 }  // namespace aidl::android::hardware::biometrics::face
diff --git a/biometrics/face/aidl/default/FakeFaceEngine.cpp b/biometrics/face/aidl/default/FakeFaceEngine.cpp
index 70d9f2df70..47f00f610f 100644
--- a/biometrics/face/aidl/default/FakeFaceEngine.cpp
+++ b/biometrics/face/aidl/default/FakeFaceEngine.cpp
@@ -128,13 +128,16 @@ void FakeFaceEngine::enrollImpl(ISessionCallback* cb, const keymaster::HardwareA
             }
             EnrollmentFrame frame = {};
             auto ac = convertAcquiredInfo(acquired[j]);
-            frame.data.acquiredInfo = ac.first;
-            frame.data.vendorCode = ac.second;
-            frame.stage = (i == 0 && j == 0) ? EnrollmentStage::FIRST_FRAME_RECEIVED
-                          : (i == progress.size() - 2 && j == N - 1)
-                                  ? EnrollmentStage::ENROLLMENT_FINISHED
-                                  : EnrollmentStage::WAITING_FOR_CENTERING;
-            cb->onEnrollmentFrame(frame);
+            if (ac.first != AcquiredInfo::UNKNOWN) {
+                frame.data.acquiredInfo = ac.first;
+                frame.data.vendorCode = ac.second;
+
+                frame.stage = (i == 0 && j == 0) ? EnrollmentStage::FIRST_FRAME_RECEIVED
+                              : (i == progress.size() - 2 && j == N - 1)
+                                      ? EnrollmentStage::ENROLLMENT_FINISHED
+                                      : EnrollmentStage::WAITING_FOR_CENTERING;
+                cb->onEnrollmentFrame(frame);
+            }
         }
 
         if (left == 0 && !IS_TRUE(parts[2])) {  // end and failed
@@ -198,19 +201,9 @@ void FakeFaceEngine::authenticateImpl(ISessionCallback* cb, int64_t /*operationI
     int64_t now = Util::getSystemNanoTime();
     int64_t duration = Face::cfg().get<std::int32_t>("operation_authenticate_duration");
     auto acquired = Face::cfg().get<std::string>("operation_authenticate_acquired");
-    if (acquired.empty()) {
-        Face::cfg().set<std::string>("operation_authenticate_acquired", defaultAcquiredInfo);
-        acquired = defaultAcquiredInfo;
-    }
     auto acquiredInfos = Util::parseIntSequence(acquired);
     int N = acquiredInfos.size();
 
-    if (N == 0) {
-        LOG(ERROR) << "Fail to parse authentiate acquired info: " + acquired;
-        cb->onError(Error::UNABLE_TO_PROCESS, 0 /* vendorError */);
-        return;
-    }
-
     if (mLockoutTracker.checkIfLockout(cb)) {
         return;
     }
@@ -255,20 +248,19 @@ void FakeFaceEngine::authenticateImpl(ISessionCallback* cb, int64_t /*operationI
             LOG(INFO) << "AcquiredInfo:" << i << ": (" << (int)ac.first << "," << (int)ac.second
                       << ")";
             i++;
-
-            // the captured face id may change during authentication period
-            auto idnew = Face::cfg().get<std::int32_t>("enrollment_hit");
-            if (id != idnew) {
-                isEnrolled = std::find(enrolls.begin(), enrolls.end(), idnew) != enrolls.end();
-                LOG(INFO) << "enrollment_hit changed from " << id << " to " << idnew;
-                id = idnew;
-                break;
-            }
         }
 
-        SLEEP_MS(duration / N);
+        SLEEP_MS(duration / (N + 1));
     } while (!Util::hasElapsed(now, duration));
 
+    // The captured face id may change after authentication request is made
+    auto idnew = getEnrollmentHit();
+    if (id != idnew) {
+        isEnrolled = std::find(enrolls.begin(), enrolls.end(), idnew) != enrolls.end();
+        LOG(INFO) << "enrollment_hit changed from " << id << " to " << idnew;
+        id = idnew;
+    }
+
     if (id > 0 && isEnrolled) {
         mLockoutTracker.reset();
         cb->onAuthenticationSucceeded(id, {} /* hat */);
@@ -282,6 +274,20 @@ void FakeFaceEngine::authenticateImpl(ISessionCallback* cb, int64_t /*operationI
     }
 }
 
+int32_t FakeFaceEngine::getEnrollmentHit() {
+    int64_t now = Util::getSystemNanoTime();
+    int64_t timeout = 5000LL;
+    int32_t enrollmentHit = -1;
+
+    do {
+        enrollmentHit = Face::cfg().get<std::int32_t>("enrollment_hit");
+        if (enrollmentHit > 0) break;
+        SLEEP_MS(timeout / 10);
+    } while (!Util::hasElapsed(now, timeout));
+
+    return enrollmentHit;
+}
+
 std::pair<AcquiredInfo, int32_t> FakeFaceEngine::convertAcquiredInfo(int32_t code) {
     std::pair<AcquiredInfo, int32_t> res;
     if (code > FACE_ACQUIRED_VENDOR_BASE) {
diff --git a/biometrics/face/aidl/default/FakeFaceEngine.h b/biometrics/face/aidl/default/FakeFaceEngine.h
index b1e1388186..2b36c2cde3 100644
--- a/biometrics/face/aidl/default/FakeFaceEngine.h
+++ b/biometrics/face/aidl/default/FakeFaceEngine.h
@@ -73,6 +73,7 @@ class FakeFaceEngine {
 
   private:
     int32_t getRandomInRange(int32_t bound1, int32_t bound2);
+    int32_t getEnrollmentHit();
     static constexpr int32_t FACE_ACQUIRED_VENDOR_BASE = 1000;
     static constexpr int32_t FACE_ERROR_VENDOR_BASE = 1000;
     std::pair<AcquiredInfo, int32_t> convertAcquiredInfo(int32_t code);
diff --git a/biometrics/fingerprint/aidl/default/Android.bp b/biometrics/fingerprint/aidl/default/Android.bp
index c6ffc5100f..eacc2aaf49 100644
--- a/biometrics/fingerprint/aidl/default/Android.bp
+++ b/biometrics/fingerprint/aidl/default/Android.bp
@@ -17,6 +17,7 @@ cc_library_static {
         "FakeFingerprintEngine.cpp",
         "FakeFingerprintEngineRear.cpp",
         "FakeFingerprintEngineUdfps.cpp",
+        "FakeFingerprintEngineUdfpsUltraSonic.cpp",
         "FakeFingerprintEngineSide.cpp",
         "Fingerprint.cpp",
         "Session.cpp",
@@ -225,6 +226,7 @@ cc_test {
         "VirtualHal.cpp",
         "FakeFingerprintEngineRear.cpp",
         "FakeFingerprintEngineUdfps.cpp",
+        "FakeFingerprintEngineUdfpsUltraSonic.cpp",
         "FakeFingerprintEngineSide.cpp",
         "FakeFingerprintEngine.cpp",
         "FakeLockoutTracker.cpp",
diff --git a/biometrics/fingerprint/aidl/default/FakeFingerprintEngine.cpp b/biometrics/fingerprint/aidl/default/FakeFingerprintEngine.cpp
index 175e3100dd..00e14d7983 100644
--- a/biometrics/fingerprint/aidl/default/FakeFingerprintEngine.cpp
+++ b/biometrics/fingerprint/aidl/default/FakeFingerprintEngine.cpp
@@ -166,7 +166,9 @@ bool FakeFingerprintEngine::onEnrollFingerDown(ISessionCallback* cb,
                 return true;
             }
             auto ac = convertAcquiredInfo(acquired[j]);
-            cb->onAcquired(ac.first, ac.second);
+            if (ac.first != AcquiredInfo::UNKNOWN) {
+                cb->onAcquired(ac.first, ac.second);
+            }
         }
 
         if (left == 0 && !IS_TRUE(parts[2])) {  // end and failed
@@ -204,12 +206,6 @@ bool FakeFingerprintEngine::onAuthenticateFingerDown(ISessionCallback* cb,
     auto acquiredInfos = Util::parseIntSequence(acquired);
     int N = acquiredInfos.size();
 
-    if (N == 0) {
-        LOG(ERROR) << "Fail to parse authentiate acquired info: " + acquired;
-        cb->onError(Error::UNABLE_TO_PROCESS, 0 /* vendorError */);
-        return true;
-    }
-
     // got lockout?
     if (checkSensorLockout(cb)) {
         return FakeLockoutTracker::LockoutMode::kPermanent == mLockoutTracker.getMode();
@@ -248,11 +244,13 @@ bool FakeFingerprintEngine::onAuthenticateFingerDown(ISessionCallback* cb,
 
         if (i < N) {
             auto ac = convertAcquiredInfo(acquiredInfos[i]);
-            cb->onAcquired(ac.first, ac.second);
+            if (ac.first != AcquiredInfo::UNKNOWN) {
+                cb->onAcquired(ac.first, ac.second);
+            }
             i++;
         }
 
-        SLEEP_MS(duration / N);
+        SLEEP_MS(duration / (N + 1));
     } while (!Util::hasElapsed(now, duration));
 
     auto id = Fingerprint::cfg().get<std::int32_t>("enrollment_hit");
@@ -284,12 +282,6 @@ bool FakeFingerprintEngine::onDetectInteractFingerDown(ISessionCallback* cb,
     int N = acquiredInfos.size();
     int64_t now = Util::getSystemNanoTime();
 
-    if (N == 0) {
-        LOG(ERROR) << "Fail to parse detect interaction acquired info: " + acquired;
-        cb->onError(Error::UNABLE_TO_PROCESS, 0 /* vendorError */);
-        return true;
-    }
-
     int i = 0;
     do {
         auto err = Fingerprint::cfg().get<std::int32_t>("operation_detect_interaction_error");
@@ -311,7 +303,7 @@ bool FakeFingerprintEngine::onDetectInteractFingerDown(ISessionCallback* cb,
             cb->onAcquired(ac.first, ac.second);
             i++;
         }
-        SLEEP_MS(duration / N);
+        SLEEP_MS(duration / (N + 1));
     } while (!Util::hasElapsed(now, duration));
 
     cb->onInteractionDetected();
diff --git a/biometrics/fingerprint/aidl/default/FakeFingerprintEngineUdfpsUltraSonic.cpp b/biometrics/fingerprint/aidl/default/FakeFingerprintEngineUdfpsUltraSonic.cpp
new file mode 100644
index 0000000000..9d0faea86d
--- /dev/null
+++ b/biometrics/fingerprint/aidl/default/FakeFingerprintEngineUdfpsUltraSonic.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "FakeFingerprintEngineUdfpsUltraSonic.h"
+
+#include <android-base/logging.h>
+
+#include <fingerprint.sysprop.h>
+
+#include "Fingerprint.h"
+#include "util/CancellationSignal.h"
+#include "util/Util.h"
+
+#undef LOG_TAG
+#define LOG_TAG "FingerprintVirtualHalUdfpsUltraSonic"
+
+using namespace ::android::fingerprint::virt;
+
+namespace aidl::android::hardware::biometrics::fingerprint {
+
+FakeFingerprintEngineUdfpsUltraSonic::FakeFingerprintEngineUdfpsUltraSonic()
+    : FakeFingerprintEngineUdfps() {}
+
+ndk::ScopedAStatus FakeFingerprintEngineUdfpsUltraSonic::onPointerDownImpl(
+        int32_t /*pointerId*/, int32_t /*x*/, int32_t /*y*/, float /*minor*/, float /*major*/) {
+    BEGIN_OP(0);
+
+    // UltraSonic sensor does not need illumination, so fingerprint capture can start on
+    //   PointerDown action rather UiReady action which is required for optical sensor
+    fingerDownAction();
+
+    return ndk::ScopedAStatus::ok();
+}
+
+}  // namespace aidl::android::hardware::biometrics::fingerprint
diff --git a/biometrics/fingerprint/aidl/default/Fingerprint.cpp b/biometrics/fingerprint/aidl/default/Fingerprint.cpp
index 6d39e12c00..715cbb5a58 100644
--- a/biometrics/fingerprint/aidl/default/Fingerprint.cpp
+++ b/biometrics/fingerprint/aidl/default/Fingerprint.cpp
@@ -52,7 +52,7 @@ Fingerprint::Fingerprint() : mWorker(MAX_WORKER_QUEUE_SIZE) {
         mEngine = std::make_unique<FakeFingerprintEngineUdfps>();
     } else if (sensorTypeProp == "udfps-us") {
         mSensorType = FingerprintSensorType::UNDER_DISPLAY_ULTRASONIC;
-        mEngine = std::make_unique<FakeFingerprintEngineUdfps>();
+        mEngine = std::make_unique<FakeFingerprintEngineUdfpsUltraSonic>();
     } else if (sensorTypeProp == "side") {
         mSensorType = FingerprintSensorType::POWER_BUTTON;
         mEngine = std::make_unique<FakeFingerprintEngineSide>();
diff --git a/biometrics/fingerprint/aidl/default/FingerprintConfig.cpp b/biometrics/fingerprint/aidl/default/FingerprintConfig.cpp
index 2a87a55819..f0e18777cc 100644
--- a/biometrics/fingerprint/aidl/default/FingerprintConfig.cpp
+++ b/biometrics/fingerprint/aidl/default/FingerprintConfig.cpp
@@ -82,13 +82,13 @@ static Config::Data configData[] = {
         {NGS(operation_authenticate_latency), &Config::parseIntVec, ""},
         {NGS(operation_authenticate_duration), &Config::parseInt32, "10"},
         {NGS(operation_authenticate_error), &Config::parseInt32, "0"},
-        {NGS(operation_authenticate_acquired), &Config::parseString, "1"},
+        {NGS(operation_authenticate_acquired), &Config::parseString, ""},
         {NGS(operation_enroll_error), &Config::parseInt32, "0"},
         {NGS(operation_enroll_latency), &Config::parseIntVec, ""},
         {NGS(operation_detect_interaction_latency), &Config::parseIntVec, ""},
         {NGS(operation_detect_interaction_error), &Config::parseInt32, "0"},
         {NGS(operation_detect_interaction_duration), &Config::parseInt32, "10"},
-        {NGS(operation_detect_interaction_acquired), &Config::parseString, "1"},
+        {NGS(operation_detect_interaction_acquired), &Config::parseString, ""},
         {NGS(max_enrollments), &Config::parseInt32, "5"},
         {NGS(navigation_gesture), &Config::parseBool, "false"},
         {NGS(detect_interaction), &Config::parseBool, "false"},
diff --git a/biometrics/fingerprint/aidl/default/include/FakeFingerprintEngineUdfpsUltraSonic.h b/biometrics/fingerprint/aidl/default/include/FakeFingerprintEngineUdfpsUltraSonic.h
new file mode 100644
index 0000000000..37440f291f
--- /dev/null
+++ b/biometrics/fingerprint/aidl/default/include/FakeFingerprintEngineUdfpsUltraSonic.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+#include "FakeFingerprintEngineUdfps.h"
+
+using namespace ::aidl::android::hardware::biometrics::common;
+
+namespace aidl::android::hardware::biometrics::fingerprint {
+
+// A fake engine that is backed by system properties instead of hardware.
+class FakeFingerprintEngineUdfpsUltraSonic : public FakeFingerprintEngineUdfps {
+  public:
+    FakeFingerprintEngineUdfpsUltraSonic();
+    ~FakeFingerprintEngineUdfpsUltraSonic() {}
+    ndk::ScopedAStatus onPointerDownImpl(int32_t pointerId, int32_t x, int32_t y, float minor,
+                                         float major) override;
+};
+
+}  // namespace aidl::android::hardware::biometrics::fingerprint
diff --git a/biometrics/fingerprint/aidl/default/include/Fingerprint.h b/biometrics/fingerprint/aidl/default/include/Fingerprint.h
index 90f89cbe02..7308335fe0 100644
--- a/biometrics/fingerprint/aidl/default/include/Fingerprint.h
+++ b/biometrics/fingerprint/aidl/default/include/Fingerprint.h
@@ -22,6 +22,7 @@
 #include "FakeFingerprintEngineRear.h"
 #include "FakeFingerprintEngineSide.h"
 #include "FakeFingerprintEngineUdfps.h"
+#include "FakeFingerprintEngineUdfpsUltraSonic.h"
 
 #include "FingerprintConfig.h"
 #include "Session.h"
diff --git a/biometrics/fingerprint/aidl/default/include/FingerprintConfig.h b/biometrics/fingerprint/aidl/default/include/FingerprintConfig.h
index bd1ad4c904..9d208ca785 100644
--- a/biometrics/fingerprint/aidl/default/include/FingerprintConfig.h
+++ b/biometrics/fingerprint/aidl/default/include/FingerprintConfig.h
@@ -22,6 +22,7 @@ namespace aidl::android::hardware::biometrics::fingerprint {
 
 class FingerprintConfig : public Config {
     Config::Data* getConfigData(int* size) override;
+    std::string getSubTag() { return "Fingerprint "; }
 };
 
 }  // namespace aidl::android::hardware::biometrics::fingerprint
diff --git a/biometrics/fingerprint/aidl/default/tests/FakeFingerprintEngineTest.cpp b/biometrics/fingerprint/aidl/default/tests/FakeFingerprintEngineTest.cpp
index 039f25ea82..afcb6a2757 100644
--- a/biometrics/fingerprint/aidl/default/tests/FakeFingerprintEngineTest.cpp
+++ b/biometrics/fingerprint/aidl/default/tests/FakeFingerprintEngineTest.cpp
@@ -183,7 +183,7 @@ TEST_F(FakeFingerprintEngineTest, AuthenticatorIdInvalidate) {
 
 TEST_F(FakeFingerprintEngineTest, Enroll) {
     Fingerprint::cfg().setopt<OptIntVec>("enrollments", {});
-    Fingerprint::cfg().set<std::string>("next_enrollment", "4:0,0:true");
+    Fingerprint::cfg().set<std::string>("next_enrollment", "4:0-[1],0:true");
     keymaster::HardwareAuthToken hat{.mac = {2, 4}};
     mEngine.notifyFingerdown();
     mEngine.enrollImpl(mCallback.get(), hat, mCancel.get_future());
@@ -238,7 +238,7 @@ TEST_F(FakeFingerprintEngineTest, EnrollAcquired) {
     ASSERT_EQ(1, Fingerprint::cfg().getopt<OptIntVec>("enrollments").size());
     ASSERT_EQ(4, Fingerprint::cfg().getopt<OptIntVec>("enrollments")[0].value());
     ASSERT_EQ(4, mCallback->mLastEnrolled);
-    ASSERT_EQ(prevCnt + 3, mCallback->mLastAcquiredCount);
+    ASSERT_EQ(prevCnt + 2, mCallback->mLastAcquiredCount);
     ASSERT_EQ(7, mCallback->mLastAcquiredInfo);
     ASSERT_EQ(13, mCallback->mLastAcquiredVendorCode);
 }
@@ -252,7 +252,7 @@ TEST_F(FakeFingerprintEngineTest, Authenticate) {
     mEngine.fingerDownAction();
     ASSERT_FALSE(mCallback->mAuthenticateFailed);
     ASSERT_EQ(2, mCallback->mLastAuthenticated);
-    ASSERT_EQ(1, mCallback->mLastAcquiredInfo);
+    ASSERT_EQ(-1, mCallback->mLastAcquiredInfo);
     ASSERT_EQ(mEngine.getWorkMode(), FakeFingerprintEngine::WorkMode::kIdle);
 }
 
@@ -344,7 +344,7 @@ TEST_F(FakeFingerprintEngineTest, InteractionDetect) {
     Fingerprint::cfg().set<bool>("detect_interaction", true);
     Fingerprint::cfg().setopt<OptIntVec>("enrollments", {1, 2});
     Fingerprint::cfg().set<std::int32_t>("enrollment_hit", 2);
-    Fingerprint::cfg().set<std::string>("operation_detect_interaction_acquired", "");
+    Fingerprint::cfg().set<std::string>("operation_detect_interaction_acquired", "1");
     mEngine.notifyFingerdown();
     mEngine.detectInteractionImpl(mCallback.get(), mCancel.get_future());
     ASSERT_EQ(mEngine.getWorkMode(), FakeFingerprintEngine::WorkMode::kDetectInteract);
@@ -465,7 +465,7 @@ TEST_F(FakeFingerprintEngineTest, parseEnrollmentCaptureOk) {
     ecV = Util::parseEnrollmentCapture("100,200,300");
     ASSERT_EQ(6, ecV.size());
     std::vector<std::vector<int32_t>> expE{{100}, {200}, {300}};
-    std::vector<int32_t> defC{1};
+    std::vector<int32_t> defC{0};
     for (int i = 0; i < ecV.size(); i += 2) {
         ASSERT_EQ(expE[i / 2], ecV[i]);
         ASSERT_EQ(defC, ecV[i + 1]);
@@ -483,7 +483,7 @@ TEST_F(FakeFingerprintEngineTest, parseEnrollmentCaptureOk) {
         ASSERT_EQ(expC, ecV[i + 1]);
     }
     ecV = Util::parseEnrollmentCapture("100-[5,6,7], 200, 300-[9,10]");
-    std::vector<std::vector<int32_t>> expC1{{5, 6, 7}, {1}, {9, 10}};
+    std::vector<std::vector<int32_t>> expC1{{5, 6, 7}, {0}, {9, 10}};
     ASSERT_EQ(6, ecV.size());
     for (int i = 0; i < ecV.size(); i += 2) {
         ASSERT_EQ(expE[i / 2], ecV[i]);
diff --git a/bluetooth/audio/aidl/default/A2dpOffloadCodecAac.cpp b/bluetooth/audio/aidl/default/A2dpOffloadCodecAac.cpp
index 1570cd8e4f..14e8428afd 100644
--- a/bluetooth/audio/aidl/default/A2dpOffloadCodecAac.cpp
+++ b/bluetooth/audio/aidl/default/A2dpOffloadCodecAac.cpp
@@ -31,7 +31,7 @@ enum : bool {
 
 enum : bool {
   kEnableSamplingFrequency44100 = true,
-  kEnableSamplingFrequency48000 = true,
+  kEnableSamplingFrequency48000 = false,
   kEnableSamplingFrequency88200 = false,
   kEnableSamplingFrequency96000 = false,
 };
diff --git a/bluetooth/audio/aidl/default/Android.bp b/bluetooth/audio/aidl/default/Android.bp
index af6bf86ddf..c2cc681dad 100644
--- a/bluetooth/audio/aidl/default/Android.bp
+++ b/bluetooth/audio/aidl/default/Android.bp
@@ -12,6 +12,7 @@ cc_library_shared {
     vendor: true,
     vintf_fragments: ["bluetooth_audio.xml"],
     defaults: [
+        "aconfig_lib_cc_static_link.defaults",
         "latest_android_hardware_bluetooth_audio_ndk_shared",
     ],
     srcs: [
@@ -38,6 +39,10 @@ cc_library_shared {
         "libfmq",
         "liblog",
         "libbluetooth_audio_session_aidl",
+        "server_configurable_flags",
+    ],
+    static_libs: [
+        "btaudiohal_flags_c_lib",
     ],
 }
 
diff --git a/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.cpp b/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.cpp
index 3d7c37676b..96a1382e85 100644
--- a/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.cpp
+++ b/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.cpp
@@ -14,13 +14,15 @@
  * limitations under the License.
  */
 
+#include "aidl/android/hardware/bluetooth/audio/CodecId.h"
 #define LOG_TAG "BTAudioProviderLeAudioHW"
 
-#include "LeAudioOffloadAudioProvider.h"
-
 #include <BluetoothAudioCodecs.h>
 #include <BluetoothAudioSessionReport.h>
 #include <android-base/logging.h>
+#include <com_android_btaudio_hal_flags.h>
+
+#include "LeAudioOffloadAudioProvider.h"
 
 namespace aidl {
 namespace android {
@@ -33,6 +35,14 @@ constexpr uint8_t kLeAudioDirectionSource = 0x02;
 constexpr uint8_t kIsoDataPathHci = 0x00;
 constexpr uint8_t kIsoDataPathPlatformDefault = 0x01;
 
+constexpr uint16_t kLeAudioVendorCompanyIdGoogle = 0x00E0;
+constexpr uint16_t kLeAudioVendorCodecIdOpus = 0x0001;
+
+const CodecId::Vendor opus_codec{
+    .codecId = kLeAudioVendorCodecIdOpus,
+    .id = kLeAudioVendorCompanyIdGoogle,
+};
+
 const std::map<CodecSpecificConfigurationLtv::SamplingFrequency, uint32_t>
     freq_to_support_bitmask_map = {
         {CodecSpecificConfigurationLtv::SamplingFrequency::HZ8000,
@@ -100,6 +110,30 @@ std::map<int32_t, CodecSpecificConfigurationLtv::FrameDuration>
         {10000, CodecSpecificConfigurationLtv::FrameDuration::US10000},
 };
 
+bool isOpusCodec(const LeAudioAseConfiguration& ase) {
+  if (ase.codecId.has_value() &&
+      ase.codecId.value().getTag() == CodecId::vendor) {
+    auto cid = ase.codecId.value().get<CodecId::vendor>();
+    return cid == opus_codec;
+  }
+  return false;
+}
+
+bool isOpusHiResCodec(const LeAudioAseConfiguration& ase) {
+  if (isOpusCodec(ase)) {
+    for (auto ltv : ase.codecConfiguration) {
+      // Base on sampling frequency
+      if (ltv.getTag() == CodecSpecificConfigurationLtv::samplingFrequency) {
+        if (ltv.get<CodecSpecificConfigurationLtv::samplingFrequency>() ==
+            CodecSpecificConfigurationLtv::SamplingFrequency::HZ96000) {
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+
 LeAudioOffloadOutputAudioProvider::LeAudioOffloadOutputAudioProvider()
     : LeAudioOffloadAudioProvider() {
   session_type_ = SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH;
@@ -346,11 +380,16 @@ bool LeAudioOffloadAudioProvider::filterMatchedAseConfiguration(
     }
   }
 
-  if (requirement_cfg.targetLatency !=
-          LeAudioAseConfiguration::TargetLatency::UNDEFINED &&
-      setting_cfg.targetLatency != requirement_cfg.targetLatency) {
-    return false;
+  if (isOpusCodec(setting_cfg)) {
+    LOG(INFO) << __func__ << ": ignore target latency for vendor codec.";
+  } else {
+    if (requirement_cfg.targetLatency !=
+            LeAudioAseConfiguration::TargetLatency::UNDEFINED &&
+        setting_cfg.targetLatency != requirement_cfg.targetLatency) {
+      return false;
+    }
   }
+
   // Ignore PHY requirement
 
   // Check all codec configuration
@@ -409,11 +448,21 @@ void LeAudioOffloadAudioProvider::filterCapabilitiesAseDirectionConfiguration(
             direction_configuration.value().aseConfiguration.codecId.value(),
             capabilities.codecId))
       continue;
+    if (direction_configuration.value()
+            .aseConfiguration.codecId.value()
+            .getTag() == CodecId::vendor) {
+      LOG(DEBUG) << __func__ << ": vendor codec capability matched, config = "
+                 << direction_configuration.value().aseConfiguration.toString()
+                 << ", cap = " << capabilities.toString();
+      valid_direction_configurations.push_back(direction_configuration);
+      continue;
+    }
     // Check matching for codec configuration <=> codec capabilities
     if (!isCapabilitiesMatchedCodecConfiguration(
             direction_configuration.value().aseConfiguration.codecConfiguration,
             capabilities.codecSpecificCapabilities))
       continue;
+    // Matched case, add the configuration for this direction.
     valid_direction_configurations.push_back(direction_configuration);
   }
 }
@@ -494,6 +543,120 @@ std::vector<AseDirectionConfiguration> getValidConfigurationsFromAllocation(
   return {};
 }
 
+void LeAudioOffloadAudioProvider::
+    filterRequirementAseDirectionConfigurationExact(
+        std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+            direction_configurations,
+        const std::vector<std::optional<AseDirectionRequirement>>& requirements,
+        std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+            valid_direction_configurations) {
+  // Exact matching process
+  // Need to respect the number of device
+  for (int i = 0; i < requirements.size(); ++i) {
+    auto requirement = requirements[i];
+    auto direction_configuration = direction_configurations.value()[i];
+    if (!direction_configuration.has_value()) {
+      valid_direction_configurations = std::nullopt;
+      return;
+    }
+    auto cfg = direction_configuration.value();
+    if (!com::android::btaudio::hal::flags::leaudio_sw_offload() &&
+        isOpusHiResCodec(cfg.aseConfiguration)) {
+      LOG(DEBUG) << ": Ignore opus high res codec";
+      valid_direction_configurations = std::nullopt;
+      return;
+    }
+    if (!filterMatchedAseConfiguration(cfg.aseConfiguration,
+                                       requirement.value().aseConfiguration)) {
+      valid_direction_configurations = std::nullopt;
+      return;  // No way to match
+    }
+    // Ignore allocation match if setting is a vendor codec.
+    if (cfg.aseConfiguration.codecId.has_value() &&
+        cfg.aseConfiguration.codecId.value().getTag() == CodecId::vendor) {
+      valid_direction_configurations.value().push_back(cfg);
+      LOG(INFO) << __func__ << ": ignore allocation for vendor codec.";
+      continue;
+    }
+    // For exact match, we require this direction to have the same allocation.
+    // If stereo, need stereo.
+    // If mono, need mono (modified to the correct required allocation)
+    auto req_allocation_bitmask = getLeAudioAseConfigurationAllocationBitmask(
+        requirement.value().aseConfiguration);
+    int req_channel_count = getCountFromBitmask(req_allocation_bitmask);
+    int cfg_bitmask =
+        getLeAudioAseConfigurationAllocationBitmask(cfg.aseConfiguration);
+    int cfg_channel_count = getCountFromBitmask(cfg_bitmask);
+    if (req_channel_count <= 1) {
+      // MONO case, is a match if also mono, modify to the same allocation
+      if (cfg_channel_count > 1) {
+        valid_direction_configurations = std::nullopt;
+        return;  // Not a match
+      }
+      // Modify the bitmask to be the same as the requirement
+      for (auto& codec_cfg : cfg.aseConfiguration.codecConfiguration) {
+        if (codec_cfg.getTag() ==
+            CodecSpecificConfigurationLtv::Tag::audioChannelAllocation) {
+          codec_cfg
+              .get<CodecSpecificConfigurationLtv::Tag::audioChannelAllocation>()
+              .bitmask = req_allocation_bitmask;
+          break;
+        }
+      }
+    } else {
+      // STEREO case, is a match if same allocation
+      if (req_allocation_bitmask != cfg_bitmask) {
+        valid_direction_configurations = std::nullopt;
+        return;  // Not a match
+      }
+    }
+    // Push to list if valid
+    valid_direction_configurations.value().push_back(cfg);
+  }
+}
+
+void LeAudioOffloadAudioProvider::
+    filterRequirementAseDirectionConfigurationLoose(
+        std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+            direction_configurations,
+        const std::vector<std::optional<AseDirectionRequirement>>& requirements,
+        std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+            valid_direction_configurations) {
+  // Loose matching process
+  for (auto& requirement : requirements) {
+    if (!requirement.has_value()) continue;
+    auto req_allocation_bitmask = getLeAudioAseConfigurationAllocationBitmask(
+        requirement.value().aseConfiguration);
+    auto req_channel_count = getCountFromBitmask(req_allocation_bitmask);
+
+    auto temp = std::vector<AseDirectionConfiguration>();
+
+    for (auto direction_configuration : direction_configurations.value()) {
+      if (!direction_configuration.has_value()) continue;
+      if (!filterMatchedAseConfiguration(
+              direction_configuration.value().aseConfiguration,
+              requirement.value().aseConfiguration))
+        continue;
+      // Valid if match any requirement.
+      temp.push_back(direction_configuration.value());
+    }
+
+    // Get the best matching config based on channel allocation
+    auto total_cfg_channel_count = 0;
+    auto req_valid_configs = getValidConfigurationsFromAllocation(
+        req_allocation_bitmask, temp, false);
+    // Count and check required channel counts
+    for (auto& cfg : req_valid_configs) {
+      total_cfg_channel_count += getCountFromBitmask(
+          getLeAudioAseConfigurationAllocationBitmask(cfg.aseConfiguration));
+      valid_direction_configurations.value().push_back(cfg);
+    }
+    if (total_cfg_channel_count != req_channel_count) {
+      valid_direction_configurations = std::nullopt;
+      return;
+    }
+  }
+}
 // Check and filter each index to see if it's a match.
 void LeAudioOffloadAudioProvider::filterRequirementAseDirectionConfiguration(
     std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
@@ -510,92 +673,11 @@ void LeAudioOffloadAudioProvider::filterRequirementAseDirectionConfiguration(
   }
 
   if (isExact) {
-    // Exact matching process
-    // Need to respect the number of device
-    for (int i = 0; i < requirements.size(); ++i) {
-      auto requirement = requirements[i];
-      auto direction_configuration = direction_configurations.value()[i];
-      if (!direction_configuration.has_value()) {
-        valid_direction_configurations = std::nullopt;
-        return;
-      }
-      auto cfg = direction_configuration.value();
-      if (!filterMatchedAseConfiguration(
-              cfg.aseConfiguration, requirement.value().aseConfiguration)) {
-        valid_direction_configurations = std::nullopt;
-        return;  // No way to match
-      }
-      // For exact match, we require this direction to have the same allocation.
-      // If stereo, need stereo.
-      // If mono, need mono (modified to the correct required allocation)
-      auto req_allocation_bitmask = getLeAudioAseConfigurationAllocationBitmask(
-          requirement.value().aseConfiguration);
-      int req_channel_count = getCountFromBitmask(req_allocation_bitmask);
-      int cfg_bitmask =
-          getLeAudioAseConfigurationAllocationBitmask(cfg.aseConfiguration);
-      int cfg_channel_count = getCountFromBitmask(cfg_bitmask);
-      if (req_channel_count <= 1) {
-        // MONO case, is a match if also mono, modify to the same allocation
-        if (cfg_channel_count > 1) {
-          valid_direction_configurations = std::nullopt;
-          return;  // Not a match
-        }
-        // Modify the bitmask to be the same as the requirement
-        for (auto& codec_cfg : cfg.aseConfiguration.codecConfiguration) {
-          if (codec_cfg.getTag() ==
-              CodecSpecificConfigurationLtv::Tag::audioChannelAllocation) {
-            codec_cfg
-                .get<CodecSpecificConfigurationLtv::Tag::
-                         audioChannelAllocation>()
-                .bitmask = req_allocation_bitmask;
-            break;
-          }
-        }
-      } else {
-        // STEREO case, is a match if same allocation
-        if (req_allocation_bitmask != cfg_bitmask) {
-          valid_direction_configurations = std::nullopt;
-          return;  // Not a match
-        }
-      }
-      // Push to list if valid
-      valid_direction_configurations.value().push_back(cfg);
-    }
+    filterRequirementAseDirectionConfigurationExact(
+        direction_configurations, requirements, valid_direction_configurations);
   } else {
-    // Loose matching process
-    for (auto& requirement : requirements) {
-      if (!requirement.has_value()) continue;
-      auto req_allocation_bitmask = getLeAudioAseConfigurationAllocationBitmask(
-          requirement.value().aseConfiguration);
-      auto req_channel_count = getCountFromBitmask(req_allocation_bitmask);
-
-      auto temp = std::vector<AseDirectionConfiguration>();
-
-      for (auto direction_configuration : direction_configurations.value()) {
-        if (!direction_configuration.has_value()) continue;
-        if (!filterMatchedAseConfiguration(
-                direction_configuration.value().aseConfiguration,
-                requirement.value().aseConfiguration))
-          continue;
-        // Valid if match any requirement.
-        temp.push_back(direction_configuration.value());
-      }
-
-      // Get the best matching config based on channel allocation
-      auto total_cfg_channel_count = 0;
-      auto req_valid_configs = getValidConfigurationsFromAllocation(
-          req_allocation_bitmask, temp, isExact);
-      // Count and check required channel counts
-      for (auto& cfg : req_valid_configs) {
-        total_cfg_channel_count += getCountFromBitmask(
-            getLeAudioAseConfigurationAllocationBitmask(cfg.aseConfiguration));
-        valid_direction_configurations.value().push_back(cfg);
-      }
-      if (total_cfg_channel_count != req_channel_count) {
-        valid_direction_configurations = std::nullopt;
-        return;
-      }
-    }
+    filterRequirementAseDirectionConfigurationLoose(
+        direction_configurations, requirements, valid_direction_configurations);
   }
 }
 
@@ -740,9 +822,9 @@ LeAudioOffloadAudioProvider::matchWithRequirement(
     // Try to match configuration flags
     if (isMatchFlags) {
       if (!setting.flags.has_value()) continue;
-      if ((setting.flags.value().bitmask & requirement_flags_bitmask) !=
-          requirement_flags_bitmask)
-        continue;
+      // Flag matching is a strict match.
+      // This prevent configuration meanted for other usecases to be matched.
+      if (setting.flags.value().bitmask != requirement_flags_bitmask) continue;
       LOG(DEBUG) << __func__
                  << ": Setting with matched flags: name: " << setting_name
                  << ", setting: " << setting.toString();
@@ -848,15 +930,13 @@ ndk::ScopedAStatus LeAudioOffloadAudioProvider::getLeAudioAseConfiguration(
     // If we cannot match, return an empty result.
 
     // Matching priority list:
-    // Matched configuration flags, i.e. for asymmetric requirement.
-    // Preferred context - exact match with allocation
-    // Preferred context - loose match with allocation
-    // Any context - exact match with allocation
-    // Any context - loose match with allocation
+    // Exact match with allocation: strict matching for the correct topology.
+    // Preferred context: Prefer the correct context to get the best config.
+    // Matched configuration flags: Prefer the config for supported usecases.
     bool found = false;
-    for (bool match_flag : {true, false}) {
+    for (bool match_exact : {true, false}) {
       for (bool match_context : {true, false}) {
-        for (bool match_exact : {true, false}) {
+        for (bool match_flag : {true, false}) {
           auto matched_setting = matchWithRequirement(
               matched_ase_configuration_settings, requirement, match_context,
               match_exact, match_flag);
@@ -1382,7 +1462,8 @@ LeAudioOffloadAudioProvider::getLeAudioBroadcastConfiguration(
   }
 
   // Broadcast setting are from provider info
-  // We will allow empty capability input, match all settings with requirements.
+  // We will allow empty capability input, match all settings with
+  // requirements.
   getBroadcastSettings();
   std::vector<LeAudioBroadcastConfigurationSetting> filtered_settings;
   if (!in_remoteSinkAudioCapabilities.has_value() ||
diff --git a/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.h b/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.h
index 6d402a43a2..316221bbcb 100644
--- a/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.h
+++ b/bluetooth/audio/aidl/default/LeAudioOffloadAudioProvider.h
@@ -141,6 +141,18 @@ class LeAudioOffloadAudioProvider : public BluetoothAudioProvider {
       std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
           valid_direction_configurations,
       bool isExact);
+  void filterRequirementAseDirectionConfigurationExact(
+      std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+          direction_configurations,
+      const std::vector<std::optional<AseDirectionRequirement>>& requirements,
+      std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+          valid_direction_configurations);
+  void filterRequirementAseDirectionConfigurationLoose(
+      std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+          direction_configurations,
+      const std::vector<std::optional<AseDirectionRequirement>>& requirements,
+      std::optional<std::vector<std::optional<AseDirectionConfiguration>>>&
+          valid_direction_configurations);
   std::optional<LeAudioAseConfigurationSetting>
   getCapabilitiesMatchedAseConfigurationSettings(
       IBluetoothAudioProvider::LeAudioAseConfigurationSetting& setting,
diff --git a/bluetooth/audio/utils/Android.bp b/bluetooth/audio/utils/Android.bp
index 6d1da63a68..4e247606db 100644
--- a/bluetooth/audio/utils/Android.bp
+++ b/bluetooth/audio/utils/Android.bp
@@ -49,6 +49,7 @@ cc_library_shared {
     header_libs: [
         "libhardware_headers",
         "libxsdc-utils",
+        "libbluetooth_offload_leaudio_headers",
     ],
     defaults: [
         "aconfig_lib_cc_static_link.defaults",
@@ -69,6 +70,9 @@ cc_library_shared {
     ],
     static_libs: [
         "btaudiohal_flags_c_lib",
+        "libbluetooth_offload_leaudio_audio",
+        "liblc3",
+        "libopus-experimental",
     ],
     generated_sources: [
         "le_audio_codec_capabilities",
diff --git a/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.cpp b/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.cpp
index c62784e47f..048d851b1a 100644
--- a/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.cpp
+++ b/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.cpp
@@ -15,15 +15,27 @@
  */
 
 #include <sys/types.h>
+
+#include <cstdint>
+#include <optional>
+
+#include "aidl/android/hardware/bluetooth/audio/ChannelMode.h"
+#include "aidl/android/hardware/bluetooth/audio/CodecId.h"
+#include "aidl/android/hardware/bluetooth/audio/CodecSpecificConfigurationLtv.h"
+#include "aidl/android/hardware/bluetooth/audio/CodecType.h"
+#include "aidl/android/hardware/bluetooth/audio/OpusConfiguration.h"
 #define LOG_TAG "BTAudioSessionAidl"
 
 #include <android-base/logging.h>
+#include <android-base/properties.h>
 #include <android-base/stringprintf.h>
 #include <android/binder_manager.h>
 #include <com_android_btaudio_hal_flags.h>
 #include <hardware/audio.h>
 
 #include "BluetoothAudioSession.h"
+#include "BluetoothAudioSwOffload.h"
+#include "BluetoothAudioType.h"
 
 namespace aidl {
 namespace android {
@@ -37,6 +49,9 @@ static constexpr int kFmqReceiveTimeoutMs =
 static constexpr int kWritePollMs = 1;  // polled non-blocking interval
 static constexpr int kReadPollMs = 1;   // polled non-blocking interval
 
+constexpr char kPropertyLeaSwOffload[] =
+    "persist.vendor.audio.leaudio_sw_offload";
+
 static std::string toString(const std::vector<LatencyMode>& latencies) {
   std::stringstream latencyModesStr;
   for (LatencyMode mode : latencies) {
@@ -82,11 +97,18 @@ void BluetoothAudioSession::OnSessionStarted(
 
 void BluetoothAudioSession::OnSessionEnded() {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  bool toggled = IsSessionReady();
+  bool toggled = IsSessionReadyInternal();
   LOG(INFO) << __func__ << " - SessionType=" << toString(session_type_);
   audio_config_ = nullptr;
   stack_iface_ = nullptr;
   UpdateDataPath(nullptr);
+  if (com::android::btaudio::hal::flags::leaudio_sw_offload() &&
+      ::android::base::GetBoolProperty(kPropertyLeaSwOffload, false)) {
+    if (session_type_ ==
+        SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
+      LeAudioSwOffloadInstance::releaseSwOffload();
+    }
+  }
   if (toggled) {
     ReportSessionStatus();
   }
@@ -98,9 +120,173 @@ void BluetoothAudioSession::OnSessionEnded() {
  *
  ***/
 
+std::vector<CodecSpecificConfigurationLtv>
+getCodecConfigFromVendorCodecConfiguration(
+    std::vector<uint8_t>& vendor_codec_config) {
+  std::vector<CodecSpecificConfigurationLtv> codec_config;
+  int i = 0;
+  while (i < vendor_codec_config.size()) {
+    auto opcode = vendor_codec_config[i++];
+    auto subopcode = vendor_codec_config[i++];
+    if (opcode == kCodecConfigOpcode) {
+      if (subopcode == kSamplingFrequencySubOpcode) {
+        auto p =
+            codec_cfg_map_to_sampling_rate_ltv.find(vendor_codec_config[i++]);
+        if (p != codec_cfg_map_to_sampling_rate_ltv.end()) {
+          codec_config.push_back(p->second);
+        }
+      } else if (subopcode == kFrameDurationSubOpcode) {
+        auto p =
+            codec_cfg_map_to_frame_duration_ltv.find(vendor_codec_config[i++]);
+        if (p != codec_cfg_map_to_frame_duration_ltv.end()) {
+          codec_config.push_back(p->second);
+        }
+      } else if (subopcode == kFrameBlocksPerSDUSubOpcode) {
+        auto frame_block =
+            CodecSpecificConfigurationLtv::CodecFrameBlocksPerSDU();
+        frame_block.value = vendor_codec_config[i++];
+        codec_config.push_back(frame_block);
+      }
+    } else if (opcode == kAudioChannelAllocationOpcode) {
+      auto allocation = CodecSpecificConfigurationLtv::AudioChannelAllocation();
+      for (int b = 0; b < 4; ++b) {
+        allocation.bitmask |= (vendor_codec_config[i++] << (b * 8));
+      }
+      codec_config.push_back(allocation);
+    } else if (opcode == kOctetsPerCodecFrameOpcode) {
+      auto octet = CodecSpecificConfigurationLtv::OctetsPerCodecFrame();
+      for (int b = 0; b < 2; ++b) {
+        octet.value |= (vendor_codec_config[i++] << (b * 8));
+      }
+      codec_config.push_back(octet);
+    }
+  }
+  return codec_config;
+}
+
+OpusConfiguration getOpusConfigFromCodecConfig(
+    std::vector<CodecSpecificConfigurationLtv> codecConfiguration) {
+  OpusConfiguration opus_config;
+  opus_config.pcmBitDepth = 16;
+  for (auto ltv : codecConfiguration) {
+    if (ltv.getTag() == CodecSpecificConfigurationLtv::samplingFrequency) {
+      auto p = sampling_rate_ltv_map.find(
+          ltv.get<CodecSpecificConfigurationLtv::samplingFrequency>());
+      if (p != sampling_rate_ltv_map.end()) {
+        opus_config.samplingFrequencyHz = p->second;
+      }
+    } else if (ltv.getTag() == CodecSpecificConfigurationLtv::frameDuration) {
+      auto p = frame_duration_ltv_map.find(
+          ltv.get<CodecSpecificConfigurationLtv::frameDuration>());
+      if (p != frame_duration_ltv_map.end()) {
+        opus_config.frameDurationUs = p->second;
+      }
+    } else if (ltv.getTag() ==
+               CodecSpecificConfigurationLtv::octetsPerCodecFrame) {
+      auto octet =
+          ltv.get<CodecSpecificConfigurationLtv::octetsPerCodecFrame>();
+      opus_config.octetsPerFrame = octet.value;
+    } else if (ltv.getTag() ==
+               CodecSpecificConfigurationLtv::codecFrameBlocksPerSDU) {
+      auto block =
+          ltv.get<CodecSpecificConfigurationLtv::codecFrameBlocksPerSDU>();
+      opus_config.blocksPerSdu = block.value;
+    }
+  }
+  opus_config.channelMode = ChannelMode::STEREO;
+  return opus_config;
+}
+
+std::optional<AudioConfiguration> convertToOpusAudioConfiguration(
+    const AudioConfiguration& audio_config_,
+    std::optional<bool>& is_stream_active) {
+  if (audio_config_.getTag() == AudioConfiguration::leAudioConfig) {
+    is_stream_active = false;
+    auto le_audio_config =
+        audio_config_.get<AudioConfiguration::leAudioConfig>();
+    // Conversion from extension to Lc3Configuration
+    LOG(DEBUG) << __func__ << ": leAudioConfig detected, len = "
+               << le_audio_config.streamMap.size();
+    for (auto info : le_audio_config.streamMap) {
+      LOG(DEBUG) << __func__ << ": info is " << info.toString();
+      if (info.streamHandle != 0) {
+        is_stream_active = true;
+      }
+      if (info.aseConfiguration.has_value()) {
+        auto ase_config = info.aseConfiguration.value();
+        auto codec_id = ase_config.codecId;
+        if (codec_id.has_value() &&
+            codec_id.value().getTag() == CodecId::vendor) {
+          auto cid = codec_id.value().get<CodecId::vendor>();
+          if (cid == opus_codec &&
+              ase_config.vendorCodecConfiguration.has_value()) {
+            OpusConfiguration opus_config = getOpusConfigFromCodecConfig(
+                getCodecConfigFromVendorCodecConfiguration(
+                    ase_config.vendorCodecConfiguration.value()));
+            LOG(DEBUG) << __func__ << ": converted and set to OPUS config: "
+                       << opus_config.toString();
+            if (com::android::btaudio::hal::flags::leaudio_sw_offload() &&
+                ::android::base::GetBoolProperty(kPropertyLeaSwOffload,
+                                                 false) &&
+                opus_config.samplingFrequencyHz ==
+                    kOpusHiresSamplingFrequency) {
+              LOG(INFO) << __func__
+                        << ": Detect premium audio, use software offload path.";
+
+              if (info.streamHandle != 0) {
+                swoff::AudioConfig audio_config_sw_off = {
+                    .bitdepth = kOpusHiresBitPerSample,
+                    .sample_rate = kOpusHiresSamplingFrequency,
+                    .frame_duration_us = opus_config.frameDurationUs,
+                    .codec_type = swoff::OPUS,
+                    .codec_config.opus = {opus_config.octetsPerFrame,
+                                          kOpusHiresVbr, kOpusHiresComplexity}};
+
+                std::vector<swoff::IsoStream> iso_streams = {
+                    {info.streamHandle,
+                     static_cast<uint32_t>(info.audioChannelAllocation)}};
+
+                LeAudioSwOffloadInstance::sw_offload_cbacks_ =
+                    std::make_shared<LeAudioSwOffloadCallbacks>();
+                LeAudioSwOffloadInstance::sw_offload_streams_ =
+                    std::make_shared<swoff::LeAudioStream>(
+                        iso_streams, audio_config_sw_off,
+                        LeAudioSwOffloadInstance::sw_offload_cbacks_);
+              } else {
+                LOG(WARNING) << __func__
+                             << ": ISO stream handle is 0, do not initialte "
+                                "stream in software offload library.";
+              }
+
+              PcmConfiguration pcm_config{
+                  .sampleRateHz = kOpusHiresSamplingFrequency,
+                  .channelMode = ChannelMode::STEREO,
+                  .bitsPerSample = kOpusHiresBitPerSample,
+                  .dataIntervalUs = opus_config.frameDurationUs};
+
+              LeAudioSwOffloadInstance::is_using_swoffload_ = true;
+              return pcm_config;
+            } else {
+              LeAudioConfiguration audio_config;
+              audio_config.leAudioCodecConfig = opus_config;
+              audio_config.codecType = CodecType::OPUS;
+              audio_config.streamMap = le_audio_config.streamMap;
+              audio_config.peerDelayUs = le_audio_config.peerDelayUs;
+              audio_config.vendorSpecificMetadata =
+                  le_audio_config.vendorSpecificMetadata;
+              return audio_config;
+            }
+          }
+        }
+      }
+    }
+  }
+  return std::nullopt;
+}
+
 const AudioConfiguration BluetoothAudioSession::GetAudioConfig() {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     switch (session_type_) {
       case SessionType::A2DP_HARDWARE_OFFLOAD_ENCODING_DATAPATH:
       case SessionType::A2DP_HARDWARE_OFFLOAD_DECODING_DATAPATH:
@@ -129,20 +315,21 @@ void BluetoothAudioSession::ReportAudioConfigChanged(
             SessionType::LE_AUDIO_HARDWARE_OFFLOAD_DECODING_DATAPATH) {
       if (audio_config.getTag() != AudioConfiguration::leAudioConfig) {
         LOG(ERROR) << __func__ << " invalid audio config type for SessionType ="
-                  << toString(session_type_);
+                   << toString(session_type_);
         return;
       }
     } else if (session_type_ ==
-            SessionType::LE_AUDIO_BROADCAST_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
+               SessionType::
+                   LE_AUDIO_BROADCAST_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
       if (audio_config.getTag() != AudioConfiguration::leAudioBroadcastConfig) {
         LOG(ERROR) << __func__ << " invalid audio config type for SessionType ="
-                  << toString(session_type_);
+                   << toString(session_type_);
         return;
       }
-    } else if(session_type_ == SessionType::HFP_HARDWARE_OFFLOAD_DATAPATH) {
+    } else if (session_type_ == SessionType::HFP_HARDWARE_OFFLOAD_DATAPATH) {
       if (audio_config.getTag() != AudioConfiguration::hfpConfig) {
         LOG(ERROR) << __func__ << " invalid audio config type for SessionType ="
-                  << toString(session_type_);
+                   << toString(session_type_);
         return;
       }
     } else if (session_type_ == SessionType::HFP_SOFTWARE_DECODING_DATAPATH ||
@@ -153,8 +340,8 @@ void BluetoothAudioSession::ReportAudioConfigChanged(
         return;
       }
     } else {
-      LOG(ERROR) << __func__ << " invalid SessionType ="
-                 << toString(session_type_);
+      LOG(ERROR) << __func__
+                 << " invalid SessionType =" << toString(session_type_);
       return;
     }
   } else {
@@ -167,10 +354,10 @@ void BluetoothAudioSession::ReportAudioConfigChanged(
                    << toString(session_type_);
         return;
       }
-    } else if(session_type_ == SessionType::HFP_HARDWARE_OFFLOAD_DATAPATH) {
+    } else if (session_type_ == SessionType::HFP_HARDWARE_OFFLOAD_DATAPATH) {
       if (audio_config.getTag() != AudioConfiguration::hfpConfig) {
         LOG(ERROR) << __func__ << " invalid audio config type for SessionType ="
-                  << toString(session_type_);
+                   << toString(session_type_);
         return;
       }
     } else if (session_type_ == SessionType::HFP_SOFTWARE_DECODING_DATAPATH ||
@@ -187,8 +374,30 @@ void BluetoothAudioSession::ReportAudioConfigChanged(
     }
   }
 
+  if (session_type_ ==
+      SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
+    // reset swoffload when new config is coming with offload session
+    // type
+    LeAudioSwOffloadInstance::releaseSwOffload();
+  }
+
   audio_config_ = std::make_unique<AudioConfiguration>(audio_config);
 
+  std::optional<bool> is_stream_active;
+  auto opus_audio_config =
+      convertToOpusAudioConfiguration(audio_config, is_stream_active);
+
+  if (opus_audio_config.has_value()) {
+    audio_config_ =
+        std::make_unique<AudioConfiguration>(opus_audio_config.value());
+  }
+
+  if (is_stream_active.has_value() && !is_stream_active.value()) {
+    LOG(WARNING) << __func__ << " - SessionType=" << toString(session_type_)
+                 << " has NO active stream.";
+    return;
+  }
+
   if (observers_.empty()) {
     LOG(WARNING) << __func__ << " - SessionType=" << toString(session_type_)
                  << " has NO port state observer";
@@ -206,7 +415,35 @@ void BluetoothAudioSession::ReportAudioConfigChanged(
   }
 }
 
-bool BluetoothAudioSession::IsSessionReady() {
+bool BluetoothAudioSession::IsSessionReady(bool is_primary_hal) {
+  std::lock_guard<std::recursive_mutex> guard(mutex_);
+
+  bool is_mq_valid =
+      (session_type_ == SessionType::A2DP_HARDWARE_OFFLOAD_ENCODING_DATAPATH ||
+       session_type_ ==
+           SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH ||
+       session_type_ ==
+           SessionType::LE_AUDIO_HARDWARE_OFFLOAD_DECODING_DATAPATH ||
+       session_type_ ==
+           SessionType::LE_AUDIO_BROADCAST_HARDWARE_OFFLOAD_ENCODING_DATAPATH ||
+       session_type_ == SessionType::A2DP_HARDWARE_OFFLOAD_DECODING_DATAPATH ||
+       session_type_ == SessionType::HFP_HARDWARE_OFFLOAD_DATAPATH ||
+       (data_mq_ != nullptr && data_mq_->isValid()));
+
+  if (com::android::btaudio::hal::flags::leaudio_sw_offload() &&
+      ::android::base::GetBoolProperty(kPropertyLeaSwOffload, false)) {
+    if (session_type_ ==
+        SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
+      if (!is_primary_hal) {
+        is_mq_valid &= LeAudioSwOffloadInstance::is_using_swoffload_.load();
+      }
+    }
+  }
+
+  return stack_iface_ != nullptr && is_mq_valid && audio_config_ != nullptr;
+}
+
+bool BluetoothAudioSession::IsSessionReadyInternal() {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
 
   bool is_mq_valid =
@@ -271,7 +508,7 @@ void BluetoothAudioSession::UnregisterStatusCback(uint16_t cookie) {
 
 bool BluetoothAudioSession::StartStream(bool is_low_latency) {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return false;
@@ -287,7 +524,7 @@ bool BluetoothAudioSession::StartStream(bool is_low_latency) {
 
 bool BluetoothAudioSession::SuspendStream() {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return false;
@@ -303,7 +540,7 @@ bool BluetoothAudioSession::SuspendStream() {
 
 void BluetoothAudioSession::StopStream() {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     return;
   }
   auto hal_retval = stack_iface_->stopStream();
@@ -383,7 +620,23 @@ bool BluetoothAudioSession::UpdateAudioConfig(
       !is_le_audio_offload_broadcast_audio_config) {
     return false;
   }
+
+  if (session_type_ ==
+      SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
+    // reset swoffload when new config is coming with offload session
+    // type
+    LeAudioSwOffloadInstance::releaseSwOffload();
+  }
+
   audio_config_ = std::make_unique<AudioConfiguration>(audio_config);
+
+  std::optional<bool> is_stream_active;
+  auto opus_audio_config =
+      convertToOpusAudioConfiguration(audio_config, is_stream_active);
+  if (opus_audio_config.has_value()) {
+    audio_config_ =
+        std::make_unique<AudioConfiguration>(opus_audio_config.value());
+  }
   return true;
 }
 
@@ -415,38 +668,58 @@ size_t BluetoothAudioSession::OutWritePcmData(const void* buffer,
   if (buffer == nullptr || bytes <= 0) {
     return 0;
   }
-  size_t total_written = 0;
-  int timeout_ms = kFmqSendTimeoutMs;
-  do {
+
+  if (session_type_ ==
+      SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH) {
     std::unique_lock<std::recursive_mutex> lock(mutex_);
-    if (!IsSessionReady()) {
-      break;
-    }
-    size_t num_bytes_to_write = data_mq_->availableToWrite();
-    if (num_bytes_to_write) {
-      if (num_bytes_to_write > (bytes - total_written)) {
-        num_bytes_to_write = bytes - total_written;
+    if (LeAudioSwOffloadInstance::is_using_swoffload_) {
+      if (!LeAudioSwOffloadInstance::is_swoff_stream_running_) {
+        return 0;
       }
+      size_t total_written =
+          LeAudioSwOffloadInstance::sw_offload_streams_->write(buffer, bytes);
 
-      if (!data_mq_->write(
-              static_cast<const MQDataType*>(buffer) + total_written,
-              num_bytes_to_write)) {
-        LOG(ERROR) << "FMQ datapath writing " << total_written << "/" << bytes
-                   << " failed";
-        return total_written;
+      if (total_written != bytes) {
+        LOG(WARNING) << "Software offload write not complete.";
       }
-      total_written += num_bytes_to_write;
-    } else if (timeout_ms >= kWritePollMs) {
-      lock.unlock();
-      usleep(kWritePollMs * 1000);
-      timeout_ms -= kWritePollMs;
-    } else {
-      LOG(DEBUG) << "Data " << total_written << "/" << bytes << " overflow "
-                 << (kFmqSendTimeoutMs - timeout_ms) << " ms";
       return total_written;
+    } else {
+      return 0;
     }
-  } while (total_written < bytes);
-  return total_written;
+  } else {
+    size_t total_written = 0;
+    int timeout_ms = kFmqSendTimeoutMs;
+    do {
+      std::unique_lock<std::recursive_mutex> lock(mutex_);
+      if (!IsSessionReadyInternal()) {
+        break;
+      }
+      size_t num_bytes_to_write = data_mq_->availableToWrite();
+      if (num_bytes_to_write) {
+        if (num_bytes_to_write > (bytes - total_written)) {
+          num_bytes_to_write = bytes - total_written;
+        }
+
+        if (!data_mq_->write(
+                static_cast<const MQDataType*>(buffer) + total_written,
+                num_bytes_to_write)) {
+          LOG(ERROR) << "FMQ datapath writing " << total_written << "/" << bytes
+                     << " failed";
+          return total_written;
+        }
+        total_written += num_bytes_to_write;
+      } else if (timeout_ms >= kWritePollMs) {
+        lock.unlock();
+        usleep(kWritePollMs * 1000);
+        timeout_ms -= kWritePollMs;
+      } else {
+        LOG(DEBUG) << "Data " << total_written << "/" << bytes << " overflow "
+                   << (kFmqSendTimeoutMs - timeout_ms) << " ms";
+        return total_written;
+      }
+    } while (total_written < bytes);
+    return total_written;
+  }
 }
 
 size_t BluetoothAudioSession::InReadPcmData(void* buffer, size_t bytes) {
@@ -457,7 +730,7 @@ size_t BluetoothAudioSession::InReadPcmData(void* buffer, size_t bytes) {
   int timeout_ms = kFmqReceiveTimeoutMs;
   do {
     std::unique_lock<std::recursive_mutex> lock(mutex_);
-    if (!IsSessionReady()) {
+    if (!IsSessionReadyInternal()) {
       break;
     }
     size_t num_bytes_to_read = data_mq_->availableToRead();
@@ -547,7 +820,7 @@ void BluetoothAudioSession::ReportLowLatencyModeAllowedChanged(bool allowed) {
 bool BluetoothAudioSession::GetPresentationPosition(
     PresentationPosition& presentation_position) {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return false;
@@ -609,7 +882,7 @@ void BluetoothAudioSession::UpdateSinkMetadata(
 bool BluetoothAudioSession::UpdateSourceMetadata(
     const SourceMetadata& hal_source_metadata) {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return false;
@@ -636,7 +909,7 @@ bool BluetoothAudioSession::UpdateSourceMetadata(
 bool BluetoothAudioSession::UpdateSinkMetadata(
     const SinkMetadata& hal_sink_metadata) {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return false;
@@ -662,7 +935,7 @@ bool BluetoothAudioSession::UpdateSinkMetadata(
 
 std::vector<LatencyMode> BluetoothAudioSession::GetSupportedLatencyModes() {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return std::vector<LatencyMode>();
@@ -712,7 +985,7 @@ std::vector<LatencyMode> BluetoothAudioSession::GetSupportedLatencyModes() {
 
 void BluetoothAudioSession::SetLatencyMode(const LatencyMode& latency_mode) {
   std::lock_guard<std::recursive_mutex> guard(mutex_);
-  if (!IsSessionReady()) {
+  if (!IsSessionReadyInternal()) {
     LOG(DEBUG) << __func__ << " - SessionType=" << toString(session_type_)
                << " has NO session";
     return;
@@ -760,6 +1033,41 @@ BluetoothAudioSessionInstance::GetSessionInstance(
   return session_ptr;
 }
 
+/***
+ *
+ * LeAudioSwOffload
+ *
+ ***/
+std::shared_ptr<LeAudioSwOffloadCallbacks>
+    LeAudioSwOffloadInstance::sw_offload_cbacks_;
+std::shared_ptr<swoff::LeAudioStream>
+    LeAudioSwOffloadInstance::sw_offload_streams_;
+std::atomic<bool> LeAudioSwOffloadInstance::is_swoff_stream_running_ = false;
+std::atomic<bool> LeAudioSwOffloadInstance::is_using_swoffload_ = false;
+
+void LeAudioSwOffloadInstance::releaseSwOffload() {
+  if (com::android::btaudio::hal::flags::leaudio_sw_offload() &&
+      ::android::base::GetBoolProperty(kPropertyLeaSwOffload, false)) {
+    if (LeAudioSwOffloadInstance::sw_offload_streams_) {
+      LeAudioSwOffloadInstance::is_using_swoffload_ = false;
+      LeAudioSwOffloadInstance::is_swoff_stream_running_ = false;
+      LeAudioSwOffloadInstance::sw_offload_streams_ = nullptr;
+      LeAudioSwOffloadInstance::sw_offload_cbacks_ = nullptr;
+    }
+  }
+}
+
+LeAudioSwOffloadCallbacks::LeAudioSwOffloadCallbacks() {}
+
+void LeAudioSwOffloadCallbacks::start() {
+  LOG(INFO) << __func__ << "Stream started";
+  LeAudioSwOffloadInstance::is_swoff_stream_running_ = true;
+}
+void LeAudioSwOffloadCallbacks::stop() {
+  LOG(INFO) << __func__ << "Stream stopped";
+  LeAudioSwOffloadInstance::is_swoff_stream_running_ = false;
+}
+
 }  // namespace audio
 }  // namespace bluetooth
 }  // namespace hardware
diff --git a/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.h b/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.h
index 103a9ea61b..2a0c55e543 100644
--- a/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.h
+++ b/bluetooth/audio/utils/aidl_session/BluetoothAudioSession.h
@@ -113,9 +113,10 @@ class BluetoothAudioSession {
 
   /***
    * The function helps to check if this session is ready or not
+   * @param: is_primary_hal - indicates which hal calls it
    * @return: true if the Bluetooth stack has started the specified session
    ***/
-  bool IsSessionReady();
+  bool IsSessionReady(bool is_primary_hal);
 
   /***
    * The report function is used to report that the Bluetooth stack has started
@@ -223,6 +224,7 @@ class BluetoothAudioSession {
   bool UpdateAudioConfig(const AudioConfiguration& audio_config);
   // invoking the registered session_changed_cb_
   void ReportSessionStatus();
+  bool IsSessionReadyInternal();
 
   static inline std::atomic<bool> is_aidl_checked = false;
   static inline std::atomic<bool> is_aidl_available = false;
diff --git a/bluetooth/audio/utils/aidl_session/BluetoothAudioSessionControl.h b/bluetooth/audio/utils/aidl_session/BluetoothAudioSessionControl.h
index 5263222084..f2fcc8a9b0 100644
--- a/bluetooth/audio/utils/aidl_session/BluetoothAudioSessionControl.h
+++ b/bluetooth/audio/utils/aidl_session/BluetoothAudioSessionControl.h
@@ -30,11 +30,12 @@ class BluetoothAudioSessionControl {
    * The control API helps to check if session is ready or not
    * @return: true if the Bluetooth stack has started th specified session
    ***/
-  static bool IsSessionReady(const SessionType& session_type) {
+  static bool IsSessionReady(const SessionType& session_type,
+                             bool is_primary_hal = true) {
     std::shared_ptr<BluetoothAudioSession> session_ptr =
         BluetoothAudioSessionInstance::GetSessionInstance(session_type);
     if (session_ptr != nullptr) {
-      return session_ptr->IsSessionReady();
+      return session_ptr->IsSessionReady(is_primary_hal);
     }
 
     return false;
diff --git a/bluetooth/audio/utils/aidl_session/BluetoothAudioSwOffload.h b/bluetooth/audio/utils/aidl_session/BluetoothAudioSwOffload.h
new file mode 100644
index 0000000000..25554c34d7
--- /dev/null
+++ b/bluetooth/audio/utils/aidl_session/BluetoothAudioSwOffload.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <swoff/swoff_lea.h>
+
+namespace aidl::android::hardware::bluetooth::audio {
+
+class LeAudioSwOffloadCallbacks : public swoff::LeAudioCallbacks {
+ public:
+  LeAudioSwOffloadCallbacks();
+  void start() override;
+  void stop() override;
+};
+
+class LeAudioSwOffloadInstance {
+ public:
+  static std::shared_ptr<LeAudioSwOffloadCallbacks> sw_offload_cbacks_;
+  static std::shared_ptr<swoff::LeAudioStream> sw_offload_streams_;
+  static std::atomic<bool> is_using_swoffload_;
+  static std::atomic<bool> is_swoff_stream_running_;
+  static void releaseSwOffload();
+};
+
+}  // namespace aidl::android::hardware::bluetooth::audio
diff --git a/bluetooth/audio/utils/aidl_session/BluetoothAudioType.h b/bluetooth/audio/utils/aidl_session/BluetoothAudioType.h
new file mode 100644
index 0000000000..19c588afa8
--- /dev/null
+++ b/bluetooth/audio/utils/aidl_session/BluetoothAudioType.h
@@ -0,0 +1,298 @@
+#include <sys/types.h>
+
+#include <cstdint>
+#include <map>
+
+#include "aidl/android/hardware/bluetooth/audio/CodecId.h"
+#include "aidl/android/hardware/bluetooth/audio/CodecSpecificConfigurationLtv.h"
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace bluetooth {
+namespace audio {
+
+/* Datapath */
+constexpr uint8_t kIsoDataPathHci = 0x00;
+constexpr uint8_t kIsoDataPathPlatformDefault = 0x01;
+constexpr uint8_t kIsoDataPathHciLinkFeedback = 0x19;
+constexpr uint8_t kIsoDataPathDisabled = 0xFF;
+
+/* Direction */
+constexpr uint8_t kLeAudioDirectionSink = 0x01;
+constexpr uint8_t kLeAudioDirectionSource = 0x02;
+constexpr uint8_t kLeAudioDirectionBoth =
+    kLeAudioDirectionSink | kLeAudioDirectionSource;
+
+/* Sampling Frequencies */
+constexpr uint8_t kLeAudioSamplingFreq8000Hz = 0x01;
+constexpr uint8_t kLeAudioSamplingFreq11025Hz = 0x02;
+constexpr uint8_t kLeAudioSamplingFreq16000Hz = 0x03;
+constexpr uint8_t kLeAudioSamplingFreq22050Hz = 0x04;
+constexpr uint8_t kLeAudioSamplingFreq24000Hz = 0x05;
+constexpr uint8_t kLeAudioSamplingFreq32000Hz = 0x06;
+constexpr uint8_t kLeAudioSamplingFreq44100Hz = 0x07;
+constexpr uint8_t kLeAudioSamplingFreq48000Hz = 0x08;
+constexpr uint8_t kLeAudioSamplingFreq88200Hz = 0x09;
+constexpr uint8_t kLeAudioSamplingFreq96000Hz = 0x0A;
+constexpr uint8_t kLeAudioSamplingFreq176400Hz = 0x0B;
+constexpr uint8_t kLeAudioSamplingFreq192000Hz = 0x0C;
+constexpr uint8_t kLeAudioSamplingFreq384000Hz = 0x0D;
+
+/* Frame Durations */
+constexpr uint8_t kLeAudioCodecFrameDur7500us = 0x00;
+constexpr uint8_t kLeAudioCodecFrameDur10000us = 0x01;
+constexpr uint8_t kLeAudioCodecFrameDur20000us = 0x02;
+
+/* Audio Allocations */
+constexpr uint32_t kLeAudioLocationMonoAudio = 0x00000000;
+constexpr uint32_t kLeAudioLocationFrontLeft = 0x00000001;
+constexpr uint32_t kLeAudioLocationFrontRight = 0x00000002;
+constexpr uint32_t kLeAudioLocationFrontCenter = 0x00000004;
+constexpr uint32_t kLeAudioLocationLowFreqEffects1 = 0x00000008;
+constexpr uint32_t kLeAudioLocationBackLeft = 0x00000010;
+constexpr uint32_t kLeAudioLocationBackRight = 0x00000020;
+constexpr uint32_t kLeAudioLocationFrontLeftOfCenter = 0x00000040;
+constexpr uint32_t kLeAudioLocationFrontRightOfCenter = 0x00000080;
+constexpr uint32_t kLeAudioLocationBackCenter = 0x00000100;
+constexpr uint32_t kLeAudioLocationLowFreqEffects2 = 0x00000200;
+constexpr uint32_t kLeAudioLocationSideLeft = 0x00000400;
+constexpr uint32_t kLeAudioLocationSideRight = 0x00000800;
+constexpr uint32_t kLeAudioLocationTopFrontLeft = 0x00001000;
+constexpr uint32_t kLeAudioLocationTopFrontRight = 0x00002000;
+constexpr uint32_t kLeAudioLocationTopFrontCenter = 0x00004000;
+constexpr uint32_t kLeAudioLocationTopCenter = 0x00008000;
+constexpr uint32_t kLeAudioLocationTopBackLeft = 0x00010000;
+constexpr uint32_t kLeAudioLocationTopBackRight = 0x00020000;
+constexpr uint32_t kLeAudioLocationTopSideLeft = 0x00040000;
+constexpr uint32_t kLeAudioLocationTopSideRight = 0x00080000;
+constexpr uint32_t kLeAudioLocationTopBackCenter = 0x00100000;
+constexpr uint32_t kLeAudioLocationBottomFrontCenter = 0x00200000;
+constexpr uint32_t kLeAudioLocationBottomFrontLeft = 0x00400000;
+constexpr uint32_t kLeAudioLocationBottomFrontRight = 0x00800000;
+constexpr uint32_t kLeAudioLocationFrontLeftWide = 0x01000000;
+constexpr uint32_t kLeAudioLocationFrontRightWide = 0x02000000;
+constexpr uint32_t kLeAudioLocationLeftSurround = 0x04000000;
+constexpr uint32_t kLeAudioLocationRightSurround = 0x08000000;
+
+constexpr uint32_t kLeAudioLocationAnyLeft =
+    kLeAudioLocationFrontLeft | kLeAudioLocationBackLeft |
+    kLeAudioLocationFrontLeftOfCenter | kLeAudioLocationSideLeft |
+    kLeAudioLocationTopFrontLeft | kLeAudioLocationTopBackLeft |
+    kLeAudioLocationTopSideLeft | kLeAudioLocationBottomFrontLeft |
+    kLeAudioLocationFrontLeftWide | kLeAudioLocationLeftSurround;
+
+constexpr uint32_t kLeAudioLocationAnyRight =
+    kLeAudioLocationFrontRight | kLeAudioLocationBackRight |
+    kLeAudioLocationFrontRightOfCenter | kLeAudioLocationSideRight |
+    kLeAudioLocationTopFrontRight | kLeAudioLocationTopBackRight |
+    kLeAudioLocationTopSideRight | kLeAudioLocationBottomFrontRight |
+    kLeAudioLocationFrontRightWide | kLeAudioLocationRightSurround;
+
+constexpr uint32_t kLeAudioLocationStereo =
+    kLeAudioLocationFrontLeft | kLeAudioLocationFrontRight;
+
+/* Octets Per Frame */
+constexpr uint16_t kLeAudioCodecFrameLen30 = 30;
+constexpr uint16_t kLeAudioCodecFrameLen40 = 40;
+constexpr uint16_t kLeAudioCodecFrameLen60 = 60;
+constexpr uint16_t kLeAudioCodecFrameLen80 = 80;
+constexpr uint16_t kLeAudioCodecFrameLen100 = 100;
+constexpr uint16_t kLeAudioCodecFrameLen120 = 120;
+
+constexpr uint8_t kCodecConfigOpcode = 0x02;
+constexpr uint8_t kAudioChannelAllocationOpcode = 0x05;
+constexpr uint8_t kOctetsPerCodecFrameOpcode = 0x03;
+constexpr uint8_t kFrameBlocksPerSDUSubOpcode = 0x05;
+
+constexpr uint8_t kFrameDurationSubOpcode = 0x02;
+constexpr uint8_t kSamplingFrequencySubOpcode = 0x01;
+constexpr uint8_t kAudioChannelAllocationSubOpcode = 0x03;
+constexpr uint8_t kOctetsPerCodecFrameSubOpcode = 0x04;
+
+/* Vendor codec ID */
+constexpr uint16_t kLeAudioVendorCompanyIdGoogle = 0x00E0;
+constexpr uint16_t kLeAudioVendorCodecIdOpus = 0x0001;
+
+const CodecId::Vendor opus_codec{
+    .codecId = kLeAudioVendorCodecIdOpus,
+    .id = kLeAudioVendorCompanyIdGoogle,
+};
+
+/* Opus Hi-res */
+constexpr uint32_t kOpusHiresSamplingFrequency = 96000;
+constexpr uint32_t kOpusHiresBitPerSample = 24;
+constexpr uint32_t kOpusHiresComplexity = 10;
+constexpr bool kOpusHiresVbr = false;
+
+/* Utility conversion */
+const std::map<CodecSpecificConfigurationLtv::SamplingFrequency, uint32_t>
+    sampling_rate_ltv_map = {
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ8000, 8000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ11025, 11025},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ16000, 16000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ22050, 22050},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ24000, 24000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ32000, 32000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ48000, 48000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ88200, 88200},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ96000, 96000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ176400, 176400},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ192000, 192000},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ384000, 384000},
+};
+
+const std::map<CodecSpecificConfigurationLtv::FrameDuration, int32_t>
+    frame_duration_ltv_map = {
+        {CodecSpecificConfigurationLtv::FrameDuration::US7500, 7500},
+        {CodecSpecificConfigurationLtv::FrameDuration::US10000, 10000},
+        {CodecSpecificConfigurationLtv::FrameDuration::US20000, 20000},
+};
+
+const std::map<uint32_t, CodecSpecificConfigurationLtv::SamplingFrequency>
+    codec_cfg_map_to_sampling_rate_ltv = {
+        {0x01, CodecSpecificConfigurationLtv::SamplingFrequency::HZ8000},
+        {0x02, CodecSpecificConfigurationLtv::SamplingFrequency::HZ11025},
+        {0x03, CodecSpecificConfigurationLtv::SamplingFrequency::HZ16000},
+        {0x04, CodecSpecificConfigurationLtv::SamplingFrequency::HZ22050},
+        {0x05, CodecSpecificConfigurationLtv::SamplingFrequency::HZ24000},
+        {0x06, CodecSpecificConfigurationLtv::SamplingFrequency::HZ32000},
+        {0x07, CodecSpecificConfigurationLtv::SamplingFrequency::HZ44100},
+        {0x08, CodecSpecificConfigurationLtv::SamplingFrequency::HZ48000},
+        {0x09, CodecSpecificConfigurationLtv::SamplingFrequency::HZ88200},
+        {0x0A, CodecSpecificConfigurationLtv::SamplingFrequency::HZ96000},
+        {0x0B, CodecSpecificConfigurationLtv::SamplingFrequency::HZ176400},
+        {0x0C, CodecSpecificConfigurationLtv::SamplingFrequency::HZ192000},
+        {0x0D, CodecSpecificConfigurationLtv::SamplingFrequency::HZ384000},
+};
+
+const std::map<uint32_t, CodecSpecificConfigurationLtv::FrameDuration>
+    codec_cfg_map_to_frame_duration_ltv = {
+        {0x00, CodecSpecificConfigurationLtv::FrameDuration::US7500},
+        {0x01, CodecSpecificConfigurationLtv::FrameDuration::US10000},
+        {0x02, CodecSpecificConfigurationLtv::FrameDuration::US20000},
+};
+
+const std::map<uint8_t, CodecSpecificConfigurationLtv::SamplingFrequency>
+    sampling_freq_map = {
+        {kLeAudioSamplingFreq8000Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ8000},
+        {kLeAudioSamplingFreq16000Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ16000},
+        {kLeAudioSamplingFreq24000Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ24000},
+        {kLeAudioSamplingFreq32000Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ32000},
+        {kLeAudioSamplingFreq44100Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ44100},
+        {kLeAudioSamplingFreq48000Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ48000},
+        {kLeAudioSamplingFreq96000Hz,
+         CodecSpecificConfigurationLtv::SamplingFrequency::HZ96000}};
+
+/* Helper map for matching various frame durations notations */
+const std::map<uint8_t, CodecSpecificConfigurationLtv::FrameDuration>
+    frame_duration_map = {
+        {kLeAudioCodecFrameDur7500us,
+         CodecSpecificConfigurationLtv::FrameDuration::US7500},
+        {kLeAudioCodecFrameDur10000us,
+         CodecSpecificConfigurationLtv::FrameDuration::US10000},
+        {kLeAudioCodecFrameDur20000us,
+         CodecSpecificConfigurationLtv::FrameDuration::US20000}};
+
+/* Helper map for matching various audio channel allocation notations */
+const std::map<uint32_t, uint32_t> audio_channel_allocation_map = {
+    {kLeAudioLocationMonoAudio,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::MONO},
+    {kLeAudioLocationFrontLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_LEFT},
+    {kLeAudioLocationFrontRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_RIGHT},
+    {kLeAudioLocationFrontCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_CENTER},
+    {kLeAudioLocationLowFreqEffects1,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::
+         LOW_FREQUENCY_EFFECTS_1},
+    {kLeAudioLocationBackLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::BACK_LEFT},
+    {kLeAudioLocationBackRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::BACK_RIGHT},
+    {kLeAudioLocationFrontLeftOfCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::
+         FRONT_LEFT_OF_CENTER},
+    {kLeAudioLocationFrontRightOfCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::
+         FRONT_RIGHT_OF_CENTER},
+    {kLeAudioLocationBackCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::BACK_CENTER},
+    {kLeAudioLocationLowFreqEffects2,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::
+         LOW_FREQUENCY_EFFECTS_2},
+    {kLeAudioLocationSideLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::SIDE_LEFT},
+    {kLeAudioLocationSideRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::SIDE_RIGHT},
+    {kLeAudioLocationTopFrontLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_FRONT_LEFT},
+    {kLeAudioLocationTopFrontRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_FRONT_RIGHT},
+    {kLeAudioLocationTopFrontCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_FRONT_CENTER},
+    {kLeAudioLocationTopCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_CENTER},
+    {kLeAudioLocationTopBackLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_BACK_LEFT},
+    {kLeAudioLocationTopBackRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_BACK_RIGHT},
+    {kLeAudioLocationTopSideLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_SIDE_LEFT},
+    {kLeAudioLocationTopSideRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_SIDE_RIGHT},
+    {kLeAudioLocationTopBackCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_BACK_CENTER},
+    {kLeAudioLocationBottomFrontCenter,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::
+         BOTTOM_FRONT_CENTER},
+    {kLeAudioLocationBottomFrontLeft,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::BOTTOM_FRONT_LEFT},
+    {kLeAudioLocationBottomFrontRight,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::BOTTOM_FRONT_RIGHT},
+    {kLeAudioLocationFrontLeftWide,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_LEFT_WIDE},
+    {kLeAudioLocationFrontRightWide,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_RIGHT_WIDE},
+    {kLeAudioLocationLeftSurround,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::LEFT_SURROUND},
+    {kLeAudioLocationRightSurround,
+     CodecSpecificConfigurationLtv::AudioChannelAllocation::RIGHT_SURROUND},
+};
+
+const std::map<CodecSpecificConfigurationLtv::SamplingFrequency, uint32_t>
+    sampling_rate_ltv_to_codec_cfg_map = {
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ8000, 0x01},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ11025, 0x02},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ16000, 0x03},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ22050, 0x04},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ24000, 0x05},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ32000, 0x06},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ44100, 0x07},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ48000, 0x08},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ88200, 0x09},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ96000, 0x0A},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ176400, 0x0B},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ192000, 0x0C},
+        {CodecSpecificConfigurationLtv::SamplingFrequency::HZ384000, 0x0D},
+};
+
+const std::map<CodecSpecificConfigurationLtv::FrameDuration, uint32_t>
+    frame_duration_ltv_to_codec_cfg_map = {
+        {CodecSpecificConfigurationLtv::FrameDuration::US7500, 0x00},
+        {CodecSpecificConfigurationLtv::FrameDuration::US10000, 0x01},
+        {CodecSpecificConfigurationLtv::FrameDuration::US20000, 0x02},
+};
+
+}  // namespace audio
+}  // namespace bluetooth
+}  // namespace hardware
+}  // namespace android
+}  // namespace aidl
diff --git a/bluetooth/audio/utils/aidl_session/BluetoothLeAudioAseConfigurationSettingProvider.cpp b/bluetooth/audio/utils/aidl_session/BluetoothLeAudioAseConfigurationSettingProvider.cpp
index feb4cda4cc..78c8dd0ea6 100644
--- a/bluetooth/audio/utils/aidl_session/BluetoothLeAudioAseConfigurationSettingProvider.cpp
+++ b/bluetooth/audio/utils/aidl_session/BluetoothLeAudioAseConfigurationSettingProvider.cpp
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+#include <cstdint>
+#include <vector>
 #define STREAM_TO_UINT8(u8, p) \
   {                            \
     (u8) = (uint8_t)(*(p));    \
@@ -34,8 +36,6 @@
 
 #define LOG_TAG "BTAudioAseConfigAidl"
 
-#include "BluetoothLeAudioAseConfigurationSettingProvider.h"
-
 #include <aidl/android/hardware/bluetooth/audio/AudioConfiguration.h>
 #include <aidl/android/hardware/bluetooth/audio/AudioContext.h>
 #include <aidl/android/hardware/bluetooth/audio/BluetoothAudioStatus.h>
@@ -49,6 +49,8 @@
 
 #include <optional>
 
+#include "BluetoothAudioType.h"
+#include "BluetoothLeAudioAseConfigurationSettingProvider.h"
 #include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
 
@@ -68,184 +70,6 @@ std::map<std::string,
 std::vector<std::pair<std::string, LeAudioAseConfigurationSetting>>
     ase_configuration_settings_;
 
-constexpr uint8_t kIsoDataPathHci = 0x00;
-constexpr uint8_t kIsoDataPathPlatformDefault = 0x01;
-constexpr uint8_t kIsoDataPathDisabled = 0xFF;
-
-constexpr uint8_t kLeAudioDirectionSink = 0x01;
-constexpr uint8_t kLeAudioDirectionSource = 0x02;
-constexpr uint8_t kLeAudioDirectionBoth =
-    kLeAudioDirectionSink | kLeAudioDirectionSource;
-
-/* Sampling Frequencies */
-constexpr uint8_t kLeAudioSamplingFreq8000Hz = 0x01;
-constexpr uint8_t kLeAudioSamplingFreq11025Hz = 0x02;
-constexpr uint8_t kLeAudioSamplingFreq16000Hz = 0x03;
-constexpr uint8_t kLeAudioSamplingFreq22050Hz = 0x04;
-constexpr uint8_t kLeAudioSamplingFreq24000Hz = 0x05;
-constexpr uint8_t kLeAudioSamplingFreq32000Hz = 0x06;
-constexpr uint8_t kLeAudioSamplingFreq44100Hz = 0x07;
-constexpr uint8_t kLeAudioSamplingFreq48000Hz = 0x08;
-constexpr uint8_t kLeAudioSamplingFreq88200Hz = 0x09;
-constexpr uint8_t kLeAudioSamplingFreq96000Hz = 0x0A;
-constexpr uint8_t kLeAudioSamplingFreq176400Hz = 0x0B;
-constexpr uint8_t kLeAudioSamplingFreq192000Hz = 0x0C;
-constexpr uint8_t kLeAudioSamplingFreq384000Hz = 0x0D;
-
-/* Frame Durations */
-constexpr uint8_t kLeAudioCodecFrameDur7500us = 0x00;
-constexpr uint8_t kLeAudioCodecFrameDur10000us = 0x01;
-constexpr uint8_t kLeAudioCodecFrameDur20000us = 0x02;
-
-/* Audio Allocations */
-constexpr uint32_t kLeAudioLocationMonoAudio = 0x00000000;
-constexpr uint32_t kLeAudioLocationFrontLeft = 0x00000001;
-constexpr uint32_t kLeAudioLocationFrontRight = 0x00000002;
-constexpr uint32_t kLeAudioLocationFrontCenter = 0x00000004;
-constexpr uint32_t kLeAudioLocationLowFreqEffects1 = 0x00000008;
-constexpr uint32_t kLeAudioLocationBackLeft = 0x00000010;
-constexpr uint32_t kLeAudioLocationBackRight = 0x00000020;
-constexpr uint32_t kLeAudioLocationFrontLeftOfCenter = 0x00000040;
-constexpr uint32_t kLeAudioLocationFrontRightOfCenter = 0x00000080;
-constexpr uint32_t kLeAudioLocationBackCenter = 0x00000100;
-constexpr uint32_t kLeAudioLocationLowFreqEffects2 = 0x00000200;
-constexpr uint32_t kLeAudioLocationSideLeft = 0x00000400;
-constexpr uint32_t kLeAudioLocationSideRight = 0x00000800;
-constexpr uint32_t kLeAudioLocationTopFrontLeft = 0x00001000;
-constexpr uint32_t kLeAudioLocationTopFrontRight = 0x00002000;
-constexpr uint32_t kLeAudioLocationTopFrontCenter = 0x00004000;
-constexpr uint32_t kLeAudioLocationTopCenter = 0x00008000;
-constexpr uint32_t kLeAudioLocationTopBackLeft = 0x00010000;
-constexpr uint32_t kLeAudioLocationTopBackRight = 0x00020000;
-constexpr uint32_t kLeAudioLocationTopSideLeft = 0x00040000;
-constexpr uint32_t kLeAudioLocationTopSideRight = 0x00080000;
-constexpr uint32_t kLeAudioLocationTopBackCenter = 0x00100000;
-constexpr uint32_t kLeAudioLocationBottomFrontCenter = 0x00200000;
-constexpr uint32_t kLeAudioLocationBottomFrontLeft = 0x00400000;
-constexpr uint32_t kLeAudioLocationBottomFrontRight = 0x00800000;
-constexpr uint32_t kLeAudioLocationFrontLeftWide = 0x01000000;
-constexpr uint32_t kLeAudioLocationFrontRightWide = 0x02000000;
-constexpr uint32_t kLeAudioLocationLeftSurround = 0x04000000;
-constexpr uint32_t kLeAudioLocationRightSurround = 0x08000000;
-
-constexpr uint32_t kLeAudioLocationAnyLeft =
-    kLeAudioLocationFrontLeft | kLeAudioLocationBackLeft |
-    kLeAudioLocationFrontLeftOfCenter | kLeAudioLocationSideLeft |
-    kLeAudioLocationTopFrontLeft | kLeAudioLocationTopBackLeft |
-    kLeAudioLocationTopSideLeft | kLeAudioLocationBottomFrontLeft |
-    kLeAudioLocationFrontLeftWide | kLeAudioLocationLeftSurround;
-
-constexpr uint32_t kLeAudioLocationAnyRight =
-    kLeAudioLocationFrontRight | kLeAudioLocationBackRight |
-    kLeAudioLocationFrontRightOfCenter | kLeAudioLocationSideRight |
-    kLeAudioLocationTopFrontRight | kLeAudioLocationTopBackRight |
-    kLeAudioLocationTopSideRight | kLeAudioLocationBottomFrontRight |
-    kLeAudioLocationFrontRightWide | kLeAudioLocationRightSurround;
-
-constexpr uint32_t kLeAudioLocationStereo =
-    kLeAudioLocationFrontLeft | kLeAudioLocationFrontRight;
-
-/* Octets Per Frame */
-constexpr uint16_t kLeAudioCodecFrameLen30 = 30;
-constexpr uint16_t kLeAudioCodecFrameLen40 = 40;
-constexpr uint16_t kLeAudioCodecFrameLen60 = 60;
-constexpr uint16_t kLeAudioCodecFrameLen80 = 80;
-constexpr uint16_t kLeAudioCodecFrameLen100 = 100;
-constexpr uint16_t kLeAudioCodecFrameLen120 = 120;
-
-/* Helper map for matching various sampling frequency notations */
-const std::map<uint8_t, CodecSpecificConfigurationLtv::SamplingFrequency>
-    sampling_freq_map = {
-        {kLeAudioSamplingFreq8000Hz,
-         CodecSpecificConfigurationLtv::SamplingFrequency::HZ8000},
-        {kLeAudioSamplingFreq16000Hz,
-         CodecSpecificConfigurationLtv::SamplingFrequency::HZ16000},
-        {kLeAudioSamplingFreq24000Hz,
-         CodecSpecificConfigurationLtv::SamplingFrequency::HZ24000},
-        {kLeAudioSamplingFreq32000Hz,
-         CodecSpecificConfigurationLtv::SamplingFrequency::HZ32000},
-        {kLeAudioSamplingFreq44100Hz,
-         CodecSpecificConfigurationLtv::SamplingFrequency::HZ44100},
-        {kLeAudioSamplingFreq48000Hz,
-         CodecSpecificConfigurationLtv::SamplingFrequency::HZ48000}};
-
-/* Helper map for matching various frame durations notations */
-const std::map<uint8_t, CodecSpecificConfigurationLtv::FrameDuration>
-    frame_duration_map = {
-        {kLeAudioCodecFrameDur7500us,
-         CodecSpecificConfigurationLtv::FrameDuration::US7500},
-        {kLeAudioCodecFrameDur10000us,
-         CodecSpecificConfigurationLtv::FrameDuration::US10000},
-        {kLeAudioCodecFrameDur20000us,
-         CodecSpecificConfigurationLtv::FrameDuration::US20000}};
-
-/* Helper map for matching various audio channel allocation notations */
-std::map<uint32_t, uint32_t> audio_channel_allocation_map = {
-    {kLeAudioLocationMonoAudio,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::MONO},
-    {kLeAudioLocationFrontLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_LEFT},
-    {kLeAudioLocationFrontRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_RIGHT},
-    {kLeAudioLocationFrontCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_CENTER},
-    {kLeAudioLocationLowFreqEffects1,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::
-         LOW_FREQUENCY_EFFECTS_1},
-    {kLeAudioLocationBackLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::BACK_LEFT},
-    {kLeAudioLocationBackRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::BACK_RIGHT},
-    {kLeAudioLocationFrontLeftOfCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::
-         FRONT_LEFT_OF_CENTER},
-    {kLeAudioLocationFrontRightOfCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::
-         FRONT_RIGHT_OF_CENTER},
-    {kLeAudioLocationBackCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::BACK_CENTER},
-    {kLeAudioLocationLowFreqEffects2,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::
-         LOW_FREQUENCY_EFFECTS_2},
-    {kLeAudioLocationSideLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::SIDE_LEFT},
-    {kLeAudioLocationSideRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::SIDE_RIGHT},
-    {kLeAudioLocationTopFrontLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_FRONT_LEFT},
-    {kLeAudioLocationTopFrontRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_FRONT_RIGHT},
-    {kLeAudioLocationTopFrontCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_FRONT_CENTER},
-    {kLeAudioLocationTopCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_CENTER},
-    {kLeAudioLocationTopBackLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_BACK_LEFT},
-    {kLeAudioLocationTopBackRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_BACK_RIGHT},
-    {kLeAudioLocationTopSideLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_SIDE_LEFT},
-    {kLeAudioLocationTopSideRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_SIDE_RIGHT},
-    {kLeAudioLocationTopBackCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::TOP_BACK_CENTER},
-    {kLeAudioLocationBottomFrontCenter,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::
-         BOTTOM_FRONT_CENTER},
-    {kLeAudioLocationBottomFrontLeft,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::BOTTOM_FRONT_LEFT},
-    {kLeAudioLocationBottomFrontRight,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::BOTTOM_FRONT_RIGHT},
-    {kLeAudioLocationFrontLeftWide,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_LEFT_WIDE},
-    {kLeAudioLocationFrontRightWide,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_RIGHT_WIDE},
-    {kLeAudioLocationLeftSurround,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::LEFT_SURROUND},
-    {kLeAudioLocationRightSurround,
-     CodecSpecificConfigurationLtv::AudioChannelAllocation::RIGHT_SURROUND},
-};
-
 // Set configuration and scenario files with fallback default
 static const std::vector<
     std::pair<const char* /*schema*/, const char* /*content*/>>
@@ -444,13 +268,17 @@ void AudioSetConfigurationProviderJson::populateAseQosConfiguration(
   std::optional<CodecSpecificConfigurationLtv::OctetsPerCodecFrame> octet =
       std::nullopt;
 
-  // Hack to put back allocation
+  // Put back allocation
   CodecSpecificConfigurationLtv::AudioChannelAllocation allocation =
       CodecSpecificConfigurationLtv::AudioChannelAllocation();
   if (ase_channel_cnt == 1) {
-    allocation.bitmask |=
-        CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_CENTER;
-
+    if (ase.codecId.value().getTag() == CodecId::vendor) {
+      allocation.bitmask =
+          CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_LEFT;
+    } else {
+      allocation.bitmask |=
+          CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_CENTER;
+    }
   } else {
     allocation.bitmask |=
         CodecSpecificConfigurationLtv::AudioChannelAllocation::FRONT_LEFT |
@@ -478,7 +306,13 @@ void AudioSetConfigurationProviderJson::populateAseQosConfiguration(
 
   // Populate maxSdu
   if (octet.has_value()) {
-    qos.maxSdu = ase_channel_cnt * octet.value().value * frameBlockValue;
+    // Vendor logic: maxSdu = octet.value().value to allow set directly.
+    if (ase.codecId.has_value() &&
+        ase.codecId.value().getTag() == CodecId::vendor) {
+      qos.maxSdu = octet.value().value * frameBlockValue;
+    } else {
+      qos.maxSdu = ase_channel_cnt * octet.value().value * frameBlockValue;
+    }
   }
   // Populate sduIntervalUs
   if (frameDuration.has_value()) {
@@ -499,6 +333,107 @@ void AudioSetConfigurationProviderJson::populateAseQosConfiguration(
   qos.retransmissionNum = qos_cfg->retransmission_number();
 }
 
+void populateVendorCodecConfiguration(LeAudioAseConfiguration& ase) {
+  if (ase.codecId.has_value() &&
+      ase.codecId.value().getTag() == CodecId::vendor) {
+    // Only populate for vendor codec.
+    std::vector<uint8_t> codec_config;
+    for (auto ltv : ase.codecConfiguration) {
+      if (ltv.getTag() == CodecSpecificConfigurationLtv::samplingFrequency) {
+        auto p = sampling_rate_ltv_to_codec_cfg_map.find(
+            ltv.get<CodecSpecificConfigurationLtv::samplingFrequency>());
+        if (p != sampling_rate_ltv_to_codec_cfg_map.end()) {
+          codec_config.push_back(kCodecConfigOpcode);
+          codec_config.push_back(kSamplingFrequencySubOpcode);
+          codec_config.push_back(p->second);
+        }
+      } else if (ltv.getTag() == CodecSpecificConfigurationLtv::frameDuration) {
+        auto p = frame_duration_ltv_to_codec_cfg_map.find(
+            ltv.get<CodecSpecificConfigurationLtv::frameDuration>());
+        if (p != frame_duration_ltv_to_codec_cfg_map.end()) {
+          codec_config.push_back(kCodecConfigOpcode);
+          codec_config.push_back(kFrameDurationSubOpcode);
+          codec_config.push_back(p->second);
+        }
+      } else if (ltv.getTag() ==
+                 CodecSpecificConfigurationLtv::audioChannelAllocation) {
+        auto allocation =
+            ltv.get<CodecSpecificConfigurationLtv::audioChannelAllocation>();
+        codec_config.push_back(kAudioChannelAllocationOpcode);
+        codec_config.push_back(kAudioChannelAllocationSubOpcode);
+        for (int b = 0; b < 4; ++b) {
+          codec_config.push_back((allocation.bitmask >> (b * 8)) & 0xff);
+        }
+      } else if (ltv.getTag() ==
+                 CodecSpecificConfigurationLtv::octetsPerCodecFrame) {
+        auto octet =
+            ltv.get<CodecSpecificConfigurationLtv::octetsPerCodecFrame>();
+        codec_config.push_back(kOctetsPerCodecFrameOpcode);
+        codec_config.push_back(kOctetsPerCodecFrameSubOpcode);
+        for (int b = 0; b < 2; ++b) {
+          codec_config.push_back((octet.value >> (b * 8)) & 0xff);
+        }
+      } else if (ltv.getTag() ==
+                 CodecSpecificConfigurationLtv::codecFrameBlocksPerSDU) {
+        auto frame_block =
+            ltv.get<CodecSpecificConfigurationLtv::codecFrameBlocksPerSDU>();
+        codec_config.push_back(kCodecConfigOpcode);
+        codec_config.push_back(kFrameBlocksPerSDUSubOpcode);
+        codec_config.push_back(frame_block.value);
+      }
+    }
+    ase.vendorCodecConfiguration = codec_config;
+  }
+}
+
+bool isOpusHiResCodec(const LeAudioAseConfiguration& ase) {
+  if (ase.codecId.has_value() &&
+      ase.codecId.value().getTag() == CodecId::vendor) {
+    auto cid = ase.codecId.value().get<CodecId::vendor>();
+    if (cid == opus_codec) {
+      // Based on the sampling freq
+      for (auto ltv : ase.codecConfiguration) {
+        if (ltv.getTag() == CodecSpecificConfigurationLtv::samplingFrequency) {
+          if (ltv.get<CodecSpecificConfigurationLtv::samplingFrequency>() ==
+              CodecSpecificConfigurationLtv::SamplingFrequency::HZ96000) {
+            return true;
+          }
+        }
+      }
+    }
+  }
+  return false;
+}
+
+LeAudioDataPathConfiguration populateDatapath(
+    const CodecLocation& location, const LeAudioAseConfiguration& ase) {
+  LeAudioDataPathConfiguration path;
+  // Move codecId to iso data path
+  path.isoDataPathConfiguration.codecId = ase.codecId.value();
+  // Specific vendor datapath logic
+  if (isOpusHiResCodec(ase)) {
+    path.isoDataPathConfiguration.isTransparent = true;
+    path.dataPathId = kIsoDataPathHciLinkFeedback;
+    return path;
+  }
+  // Translate location to data path id
+  switch (location) {
+    case CodecLocation::ADSP:
+      path.isoDataPathConfiguration.isTransparent = true;
+      path.dataPathId = kIsoDataPathPlatformDefault;
+      break;
+    case CodecLocation::HOST:
+      path.isoDataPathConfiguration.isTransparent = true;
+      path.dataPathId = kIsoDataPathHci;
+      break;
+    case CodecLocation::CONTROLLER:
+      path.isoDataPathConfiguration.isTransparent = false;
+      path.dataPathId = kIsoDataPathPlatformDefault;
+      break;
+  }
+  return path;
+}
+
 // Parse into AseDirectionConfiguration
 AseDirectionConfiguration
 AudioSetConfigurationProviderJson::SetConfigurationFromFlatSubconfig(
@@ -509,7 +444,6 @@ AudioSetConfigurationProviderJson::SetConfigurationFromFlatSubconfig(
 
   LeAudioAseConfiguration ase;
   LeAudioAseQosConfiguration qos;
-  LeAudioDataPathConfiguration path;
 
   // Translate into LeAudioAseConfiguration
   populateAseConfiguration(ase, flat_subconfig, qos_cfg, configurationFlags);
@@ -518,27 +452,13 @@ AudioSetConfigurationProviderJson::SetConfigurationFromFlatSubconfig(
   populateAseQosConfiguration(qos, qos_cfg, ase,
                               flat_subconfig->ase_channel_cnt());
 
-  // Translate location to data path id
-  switch (location) {
-    case CodecLocation::ADSP:
-      path.isoDataPathConfiguration.isTransparent = true;
-      path.dataPathId = kIsoDataPathPlatformDefault;
-      break;
-    case CodecLocation::HOST:
-      path.isoDataPathConfiguration.isTransparent = true;
-      path.dataPathId = kIsoDataPathHci;
-      break;
-    case CodecLocation::CONTROLLER:
-      path.isoDataPathConfiguration.isTransparent = false;
-      path.dataPathId = kIsoDataPathPlatformDefault;
-      break;
-  }
-  // Move codecId to iso data path
-  path.isoDataPathConfiguration.codecId = ase.codecId.value();
+  // Populate vendorCodecConfiguration using the correct LTV
+  populateVendorCodecConfiguration(ase);
 
   direction_conf.aseConfiguration = ase;
   direction_conf.qosConfiguration = qos;
-  direction_conf.dataPathConfiguration = path;
+  // Populate the correct datapath.
+  direction_conf.dataPathConfiguration = populateDatapath(location, ase);
 
   return direction_conf;
 }
@@ -559,15 +479,28 @@ void AudioSetConfigurationProviderJson::processSubconfig(
   if (ase_cnt == 2) directionAseConfiguration.push_back(config);
 }
 
-// Comparing if 2 AseDirectionConfiguration is equal.
-// Configuration are copied in, so we can remove some fields for comparison
-// without affecting the result.
-bool isAseConfigurationEqual(AseDirectionConfiguration cfg_a,
-                             AseDirectionConfiguration cfg_b) {
-  // Remove unneeded fields when comparing.
-  cfg_a.aseConfiguration.metadata = std::nullopt;
-  cfg_b.aseConfiguration.metadata = std::nullopt;
-  return cfg_a == cfg_b;
+// Comparing if 2 AseDirectionConfiguration is asymmetrical.
+bool isAseConfigurationAsymmetrical(AseDirectionConfiguration cfg_a,
+                                    AseDirectionConfiguration cfg_b) {
+  // Comparing samplingFrequency of these 2 config.
+  std::optional<CodecSpecificConfigurationLtv> cfg_a_fr = std::nullopt;
+  std::optional<CodecSpecificConfigurationLtv> cfg_b_fr = std::nullopt;
+  for (auto ltv : cfg_a.aseConfiguration.codecConfiguration) {
+    if (ltv.getTag() == CodecSpecificConfigurationLtv::samplingFrequency) {
+      cfg_a_fr = ltv.get<CodecSpecificConfigurationLtv::samplingFrequency>();
+      break;
+    }
+  }
+  for (auto ltv : cfg_b.aseConfiguration.codecConfiguration) {
+    if (ltv.getTag() == CodecSpecificConfigurationLtv::samplingFrequency) {
+      cfg_b_fr = ltv.get<CodecSpecificConfigurationLtv::samplingFrequency>();
+      break;
+    }
+  }
+  if (cfg_a_fr.has_value() && cfg_b_fr.has_value()) {
+    return cfg_a_fr.value() != cfg_b_fr.value();
+  }
+  return false;
 }
 
 void AudioSetConfigurationProviderJson::PopulateAseConfigurationFromFlat(
@@ -649,26 +582,21 @@ void AudioSetConfigurationProviderJson::PopulateAseConfigurationFromFlat(
     // After putting all subconfig, check if it's an asymmetric configuration
     // and populate information for ConfigurationFlags
     if (!sinkAseConfiguration.empty() && !sourceAseConfiguration.empty()) {
-      if (sinkAseConfiguration.size() == sourceAseConfiguration.size()) {
-        for (int i = 0; i < sinkAseConfiguration.size(); ++i) {
-          if (sinkAseConfiguration[i].has_value() !=
-              sourceAseConfiguration[i].has_value()) {
-            // Different configuration: one is not empty and other is.
+      for (int i = 0; i < sinkAseConfiguration.size(); ++i) {
+        // Only check for comparable source and sink configuration.
+        if (sourceAseConfiguration.size() <= i) break;
+        if (sinkAseConfiguration[i].has_value() &&
+            sourceAseConfiguration[i].has_value()) {
+          // Has both direction, comparing inner fields:
+          if (isAseConfigurationAsymmetrical(
+                  sinkAseConfiguration[i].value(),
+                  sourceAseConfiguration[i].value())) {
             configurationFlags.bitmask |=
                 ConfigurationFlags::ALLOW_ASYMMETRIC_CONFIGURATIONS;
-          } else if (sinkAseConfiguration[i].has_value()) {
-            // Both is not empty, comparing inner fields:
-            if (!isAseConfigurationEqual(sinkAseConfiguration[i].value(),
-                                         sourceAseConfiguration[i].value())) {
-              configurationFlags.bitmask |=
-                  ConfigurationFlags::ALLOW_ASYMMETRIC_CONFIGURATIONS;
-            }
+            // Already detect asymmetrical config.
+            break;
           }
         }
-      } else {
-        // Different number of ASE, is a different configuration.
-        configurationFlags.bitmask |=
-            ConfigurationFlags::ALLOW_ASYMMETRIC_CONFIGURATIONS;
       }
     }
   } else {
diff --git a/bluetooth/bluetooth_hal/Android.bp b/bluetooth/bluetooth_hal/Android.bp
new file mode 100644
index 0000000000..9cd20c5290
--- /dev/null
+++ b/bluetooth/bluetooth_hal/Android.bp
@@ -0,0 +1,520 @@
+//
+// Copyright 2020 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+cc_defaults {
+    name: "libbluetooth_hal_defaults",
+    srcs: [
+        ":hal_common_srcs",
+        ":hal_config_srcs",
+        ":hal_debug_srcs",
+        ":hal_extension_srcs",
+        ":hal_hwinit_srcs",
+        ":hal_transport_srcs",
+        ":hal_util_srcs",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+    ],
+    local_include_dirs: ["include/public/"],
+    header_libs: [
+        "libeigen",
+    ],
+    whole_static_libs: [
+        "android.hardware.bluetooth-V1-ndk",
+        "android.hardware.bluetooth.finder-V1-ndk",
+        "android.hardware.bluetooth.ranging-V1-ndk",
+        "hal_proto_lib",
+        "//hardware/google/interfaces:hardware.google.bluetooth.ccc-V1-ndk",
+        "//hardware/google/interfaces:hardware.google.bluetooth.ext-V1-ndk",
+        "//hardware/google/interfaces:hardware.google.bluetooth.sar-V1-ndk",
+        "//hardware/google/interfaces:hardware.google.bluetooth.bt_channel_avoidance-V1-ndk",
+    ],
+    shared_libs: [
+        "libbase",
+        "libbinder_ndk",
+        "libcutils",
+        "libhardware_legacy",
+        "libutils",
+        "libprotobuf-cpp-full",
+        "server_configurable_flags",
+        "libaconfig_storage_read_api_cc",
+    ],
+    conlyflags: [
+        "-std=c99",
+    ],
+}
+
+filegroup {
+    name: "hal_common_srcs",
+    srcs: [
+        "bluetooth_hal.cc",
+        "bluetooth_hci.cc",
+        "hci_router.cc",
+        "hci_router_client.cc",
+        "hci_router_client_agent.cc",
+    ],
+}
+
+filegroup {
+    name: "hal_config_srcs",
+    srcs: [
+        "config/cs_config_loader.cc",
+        "config/firmware_config_loader.cc",
+        "config/hal_config_loader.cc",
+    ],
+}
+
+filegroup {
+    name: "hal_debug_srcs",
+    srcs: [
+        "debug/bluetooth_activity.cc",
+        "debug/bluetooth_bqr.cc",
+        "debug/debug_central.cc",
+        "debug/stack_trace_helper.cc",
+        "debug/vnd_snoop_logger.cc",
+        "debug/debug_event_watcher.cc",
+    ],
+}
+
+filegroup {
+    name: "hal_extension_srcs",
+    srcs: [
+        "extensions/cs/bluetooth_channel_sounding.cc",
+        "extensions/cs/bluetooth_channel_sounding_handler.cc",
+        "extensions/cs/bluetooth_channel_sounding_session.cc",
+        "extensions/cs/bluetooth_channel_sounding_util.cc",
+        "extensions/channel_avoidance/bluetooth_channel_avoidance.cc",
+        "extensions/channel_avoidance/bluetooth_channel_avoidance_handler.cc",
+        "extensions/ext/bluetooth_ext.cc",
+        "extensions/ext/bluetooth_ext_handler.cc",
+        "extensions/finder/bluetooth_finder.cc",
+        "extensions/finder/bluetooth_finder_handler.cc",
+        "extensions/sar/bluetooth_sar.cc",
+        "extensions/sar/bluetooth_sar_handler.cc",
+        "extensions/thread/socket_processor.cc",
+        "extensions/thread/thread_daemon.cc",
+        "extensions/thread/thread_handler.cc",
+        "extensions/ccc/bluetooth_ccc.cc",
+        "extensions/ccc/bluetooth_ccc_handler.cc",
+        "extensions/ccc/bluetooth_ccc_timesync_event.cc",
+        "extensions/ccc/bluetooth_ccc_timesync_command.cc",
+    ],
+}
+
+filegroup {
+    name: "hal_hwinit_srcs",
+    srcs: [
+        "chip/chip_provisioner.cc",
+        "chip/async_chip_provisioner.cc",
+    ],
+}
+
+filegroup {
+    name: "hal_util_srcs",
+    srcs: [
+        "util/android_base_wrapper.cc",
+        "util/logging.cc",
+        "util/system_call_wrapper.cc",
+        "util/fd_watcher.cc",
+        "util/files.cc",
+        "util/timer_manager.cc",
+        "util/power/wakelock.cc",
+        "util/power/wakelock_watchdog.cc",
+        "util/power/power_interface.cc",
+    ],
+}
+
+filegroup {
+    name: "hal_transport_srcs",
+    srcs: [
+        "transport/device_control/uart_manager.cc",
+        "transport/device_control/power_manager.cc",
+        "transport/transport_interface.cc",
+        "transport/uart_h4/data_processor.cc",
+        "transport/uart_h4/hci_packetizer.cc",
+        "transport/uart_h4/transport_uart_h4.cc",
+    ],
+}
+
+cc_library_static {
+    name: "libbluetooth_hal",
+    vendor_available: true,
+    defaults: ["libbluetooth_hal_defaults"],
+    export_include_dirs: ["include/public"],
+}
+
+cc_library_headers {
+    name: "libbluetooth_hal_headers",
+    export_include_dirs: ["include/public"],
+    proprietary: true,
+}
+
+cc_defaults {
+    name: "bluetooth_hal_test_defaults",
+    team: "trendy_team_bluetooth",
+    test_suites: ["general-tests"],
+    local_include_dirs: ["include/public"],
+    cflags: ["-DUNIT_TEST"],
+    host_supported: true,
+}
+
+cc_test {
+    name: "bluetooth_hal_core_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "hal_packet_test.cc",
+        "hci_monitor_test.cc",
+        "hci_router_client_test.cc",
+        "hci_router_client.cc",
+        "bluetooth_address_test.cc",
+        ":test_mock_router_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_router_client_agent_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "hci_router_client_agent_test.cc",
+        "hci_router_client_agent.cc",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_hci_router_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "hci_router.cc",
+        "hci_router_test.cc",
+        "hci_router_client.cc",
+        "extensions/thread/socket_processor.cc",
+        "extensions/thread/thread_daemon.cc",
+        "extensions/thread/thread_handler.cc",
+        "util/system_call_wrapper.cc",
+        ":test_mock_transport_srcs",
+        ":test_mock_util_srcs",
+        ":test_mock_debug_srcs",
+        ":test_mock_router_client_agent_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_finder_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    host_supported: false,
+    srcs: [
+        "hci_router_client.cc",
+        "extensions/finder/bluetooth_finder_handler.cc",
+        "extensions/finder/bluetooth_finder_handler_test.cc",
+        ":test_mock_router_srcs",
+        ":test_mock_util_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+        "android.hardware.bluetooth.finder-V1-ndk",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_ext_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    host_supported: true,
+    srcs: [
+        "hci_router_client.cc",
+        "extensions/ext/bluetooth_ext_handler.cc",
+        "extensions/ext/bluetooth_ext_handler_test.cc",
+        ":test_mock_router_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_sar_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "hci_router_client.cc",
+        "extensions/sar/bluetooth_sar_handler.cc",
+        "extensions/sar/bluetooth_sar_handler_test.cc",
+        ":test_mock_router_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_channel_sounding_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "hci_router_client.cc",
+        "extensions/cs/bluetooth_channel_sounding_session.cc",
+        "extensions/cs/bluetooth_channel_sounding_util.cc",
+        "extensions/cs/bluetooth_channel_sounding_handler.cc",
+        "extensions/cs/bluetooth_channel_sounding_handler_test.cc",
+        ":test_mock_router_srcs",
+        ":test_mock_util_srcs",
+    ],
+    header_libs: [
+        "libeigen",
+    ],
+    static_libs: [
+        "android.hardware.bluetooth-V1-ndk",
+        "android.hardware.bluetooth.ranging-V1-ndk",
+        "libgmock",
+        "hal_proto_lib",
+    ],
+    shared_libs: [
+        "libbinder_ndk",
+        "libbase",
+        "libprotobuf-cpp-full",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_thread_handler_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "extensions/thread/socket_processor.cc",
+        "extensions/thread/thread_daemon.cc",
+        "extensions/thread/thread_handler.cc",
+        "extensions/thread/thread_handler_test.cc",
+        "hci_router_client.cc",
+        "util/system_call_wrapper.cc",
+        ":test_mock_router_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_socket_processor_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "extensions/thread/socket_processor.cc",
+        "extensions/thread/socket_processor_test.cc",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_thread_daemon_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "extensions/thread/thread_daemon.cc",
+        "extensions/thread/thread_daemon_test.cc",
+        ":test_mock_thread_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_ccc_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        ":test_mock_router_srcs",
+        "hci_router_client.cc",
+        "extensions/ccc/bluetooth_ccc_timesync_event.cc",
+        "extensions/ccc/bluetooth_ccc_timesync_command.cc",
+        "extensions/ccc/bluetooth_ccc_handler.cc",
+        "extensions/ccc/bluetooth_ccc_timesync_event_test.cc",
+        "extensions/ccc/bluetooth_ccc_timesync_command_test.cc",
+        "extensions/ccc/bluetooth_ccc_handler_test.cc",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_channel_avoidance_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        ":test_mock_router_srcs",
+        "hci_router_client.cc",
+        "extensions/channel_avoidance/bluetooth_channel_avoidance_handler.cc",
+        "extensions/channel_avoidance/bluetooth_channel_avoidance_handler_test.cc",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_config_loader_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "config/hal_config_loader.cc",
+        "config/hal_config_loader_test.cc",
+        ":test_mock_transport_srcs",
+        ":test_mock_util_srcs",
+        "config/cs_config_loader.cc",
+        "config/cs_config_loader_test.cc",
+        "config/firmware_config_loader.cc",
+        "config/firmware_config_loader_test.cc",
+    ],
+    static_libs: [
+        "libgmock",
+        "hal_proto_lib",
+    ],
+    shared_libs: [
+        "libbase",
+        "libprotobuf-cpp-full",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_hci_packetizer_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "transport/uart_h4/hci_packetizer.cc",
+        "transport/uart_h4/hci_packetizer_test.cc",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_transport_interface_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "transport/device_control/uart_manager.cc",
+        "transport/device_control/power_manager.cc",
+        "transport/transport_interface.cc",
+        "transport/transport_interface_test.cc",
+        "transport/uart_h4/data_processor.cc",
+        "transport/uart_h4/hci_packetizer.cc",
+        "transport/uart_h4/transport_uart_h4.cc",
+        "util/fd_watcher.cc",
+        "util/system_call_wrapper.cc",
+        "util/timer_manager.cc",
+        ":test_mock_util_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+        "hal_proto_lib",
+
+    ],
+    shared_libs: [
+        "libbase",
+        "libprotobuf-cpp-full",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_transport_uart_h4_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "config/hal_config_loader.cc",
+        "transport/device_control/uart_manager.cc",
+        "transport/device_control/power_manager.cc",
+        "transport/transport_interface.cc",
+        "transport/uart_h4/data_processor.cc",
+        "transport/uart_h4/hci_packetizer.cc",
+        "transport/uart_h4/transport_uart_h4.cc",
+        "transport/uart_h4/transport_uart_h4_test.cc",
+        "util/fd_watcher.cc",
+        "util/system_call_wrapper.cc",
+        "util/timer_manager.cc",
+        ":test_mock_util_srcs",
+    ],
+    static_libs: [
+        "libgmock",
+        "hal_proto_lib",
+    ],
+    shared_libs: [
+        "libbase",
+        "libprotobuf-cpp-full",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_data_processor_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "transport/uart_h4/hci_packetizer.cc",
+        "transport/uart_h4/data_processor.cc",
+        "transport/uart_h4/data_processor_test.cc",
+        "util/fd_watcher.cc",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "bluetooth_hal_timer_manager_test",
+    defaults: ["bluetooth_hal_test_defaults"],
+    srcs: [
+        "util/timer_manager.cc",
+        "util/timer_manager_test.cc",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
diff --git a/bluetooth/bluetooth_hal/OWNERS b/bluetooth/bluetooth_hal/OWNERS
new file mode 100644
index 0000000000..e059c98d52
--- /dev/null
+++ b/bluetooth/bluetooth_hal/OWNERS
@@ -0,0 +1,2 @@
+ugoyu@google.com
+ashchen@google.com
diff --git a/bluetooth/bluetooth_hal/bluetooth_address_test.cc b/bluetooth/bluetooth_hal/bluetooth_address_test.cc
new file mode 100644
index 0000000000..2a1614ffae
--- /dev/null
+++ b/bluetooth/bluetooth_hal/bluetooth_address_test.cc
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/bluetooth_address.h"
+
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace hci {
+namespace {
+
+TEST(BluetoothAddressTest, HandleToString) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  ASSERT_EQ(address.ToFullString(), "11:22:33:44:55:66");
+  ASSERT_EQ(address.ToString(), "XX:XX:XX:XX:55:66");
+}
+
+}  // namespace
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/bluetooth_hal.cc b/bluetooth/bluetooth_hal/bluetooth_hal.cc
new file mode 100644
index 0000000000..7e0a083493
--- /dev/null
+++ b/bluetooth/bluetooth_hal/bluetooth_hal.cc
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/bluetooth_hal.h"
+
+#include <memory>
+#include <string>
+
+#include "android-base/logging.h"
+#include "android/binder_interface_utils.h"
+#include "android/binder_manager.h"
+#include "android/binder_process.h"
+#include "android/binder_status.h"
+#include "bluetooth_hal/bluetooth_hci.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding.h"
+#include "bluetooth_hal/extensions/finder/bluetooth_finder.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+
+namespace bluetooth_hal {
+
+using ::bluetooth_hal::BluetoothHci;
+using ::bluetooth_hal::extensions::cs::BluetoothChannelSounding;
+using ::bluetooth_hal::extensions::finder::BluetoothFinder;
+using ::bluetooth_hal::transport::TransportInterface;
+
+using ::ndk::SharedRefBase;
+
+BluetoothHal& BluetoothHal::GetHal() {
+  static BluetoothHal hal;
+  return hal;
+}
+
+bool BluetoothHal::RegisterVendorTransport(
+    std::unique_ptr<::bluetooth_hal::transport::TransportInterface> transport) {
+  return TransportInterface::RegisterVendorTransport(std::move(transport));
+}
+
+void BluetoothHal::Start() {
+  std::shared_ptr<BluetoothChannelSounding> bluetooth_channel_sounding =
+      SharedRefBase::make<BluetoothChannelSounding>();
+  std::shared_ptr<BluetoothFinder> bluetooth_finder =
+      SharedRefBase::make<BluetoothFinder>();
+
+  std::string instance;
+  int status;
+
+  instance = std::string() + BluetoothChannelSounding::descriptor + "/default";
+  status = AServiceManager_addService(
+      bluetooth_channel_sounding->asBinder().get(), instance.c_str());
+  if (status != STATUS_OK) {
+    LOG(ERROR) << "Could not register BluetoothChannelSounding as a service!";
+  }
+
+  instance = std::string() + BluetoothFinder::descriptor + "/default";
+  status = AServiceManager_addService(bluetooth_finder->asBinder().get(),
+                                      instance.c_str());
+  if (status != STATUS_OK) {
+    LOG(ERROR) << "Could not register BluetoothFinder as a service!";
+  }
+
+  instance = std::string() + BluetoothHci::descriptor + "/default";
+  status = AServiceManager_addService(BluetoothHci::GetHci().asBinder().get(),
+                                      instance.c_str());
+  if (status == STATUS_OK) {
+    ABinderProcess_joinThreadPool();
+  } else {
+    LOG(ERROR) << "Could not register as a service!";
+  }
+}
+
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/bluetooth_hci.cc b/bluetooth/bluetooth_hal/bluetooth_hci.cc
new file mode 100644
index 0000000000..39feb03777
--- /dev/null
+++ b/bluetooth/bluetooth_hal/bluetooth_hci.cc
@@ -0,0 +1,348 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.hci"
+
+#include "bluetooth_hal/bluetooth_hci.h"
+
+#include <atomic>
+#include <csignal>
+#include <cstdint>
+#include <functional>
+#include <memory>
+#include <sstream>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/IBluetoothHciCallbacks.h"
+#include "aidl/android/hardware/bluetooth/Status.h"
+#include "android-base/logging.h"
+#include "android/binder_auto_utils.h"
+#include "android/binder_status.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/extensions/finder/bluetooth_finder_handler.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router.h"
+#include "bluetooth_hal/util/power/wakelock.h"
+
+namespace bluetooth_hal {
+
+using ::aidl::android::hardware::bluetooth::IBluetoothHciCallbacks;
+using ::aidl::android::hardware::bluetooth::Status;
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::debug::DebugCentral;
+using ::bluetooth_hal::extensions::finder::BluetoothFinderHandler;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HalPacketCallback;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::HciRouter;
+using ::bluetooth_hal::hci::HciRouterCallback;
+using ::bluetooth_hal::hci::MonitorMode;
+using ::bluetooth_hal::util::power::ScopedWakelock;
+using ::bluetooth_hal::util::power::WakeSource;
+
+using ::ndk::ScopedAStatus;
+
+using HalStateChangedCallback = std::function<void(HalState, HalState)>;
+
+std::atomic<bool> BluetoothHci::is_signal_handled_{false};
+
+class BluetoothHalDeathRecipient {
+ public:
+  void LinkToDeath(const std::shared_ptr<IBluetoothHciCallbacks>& cb) {
+    bluetooth_hci_callback_ = cb;
+
+    auto on_link_died = [](void* cookie) {
+      auto* death_recipient = static_cast<BluetoothHalDeathRecipient*>(cookie);
+      death_recipient->ServiceDied();
+    };
+
+    client_death_recipient_ = AIBinder_DeathRecipient_new(on_link_died);
+
+    binder_status_t link_to_death_return_status =
+        AIBinder_linkToDeath(bluetooth_hci_callback_->asBinder().get(),
+                             client_death_recipient_, this /* cookie */);
+
+    if (link_to_death_return_status != STATUS_OK) {
+      LOG(FATAL) << "Unable to link to death recipient";
+    }
+  }
+
+  void UnlinkToDeath(const std::shared_ptr<IBluetoothHciCallbacks>& cb) {
+    if (cb != bluetooth_hci_callback_) {
+      LOG(FATAL) << "Unable to unlink mismatched pointers";
+    }
+
+    binder_status_t unlink_to_death_return_status =
+        AIBinder_unlinkToDeath(bluetooth_hci_callback_->asBinder().get(),
+                               client_death_recipient_, this);
+
+    if (unlink_to_death_return_status != STATUS_OK) {
+      LOG(FATAL) << "Unable to unlink to death recipient";
+    }
+  }
+
+  void ServiceDied() {
+    if (bluetooth_hci_callback_ != nullptr &&
+        !AIBinder_isAlive(bluetooth_hci_callback_->asBinder().get())) {
+      LOG(ERROR)
+          << "BluetoothHalDeathRecipient::serviceDied - Bluetooth service died";
+    } else {
+      LOG(ERROR) << "BluetoothHalDeathRecipient::serviceDied called but "
+                    "service not dead";
+      return;
+    }
+    has_died_ = true;
+    ANCHOR_LOG(AnchorType::SERVICE_DIED) << __func__;
+
+    // TODO: b/414524533 - remove FATAL message once the bug is fixed.
+    LOG(FATAL) << "Bluetooth stack ServiceDied!";
+
+    BluetoothHci::GetHci().close();
+  }
+  bool GetHasDied() const { return has_died_; }
+  void SetHasDied(bool died) { has_died_ = died; }
+
+ private:
+  bool has_died_;
+  std::shared_ptr<IBluetoothHciCallbacks> bluetooth_hci_callback_;
+  AIBinder_DeathRecipient* client_death_recipient_;
+};
+
+class HciCallback : public HciRouterCallback {
+ public:
+  HciCallback(const HalPacketCallback& dispatch_packet_to_stack,
+              const HalStateChangedCallback& handle_hal_state_changed)
+      : dispatch_packet_to_stack_(dispatch_packet_to_stack),
+        handle_hal_state_changed_(handle_hal_state_changed) {}
+
+  void OnCommandCallback(const HalPacket& packet) override {
+    OnPacketCallback(packet);
+  }
+
+  MonitorMode OnPacketCallback(const HalPacket& packet) override {
+    dispatch_packet_to_stack_(packet);
+    return MonitorMode::kNone;
+  }
+
+  void OnHalStateChanged(const HalState new_state, const HalState old_state) {
+    handle_hal_state_changed_(new_state, old_state);
+  }
+
+ private:
+  HalPacketCallback dispatch_packet_to_stack_;
+  HalStateChangedCallback handle_hal_state_changed_;
+};
+
+BluetoothHci::BluetoothHci()
+    : bluetooth_hci_callback_(nullptr),
+      death_recipient_(std::make_shared<BluetoothHalDeathRecipient>()) {
+  // Get configs.
+
+  std::signal(SIGTERM, SigtermHandler);
+
+  // Lazily construct the static HciRouter instance.
+  HciRouter::GetRouter();
+}
+
+void BluetoothHci::SigtermHandler(int signum) {
+  LOG(ERROR) << __func__ << ": Received signal: " << signum;
+
+  if (is_signal_handled_.exchange(true)) {
+    LOG(WARNING) << __func__ << ": Signal is already handled, Skip.";
+    return;
+  }
+
+  if (BluetoothFinderHandler::GetHandler().StartPoweredOffFinderMode()) {
+    return;
+  }
+
+  BluetoothHci::GetHci().close();
+  kill(getpid(), SIGKILL);
+}
+
+ScopedAStatus BluetoothHci::initialize(
+    const std::shared_ptr<IBluetoothHciCallbacks>& cb) {
+  DURATION_TRACKER(AnchorType::BTHAL_INIT, __func__);
+  ScopedWakelock wakelock(WakeSource::kInitialize);
+
+  LOG(INFO) << "Initializing Bluetooth HAL.";
+  if (bluetooth_hci_callback_ != nullptr) {
+    LOG(WARNING) << "The HAL has already been initialized!";
+    cb->initializationComplete(Status::ALREADY_INITIALIZED);
+    return ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+  }
+
+  is_initializing_ = true;
+  bluetooth_hci_callback_ = cb;
+
+  death_recipient_->SetHasDied(false);
+  death_recipient_->LinkToDeath(cb);
+  unlink_cb_ =
+      [cb](std::shared_ptr<BluetoothHalDeathRecipient>& death_recipient) {
+        if (death_recipient->GetHasDied()) {
+          LOG(INFO) << "Skipping unlink call, service died.";
+        } else {
+          death_recipient->UnlinkToDeath(cb);
+        }
+      };
+
+  auto callback = std::make_shared<HciCallback>(
+      std::bind_front(&BluetoothHci::DispatchPacketToStack, this),
+      std::bind_front(&BluetoothHci::HandleHalStateChanged, this));
+  bool status = HciRouter::GetRouter().Initialize(callback);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothHci::sendHciCommand(
+    const std::vector<uint8_t>& command) {
+  HalPacket packet(static_cast<uint8_t>(HciPacketType::kCommand), command);
+  DURATION_TRACKER(
+      AnchorType::SEND_HCI_CMD,
+      (std::stringstream() << __func__ << ": 0x" << std::hex << std::setw(4)
+                           << std::setfill('0') << packet.GetCommandOpcode()
+                           << " - " << std::dec << packet.size() << " bytes")
+          .str());
+  SendDataToController(packet);
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothHci::sendAclData(const std::vector<uint8_t>& data) {
+  HalPacket packet(static_cast<uint8_t>(HciPacketType::kAclData), data);
+  DURATION_TRACKER(
+      AnchorType::SEND_ACL_DAT,
+      (std::stringstream() << __func__ << ": " << packet.size() << " bytes")
+          .str());
+  SendDataToController(packet);
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothHci::sendScoData(const std::vector<uint8_t>& data) {
+  HalPacket packet(static_cast<uint8_t>(HciPacketType::kScoData), data);
+  DURATION_TRACKER(
+      AnchorType::SEND_SCO_DAT,
+      (std::stringstream() << __func__ << ": " << packet.size() << " bytes")
+          .str());
+  SendDataToController(packet);
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothHci::sendIsoData(const std::vector<uint8_t>& data) {
+  HalPacket packet(static_cast<uint8_t>(HciPacketType::kIsoData), data);
+  DURATION_TRACKER(
+      AnchorType::SEND_ISO_DAT,
+      (std::stringstream() << __func__ << ": " << packet.size() << " bytes")
+          .str());
+  SendDataToController(packet);
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothHci::close() {
+  bluetooth_hci_callback_ = nullptr;
+  ANCHOR_LOG_INFO(AnchorType::BTHAL_CLOSE) << __func__;
+  ScopedWakelock wakelock(WakeSource::kClose);
+  HciRouter::GetRouter().Cleanup();
+  unlink_cb_(death_recipient_);
+  return ScopedAStatus::ok();
+}
+
+binder_status_t BluetoothHci::dump(int fd, const char**, uint32_t) {
+  LOG(INFO) << __func__ << ": Dump debug log";
+#ifndef UNIT_TEST
+  DebugCentral::Get()->Dump(fd);
+#endif
+  fsync(fd);
+  return STATUS_OK;
+}
+
+void BluetoothHci::SendDataToController(const HalPacket& packet) {
+  HciRouter::GetRouter().Send(packet);
+}
+
+void BluetoothHci::DispatchPacketToStack(const HalPacket& packet) {
+  if (bluetooth_hci_callback_ == nullptr) {
+    LOG(ERROR) << "bluetooth_hci_callback is null!";
+    return;
+  }
+  HciPacketType type = packet.GetType();
+  switch (type) {
+    case HciPacketType::kEvent: {
+      DURATION_TRACKER(AnchorType::CALLBACK_HCI_EVT,
+                       (std::stringstream() << "cb->hciEventReceived: "
+                                            << packet.size() << " bytes")
+                           .str());
+      bluetooth_hci_callback_->hciEventReceived(packet.GetBody());
+      break;
+    }
+    case HciPacketType::kAclData: {
+      DURATION_TRACKER(AnchorType::CALLBACK_HCI_ACL,
+                       (std::stringstream()
+                        << "cb->aclDataReceived: " << packet.size() << " bytes")
+                           .str());
+      bluetooth_hci_callback_->aclDataReceived(packet.GetBody());
+      break;
+    }
+    case HciPacketType::kScoData: {
+      DURATION_TRACKER(AnchorType::CALLBACK_HCI_SCO,
+                       (std::stringstream()
+                        << "cb->scoDataReceived: " << packet.size() << " bytes")
+                           .str());
+      bluetooth_hci_callback_->scoDataReceived(packet.GetBody());
+      break;
+    }
+    case HciPacketType::kIsoData: {
+      DURATION_TRACKER(AnchorType::CALLBACK_HCI_ISO,
+                       (std::stringstream()
+                        << "cb->isoDataReceived: " << packet.size() << " bytes")
+                           .str());
+      bluetooth_hci_callback_->isoDataReceived(packet.GetBody());
+      break;
+    }
+    default:
+      LOG(ERROR) << "Unexpected packet type: " << packet.ToString();
+      break;
+  }
+}
+
+void BluetoothHci::HandleHalStateChanged(HalState new_state,
+                                         [[maybe_unused]] HalState old_state) {
+  if (is_initializing_ && bluetooth_hci_callback_ != nullptr) {
+    switch (new_state) {
+      case HalState::kRunning:
+        LOG(INFO) << "Initialization Complete!";
+        is_initializing_ = false;
+        bluetooth_hci_callback_->initializationComplete(Status::SUCCESS);
+        break;
+      case HalState::kShutdown:
+        LOG(ERROR) << "Unexpected state change during initialization!";
+        is_initializing_ = false;
+        bluetooth_hci_callback_->initializationComplete(
+            Status::HARDWARE_INITIALIZATION_ERROR);
+        break;
+      default:
+        break;
+    }
+  }
+}
+
+BluetoothHci& BluetoothHci::GetHci() {
+  static BluetoothHci hci;
+  return hci;
+}
+
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/chip/async_chip_provisioner.cc b/bluetooth/bluetooth_hal/chip/async_chip_provisioner.cc
new file mode 100644
index 0000000000..2c91d4b75c
--- /dev/null
+++ b/bluetooth/bluetooth_hal/chip/async_chip_provisioner.cc
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.chip_provisioner"
+
+#include "bluetooth_hal/chip/async_chip_provisioner.h"
+
+#include <memory>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/worker.h"
+
+namespace bluetooth_hal {
+namespace chip {
+namespace {
+
+using ::bluetooth_hal::HalState;
+
+std::string MessageTypeToString(ChipProvisionMessageType type) {
+  switch (type) {
+    case ChipProvisionMessageType::kInitialize:
+      return "Initialize";
+    case ChipProvisionMessageType::kDownloadFirmware:
+      return "DownloadFirmware";
+    case ChipProvisionMessageType::kResetFirmware:
+      return "ResetFirmware";
+    default:
+      return "Unknown";
+  }
+}
+
+}  // namespace
+
+ChipProvisionMessage ChipProvisionMessage::CreateInitialize(
+    InitializePayload payload) {
+  ChipProvisionMessage msg;
+  msg.type = ChipProvisionMessageType::kInitialize;
+  msg.payload = std::move(payload);
+  return msg;
+}
+
+ChipProvisionMessage ChipProvisionMessage::CreateDownloadFirmware() {
+  ChipProvisionMessage msg;
+  msg.type = ChipProvisionMessageType::kDownloadFirmware;
+  msg.payload = DownloadFirmwarePayload{};
+  return msg;
+}
+
+ChipProvisionMessage ChipProvisionMessage::CreateResetFirmware() {
+  ChipProvisionMessage msg;
+  msg.type = ChipProvisionMessageType::kResetFirmware;
+  msg.payload = ResetFirmwarePayload{};
+  return msg;
+}
+
+AsyncChipProvisioner::AsyncChipProvisioner()
+    : worker_([this](ChipProvisionMessage msg) {
+        this->ProcessMessage(std::move(msg));
+      }) {}
+
+AsyncChipProvisioner& AsyncChipProvisioner::GetProvisioner() {
+  static AsyncChipProvisioner provisioner;
+  return provisioner;
+}
+
+void AsyncChipProvisioner::PostInitialize(
+    const std::function<void(HalState)> on_hal_state_update) {
+  InitializePayload payload = {std::move(on_hal_state_update)};
+  worker_.Post(ChipProvisionMessage::CreateInitialize(std::move(payload)));
+}
+
+void AsyncChipProvisioner::PostDownloadFirmware() {
+  worker_.Post(ChipProvisionMessage::CreateDownloadFirmware());
+}
+
+void AsyncChipProvisioner::PostResetFirmware() {
+  worker_.Post(ChipProvisionMessage::CreateResetFirmware());
+}
+
+void AsyncChipProvisioner::ProcessMessage(ChipProvisionMessage message) {
+  LOG(DEBUG) << __func__
+             << ": Message type: " << MessageTypeToString(message.type);
+
+  switch (message.type) {
+    case ChipProvisionMessageType::kInitialize:
+      // Only Initialize has a payload now.
+      if (auto* payload = std::get_if<InitializePayload>(&message.payload)) {
+        HandleInitialize(*payload);
+      } else {
+        LOG(WARNING) << __func__ << ": Callback is null.";
+      }
+      break;
+    case ChipProvisionMessageType::kDownloadFirmware:
+      HandleDownloadFirmware();
+      break;
+    case ChipProvisionMessageType::kResetFirmware:
+      HandleResetFirmware();
+      break;
+    default:
+      break;
+  }
+}
+
+void AsyncChipProvisioner::HandleInitialize(const InitializePayload& payload) {
+  if (chip_provisioner_) {
+    return;
+  }
+  chip_provisioner_ = std::make_unique<ChipProvisioner>();
+  chip_provisioner_->Initialize(payload.on_hal_state_update);
+};
+
+void AsyncChipProvisioner::HandleDownloadFirmware() {
+  if (chip_provisioner_) {
+    chip_provisioner_->DownloadFirmware();
+  }
+};
+
+void AsyncChipProvisioner::HandleResetFirmware() {
+  if (chip_provisioner_) {
+    chip_provisioner_->ResetFirmware();
+  }
+};
+
+}  // namespace chip
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/chip/chip_provisioner.cc b/bluetooth/bluetooth_hal/chip/chip_provisioner.cc
new file mode 100644
index 0000000000..5a54d92233
--- /dev/null
+++ b/bluetooth/bluetooth_hal/chip/chip_provisioner.cc
@@ -0,0 +1,358 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.chip_provisioner"
+
+#include "bluetooth_hal/chip/chip_provisioner.h"
+
+#include <chrono>
+#include <fstream>
+#include <future>
+#include <sstream>
+#include <thread>
+
+#include "android-base/logging.h"
+#include "android-base/properties.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/config/firmware_config_loader.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router.h"
+
+namespace bluetooth_hal {
+namespace chip {
+namespace {
+
+using ::android::base::GetProperty;
+using ::android::base::StringPrintf;
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::config::DataPacket;
+using ::bluetooth_hal::config::DataType;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::config::SetupCommandType;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::HciRouter;
+
+constexpr char kDevinfoNodePath[] = "/proc/device-tree/chosen/config/bt_addr";
+constexpr char kRandGenBdaddrPath[] =
+    "/mnt/vendor/persist/bluetooth/bdaddr.txt";
+constexpr char kEvbDefaultBdaddrProp[] = "ro.vendor.bluetooth.evb_bdaddr";
+constexpr uint16_t kHciVscWriteBdAddress = 0xfc01;
+constexpr uint16_t kHciVscWriteBdAddressLength = 0x0A;
+
+}  // namespace
+
+void ChipProvisioner::Initialize(
+    const std::function<void(HalState)> on_hal_state_update) {
+  on_hal_state_update_ = std::move(on_hal_state_update);
+}
+
+bool ChipProvisioner::DownloadFirmware() {
+  LOG(INFO) << __func__;
+
+  HandleNextSetupStep(SetupCommandType::kReset);
+
+  if (HciRouter::GetRouter().GetHalState() < HalState::kBtChipReady) {
+    // TODO: b/372148907 - Need to report error (kill self if needed).
+    LOG(FATAL) << __func__ << ": Failed to complete download firmware.";
+    return false;
+  }
+  return true;
+}
+
+bool ChipProvisioner::ResetFirmware() {
+  LOG(INFO) << __func__;
+  if (!ExecuteCurrentSetupStep(SetupCommandType::kReset)) {
+    LOG(ERROR) << __func__ << ": Failed to reset firmware.";
+    // TODO: b/372148907 - Need to report error (kill self if needed).
+    return false;
+  }
+
+  switch (HciRouter::GetRouter().GetHalState()) {
+    case HalState::kBtChipReady:
+      UpdateHalState(HalState::kRunning);
+      break;
+    case HalState::kRunning:
+      UpdateHalState(HalState::kBtChipReady);
+      break;
+    default:
+      // TODO: b/372148907 - Need to report error (kill self if needed).
+      return false;
+  }
+
+  return true;
+}
+
+bool ChipProvisioner::ExecuteCurrentSetupStep(SetupCommandType command_type) {
+  // Get the next firmware setup command via command type.
+  auto next_setup_command = config_loader_.GetSetupCommandPacket(command_type);
+  if (!next_setup_command.has_value()) {
+    LOG(ERROR) << __func__ << ": Failed to get next setup command.";
+    return false;
+  }
+
+  return SendCommandAndWait(next_setup_command->get().GetPayload());
+}
+
+bool ChipProvisioner::SendCommandAndWait(const HalPacket& packet) {
+  if (!SendCommand(packet)) {
+    LOG(ERROR) << __func__ << ": Failed to send next setup command.";
+    return false;
+  }
+
+  std::future_status status =
+      command_promise_.get_future().wait_for(std::chrono::milliseconds(1000));
+  if (status != std::future_status::ready) {
+    LOG(ERROR) << __func__ << ": Command timeout during download firmware.";
+    return false;
+  }
+  command_promise_ = std::promise<void>();
+  return firmware_command_success_;
+}
+
+void ChipProvisioner::OnCommandCallback(const HalPacket& callback_event) {
+  bool success = (callback_event.GetCommandCompleteEventResult() ==
+                  static_cast<uint8_t>(EventResultCode::kSuccess));
+  LOG(success ? INFO : WARNING)
+      << __func__ << ": Recv VSE <" << callback_event.ToString() << "> "
+      << (success ? "[Success]" : "[Failed]");
+  firmware_command_success_ = success;
+  command_promise_.set_value();
+}
+
+bool ChipProvisioner::ProvisionBluetoothAddress() {
+  LOG(INFO) << __func__;
+  std::string bdaddr_str;
+  std::fstream devinfo(kDevinfoNodePath, std::ios::in);
+  std::fstream randgen(kRandGenBdaddrPath, std::ios::in);
+  if (devinfo.is_open()) {
+    std::getline(devinfo, bdaddr_str);
+  } else if (randgen.is_open()) {
+    std::getline(randgen, bdaddr_str);
+  } else {
+    bdaddr_str = GetProperty(kEvbDefaultBdaddrProp, "");
+  }
+
+  if (bdaddr_str.empty()) {
+    LOG(ERROR) << __func__ << "Can't fetch the provisioning BDA (empty string)";
+    return false;
+  }
+
+  unsigned char trailing_char = '\0';
+  auto try_parse = [&](const char* fmt) {
+    return std::sscanf(bdaddr_str.data(), fmt, &bdaddr_[5], &bdaddr_[4],
+                       &bdaddr_[3], &bdaddr_[2], &bdaddr_[1], &bdaddr_[0],
+                       &trailing_char) == kBluetoothAddressLength;
+  };
+
+  bool success = try_parse("%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx%c") ||
+                 try_parse("%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%c");
+
+  if (!success) {
+    LOG(ERROR) << __func__
+               << "Can't fetch the provisioning BDA (invalid format)";
+    return false;
+  }
+
+  LOG(INFO) << __func__ << ": BDADDR <"
+            << StringPrintf("xx:xx:xx:xx:%02x:%02x", bdaddr_[1], bdaddr_[0])
+            << ">";
+
+  std::optional<HalPacket> write_bda_packet = PrepareWriteBdAddressPacket();
+  if (write_bda_packet.has_value()) {
+    if (!SendCommandAndWait(write_bda_packet.value())) {
+      LOG(ERROR) << __func__
+                 << "Failed to send write Bluetooth address command.";
+      return false;
+    }
+    return true;
+  } else {
+    LOG(ERROR) << __func__
+               << "Failed to prepare write Bluetooth address packet.";
+    return false;
+  }
+}
+
+std::optional<HalPacket> ChipProvisioner::PrepareWriteBdAddressPacket() {
+  if (bdaddr_.size() != kBluetoothAddressLength) {
+    LOG(ERROR) << __func__ << ": Invalid Bluetooth address length";
+    return std::nullopt;
+  }
+
+  HalPacket write_bda_vsc;
+  write_bda_vsc.resize(kHciVscWriteBdAddressLength);
+
+  // Prepare the HalPacket elements for the WriteBdAddress command.
+  write_bda_vsc[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  write_bda_vsc[1] = kHciVscWriteBdAddress & 0xff;
+  write_bda_vsc[2] = (kHciVscWriteBdAddress >> 8u) & 0xff;
+  write_bda_vsc[3] = kBluetoothAddressLength;
+
+  memcpy(write_bda_vsc.data() + 4, bdaddr_.data(), kBluetoothAddressLength);
+
+  std::stringstream ss;
+  for (uint8_t byte : write_bda_vsc) {
+    ss << StringPrintf("%02x", byte);
+  }
+  LOG(INFO) << __func__ << ": Prepared VSC <" << ss.str() << ">";
+
+  return write_bda_vsc;
+}
+
+void ChipProvisioner::UpdateHalState(HalState status) {
+  // Check if a callback is present.
+  if (on_hal_state_update_.has_value()) {
+    on_hal_state_update_.value()(status);
+  } else {
+    LOG(WARNING) << "No download callback registered.";
+  }
+}
+
+bool ChipProvisioner::SendCommandNoAck(const HalPacket& packet) {
+  if (packet.GetType() != HciPacketType::kCommand) {
+    LOG(WARNING) << __func__ << ": Invalid Packet Type.";
+    return false;
+  }
+  return HciRouter::GetRouter().SendCommandNoAck(packet);
+}
+
+void ChipProvisioner::HandleNextSetupStep(SetupCommandType command) {
+  switch (command) {
+    case SetupCommandType::kReset:
+      LOG(INFO) << __func__ << ": Reset";
+      if (ExecuteCurrentSetupStep(command)) {
+        HandleNextSetupStep(SetupCommandType::kReadChipId);
+      }
+      break;
+    case SetupCommandType::kReadChipId:
+      LOG(INFO) << __func__ << ": ReadChipId";
+      if (ExecuteCurrentSetupStep(command)) {
+        HandleNextSetupStep(SetupCommandType::kUpdateChipBaudRate);
+      }
+      break;
+    case SetupCommandType::kUpdateChipBaudRate:
+      if (ExecuteCurrentSetupStep(command)) {
+        if (HciRouter::GetRouter().GetHalState() ==
+            HalState::kFirmwareDownloadCompleted) {
+          LOG(INFO) << __func__ << ": [ FirmwareReady ]";
+          UpdateHalState(HalState::kFirmwareReady);
+          HandleNextSetupStep(SetupCommandType::kReadFwVersion);
+        } else {
+          LOG(INFO) << __func__ << ": [ FirmwareDownloading ]";
+          UpdateHalState(HalState::kFirmwareDownloading);
+          HandleNextSetupStep(SetupCommandType::kSetFastDownload);
+        }
+      }
+      break;
+    case SetupCommandType::kSetFastDownload:
+      LOG(INFO) << __func__ << ": SetFastDownload";
+      if (ExecuteCurrentSetupStep(command)) {
+        HandleNextSetupStep(SetupCommandType::kDownloadMinidrv);
+      }
+      break;
+    case SetupCommandType::kDownloadMinidrv: {
+      if (ExecuteCurrentSetupStep(command)) {
+        // Add delay time for placing firmware in download mode
+        int mini_drv_delay_ms = config_loader_.GetLoadMiniDrvDelayMs();
+        std::this_thread::sleep_for(
+            std::chrono::milliseconds(mini_drv_delay_ms));
+        LOG(INFO) << __func__ << ":Writing firmware patchram";
+        // Write firmware patchram packets.
+        if (!WriteFwPatchramPacket()) {
+          LOG(ERROR) << __func__
+                     << ": Failed to write Firmware PatchRam Packets.";
+          return;
+        }
+        HandleNextSetupStep(SetupCommandType::kLaunchRam);
+      }
+      break;
+    }
+    case SetupCommandType::kLaunchRam: {
+      if (ExecuteCurrentSetupStep(command)) {
+        // Add settlement time after launching ram.
+        int launch_ram_delay_ms = config_loader_.GetLaunchRamDelayMs();
+        std::this_thread::sleep_for(
+            std::chrono::milliseconds(launch_ram_delay_ms));
+
+        LOG(INFO) << "[ FirmwareDownloadCompleted ]";
+        UpdateHalState(HalState::kFirmwareDownloadCompleted);
+        HandleNextSetupStep(SetupCommandType::kReset);
+      }
+      break;
+    }
+    case SetupCommandType::kReadFwVersion:
+      if (ExecuteCurrentSetupStep(command)) {
+        // TODO: Extract firmware version from the callback event.
+        LOG(INFO) << "ReadFwVersion";
+        HandleNextSetupStep(SetupCommandType::kWriteBdAddress);
+      }
+      break;
+    case SetupCommandType::kWriteBdAddress:
+      LOG(INFO) << "writing BDA to controller";
+      if (!ProvisionBluetoothAddress()) {
+        LOG(ERROR) << __func__
+                   << ": Failed to provision and write Bluetooth address.";
+        // TODO: b/409658769 - Force to abort hal service and report issue.
+      }
+      HandleNextSetupStep(SetupCommandType::kSetupLowPowerMode);
+      break;
+    case SetupCommandType::kSetupLowPowerMode:
+      if (HalConfigLoader::GetLoader().IsLowPowerModeSupported()) {
+        if (!ExecuteCurrentSetupStep(command)) {
+          // Command failed, no need to proceed to BtChipReady
+          LOG(ERROR) << __func__ << ": Failed to send low power mode command.";
+          break;  // Exit the case early
+        }
+      } else {
+        LOG(WARNING) << "Low power mode is disabled!";
+      }
+      // End of the firmware downloading process.
+      LOG(INFO) << "[ BtChipReady ]";
+      UpdateHalState(HalState::kBtChipReady);
+      break;
+    default:
+      LOG(ERROR) << __func__ << ": Unknown setup command type.";
+      return;
+  }
+}
+
+bool ChipProvisioner::WriteFwPatchramPacket() {
+  if (!config_loader_.ResetFirmwareDataLoadingState()) {
+    LOG(ERROR) << __func__ << ": Failed to load firmware data";
+    return false;
+  }
+
+  std::optional<DataPacket> data_packet;
+  while ((data_packet = config_loader_.GetNextFirmwareData()).has_value()) {
+    if ((*data_packet).GetDataType() == config::DataType::kDataEnd) {
+      // The last firmware patchram packet is expected be launchram command.
+      LOG(INFO) << " the latest patchram packet: "
+                << (*data_packet).GetPayload().ToString();
+      break;
+    }
+    if (!SendCommandNoAck((*data_packet).GetPayload())) {
+      LOG(ERROR) << __func__ << ": Failed to send firmware data packet";
+      return false;
+    }
+  }
+  return true;
+}
+
+}  // namespace chip
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/cs_config_loader.cc b/bluetooth/bluetooth_hal/config/cs_config_loader.cc
new file mode 100644
index 0000000000..e4742fbb37
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/cs_config_loader.cc
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.cs_config"
+
+#include "bluetooth_hal/config/cs_config_loader.h"
+
+#include <fstream>
+#include <iterator>
+#include <sstream>
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "cs_config.pb.h"
+#include "google/protobuf/util/json_util.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+using ::bluetooth_hal::config::proto::CalibrationCommands;
+using ::bluetooth_hal::hci::HalPacket;
+
+using ::google::protobuf::util::JsonParseOptions;
+using ::google::protobuf::util::JsonStringToMessage;
+using ::google::protobuf::util::Status;
+
+constexpr std::string_view kCsConfigFile =
+    "/vendor/etc/bluetooth/bluetooth_channel_sounding_calibration.json";
+
+class CsConfigLoaderImpl : public CsConfigLoader {
+ public:
+  CsConfigLoaderImpl();
+
+  bool LoadConfig() override;
+  bool LoadConfigFromFile(std::string_view path) override;
+  bool LoadConfigFromString(std::string_view content) override;
+
+  const std::vector<HalPacket>& GetCsCalibrationCommands() const override;
+
+  std::string DumpConfigToString() const override;
+
+ private:
+  std::vector<HalPacket> cs_calibration_commands_;
+};
+
+CsConfigLoaderImpl::CsConfigLoaderImpl() {
+#ifndef UNIT_TEST
+  LoadConfig();
+#endif
+}
+
+bool CsConfigLoaderImpl::LoadConfig() {
+  return LoadConfigFromFile(kCsConfigFile);
+}
+
+bool CsConfigLoaderImpl::LoadConfigFromFile(std::string_view path) {
+  std::ifstream json_file(path.data());
+  if (!json_file.is_open()) {
+    LOG(ERROR) << __func__ << ": Failed to open json file " << path.data();
+    return false;
+  }
+
+  std::string json_str((std::istreambuf_iterator<char>(json_file)),
+                       std::istreambuf_iterator<char>());
+
+  return LoadConfigFromString(json_str);
+}
+
+bool CsConfigLoaderImpl::LoadConfigFromString(std::string_view content) {
+  CalibrationCommands calibration_commands;
+  JsonParseOptions options;
+  options.ignore_unknown_fields = true;
+
+  Status status = JsonStringToMessage(content, &calibration_commands, options);
+  if (!status.ok()) {
+    LOG(ERROR) << __func__
+               << ": Failed to parse json content, error: " << status.message();
+    return false;
+  }
+
+  cs_calibration_commands_.clear();
+
+  for (const auto& command : calibration_commands.commands()) {
+    HalPacket packet;
+
+    packet.push_back(command.packet_type());
+    packet.push_back(command.opcode() & 0xff);
+    packet.push_back((command.opcode() >> 8u) & 0xff);
+    packet.push_back(command.payload_length());
+
+    packet.insert(packet.end(), command.sub_opcode().begin(),
+                  command.sub_opcode().end());
+    packet.insert(packet.end(), command.data().begin(), command.data().end());
+
+    cs_calibration_commands_.emplace_back(packet);
+  }
+
+  LOG(INFO) << DumpConfigToString();
+
+  return true;
+}
+
+const std::vector<HalPacket>& CsConfigLoaderImpl::GetCsCalibrationCommands()
+    const {
+  return cs_calibration_commands_;
+}
+
+std::string CsConfigLoaderImpl::DumpConfigToString() const {
+  std::stringstream ss;
+  ss << "--- CsConfigLoaderImpl State ---\n";
+  ss << "CS Calibration Commands Loaded: " << cs_calibration_commands_.size()
+     << " command(s)\n";
+  ss << "-------------------------------\n";
+  return ss.str();
+}
+
+CsConfigLoader& CsConfigLoader::GetLoader() {
+  static CsConfigLoaderImpl loader;
+  return loader;
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/cs_config_loader_test.cc b/bluetooth/bluetooth_hal/config/cs_config_loader_test.cc
new file mode 100644
index 0000000000..72ae40fe32
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/cs_config_loader_test.cc
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/config/cs_config_loader.h"
+
+#include <string_view>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace config {
+namespace {
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::util::MockAndroidBaseWrapper;
+
+using ::testing::Test;
+
+constexpr std::string_view kValidContent = R"({
+  "commands": [
+      {
+          "packet_type": 1,
+          "opcode": 4660,
+          "payload_length": 8,
+          "sub_opcode": [1, 2, 3],
+          "data": [4, 5, 6, 7, 8]
+      },
+      {
+          "packet_type": 1,
+          "opcode": 4660,
+          "payload_length": 5,
+          "sub_opcode": [10, 11],
+          "data": [12, 13, 14]
+      }
+  ]
+})";
+
+// Content with invalid filed `payload_lengths`.
+constexpr std::string_view kEmptyContent = R"({
+  "commands": [
+
+  ]
+})";
+
+class CsConfigLoaderTest : public Test {
+ protected:
+  void SetUp() override {
+    MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper_);
+  }
+
+  MockAndroidBaseWrapper mock_android_base_wrapper_;
+};
+
+TEST_F(CsConfigLoaderTest, ParseValidContentAndGetCsCalibrationCommands) {
+  EXPECT_TRUE(CsConfigLoader::GetLoader().LoadConfigFromString(kValidContent));
+
+  const std::vector<HalPacket>& commands =
+      CsConfigLoader::GetLoader().GetCsCalibrationCommands();
+
+  EXPECT_EQ(commands.size(), 2);
+
+  EXPECT_EQ(commands[0],
+            std::vector<uint8_t>({0x01, 0x34, 0x12, 0x08, 0x01, 0x02, 0x03,
+                                  0x04, 0x05, 0x06, 0x07, 0x08}));
+
+  EXPECT_EQ(commands[1], std::vector<uint8_t>({0x01, 0x34, 0x12, 0x05, 0x0A,
+                                               0x0B, 0x0C, 0x0D, 0x0E}));
+}
+
+TEST_F(CsConfigLoaderTest, ParseEmptyContent) {
+  EXPECT_TRUE(CsConfigLoader::GetLoader().LoadConfigFromString(kEmptyContent));
+
+  const std::vector<HalPacket>& commands =
+      CsConfigLoader::GetLoader().GetCsCalibrationCommands();
+
+  EXPECT_TRUE(commands.empty());
+}
+
+}  // namespace
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/firmware_config_loader.cc b/bluetooth/bluetooth_hal/config/firmware_config_loader.cc
new file mode 100644
index 0000000000..d491160650
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/firmware_config_loader.cc
@@ -0,0 +1,477 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.fw_config"
+
+#include "bluetooth_hal/config/firmware_config_loader.h"
+
+#include <asm-generic/fcntl.h>
+#include <unistd.h>
+
+#include <cstdint>
+#include <fstream>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <optional>
+#include <span>
+#include <sstream>
+#include <string>
+#include <string_view>
+#include <unordered_map>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+#include "firmware_config.pb.h"
+#include "google/protobuf/util/json_util.h"
+
+namespace bluetooth_hal {
+namespace config {
+namespace {
+
+using ::bluetooth_hal::config::proto::FirmwareConfig;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+using ::google::protobuf::RepeatedField;
+using ::google::protobuf::util::JsonParseOptions;
+using ::google::protobuf::util::JsonStringToMessage;
+using ::google::protobuf::util::Status;
+
+constexpr std::string_view kFirmwareConfigFile =
+    "/vendor/etc/bluetooth/firmware_config.json";
+
+constexpr int kDefaultLoadMiniDrvDelayMs = 50;
+constexpr int kDefaultLaunchRamDelayMs = 250;
+
+// Used for downloading firmware data.
+constexpr uint16_t kHciVscLaunchRamOpcode = 0xfc4e;
+constexpr int kBufferSize = 32 * 1024;
+
+enum class DataLoadingType : int {
+  kByPacket = 0,
+  kByAccumulation,
+};
+
+constexpr uint16_t GetOpcode(std::span<const uint8_t> packet) {
+  if (packet.size() < 2) {
+    // Invalid packet.
+    return 0;
+  }
+  return (packet[1] << 8) | packet[0];
+}
+
+std::string SetupCommandTypeToString(SetupCommandType type) {
+  switch (type) {
+    case SetupCommandType::kReset:
+      return "Reset";
+    case SetupCommandType::kReadChipId:
+      return "ReadChipId";
+    case SetupCommandType::kUpdateChipBaudRate:
+      return "UpdateChipBaudRate";
+    case SetupCommandType::kSetFastDownload:
+      return "SetFastDownload";
+    case SetupCommandType::kDownloadMinidrv:
+      return "DownloadMinidrv";
+    case SetupCommandType::kLaunchRam:
+      return "LaunchRam";
+    case SetupCommandType::kReadFwVersion:
+      return "ReadFwVersion";
+    case SetupCommandType::kSetupLowPowerMode:
+      return "SetupLowPowerMode";
+    case SetupCommandType::kWriteBdAddress:
+      return "WriteBdAddress";
+    default:
+      return "Unknown";
+  }
+}
+}  // namespace
+
+class FirmwareConfigLoaderImpl : public FirmwareConfigLoader {
+ public:
+  FirmwareConfigLoaderImpl();
+  ~FirmwareConfigLoaderImpl() override = default;
+
+  bool LoadConfig() override;
+  bool LoadConfigFromFile(std::string_view path) override;
+  bool LoadConfigFromString(std::string_view content) override;
+
+  bool ResetFirmwareDataLoadingState() override;
+
+  std::optional<DataPacket> GetNextFirmwareData() override;
+
+  std::optional<std::reference_wrapper<const SetupCommandPacket>>
+  GetSetupCommandPacket(SetupCommandType command_type) const override;
+
+  int GetLoadMiniDrvDelayMs() const override;
+
+  int GetLaunchRamDelayMs() const override;
+
+  std::string DumpConfigToString() const override;
+
+ private:
+  void LoadSetupCommandsFromConfig(const FirmwareConfig& config);
+
+  std::optional<DataPacket> GetNextFirmwareDataByPacket();
+  std::optional<DataPacket> GetNextFirmwareDataByAccumulation();
+
+  std::unordered_map<SetupCommandType, std::unique_ptr<SetupCommandPacket>>
+      setup_commands_;
+
+  std::string firmware_folder_;
+  std::string firmware_file_;
+  int chip_id_;
+  int load_mini_drv_delay_ms_{kDefaultLoadMiniDrvDelayMs};
+  int launch_ram_delay_ms_{kDefaultLaunchRamDelayMs};
+  DataLoadingType data_loading_type_{DataLoadingType::kByPacket};
+
+  std::mutex firmware_data_mutex_;
+
+  std::optional<std::vector<uint8_t>> previous_header_;
+  int firmware_file_fd_{-1};
+};
+
+bool FirmwareConfigLoaderImpl::ResetFirmwareDataLoadingState() {
+  const std::string firmware_path = firmware_folder_ + firmware_file_;
+  firmware_file_fd_ =
+      SystemCallWrapper::GetWrapper().Open(firmware_path.c_str(), O_RDONLY);
+  if (firmware_file_fd_ < 0) {
+    LOG(ERROR) << __func__ << ": Cannot open firmware file: " << firmware_path
+               << ".";
+    return false;
+  }
+
+  return true;
+}
+
+std::optional<DataPacket> FirmwareConfigLoaderImpl::GetNextFirmwareData() {
+  if (firmware_file_fd_ == -1) {
+    return std::nullopt;
+  }
+
+  {
+    std::scoped_lock lock(firmware_data_mutex_);
+    switch (data_loading_type_) {
+      case DataLoadingType::kByAccumulation:
+        return GetNextFirmwareDataByAccumulation();
+      case DataLoadingType::kByPacket:
+      default:
+        return GetNextFirmwareDataByPacket();
+        break;
+    }
+  }
+}
+
+std::optional<std::reference_wrapper<const SetupCommandPacket>>
+FirmwareConfigLoaderImpl::GetSetupCommandPacket(
+    SetupCommandType command_type) const {
+  const auto iter = setup_commands_.find(command_type);
+  if (iter == setup_commands_.end()) {
+    return std::nullopt;
+  }
+  return std::cref(*iter->second);
+}
+
+int FirmwareConfigLoaderImpl::GetLoadMiniDrvDelayMs() const {
+  return load_mini_drv_delay_ms_;
+}
+
+int FirmwareConfigLoaderImpl::GetLaunchRamDelayMs() const {
+  return launch_ram_delay_ms_;
+}
+
+std::string FirmwareConfigLoaderImpl::DumpConfigToString() const {
+  std::stringstream ss;
+  ss << "--- FirmwareConfigLoaderImpl State ---\n";
+  ss << "Firmware Folder: \"" << firmware_folder_ << "\"\n";
+  ss << "Firmware File: \"" << firmware_file_ << "\"\n";
+  ss << "Chip ID: " << chip_id_ << "\n";
+  ss << "Load MiniDrv Delay (ms): " << GetLoadMiniDrvDelayMs() << "\n";
+  ss << "Launch RAM Delay (ms): " << GetLaunchRamDelayMs() << "\n";
+  ss << "Data Loading Type: " << static_cast<int>(data_loading_type_)
+     << (data_loading_type_ == DataLoadingType::kByAccumulation
+             ? " (Accumulation)"
+             : " (By Packet)")
+     << "\n";
+
+  ss << "Setup Commands Loaded:\n";
+  if (setup_commands_.empty()) {
+    ss << "  (None)\n";
+  } else {
+    for (const auto& [type, packet_ptr] : setup_commands_) {
+      ss << "  - " << SetupCommandTypeToString(type) << ": "
+         << (packet_ptr ? "Present" : "Absent") << "\n";
+    }
+  }
+  ss << "-------------------------------------\n";
+  return ss.str();
+}
+FirmwareConfigLoaderImpl::FirmwareConfigLoaderImpl() {
+#ifndef UNIT_TEST
+  LoadConfig();
+#endif
+}
+
+bool FirmwareConfigLoaderImpl::LoadConfig() {
+  return LoadConfigFromFile(kFirmwareConfigFile);
+}
+
+bool FirmwareConfigLoaderImpl::LoadConfigFromFile(std::string_view path) {
+  std::ifstream json_file(path.data());
+  if (!json_file.is_open()) {
+    LOG(ERROR) << __func__ << ": Failed to open json file " << path.data();
+    return false;
+  }
+
+  std::string json_str((std::istreambuf_iterator<char>(json_file)),
+                       std::istreambuf_iterator<char>());
+
+  return LoadConfigFromString(json_str);
+}
+
+bool FirmwareConfigLoaderImpl::LoadConfigFromString(std::string_view content) {
+  FirmwareConfig config;
+  JsonParseOptions options;
+  options.ignore_unknown_fields = true;
+
+  Status status = JsonStringToMessage(content, &config, options);
+  if (!status.ok()) {
+    LOG(ERROR) << __func__
+               << ": Failed to parse json file, error: " << status.message();
+    return false;
+  }
+
+  if (config.has_firmware_folder_name()) {
+    firmware_folder_ = config.firmware_folder_name();
+  }
+
+  if (config.has_firmware_file_name()) {
+    firmware_file_ = config.firmware_file_name();
+  }
+
+  if (config.has_chip_id()) {
+    chip_id_ = config.chip_id();
+  }
+
+  if (config.has_load_mini_drv_delay_ms()) {
+    load_mini_drv_delay_ms_ = config.load_mini_drv_delay_ms();
+  }
+
+  if (config.has_launch_ram_delay_ms()) {
+    launch_ram_delay_ms_ = config.launch_ram_delay_ms();
+  }
+
+  if (config.has_firmware_data_loading_type()) {
+    data_loading_type_ =
+        static_cast<DataLoadingType>(config.firmware_data_loading_type());
+  }
+
+  LoadSetupCommandsFromConfig(config);
+
+  LOG(INFO) << DumpConfigToString();
+
+  return true;
+}
+
+void FirmwareConfigLoaderImpl::LoadSetupCommandsFromConfig(
+    const FirmwareConfig& config) {
+  if (!config.has_setup_commands()) {
+    return;
+  }
+
+  const auto& commands = config.setup_commands();
+
+  auto to_vector = [](const RepeatedField<uint32_t>& field) {
+    return std::vector<uint8_t>(field.begin(), field.end());
+  };
+
+  auto add = [&](SetupCommandType type, const RepeatedField<uint32_t>& data) {
+    setup_commands_.emplace(
+        type, std::make_unique<SetupCommandPacket>(type, to_vector(data)));
+  };
+
+  if (commands.hci_reset_size()) {
+    add(SetupCommandType::kReset, commands.hci_reset());
+  }
+  if (commands.hci_read_chip_id_size()) {
+    add(SetupCommandType::kReadChipId, commands.hci_read_chip_id());
+  }
+  if (commands.hci_update_chip_baud_rate_size()) {
+    add(SetupCommandType::kUpdateChipBaudRate,
+        commands.hci_update_chip_baud_rate());
+  }
+  if (commands.hci_set_fast_download_size()) {
+    add(SetupCommandType::kSetFastDownload, commands.hci_set_fast_download());
+  }
+  if (commands.hci_download_minidrv_size()) {
+    add(SetupCommandType::kDownloadMinidrv, commands.hci_download_minidrv());
+  }
+  if (commands.hci_vsc_launch_ram_size()) {
+    add(SetupCommandType::kLaunchRam, commands.hci_vsc_launch_ram());
+  }
+  if (commands.hci_read_fw_version_size()) {
+    add(SetupCommandType::kReadFwVersion, commands.hci_read_fw_version());
+  }
+  if (commands.hci_setup_low_power_mode_size()) {
+    add(SetupCommandType::kSetupLowPowerMode,
+        commands.hci_setup_low_power_mode());
+  }
+  if (commands.hci_write_bd_address_size()) {
+    add(SetupCommandType::kWriteBdAddress, commands.hci_write_bd_address());
+  }
+}
+
+std::optional<DataPacket>
+FirmwareConfigLoaderImpl::GetNextFirmwareDataByPacket() {
+  if (firmware_file_fd_ == -1) {
+    return std::nullopt;
+  }
+
+  // Read packet header (opcode and length).
+  std::vector<uint8_t> header(3);
+  ssize_t bytes_read = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Read(
+      firmware_file_fd_, header.data(), header.size()));
+  if (bytes_read <= 0) {
+    // End of stream or error.
+    firmware_file_fd_ = -1;
+    return std::nullopt;
+  }
+
+  // Read remaining packet data.
+  const size_t payload_size = header[2];
+  std::vector<uint8_t> packet(1 + header.size() + payload_size);
+  packet[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  std::copy(header.begin(), header.end(), packet.begin() + 1);
+
+  bytes_read = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Read(
+      firmware_file_fd_, packet.data() + 1 + header.size(), payload_size));
+  if (bytes_read != static_cast<ssize_t>(payload_size)) {
+    // Incomplete packet or error.
+    firmware_file_fd_ = -1;
+    return std::nullopt;
+  }
+
+  // Check for target opcode after reading the whole packet.
+  if (GetOpcode(std::span(header)) == kHciVscLaunchRamOpcode) {
+    LOG(INFO) << __func__ << " Firmware data download is completed.";
+    firmware_file_fd_ = -1;
+    return DataPacket(DataType::kDataEnd, packet);
+  }
+
+  return DataPacket(DataType::kDataFragment, packet);
+}
+
+std::optional<DataPacket>
+FirmwareConfigLoaderImpl::GetNextFirmwareDataByAccumulation() {
+  if (firmware_file_fd_ == -1) {
+    return std::nullopt;
+  }
+
+  std::vector<uint8_t> buffer;
+  buffer.reserve(kBufferSize);
+
+  bool is_end = false;
+
+  while (true) {
+    std::vector<uint8_t> header;
+
+    if (previous_header_.has_value()) {
+      header = std::move(previous_header_.value());
+      previous_header_.reset();
+    } else {
+      // Read packet header (opcode and length).
+      header.resize(3);
+      ssize_t bytes_read =
+          TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Read(
+              firmware_file_fd_, header.data(), header.size()));
+      if (bytes_read <= 0) {
+        // End of stream or error.
+        firmware_file_fd_ = -1;
+        break;
+      }
+    }
+
+    // Calculate total packet size.
+    const size_t payload_size = header[2];
+    const size_t packet_size = 1 + header.size() + payload_size;
+
+    // Check if the current packet fits in the buffer.
+    if (buffer.size() + packet_size > kBufferSize) {
+      previous_header_ = std::move(header);
+      return DataPacket(DataType::kDataFragment, std::move(buffer));
+    }
+
+    if (GetOpcode(header) == kHciVscLaunchRamOpcode && !buffer.empty()) {
+      previous_header_ = std::move(header);
+      return DataPacket(DataType::kDataFragment, std::move(buffer));
+    }
+
+    // Read remaining packet data and append to buffer.
+    buffer.push_back(static_cast<uint8_t>(HciPacketType::kCommand));
+    buffer.insert(buffer.end(), header.begin(), header.end());
+
+    std::vector<uint8_t> payload(payload_size);
+    ssize_t bytes_read =
+        TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Read(
+            firmware_file_fd_, payload.data(), payload_size));
+    if (bytes_read != static_cast<ssize_t>(payload_size)) {
+      // Incomplete packet or error.
+      firmware_file_fd_ = -1;
+      break;
+    }
+    buffer.insert(buffer.end(), payload.begin(), payload.end());
+
+    // Check for target opcode after reading the whole packet.
+    if (GetOpcode(header) == kHciVscLaunchRamOpcode) {
+      LOG(INFO) << __func__ << " Firmware data download is completed.";
+      firmware_file_fd_ = -1;
+      is_end = true;
+      break;
+    }
+  }
+
+  // Return accumulated data.
+  if (!buffer.empty()) {
+    return DataPacket(is_end ? DataType::kDataEnd : DataType::kDataFragment,
+                      std::move(buffer));
+  }
+
+  return std::nullopt;
+}
+
+std::mutex FirmwareConfigLoader::loader_mutex_;
+FirmwareConfigLoader* FirmwareConfigLoader::loader_ = nullptr;
+
+FirmwareConfigLoader& FirmwareConfigLoader::GetLoader() {
+  std::lock_guard<std::mutex> lock(loader_mutex_);
+  if (loader_ == nullptr) {
+    loader_ = new FirmwareConfigLoaderImpl();
+  }
+  return *loader_;
+}
+
+void FirmwareConfigLoader::ResetLoader() {
+  std::lock_guard<std::mutex> lock(loader_mutex_);
+  if (loader_ != nullptr) {
+    delete loader_;
+    loader_ = nullptr;
+  }
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/firmware_config_loader_test.cc b/bluetooth/bluetooth_hal/config/firmware_config_loader_test.cc
new file mode 100644
index 0000000000..e405f5e42e
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/firmware_config_loader_test.cc
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/config/firmware_config_loader.h"
+
+#include <cstddef>
+#include <string_view>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+#include "bluetooth_hal/test/mock/mock_system_call_wrapper.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace config {
+namespace {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Invoke;
+using ::testing::Return;
+using ::testing::Test;
+using ::testing::Values;
+using ::testing::WithParamInterface;
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::util::MockAndroidBaseWrapper;
+using ::bluetooth_hal::util::MockSystemCallWrapper;
+
+constexpr int kDefaultLoadMiniDrvDelayMs = 50;
+constexpr int kDefaultLaunchRamDelayMs = 250;
+
+constexpr int kLoadMiniDrvDelayMs = 100;
+constexpr int kLaunchRamDelayMs = 100;
+
+const std::string kValidContent = R"({
+  "firmware_folder_name": "/PATH/TO/FOLDER/",
+  "firmware_file_name": "FILENAME",
+  "chip_id": 123,
+  "load_mini_drv_delay_ms": 100,
+  "launch_ram_delay_ms": 100,
+  "firmware_data_loading_type": "PACKET_BY_PACKET",
+  "setup_commands": {
+    "hci_reset": [1, 3, 12, 0],
+    "hci_read_chip_id": [1, 121, 252, 0],
+    "hci_update_chip_baud_rate": [1, 24, 252, 6, 0, 0, 0, 9, 61, 0],
+    "hci_set_fast_download": [1, 114, 254, 2, 0, 1],
+    "hci_download_minidrv": [1, 46, 252, 0],
+    "hci_vsc_launch_ram": [1, 78, 252, 4, 255, 255, 255, 255],
+    "hci_read_fw_version": [1, 20, 12, 0],
+    "hci_setup_low_power_mode": [1, 39, 252, 12, 1, 24, 24, 1, 1, 1, 1, 0, 0, 0, 0, 0],
+    "hci_write_bd_address": [1, 1, 252, 6, 30, 77, 19, 43, 213, 232]
+  }
+})";
+
+TEST(FirmwareConfigLoaderTest, IsSameSingleton) {
+  MockSystemCallWrapper mock_system_call_wrapper;
+  MockSystemCallWrapper::SetMockWrapper(&mock_system_call_wrapper);
+
+  MockAndroidBaseWrapper mock_android_base_wrapper;
+  MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper);
+
+  EXPECT_EQ(&FirmwareConfigLoader::GetLoader(),
+            &FirmwareConfigLoader::GetLoader());
+}
+
+class FirmwareConfigLoaderTestBase : public Test {
+ protected:
+  void SetUp() override {
+    MockSystemCallWrapper::SetMockWrapper(&mock_system_call_wrapper_);
+    MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper_);
+
+    FirmwareConfigLoader::ResetLoader();
+  }
+
+  void TearDown() override {}
+
+  MockSystemCallWrapper mock_system_call_wrapper_;
+  MockAndroidBaseWrapper mock_android_base_wrapper_;
+};
+
+TEST_F(FirmwareConfigLoaderTestBase, GetNextFirmwareDataOnInit) {
+  EXPECT_FALSE(
+      FirmwareConfigLoader::GetLoader().GetNextFirmwareData().has_value());
+}
+
+TEST_F(FirmwareConfigLoaderTestBase, GetLoadMiniDrvDelayMsOnInit) {
+  EXPECT_EQ(FirmwareConfigLoader::GetLoader().GetLoadMiniDrvDelayMs(),
+            kDefaultLoadMiniDrvDelayMs);
+}
+
+TEST_F(FirmwareConfigLoaderTestBase, GetLaunchRamDelayMsOnInit) {
+  EXPECT_EQ(FirmwareConfigLoader::GetLoader().GetLaunchRamDelayMs(),
+            kDefaultLaunchRamDelayMs);
+}
+
+struct SetupCommandValueTestParam {
+  SetupCommandType command_type;
+  std::vector<uint8_t> expected_command;
+};
+
+class LoadConfigSetupCommandTypeTest
+    : public FirmwareConfigLoaderTestBase,
+      public WithParamInterface<SetupCommandValueTestParam> {
+ protected:
+  void SetUp() override {
+    FirmwareConfigLoaderTestBase::SetUp();
+    EXPECT_TRUE(
+        FirmwareConfigLoader::GetLoader().LoadConfigFromString(kValidContent));
+  }
+};
+
+TEST_P(LoadConfigSetupCommandTypeTest, ParsesSetupCommand) {
+  const auto& [command_type, expected_command] = GetParam();
+  const auto command_packet =
+      FirmwareConfigLoader::GetLoader().GetSetupCommandPacket(command_type);
+
+  EXPECT_EQ(command_packet.has_value(), !expected_command.empty());
+  if (!expected_command.empty()) {
+    EXPECT_EQ(command_packet.value().get().GetPayload(), expected_command);
+  }
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    TestAllSetupCommandTypeConfig, LoadConfigSetupCommandTypeTest,
+    Values(SetupCommandValueTestParam{.command_type = SetupCommandType::kReset,
+                                      .expected_command = {0x01, 0x03, 0x0c,
+                                                           0x00}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kReadChipId,
+               .expected_command = {0x01, 0x79, 0xfc, 0x00}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kUpdateChipBaudRate,
+               .expected_command = {0x01, 0x18, 0xfc, 0x06, 0x00, 0x00, 0x00,
+                                    0x09, 0x3d, 0x00}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kSetFastDownload,
+               .expected_command = {0x01, 0x72, 0xfe, 0x02, 0x00, 0x01}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kDownloadMinidrv,
+               .expected_command = {0x01, 0x2e, 0xfc, 0x00}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kLaunchRam,
+               .expected_command = {0x01, 0x4e, 0xfc, 0x04, 0xff, 0xff, 0xff,
+                                    0xff}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kReadFwVersion,
+               .expected_command = {0x01, 0x14, 0x0c, 0x00}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kSetupLowPowerMode,
+               .expected_command = {0x01, 0x27, 0xfc, 0x0c, 0x01, 0x18, 0x18,
+                                    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
+                                    0x00, 0x00}},
+           SetupCommandValueTestParam{
+               .command_type = SetupCommandType::kWriteBdAddress,
+               .expected_command = {0x01, 0x01, 0xfc, 0x06, 0x1e, 0x4d, 0x13,
+                                    0x2b, 0xd5, 0xe8}}));
+
+TEST(FirmwarePacketTest, HandleDifferentFirmwarePacketType) {
+  std::vector<uint8_t> payload = {0x01};
+
+  for (int i = 0; i <= static_cast<int>(FirmwarePacketType::kData); ++i) {
+    FirmwarePacketType packet_type = static_cast<FirmwarePacketType>(i);
+    FirmwarePacket packet(packet_type, payload);
+    EXPECT_EQ(packet.GetPacketType(), packet_type);
+  }
+}
+
+TEST(FirmwarePacketTest, HandlePayload) {
+  std::vector<uint8_t> payload = {0x01, 0x02, 0x03};
+  FirmwarePacket packet(FirmwarePacketType::kData, payload);
+  EXPECT_EQ(packet.GetPayload(), payload);
+}
+
+TEST(FirmwarePacketTest, HandleEmptyPayload) {
+  FirmwarePacket packet(FirmwarePacketType::kData, {});
+  EXPECT_TRUE(packet.GetPayload().empty());
+}
+
+TEST(SetupCommandPacketTest, HandleDifferentSetupCommandPacketTypes) {
+  std::vector<uint8_t> payload = {0x01};
+
+  for (int i = 0; i <= static_cast<int>(SetupCommandType::kWriteBdAddress);
+       ++i) {
+    SetupCommandType command_type = static_cast<SetupCommandType>(i);
+    SetupCommandPacket packet(command_type, payload);
+    EXPECT_EQ(packet.GetCommandType(), command_type);
+  }
+}
+
+TEST(DataPacketTest, HandleDifferentDataPacketTypes) {
+  std::vector<uint8_t> payload = {0x01};
+
+  for (int i = 0; i <= static_cast<int>(DataType::kDataEnd); ++i) {
+    DataType data_type = static_cast<DataType>(i);
+    DataPacket packet(data_type, payload);
+    EXPECT_EQ(packet.GetDataType(), data_type);
+  }
+}
+
+}  // namespace
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/hal_config_loader.cc b/bluetooth/bluetooth_hal/config/hal_config_loader.cc
new file mode 100644
index 0000000000..bfcf9591c6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/hal_config_loader.cc
@@ -0,0 +1,528 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.hal_config"
+
+#include "bluetooth_hal/config/hal_config_loader.h"
+
+#include <fstream>
+#include <iterator>
+#include <mutex>
+#include <sstream>
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/config/config_constants.h"
+#include "bluetooth_hal/config/config_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/android_base_wrapper.h"
+#include "google/protobuf/util/json_util.h"
+#include "hal_config.pb.h"
+
+namespace bluetooth_hal {
+namespace config {
+namespace {
+
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::config::proto::HalConfig;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::transport::TransportType;
+using ::bluetooth_hal::uart::BaudRate;
+using ::bluetooth_hal::util::AndroidBaseWrapper;
+
+using ::google::protobuf::util::JsonParseOptions;
+using ::google::protobuf::util::JsonStringToMessage;
+using ::google::protobuf::util::Status;
+
+namespace cfg_consts = ::bluetooth_hal::config::constants;
+
+std::string TransportTypeToString(TransportType type) {
+  return std::to_string(static_cast<int>(type));
+}
+
+template <typename T>
+std::string VectorToString(const std::vector<T>& vec) {
+  std::stringstream ss;
+  ss << "[";
+  for (size_t i = 0; i < vec.size(); ++i) {
+    if constexpr (std::is_same_v<T, TransportType>) {
+      ss << TransportTypeToString(vec[i]);
+    } else {
+      ss << vec[i];
+    }
+    if (i < vec.size() - 1) {
+      ss << ", ";
+    }
+  }
+  ss << "]";
+  return ss.str();
+}
+
+}  // namespace
+
+class HalConfigLoaderImpl : public HalConfigLoader {
+ public:
+  HalConfigLoaderImpl();
+  ~HalConfigLoaderImpl() override = default;
+
+  bool LoadConfig() override;
+  bool LoadConfigFromFile(std::string_view path) override;
+  bool LoadConfigFromString(std::string_view content) override;
+
+  bool IsFastDownloadEnabled() const override;
+  bool IsSarBackoffHighResolutionEnabled() const override;
+  int GetBtRegOnDelayMs() const override;
+  const std::string& GetBtUartDevicePort() const override;
+  const std::vector<TransportType>& GetTransportTypePriority() const override;
+  bool IsAcceleratedBtOnSupported() const override;
+  bool IsThreadDispatcherEnabled() const override;
+  bool IsBtPowerControlledByLpp() const override;
+  const std::vector<std::string>& GetHwStagesWithoutLppControlBtPowerPin()
+      const override;
+  const std::vector<std::string>& GetFwUnsupportedHwStages() const override;
+  int GetVendorTransportCrashIntervalSec() const override;
+  bool IsHpUartSkipSuspendSupported() const override;
+  bool IsEnergyControllerLoggingSupported() const override;
+  bool IsBtHalRestartRecoverySupported() const override;
+  bool IsBleNonConnectionSarEnabled() const override;
+  int GetKernelRxWakelockTimeMilliseconds() const override;
+  bool IsLowPowerModeSupported() const override;
+  bool IsTranportFallbackEnabled() const override;
+  bool IsBtSnoopLogFullModeOn() const override;
+  BaudRate GetUartBaudRate(TransportType type) const override;
+  bool IsUserDebugOrEngBuild() const override;
+  const std::string& GetLpmEnableProcNode() const override;
+  const std::string& GetLpmWakingProcNode() const override;
+  const std::string& GetLpmWakelockCtrlProcNode() const override;
+  const std::string& GetRfkillFolderPrefix() const override;
+  const std::string& GetRfkillTypeBluetooth() const override;
+
+  std::string DumpConfigToString() const override;
+
+ private:
+  void UpdateBqrEventMask(const std::string& mask);
+  void UpdateTransportFallbackType(int type);
+  void UpdateLdacQualityMode(const std::string& mode);
+
+  int reg_on_delay_ms_{cfg_consts::kDefaultBtRegOnDelay};
+  int vendor_transport_crash_interval_sec_{
+      cfg_consts::kDefaultVendorTransportCrashIntervalSec};
+  std::string uart_device_port_{cfg_consts::kDefaultBtUartDevicePort};
+  std::vector<TransportType> transport_priority_list_{
+      cfg_consts::kDefaultBtTransportType};
+  std::vector<std::string> hw_stages_without_lpp_control_bt_power_pin_;
+  std::vector<std::string> fw_unsupported_hw_stages_;
+  TransportType transport_fallback_type_{cfg_consts::kDefaultBtTransportType};
+  bool is_fast_download_enabled_{false};
+  bool is_sar_backoff_high_resolution_enabled_{false};
+  bool is_accel_bt_on_enabled_{false};
+  bool is_thread_dispatcher_enabled_{false};
+  bool is_bt_power_controlled_by_lpp_{false};
+  bool is_debug_image_build_{IsUserDebugOrEngBuild()};
+  bool is_hp_uart_skip_suspend_enabled_{false};
+  bool is_energy_controller_logging_enabled_{false};
+  bool is_self_restart_recovery_enabled_{false};
+  bool is_ble_non_connection_sar_enabled_{false};
+  int kernel_rx_wake_lock_time_ms_{0};
+  bool is_low_power_mode_enabled_{false};
+  std::string lpm_enable_proc_node_{cfg_consts::kLpmEnableProcNode};
+  std::string lpm_waking_proc_node_{cfg_consts::kLpmWakingProcNode};
+  std::string lpm_wakelock_ctrl_proc_node_{
+      cfg_consts::kLpmWakelockCtrlProcNode};
+  std::string rfkill_folder_prefix_{cfg_consts::kRfkillFolderPrefix};
+  std::string rfkill_type_bluetooth_{cfg_consts::kRfkillTypeBluetooth};
+};
+
+bool HalConfigLoaderImpl::IsFastDownloadEnabled() const {
+  return is_fast_download_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsSarBackoffHighResolutionEnabled() const {
+  return is_sar_backoff_high_resolution_enabled_;
+}
+
+int HalConfigLoaderImpl::GetBtRegOnDelayMs() const { return reg_on_delay_ms_; }
+
+const std::string& HalConfigLoaderImpl::GetBtUartDevicePort() const {
+  return uart_device_port_;
+}
+
+const std::vector<TransportType>&
+HalConfigLoaderImpl::GetTransportTypePriority() const {
+  if (IsTranportFallbackEnabled() &&
+      transport_fallback_type_ != TransportType::kUnknown) {
+    static const std::vector<TransportType> fallback_types{
+        transport_fallback_type_};
+    return fallback_types;
+  }
+  return transport_priority_list_;
+}
+
+bool HalConfigLoaderImpl::IsAcceleratedBtOnSupported() const {
+  return is_accel_bt_on_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsThreadDispatcherEnabled() const {
+  return is_thread_dispatcher_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsBtPowerControlledByLpp() const {
+  return is_bt_power_controlled_by_lpp_;
+}
+
+const std::vector<std::string>&
+HalConfigLoaderImpl::GetHwStagesWithoutLppControlBtPowerPin() const {
+  return hw_stages_without_lpp_control_bt_power_pin_;
+}
+
+const std::vector<std::string>& HalConfigLoaderImpl::GetFwUnsupportedHwStages()
+    const {
+  return fw_unsupported_hw_stages_;
+}
+
+int HalConfigLoaderImpl::GetVendorTransportCrashIntervalSec() const {
+  return vendor_transport_crash_interval_sec_;
+}
+
+bool HalConfigLoaderImpl::IsHpUartSkipSuspendSupported() const {
+  return is_hp_uart_skip_suspend_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsEnergyControllerLoggingSupported() const {
+  return is_energy_controller_logging_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsBtHalRestartRecoverySupported() const {
+  return is_self_restart_recovery_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsBleNonConnectionSarEnabled() const {
+  return is_ble_non_connection_sar_enabled_;
+}
+
+int HalConfigLoaderImpl::GetKernelRxWakelockTimeMilliseconds() const {
+  return kernel_rx_wake_lock_time_ms_;
+}
+
+bool HalConfigLoaderImpl::IsLowPowerModeSupported() const {
+  return is_low_power_mode_enabled_;
+}
+
+bool HalConfigLoaderImpl::IsUserDebugOrEngBuild() const {
+  const std::string build_type =
+      AndroidBaseWrapper::GetWrapper().GetProperty(Property::kBuildType, "");
+  return build_type == "userdebug" || build_type == "eng";
+}
+
+bool HalConfigLoaderImpl::IsTranportFallbackEnabled() const {
+  return AndroidBaseWrapper::GetWrapper().GetBoolProperty(
+      Property::kTransportFallbackEnabled, false);
+}
+
+BaudRate HalConfigLoaderImpl::GetUartBaudRate(
+    [[maybe_unused]] TransportType type) const {
+  // TODO: b/421025035 - Put the value into the json file.
+  return BaudRate::kRate4000000;
+}
+
+bool HalConfigLoaderImpl::IsBtSnoopLogFullModeOn() const {
+  const std::string bt_snoop_full_mode("full");
+
+  const std::string bt_snoop_log_mode =
+      AndroidBaseWrapper::GetWrapper().GetProperty(Property::kBtSnoopLogMode,
+                                                   "disabled");
+
+  return bt_snoop_log_mode == bt_snoop_full_mode;
+}
+
+const std::string& HalConfigLoaderImpl::GetLpmEnableProcNode() const {
+  return lpm_enable_proc_node_;
+}
+
+const std::string& HalConfigLoaderImpl::GetLpmWakingProcNode() const {
+  return lpm_waking_proc_node_;
+}
+
+const std::string& HalConfigLoaderImpl::GetLpmWakelockCtrlProcNode() const {
+  return lpm_wakelock_ctrl_proc_node_;
+}
+
+const std::string& HalConfigLoaderImpl::GetRfkillFolderPrefix() const {
+  return rfkill_folder_prefix_;
+}
+
+const std::string& HalConfigLoaderImpl::GetRfkillTypeBluetooth() const {
+  return rfkill_type_bluetooth_;
+}
+
+void HalConfigLoaderImpl::UpdateBqrEventMask(const std::string& mask) {
+  const std::string current_bqr_event_mask =
+      AndroidBaseWrapper::GetWrapper().GetProperty(Property::kBqrEventMask,
+                                                   "false");
+
+  if ((mask != current_bqr_event_mask) && is_debug_image_build_) {
+    LOG(INFO) << __func__ << ": Set to default bqr.event_mask: " << mask << ".";
+    AndroidBaseWrapper::GetWrapper().SetProperty(Property::kBqrEventMask, mask);
+  }
+}
+
+void HalConfigLoaderImpl::UpdateTransportFallbackType(int type) {
+  const auto fallback_type = static_cast<TransportType>(type);
+  transport_fallback_type_ = (fallback_type >= TransportType::kUartH4 &&
+                              fallback_type < TransportType::kUnknown)
+                                 ? fallback_type
+                                 : TransportType::kUnknown;
+}
+
+void HalConfigLoaderImpl::UpdateLdacQualityMode(const std::string& mode) {
+  LOG(INFO) << __func__ << ": Set " << Property::kLdacDefaultQualityMode << ": "
+            << mode << ".";
+  AndroidBaseWrapper::GetWrapper().SetProperty(
+      Property::kLdacDefaultQualityMode, mode);
+}
+
+HalConfigLoaderImpl::HalConfigLoaderImpl() {
+#ifndef UNIT_TEST
+  LoadConfig();
+#endif
+}
+
+bool HalConfigLoaderImpl::LoadConfig() {
+  return LoadConfigFromFile(constants::kHalConfigFile);
+}
+
+bool HalConfigLoaderImpl::LoadConfigFromFile(std::string_view path) {
+  std::ifstream json_file(path.data());
+  if (!json_file.is_open()) {
+    LOG(ERROR) << __func__ << ": Failed to open json file " << path.data();
+    return false;
+  }
+
+  std::string json_str((std::istreambuf_iterator<char>(json_file)),
+                       std::istreambuf_iterator<char>());
+
+  return LoadConfigFromString(json_str);
+}
+
+bool HalConfigLoaderImpl::LoadConfigFromString(std::string_view content) {
+  HalConfig config;
+  JsonParseOptions options;
+  options.ignore_unknown_fields = true;
+
+  Status status = JsonStringToMessage(content, &config, options);
+  if (!status.ok()) {
+    LOG(ERROR) << __func__
+               << ": Failed to parse json file, error: " << status.message();
+    return false;
+  }
+
+  if (config.has_fast_download_enabled()) {
+    is_fast_download_enabled_ = config.fast_download_enabled();
+  }
+
+  if (config.has_sar_backoff_high_resolution_enabled()) {
+    is_sar_backoff_high_resolution_enabled_ =
+        config.sar_backoff_high_resolution_enabled();
+  }
+
+  if (config.has_reg_on_delay_ms()) {
+    reg_on_delay_ms_ = config.reg_on_delay_ms();
+  }
+
+  if (config.has_uart_device_port()) {
+    uart_device_port_ = config.uart_device_port();
+  }
+
+  if (config.transport_type_priority_size()) {
+    transport_priority_list_.clear();
+    for (const auto type : config.transport_type_priority()) {
+      transport_priority_list_.push_back(static_cast<TransportType>(type));
+    }
+  }
+
+  if (config.has_accelerated_bt_on_enabled()) {
+    is_accel_bt_on_enabled_ = config.accelerated_bt_on_enabled();
+  }
+
+  if (config.has_thread_dispatcher_enabled()) {
+    is_thread_dispatcher_enabled_ = config.thread_dispatcher_enabled();
+  }
+
+  if (config.has_bt_power_controlled_by_lpp()) {
+    is_bt_power_controlled_by_lpp_ = config.bt_power_controlled_by_lpp();
+  }
+
+  if (config.hw_stages_without_lpp_control_bt_power_pin_size()) {
+    hw_stages_without_lpp_control_bt_power_pin_.clear();
+    hw_stages_without_lpp_control_bt_power_pin_.assign(
+        config.hw_stages_without_lpp_control_bt_power_pin().begin(),
+        config.hw_stages_without_lpp_control_bt_power_pin().end());
+  }
+
+  if (config.fw_unsupported_hw_stages_size()) {
+    fw_unsupported_hw_stages_.clear();
+    fw_unsupported_hw_stages_.assign(config.fw_unsupported_hw_stages().begin(),
+                                     config.fw_unsupported_hw_stages().end());
+  }
+
+  if (config.has_vendor_transport_crash_interval_sec()) {
+    vendor_transport_crash_interval_sec_ =
+        config.vendor_transport_crash_interval_sec();
+  }
+
+  if (config.has_hp_uart_skip_suspend_enabled()) {
+    is_hp_uart_skip_suspend_enabled_ = config.hp_uart_skip_suspend_enabled();
+  }
+
+  if (config.has_energy_controller_logging_enabled()) {
+    is_energy_controller_logging_enabled_ =
+        config.energy_controller_logging_enabled();
+  }
+
+  if (config.has_self_restart_recovery_enabled()) {
+    is_self_restart_recovery_enabled_ = config.self_restart_recovery_enabled();
+  }
+
+  if (config.has_ble_non_connection_sar_enabled()) {
+    is_ble_non_connection_sar_enabled_ =
+        config.ble_non_connection_sar_enabled();
+  }
+
+  if (config.has_kernel_rx_wakelock_time_ms()) {
+    kernel_rx_wake_lock_time_ms_ = config.kernel_rx_wakelock_time_ms();
+  }
+
+  if (config.has_low_power_mode_enabled()) {
+    is_low_power_mode_enabled_ = config.low_power_mode_enabled();
+  }
+
+  if (config.has_bqr_event_mask()) {
+    UpdateBqrEventMask(config.bqr_event_mask());
+  }
+
+  if (config.has_ldac_quality_mode()) {
+    UpdateLdacQualityMode(config.ldac_quality_mode());
+  }
+
+  if (config.has_transport_fallback_type()) {
+    UpdateTransportFallbackType(config.transport_fallback_type());
+  }
+
+  if (config.has_lpm_enable_proc_node()) {
+    lpm_enable_proc_node_ = config.lpm_enable_proc_node();
+  }
+
+  if (config.has_lpm_waking_proc_node()) {
+    lpm_waking_proc_node_ = config.lpm_waking_proc_node();
+  }
+
+  if (config.has_lpm_wakelock_ctrl_proc_node()) {
+    lpm_wakelock_ctrl_proc_node_ = config.lpm_wakelock_ctrl_proc_node();
+  }
+
+  if (config.has_rfkill_folder_prefix()) {
+    rfkill_folder_prefix_ = config.rfkill_folder_prefix();
+  }
+
+  if (config.has_rfkill_type_bluetooth()) {
+    rfkill_type_bluetooth_ = config.rfkill_type_bluetooth();
+  }
+
+  LOG(INFO) << DumpConfigToString();
+
+  return true;
+}
+
+std::string HalConfigLoaderImpl::DumpConfigToString() const {
+  std::stringstream ss;
+  ss << std::boolalpha;
+
+  ss << "--- HalConfigLoader State ---\n";
+  ss << "IsFastDownloadEnabled: " << IsFastDownloadEnabled() << "\n";
+  ss << "IsSarBackoffHighResolutionEnabled: "
+     << IsSarBackoffHighResolutionEnabled() << "\n";
+  ss << "GetBtRegOnDelayMs: " << GetBtRegOnDelayMs() << "\n";
+  ss << "GetBtUartDevicePort: \"" << GetBtUartDevicePort() << "\"\n";
+  ss << "GetTransportTypePriority (Effective): "
+     << VectorToString(GetTransportTypePriority()) << "\n";
+  ss << "  (Configured List): " << VectorToString(transport_priority_list_)
+     << "\n";
+  ss << "  (Fallback Type): " << TransportTypeToString(transport_fallback_type_)
+     << "\n";
+  ss << "IsAcceleratedBtOnSupported: " << IsAcceleratedBtOnSupported() << "\n";
+  ss << "IsThreadDispatcherEnabled: " << IsThreadDispatcherEnabled() << "\n";
+  ss << "IsBtPowerControlledByLpp: " << IsBtPowerControlledByLpp() << "\n";
+  ss << "GetHwStagesWithoutLppControlBtPowerPin: "
+     << VectorToString(GetHwStagesWithoutLppControlBtPowerPin()) << "\n";
+  ss << "GetFwUnsupportedHwStages: "
+     << VectorToString(GetFwUnsupportedHwStages()) << "\n";
+  ss << "GetVendorTransportCrashIntervalSec: "
+     << GetVendorTransportCrashIntervalSec() << "\n";
+  ss << "IsHpUartSkipSuspendSupported: " << IsHpUartSkipSuspendSupported()
+     << "\n";
+  ss << "IsEnergyControllerLoggingSupported: "
+     << IsEnergyControllerLoggingSupported() << "\n";
+  ss << "IsBtHalRestartRecoverySupported: " << IsBtHalRestartRecoverySupported()
+     << "\n";
+  ss << "IsBleNonConnectionSarEnabled: " << IsBleNonConnectionSarEnabled()
+     << "\n";
+  ss << "GetKernelRxWakelockTimeMilliseconds: "
+     << GetKernelRxWakelockTimeMilliseconds() << "\n";
+  ss << "IsLowPowerModeSupported: " << IsLowPowerModeSupported() << "\n";
+  // Runtime checks.
+  ss << "--- Runtime Checks ---\n";
+  ss << "IsTranportFallbackEnabled (Property): " << IsTranportFallbackEnabled()
+     << "\n";
+  ss << "IsBtSnoopLogFullModeOn (Property): " << IsBtSnoopLogFullModeOn()
+     << "\n";
+  ss << "GetLpmEnableProcNode: \"" << GetLpmEnableProcNode() << "\"\n";
+  ss << "GetLpmWakingProcNode: \"" << GetLpmWakingProcNode() << "\"\n";
+  ss << "GetLpmWakelockCtrlProcNode: \"" << GetLpmWakelockCtrlProcNode()
+     << "\"\n";
+  ss << "GetRfkillFolderPrefix: \"" << GetRfkillFolderPrefix() << "\"\n";
+  ss << "GetRfkillTypeBluetooth: \"" << GetRfkillTypeBluetooth() << "\"\n";
+
+  // Runtime checks.
+  ss << "IsUserDebugOrEngBuild (Property): " << IsUserDebugOrEngBuild() << "\n";
+  ss << "---------------------------------\n";
+
+  return ss.str();
+}
+
+std::mutex HalConfigLoader::loader_mutex_;
+HalConfigLoader* HalConfigLoader::loader_ = nullptr;
+
+HalConfigLoader& HalConfigLoader::GetLoader() {
+  std::lock_guard<std::mutex> lock(loader_mutex_);
+  if (loader_ == nullptr) {
+    loader_ = new HalConfigLoaderImpl();
+  }
+  return *loader_;
+}
+
+void HalConfigLoader::ResetLoader() {
+  std::lock_guard<std::mutex> lock(loader_mutex_);
+  if (loader_ != nullptr) {
+    delete loader_;
+    loader_ = nullptr;
+  }
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/hal_config_loader_test.cc b/bluetooth/bluetooth_hal/config/hal_config_loader_test.cc
new file mode 100644
index 0000000000..2800f778f4
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/hal_config_loader_test.cc
@@ -0,0 +1,380 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/config/hal_config_loader.h"
+
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include "bluetooth_hal/config/config_constants.h"
+#include "bluetooth_hal/config/config_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+#include "bluetooth_hal/test/mock/mock_transport_interface.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace config {
+namespace {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Eq;
+using ::testing::Invoke;
+using ::testing::Mock;
+using ::testing::Return;
+using ::testing::Test;
+using ::testing::ValuesIn;
+using ::testing::WithParamInterface;
+
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::transport::MockTransportInterface;
+using ::bluetooth_hal::transport::TransportInterface;
+using ::bluetooth_hal::transport::TransportType;
+using ::bluetooth_hal::uart::BaudRate;
+using ::bluetooth_hal::util::MockAndroidBaseWrapper;
+
+namespace cfg_consts = ::bluetooth_hal::config::constants;
+
+constexpr std::string_view kTestUartDevicePort = "/dev/ttySAC18";
+constexpr int kTestVendorTransportCrashIntervalSec = 3000;
+constexpr int kTestBtRegOnDelayMs = 500;
+constexpr int kTestKernelRxWakelockTimeMs = 200;
+constexpr std::string_view kTestLpmEnableProcNode =
+    "/test/proc/bluetooth/sleep/lpm";
+constexpr std::string_view kTestLpmWakingProcNode =
+    "/test/proc/bluetooth/sleep/btwrite";
+constexpr std::string_view kTestLpmWakelockCtrlProcNode =
+    "/test/proc/bluetooth/sleep/wakelock_ctrl";
+constexpr std::string_view kTestRfkillFolderPrefix =
+    "/test/sys/class/rfkill/rfkill";
+constexpr std::string_view kTestRfkillTypeBluetooth = "testbluetooth";
+
+constexpr std::string_view kValidContent = R"({
+  "fast_download_enabled": true,
+  "sar_backoff_high_resolution_enabled": true,
+  "reg_on_delay_ms": 500,
+  "uart_device_port": "/dev/ttySAC18",
+  "transport_type_priority": [1],
+  "accelerated_bt_on_enabled": true,
+  "thread_dispatcher_enabled": true,
+  "bt_power_controlled_by_lpp": true,
+  "hw_stages_without_lpp_control_bt_power_pin": [
+    "stage1",
+    "stage2"
+  ],
+  "fw_unsupported_hw_stages": [
+    "stage1",
+    "stage2"
+  ],
+  "vendor_transport_crash_interval_sec": 3000,
+  "hp_uart_skip_suspend_enabled": true,
+  "energy_controller_logging_enabled": true,
+  "self_restart_recovery_enabled": true,
+  "ble_non_connection_sar_enabled": true,
+  "kernel_rx_wakelock_time_ms": 200,
+  "low_power_mode_enabled": true,
+  "bqr_event_mask": "456",
+  "ldac_quality_mode": "mode1",
+  "transport_fallback_type": 1,
+  "lpm_enable_proc_node": "/test/proc/bluetooth/sleep/lpm",
+  "lpm_waking_proc_node": "/test/proc/bluetooth/sleep/btwrite",
+  "lpm_wakelock_ctrl_proc_node": "/test/proc/bluetooth/sleep/wakelock_ctrl",
+  "rfkill_folder_prefix": "/test/sys/class/rfkill/rfkill",
+  "rfkill_type_bluetooth": "testbluetooth"
+})";
+
+class ConfigLoaderTestBase : public Test {
+ protected:
+  void SetUp() override {
+    MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper_);
+    MockTransportInterface::SetMockTransport(&mock_transport_interface_);
+
+    HalConfigLoader::ResetLoader();
+  }
+
+  void SetupSetPropertyExpectations(const std::string& name,
+                                    const std::string& value) {
+    EXPECT_CALL(mock_android_base_wrapper_, SetProperty(name, value))
+        .Times(1)
+        .WillOnce(Return(true));
+  }
+
+  MockAndroidBaseWrapper mock_android_base_wrapper_;
+  MockTransportInterface mock_transport_interface_;
+};
+
+TEST_F(ConfigLoaderTestBase, IsFastDownloadEnabledOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsFastDownloadEnabled());
+}
+
+TEST_F(ConfigLoaderTestBase, IsSarBackoffHighResolutionEnabledOnInit) {
+  EXPECT_FALSE(
+      HalConfigLoader::GetLoader().IsSarBackoffHighResolutionEnabled());
+}
+
+TEST_F(ConfigLoaderTestBase, GetBtRegOnDelayMsOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetBtRegOnDelayMs(),
+            cfg_consts::kDefaultBtRegOnDelay);
+}
+
+TEST_F(ConfigLoaderTestBase, GetBtUartDevicePortOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetBtUartDevicePort(),
+            cfg_consts::kDefaultBtUartDevicePort);
+}
+
+TEST_F(ConfigLoaderTestBase, GetTransportTypePriorityOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetTransportTypePriority(),
+            (std::vector<TransportType>{TransportType::kUartH4}));
+}
+
+TEST_F(ConfigLoaderTestBase, IsAcceleratedBtOnSupportedOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported());
+}
+
+TEST_F(ConfigLoaderTestBase, IsThreadDispatcherEnabledOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsThreadDispatcherEnabled());
+}
+
+TEST_F(ConfigLoaderTestBase, IsBtPowerControlledByLppOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsBtPowerControlledByLpp());
+}
+
+TEST_F(ConfigLoaderTestBase, GetHwStagesWithoutLppControlBtPowerPinOnInit) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader()
+                  .GetHwStagesWithoutLppControlBtPowerPin()
+                  .empty());
+}
+
+TEST_F(ConfigLoaderTestBase, GetFwUnsupportedHwStagesOnInit) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().GetFwUnsupportedHwStages().empty());
+}
+
+TEST_F(ConfigLoaderTestBase, GetVendorTransportCrashIntervalSecOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetVendorTransportCrashIntervalSec(),
+            cfg_consts::kDefaultVendorTransportCrashIntervalSec);
+}
+
+TEST_F(ConfigLoaderTestBase, IsHpUartSkipSuspendSupportedOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsHpUartSkipSuspendSupported());
+}
+
+TEST_F(ConfigLoaderTestBase, IsEnergyControllerLoggingSupportedOnInit) {
+  EXPECT_FALSE(
+      HalConfigLoader::GetLoader().IsEnergyControllerLoggingSupported());
+}
+
+TEST_F(ConfigLoaderTestBase, IsBtHalRestartRecoverySupportedOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsBtHalRestartRecoverySupported());
+}
+
+TEST_F(ConfigLoaderTestBase, IsBleNonConnectionSarEnabledOnInit) {
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsBleNonConnectionSarEnabled());
+}
+
+TEST_F(ConfigLoaderTestBase, GetKernelRxWakelockTimeMillisecondsOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetKernelRxWakelockTimeMilliseconds(),
+            0);
+}
+
+TEST_F(ConfigLoaderTestBase, GetLpmEnableProcNodeOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetLpmEnableProcNode(),
+            cfg_consts::kLpmEnableProcNode);
+}
+
+TEST_F(ConfigLoaderTestBase, GetLpmWakingProcNodeOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetLpmWakingProcNode(),
+            cfg_consts::kLpmWakingProcNode);
+}
+
+TEST_F(ConfigLoaderTestBase, GetLpmWakelockCtrlProcNodeOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetLpmWakelockCtrlProcNode(),
+            cfg_consts::kLpmWakelockCtrlProcNode);
+}
+
+TEST_F(ConfigLoaderTestBase, GetRfkillFolderPrefixOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetRfkillFolderPrefix(),
+            cfg_consts::kRfkillFolderPrefix);
+}
+
+TEST_F(ConfigLoaderTestBase, GetRfkillTypeBluetoothOnInit) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetRfkillTypeBluetooth(),
+            cfg_consts::kRfkillTypeBluetooth);
+}
+
+class ConfigLoaderProtoTest : public ConfigLoaderTestBase {
+ protected:
+  void SetUp() override {
+    ConfigLoaderTestBase::SetUp();
+    EXPECT_TRUE(
+        HalConfigLoader::GetLoader().LoadConfigFromString(kValidContent));
+  }
+};
+
+TEST_F(ConfigLoaderProtoTest, IsFastDownloadEnabled) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsFastDownloadEnabled());
+}
+
+TEST_F(ConfigLoaderProtoTest, IsSarBackoffHighResolutionEnabled) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsSarBackoffHighResolutionEnabled());
+}
+
+TEST_F(ConfigLoaderProtoTest, GetBtRegOnDelayMs) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetBtRegOnDelayMs(),
+            kTestBtRegOnDelayMs);
+}
+
+TEST_F(ConfigLoaderProtoTest, GetBtUartDevicePort) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetBtUartDevicePort(),
+            kTestUartDevicePort);
+}
+
+TEST_F(ConfigLoaderProtoTest, GetTransportTypePriority) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetTransportTypePriority(),
+            (std::vector<TransportType>{TransportType::kUartH4}));
+}
+
+TEST_F(ConfigLoaderProtoTest, IsAcceleratedBtOnSupported) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported());
+}
+
+TEST_F(ConfigLoaderProtoTest, IsThreadDispatcherEnabled) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsThreadDispatcherEnabled());
+}
+
+TEST_F(ConfigLoaderProtoTest, IsBtPowerControlledByLpp) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsBtPowerControlledByLpp());
+}
+
+TEST_F(ConfigLoaderProtoTest, GetHwStagesWithoutLppControlBtPowerPin) {
+  EXPECT_EQ(
+      HalConfigLoader::GetLoader().GetHwStagesWithoutLppControlBtPowerPin(),
+      (std::vector<std::string>{"stage1", "stage2"}));
+}
+
+TEST_F(ConfigLoaderProtoTest, GetFwUnsupportedHwStages) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetFwUnsupportedHwStages(),
+            (std::vector<std::string>{"stage1", "stage2"}));
+}
+
+TEST_F(ConfigLoaderProtoTest, GetVendorTransportCrashIntervalSec) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetVendorTransportCrashIntervalSec(),
+            kTestVendorTransportCrashIntervalSec);
+}
+
+TEST_F(ConfigLoaderProtoTest, IsHpUartSkipSuspendSupported) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsHpUartSkipSuspendSupported());
+}
+
+TEST_F(ConfigLoaderProtoTest, IsEnergyControllerLoggingSupported) {
+  EXPECT_TRUE(
+      HalConfigLoader::GetLoader().IsEnergyControllerLoggingSupported());
+}
+
+TEST_F(ConfigLoaderProtoTest, IsBtHalRestartRecoverySupported) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsBtHalRestartRecoverySupported());
+}
+
+TEST_F(ConfigLoaderProtoTest, IsBleNonConnectionSarEnabled) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsBleNonConnectionSarEnabled());
+}
+
+TEST_F(ConfigLoaderProtoTest, GetKernelRxWakelockTimeMilliseconds) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetKernelRxWakelockTimeMilliseconds(),
+            kTestKernelRxWakelockTimeMs);
+}
+
+TEST_F(ConfigLoaderProtoTest, IsLowPowerModeSupported) {
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsLowPowerModeSupported());
+}
+
+TEST_F(ConfigLoaderProtoTest, GetLpmEnableProcNode) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetLpmEnableProcNode(),
+            kTestLpmEnableProcNode);
+}
+
+TEST_F(ConfigLoaderProtoTest, GetLpmWakingProcNode) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetLpmWakingProcNode(),
+            kTestLpmWakingProcNode);
+}
+
+TEST_F(ConfigLoaderProtoTest, GetLpmWakelockCtrlProcNode) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetLpmWakelockCtrlProcNode(),
+            kTestLpmWakelockCtrlProcNode);
+}
+
+TEST_F(ConfigLoaderProtoTest, GetRfkillFolderPrefix) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetRfkillFolderPrefix(),
+            kTestRfkillFolderPrefix);
+}
+
+TEST_F(ConfigLoaderProtoTest, GetRfkillTypeBluetooth) {
+  EXPECT_EQ(HalConfigLoader::GetLoader().GetRfkillTypeBluetooth(),
+            kTestRfkillTypeBluetooth);
+}
+
+class ConfigLoaderUtilTest : public ConfigLoaderTestBase {};
+
+TEST_F(ConfigLoaderUtilTest, IsBtSnoopLogFullModeOnReturnsTrue) {
+  HalConfigLoader& config_loader = HalConfigLoader::GetLoader();
+  Mock::VerifyAndClearExpectations(&mock_android_base_wrapper_);
+
+  EXPECT_CALL(mock_android_base_wrapper_,
+              GetProperty(Property::kBtSnoopLogMode, _))
+      .Times(1)
+      .WillOnce(Return("full"));
+  EXPECT_TRUE(config_loader.IsBtSnoopLogFullModeOn());
+}
+
+TEST_F(ConfigLoaderUtilTest, GetUartBaudRateWithUartH4Interface) {
+  EXPECT_EQ(
+      HalConfigLoader::GetLoader().GetUartBaudRate(TransportType::kUartH4),
+      BaudRate::kRate4000000);
+}
+
+TEST_F(ConfigLoaderUtilTest, IsUserDebugOrEngBuildReturnsTrue) {
+  ON_CALL(mock_android_base_wrapper_, GetProperty(Property::kBuildType, _))
+      .WillByDefault(Return("userdebug"));
+
+  EXPECT_TRUE(HalConfigLoader::GetLoader().IsUserDebugOrEngBuild());
+}
+
+TEST_F(ConfigLoaderUtilTest, IsUserDebugOrEngBuildReturnsFalse) {
+  ON_CALL(mock_android_base_wrapper_, GetProperty(Property::kBuildType, _))
+      .WillByDefault(Return("user"));
+
+  EXPECT_FALSE(HalConfigLoader::GetLoader().IsUserDebugOrEngBuild());
+}
+
+TEST_F(ConfigLoaderUtilTest, TransportFallbackEnabled) {
+  SetupSetPropertyExpectations(Property::kIsAcceleratedBtOnEnabled, "false");
+  SetupSetPropertyExpectations(Property::kTransportFallbackEnabled, "true");
+
+  EnableTransportFallback();
+}
+
+TEST_F(ConfigLoaderUtilTest, IsSameSingleton) {
+  EXPECT_EQ(&HalConfigLoader::GetLoader(), &HalConfigLoader::GetLoader());
+}
+
+}  // namespace
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/config/proto/Android.bp b/bluetooth/bluetooth_hal/config/proto/Android.bp
new file mode 100644
index 0000000000..4b0e6b11d6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/Android.bp
@@ -0,0 +1,130 @@
+/*
+ *  Copyright (c) 2025 The Android Open Source Project
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+genrule {
+    name: "cs_config_proto_headers",
+    tools: [
+        "aprotoc",
+    ],
+    cmd: "$(location aprotoc) --proto_path=hardware/interfaces/bluetooth/bluetooth_hal/config/proto $(in) --cpp_out=$(genDir)",
+    srcs: [
+        "cs_config.proto",
+    ],
+    out: [
+        "cs_config.pb.h",
+    ],
+}
+
+genrule {
+    name: "cs_config_proto_sources",
+    tools: [
+        "aprotoc",
+    ],
+    cmd: "$(location aprotoc) --proto_path=hardware/interfaces/bluetooth/bluetooth_hal/config/proto $(in) --cpp_out=$(genDir)",
+    srcs: [
+        "cs_config.proto",
+    ],
+    out: [
+        "cs_config.pb.cc",
+    ],
+}
+
+genrule {
+    name: "hal_config_proto_headers",
+    tools: [
+        "aprotoc",
+    ],
+    cmd: "$(location aprotoc) --proto_path=hardware/interfaces/bluetooth/bluetooth_hal/config/proto $(in) --cpp_out=$(genDir)",
+    srcs: [
+        "hal_config.proto",
+    ],
+    out: [
+        "hal_config.pb.h",
+    ],
+}
+
+genrule {
+    name: "hal_config_proto_sources",
+    tools: [
+        "aprotoc",
+    ],
+    cmd: "$(location aprotoc) --proto_path=hardware/interfaces/bluetooth/bluetooth_hal/config/proto $(in) --cpp_out=$(genDir)",
+    srcs: [
+        "hal_config.proto",
+    ],
+    out: [
+        "hal_config.pb.cc",
+    ],
+}
+
+genrule {
+    name: "firmware_config_proto_headers",
+    tools: [
+        "aprotoc",
+    ],
+    cmd: "$(location aprotoc) --proto_path=hardware/interfaces/bluetooth/bluetooth_hal/config/proto $(in) --cpp_out=$(genDir)",
+    srcs: [
+        "firmware_config.proto",
+    ],
+    out: [
+        "firmware_config.pb.h",
+    ],
+}
+
+genrule {
+    name: "firmware_config_proto_sources",
+    tools: [
+        "aprotoc",
+    ],
+    cmd: "$(location aprotoc) --proto_path=hardware/interfaces/bluetooth/bluetooth_hal/config/proto $(in) --cpp_out=$(genDir)",
+    srcs: [
+        "firmware_config.proto",
+    ],
+    out: [
+        "firmware_config.pb.cc",
+    ],
+}
+
+cc_library_static {
+    name: "hal_proto_lib",
+    host_supported: true,
+    include_dirs: [
+        "external/protobuf/src",
+    ],
+    generated_headers: [
+        "cs_config_proto_headers",
+        "hal_config_proto_headers",
+        "firmware_config_proto_headers",
+    ],
+    export_generated_headers: [
+        "cs_config_proto_headers",
+        "hal_config_proto_headers",
+        "firmware_config_proto_headers",
+    ],
+    generated_sources: [
+        "cs_config_proto_sources",
+        "hal_config_proto_sources",
+        "firmware_config_proto_sources",
+    ],
+    shared_libs: [
+        "libprotobuf-cpp-full",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+        "-Wno-unused-parameter",
+    ],
+}
diff --git a/bluetooth/bluetooth_hal/config/proto/README b/bluetooth/bluetooth_hal/config/proto/README
new file mode 100644
index 0000000000..945c0c3d44
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/README
@@ -0,0 +1,27 @@
+# Bluetooth HAL Configuration Files Description
+
+This directory contains Protobuf files that define the structure of configuration files used by the Bluetooth HAL (Hardware Abstraction Layer). The actual configuration files are in JSON format and must be placed in the `/vendor/etc/bluetooth/` directory on the device.
+
+## Configuration File Location
+
+All JSON configuration files defined by these Protobuf files must be placed at the following path on the device:
+
+`/vendor/etc/bluetooth/`
+
+## Protobuf File Descriptions
+
+Below is a brief description of each Protobuf file and its corresponding JSON file:
+
+1.  **`hal_config.proto`**
+    *   **Corresponding JSON File:** `hal_config.json`
+    *   **Purpose:** This file defines the main configuration for the Bluetooth HAL. It includes settings for general HAL functionalities such as the UART serial port path, transport type priority, whether to enable fast firmware download, SAR (Specific Absorption Rate) feature settings, and whether to enable accelerated Bluetooth startup.
+
+2.  **`firmware_config.proto`**
+    *   **Corresponding JSON File:** `firmware_config.json`
+    *   **Purpose:** This file defines settings related to Bluetooth chip firmware download and initialization. It includes the path to the firmware file, chip ID, HCI commands to be executed before/after firmware download (e.g., HCI Reset, update baud rate, download Minidriver), and the delay times between executing these commands.
+
+3.  **`cs_config.proto`** (`cs` stands for Channel Sounding)
+    *   **Corresponding JSON File:** `bluetooth_channel_sounding_calibration.json`
+    *   **Purpose:** This file defines the calibration commands required for the Bluetooth Channel Sounding feature. It contains a series of HCI commands that are sent to the Bluetooth controller at specific times to complete the calibration procedure for the Channel Sounding feature.
+
+Please ensure that the corresponding JSON configuration files are correctly placed in the `/vendor/etc/bluetooth/` directory when building the system image, so that the Bluetooth HAL can read and apply these settings.
diff --git a/bluetooth/bluetooth_hal/config/proto/cs_config.json b/bluetooth/bluetooth_hal/config/proto/cs_config.json
new file mode 100644
index 0000000000..a231d552fe
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/cs_config.json
@@ -0,0 +1,35 @@
+{
+  "commands": [
+    {
+      "packet_type": 1,
+      "opcode": 4660,
+      "payload_length": 8,
+      "sub_opcode": [
+        1,
+        2,
+        3
+      ],
+      "data": [
+        4,
+        5,
+        6,
+        7,
+        8
+      ]
+    },
+    {
+      "packet_type": 1,
+      "opcode": 4660,
+      "payload_length": 5,
+      "sub_opcode": [
+        10,
+        11
+      ],
+      "data": [
+        12,
+        13,
+        14
+      ]
+    }
+  ]
+}
diff --git a/bluetooth/bluetooth_hal/config/proto/cs_config.proto b/bluetooth/bluetooth_hal/config/proto/cs_config.proto
new file mode 100644
index 0000000000..c2857f3b36
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/cs_config.proto
@@ -0,0 +1,31 @@
+/*
+ *  Copyright (c) 2025 The Android Open Source Project
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+syntax = "proto3";
+
+package bluetooth_hal.config.proto;
+
+message Command {
+  uint32 packet_type = 1;
+  uint32 opcode = 2;
+  uint32 payload_length = 3;
+  repeated uint32 sub_opcode = 4;
+  repeated uint32 data = 5;
+}
+
+message CalibrationCommands {
+  repeated Command commands = 1;
+}
diff --git a/bluetooth/bluetooth_hal/config/proto/firmware_config.json b/bluetooth/bluetooth_hal/config/proto/firmware_config.json
new file mode 100644
index 0000000000..b65d7a6e46
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/firmware_config.json
@@ -0,0 +1,94 @@
+{
+  "firmware_folder_name": "/PATH/TO/FOLDER/",
+  "firmware_file_name": "FILENAME",
+  "chip_id": 123,
+  "load_mini_drv_delay_ms": 100,
+  "launch_ram_delay_ms": 100,
+  "firmware_data_loading_type": "PACKET_BY_PACKET",
+  "setup_commands": {
+    "hci_reset": [
+      1,
+      3,
+      12,
+      0
+    ],
+    "hci_read_chip_id": [
+      1,
+      121,
+      252,
+      0
+    ],
+    "hci_update_chip_baud_rate": [
+      1,
+      24,
+      252,
+      6,
+      0,
+      0,
+      0,
+      9,
+      61,
+      0
+    ],
+    "hci_set_fast_download": [
+      1,
+      114,
+      254,
+      2,
+      0,
+      1
+    ],
+    "hci_download_minidrv": [
+      1,
+      46,
+      252,
+      0
+    ],
+    "hci_vsc_launch_ram": [
+      1,
+      78,
+      252,
+      4,
+      255,
+      255,
+      255,
+      255
+    ],
+    "hci_read_fw_version": [
+      1,
+      20,
+      12,
+      0
+    ],
+    "hci_setup_low_power_mode": [
+      1,
+      39,
+      252,
+      12,
+      1,
+      24,
+      24,
+      1,
+      1,
+      1,
+      1,
+      0,
+      0,
+      0,
+      0,
+      0
+    ],
+    "hci_write_bd_address": [
+      1,
+      1,
+      252,
+      6,
+      30,
+      77,
+      19,
+      43,
+      213,
+      232
+    ]
+  }
+}
diff --git a/bluetooth/bluetooth_hal/config/proto/firmware_config.proto b/bluetooth/bluetooth_hal/config/proto/firmware_config.proto
new file mode 100644
index 0000000000..c0851e6db8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/firmware_config.proto
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (c) 2025 The Android Open Source Project
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+syntax = "proto3";
+
+package bluetooth_hal.config.proto;
+
+message FirmwareConfig {
+  optional string firmware_folder_name = 1;
+  optional string firmware_file_name = 2;
+  optional uint32 chip_id = 3;
+  optional uint32 load_mini_drv_delay_ms = 4;
+  optional uint32 launch_ram_delay_ms = 5;
+
+  enum FirmwareDataLoadingType {
+    PACKET_BY_PACKET = 0;
+    ACCUMULATED_BUFFER = 1;
+  }
+  optional FirmwareDataLoadingType firmware_data_loading_type = 6;
+
+  optional SetupCommands setup_commands = 7;
+}
+
+message SetupCommands {
+  repeated uint32 hci_reset = 1;
+  repeated uint32 hci_read_chip_id = 2;
+  repeated uint32 hci_update_chip_baud_rate = 3;
+  repeated uint32 hci_set_fast_download = 4;
+  repeated uint32 hci_download_minidrv = 5;
+  repeated uint32 hci_vsc_launch_ram = 6;
+  repeated uint32 hci_read_fw_version = 7;
+  repeated uint32 hci_setup_low_power_mode = 8;
+  repeated uint32 hci_write_bd_address = 9;
+}
diff --git a/bluetooth/bluetooth_hal/config/proto/hal_config.json b/bluetooth/bluetooth_hal/config/proto/hal_config.json
new file mode 100644
index 0000000000..85a371133a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/hal_config.json
@@ -0,0 +1,37 @@
+{
+  "fast_download_enabled": true,
+  "sar_backoff_high_resolution_enabled": true,
+  "reg_on_delay_ms": 500,
+  "uart_device_port": "/dev/ttySAC18",
+  "transport_type_priority": [
+    1,
+    2,
+    3
+  ],
+  "accelerated_bt_on_enabled": true,
+  "thread_dispatcher_enabled": true,
+  "bt_power_controlled_by_lpp": true,
+  "hw_stages_without_lpp_control_bt_power_pin": [
+    "stage1",
+    "stage2"
+  ],
+  "fw_unsupported_hw_stages": [
+    "stage1",
+    "stage2"
+  ],
+  "vendor_transport_crash_interval_sec": 3000,
+  "hp_uart_skip_suspend_enabled": true,
+  "energy_controller_logging_enabled": true,
+  "self_restart_recovery_enabled": true,
+  "ble_non_connection_sar_enabled": true,
+  "kernel_rx_wakelock_time_ms": 200,
+  "low_power_mode_enabled": true,
+  "bqr_event_mask": "456",
+  "ldac_quality_mode": "mode1",
+  "transport_fallback_type": 1,
+  "lpm_enable_proc_node": "/proc/bluetooth/sleep/lpm",
+  "lpm_waking_proc_node": "/proc/bluetooth/sleep/btwrite",
+  "lpm_wakelock_ctrl_proc_node": "/proc/bluetooth/sleep/wakelock_ctrl",
+  "rfkill_folder_prefix": "/sys/class/rfkill/rfkill",
+  "rfkill_type_bluetooth": "bluetooth"
+}
diff --git a/bluetooth/bluetooth_hal/config/proto/hal_config.proto b/bluetooth/bluetooth_hal/config/proto/hal_config.proto
new file mode 100644
index 0000000000..0bc274632e
--- /dev/null
+++ b/bluetooth/bluetooth_hal/config/proto/hal_config.proto
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (c) 2025 The Android Open Source Project
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+syntax = "proto3";
+
+package bluetooth_hal.config.proto;
+
+message HalConfig {
+  optional bool fast_download_enabled = 1;
+  optional bool sar_backoff_high_resolution_enabled = 2;
+  optional int32 reg_on_delay_ms = 3;
+  optional string uart_device_port = 4;
+  repeated int32 transport_type_priority = 5;
+  optional bool accelerated_bt_on_enabled = 6;
+  optional bool thread_dispatcher_enabled = 7;
+  optional bool bt_power_controlled_by_lpp = 8;
+  repeated string hw_stages_without_lpp_control_bt_power_pin = 9;
+  repeated string fw_unsupported_hw_stages = 10;
+  optional int32 vendor_transport_crash_interval_sec = 12;
+  optional bool hp_uart_skip_suspend_enabled = 13;
+  optional bool energy_controller_logging_enabled = 14;
+  optional bool self_restart_recovery_enabled = 15;
+  optional bool ble_non_connection_sar_enabled = 16;
+  optional int32 kernel_rx_wakelock_time_ms = 17;
+  optional bool low_power_mode_enabled = 18;
+  optional string bqr_event_mask = 19;
+  optional string ldac_quality_mode = 20;
+  optional int32 transport_fallback_type = 21;
+  optional string lpm_enable_proc_node = 22;
+  optional string lpm_waking_proc_node = 23;
+  optional string lpm_wakelock_ctrl_proc_node = 24;
+  optional string rfkill_folder_prefix = 25;
+  optional string rfkill_type_bluetooth = 26;
+}
diff --git a/bluetooth/bluetooth_hal/debug/bluetooth_activity.cc b/bluetooth/bluetooth_hal/debug/bluetooth_activity.cc
new file mode 100644
index 0000000000..cbb674b987
--- /dev/null
+++ b/bluetooth/bluetooth_hal/debug/bluetooth_activity.cc
@@ -0,0 +1,734 @@
+/*
+ * Copyright 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.activity"
+
+#include "bluetooth_hal/debug/bluetooth_activity.h"
+
+#include <sys/stat.h>
+
+#include <future>
+#include <mutex>
+#include <sstream>
+#include <string>
+
+#include "android-base/logging.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/debug/command_error_code.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/files.h"
+#include "bluetooth_hal/util/logging.h"
+
+namespace {
+
+using ::android::base::StringPrintf;
+using ::bluetooth_hal::hci::CommandOpCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::util::Logger;
+
+using Milliseconds = std::chrono::milliseconds;
+using SteadyClockPoint = std::chrono::time_point<std::chrono::steady_clock>;
+
+std::recursive_mutex mutex_activity;
+timer_t acl_data_timer;
+itimerspec acl_ts{};
+bool acl_data_activity_flag = false;
+bool acl_data_timer_created = false;
+uint32_t acl_data_counter = 0;
+uint32_t acl_tx_data_counter = 0;
+uint32_t acl_rx_data_counter = 0;
+uint32_t num_of_compl_packet = 0;
+uint32_t hci_command_counter = 0;
+uint32_t hci_event_counter = 0;
+SteadyClockPoint first_acl_data_timepoint_;
+acl_data_activities_t acl_stat{};
+
+timer_t le_adv_timer;
+itimerspec le_ts{};
+bool le_adv_activity_flag = false;
+bool le_adv_timer_created = false;
+uint32_t le_adv_counter = 0;
+SteadyClockPoint first_le_adv_timepoint_;
+ble_adv_activities_t ble_stat{};
+
+timer_t pkt_timer;
+itimerspec pkt_ts{};
+bool pkt_activity_flag = false;
+bool pkt_timer_created = false;
+int pkt_counter = 0;
+SteadyClockPoint first_pkt_timepoint_;
+SteadyClockPoint previous_last_pkt_timepoint_;
+pkt_activities_t pkt_stat{};
+
+bool is_logger_on = false;
+constexpr uint16_t kBtContiBleAdvRecordPeriodMs = 10000;
+constexpr uint16_t kBtContiAclDataRecordPeriodMs = 10000;
+constexpr uint8_t kBtContiDataTimerExpiredSec = 1;
+constexpr uint32_t kBtContiDataTimerExpiredNs = 0;
+
+constexpr uint16_t kBtMaxConnectHistoryRecord = 1024;
+constexpr uint8_t kConnectionCompleteEventCode = 0x03;
+constexpr uint8_t kDisConnectionCompleteEventCode = 0x05;
+constexpr uint8_t kLeAdvertisingEventCode = 0x3e;
+constexpr uint8_t kNumberOfCompletedPacketsEvent = 0x13;
+
+const std::string kBtActivitiesPacketLogPath =
+    "/data/vendor/bluetooth/bt_activity_pkt.txt";
+}  // namespace
+
+namespace bluetooth_hal {
+namespace debug {
+
+void sum_of_acl_data(std::vector<acl_data_activities_t>& acl_data,
+                     uint32_t* sum_of_duration, uint32_t* sum_of_acl_count,
+                     uint32_t* sum_of_acltx_count,
+                     uint32_t* sum_of_aclrx_count) {
+  for (int i = 0; i < acl_data.size(); i++) {
+    *sum_of_duration += acl_data[i].duration;
+    *sum_of_acl_count += acl_data[i].acl_data_count;
+    *sum_of_acltx_count += acl_data[i].acl_tx_data_count;
+    *sum_of_aclrx_count += acl_data[i].acl_rx_data_count;
+  }
+}
+
+void sum_of_ble_adv_data(std::vector<ble_adv_activities_t>& adv_data,
+                         uint32_t* sum_of_duration, uint32_t* sum_of_count) {
+  for (int i = 0; i < adv_data.size(); i++) {
+    *sum_of_duration += adv_data[i].duration;
+    *sum_of_count += adv_data[i].le_adv_count;
+  }
+}
+
+BtActivitiesLogger bt_metrics_instance_;
+
+std::ofstream BtActivitiesLogger::pkt_activity_ostream_;
+
+BtActivitiesLogger* BtActivitiesLogger::GetInstacne() {
+  return &bt_metrics_instance_;
+}
+
+void BtActivitiesLogger::update_connect_disconnect_history(
+    const tCONN_DEVICE& device) {
+  if (connection_history_.size() >= kBtMaxConnectHistoryRecord) {
+    auto it = connection_history_.begin();
+    // remove the eariset connecting/disconnecting record
+    connection_history_.erase(it);
+  }
+  // push new connecting/disconnecting record to the back of list
+  connection_history_.emplace_back(device);
+}
+
+void BtActivitiesLogger::open_new_hci_packet_log_file() {
+  LOG(INFO) << __func__;
+  bt_activities_pkt_log_path_ = std::move(kBtActivitiesPacketLogPath);
+  os::CloseLogFileStream(pkt_activity_ostream_);
+  os::CreateLogFile(bt_activities_pkt_log_path_, pkt_activity_ostream_);
+  pkt_activity_ostream_ << "start_timestamp" << ", end_timestamp"
+                        << ", pkt_duration (ms)" << ", idle_delta"
+                        << ", packet_count" << ", total_packet_count"
+                        << ", ble_adv:" << ", adv_timestamp"
+                        << ", adv_duration (ms)" << ", adv_count"
+                        << ", total_adv_count"
+                        << ", acl_data:" << ", acl_timestamp"
+                        << ", acl_duration (ms)" << ", acl_conn_handle"
+                        << ", acl_data_count" << ", acl_tx_count"
+                        << ", acl_rx_count" << ", total_acl_data_count"
+                        << ", total_acl_tx_count" << ", total_acl_rx_count"
+                        << ", cmd/evt:" << ", cmd_count" << ", evt_count"
+                        << ", num_compl_pkt_evt_count" << std::endl;
+  if (!pkt_activity_ostream_.flush()) {
+    LOG(ERROR) << __func__ << ": Failed to flush, error: \"" << strerror(errno)
+               << "\".";
+  }
+}
+
+void BtActivitiesLogger::ForceUpdating() {
+  LOG(INFO) << __func__;
+  LeAdvTimeout();
+  AclDataTimeout();
+  HciPacketTimeout();
+}
+
+void BtActivitiesLogger::StartLogging() { open_new_hci_packet_log_file(); }
+
+void BtActivitiesLogger::StopLogging() {
+  LOG(INFO) << __func__;
+  ForceUpdating();
+  os::CloseLogFileStream(pkt_activity_ostream_);
+}
+
+void BtActivitiesLogger::OnBluetoothEnabled() {
+  LOG(INFO) << __func__;
+  int ret;
+  ble_stat = {};
+  acl_stat = {};
+  pkt_stat = {};
+  hci_command_counter = 0;
+  hci_event_counter = 0;
+  acl_data_counter = 0;
+  acl_tx_data_counter = 0;
+  acl_rx_data_counter = 0;
+  num_of_compl_packet = 0;
+
+  sigevent se{};
+  se.sigev_notify = SIGEV_THREAD;
+  se.sigev_value.sival_ptr = this;
+  se.sigev_notify_function = (void (*)(sigval))LeAdvTimeout;
+  se.sigev_notify_attributes = NULL;
+  ret = timer_create(CLOCK_MONOTONIC, &se, &le_adv_timer);
+  if (ret < 0) {
+    LOG(ERROR) << __func__ << ": Cannot create le_adv_timer!";
+  } else {
+    le_adv_timer_created = true;
+  }
+
+  sigevent acl_se{};
+  acl_se.sigev_notify = SIGEV_THREAD;
+  acl_se.sigev_value.sival_ptr = this;
+  acl_se.sigev_notify_function = (void (*)(sigval))AclDataTimeout;
+  acl_se.sigev_notify_attributes = NULL;
+  ret = timer_create(CLOCK_MONOTONIC, &acl_se, &acl_data_timer);
+  if (ret < 0) {
+    LOG(ERROR) << __func__ << ": Cannot create acl_data_timer!";
+  } else {
+    acl_data_timer_created = true;
+  }
+
+  sigevent pkt_se{};
+  pkt_se.sigev_notify = SIGEV_THREAD;
+  pkt_se.sigev_value.sival_ptr = this;
+  pkt_se.sigev_notify_function = (void (*)(sigval))HciPacketTimeout;
+  pkt_se.sigev_notify_attributes = NULL;
+  ret = timer_create(CLOCK_MONOTONIC, &pkt_se, &pkt_timer);
+  if (ret < 0) {
+    LOG(ERROR) << __func__ << ": Cannot create pkt_timer!";
+  } else {
+    pkt_timer_created = true;
+  }
+  is_logger_on = true;
+}
+
+void BtActivitiesLogger::OnBluetoothDisabled() {
+  LOG(INFO) << __func__;
+  is_logger_on = false;
+  if (le_adv_timer_created == true) {
+    itimerspec se{};
+    timer_settime(le_adv_timer, 0, &se, NULL);
+    timer_delete(le_adv_timer);
+    le_adv_timer_created = false;
+  }
+  if (acl_data_timer_created == true) {
+    itimerspec acl_se{};
+    timer_settime(acl_data_timer, 0, &acl_se, NULL);
+    timer_delete(acl_data_timer);
+    acl_data_timer_created = false;
+  }
+  if (pkt_timer_created == true) {
+    itimerspec pkt_se{};
+    timer_settime(pkt_timer, 0, &pkt_se, NULL);
+    timer_delete(pkt_timer);
+    pkt_timer_created = false;
+  }
+
+  LeAdvTimeout();
+  AclDataTimeout();
+  HciPacketTimeout();
+  ble_stat = {};
+  acl_stat = {};
+  pkt_stat = {};
+}
+
+void BtActivitiesLogger::AclDataTimeout() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_activity);
+  if (acl_data_activity_flag == true) {
+    SteadyClockPoint last_acl_data_timepoint_ =
+        std::chrono::steady_clock::now();
+    Milliseconds delta_ms = std::chrono::duration_cast<Milliseconds>(
+        last_acl_data_timepoint_ - first_acl_data_timepoint_);
+    acl_stat.duration = delta_ms.count();
+    acl_stat.end_timestamp = Logger::GetLogFormatTimestamp();
+    acl_stat.acl_tx_data_count = acl_tx_data_counter;
+    acl_stat.acl_rx_data_count = acl_rx_data_counter;
+    acl_stat.acl_data_count = acl_data_counter;
+    acl_stat.total_acl_data_count += acl_data_counter;
+
+    LOG(INFO) << __func__
+              << ": bt_power: AclDataStat: " << acl_stat.start_timestamp
+              << " - " << acl_stat.end_timestamp
+              << ", conn_handle: " << acl_stat.acl_conn_handle
+              << ", duration: " << acl_stat.duration
+              << ", acl_data_count: " << acl_stat.acl_data_count
+              << ", acl_tx_data_count: " << acl_stat.acl_tx_data_count
+              << ", acl_rx_data_count: " << acl_stat.acl_rx_data_count
+              << ", total_acl_data_count: " << acl_stat.total_acl_data_count
+              << ".";
+
+    BtActivitiesLogger::GetInstacne()->UpdateAclDataStat(acl_stat);
+    pkt_stat.acl_data.push_back(std::move(acl_stat));
+    acl_data_activity_flag = false;
+    acl_data_counter = 0;
+    acl_tx_data_counter = 0;
+    acl_rx_data_counter = 0;
+  }
+  acl_ts.it_value.tv_sec = 0;
+  acl_ts.it_value.tv_nsec = 0;
+  if (acl_data_timer_created == true && is_logger_on == true) {
+    timer_settime(acl_data_timer, 0, &acl_ts, NULL);
+  }
+}
+
+void BtActivitiesLogger::LeAdvTimeout() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_activity);
+  if (le_adv_activity_flag == true) {
+    SteadyClockPoint last_le_adv_timepoint_ = std::chrono::steady_clock::now();
+    Milliseconds delta_ms = std::chrono::duration_cast<Milliseconds>(
+        last_le_adv_timepoint_ - first_le_adv_timepoint_);
+    ble_stat.duration = delta_ms.count();
+    ble_stat.le_adv_count = le_adv_counter;
+    ble_stat.total_le_adv_count += le_adv_counter;
+    ble_stat.end_timestamp = Logger::GetLogFormatTimestamp();
+
+    LOG(INFO) << __func__
+              << ": bt_power: LeAdvStat: " << ble_stat.start_timestamp << " - "
+              << ble_stat.end_timestamp << ", duration: " << ble_stat.duration
+              << ", le_adv_count: " << ble_stat.le_adv_count
+              << ", total_le_adv_count: " << ble_stat.total_le_adv_count
+              << ", total_event_count: " << hci_event_counter << ".";
+
+    BtActivitiesLogger::GetInstacne()->UpdateLeAdvStat(ble_stat);
+    pkt_stat.ble_stat.push_back(std::move(ble_stat));
+    le_adv_activity_flag = false;
+    le_adv_counter = 0;
+  }
+  le_ts.it_value.tv_sec = 0;
+  le_ts.it_value.tv_nsec = 0;
+  if (le_adv_timer_created == true && is_logger_on == true) {
+    timer_settime(le_adv_timer, 0, &le_ts, NULL);
+  }
+}
+
+void BtActivitiesLogger::HciPacketTimeout() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_activity);
+  if (pkt_activity_flag == true) {
+    SteadyClockPoint last_pkt_timepoint_ = std::chrono::steady_clock::now();
+    previous_last_pkt_timepoint_ = last_pkt_timepoint_;
+    Milliseconds delta_ms = std::chrono::duration_cast<Milliseconds>(
+        last_pkt_timepoint_ - first_pkt_timepoint_);
+    pkt_stat.duration = delta_ms.count();
+    pkt_stat.pkt_count = pkt_counter;
+    pkt_stat.total_pkt_count += pkt_counter;
+    pkt_stat.hci_command_count = hci_command_counter;
+    pkt_stat.hci_event_count = hci_event_counter;
+    pkt_stat.num_cmpl_pkt_evt_count = num_of_compl_packet;
+    pkt_stat.end_timestamp = Logger::GetLogFormatTimestamp();
+    pkt_activity_flag = false;
+    pkt_counter = 0;
+    std::future<void> future = std::async(
+        BtActivitiesLogger::UpdateHciPacketStat, std::move(pkt_stat));
+    future.wait();
+  }
+  hci_command_counter = 0;
+  hci_event_counter = 0;
+  pkt_ts.it_value.tv_sec = 0;
+  pkt_ts.it_value.tv_nsec = 0;
+  if (pkt_timer_created == true && is_logger_on == true) {
+    timer_settime(pkt_timer, 0, &pkt_ts, NULL);
+  }
+}
+
+void BtActivitiesLogger::handle_ble_meta_event(const HalPacket& data) {
+  int ret;
+  uint16_t le_meta_subevent = data[2];
+  if (le_meta_subevent == 0x0d || le_meta_subevent == 0x02) {
+    // LE Meta Event, SubEvent: LE Extended Advertising Report
+    if (le_adv_activity_flag == false) {
+      first_le_adv_timepoint_ = std::chrono::steady_clock::now();
+      ble_stat.start_timestamp = Logger::GetLogFormatTimestamp();
+      le_adv_activity_flag = true;
+    }
+    le_adv_counter++;
+    // update timer
+    le_ts.it_value.tv_sec = kBtContiDataTimerExpiredSec;
+    le_ts.it_value.tv_nsec = kBtContiDataTimerExpiredNs;
+    if (le_adv_timer_created == true && is_logger_on == true) {
+      ret = timer_settime(le_adv_timer, 0, &le_ts, NULL);
+      if (ret < 0) {
+        LOG(ERROR) << __func__ << ": Cannot arm le_adv_timer!";
+      }
+    }
+  } else if (le_meta_subevent == 0x0a && data[3] == 0x00) {
+    // LE Meta Event, SubEvent: LE Enhanced Connection Complete
+    tCONN_DEVICE bt_device{};
+    bt_device.connect_handle = data[4] + ((data[5] << 8u) & 0x0F00);
+    bt_device.bd_addr = StringPrintf("XX:XX:%02hhx:%02hhx:%02hhx:%02hhx",
+                                     data[11], data[10], data[9], data[8]);
+    bt_device.status = GetResultString(data[3]);
+    if (bt_device.status == "Success") {
+      connected_bda_[bt_device.connect_handle] = bt_device.bd_addr;
+    }
+    bt_device.timestamp = Logger::GetLogFormatTimestamp();
+    bt_device.rcvd_event = "LE Enhanced Connection Complete";
+    LOG(INFO) << __func__
+              << ": LE Enhanced Connection Complete, conn_handle: " << std::hex
+              << std::setw(3) << std::setfill('0') << bt_device.connect_handle
+              << ", conn_bda: " << bt_device.bd_addr << ".";
+
+    // push a new coming record to the back of list
+    update_connect_disconnect_history(bt_device);
+  }
+}
+
+void BtActivitiesLogger::handle_connect_complete_event(const HalPacket& data) {
+  tCONN_DEVICE bt_device{};
+  uint16_t conn_handle = data[3] + ((data[4] << 8u) & 0x0F00);
+  bt_device.connect_handle = conn_handle;
+  bt_device.timestamp = Logger::GetLogFormatTimestamp();
+  bt_device.status = GetResultString(data[2]);
+  bt_device.bd_addr = StringPrintf("XX:XX:%02hhx:%02hhx:%02hhx:%02hhx", data[8],
+                                   data[7], data[6], data[5]);
+  if (bt_device.status == "Success") {
+    connected_bda_[conn_handle] = bt_device.bd_addr;
+    LOG(INFO) << __func__
+              << ": CreateConnectCompleteEvent, conn_handle: " << std::hex
+              << std::setw(3) << std::setfill('0') << bt_device.connect_handle
+              << ", conn_bda: " << bt_device.bd_addr << ".";
+  }
+  bt_device.rcvd_event = "Connect Complete";
+  // push a new coming record to the back of list
+  update_connect_disconnect_history(bt_device);
+}
+
+void BtActivitiesLogger::handle_disconnect_complete_event(
+    const HalPacket& data) {
+  tCONN_DEVICE bt_device{};
+  uint16_t conn_handle = data[3] + ((data[4] << 8u) & 0x0F00);
+  bt_device.connect_handle = conn_handle;
+  bt_device.bd_addr = connected_bda_[conn_handle];
+  bt_device.timestamp = Logger::GetLogFormatTimestamp();
+  bt_device.status = GetResultString(data[5]);
+  if (bt_device.status == "Success") {
+    connected_bda_.erase(conn_handle);
+    LOG(INFO) << __func__
+              << ": DisConnectCompleteEvent, conn_handle: " << std::hex
+              << std::setw(3) << std::setfill('0') << bt_device.connect_handle
+              << ", conn_bda: " << bt_device.bd_addr << ".";
+  }
+  bt_device.rcvd_event = "Disconnect Complete";
+  // push a new disconnecting record to the back of list
+  update_connect_disconnect_history(bt_device);
+}
+
+void BtActivitiesLogger::LogActivities(BtActivityPacketType activity_type,
+                                       const HalPacket& data) {
+  int ret;
+  uint16_t opcode;
+  std::unique_lock<std::recursive_mutex> lock(mutex_activity);
+  if (pkt_activity_flag == false) {
+    pkt_stat.ble_stat = {};
+    pkt_stat.acl_data = {};
+    pkt_counter = 0;
+    num_of_compl_packet = 0;
+    first_pkt_timepoint_ = std::chrono::steady_clock::now();
+    if (first_pkt_timepoint_ > previous_last_pkt_timepoint_) {
+      Milliseconds delta_ms = std::chrono::duration_cast<Milliseconds>(
+          first_pkt_timepoint_ - previous_last_pkt_timepoint_);
+      pkt_stat.delta = delta_ms.count();
+    } else {
+      pkt_stat.delta = 0;
+    }
+    pkt_stat.start_timestamp = Logger::GetLogFormatTimestamp();
+    pkt_activity_flag = true;
+  }
+  pkt_counter++;
+  switch (activity_type) {
+    case BtActivityPacketType::COMMAND:
+      hci_command_counter++;
+      opcode = data[0] + ((data[1] << 8u) & 0xFF00);
+      if (opcode == static_cast<uint16_t>(CommandOpCode::kLeScanEnable)) {
+        if (data[3] == 0x01) {
+          // Enable
+          LOG(INFO) << __func__ << ": Enable LE Scanning, 0x" << std::hex
+                    << std::setw(2) << std::setfill('0') << opcode << ".";
+        } else if (data[3] == 0x00) {
+          // Disable
+          LOG(INFO) << __func__ << ": Disable LE Scanning, 0x" << std::hex
+                    << std::setw(2) << std::setfill('0') << opcode << ".";
+        } else {
+          LOG(INFO) << __func__ << ": Invalid Parameter of LE_Set_Scan_Enable.";
+        }
+      } else if (opcode == static_cast<uint16_t>(
+                               CommandOpCode::kLeSetExtendedScanParam)) {
+        uint16_t scan_interval = data[7] + ((data[8] << 8u) & 0xFF00);
+        uint16_t scan_window = data[9] + ((data[10] << 8u) & 0xFF00);
+        int ratio = scan_interval / scan_window;
+        if (ratio == 1) {
+          LOG(INFO) << __func__ << ": LOW_LATENCY ScanMode.";
+        } else if (ratio == 4) {
+          LOG(INFO) << __func__ << ": BALANCED ScanMode.";
+
+        } else if (ratio == 10) {
+          LOG(INFO) << __func__ << ": LOW_POWER ScanMode.";
+        } else {
+          LOG(INFO) << __func__ << ": Other ScanMode, ratio: " << ratio << ".";
+        }
+      } else if (opcode ==
+                 static_cast<uint16_t>(CommandOpCode::kLeExtCreateConnection)) {
+        LOG(INFO) << __func__ << ": LE Extended Create Connection.";
+      }
+      break;
+    case BtActivityPacketType::EVENT:
+      hci_event_counter++;
+      // LE Meta Event
+      if (data[0] == kLeAdvertisingEventCode) {
+        handle_ble_meta_event(data);
+      } else if (data[0] == kConnectionCompleteEventCode) {
+        handle_connect_complete_event(data);
+      } else if (data[0] == kDisConnectionCompleteEventCode) {
+        handle_disconnect_complete_event(data);
+      } else if (data[0] == kNumberOfCompletedPacketsEvent) {
+        num_of_compl_packet++;
+      }
+      break;
+    case BtActivityPacketType::ACL_TX_DATA:
+    case BtActivityPacketType::ACL_RX_DATA: {
+      uint16_t conn_handle = data[0] + ((data[1] << 8u) & 0x0F00);
+      acl_data_counter++;
+      if (acl_data_activity_flag == false) {
+        acl_stat.acl_conn_handle = conn_handle;
+        first_acl_data_timepoint_ = std::chrono::steady_clock::now();
+        acl_stat.start_timestamp = Logger::GetLogFormatTimestamp();
+        acl_data_activity_flag = true;
+      }
+      if (activity_type == BtActivityPacketType::ACL_TX_DATA) {
+        acl_tx_data_counter++;
+        acl_stat.total_acl_tx_data_count++;
+      } else {
+        acl_rx_data_counter++;
+        acl_stat.total_acl_rx_data_count++;
+      }
+      // update timer
+      acl_ts.it_value.tv_sec = kBtContiDataTimerExpiredSec;
+      acl_ts.it_value.tv_nsec = kBtContiDataTimerExpiredNs;
+      if (acl_data_timer_created == true && is_logger_on == true) {
+        ret = timer_settime(acl_data_timer, 0, &acl_ts, NULL);
+        if (ret < 0) {
+          LOG(ERROR) << __func__ << ": Cannot arm acl_data_timer!";
+        }
+      }
+    } break;
+    default:
+      LOG(WARNING) << __func__ << ": Unexpected Packet Type: "
+                   << static_cast<uint8_t>(activity_type) << ".";
+      break;
+  }
+
+  // update pkt_timer
+  pkt_ts.it_value.tv_sec = kBtContiDataTimerExpiredSec;
+  pkt_ts.it_value.tv_nsec = kBtContiDataTimerExpiredNs;
+  if (pkt_timer_created == true && is_logger_on == true) {
+    ret = timer_settime(pkt_timer, 0, &pkt_ts, NULL);
+    if (ret < 0) {
+      LOG(ERROR) << __func__ << ": Cannot arm pkt_timer!";
+    }
+  }
+}
+
+void BtActivitiesLogger::UpdateBthalWakelockStat(
+    const bthal_wakelock_stat_t& stat) {
+  LOG(INFO) << __func__
+            << ": bt_power: TxWakeLockStat: " << stat.start_timestamp << " - "
+            << stat.end_timestamp << ", duration: " << stat.duration
+            << ", tx_packet_count: " << stat.tx_packet_count
+            << ", total_tx_packet_count: " << stat.total_tx_packet_count << ".";
+
+  if (bthal_tx_wakelock_recorder_.size() >= kMaxRecordHistory) {
+    bthal_tx_wakelock_recorder_.pop_front();
+  }
+  bthal_tx_wakelock_recorder_.push_back(stat);
+}
+
+void BtActivitiesLogger::UpdateLeAdvStat(const ble_adv_activities_t& stat) {
+  if (stat.duration > kBtContiBleAdvRecordPeriodMs) {
+    if (ble_adv_activities_recorder_.size() >= kMaxRecordHistory) {
+      ble_adv_activities_recorder_.pop_front();
+    }
+    ble_adv_activities_recorder_.push_back(stat);
+  }
+}
+
+void BtActivitiesLogger::UpdateAclDataStat(const acl_data_activities_t& stat) {
+  if (stat.duration > kBtContiAclDataRecordPeriodMs) {
+    if (acl_data_activities_recorder_.size() >= kMaxRecordHistory) {
+      acl_data_activities_recorder_.pop_front();
+    }
+    acl_data_activities_recorder_.push_back(stat);
+  }
+}
+
+void BtActivitiesLogger::UpdateHciPacketStat(const pkt_activities_t& pkt_stat) {
+  // HCI Packets.
+  pkt_activity_ostream_ << pkt_stat.start_timestamp << ", "
+                        << pkt_stat.end_timestamp << ", "
+                        << std::to_string(pkt_stat.duration) << ", "
+                        << std::to_string(pkt_stat.delta) << ", "
+                        << std::to_string(pkt_stat.pkt_count) << ", "
+                        << std::to_string(pkt_stat.total_pkt_count);
+  // BLE ADV Packets.
+  if (pkt_stat.ble_stat.size() > 0) {
+    uint32_t sum_of_adv_duration = 0;
+    uint32_t sum_of_adv_count = 0;
+    std::vector<ble_adv_activities_t> ble_adv(pkt_stat.ble_stat);
+    sum_of_ble_adv_data(ble_adv, &sum_of_adv_duration, &sum_of_adv_count);
+    pkt_activity_ostream_
+        << " , ble_adv:," << ble_adv[0].start_timestamp << ", "
+        << std::to_string(sum_of_adv_duration) << ", "
+        << std::to_string(sum_of_adv_count) << ", "
+        << std::to_string(ble_adv[ble_adv.size() - 1].total_le_adv_count);
+  } else {
+    pkt_activity_ostream_ << ", ble_adv:" << ", --:--:--:--" << ", 0" << ", 0"
+                          << ", 0";
+  }
+  // ACL_Data paxkets.
+  if (pkt_stat.acl_data.size() > 0) {
+    uint32_t sum_of_acl_duration = 0;
+    uint32_t sum_of_acl_count = 0;
+    uint32_t sum_of_acltx_count = 0;
+    uint32_t sum_of_aclrx_count = 0;
+    std::vector<acl_data_activities_t> acl_data(pkt_stat.acl_data);
+    sum_of_acl_data(acl_data, &sum_of_acl_duration, &sum_of_acl_count,
+                    &sum_of_acltx_count, &sum_of_aclrx_count);
+    pkt_activity_ostream_
+        << " , acl_data:," << acl_data[0].start_timestamp << ", "
+        << std::to_string(sum_of_acl_duration) << ", "
+        << acl_data[0].acl_conn_handle << ", "
+        << std::to_string(sum_of_acl_count) << ", "
+        << std::to_string(sum_of_acltx_count) << ", "
+        << std::to_string(sum_of_aclrx_count) << ", "
+        << std::to_string(acl_data[acl_data.size() - 1].total_acl_data_count)
+        << ", "
+        << std::to_string(acl_data[acl_data.size() - 1].total_acl_tx_data_count)
+        << ", "
+        << std::to_string(
+               acl_data[acl_data.size() - 1].total_acl_rx_data_count);
+  } else {
+    pkt_activity_ostream_ << ", acl_data:" << ", --:--:--:--" << ", 0" << ", 0"
+                          << ", 0" << ", 0" << ", 0" << ", 0" << ", 0" << ", 0";
+  }
+  // Command/Event packets
+  pkt_activity_ostream_ << " , cmd/evt:,"
+                        << std::to_string(pkt_stat.hci_command_count) << ", "
+                        << std::to_string(pkt_stat.hci_event_count) << ", "
+                        << std::to_string(pkt_stat.num_cmpl_pkt_evt_count);
+  // End of this record
+  pkt_activity_ostream_ << std::endl;
+
+  if (!pkt_activity_ostream_.flush()) {
+    LOG(ERROR) << __func__ << ": Failed to flush, error: \"" << strerror(errno)
+               << "\".";
+  }
+}
+
+void BtActivitiesLogger::DumpBtActivitiesStatistics(int fd) {
+  std::stringstream ss;
+
+  ss << "*********************************************" << std::endl;
+  ss << "*   Begin Of Bluetooth Activities Reports   *" << std::endl;
+  ss << "*********************************************" << std::endl;
+  ss << "=============================================" << std::endl;
+  ss << " 1. Connected devices Report :" << std::endl;
+  ss << "=============================================" << std::endl;
+  ss << "handle" << ", bt_address" << ", timestamp" << ", rcvd_event"
+     << ", event_status" << std::endl;
+
+  for (auto it = connection_history_.begin(); it != connection_history_.end();
+       it++) {
+    LOG(INFO) << __func__ << ": HCI_ACL: conn_handle: " << std::hex
+              << std::setw(3) << std::setfill('0') << it->connect_handle
+              << ", bda: " << it->bd_addr
+              << ", created_timestamp: " << it->timestamp
+              << ", rcvd_event: " << it->rcvd_event
+              << ", event_status: " << it->status << ".";
+
+    ss << it->connect_handle << ", " << it->bd_addr << ", " << it->timestamp
+       << ", " << it->rcvd_event << ", " << it->status << std::endl;
+  }
+
+  ss << "=============================================" << std::endl;
+  ss << " 2. BtHal Tx Wakelock Report :" << std::endl;
+  ss << "=============================================" << std::endl;
+  auto begin_wakelock = bthal_tx_wakelock_recorder_.begin();
+  auto end_wakelock = bthal_tx_wakelock_recorder_.end();
+
+  ss << "start_timestamp" << ", end_timestamp" << ", during"
+     << ", tx_packet_count" << ", total tx_packet_count" << std::endl;
+  for (auto it = begin_wakelock; it != end_wakelock; ++it) {
+    ss << it->start_timestamp << ", " << it->end_timestamp << ", "
+       << std::to_string(it->duration) << ", "
+       << std::to_string(it->tx_packet_count) << ", "
+       << std::to_string(it->total_tx_packet_count) << std::endl;
+  }
+
+  ss << "=============================================" << std::endl;
+  ss << " 3. BtHal ACL Data Report :" << std::endl;
+  ss << "=============================================" << std::endl;
+  auto begin_acl = acl_data_activities_recorder_.begin();
+  auto end_acl = acl_data_activities_recorder_.end();
+
+  ss << "start_timestamp" << ", end_timestamp" << ", conn_handle" << ", during"
+     << ", acl_data_count" << ", acl_tx_data_count" << ", acl_rx_data_count"
+     << ", total_acl_data_count" << ", total_acl_tx_data_count"
+     << ", total_acl_rx_data_count" << std::endl;
+  for (auto it = begin_acl; it != end_acl; ++it) {
+    ss << it->start_timestamp << ", " << it->end_timestamp << ", "
+       << it->acl_conn_handle << ", " << std::to_string(it->duration) << ", "
+       << std::to_string(it->acl_data_count) << ", "
+       << std::to_string(it->acl_tx_data_count) << ", "
+       << std::to_string(it->acl_rx_data_count) << ", "
+       << std::to_string(it->total_acl_data_count) << ", "
+       << std::to_string(it->total_acl_tx_data_count) << ", "
+       << std::to_string(it->total_acl_rx_data_count) << std::endl;
+  }
+
+  ss << "=============================================" << std::endl;
+  ss << " 4. BLE Advertising Report :" << std::endl;
+  ss << "=============================================" << std::endl;
+  auto begin_entry = ble_adv_activities_recorder_.begin();
+  auto end_entry = ble_adv_activities_recorder_.end();
+
+  ss << "start_timestamp" << ", end_timestamp" << ", duration"
+     << ", le_adv_count" << ", total le_adv_count" << std::endl;
+  for (auto it = begin_entry; it != end_entry; ++it) {
+    ss << it->start_timestamp << ", " << it->end_timestamp << ", "
+       << std::to_string(it->duration) << ", "
+       << std::to_string(it->le_adv_count) << ", "
+       << std::to_string(it->total_le_adv_count) << std::endl;
+  }
+
+  ss << "*********************************************" << std::endl;
+  ss << "*    End Of Bluetooth Activities Reports    *" << std::endl;
+  ss << "*********************************************" << std::endl;
+
+  write(fd, ss.str().c_str(), ss.str().length());
+}
+
+bool BtActivitiesLogger::HasConnectedDevices() {
+  return connected_bda_.size() > 0;
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/debug/bluetooth_bqr.cc b/bluetooth/bluetooth_hal/debug/bluetooth_bqr.cc
new file mode 100644
index 0000000000..777a163f66
--- /dev/null
+++ b/bluetooth/bluetooth_hal/debug/bluetooth_bqr.cc
@@ -0,0 +1,1138 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.bqr"
+
+#include "bluetooth_hal/debug/bluetooth_bqr.h"
+
+#include "android-base/logging.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/util/files.h"
+#include "bluetooth_hal/util/logging.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+using ::android::base::StringPrintf;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::util::Logger;
+
+static uint16_t kSupportedVersion = 256;
+static constexpr int kVendorReportIdOffset = 4;
+
+static constexpr int kVendorQualityEventIdOffset = 4;
+static constexpr int kVendorQualityEventHRModeLength =
+    1 /* vendor_specific_event */ + 1 /* parameter_total_length */ +
+    1 /* sub_event */ + 1 /* quality_report_id */ +
+    1 /* vendor_specific_quality_event_id */ + 2 /* conn_handle */ +
+    132 /* HR mode counter statistics */;
+
+// Bluetooth Bqr Energy Monitor Payload offset
+static constexpr int kBqrEnergyMonitorPacketOffset = 4;
+
+const std::string kBtActivitiesBqrEnergyLogPath =
+    "/data/vendor/bluetooth/bt_activity_bqr_energy.txt";
+
+void AddOctets(size_t bytes, uint64_t value, std::vector<uint8_t>& value_vec);
+
+BtBqrEnergyRecoder bt_energy_instance;
+
+BtBqrEnergyRecoder* BtBqrEnergyRecoder::GetInstacne() {
+  return &bt_energy_instance;
+}
+
+std::string QualityReportIdToString(BqrQualityReportId quality_report_id) {
+  switch (quality_report_id) {
+    case BqrQualityReportId::kMonitorMode:
+      return "Monitoring ";
+    case BqrQualityReportId::kApproachLsto:
+      return "Appro LSTO ";
+    case BqrQualityReportId::kA2dpAudioChoppy:
+      return "A2DP Choppy";
+    case BqrQualityReportId::kScoVoiceChoppy:
+      return "SCO Choppy ";
+    case BqrQualityReportId::kLeAudioChoppy:
+      return "LE Audio Choppy";
+    default:
+      return "Invalid    ";
+  }
+}
+
+std::string PacketTypeToString(BqrPacketType packet_type) {
+  switch (packet_type) {
+    case BqrPacketType::kId:
+      return "ID";
+    case BqrPacketType::kNull:
+      return "NULL";
+    case BqrPacketType::kPoll:
+      return "POLL";
+    case BqrPacketType::kFhs:
+      return "FHS";
+    case BqrPacketType::kHv1:
+      return "HV1";
+    case BqrPacketType::kHv2:
+      return "HV2";
+    case BqrPacketType::kHv3:
+      return "HV3";
+    case BqrPacketType::kDv:
+      return "DV";
+    case BqrPacketType::kEv3:
+      return "EV3";
+    case BqrPacketType::kEv4:
+      return "EV4";
+    case BqrPacketType::kEv5:
+      return "EV5";
+    case BqrPacketType::k2Ev3:
+      return "2EV3";
+    case BqrPacketType::k2Ev5:
+      return "2EV5";
+    case BqrPacketType::k3Ev3:
+      return "3EV3";
+    case BqrPacketType::k3Ev5:
+      return "3EV5";
+    case BqrPacketType::kDm1:
+      return "DM1";
+    case BqrPacketType::kDh1:
+      return "DH1";
+    case BqrPacketType::kDm3:
+      return "DM3";
+    case BqrPacketType::kDh3:
+      return "DH3";
+    case BqrPacketType::kDm5:
+      return "DM5";
+    case BqrPacketType::kDh5:
+      return "DH5";
+    case BqrPacketType::kAux1:
+      return "AUX1";
+    case BqrPacketType::k2Dh1:
+      return "2DH1";
+    case BqrPacketType::k2Dh3:
+      return "2DH3";
+    case BqrPacketType::k2Dh5:
+      return "2DH5";
+    case BqrPacketType::k3Dh1:
+      return "3DH1";
+    case BqrPacketType::k3Dh3:
+      return "3DH3";
+    case BqrPacketType::k3Dh5:
+      return "3DH5";
+    case BqrPacketType::k4Dh1:
+      return "4DH1";
+    case BqrPacketType::k4Dh3:
+      return "4DH3";
+    case BqrPacketType::k4Dh5:
+      return "4DH5";
+    case BqrPacketType::k8Dh1:
+      return "8DH1";
+    case BqrPacketType::k8Dh3:
+      return "8DH3";
+    case BqrPacketType::k8Dh5:
+      return "8DH5";
+    case BqrPacketType::k4Ev3:
+      return "4EV3";
+    case BqrPacketType::k4Ev5:
+      return "4EV5";
+    case BqrPacketType::k8Ev3:
+      return "8EV3";
+    case BqrPacketType::k8Ev5:
+      return "8EV5";
+    case BqrPacketType::kIso:
+      return "ISO";
+    default:
+      return "UnKnown ";
+  }
+}
+
+// Sub-event code = 0x58 [Quality_Report_Id = 0x01 ~ 0x04, and 0x07 ~ 0x08, Link
+// Quality related event]
+void ParseLinkQualityRelatedEvt(const HalPacket& packet) {
+  if (kSupportedVersion < BQR_VERSION_V4) {
+    // Only parse the event containing Vendor Specific parameters
+    if (packet.size() < sizeof(BqrLinkQualityEventV3AndBackward)) {
+      return;
+    }
+
+    const BqrLinkQualityEventV3AndBackward* p_bqr_link_quality_event =
+        reinterpret_cast<const BqrLinkQualityEventV3AndBackward*>(
+            packet.data());
+
+    LOG(WARNING)
+        << __func__ << ": Generic Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", "
+        << PacketTypeToString(static_cast<BqrPacketType>(
+               p_bqr_link_quality_event->packet_types))
+        << StringPrintf(", %s",
+                        ((p_bqr_link_quality_event->connection_role == 0)
+                             ? "Central"
+                             : "Peripheral "))
+        << ", PwLv: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_level)
+        << ", RSSI: " << std::to_string(p_bqr_link_quality_event->rssi)
+        << ", SNR: " << std::to_string(p_bqr_link_quality_event->snr)
+        << ", UnusedCh: "
+        << std::to_string(p_bqr_link_quality_event->unused_afh_channel_count)
+        << ", UnidealCh: "
+        << std::to_string(
+               p_bqr_link_quality_event->afh_select_unideal_channel_count)
+        << ", ReTx: "
+        << std::to_string(p_bqr_link_quality_event->retransmission_count)
+        << ", NoRX: " << std::to_string(p_bqr_link_quality_event->no_rx_count)
+        << ", NAK: " << std::to_string(p_bqr_link_quality_event->nak_count)
+        << ", FlowOff: "
+        << std::to_string(p_bqr_link_quality_event->flow_off_count)
+        << ", OverFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_overflow_bytes)
+        << ", UndFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_underflow_bytes)
+        << ".";
+
+    LOG(WARNING)
+        << __func__ << ": Vendor Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", RSSI_C0: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core0)
+        << ", RSSI_C1: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core1)
+        << ", TxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core0)
+        << ", ReTxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core0)
+        << ", TxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core1)
+        << ", ReTxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core1)
+        << StringPrintf(
+               ", BFTx: 0x%02x, BFReTx: 0x%02x, DivTx: 0x%02x, DivReTx: "
+               "0x%02x.",
+               p_bqr_link_quality_event->bf_state_for_tx,
+               p_bqr_link_quality_event->bf_state_for_retx,
+               p_bqr_link_quality_event->div_state_for_tx,
+               p_bqr_link_quality_event->div_state_for_retx);
+  } else if (kSupportedVersion < BQR_VERSION_V5) {
+    // Only parse the event containing Vendor Specific parameters
+    if (packet.size() < sizeof(BqrLinkQualityEventV4)) {
+      return;
+    }
+
+    const BqrLinkQualityEventV4* p_bqr_link_quality_event =
+        reinterpret_cast<const BqrLinkQualityEventV4*>(packet.data());
+
+    LOG(WARNING)
+        << __func__ << ": Generic Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", "
+        << PacketTypeToString(static_cast<BqrPacketType>(
+               p_bqr_link_quality_event->packet_types))
+        << StringPrintf(", %s",
+                        ((p_bqr_link_quality_event->connection_role == 0)
+                             ? "Central"
+                             : "Peripheral "))
+        << ", PwLv: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_level)
+        << ", RSSI: " << std::to_string(p_bqr_link_quality_event->rssi)
+        << ", SNR: " << std::to_string(p_bqr_link_quality_event->snr)
+        << ", UnusedCh: "
+        << std::to_string(p_bqr_link_quality_event->unused_afh_channel_count)
+        << ", UnidealCh: "
+        << std::to_string(
+               p_bqr_link_quality_event->afh_select_unideal_channel_count)
+        << ", ReTx: "
+        << std::to_string(p_bqr_link_quality_event->retransmission_count)
+        << ", NoRX: " << std::to_string(p_bqr_link_quality_event->no_rx_count)
+        << ", NAK: " << std::to_string(p_bqr_link_quality_event->nak_count)
+        << ", FlowOff: "
+        << std::to_string(p_bqr_link_quality_event->flow_off_count)
+        << ", OverFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_overflow_bytes)
+        << ", UndFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_underflow_bytes)
+        // for BQR v4 iso le audio
+        << ", TxTotal: "
+        << std::to_string(p_bqr_link_quality_event->tx_total_packets)
+        << ", TxUnAcked: "
+        << std::to_string(p_bqr_link_quality_event->tx_unacked_packets)
+        << ", TxFlushed: "
+        << std::to_string(p_bqr_link_quality_event->tx_flushed_packets)
+        << ", TxLastSubEvent: "
+        << std::to_string(p_bqr_link_quality_event->tx_last_subevent_packets)
+        << ", CRCError: "
+        << std::to_string(p_bqr_link_quality_event->crc_error_packets)
+        << ", RxDuplicate: "
+        << std::to_string(p_bqr_link_quality_event->rx_duplicate_packets)
+        << ".";
+
+    LOG(WARNING)
+        << __func__ << ": Vendor Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", RSSI_C0: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core0)
+        << ", RSSI_C1: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core1)
+        << ", TxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core0)
+        << ", ReTxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core0)
+        << ", TxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core1)
+        << ", ReTxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core1)
+        << StringPrintf(
+               ", BFTx: 0x%02x, BFReTx: 0x%02x, DivTx: 0x%02x, DivReTx: 0x%02x",
+               p_bqr_link_quality_event->bf_state_for_tx,
+               p_bqr_link_quality_event->bf_state_for_retx,
+               p_bqr_link_quality_event->div_state_for_tx,
+               p_bqr_link_quality_event->div_state_for_retx)
+        << StringPrintf(", Overall_link_quality: %u",
+                        p_bqr_link_quality_event->overall_link_quality)
+        << StringPrintf(", Tx_link_quality: %u",
+                        p_bqr_link_quality_event->tx_link_quality)
+        << StringPrintf(", Rx_link_quality: %u.",
+                        p_bqr_link_quality_event->rx_link_quality);
+  } else if (kSupportedVersion < BQR_VERSION_V6) {
+    if (packet.size() < sizeof(BqrLinkQualityEventV5)) {
+      return;
+    }
+
+    const BqrLinkQualityEventV5* p_bqr_link_quality_event =
+        reinterpret_cast<const BqrLinkQualityEventV5*>(packet.data());
+
+    LOG(WARNING)
+        << __func__ << ": Generic Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", "
+        << PacketTypeToString(static_cast<BqrPacketType>(
+               p_bqr_link_quality_event->packet_types))
+        << StringPrintf(", %s",
+                        ((p_bqr_link_quality_event->connection_role == 0)
+                             ? "Central"
+                             : "Peripheral "))
+        << ", PwLv: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_level)
+        << ", RSSI: " << std::to_string(p_bqr_link_quality_event->rssi)
+        << ", SNR: " << std::to_string(p_bqr_link_quality_event->snr)
+        << ", UnusedCh: "
+        << std::to_string(p_bqr_link_quality_event->unused_afh_channel_count)
+        << ", UnidealCh: "
+        << std::to_string(
+               p_bqr_link_quality_event->afh_select_unideal_channel_count)
+        << ", ReTx: "
+        << std::to_string(p_bqr_link_quality_event->retransmission_count)
+        << ", NoRX: " << std::to_string(p_bqr_link_quality_event->no_rx_count)
+        << ", NAK: " << std::to_string(p_bqr_link_quality_event->nak_count)
+        << ", FlowOff: "
+        << std::to_string(p_bqr_link_quality_event->flow_off_count)
+        << ", OverFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_overflow_bytes)
+        << ", UndFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_underflow_bytes)
+        << ", failedCount: "
+        << std::to_string(p_bqr_link_quality_event->call_failed_item_count)
+        // for BQR v4 iso le audio
+        << ", TxTotal: "
+        << std::to_string(p_bqr_link_quality_event->tx_total_packets)
+        << ", TxUnAcked: "
+        << std::to_string(p_bqr_link_quality_event->tx_unacked_packets)
+        << ", TxFlushed: "
+        << std::to_string(p_bqr_link_quality_event->tx_flushed_packets)
+        << ", TxLastSubEvent: "
+        << std::to_string(p_bqr_link_quality_event->tx_last_subevent_packets)
+        << ", CRCError: "
+        << std::to_string(p_bqr_link_quality_event->crc_error_packets)
+        << ", RxDuplicate: "
+        << std::to_string(p_bqr_link_quality_event->rx_duplicate_packets)
+        << ".";
+
+    LOG(WARNING)
+        << __func__ << ": Vendor Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", RSSI_C0: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core0)
+        << ", RSSI_C1: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core1)
+        << ", TxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core0)
+        << ", ReTxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core0)
+        << ", TxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core1)
+        << ", ReTxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core1)
+        << StringPrintf(
+               ", BFTx: 0x%02x, BFReTx: 0x%02x, DivTx: 0x%02x, DivReTx: 0x%02x",
+               p_bqr_link_quality_event->bf_state_for_tx,
+               p_bqr_link_quality_event->bf_state_for_retx,
+               p_bqr_link_quality_event->div_state_for_tx,
+               p_bqr_link_quality_event->div_state_for_retx)
+        << StringPrintf(", Overall_link_quality: %u",
+                        p_bqr_link_quality_event->overall_link_quality)
+        << StringPrintf(", Tx_link_quality: %u",
+                        p_bqr_link_quality_event->tx_link_quality)
+        << StringPrintf(", Rx_link_quality: %u.",
+                        p_bqr_link_quality_event->rx_link_quality);
+  } else {  // BQRv6
+    if (packet.size() < sizeof(BqrLinkQualityEventV6)) {
+      return;
+    }
+
+    const BqrLinkQualityEventV6* p_bqr_link_quality_event =
+        reinterpret_cast<const BqrLinkQualityEventV6*>(packet.data());
+
+    LOG(WARNING)
+        << __func__ << ": Generic Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", "
+        << PacketTypeToString(static_cast<BqrPacketType>(
+               p_bqr_link_quality_event->packet_types))
+        << StringPrintf(", %s",
+                        ((p_bqr_link_quality_event->connection_role == 0)
+                             ? "Central"
+                             : "Peripheral "))
+        << ", PwLv: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_level)
+        << ", RSSI: " << std::to_string(p_bqr_link_quality_event->rssi)
+        << ", SNR: " << std::to_string(p_bqr_link_quality_event->snr)
+        << ", UnusedCh: "
+        << std::to_string(p_bqr_link_quality_event->unused_afh_channel_count)
+        << ", UnidealCh: "
+        << std::to_string(
+               p_bqr_link_quality_event->afh_select_unideal_channel_count)
+        << ", ReTx: "
+        << std::to_string(p_bqr_link_quality_event->retransmission_count)
+        << ", NoRX: " << std::to_string(p_bqr_link_quality_event->no_rx_count)
+        << ", NAK: " << std::to_string(p_bqr_link_quality_event->nak_count)
+        << ", FlowOff: "
+        << std::to_string(p_bqr_link_quality_event->flow_off_count)
+        << ", OverFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_overflow_bytes)
+        << ", UndFlow: "
+        << std::to_string(p_bqr_link_quality_event->buffer_underflow_bytes)
+        << ", failedCount: "
+        << std::to_string(p_bqr_link_quality_event->call_failed_item_count)
+        // for BQR v4 iso le audio
+        << ", TxTotal: "
+        << std::to_string(p_bqr_link_quality_event->tx_total_packets)
+        << ", TxUnAcked: "
+        << std::to_string(p_bqr_link_quality_event->tx_unacked_packets)
+        << ", TxFlushed: "
+        << std::to_string(p_bqr_link_quality_event->tx_flushed_packets)
+        << ", TxLastSubEvent: "
+        << std::to_string(p_bqr_link_quality_event->tx_last_subevent_packets)
+        << ", CRCError: "
+        << std::to_string(p_bqr_link_quality_event->crc_error_packets)
+        << ", RxDuplicate: "
+        << std::to_string(p_bqr_link_quality_event->rx_duplicate_packets)
+        << ", RxUnreceived: "
+        << std::to_string(p_bqr_link_quality_event->rx_unreceived_packets)
+        << ", coex_info_mask: "
+        << std::to_string(p_bqr_link_quality_event->coex_info_mask) << ".";
+
+    LOG(WARNING)
+        << __func__ << ": Vendor Parameters: "
+        << QualityReportIdToString(static_cast<BqrQualityReportId>(
+               p_bqr_link_quality_event->quality_report_id))
+        << StringPrintf(", Handle: 0x%04x",
+                        p_bqr_link_quality_event->connection_handle)
+        << ", RSSI_C0: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core0)
+        << ", RSSI_C1: "
+        << std::to_string(p_bqr_link_quality_event->rssi_for_core1)
+        << ", TxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core0)
+        << ", ReTxPw_C0: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core0)
+        << ", TxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core1)
+        << ", ReTxPw_C1: "
+        << std::to_string(p_bqr_link_quality_event->retx_power_for_core1)
+        << StringPrintf(
+               ", BFTx: 0x%02x, BFReTx: 0x%02x, DivTx: 0x%02x, DivReTx: 0x%02x",
+               p_bqr_link_quality_event->bf_state_for_tx,
+               p_bqr_link_quality_event->bf_state_for_retx,
+               p_bqr_link_quality_event->div_state_for_tx,
+               p_bqr_link_quality_event->div_state_for_retx)
+        << StringPrintf(", Overall_link_quality: %u",
+                        p_bqr_link_quality_event->overall_link_quality)
+        << StringPrintf(", Tx_link_quality: %u",
+                        p_bqr_link_quality_event->tx_link_quality)
+        << StringPrintf(", Rx_link_quality: %u",
+                        p_bqr_link_quality_event->rx_link_quality)
+        << ", TotalTx_pkts_c0: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core0)
+        << ", TotalTx_pkts_c1: "
+        << std::to_string(p_bqr_link_quality_event->tx_power_for_core1)
+        << ", TotalTx_pkts_beamforming: "
+        << std::to_string(p_bqr_link_quality_event->total_tx_pkts_beamforming)
+        << ".";
+  }
+}
+
+void updateControllerCapability(const HalPacket& packet) {
+  if (packet.size() < 16) {
+    return;
+  }
+  kSupportedVersion = (packet[15] << 8) + packet[14];
+  LOG(INFO) << __func__ << ": Vendor capability supported version: "
+            << static_cast<uint16_t>(kSupportedVersion) << ".";
+}
+
+void ParseVendorSpecificQualityEvt(const HalPacket& packet) {
+  if (packet.size() <= kVendorQualityEventIdOffset) {
+    LOG(ERROR) << __func__ << ": Invalid length of BQR vendor specific event!";
+    return;
+  }
+  auto vendor_quality_event_id =
+      static_cast<VendorReportId>(packet[kVendorQualityEventIdOffset]);
+  switch (vendor_quality_event_id) {
+    case VendorReportId::kHrMode:
+      ParseHRModeStatisticLog(packet);
+      break;
+    default:
+      LOG(ERROR) << __func__ << ": Invalid vendor specific quality id";
+  }
+}
+
+void ParseHRModeStatisticLog(const HalPacket& packet) {
+  if (packet.size() < kVendorQualityEventHRModeLength) {
+    LOG(ERROR) << __func__
+               << ": Invalid length of HR Mode statistic specific event!";
+    return;
+  }
+  const BqrVendorSpecificEventHRMode* p_bqr_hr_evt =
+      reinterpret_cast<const BqrVendorSpecificEventHRMode*>(packet.data());
+
+  LOG(WARNING) << __func__
+               << ": Vendor Specific quality event: HR Mode statistic"
+               << StringPrintf(", Handle: 0x%04x", p_bqr_hr_evt->conn_handle)
+               << StringPrintf(", rx_null_cnt: %d", p_bqr_hr_evt->rx_null_cnt)
+               << StringPrintf(", rx_poll_cnt: %d", p_bqr_hr_evt->rx_poll_cnt)
+               << StringPrintf(", rx_dm1_cnt: %d", p_bqr_hr_evt->rx_dm1_cnt)
+
+               << StringPrintf(", tx_null_cnt: %d", p_bqr_hr_evt->tx_null_cnt)
+               << StringPrintf(", tx_poll_cnt: %d", p_bqr_hr_evt->tx_poll_cnt)
+               << StringPrintf(", tx_dm1_cnt: %d", p_bqr_hr_evt->tx_dm1_cnt)
+
+               << StringPrintf(", rx_hr_2dh1: %d", p_bqr_hr_evt->rx_hr_2dh1)
+               << StringPrintf(", rx_hr_4dh1: %d", p_bqr_hr_evt->rx_hr_4dh1)
+               << StringPrintf(", rx_hr_8dh1: %d", p_bqr_hr_evt->rx_hr_8dh1)
+               << StringPrintf(", rx_hr_2dh3: %d", p_bqr_hr_evt->rx_hr_2dh3)
+               << StringPrintf(", rx_hr_4dh3: %d", p_bqr_hr_evt->rx_hr_4dh3)
+               << StringPrintf(", rx_hr_8dh3: %d", p_bqr_hr_evt->rx_hr_8dh3)
+               << StringPrintf(", rx_hr_2dh5: %d", p_bqr_hr_evt->rx_hr_2dh5)
+               << StringPrintf(", rx_hr_4dh5: %d", p_bqr_hr_evt->rx_hr_4dh5)
+               << StringPrintf(", rx_hr_8dh5: %d", p_bqr_hr_evt->rx_hr_8dh5)
+
+               << StringPrintf(", tx_hr_2dh1: %d", p_bqr_hr_evt->tx_hr_2dh1)
+               << StringPrintf(", tx_hr_4dh1: %d", p_bqr_hr_evt->tx_hr_4dh1)
+               << StringPrintf(", tx_hr_8dh1: %d", p_bqr_hr_evt->tx_hr_8dh1)
+               << StringPrintf(", tx_hr_2dh3: %d", p_bqr_hr_evt->tx_hr_2dh3)
+               << StringPrintf(", tx_hr_4dh3: %d", p_bqr_hr_evt->tx_hr_4dh3)
+               << StringPrintf(", tx_hr_8dh3: %d", p_bqr_hr_evt->tx_hr_8dh3)
+               << StringPrintf(", tx_hr_2dh5: %d", p_bqr_hr_evt->tx_hr_2dh5)
+               << StringPrintf(", tx_hr_4dh5: %d", p_bqr_hr_evt->tx_hr_4dh5)
+               << StringPrintf(", tx_hr_8dh5: %d.", p_bqr_hr_evt->tx_hr_8dh5);
+}
+
+void ParseVendorSpecificTraceEvt(const HalPacket& packet) {
+  if (packet.size() <= kVendorReportIdOffset) {
+    LOG(ERROR) << __func__ << ": Invalid length of BQR vendor specific event!";
+    return;
+  }
+
+  auto vendor_report_id =
+      static_cast<VendorReportId>(packet[kVendorReportIdOffset]);
+  switch (vendor_report_id) {
+    case VendorReportId::kA2dpLatencyMeasurement:
+      ParseA2DPLatencyMeasurement(packet);
+      break;
+    default:
+      LOG(ERROR) << __func__ << ": Invalid vendor report id.";
+  }
+}
+
+void ParseA2DPLatencyMeasurement(const HalPacket& packet) {
+  const BqrVsteA2dpLatencyMeasurement* p_bqr_a2dp_latency_evt =
+      reinterpret_cast<const BqrVsteA2dpLatencyMeasurement*>(packet.data());
+
+  LOG(WARNING) << __func__
+               << ": Vendor Specific Trace Event: A2DP Latency Measurement"
+               << StringPrintf(", Handle: 0x%04x",
+                               p_bqr_a2dp_latency_evt->conn_handle)
+               << StringPrintf(", Num_Packets_Logged: %d, Base_Timestamp: %d.",
+                               p_bqr_a2dp_latency_evt->num_packets_logged,
+                               p_bqr_a2dp_latency_evt->base_timestamp);
+
+  if (p_bqr_a2dp_latency_evt->num_packets_logged == 0) return;
+
+  const A2DPLatency* a2dp_latencies =
+      &(p_bqr_a2dp_latency_evt->a2dp_latencies[0]);
+  uint8_t num_packets = p_bqr_a2dp_latency_evt->num_packets_logged;
+  double first_transmit;
+  double first_ack;
+  double final_transmit;
+  double first_transmit_avg = 0;
+  double first_ack_avg = 0;
+  double final_transmit_avg = 0;
+
+  for (uint8_t i = 0; i < num_packets; ++i) {
+    // 1 bt slot = 0.625 ms
+    first_transmit =
+        (double)a2dp_latencies[i].first_packet_transmit_delay * 0.625;
+    first_ack = (double)a2dp_latencies[i].first_packet_ack_delay * 0.625;
+    final_transmit =
+        (double)a2dp_latencies[i].final_packet_transmit_delay * 0.625;
+
+    LOG(WARNING) << __func__
+                 << StringPrintf(
+                        ": Packet[%d/%d], Packet_Entry_Time_Offset: %3.3f,"
+                        "First_Packet_Transmit_Delay: %3.3f, "
+                        "First_Packet_Ack_Delay: %3.3f,"
+                        "Final_Packet_Transmit_Delay: %3.3f.",
+                        i + 1, num_packets,
+                        (double)a2dp_latencies[i].packet_entry_time_offset *
+                            0.625,
+                        first_transmit, first_ack, final_transmit);
+
+    first_transmit_avg += first_transmit;
+    first_ack_avg += first_ack;
+    final_transmit_avg += final_transmit;
+  }
+
+  first_transmit_avg /= num_packets;
+  first_ack_avg /= num_packets;
+  final_transmit_avg /= num_packets;
+  LOG(WARNING)
+      << __func__
+      << StringPrintf(
+             ": Average, Packet_num: %d, First_Packet_Transmit_Delay_avg: "
+             "%3.3f, First_Packet_Ack_Delay_avg: %3.3f, "
+             "Final_Packet_Transmit_Delay_avg: %3.3f.",
+             num_packets, first_transmit_avg, first_ack_avg,
+             final_transmit_avg);
+}
+
+// Sub-event code = 0x58 [Quality_Report_Id = 0x09~0x0A, Advance RF Stats event]
+void ParseAdvanceRFStatsEvt(const HalPacket& packet) {
+  if (packet.size() < sizeof(BqrAdvanceRFStatsEvent)) {
+    LOG(WARNING) << __func__ << ": Packet size() error.";
+    return;
+  }
+
+  const BqrAdvanceRFStatsEvent* p_bqr_rf_stats_event =
+      reinterpret_cast<const BqrAdvanceRFStatsEvent*>(packet.data());
+
+  if (p_bqr_rf_stats_event->ext_info == BQR_RFSTATS_EXT_INFO_V6) {
+    LOG(WARNING) << __func__ << ": Advance RF Stats: Time Period:"
+                 << std::to_string(p_bqr_rf_stats_event->tm_period) << " ms"
+                 << ", Extension id: "
+                 << std::to_string(p_bqr_rf_stats_event->ext_info)
+                 << ", TW_Pw_iPA_BF: "
+                 << std::to_string(p_bqr_rf_stats_event->tx_pw_ipa_bf)
+                 << ", TW_Pw_ePA_BF: "
+                 << std::to_string(p_bqr_rf_stats_event->tx_pw_epa_bf)
+                 << ", TW_Pw_iPA_Div: "
+                 << std::to_string(p_bqr_rf_stats_event->tx_pw_ipa_div)
+                 << ", TW_Pw_ePA_Div: "
+                 << std::to_string(p_bqr_rf_stats_event->tx_pw_epa_div)
+                 << ", RSSI_Chain_>-50: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_50)
+                 << ", RSSI_Chain_-50_-55: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_50_55)
+                 << ", RSSI_Chain_-55_-60: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_55_60)
+                 << ", RSSI_Chain_-60_-65: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_60_65)
+                 << ", RSSI_Chain_-65_-70: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_65_70)
+                 << ", RSSI_Chain_-70_-75: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_70_75)
+                 << ", RSSI_Chain_-75_-80: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_75_80)
+                 << ", RSSI_Chain_-80_-85: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_80_85)
+                 << ", RSSI_Chain_-85_-90: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_85_90)
+                 << ", RSSI_Chain_<-90: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_ch_90)
+                 << ", RSSI_Delta_<2: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_delta_2_down)
+                 << ", RSSI_Delta_2_5: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_delta_2_5)
+                 << ", RSSI_Delta_5_8: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_delta_5_8)
+                 << ", RSSI_Delta_8_11: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_delta_8_11)
+                 << ", RSSI_Delta_>11: "
+                 << std::to_string(p_bqr_rf_stats_event->rssi_delta_11_up)
+                 << ".";
+  } else {
+    LOG(WARNING) << __func__
+                 << ": Advance RF Stats: Invalid Extension Info ID.";
+  }
+}
+
+inline uint8_t stream_to_int8(const HalPacket& event, uint8_t* offset_ptr) {
+  uint8_t offset = *offset_ptr;
+  uint8_t number = 0;
+  number = ((uint8_t)(event[offset]));
+  *offset_ptr += 1;
+  return number;
+}
+
+inline uint16_t stream_to_int16(const HalPacket& event, uint8_t* offset_ptr) {
+  uint8_t offset = *offset_ptr;
+  uint16_t number = 0;
+  number = ((uint16_t)(event[offset])) + ((uint16_t)(event[offset + 1] << 8));
+  *offset_ptr += 2;
+  return number;
+}
+
+inline uint32_t stream_to_int32(const HalPacket& event, uint8_t* offset_ptr) {
+  uint8_t offset = *offset_ptr;
+  uint32_t number = 0;
+  number = ((uint16_t)(event[offset])) + ((uint16_t)(event[offset + 1] << 8)) +
+           ((uint16_t)(event[offset + 2] << 16)) +
+           ((uint16_t)(event[offset + 3] << 24));
+  *offset_ptr += 4;
+  return number;
+}
+
+void BtBqrEnergyRecoder::StartLogging() {
+  LOG(INFO) << __func__;
+  if (HalConfigLoader::GetLoader().IsEnergyControllerLoggingSupported()) {
+    bt_activities_bqr_energy_log_path_ =
+        std::move(kBtActivitiesBqrEnergyLogPath);
+    open_new_energy_log_file();
+  }
+}
+
+void BtBqrEnergyRecoder::StopLogging() {
+  LOG(INFO) << __func__;
+  if (HalConfigLoader::GetLoader().IsEnergyControllerLoggingSupported()) {
+    LOG(DEBUG) << __func__ << ": Closing bqr energy log data at "
+               << bt_activities_bqr_energy_log_path_ << ".";
+    os::CloseLogFileStream(bqr_energy_activity_ostream_);
+  }
+}
+
+void BtBqrEnergyRecoder::open_new_energy_log_file() {
+  LOG(INFO) << __func__;
+  os::CloseLogFileStream(bqr_energy_activity_ostream_);
+  os::CreateLogFile(bt_activities_bqr_energy_log_path_,
+                    bqr_energy_activity_ostream_);
+  bqr_energy_activity_ostream_
+      << "TimeStamp" << ", Batt_Per" << ", Avg_Cur_Pwr" << ", BEr_Tx_Plv"
+      << ", Le_Tx_Plv" << ", Idle_Tm" << ", Act_Tm" << ", Act_Cnt"
+      << ", BEr_Tx_Tm" << ", BEr_Tx_Cnt" << ", BEr_Rx_Tm" << ", BEr_Rx_Cnt"
+      << ", Le_Tx_Tm" << ", Le_Tx_Cnt" << ", Le_Rx_Tm" << ", Le_Rx_Cnt"
+      << std::endl;
+
+  if (!bqr_energy_activity_ostream_.flush()) {
+    LOG(ERROR) << __func__ << ": Failed to flush, error: \"" << strerror(errno)
+               << "\".";
+  }
+}
+
+void BtBqrEnergyRecoder::update_bqr_energy_report(bt_energy_sector_t& stat) {
+  if (!HalConfigLoader::GetLoader().IsEnergyControllerLoggingSupported()) {
+    return;
+  }
+
+  LOG(INFO) << __func__
+            << ": Avg_Cur_Pwr: " << stat.entries.average_current_consumption
+            << ", BEr_Tx_Plv: " << stat.entries.br_edr_tx_average_power_level
+            << " dBm"
+            << ", Le_Tx_Plv: " << stat.entries.le_tx_average_power_level << ".";
+
+  packet_counter_++;
+  if (packet_counter_ > kMaxPacketsPerFile_) {
+    LOG(INFO) << __func__
+              << ": Exceed kMaxPacketsPerFile_, open another new log file.";
+
+    open_new_energy_log_file();
+    packet_counter_ = 0;
+  }
+  bqr_energy_activity_ostream_
+      << stat.timestamp << ", " << batt_level_.c_str() << ", "
+      << stat.entries.average_current_consumption << ", "
+      << std::to_string(stat.entries.br_edr_tx_average_power_level) << ", "
+      << std::to_string(stat.entries.le_tx_average_power_level) << ", "
+      << std::to_string(stat.entries.idle_total_time) << ", "
+      << std::to_string(stat.entries.active_total_time) << ", "
+      << std::to_string(stat.entries.active_state_enter_count) << ", "
+      << std::to_string(stat.entries.br_edr_tx_total_time) << ", "
+      << std::to_string(stat.entries.br_edr_tx_state_enter_count) << ", "
+      << std::to_string(stat.entries.br_edr_rx_total_time) << ", "
+      << std::to_string(stat.entries.br_edr_rx_state_enter_count) << ", "
+      << std::to_string(stat.entries.le_tx_total_time) << ", "
+      << std::to_string(stat.entries.le_tx_state_enter_count) << ", "
+      << std::to_string(stat.entries.le_rx_total_time) << ", "
+      << std::to_string(stat.entries.le_rx_state_enter_count) << std::endl;
+
+  if (!bqr_energy_activity_ostream_.flush()) {
+    LOG(ERROR) << __func__ << ": Failed to flush, error: \"" << strerror(errno)
+               << "\".";
+  }
+}
+
+void BtBqrEnergyRecoder::update_bqr_energy_report(bt_energy_sectorv6_t& stat) {
+  if (!HalConfigLoader::GetLoader().IsEnergyControllerLoggingSupported()) {
+    return;
+  }
+  LOG(INFO) << __func__
+            << ": Avg_Cur_Pwr: " << stat.entries.average_current_consumption
+            << ", BEr_Tx_Plv: " << stat.entries.br_edr_tx_average_power_level
+            << " dBm"
+            << ", Le_Tx_Plv: " << stat.entries.le_tx_average_power_level << ".";
+
+  packet_counter_++;
+  if (packet_counter_ > kMaxPacketsPerFile_) {
+    LOG(INFO) << __func__
+              << ": Exceed kMaxPacketsPerFile_, open another new log file.";
+    open_new_energy_log_file();
+    packet_counter_ = 0;
+  }
+  bqr_energy_activity_ostream_
+      << stat.timestamp << ", " << batt_level_.c_str() << ", "
+      << stat.entries.average_current_consumption << ", "
+      << std::to_string(stat.entries.br_edr_tx_average_power_level) << ", "
+      << std::to_string(stat.entries.le_tx_average_power_level) << ", "
+      << std::to_string(stat.entries.idle_total_time) << ", "
+      << std::to_string(stat.entries.active_total_time) << ", "
+      << std::to_string(stat.entries.active_state_enter_count) << ", "
+      << std::to_string(stat.entries.br_edr_tx_total_time) << ", "
+      << std::to_string(stat.entries.br_edr_tx_state_enter_count) << ", "
+      << std::to_string(stat.entries.br_edr_rx_total_time) << ", "
+      << std::to_string(stat.entries.br_edr_rx_state_enter_count) << ", "
+      << std::to_string(stat.entries.le_tx_total_time) << ", "
+      << std::to_string(stat.entries.le_tx_state_enter_count) << ", "
+      << std::to_string(stat.entries.le_rx_total_time) << ", "
+      << std::to_string(stat.entries.le_rx_state_enter_count) << ", "
+      << std::to_string(stat.entries.report_time_duration) << ", "
+      << std::to_string(stat.entries.rx_active_one_chain_time) << ", "
+      << std::to_string(stat.entries.rx_active_two_chain_time) << ", "
+      << std::to_string(stat.entries.tx_ipa_active_one_chain_time) << ", "
+      << std::to_string(stat.entries.tx_ipa_active_two_chain_time) << ", "
+      << std::to_string(stat.entries.tx_xpa_active_one_chain_time) << ", "
+      << std::to_string(stat.entries.tx_xpa_active_two_chain_time) << std::endl;
+
+  if (!bqr_energy_activity_ostream_.flush()) {
+    LOG(ERROR) << __func__ << ": Failed to flush, error: \"" << strerror(errno)
+               << "\".";
+  }
+}
+
+void BtBqrEnergyRecoder::ParseBqrEnergyMonitorEvt(
+    const HalPacket& energy_event) {
+  if (kSupportedVersion < BQR_VERSION_V6) {
+    if (energy_event.size() < sizeof(BqrEnergyMonitoringEvent)) {
+      return;
+    }
+
+    bt_energy_sector_t bqr_energy_sector;
+    BqrEnergyMonitoringEvent bqr_energy_packet;
+    uint8_t offset = kBqrEnergyMonitorPacketOffset;
+
+    std::string engery_timestamp = Logger::GetLogFormatTimestamp();
+
+    // Parse Energy Monitor Event
+    bqr_energy_packet.average_current_consumption =
+        stream_to_int16(energy_event, &offset);
+    bqr_energy_packet.idle_total_time = stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.idle_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.active_total_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.active_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+
+    bqr_energy_packet.br_edr_tx_total_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.br_edr_tx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.br_edr_tx_average_power_level =
+        stream_to_int8(energy_event, &offset);
+    bqr_energy_packet.br_edr_rx_total_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.br_edr_rx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+
+    bqr_energy_packet.le_tx_total_time = stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.le_tx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.le_tx_average_power_level =
+        stream_to_int8(energy_event, &offset);
+    bqr_energy_packet.le_rx_total_time = stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.le_rx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+
+    // Update bqr_energy_sector
+    bqr_energy_sector.timestamp = engery_timestamp;
+    bqr_energy_sector.entries = bqr_energy_packet;
+    LOG(INFO) << __func__ << ": Batt_Per: " << batt_level_ << ", Avg_Cur_Pwr: "
+              << bqr_energy_packet.average_current_consumption << " mA"
+              << ", BEr_Tx_Plv: "
+              << bqr_energy_packet.br_edr_tx_average_power_level << " dBm"
+              << ", Le_Tx_Plv: " << bqr_energy_packet.le_tx_average_power_level
+              << " dBm"
+              << ", Idle_Tm: " << bqr_energy_packet.idle_total_time << " ms"
+              << ", Act_Tm: " << bqr_energy_packet.active_total_time << " ms"
+              << ", BEr_Tx_Tm: " << bqr_energy_packet.br_edr_tx_total_time
+              << " ms"
+              << ", BEr_Rx_Tm: " << bqr_energy_packet.br_edr_rx_total_time
+              << " ms"
+              << ", Le_Tx_Tm: " << bqr_energy_packet.le_tx_total_time << " ms"
+              << ", Le_Rx_Tm: " << bqr_energy_packet.le_rx_total_time << " ms.";
+
+    update_bqr_energy_report(bqr_energy_sector);
+  } else {  // BQRv6
+    if (energy_event.size() < sizeof(BqrEnergyMonitoringEventV6)) {
+      return;
+    }
+
+    bt_energy_sectorv6_t bqr_energy_sector;
+    BqrEnergyMonitoringEventV6 bqr_energy_packet;
+    uint8_t offset = kBqrEnergyMonitorPacketOffset;
+
+    std::string engery_timestamp = Logger::GetLogFormatTimestamp();
+
+    bqr_energy_packet.average_current_consumption =
+        stream_to_int16(energy_event, &offset);
+    bqr_energy_packet.idle_total_time = stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.idle_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.active_total_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.active_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+
+    bqr_energy_packet.br_edr_tx_total_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.br_edr_tx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.br_edr_tx_average_power_level =
+        stream_to_int8(energy_event, &offset);
+    bqr_energy_packet.br_edr_rx_total_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.br_edr_rx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+
+    bqr_energy_packet.le_tx_total_time = stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.le_tx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.le_tx_average_power_level =
+        stream_to_int8(energy_event, &offset);
+    bqr_energy_packet.le_rx_total_time = stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.le_rx_state_enter_count =
+        stream_to_int32(energy_event, &offset);
+
+    bqr_energy_packet.report_time_duration =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.rx_active_one_chain_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.rx_active_two_chain_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.tx_ipa_active_one_chain_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.tx_ipa_active_two_chain_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.tx_xpa_active_one_chain_time =
+        stream_to_int32(energy_event, &offset);
+    bqr_energy_packet.tx_xpa_active_two_chain_time =
+        stream_to_int32(energy_event, &offset);
+
+    // Update bqr_energy_sector
+    bqr_energy_sector.timestamp = engery_timestamp;
+    bqr_energy_sector.entries = bqr_energy_packet;
+
+    LOG(INFO)
+        << __func__ << ": Batt_Per: " << batt_level_
+        << ", Avg_Cur_Pwr: " << bqr_energy_packet.average_current_consumption
+        << " mA"
+        << ", BEr_Tx_Plv: " << bqr_energy_packet.br_edr_tx_average_power_level
+        << " dBm"
+        << ", Le_Tx_Plv: " << bqr_energy_packet.le_tx_average_power_level
+        << " dBm"
+        << ", Idle_Tm: " << bqr_energy_packet.idle_total_time << " ms"
+        << ", Act_Tm: " << bqr_energy_packet.active_total_time << " ms"
+        << ", BEr_Tx_Tm: " << bqr_energy_packet.br_edr_tx_total_time << " ms"
+        << ", BEr_Rx_Tm: " << bqr_energy_packet.br_edr_rx_total_time << " ms"
+        << ", Le_Tx_Tm: " << bqr_energy_packet.le_tx_total_time << " ms"
+        << ", Le_Rx_Tm: " << bqr_energy_packet.le_rx_total_time << " ms"
+        << ", total_Tm: " << bqr_energy_packet.report_time_duration << " ms"
+        << ", Rx_1Ch_Tm: " << bqr_energy_packet.rx_active_one_chain_time
+        << " ms"
+        << ", Rx_2Ch_Tm: " << bqr_energy_packet.rx_active_two_chain_time
+        << " ms"
+        << ", Tx_iPA_1Ch_Tm: " << bqr_energy_packet.tx_ipa_active_one_chain_time
+        << " ms"
+        << ", Tx_iPA_2Ch_Tm: " << bqr_energy_packet.tx_ipa_active_two_chain_time
+        << " ms"
+        << ", Tx_ePA_1Ch_Tm: " << bqr_energy_packet.tx_xpa_active_one_chain_time
+        << " ms"
+        << ", Tx_ePA_2Ch_Tm: " << bqr_energy_packet.tx_xpa_active_two_chain_time
+        << " ms.";
+
+    update_bqr_energy_report(bqr_energy_sector);
+  }
+}
+
+// Sub-event code = 0x58 [Quality_Report_Id = 0x0B ~ 0x0C Controller Health
+// Monitoring Event]
+void ParseControllerHealthMonitorEvt(const HalPacket& health_monitor_event) {
+  // Health monitor only supported in bqr_v7 and make sure the size is as
+  // expected.
+  if (kSupportedVersion < BQR_VERSION_V7) {
+    LOG(INFO) << __func__ << ": Error: Vdr BQR supp ver(" << kSupportedVersion
+              << ") not as expect ver(" << BQR_VERSION_V7 << ")!!";
+    return;
+  }
+  if (health_monitor_event.size() < sizeof(BqrControllerHealthMonitorEvent)) {
+    LOG(INFO) << __func__ << ": Error: received evt size("
+              << health_monitor_event.size() << ") not as expected size("
+              << sizeof(BqrControllerHealthMonitorEvent) << ")!!";
+    return;
+  }
+  static constexpr int kBqrHealthMonitorPacketOffset = 4;
+  BqrControllerHealthMonitorEvent bqr_health_monitor;
+  uint8_t offset = kBqrHealthMonitorPacketOffset;
+  // Parse Controller Health Monitor Event
+  bqr_health_monitor.packet_count_host_to_controller =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.packet_count_controller_to_host =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.last_packet_length_controller_to_host =
+      stream_to_int16(health_monitor_event, &offset);
+  bqr_health_monitor.last_packet_length_host_to_controller =
+      stream_to_int16(health_monitor_event, &offset);
+  bqr_health_monitor.total_bt_wake_count =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.total_host_wake_count =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.last_bt_wake_timestamp =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.last_host_wake_timestamp =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.reset_timestamp =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.current_timestamp =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.is_watchdog_timer_about_to_expire =
+      stream_to_int32(health_monitor_event, &offset);
+  bqr_health_monitor.coex_status_mask =
+      stream_to_int16(health_monitor_event, &offset);
+  bqr_health_monitor.total_links_br_edr_le_active =
+      stream_to_int8(health_monitor_event, &offset);
+  bqr_health_monitor.total_links_br_edr_sniff =
+      stream_to_int8(health_monitor_event, &offset);
+  bqr_health_monitor.total_links_cis =
+      stream_to_int8(health_monitor_event, &offset);
+  bqr_health_monitor.is_sco_active =
+      stream_to_int8(health_monitor_event, &offset);
+
+  LOG(INFO) << __func__ << ": pk_ct_to_ctrl: "
+            << bqr_health_monitor.packet_count_host_to_controller
+            << ", pk_ct_to_host: "
+            << bqr_health_monitor.packet_count_controller_to_host
+            << ", last_pk_len_to_host: "
+            << bqr_health_monitor.last_packet_length_controller_to_host
+            << ", last_pk_len_to_ctrl: "
+            << bqr_health_monitor.last_packet_length_host_to_controller
+            << ", bt_wake_cnt: " << bqr_health_monitor.total_bt_wake_count
+            << ", host_wake_cnt: " << bqr_health_monitor.total_host_wake_count
+            << ", reset_ts: " << bqr_health_monitor.reset_timestamp
+            << ", cur_ts: " << bqr_health_monitor.current_timestamp
+            << ", last_bt_wake_ts: "
+            << bqr_health_monitor.last_bt_wake_timestamp
+            << ", last_host_wake_ts: "
+            << bqr_health_monitor.last_host_wake_timestamp << ", watchdog_exp: "
+            << bqr_health_monitor.is_watchdog_timer_about_to_expire
+            << ", coex_mask: " << bqr_health_monitor.coex_status_mask
+            << ", links_br_edr_le: "
+            << bqr_health_monitor.total_links_br_edr_le_active
+            << ", links_br_edr_sniff: "
+            << bqr_health_monitor.total_links_br_edr_sniff
+            << ", links_cis: " << bqr_health_monitor.total_links_cis
+            << ", sco_active: " << bqr_health_monitor.is_sco_active << ".";
+}
+
+std::vector<uint8_t> GetBqrV6Cmd(BqrCmdScenario type) {
+  BqrV6CmdConfiguration bqr_config = {};
+  switch (type) {
+    case BqrCmdScenario::ENABLE_BQR_BT_OFF:
+      bqr_config.report_action = BqrReportAction::kAdd;
+      // Enable Root inflammation event
+      bqr_config.quality_event_mask = 0x10;
+      bqr_config.minimum_report_interval_ms = 0x00;
+      bqr_config.vnd_quality_mask = 0x00;
+      bqr_config.vnd_trace_mask = 0x00;
+      bqr_config.report_interval_multiple = 0x00;
+      break;
+    case BqrCmdScenario::DISABLE_BQR:
+    default:
+      bqr_config.report_action = BqrReportAction::kClear;
+      bqr_config.quality_event_mask = 0x00;
+      bqr_config.minimum_report_interval_ms = 0x00;
+      bqr_config.vnd_quality_mask = 0x00;
+      bqr_config.vnd_trace_mask = 0x00;
+      bqr_config.report_interval_multiple = 0x00;
+  }
+
+  std::vector<uint8_t> bqr_byte_vec = {};
+
+  AddOctets(1, static_cast<uint64_t>(bqr_config.report_action), bqr_byte_vec);
+  AddOctets(4, bqr_config.quality_event_mask, bqr_byte_vec);
+  AddOctets(2, bqr_config.minimum_report_interval_ms, bqr_byte_vec);
+  AddOctets(4, bqr_config.vnd_quality_mask, bqr_byte_vec);
+  AddOctets(4, bqr_config.vnd_trace_mask, bqr_byte_vec);
+  AddOctets(4, bqr_config.report_interval_multiple, bqr_byte_vec);
+
+  return bqr_byte_vec;
+}
+
+void AddOctets(size_t bytes, uint64_t value, std::vector<uint8_t>& value_vec) {
+  for (size_t i = 0; i < bytes; ++i) {
+    value_vec.push_back(value & 0xff);
+    value >>= 8;
+  }
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/debug/debug_central.cc b/bluetooth/bluetooth_hal/debug/debug_central.cc
new file mode 100644
index 0000000000..ee554f7e4b
--- /dev/null
+++ b/bluetooth/bluetooth_hal/debug/debug_central.cc
@@ -0,0 +1,1088 @@
+/*
+ * Copyright 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.debug_central"
+
+#include "bluetooth_hal/debug/debug_central.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <fstream>
+#include <iomanip>
+#include <map>
+#include <mutex>
+#include <sstream>
+#include <string>
+
+#include "android-base/logging.h"
+#include "android-base/properties.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/debug/bluetooth_activity.h"
+#include "bluetooth_hal/debug/bluetooth_bqr.h"
+#include "bluetooth_hal/extensions/thread/thread_handler.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "bluetooth_hal/util/logging.h"
+
+namespace {
+
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::thread::ThreadHandler;
+using ::bluetooth_hal::transport::TransportInterface;
+using ::bluetooth_hal::transport::TransportType;
+using ::bluetooth_hal::util::Logger;
+
+static constexpr int kVseSubEventCodeOffset = 2;
+static constexpr int kBqrReportIdOffset = 3;
+static constexpr int kBqrInflamedErrorCode = 4;
+static constexpr int kBqrInflamedVendorErrCode = 5;
+static constexpr int kDebugInfoPayloadOffset = 8;
+static constexpr int kChreDebugDumpLastBlockOffsetFisrtByte = 4;
+static constexpr int kChreDebugDumpLastBlockOffsetSecondByte = 5;
+static constexpr int kDebugInfoLastBlockOffset = 5;
+static constexpr int kHwCodeOffset = 2;
+
+static constexpr uint8_t kEventVendorSpecific =
+    0xFF;  // Event code: Vendor specific event
+static constexpr uint8_t kEventHardwareError =
+    0x10;  // Event code: Hardware error
+static constexpr uint8_t kVseSubEventDebugInfo =
+    0x57;  // Vendor specific sub event: Debug info
+static constexpr uint8_t kVseSubEventBqr =
+    0x58;  // Vendor specific sub event: Bluetooth quality report
+static constexpr uint8_t kVseSubEventDebug1 =
+    0x6A;  // Vendor specific sub event:  Debug logging
+static constexpr uint8_t kVseSubEventDebug2 =
+    0x1B;  // Vendor specific sub event:  Debug logging
+
+bool force_coredump_timer_created = false;
+timer_t force_coredump_timer;
+constexpr uint8_t kForceCoredumpTimerExpiredSec = 1;
+constexpr uint32_t kForceCoredumpTimerExpiredNs = 0;
+static const std::string kDumpReasonForceCollectCoredump =
+    "Force Collect Coredump";
+static const std::string kDumpReasonControllerHwError = "ControllerHwError";
+static const std::string kDumpReasonControllerRootInflammed =
+    "ControllerRootInflammed";
+static const std::string kDumpReasonControllerDebugDumpWithoutRootInflammed =
+    "ControllerDebugInfoDataDumpWithoutRootInflammed";
+static const std::string kDumpReasonControllerDebugInfo = "Debug Info Event";
+
+static const std::string kCrashInfoFilePath = "/data/vendor/ssrdump/";
+static const std::string kSsrdumpFilePath = "/data/vendor/ssrdump/coredump/";
+static const std::string kCrashInfoFilePrefix = "crashinfo_bt_";
+static const std::string kSsrdumpFilePrefix = "coredump_bt_";
+static const std::string kSsrdumpSocFilePrefix = "coredump_bt_socdump_";
+static const std::string kSsrdumpChreFilePrefix = "coredump_bt_chredump_";
+static const std::string kSocdumpFilePath =
+    "/data/vendor/ssrdump/coredump/coredump_bt_socdump_";
+static const std::string kChredumpFilePath =
+    "/data/vendor/ssrdump/coredump/coredump_bt_chredump_";
+static const std::string kVendorSnoopFilePath =
+    "/data/vendor/bluetooth/btsnoop_hci_vnd.log";
+static const std::string kBackupVendorSnoopFilePath =
+    "/data/vendor/bluetooth/backup_btsnoop_hci_vnd.log";
+static const std::string kVendorSnoopLastFilePath =
+    "/data/vendor/bluetooth/btsnoop_hci_vnd.log.last";
+static const std::string kBackupVendorSnoopLastFilePath =
+    "/data/vendor/bluetooth/backup_btsnoop_hci_vnd.log.last";
+
+static const std::string kDebugNodeBtLpm = "dev/logbuffer_btlpm";
+constexpr char kDebugNodeBtUartPrefix[] = "/dev/logbuffer_tty";
+constexpr char kHwStage[] = "ro.boot.hardware.revision";
+constexpr uint8_t kReservedCoredumpFileCount = 2;
+
+std::string crash_file_create_timestamp() {
+  time_t rawtime;
+  time(&rawtime);
+  struct tm* timeinfo = localtime(&rawtime);
+
+  std::stringstream ss;
+  ss << std::to_string(timeinfo->tm_year + 1900) << "-" << std::setw(2)
+     << std::setfill('0') << std::to_string(timeinfo->tm_mon + 1) << "-"
+     << std::setw(2) << std::setfill('0') << std::to_string(timeinfo->tm_mday)
+     << "_" << std::setw(2) << std::setfill('0')
+     << std::to_string(timeinfo->tm_hour) << "-" << std::setw(2)
+     << std::setfill('0') << std::to_string(timeinfo->tm_min) << "-"
+     << std::setw(2) << std::setfill('0') << std::to_string(timeinfo->tm_sec);
+  return ss.str();
+}
+
+void copy_file(const std::string& SrcDir, const std::string& DestDir) {
+  std::ifstream src(SrcDir, std::ios::binary);
+  std::ofstream dst(DestDir, std::ios::binary);
+
+  if (!src.is_open()) {
+    LOG(ERROR) << __func__ << ": Error opening source file.";
+    return;
+  }
+
+  if (!dst.is_open()) {
+    LOG(ERROR) << __func__ << ": Error opening destination file.";
+    return;
+  }
+
+  dst << src.rdbuf();
+
+  // Get source file permissions
+  struct stat src_stat;
+  if (stat(SrcDir.c_str(), &src_stat) != 0) {
+    LOG(ERROR) << __func__ << ": Error getting source file permissions.";
+    return;
+  }
+
+  // Apply permissions to destination file
+  if (chmod(DestDir.c_str(), src_stat.st_mode) != 0) {
+    LOG(ERROR) << __func__ << ": Error setting destination file permissions.";
+    return;
+  }
+}
+
+void backup_logging_files_before_crash(std::string crash_timestamp) {
+  LOG(INFO) << __func__;
+  if (crash_timestamp.empty()) {
+    crash_timestamp = crash_file_create_timestamp();
+  }
+  copy_file(kVendorSnoopLastFilePath,
+            kBackupVendorSnoopLastFilePath + "_" + crash_timestamp);
+  copy_file(kVendorSnoopFilePath,
+            kBackupVendorSnoopFilePath + "_" + crash_timestamp);
+}
+
+void dump_debugfs_to_fd(int fd, const std::string& debugfs) {
+  std::stringstream ss;
+  std::ifstream file;
+
+  ss << "=============================================" << std::endl;
+  ss << "Debugfs:" << debugfs << std::endl;
+  ss << "=============================================" << std::endl;
+  file.open(debugfs);
+  if (file.is_open()) {
+    ss << file.rdbuf() << std::endl;
+  } else {
+    ss << "Fail to read debugfs: " << debugfs << std::endl;
+  }
+  ss << std::endl;
+  write(fd, ss.str().c_str(), ss.str().length());
+}
+
+void read_as_hex(std::ifstream& file, std::stringstream& content) {
+  std::array<char, 64> memblock{};
+  while (!file.eof()) {
+    file.read(memblock.data(), memblock.size());
+    size_t len = file.gcount();
+    if (len == 0) continue;
+
+    for (size_t i = 0; i < len; i++) {
+      content << std::setbase(16) << std::setw(2) << std::setfill('0')
+              << (memblock[i] & 0xff);
+    }
+    content << "\n";
+  }
+}
+
+void collect_sscd_logs(int fd, const std::string& prefix,
+                       const std::string& dir) {
+  std::unique_ptr<DIR, decltype(&closedir)> dir_dump(opendir(dir.c_str()),
+                                                     closedir);
+
+  if (!dir_dump) {
+    LOG(WARNING) << __func__ << ": Failed to open directory, skip " << prefix
+                 << ".";
+    return;
+  }
+
+  std::stringstream content;
+  struct dirent* dp;
+  while ((dp = readdir(dir_dump.get()))) {
+    std::ifstream file;
+    std::string file_name;
+    std::stringstream path;
+
+    if (dp->d_type != DT_REG) {
+      continue;
+    }
+    file_name = dp->d_name;
+    size_t pos = file_name.find(prefix);
+    if (pos != 0) {
+      continue;
+    }
+
+    path << dir << file_name;
+    LOG(DEBUG) << __func__ << ": Dumping " << path.str() << ".";
+
+    // for coredump_bt_socdump_[timestamp].bin
+    std::size_t last_dot = file_name.rfind('.');
+    bool is_bin = (last_dot != std::string::npos &&
+                   file_name.substr(last_dot + 1) == "bin" &&
+                   (file_name.find(kSsrdumpSocFilePrefix) == 0 ||
+                    file_name.find(kSsrdumpChreFilePrefix) == 0));
+    if (is_bin)
+      file.open(path.str(), std::ifstream::binary);
+    else
+      file.open(path.str());
+    content << "*********************************************\n\n";
+    content << "BEGIN of LogFile: " << file_name << "\n\n";
+    content << "*********************************************\n";
+    if (file_name.length() != 0 && file.is_open()) {
+      if (is_bin) {
+        read_as_hex(file, content);
+      } else {
+        content << file.rdbuf() << std::endl;
+      }
+    } else {
+      content << "File open failed: " << prefix << std::endl;
+    }
+    content << "*********************************************\n\n";
+    content << "END of LogFile: " << file_name << "\n\n";
+    content << "*********************************************\n\n";
+  }
+  write(fd, content.str().c_str(), content.str().length());
+}
+
+int open_firmware_dump_file(const std::string& crash_timestamp) {
+  std::stringstream fname;
+  fname << kSocdumpFilePath << crash_timestamp << ".bin";
+  int socdump_fd;
+  if ((socdump_fd =
+           open(fname.str().c_str(), O_APPEND | O_CREAT | O_SYNC | O_WRONLY,
+                S_IRUSR | S_IWUSR | S_IRGRP)) < 0) {
+    LOG(ERROR) << __func__ << ": Failed to open socdump file: " << fname.str()
+               << ", failed: " << strerror(errno) << " (" << errno << ")";
+  }
+  // Change the file's permissions to OWNER Read/Write, GROUP Read, OTHER Read
+  if (chmod(fname.str().c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to change file permissions "
+               << fname.str() << ".";
+  }
+  return socdump_fd;
+}
+
+int open_lpp_chre_dump_file(const std::string& crash_timestamp) {
+  std::stringstream fname;
+  fname << kChredumpFilePath << crash_timestamp << ".bin";
+  int chredump_fd;
+  if ((chredump_fd =
+           open(fname.str().c_str(), O_APPEND | O_CREAT | O_SYNC | O_WRONLY,
+                S_IRUSR | S_IWUSR | S_IRGRP)) < 0) {
+    LOG(ERROR) << __func__ << ": Failed to open chredump file: " << fname.str()
+               << ", failed: " << strerror(errno) << " (" << errno << ")";
+  }
+  // Change the file's permissions to OWNER Read/Write, GROUP Read, OTHER Read
+  if (chmod(fname.str().c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to change file permissions "
+               << fname.str() << ".";
+  }
+  return chredump_fd;
+}
+
+bool is_coredump_file(const std::string& filename) {
+  return filename.find("coredump_bt_") == 0 &&
+         filename.find(".bin") == filename.size() - 4;
+}
+
+struct CoredumpFile {
+  std::string filename;
+  time_t timestamp;
+};
+
+bool compare_file_create_time(const CoredumpFile& a, const CoredumpFile& b) {
+  return a.timestamp < b.timestamp;
+}
+
+void delete_coredump_files(const std::string& dir) {
+  std::vector<CoredumpFile> coredumpfiles;
+  DIR* dir_ptr = opendir(dir.c_str());
+  if (dir_ptr != nullptr) {
+    struct dirent* entry;
+    while ((entry = readdir(dir_ptr)) != nullptr) {
+      if (is_coredump_file(entry->d_name)) {
+        struct stat statbuf;
+        stat((dir + "/" + entry->d_name).c_str(), &statbuf);
+        coredumpfiles.push_back({entry->d_name, statbuf.st_mtime});
+      }
+    }
+    closedir(dir_ptr);
+  }
+
+  sort(coredumpfiles.begin(), coredumpfiles.end(), compare_file_create_time);
+  LOG(INFO) << __func__ << ": Coredump files count: " << coredumpfiles.size()
+            << ".";
+  if (coredumpfiles.size() > kReservedCoredumpFileCount) {
+    for (int i = 0; i < coredumpfiles.size() - kReservedCoredumpFileCount;
+         i++) {
+      remove((dir + "/" + coredumpfiles[i].filename).c_str());
+      LOG(INFO) << __func__
+                << ": Delete file: " << (dir + "/" + coredumpfiles[i].filename)
+                << ".";
+    }
+  }
+}
+
+}  // namespace
+
+namespace bluetooth_hal {
+namespace debug {
+
+using ::android::base::StringPrintf;
+using ::bluetooth_hal::debug::BqrQualityReportId;
+using ::bluetooth_hal::debug::BtActivitiesLogger;
+using ::bluetooth_hal::debug::BtBqrEnergyRecoder;
+using ::bluetooth_hal::debug::ParseAdvanceRFStatsEvt;
+using ::bluetooth_hal::debug::ParseLinkQualityRelatedEvt;
+using ::bluetooth_hal::debug::ParseVendorSpecificQualityEvt;
+using ::bluetooth_hal::debug::ParseVendorSpecificTraceEvt;
+using ::bluetooth_hal::debug::updateControllerCapability;
+
+void LogFatal(BqrErrorCode error, std::string extra_info);
+const std::string get_error_code_string(BqrErrorCode error_code);
+
+const std::map<BqrErrorCode, std::string> error_code_string = {
+    // SOC FW Report Error Code
+    {BqrErrorCode::UART_PARSING, "UART Parsing error (BtFw)"},
+    {BqrErrorCode::UART_INCOMPLETE_PACKET, "UART Incomplete Packet (BtFw)"},
+    {BqrErrorCode::FIRMWARE_CHECKSUM, "Patch Firmware checksum failure (BtFw)"},
+    {BqrErrorCode::FIRMWARE_HARD_FAULT,
+     "Firmware Crash due to Hard Fault (BtFw)"},
+    {BqrErrorCode::FIRMWARE_MEM_MANAGE_FAULT,
+     "Firmware Crash due to Mem manage Fault (BtFw)"},
+    {BqrErrorCode::FIRMWARE_BUS_FAULT,
+     "Firmware Crash due to Bus Fault (BtFw)"},
+    {BqrErrorCode::FIRMWARE_USAGE_FAULT,
+     "Firmware Crash due to Usage fault (BtFw)"},
+    {BqrErrorCode::FIRMWARE_WATCHDOG_TIMEOUT,
+     "Firmware Crash due to Watchdog timeout (BtFw)"},
+    {BqrErrorCode::FIRMWARE_ASSERTION_FAILURE,
+     "Firmware Crash due to Assertion failure (BtFw)"},
+    {BqrErrorCode::FIRMWARE_MISCELLANEOUS,
+     "Firmware Crash Miscallaneuous (BtFw)"},
+    {BqrErrorCode::FIRMWARE_HOST_REQUEST_DUMP, "HCI Command Timeout (BtCmd)"},
+    {BqrErrorCode::FIRMWARE_MISCELLANEOUS_MAJOR_FAULT,
+     "Firmware Miscellaneous error - Major (BtFw)"},
+    {BqrErrorCode::FIRMWARE_MISCELLANEOUS_CRITICAL_FAULT,
+     "Firmware Miscellaneous error - Critical (BtFw)"},
+    {BqrErrorCode::FIRMWARE_THREAD_GENERIC_ERROR,
+     "Firmware crash due to 15.4 Thread error (ThreadFw)"},
+    {BqrErrorCode::FIRMWARE_THREAD_INVALID_FRAME,
+     "Firmware crash due to detecting malformed frame from host (ThreadFw)"},
+    {BqrErrorCode::FIRMWARE_THREAD_INVALID_PARAM,
+     "Firmware crash due to receiving invalid frame meta-data/parameters "
+     "(ThreadFw)"},
+    {BqrErrorCode::FIRMWARE_THREAD_UNSUPPORTED_FRAME,
+     "Firmware crash due to receiving frames from host with unsupported "
+     "command ID (ThreadFw)"},
+    {BqrErrorCode::SOC_BIG_HAMMER_FAULT, "Soc Big Hammer Error (BtWifi)"},
+    // BT HAL Report Error Code
+    {BqrErrorCode::HOST_RX_THREAD_STUCK, "Host RX Thread Stuck (BtHal)"},
+    {BqrErrorCode::HOST_HCI_COMMAND_TIMEOUT,
+     "Host HCI Command Timeout (BtHal)"},
+    {BqrErrorCode::HOST_INVALID_HCI_EVENT,
+     "Invalid / un-reassembled HCI event (BtHal)"},
+    {BqrErrorCode::HOST_UNIMPLEMENTED_PACKET_TYPE,
+     "Host Received Unimplemented Packet Type (BtHal)"},
+    {BqrErrorCode::HOST_HCI_H4_TX_ERROR, "Host HCI H4 TX Error (BtHal)"},
+    {BqrErrorCode::HOST_OPEN_USERIAL, "Host Open Userial Error (BtHal)"},
+    {BqrErrorCode::HOST_POWER_UP_CONTROLLER,
+     "Host Can't Power Up Controller (BtHal)"},
+    {BqrErrorCode::HOST_CHANGE_BAUDRATE, "Host Change Baudrate Error (BtHal)"},
+    {BqrErrorCode::HOST_RESET_BEFORE_FW,
+     "Host HCI Reset Error Before FW Download (BtHal)"},
+    {BqrErrorCode::HOST_DOWNLOAD_FW, "Host Firmware Download Error (BtHal)"},
+    {BqrErrorCode::HOST_RESET_AFTER_FW,
+     "Host HCI Reset Error After FW Download (BtHal)"},
+    {BqrErrorCode::HOST_BDADDR_FAULT,
+     "Host Can't fetch the provisioning BDA (BtHal)"},
+    {BqrErrorCode::HOST_ACCEL_BT_INIT_FAILED,
+     "Host Accelerated Init Failed (BtHal)"},
+    {BqrErrorCode::HOST_ACCEL_BT_SHUTDOWN_FAILED,
+     "Host Accelerated ShutDown Failed (BtHal)"},
+    {BqrErrorCode::CHRE_ARBITRATOR_UNIMPLEMENTED_PACKET,
+     "Arbitrator Detected Unimplemented Packet Type Error (BtChre)"},
+    {BqrErrorCode::CHRE_ARBITRATOR_INVALID_PACKET_SIZE,
+     "Arbitrator Detected Invalid Packet Size (BtChre)"},
+};
+
+DebugAnchor::DebugAnchor(AnchorType type, const std::string& anchor,
+                         DebugCentral& debugcentral)
+    : debugcentral_(&debugcentral), anchor_(anchor), type_(type) {
+  std::stringstream ss;
+  ss << anchor << " [ IN]";
+  debugcentral_->UpdateRecord(type_, ss.str());
+}
+
+DebugAnchor::~DebugAnchor() {
+  if (anchor_.empty()) {
+    return;
+  }
+  std::stringstream ss;
+  ss << anchor_ << " [OUT]";
+  debugcentral_->UpdateRecord(
+      static_cast<AnchorType>(static_cast<uint8_t>(type_) + 1), ss.str());
+  anchor_.clear();
+}
+
+// Keep this section for future refactory from HciFlowControl to
+// HciRouterClient.
+#if 0
+namespace {
+
+using WatcherCallback = std::function<bool(const HalPacket&)>;
+
+class DebugEventWatcher : public hci::HciEventWatcher {
+ public:
+  DebugEventWatcher(const char* tag, hci::HciFlowControl* handle,
+                    uint16_t event_code, uint16_t command_opcode,
+                    WatcherCallback callback)
+      : HciEventWatcher(tag, event_code, command_opcode, false, true),
+        callback_(callback),
+        hci_handle_(handle) {
+    hci_handle_->RegisterEventWatcher(this);
+  }
+
+  ~DebugEventWatcher() { hci_handle_->UnregisterEventWatcher(this); }
+
+  bool OnEventReceive(const hci::HalPacket& event) {
+    bool hijack_event = false;
+    if (callback_ != nullptr) {
+      hijack_event = callback_(event);
+    }
+    return hijack_event;
+  }
+  bool OnEventPost(const hci::HalPacket& event) {
+    (void)event;
+    return true;
+  }
+
+ private:
+  WatcherCallback callback_;
+  hci::HciFlowControl* hci_handle_;
+};
+
+}  // namespace
+#endif
+
+DebugCentral DebugCentral::instance_;
+
+DebugCentral* DebugCentral::Get() { return &instance_; }
+
+void DebugCentral::Dump(int fd) {
+  // Dump BtHal debug log
+  dump_hal_log(fd);
+  if (TransportInterface::GetTransportType() == TransportType::kUartH4) {
+    // Dump Kernel driver debugfs log
+    dump_debugfs_to_fd(fd, serial_debug_port_);
+    dump_debugfs_to_fd(fd, kDebugNodeBtLpm);
+  }
+  // Dump all crashinfo_bt files in ssrdump folder
+  collect_sscd_logs(fd, kCrashInfoFilePrefix, kCrashInfoFilePath);
+  // Dump all coredump_bt files in coredump folder
+  LOG(INFO) << __func__
+            << ": Write bt coredump files to `IBluetoothHci_default.txt`.";
+  collect_sscd_logs(fd, kSsrdumpFilePrefix, kSsrdumpFilePath);
+  // Dump Controller BT Activities Statistics
+  BtActivitiesLogger::GetInstacne()->ForceUpdating();
+  BtActivitiesLogger::GetInstacne()->DumpBtActivitiesStatistics(fd);
+  delete_coredump_files(kSsrdumpFilePath);
+}
+
+void DebugCentral::HasClientConnectWith(bool has_client) {
+  has_client_ = has_client;
+  LOG(INFO) << __func__ << ": has_client: " << has_client_ << ".";
+}
+
+void DebugCentral::SetBtUartDebugPort(const std::string& uart_port) {
+  if (uart_port.empty()) {
+    LOG(ERROR) << __func__ << ": UART port is empty!";
+    return;
+  }
+
+  std::size_t const found = uart_port.find_first_of("0123456789");
+  if (found != std::string::npos) {
+    serial_debug_port_ = kDebugNodeBtUartPrefix + uart_port.substr(found);
+    LOG(INFO) << __func__ << ": Serial debug port: " << serial_debug_port_
+              << ".";
+    return;
+  }
+  LOG(ERROR) << __func__ << ": Cannot found uart port!";
+}
+
+#if 0
+void DebugCentral::StartMonitor(hci::HciFlowControl* handle) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (handle == nullptr) {
+    LOG(ERROR) << __func__ << ": Invalid handle!";
+    return;
+  }
+
+  event_watchers_.emplace_back(std::make_unique<DebugEventWatcher>(
+      "debug_HwError", handle, kEventHardwareError,
+      hci::HciEventWatcher::kCommandUnspecifiedOpcode,
+      [](const HalPacket& packet) {
+        LOG(ERROR) << __func__ << ": Received Hardware error event!";
+        ONE_TIME_LOGGER(AnchorType::HW_ERR_EVT,
+                        "%s: Received Hardware error event!", __func__);
+        if (packet.size() > kHwCodeOffset) {
+          LOG(ERROR) << __func__ << ": Error code=" << std::hex
+                     << static_cast<int>(packet.data()[kHwCodeOffset]) << ".";
+        }
+        // TODO: b/373786258 - Need to start_crash_dump with first hci reset
+        // flag for silent report.
+
+        // Do not hijack event.
+        return false;
+      }));
+  event_watchers_.emplace_back(std::make_unique<DebugEventWatcher>(
+      "debug_VendorEvent", handle, kEventVendorSpecific,
+      hci::HciEventWatcher::kCommandUnspecifiedOpcode,
+      [this](const HalPacket& packet) {
+        handle_vendor_specific_event(packet);
+        if (hijack_event_) {
+          hijack_event_ = false;
+          // hijack this vse
+          return true;
+        }
+        // do not hijack this vse
+        return false;
+      }));
+  event_watchers_.emplace_back(std::make_unique<DebugEventWatcher>(
+      "vendorCapabilityEvent", handle,
+      hci::HciEventWatcher::kCommandCompleteEventCode,
+      hci::HciEventWatcher::kCommandVendorCapabilityOpcode,
+      [this](const HalPacket& packet) {
+        std::unique_lock<std::recursive_mutex> lock(mutex_);
+        updateControllerCapability(packet);
+        return false;
+      }));
+  // TODO(b/263604600): debugging message will be removed after issue clarified
+  event_watchers_.emplace_back(std::make_unique<DebugEventWatcher>(
+      "LeSetExtentedScanEnableEvent", handle,
+      hci::HciEventWatcher::kCommandCompleteEventCode,
+      hci::HciEventWatcher::kCommandLeScanEnableOpcode,
+      [this](const HalPacket& packet) {
+        std::unique_lock<std::recursive_mutex> lock(mutex_);
+        uint16_t opcode = packet[3] + ((packet[4] << 8u) & 0xFF00);
+        LOG(INFO) << __func__
+                  << ": Command Complete Event of LE_SET_EXTENDED_SCAN_ENABLE, "
+                  << "opcode:" << std::hex << opcode << ".";
+        return false;
+      }));
+}
+
+void DebugCentral::StopMonitor() {
+  LOG(INFO) << __func__;
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  event_watchers_.clear();
+  crash_timestamp_.clear();
+  // reset Soc MemDump Cache
+  if (!socdump_.empty()) {
+    std::queue<std::vector<uint8_t>> empty_queue;
+    std::swap(socdump_, empty_queue);
+  }
+}
+#endif
+
+void DebugCentral::UpdateRecord(AnchorType type, const std::string& anchor) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  std::string anchor_timestamp = Logger::GetLogFormatTimestamp();
+  std::pair log_entry =
+      std::pair<std::string, std::string>(anchor, anchor_timestamp);
+  if (history_record_.size() >= kMaxHistory) {
+    history_record_.pop_front();
+  }
+  history_record_.push_back(log_entry);
+  lasttime_record_[type] = log_entry;
+}
+
+void DebugCentral::ReportBqrError(BqrErrorCode error, std::string extra_info) {
+  HalPacket bqr_event({0xff, 0x04, 0x58, 0x05, 0x00, (uint8_t)error});
+  // collect debug dump and popup ssrdump notification UI
+  ONE_TIME_LOGGER(AnchorType::BQR_ERR_MSG, "%s", extra_info.c_str());
+  LOG(ERROR) << __func__ << ": Root inflamed event with error_code: ("
+             << static_cast<uint8_t>(error) << "), error_info: " << extra_info
+             << ".";
+  // report bqr root inflamed event to Stack
+  if (notify_cb_ != nullptr) {
+    LOG(WARNING) << __func__ << ": notify_cb_(bqr_event).";
+    notify_cb_(bqr_event);
+  }
+
+  if (report_ssr_crash(static_cast<uint8_t>(error))) {
+    start_crash_dump(false,
+                     kDumpReasonControllerRootInflammed + " (" +
+                         StringPrintf("error_code: 0x%02hhX",
+                                      static_cast<unsigned char>(error)) +
+                         ")" + " - " + get_error_code_string(error));
+    backup_logging_files_before_crash(crash_timestamp_);
+    LogFatal(error, extra_info);
+  } else {
+    LOG(ERROR) << __func__ << ": Silent recover!";
+    ThreadHandler::Cleanup();
+    kill(getpid(), SIGKILL);
+  }
+}
+
+void DebugCentral::ForceGetCoredumpTimeout(union sigval sig) {
+  DebugCentral* debug_ctrl = static_cast<DebugCentral*>(sig.sival_ptr);
+  // It is supported to generate coredump and record crash_timestamp_ when bthal
+  // received root-inflamed event or any fw dump packet, if the controller
+  // did not send any response packets, we force to trigger coredump here
+  if (debug_ctrl->crash_timestamp_.empty()) {
+    LOG(ERROR) << __func__
+               << ": Force a coredump to be generated if it has not been "
+                  "generated for 1 second.";
+    debug_ctrl->start_crash_dump(true,
+                                 kDumpReasonForceCollectCoredump + " (BtFw)");
+  }
+
+  if (force_coredump_timer_created == true) {
+    itimerspec ts{};
+    LOG(WARNING) << __func__ << ": Delete force_coredump_timer.";
+    timer_settime(force_coredump_timer, 0, &ts, NULL);
+    timer_delete(force_coredump_timer);
+    force_coredump_timer_created = false;
+  }
+}
+
+bool DebugCentral::IsControllerDebugDumpOpcode(const HalPacket& data) {
+  if (data.size() < 2) {
+    return false;
+  }
+
+  if (data[0] == 0x5b && data[1] == 0xfd) {
+    LOG(WARNING) << __func__ << ": Sending Controller Debug Info Command.";
+    ONE_TIME_LOGGER(AnchorType::DEBUG_INFO,
+                    "%s: Sending Controller Debug Info command!", __func__);
+    int ret;
+    itimerspec dump_ts{};
+    sigevent force_coredump_se{};
+    force_coredump_se.sigev_notify = SIGEV_THREAD;
+    force_coredump_se.sigev_value.sival_ptr = this;
+    force_coredump_se.sigev_notify_function =
+        (void (*)(sigval))ForceGetCoredumpTimeout;
+    force_coredump_se.sigev_notify_attributes = NULL;
+    ret = timer_create(CLOCK_MONOTONIC, &force_coredump_se,
+                       &force_coredump_timer);
+    if (ret < 0) {
+      LOG(ERROR) << __func__ << ": Cannot create force_coredump_timer!";
+    } else {
+      force_coredump_timer_created = true;
+    }
+
+    // update force_coredump_timer
+    dump_ts.it_value.tv_sec = kForceCoredumpTimerExpiredSec;
+    dump_ts.it_value.tv_nsec = kForceCoredumpTimerExpiredNs;
+    if (force_coredump_timer_created == true) {
+      ret = timer_settime(force_coredump_timer, 0, &dump_ts, NULL);
+      if (ret < 0) {
+        LOG(ERROR) << __func__ << ": Cannot arm force_coredump_timer!";
+      }
+    }
+    return true;
+  }
+  return false;
+}
+
+bool DebugCentral::is_hw_stage_supported() {
+  std::string cur_hw_stage = ::android::base::GetProperty(kHwStage, "default");
+  std::vector<std::string> not_supported_hw_stages =
+      HalConfigLoader::GetLoader().GetFwUnsupportedHwStages();
+  return std::find_if(not_supported_hw_stages.begin(),
+                      not_supported_hw_stages.end(),
+                      [&](std::string& not_supported_hw_stage) {
+                        return cur_hw_stage == not_supported_hw_stage;
+                      }) == not_supported_hw_stages.end();
+}
+
+bool DebugCentral::report_ssr_crash(uint8_t vendor_error_code) {
+  // Report scenario:
+  // 1) report ssr crash when bt is on
+  // 2) report ssr crash when bt is off, thread is enabled, and supports
+  // accelerated bt on
+
+  bool is_major_fault = (static_cast<BqrErrorCode>(vendor_error_code) ==
+                         BqrErrorCode::FIRMWARE_MISCELLANEOUS_MAJOR_FAULT);
+
+  if (is_major_fault || !is_hw_stage_supported()) {
+    return false;
+  }
+
+  bool is_thread_dispatcher_working =
+      ThreadHandler::IsHandlerRunning() &&
+      ThreadHandler::GetHandler().IsDaemonRunning();
+
+  return is_thread_dispatcher_working || has_client_;
+}
+
+void DebugCentral::dump_hal_log(int fd) {
+  std::stringstream ss;
+
+  ss << "=============================================" << std::endl;
+  ss << "Controller Firmware Information" << std::endl;
+  ss << "=============================================" << std::endl;
+  // TODO: b/373786258 - Print local name into stringstream.
+
+  ss << "=============================================" << std::endl;
+  ss << "Anchors' Last Appear" << std::endl;
+  ss << "=============================================" << std::endl;
+  for (auto it = lasttime_record_.begin(); it != lasttime_record_.end(); ++it) {
+    std::string anchor = it->second.first;
+    std::string anchor_timestamp = it->second.second;
+    ss << "Timestamp of " << anchor << ": " << anchor_timestamp << std::endl;
+  }
+
+  ss << "=============================================" << std::endl;
+  ss << "Anchors' History" << std::endl;
+  ss << "=============================================" << std::endl;
+  for (auto it = history_record_.begin(); it != history_record_.end(); ++it) {
+    std::string anchor = it->first;
+    std::string anchor_timestamp = it->second;
+    ss << anchor_timestamp << ": " << anchor << std::endl;
+  }
+  write(fd, ss.str().c_str(), ss.str().length());
+}
+
+void DebugCentral::handle_vendor_specific_event(const HalPacket& packet) {
+  if (packet.size() < kVseSubEventCodeOffset) {
+    LOG(WARNING) << __func__ << ": Invalid length of VS event!";
+    return;
+  }
+  uint8_t sub_event_code = packet[kVseSubEventCodeOffset];
+  switch (sub_event_code) {
+    case kVseSubEventDebugInfo:
+      static int msg_counter = 0;
+      if (++msg_counter <= 20) {
+        LOG(WARNING) << __func__ << ": Received Debug Info event!";
+      }
+      handle_debug_info_event(packet);
+      hijack_event_ = true;
+      break;
+    case kVseSubEventBqr:
+      handle_bqr_event(packet);
+      break;
+    case kVseSubEventDebug1:
+      [[fallthrough]];
+    case kVseSubEventDebug2:
+      hijack_event_ = true;
+      break;
+    default:
+      break;
+  }
+}
+
+void DebugCentral::handle_bqr_event(const HalPacket& packet) {
+  if (packet.size() <= kBqrReportIdOffset) {
+    LOG(WARNING) << __func__ << ": Invalid length of BQR event!";
+    return;
+  }
+  auto quality_report_id =
+      static_cast<BqrQualityReportId>(packet[kBqrReportIdOffset]);
+  switch (quality_report_id) {
+    case BqrQualityReportId::kMonitorMode:
+      [[fallthrough]];
+    case BqrQualityReportId::kApproachLsto:
+      [[fallthrough]];
+    case BqrQualityReportId::kA2dpAudioChoppy:
+      [[fallthrough]];
+    case BqrQualityReportId::kScoVoiceChoppy:
+      [[fallthrough]];
+    case BqrQualityReportId::kLeAudioChoppy:
+      ParseLinkQualityRelatedEvt(packet);
+      break;
+
+    case BqrQualityReportId::kRootInflammation: {
+      uint8_t error_code = packet[kBqrInflamedErrorCode];
+      uint8_t vendor_error_code = packet[kBqrInflamedVendorErrCode];
+      LOG(ERROR) << __func__ << ": Received Root Inflammation event! (0x"
+                 << std::hex << std::setw(2) << std::setfill('0')
+                 << static_cast<int>(error_code) << std::setw(2)
+                 << std::setfill('0') << static_cast<int>(vendor_error_code)
+                 << ").";
+      // for some vendor error code event that we do not report root inflamed
+      // event
+      if (report_ssr_crash(vendor_error_code)) {
+        start_crash_dump(
+            false,
+            kDumpReasonControllerRootInflammed + " (" +
+                StringPrintf("vendor_error: 0x%02hhX", vendor_error_code) +
+                ")" + " - " +
+                get_error_code_string(
+                    static_cast<BqrErrorCode>(vendor_error_code)));
+        backup_logging_files_before_crash(crash_timestamp_);
+        hijack_event_ = false;
+      } else {
+        hijack_event_ = true;
+      }
+      break;
+    }
+
+    // Just logs to vnd snoop and skips reporting to stack
+    case BqrQualityReportId::kEnergyMonitoring:
+      BtBqrEnergyRecoder::GetInstacne()->ParseBqrEnergyMonitorEvt(packet);
+      hijack_event_ = true;
+      break;
+
+    case BqrQualityReportId::kControllerDbgInfo: {
+      handle_bqr_fw_debug_data_dump(packet);
+      hijack_event_ = true;
+      break;
+    }
+
+    case BqrQualityReportId::kAdvanceRfStats:
+      [[fallthrough]];
+    case BqrQualityReportId::kAdvanceRfStatsPeriodic:
+      ParseAdvanceRFStatsEvt(packet);
+      hijack_event_ = true;
+      break;
+    case BqrQualityReportId::kControllerHealthMonitor:
+      [[fallthrough]];
+    case BqrQualityReportId::kControllerHealthMonitorPeriodic:
+      ParseControllerHealthMonitorEvt(packet);
+      hijack_event_ = true;
+      break;
+    case BqrQualityReportId::kChreDbgInfo: {
+      handle_bqr_chre_debug_data_dump(packet);
+      hijack_event_ = true;
+      break;
+    }
+    case BqrQualityReportId::kVendorSpecificTrace: {
+      ParseVendorSpecificTraceEvt(packet);
+      break;
+    }
+    case BqrQualityReportId::kVendorSpecificQuality: {
+      ParseVendorSpecificQualityEvt(packet);
+      break;
+    }
+    default: {
+      break;
+    }
+  }
+}
+
+void DebugCentral::handle_debug_info_event(const HalPacket& packet) {
+  bool last_soc_dump_packet = false;
+  if (packet.size() <= kDebugInfoPayloadOffset) {
+    LOG(INFO) << __func__ << ": Invalid length of debug info event!";
+    return;
+  }
+
+  if (crash_timestamp_.empty()) {
+    start_crash_dump(is_hw_stage_supported() ? false : true,
+                     kDumpReasonControllerDebugInfo + " (BtFw)");
+  }
+
+  // the Last soc dump debug info packet has been received
+  if (packet[kDebugInfoLastBlockOffset]) {
+    LOG(INFO) << __func__ << ": Last soc dump fragment has been received.";
+    backup_logging_files_before_crash(crash_timestamp_);
+    last_soc_dump_packet = true;
+  }
+
+  int socdump_fd;
+  if ((socdump_fd = open_firmware_dump_file(crash_timestamp_)) < 0) {
+    return;
+  }
+
+  size_t ret = 0;
+  if ((ret = TEMP_FAILURE_RETRY(
+           write(socdump_fd, packet.data(), packet.size()))) < 0) {
+    LOG(ERROR) << __func__ << ": Error writing to dest file: " << ret << " ("
+               << strerror(errno) << ").";
+  }
+
+  close(socdump_fd);
+  if (last_soc_dump_packet) {
+    LOG(ERROR) << __func__ << ": Restart bthal service for recovery!";
+    last_soc_dump_packet = false;
+    ThreadHandler::Cleanup();
+    kill(getpid(), SIGKILL);
+  }
+}
+
+void DebugCentral::handle_bqr_fw_debug_data_dump(const HalPacket& packet) {
+  if (packet.size() <= kBqrReportIdOffset) {
+    LOG(WARNING) << __func__
+                 << ": Invalid length of bqr debug firmware dump event!";
+    return;
+  }
+
+  if (crash_timestamp_.empty()) {
+    LOG(ERROR) << __func__
+               << ": Did not receive Root Inflammation event before FW Dump!";
+    start_crash_dump(
+        is_hw_stage_supported() ? false : true,
+        kDumpReasonControllerDebugDumpWithoutRootInflammed + " (BtFw)");
+  }
+
+  int socdump_fd;
+  if ((socdump_fd = open_firmware_dump_file(crash_timestamp_)) < 0) {
+    return;
+  }
+
+  size_t ret = 0;
+  if ((ret = TEMP_FAILURE_RETRY(
+           write(socdump_fd, packet.data(), packet.size()))) < 0) {
+    LOG(ERROR) << __func__ << ": Error writing to dest file: " << ret << " ("
+               << strerror(errno) << ").";
+  }
+
+  close(socdump_fd);
+}
+
+void DebugCentral::handle_bqr_chre_debug_data_dump(const HalPacket& packet) {
+  if (packet.size() <= kBqrReportIdOffset) {
+    LOG(WARNING) << __func__
+                 << ": Invalid length of bqr chre debug dump event!";
+    return;
+  }
+
+  if (crash_timestamp_.empty()) {
+    LOG(ERROR) << __func__
+               << ": Did not receive Root Inflammation event before CHRE Dump!";
+    start_crash_dump(false, kDumpReasonControllerDebugDumpWithoutRootInflammed +
+                                " (BtChre)");
+  }
+
+  std::vector<uint8_t> payload(packet.size());
+  memcpy(payload.data(), packet.data(), packet.size());
+  chredump_.push(payload);
+
+  // Cache Chre dump in DEBUG_INFO event, dump to file if last fragment.
+  uint16_t last_block;
+  last_block =
+      packet[kChreDebugDumpLastBlockOffsetSecondByte] +
+      ((packet[kChreDebugDumpLastBlockOffsetFisrtByte] << 8u) & 0xFF00);
+
+  if (last_block != 0x5A00) {
+    return;
+  }
+  LOG(INFO) << __func__ << ": Last Chre dump packet has been received.";
+
+  int chredump_fd;
+  if ((chredump_fd = open_lpp_chre_dump_file(crash_timestamp_)) < 0) {
+    return;
+  }
+
+  size_t bytes_written = 0;
+  size_t ret = 0;
+  while (!chredump_.empty()) {
+    std::vector<uint8_t>& segment = chredump_.front();
+    if ((ret = TEMP_FAILURE_RETRY(
+             write(chredump_fd, segment.data(), segment.size()))) < 0) {
+      LOG(ERROR) << __func__ << ": Error writing to dest file: " << ret << " ("
+                 << strerror(errno) << ").";
+      break;
+    }
+    if (ret != segment.size()) {
+      LOG(ERROR) << __func__ << ": Actual write (" << ret
+                 << " bytes) is not the same with expected write "
+                 << "(" << segment.size() << " bytes) size.";
+    }
+    bytes_written += ret;
+    chredump_.pop();
+  }
+  LOG(INFO) << __func__ << ": Total written " << bytes_written << " bytes.";
+
+  if (!chredump_.empty()) {
+    LOG(WARNING) << __func__ << ": There are " << chredump_.size()
+                 << " segments not be saved.";
+    chredump_ = {};
+  }
+
+  close(chredump_fd);
+  hijack_event_ = true;
+}
+
+void DebugCentral::start_crash_dump(bool slient_report,
+                                    const std::string& reason) {
+  if (!crash_timestamp_.empty()) {
+    // coredump has already been generated, avoid duplicated dump in one crash
+    // cycle
+    return;
+  }
+
+  LOG(ERROR) << __func__ << ": Reason: " << reason.c_str()
+             << ", slient_report:" << slient_report << ".";
+  crash_timestamp_ = crash_file_create_timestamp();
+  std::stringstream coredump_fname;
+  coredump_fname << kSsrdumpFilePath << kSsrdumpFilePrefix << crash_timestamp_
+                 << ".bin";
+  LOG(WARNING) << __func__ << ": Starting to generate Bluetooth ssrdump files: "
+               << coredump_fname.str().c_str() << ".";
+
+  int coredump_fd;
+  if ((coredump_fd =
+           open(coredump_fname.str().c_str(), O_CREAT | O_SYNC | O_RDWR,
+                S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
+    LOG(ERROR) << __func__ << ": Failed to open coredump file: "
+               << coredump_fname.str().c_str()
+               << ", failed: " << strerror(errno) << " (" << errno << ").";
+    return;
+  }
+  fchmod(coredump_fd, S_IRUSR | S_IRGRP | S_IROTH);
+
+  std::stringstream ss;
+  ss << "DUMP REASON: " << std::string(reason) << " - occurred at "
+     << crash_timestamp_ << std::endl;
+  write(coredump_fd, ss.str().c_str(), ss.str().length());
+
+  dump_hal_log(coredump_fd);
+  LOG(INFO) << __func__ << ": Request to get Transport Layer Debug Dump.";
+  // TODO: b/373786258 - Need to dump debug info.
+  close(coredump_fd);
+
+  if (slient_report) {
+    return;
+  }
+  // generate crashinfo file
+  std::stringstream crashinfo_fname;
+  crashinfo_fname << kCrashInfoFilePath << kCrashInfoFilePrefix
+                  << crash_timestamp_ << ".txt";
+
+  int crashinfo_fd;
+  if ((crashinfo_fd =
+           open(crashinfo_fname.str().c_str(), O_CREAT | O_SYNC | O_RDWR,
+                S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
+    LOG(ERROR) << __func__
+               << ": Failed to open crashinfo file: " << crashinfo_fname.str()
+               << ", failed: " << strerror(errno) << " (" << errno << ").";
+    return;
+  }
+  fchmod(crashinfo_fd, S_IRUSR | S_IRGRP | S_IROTH);
+
+  std::stringstream crashinfo_ss;
+  static int crash_count = 0;
+  crashinfo_ss << "crash_reason: " << std::string(reason) << std::endl;
+  crash_count++;
+  crashinfo_ss << "crash_count: " << std::to_string(crash_count) << std::endl;
+  crashinfo_ss << "timestamp: " << crash_timestamp_ << std::endl;
+  write(crashinfo_fd, crashinfo_ss.str().c_str(), crashinfo_ss.str().length());
+  close(crashinfo_fd);
+}
+
+const std::string get_error_code_string(BqrErrorCode error_code) {
+  return error_code_string.find(error_code) != error_code_string.end()
+             ? error_code_string.at(error_code)
+             : "Undefined error code";
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/debug/debug_event_watcher.cc b/bluetooth/bluetooth_hal/debug/debug_event_watcher.cc
new file mode 100644
index 0000000000..a84741367a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/debug/debug_event_watcher.cc
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.debug.watcher"
+
+#include "bluetooth_hal/debug/debug_event_watcher.h"
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+using ::bluetooth_hal::hci::CommandOpCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::MonitorMode;
+
+DebugEventWatcher::DebugEventWatcher()
+    : bqr_event_monitor_(),
+      google_vendor_capability_event_monitor_(
+          static_cast<uint16_t>(CommandOpCode::kGoogleVendorCapability)) {
+  RegisterMonitor(bqr_event_monitor_, MonitorMode::kMonitor);
+  RegisterMonitor(google_vendor_capability_event_monitor_,
+                  MonitorMode::kMonitor);
+}
+
+DebugEventWatcher::~DebugEventWatcher() {
+  UnregisterMonitor(bqr_event_monitor_);
+  UnregisterMonitor(google_vendor_capability_event_monitor_);
+}
+
+void DebugEventWatcher::OnMonitorPacketCallback(
+    [[maybe_unused]] MonitorMode mode, const HalPacket& packet) {
+  LOG(INFO) << __func__ << ": " << packet.ToString();
+};
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/debug/stack_trace_helper.cc b/bluetooth/bluetooth_hal/debug/stack_trace_helper.cc
new file mode 100644
index 0000000000..8112f48776
--- /dev/null
+++ b/bluetooth/bluetooth_hal/debug/stack_trace_helper.cc
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/debug/debug_central.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+typedef struct {
+  BqrErrorCode error_code;
+  void (*func)(std::string);
+} ErrorCodeMap;
+
+void UartParsing(std::string msg) { LOG(FATAL) << msg; }
+
+void UartIncompletePacket(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareChecksum(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareHardFault(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareMemManageFault(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareBusFault(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareFirmwareUsageFault(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareWatchdogTimeout(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareAssertionFailure(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareMiscellaneous(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareMiscellaneousMajorFault(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareMiscellaneousCriticalFault(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareThreadGenericError(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareThreadInvalidFrame(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareThreadInvalidParam(std::string msg) { LOG(FATAL) << msg; }
+
+void FirmwareThreadUnsupportedFrame(std::string msg) { LOG(FATAL) << msg; }
+
+void SocBigHammerFault(std::string msg) { LOG(FATAL) << msg; }
+
+void HostRxThreadStuck(std::string msg) { LOG(FATAL) << msg; }
+
+void HostHciCommandTimeout(std::string msg) { LOG(FATAL) << msg; }
+
+void HostInvalidHciEvent(std::string msg) { LOG(FATAL) << msg; }
+
+void HostUnimplementedPacketType(std::string msg) { LOG(FATAL) << msg; }
+
+void HosHcitH4TxError(std::string msg) { LOG(FATAL) << msg; }
+
+void HostOpenUserial(std::string msg) { LOG(FATAL) << msg; }
+
+void HostPowerUpController(std::string msg) { LOG(FATAL) << msg; }
+
+void HostResetBeforeFw(std::string msg) { LOG(FATAL) << msg; }
+
+void HostChangeBaudrate(std::string msg) { LOG(FATAL) << msg; }
+
+void HostDownloadFw(std::string msg) { LOG(FATAL) << msg; }
+
+void HostResetAfterFw(std::string msg) { LOG(FATAL) << msg; }
+
+void HostBdaddrFault(std::string msg) { LOG(FATAL) << msg; }
+
+void HostCoexDeviceOpenError(std::string msg) { LOG(FATAL) << msg; }
+
+void HostAccelatedBtInitFailed(std::string msg) { LOG(FATAL) << msg; }
+
+void HostAccelatedBtShutdownFailed(std::string msg) { LOG(FATAL) << msg; }
+
+void ChreArbitratorUnimplementedPacket(std::string msg) { LOG(FATAL) << msg; }
+
+void ChreArbitratorInvalidPacketSize(std::string msg) { LOG(FATAL) << msg; }
+
+ErrorCodeMap kErrorCodeMap[]{
+    {BqrErrorCode::UART_PARSING, UartParsing},
+    {BqrErrorCode::UART_INCOMPLETE_PACKET, UartIncompletePacket},
+    {BqrErrorCode::FIRMWARE_CHECKSUM, FirmwareChecksum},
+    {BqrErrorCode::FIRMWARE_HARD_FAULT, FirmwareHardFault},
+    {BqrErrorCode::FIRMWARE_MEM_MANAGE_FAULT, FirmwareMemManageFault},
+    {BqrErrorCode::FIRMWARE_BUS_FAULT, FirmwareBusFault},
+    {BqrErrorCode::FIRMWARE_USAGE_FAULT, FirmwareFirmwareUsageFault},
+    {BqrErrorCode::FIRMWARE_WATCHDOG_TIMEOUT, FirmwareWatchdogTimeout},
+    {BqrErrorCode::FIRMWARE_ASSERTION_FAILURE, FirmwareAssertionFailure},
+    {BqrErrorCode::FIRMWARE_MISCELLANEOUS, FirmwareMiscellaneous},
+    {BqrErrorCode::FIRMWARE_MISCELLANEOUS_MAJOR_FAULT,
+     FirmwareMiscellaneousMajorFault},
+    {BqrErrorCode::FIRMWARE_MISCELLANEOUS_CRITICAL_FAULT,
+     FirmwareMiscellaneousCriticalFault},
+    {BqrErrorCode::FIRMWARE_THREAD_GENERIC_ERROR, FirmwareThreadGenericError},
+    {BqrErrorCode::FIRMWARE_THREAD_INVALID_FRAME, FirmwareThreadInvalidFrame},
+    {BqrErrorCode::FIRMWARE_THREAD_INVALID_PARAM, FirmwareThreadInvalidParam},
+    {BqrErrorCode::FIRMWARE_THREAD_UNSUPPORTED_FRAME,
+     FirmwareThreadUnsupportedFrame},
+    {BqrErrorCode::SOC_BIG_HAMMER_FAULT, SocBigHammerFault},
+    {BqrErrorCode::HOST_RX_THREAD_STUCK, HostRxThreadStuck},
+    {BqrErrorCode::HOST_HCI_COMMAND_TIMEOUT, HostHciCommandTimeout},
+    {BqrErrorCode::HOST_INVALID_HCI_EVENT, HostInvalidHciEvent},
+    {BqrErrorCode::HOST_UNIMPLEMENTED_PACKET_TYPE, HostUnimplementedPacketType},
+    {BqrErrorCode::HOST_HCI_H4_TX_ERROR, HosHcitH4TxError},
+    {BqrErrorCode::HOST_OPEN_USERIAL, HostOpenUserial},
+    {BqrErrorCode::HOST_POWER_UP_CONTROLLER, HostPowerUpController},
+    {BqrErrorCode::HOST_CHANGE_BAUDRATE, HostChangeBaudrate},
+    {BqrErrorCode::HOST_RESET_BEFORE_FW, HostResetBeforeFw},
+    {BqrErrorCode::HOST_DOWNLOAD_FW, HostDownloadFw},
+    {BqrErrorCode::HOST_RESET_AFTER_FW, HostResetAfterFw},
+    {BqrErrorCode::HOST_BDADDR_FAULT, HostBdaddrFault},
+    {BqrErrorCode::HOST_OPEN_COEX_DEVICE_ERROR, HostCoexDeviceOpenError},
+    {BqrErrorCode::HOST_ACCEL_BT_INIT_FAILED, HostAccelatedBtInitFailed},
+    {BqrErrorCode::HOST_ACCEL_BT_SHUTDOWN_FAILED,
+     HostAccelatedBtShutdownFailed},
+    {BqrErrorCode::CHRE_ARBITRATOR_UNIMPLEMENTED_PACKET,
+     ChreArbitratorUnimplementedPacket},
+    {BqrErrorCode::CHRE_ARBITRATOR_INVALID_PACKET_SIZE,
+     ChreArbitratorInvalidPacketSize}};
+
+void LogFatal(BqrErrorCode error_code, std::string extra_info) {
+  int size = (int)(sizeof(kErrorCodeMap) / sizeof(ErrorCodeMap));
+  std::string msg =
+      "Bluetooth HAL crash with error code 0, vendor error code " +
+      std::to_string((uint8_t)error_code);
+  if (!extra_info.empty()) {
+    msg = msg + ", extra info: " + extra_info;
+  }
+  for (int index = 0; index < size; index++) {
+    if (kErrorCodeMap[index].error_code == error_code) {
+      (kErrorCodeMap[index].func)(msg);
+      break;
+    }
+  }
+  // For unknown error code, will trigger crash on here.
+  LOG(FATAL) << msg;
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/debug/vnd_snoop_logger.cc b/bluetooth/bluetooth_hal/debug/vnd_snoop_logger.cc
new file mode 100644
index 0000000000..b24cb92829
--- /dev/null
+++ b/bluetooth/bluetooth_hal/debug/vnd_snoop_logger.cc
@@ -0,0 +1,415 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.vndsnoop"
+
+#include "bluetooth_hal/debug/vnd_snoop_logger.h"
+
+#include <arpa/inet.h>
+#include <stdint.h>
+#include <sys/stat.h>
+#include <time.h>
+
+#include <chrono>
+#include <cstddef>
+#include <cstdint>
+#include <fstream>
+#include <memory>
+#include <optional>
+#include <string>
+#include <string_view>
+
+#include "android-base/logging.h"
+#include "android-base/properties.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/files.h"
+#include "bluetooth_hal/util/worker.h"
+
+namespace bluetooth_hal {
+namespace debug {
+namespace {
+
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::Worker;
+
+struct PacketHeaderType {
+  uint32_t length_original;
+  uint32_t length_captured;
+  uint32_t flags;
+  uint32_t dropped_packets;
+  uint64_t timestamp;
+  uint8_t type;
+} __attribute__((__packed__));
+
+struct FileHeaderType {
+  uint8_t identification_pattern[8];
+  uint32_t version_number;
+  uint32_t datalink_type;
+} __attribute__((__packed__));
+
+// Epoch in microseconds since 01/01/0000.
+constexpr uint64_t kBtSnoopEpochDelta = 0x00dcddb30f2f8000ULL;
+
+// A compile-time check for system endianness.
+constexpr uint32_t kBytesToTest = 0x12345678;
+constexpr uint8_t kFirstByte = static_cast<uint8_t>(kBytesToTest);
+constexpr bool kIsLittleEndian = kFirstByte == 0x78;
+constexpr bool kIsBigEndian = kFirstByte == 0x12;
+static_assert(kIsLittleEndian ||
+                  (kIsBigEndian && kIsLittleEndian != kIsBigEndian),
+              "System must be either little-endian or big-endian");
+
+constexpr uint32_t kBtSnoopVersionNumber = kIsLittleEndian ? 0x01000000 : 1;
+constexpr uint32_t kBtSnoopDatalinkType =
+    kIsLittleEndian ? 0xea030000
+                    : 0x03ea;  // Datalink Type code for HCI UART (H4) is 1002.
+constexpr FileHeaderType kBtSnoopFileHeader = {
+    .identification_pattern = {'b', 't', 's', 'n', 'o', 'o', 'p', 0x00},
+    .version_number = kBtSnoopVersionNumber,
+    .datalink_type = kBtSnoopDatalinkType};
+
+// Default number of packets per btsnoop file before rotation. Two snoop files
+// are rotated, and the size can be dynamically configured via a system
+// property. Changes take effect after toggling Bluetooth off and on.
+constexpr size_t kDefaultBtSnoopMaxPacketsPerFile = 0xffff;
+
+constexpr std::string_view kLogDirectory = "/data/vendor/bluetooth";
+constexpr std::string_view kLogFilePrefix = "btsnoop_hci_vnd";
+constexpr std::string_view kBtLogPathPrefix =
+    "/data/vendor/bluetooth/btsnoop_hci_vnd";
+constexpr int kMaxLogFileCount = 10;
+
+// Truncate to certain length for packet types that need to be filtered.
+constexpr int kFilteredPacketLength = 32;
+
+uint64_t Htonll(uint64_t ll) {
+  if constexpr (kIsLittleEndian) {
+    return static_cast<uint64_t>(htonl(ll & 0xffffffff)) << 32 |
+           htonl(ll >> 32);
+  } else {
+    return ll;
+  }
+}
+
+std::string GetLogPathWithTimeStamp(std::string_view prefix) {
+  std::chrono::time_point now = std::chrono::system_clock::now();
+  time_t in_time_t = std::chrono::system_clock::to_time_t(now);
+  std::tm* time_info = std::localtime(&in_time_t);
+
+  std::stringstream ss;
+  ss << prefix << "-" << std::put_time(time_info, "%Y-%m-%d_%H-%M-%S.log");
+
+  return ss.str();
+}
+
+bool IsVndSnoopLogEnabled() {
+  const std::string btsnoop_log_mode = android::base::GetProperty(
+      Property::kBtSnoopLogMode,
+      HalConfigLoader::GetLoader().IsUserDebugOrEngBuild() ? "filtered"
+                                                           : "disabled");
+  const bool is_enabled = android::base::GetBoolProperty(
+      Property::kBtVendorSnoopEnabledProperty, false);
+  return btsnoop_log_mode != "disabled" && is_enabled;
+}
+
+size_t GetMaxPacketsPerFile() {
+  const size_t max_packets_per_file = android::base::GetUintProperty<uint64_t>(
+      Property::kBtSnoopMaxPacketsPerFileProperty,
+      kDefaultBtSnoopMaxPacketsPerFile);
+  LOG(INFO) << __func__
+            << ": Vendor btsnoop max packets: " << max_packets_per_file << ".";
+  return max_packets_per_file;
+}
+
+}  // namespace
+
+class LoggerTask {
+ public:
+  enum class LoggerTaskType : int {
+    kStartNewRecording = 1,
+    kStopRecording = 2,
+    kCapture = 3,
+  };
+
+  struct CaptureArgs {
+    HalPacket packet;
+    VndSnoopLogger::Direction direction;
+    uint64_t timestamp_us;
+
+    CaptureArgs(const HalPacket& packet, VndSnoopLogger::Direction direction,
+                uint64_t timestamp_us)
+        : packet(packet), direction(direction), timestamp_us(timestamp_us) {}
+  };
+
+  static LoggerTask StartNewRecordingTask() {
+    return LoggerTask{LoggerTaskType::kStartNewRecording, {}};
+  }
+
+  static LoggerTask StopRecordingTask() {
+    return LoggerTask{LoggerTaskType::kStopRecording, {}};
+  }
+
+  static LoggerTask CaptureTask(const HalPacket& packet,
+                                VndSnoopLogger::Direction direction,
+                                uint64_t timestamp_us) {
+    return LoggerTask{LoggerTaskType::kCapture,
+                      CaptureArgs{packet, direction, timestamp_us}};
+  }
+  LoggerTaskType type_;
+  std::optional<CaptureArgs> args_;
+
+ private:
+  LoggerTask(LoggerTaskType type, std::optional<CaptureArgs> args)
+      : type_(type), args_(std::move(args)) {}
+};
+
+class LoggerHandler {
+ public:
+  LoggerHandler() {
+    logger_thread_ = std::make_unique<Worker<LoggerTask>>(
+        std::bind_front(&LoggerHandler::TaskHandler, this));
+  }
+
+  ~LoggerHandler() {
+    logger_thread_.reset();
+    CloseCurrentLogFile();
+  }
+
+  static LoggerHandler& GetHandler() {
+    static LoggerHandler handler;
+    return handler;
+  }
+
+  void Post(LoggerTask task) { logger_thread_->Post(std::move(task)); }
+
+ private:
+  enum class State : int {
+    kStoppedOrDisabled = 0,
+    kRecording,
+  };
+
+  void TaskHandler(LoggerTask task) {
+    switch (task.type_) {
+      case LoggerTask::LoggerTaskType::kStartNewRecording:
+        StartNewRecording();
+        break;
+      case LoggerTask::LoggerTaskType::kStopRecording:
+        StopRecording();
+        break;
+      case LoggerTask::LoggerTaskType::kCapture:
+        if (task.args_.has_value()) {
+          Capture(task.args_->packet, task.args_->direction,
+                  task.args_->timestamp_us);
+        }
+        break;
+      default:
+        LOG(ERROR) << "Unknown task type: " << static_cast<int>(task.type_);
+        break;
+    }
+  }
+
+  void StartNewRecording() {
+    LOG(INFO) << __func__ << ": Start Recording bluetooth.";
+    log_file_path_ = GetLogPathWithTimeStamp(kBtLogPathPrefix);
+    max_packets_per_file_ = GetMaxPacketsPerFile();
+
+    const bool enabled = IsVndSnoopLogEnabled();
+    LOG(INFO) << __func__ << ": Vendor btsnoop log enabled: " << enabled << ".";
+    if (enabled) {
+      PrepareNewLogFile();
+      state_ = State::kRecording;
+    } else {
+      os::DeleteOldestFiles(kLogDirectory, kLogFilePrefix, 0);
+      state_ = State::kStoppedOrDisabled;
+    }
+  }
+
+  void StopRecording() {
+    LOG(INFO) << __func__ << ": Close btsnoop log data at " << log_file_path_
+              << ".";
+    CloseCurrentLogFile();
+    state_ = State::kStoppedOrDisabled;
+  }
+
+  void Capture(const HalPacket& packet, VndSnoopLogger::Direction direction,
+               uint64_t timestamp_us) {
+    if (state_ == State::kStoppedOrDisabled) {
+      return;
+    }
+
+    const HciPacketType type = packet.GetType();
+    const std::vector<uint8_t> payload = packet.GetBody();
+
+    // Set btsnoop packet flags:
+    // Bit 0: Direction (0 for Sent/Outgoing, 1 for Received/Incoming)
+    // Bit 1: Type (0 for Data, 1 for Command/Event)
+    uint32_t flags = 0;
+    // Set filtered for data packet types.
+    bool filtered = false;
+    switch (type) {
+      case HciPacketType::kCommand:
+        flags |= (1 << 1);
+        break;
+      case HciPacketType::kEvent:
+        flags |= (1 << 0);
+        flags |= (1 << 1);
+        break;
+      case HciPacketType::kAclData:
+      case HciPacketType::kIsoData:
+      case HciPacketType::kScoData:
+      case HciPacketType::kThreadData:
+        if (direction == VndSnoopLogger::Direction::kIncoming) {
+          flags |= (1 << 0);
+        }
+        filtered = true;
+        break;
+      default:
+        break;
+    }
+
+    uint32_t captured_length = packet.size();
+    if (filtered && captured_length > kFilteredPacketLength) {
+      captured_length = kFilteredPacketLength;
+    }
+    PacketHeaderType header = {
+        .length_original = htonl(packet.size()),
+        .length_captured = htonl(captured_length),
+        .flags = htonl(flags),
+        .dropped_packets = 0,
+        .timestamp = Htonll(timestamp_us + kBtSnoopEpochDelta),
+        .type = static_cast<uint8_t>(type)};
+
+    if (++packet_counter_ > max_packets_per_file_) {
+      LOG(INFO) << __func__
+                << ": Reach max packet per file, open new log file.";
+      PrepareNewLogFile();
+    }
+
+    if (!log_ostream_.write(reinterpret_cast<const char*>(&header),
+                            sizeof(PacketHeaderType))) {
+      LOG(ERROR) << __func__
+                 << ": Failed to write packet header for btsnoop, error: \""
+                 << strerror(errno) << "\".";
+      return;
+    }
+
+    // -1 for type byte.
+    const char* packet_data = reinterpret_cast<const char*>(payload.data());
+    if (!log_ostream_.write(packet_data, captured_length - 1)) {
+      LOG(ERROR) << __func__
+                 << ": Failed to write packet payload for btsnoop, error: \""
+                 << strerror(errno) << "\".";
+    }
+
+    if (!log_ostream_.flush()) {
+      LOG(ERROR) << __func__ << ": Failed to flush, error: \""
+                 << strerror(errno) << "\".";
+    }
+  }
+
+  void CloseCurrentLogFile() {
+    os::CloseLogFileStream(log_ostream_);
+    packet_counter_ = 0;
+  }
+
+  void OpenNewLogFile() {
+    const mode_t previous_umask = umask(0);
+    // Open file in binary write mode, without append, to overwrite existing
+    // data.
+    log_ostream_.open(log_file_path_, std::ios::binary | std::ios::out);
+
+    // Set file permissions to OWNER Read/Write, GROUP Read, OTHER Read.
+    if (chmod(log_file_path_.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) !=
+        0) {
+      LOG(ERROR) << __func__ << ": Unable to change file permissions for "
+                 << log_file_path_ << ".";
+    }
+
+    if (!log_ostream_.is_open()) {
+      LOG(ERROR) << __func__ << ": Unable to open snoop log at \""
+                 << log_file_path_ << "\", error: \"" << strerror(errno)
+                 << "\".";
+    }
+
+    umask(previous_umask);
+
+    if (!log_ostream_.write(reinterpret_cast<const char*>(&kBtSnoopFileHeader),
+                            sizeof(FileHeaderType))) {
+      LOG(ERROR) << __func__ << ": Unable to write file header to \""
+                 << log_file_path_ << "\", error: \"" << strerror(errno)
+                 << "\".";
+    }
+
+    if (!log_ostream_.flush()) {
+      LOG(ERROR) << __func__ << ": Failed to flush, error: \""
+                 << strerror(errno) << "\".";
+    }
+
+    LOG(INFO) << __func__ << ": Open new btsnoop log file at " << log_file_path_
+              << ".";
+  }
+
+  void PrepareNewLogFile() {
+    CloseCurrentLogFile();
+    os::DeleteOldestFiles(kLogDirectory, kLogFilePrefix, kMaxLogFileCount - 1);
+    OpenNewLogFile();
+  }
+
+  std::ofstream log_ostream_;
+  std::string log_file_path_;
+  State state_{State::kStoppedOrDisabled};
+  size_t max_packets_per_file_{0};
+  size_t packet_counter_{0};
+  std::unique_ptr<Worker<LoggerTask>> logger_thread_;
+};
+
+class VndSnoopLoggerImpl : public VndSnoopLogger {
+ public:
+  ~VndSnoopLoggerImpl() override = default;
+  void StartNewRecording() override;
+  void StopRecording() override;
+  void Capture(const ::bluetooth_hal::hci::HalPacket& packet,
+               Direction direction) override;
+};
+
+VndSnoopLogger& VndSnoopLogger::GetLogger() {
+  static VndSnoopLoggerImpl logger;
+  return logger;
+}
+
+void VndSnoopLoggerImpl::Capture(const HalPacket& packet, Direction direction) {
+  uint64_t timestamp_us =
+      std::chrono::duration_cast<std::chrono::microseconds>(
+          std::chrono::system_clock::now().time_since_epoch())
+          .count();
+  LoggerHandler::GetHandler().Post(
+      LoggerTask::CaptureTask(packet, direction, timestamp_us));
+}
+
+void VndSnoopLoggerImpl::StartNewRecording() {
+  LoggerHandler::GetHandler().Post(LoggerTask::StartNewRecordingTask());
+}
+
+void VndSnoopLoggerImpl::StopRecording() {
+  LoggerHandler::GetHandler().Post(LoggerTask::StopRecordingTask());
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc.cc
new file mode 100644
index 0000000000..fda117adcd
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc.cc
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.ccc"
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc.h"
+
+#include <array>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "aidl/hardware/google/bluetooth/ccc/BnBluetoothCcc.h"
+#include "aidl/hardware/google/bluetooth/ccc/IBluetoothCccCallback.h"
+#include "android-base/logging.h"
+#include "android/binder_auto_utils.h"
+#include "android/binder_status.h"
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+namespace {
+
+using ::aidl::hardware::google::bluetooth::ccc::Direction;
+using ::aidl::hardware::google::bluetooth::ccc::IBluetoothCccCallback;
+using ::aidl::hardware::google::bluetooth::ccc::LmpEventId;
+using ::aidl::hardware::google::bluetooth::ccc::Timestamp;
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::ndk::ScopedAStatus;
+
+using ScopedDeathRecipient =
+    std::unique_ptr<AIBinder_DeathRecipient,
+                    void (*)(AIBinder_DeathRecipient*)>;
+
+ScopedDeathRecipient MakeScopedDeathRecipient(
+    AIBinder_DeathRecipient* death_recipient) {
+  return ScopedDeathRecipient(death_recipient, &AIBinder_DeathRecipient_delete);
+}
+
+class BluetoothCccDeathRecipient {
+ public:
+  BluetoothCccDeathRecipient(const BluetoothAddress& address)
+      : is_dead_(false),
+        ccc_callback_(nullptr),
+        client_death_recipient_(MakeScopedDeathRecipient(nullptr)),
+        address_(address) {}
+
+  void LinkToDeath(const std::shared_ptr<IBluetoothCccCallback>& cb) {
+    ccc_callback_ = cb;
+
+    auto on_link_died = [](void* cookie) {
+      auto* death_recipient = static_cast<BluetoothCccDeathRecipient*>(cookie);
+      death_recipient->ServiceDied();
+    };
+    client_death_recipient_ =
+        MakeScopedDeathRecipient(AIBinder_DeathRecipient_new(on_link_died));
+
+    binder_status_t link_to_death_return_status =
+        AIBinder_linkToDeath(ccc_callback_->asBinder().get(),
+                             client_death_recipient_.get(), this /* cookie */);
+    if (link_to_death_return_status != STATUS_OK) {
+      LOG(FATAL) << "Unable to link to death recipient";
+    }
+  }
+
+  void UnlinkToDeath() {
+    if (!is_dead_) {
+      binder_status_t unlink_to_death_return_status = AIBinder_unlinkToDeath(
+          ccc_callback_->asBinder().get(), client_death_recipient_.get(), this);
+      if (unlink_to_death_return_status != STATUS_OK) {
+        LOG(FATAL) << "Unable to unlink to death recipient";
+      }
+    }
+    client_death_recipient_.reset();
+  }
+
+  void ServiceDied() {
+    LOG(WARNING) << __func__ << ": BluetoothCccDeathRecipient::serviceDied";
+    is_dead_ = true;
+    BluetoothCccHandler::GetHandler().UnregisterLmpEvents(
+        BluetoothAddress(address_));
+  }
+
+ private:
+  bool is_dead_;
+  std::shared_ptr<IBluetoothCccCallback> ccc_callback_;
+  ScopedDeathRecipient client_death_recipient_;
+  BluetoothAddress address_;
+};
+
+class BluetoothCccHandlerCallbackImpl : public BluetoothCccHandlerCallback {
+ public:
+  explicit BluetoothCccHandlerCallbackImpl(
+      const std::shared_ptr<IBluetoothCccCallback>& bluetooth_ccc_callback,
+      const BluetoothAddress& address,
+      const std::vector<CccLmpEventId>& lmp_event_ids,
+      const std::shared_ptr<BluetoothCccDeathRecipient> death_recipient)
+      : BluetoothCccHandlerCallback(address, lmp_event_ids),
+        bluetooth_ccc_callback_(bluetooth_ccc_callback),
+        death_recipient_(death_recipient) {
+    death_recipient_->LinkToDeath(bluetooth_ccc_callback_);
+  }
+
+  ~BluetoothCccHandlerCallbackImpl() { death_recipient_->UnlinkToDeath(); }
+
+  void OnEventGenerated(const CccTimestamp& timestamp,
+                        const BluetoothAddress& address, CccDirection direction,
+                        CccLmpEventId lmp_event_id,
+                        uint8_t event_counter) override {
+    if (bluetooth_ccc_callback_ == nullptr) {
+      return;
+    }
+    bluetooth_ccc_callback_->onEventGenerated(
+        Timestamp(timestamp.system_time, timestamp.bluetooth_time), address,
+        static_cast<Direction>(direction),
+        static_cast<LmpEventId>(lmp_event_id), event_counter);
+  }
+
+  void OnRegistered(bool status) override {
+    if (bluetooth_ccc_callback_ == nullptr) {
+      return;
+    }
+    bluetooth_ccc_callback_->onRegistered(status);
+  }
+
+ private:
+  const std::shared_ptr<IBluetoothCccCallback>& bluetooth_ccc_callback_;
+  const std::shared_ptr<BluetoothCccDeathRecipient> death_recipient_;
+};
+
+std::vector<CccLmpEventId> LmpEventCast(
+    const std::vector<LmpEventId>& event_ids) {
+  std::vector<CccLmpEventId> ccc_event_ids;
+  for (const auto& event_id : event_ids) {
+    ccc_event_ids.push_back(static_cast<CccLmpEventId>(event_id));
+  }
+  return ccc_event_ids;
+}
+
+}  // namespace
+
+ScopedAStatus BluetoothCcc::registerForLmpEvents(
+    const std::shared_ptr<IBluetoothCccCallback>& callback,
+    const std::array<uint8_t, 6>& address,
+    const std::vector<LmpEventId>& lmpEventIds) {
+  const auto lmp_event_ids = LmpEventCast(lmpEventIds);
+  const auto bluetooth_address = BluetoothAddress(address);
+  const auto death_recipient =
+      std::make_shared<BluetoothCccDeathRecipient>(bluetooth_address);
+  bool status = BluetoothCccHandler::GetHandler().RegisterForLmpEvents(
+      std::make_unique<BluetoothCccHandlerCallbackImpl>(
+          callback, bluetooth_address, lmp_event_ids, death_recipient));
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromExceptionCode(EX_NULL_POINTER);
+}
+
+ScopedAStatus BluetoothCcc::unregisterLmpEvents(
+    const std::array<uint8_t, 6>& address) {
+  bool status = BluetoothCccHandler::GetHandler().UnregisterLmpEvents(
+      BluetoothAddress(address));
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromExceptionCode(EX_NULL_POINTER);
+}
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.cc
new file mode 100644
index 0000000000..08816cb3f7
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.cc
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.ccc"
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.h"
+
+#include <fcntl.h>
+
+#include <array>
+#include <chrono>
+#include <cstdint>
+#include <memory>
+#include <string_view>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_callback.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+namespace {
+
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::bluetooth_hal::hci::EventCode;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciEventMonitor;
+using ::bluetooth_hal::hci::HciMonitor;
+using ::bluetooth_hal::hci::MonitorMode;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+constexpr std::string_view kTimesyncProcNode = "/proc/bluetooth/timesync";
+constexpr std::chrono::seconds kPendingCallbackTimeout =
+    std::chrono::seconds(3);
+
+}  // namespace
+
+BluetoothCccHandler::BluetoothCccHandler() {
+  // Register monitor for CCC LMP events.
+  HciEventMonitor ccc_lmp_event_monitor(
+      static_cast<uint8_t>(EventCode::kVendorSpecific),
+      static_cast<uint8_t>(TimesyncConstants::kSubEventCode),
+      static_cast<int>(TimesyncEventOffset::kSubEventCode));
+  RegisterMonitor(ccc_lmp_event_monitor, MonitorMode::kIntercept);
+}
+
+BluetoothCccHandler& BluetoothCccHandler::GetHandler() {
+  static BluetoothCccHandler handler;
+  return handler;
+}
+
+bool BluetoothCccHandler::RegisterForLmpEvents(
+    const std::shared_ptr<BluetoothCccHandlerCallback>& callback) {
+  std::unique_lock<std::mutex> lock(mutex_);
+  const auto address = callback->GetAddress();
+  const auto lmp_event_ids = callback->GetLmpEventIds();
+
+  if (!IsBluetoothEnabled() || callback == nullptr || lmp_event_ids.empty()) {
+    LOG(WARNING) << __func__ << ": Unable to register for LMP events";
+    return false;
+  }
+
+  auto lmp_event_size = lmp_event_ids.size();
+  if (lmp_event_size == 0 ||
+      lmp_event_size > static_cast<size_t>(CccLmpEventId::kMax)) {
+    LOG(WARNING) << __func__
+                 << ": Incorrect size LMP events:" << lmp_event_size;
+    return false;
+  }
+  LOG(INFO) << __func__ << ": address: " << address.ToString();
+
+  // Push the callback to the pending queue to wait for the command complete
+  // event.
+  pending_callbacks_deque_.emplace_back(callback);
+  auto command = BluetoothCccTimesyncCommand::CreateAddCommand(
+      address, AddressType::kRandom, CccDirection::kTx, lmp_event_ids);
+  return SendCommand(command);
+}
+
+bool BluetoothCccHandler::UnregisterLmpEvents(const BluetoothAddress& address) {
+  std::unique_lock<std::mutex> lock(mutex_);
+  LOG(INFO) << __func__ << ": address: " << address.ToString();
+
+  if (!IsBluetoothEnabled()) {
+    LOG(WARNING) << __func__
+                 << ": Bluetooth is OFF, unable to unregister for LMP events";
+    return false;
+  }
+
+  // If there is a pending callback waiting for command complete event, wait
+  // for it.
+  if (!pending_callbacks_cv_.wait_for(lock, kPendingCallbackTimeout, [&] {
+        return pending_callbacks_deque_.empty();
+      })) {
+    LOG(FATAL) << "Timeout: pending_callbacks_deque_ was not empty!";
+  }
+
+  std::vector<BluetoothAddress> removed_addresses;
+  auto it = std::remove_if(
+      monitor_callbacks_.begin(), monitor_callbacks_.end(),
+      [&address, &removed_addresses](
+          const std::shared_ptr<BluetoothCccHandlerCallback>& callback) {
+        if (callback->IsAddressEqual(address)) {
+          removed_addresses.push_back(address);
+          return true;
+        }
+        return false;
+      });
+
+  if (removed_addresses.empty()) {
+    LOG(WARNING) << __func__
+                 << ": was not registered for address: " << address.ToString();
+    return false;
+  }
+  monitor_callbacks_.erase(it, monitor_callbacks_.end());
+
+  bool all_success = true;
+  for (const auto& removed_address : removed_addresses) {
+    auto command = BluetoothCccTimesyncCommand::CreateRemoveCommand(
+        removed_address, AddressType::kRandom);
+    if (!SendCommand(command)) {
+      LOG(WARNING) << __func__
+                   << ": Failed to send REMOVE command for address: "
+                   << removed_address.ToString();
+      all_success = false;
+    }
+  }
+
+  return all_success;
+}
+
+void BluetoothCccHandler::OnCommandCallback(const HalPacket& packet) {
+  std::unique_lock<std::mutex> lock(mutex_);
+  bool success = (packet.GetCommandCompleteEventResult() ==
+                  static_cast<uint8_t>(EventResultCode::kSuccess));
+  if (success) {
+    LOG(INFO) << __func__ << ": event status: Success";
+  } else {
+    LOG(WARNING) << __func__ << ": event status: Failed!";
+  }
+
+  if (pending_callbacks_deque_.empty()) {
+    // Pending queue is empty, which means the event is for a REMOVE or CLEAR
+    // command.
+    return;
+  }
+
+  // Command complete received, remove the callback from the pending queue.
+  auto callback = std::move(pending_callbacks_deque_.front());
+  pending_callbacks_deque_.pop_front();
+
+  callback->OnRegistered(success);
+
+  if (success) {
+    // if the command complete event is success, keep the callback in
+    // monitor_callbacks to look for DCK time sync events.
+    monitor_callbacks_.push_back(std::move(callback));
+  }
+  pending_callbacks_cv_.notify_one();
+}
+
+void BluetoothCccHandler::OnMonitorPacketCallback(
+    [[maybe_unused]] MonitorMode mode, const HalPacket& packet) {
+  std::unique_lock<std::mutex> lock(mutex_);
+  if (monitor_callbacks_.empty()) {
+    return;
+  }
+
+  BluetoothCccTimesyncEvent time_sync_event(packet);
+  if (!time_sync_event.IsValid()) {
+    LOG(WARNING) << __func__ << ": Invalid time sync event!";
+    return;
+  }
+
+  uint8_t toggle_count = time_sync_event.GetToggleCount();
+  uint16_t timesync_offset = time_sync_event.GetTimesyncOffset();
+  uint64_t system_time = GetSystemTime(toggle_count, timesync_offset);
+  if (system_time == 0) {
+    LOG(WARNING) << __func__ << ": Invalid system time, drop the report.";
+    return;
+  }
+  CccTimestamp timestamp(static_cast<long>(system_time),
+                         static_cast<long>(time_sync_event.GetTimestamp()));
+
+  auto address = time_sync_event.GetAddress();
+  auto direction = time_sync_event.GetDirection();
+  auto lmp_event_id = time_sync_event.GetEventId();
+  uint8_t event_counter = time_sync_event.GetEventCount();
+
+  LOG(INFO) << "Recv address: " << address.ToString()
+            << ", direction: " << static_cast<int>(direction)
+            << ", lmp_event_id: " << static_cast<int>(lmp_event_id)
+            << ", event_counter: " << static_cast<int>(event_counter)
+            << ", toggle_count: " << static_cast<int>(toggle_count)
+            << ", timesync_offset: " << timesync_offset
+            << ", bluetooth_time: " << timestamp.bluetooth_time
+            << ", system_time: " << timestamp.system_time;
+
+  for (const auto& callback : monitor_callbacks_) {
+    if (callback->IsAddressEqual(address) &&
+        callback->ContainsEventId(lmp_event_id)) {
+      callback->OnEventGenerated(timestamp, address, direction, lmp_event_id,
+                                 event_counter);
+    }
+  }
+}
+
+void BluetoothCccHandler::OnBluetoothEnabled() {
+  std::unique_lock<std::mutex> lock(mutex_);
+  // Clear all pending time sync data from the timesync fd.
+  for (uint64_t time = -1; time != 0;) {
+    time = GetSystemTime(1, 0);
+  }
+  previous_toggle_count_ = 0;
+}
+
+void BluetoothCccHandler::OnBluetoothDisabled() {
+  std::unique_lock<std::mutex> lock(mutex_);
+  monitor_callbacks_.clear();
+  previous_toggle_count_ = 0;
+  while (!pending_callbacks_deque_.empty()) {
+    pending_callbacks_deque_.front()->OnRegistered(false);
+    pending_callbacks_deque_.pop_front();
+  }
+}
+
+uint64_t BluetoothCccHandler::GetSystemTime(uint8_t current_toggle_count,
+                                            uint16_t offset) {
+  int fd = 0;
+  if ((fd = SystemCallWrapper::GetWrapper().Open(kTimesyncProcNode.data(),
+                                                 O_RDONLY)) < 0) {
+    LOG(WARNING) << __func__ << ": Unable to open timesync node";
+    return 0;
+  }
+
+  // Calculate the difference using modular arithmetic to handle overflow
+  // This correctly calculates the number of increments, even if
+  // current_toggle_count wrapped around.
+  uint8_t toggle_count = current_toggle_count - previous_toggle_count_;
+  previous_toggle_count_ = current_toggle_count;
+
+  char buff[TimesyncConstants::kUint64MaxDigitInDec];
+  for (uint8_t i = 0; i < toggle_count; i++) {
+    // The LMP commands can be sent multiple times to the air and we only care
+    // about one that success, which is the one that toggle count points to.
+    SystemCallWrapper::GetWrapper().Read(
+        fd, buff, TimesyncConstants::kUint64MaxDigitInDec);
+  }
+  SystemCallWrapper::GetWrapper().Close(fd);
+
+  uint64_t system_time = static_cast<uint64_t>(strtoul(buff, nullptr, 0));
+  if (system_time > offset) {
+    system_time -= offset;
+  }
+
+  return system_time;
+}
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_test.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_test.cc
new file mode 100644
index 0000000000..c91b9865fd
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_test.cc
@@ -0,0 +1,447 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.h"
+
+#include <chrono>
+#include <cstdint>
+#include <memory>
+#include <thread>
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_callback.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "bluetooth_hal/test/mock/mock_system_call_wrapper.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+namespace {
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+using ::bluetooth_hal::hci::MonitorMode;
+using ::bluetooth_hal::util::MockSystemCallWrapper;
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Invoke;
+using ::testing::NotNull;
+using ::testing::Return;
+using ::testing::SetArrayArgument;
+using ::testing::Test;
+
+class BluetoothCccHandlerTestInstance : public BluetoothCccHandler {
+ public:
+  void OnCommandCallback(const HalPacket& packet) override {
+    BluetoothCccHandler::OnCommandCallback(packet);
+  }
+
+  void EnableBluetooth() {
+    OnBluetoothChipReady();
+    OnBluetoothEnabled();
+    OnHalStateChanged(HalState::kRunning, HalState::kBtChipReady);
+    OnPacketCallback(HalPacket({0x04, 0x0E, 0x04, 0x01, 0x03, 0x0C, 0x00}));
+  }
+
+  void DisableBluetooth() {
+    OnBluetoothDisabled();
+    OnBluetoothChipClosed();
+  }
+};
+
+class MockCallbackVerifier : public BluetoothCccHandlerCallback {
+ public:
+  MockCallbackVerifier()
+      : BluetoothCccHandlerCallback(BluetoothAddress({}),
+                                    std::vector<CccLmpEventId>()) {}
+  MOCK_METHOD(void, OnEventGenerated,
+              (const CccTimestamp& timestamp, const BluetoothAddress& address,
+               CccDirection direction, CccLmpEventId lmp_event_id,
+               uint8_t event_counter),
+              (override));
+  MOCK_METHOD(void, OnRegistered, (bool status), (override));
+};
+
+class MockBluetoothCccHandlerCallback : public BluetoothCccHandlerCallback {
+ public:
+  MockBluetoothCccHandlerCallback(
+      BluetoothAddress& address, std::vector<CccLmpEventId> lmp_ids,
+      std::shared_ptr<MockCallbackVerifier> verifier)
+      : BluetoothCccHandlerCallback(address, lmp_ids), verifier_(verifier) {};
+
+  void OnEventGenerated(const CccTimestamp& timestamp,
+                        const BluetoothAddress& address, CccDirection direction,
+                        CccLmpEventId lmp_event_id,
+                        uint8_t event_counter) override {
+    verifier_->OnEventGenerated(timestamp, address, direction, lmp_event_id,
+                                event_counter);
+  }
+
+  void OnRegistered(bool status) override { verifier_->OnRegistered(status); }
+
+ private:
+  std::shared_ptr<MockCallbackVerifier> verifier_;
+};
+
+class BluetoothCccHandlerTest : public Test {
+ protected:
+  static void SetUpTestSuite() {}
+
+  void SetUp() override {
+    MockSystemCallWrapper::SetMockWrapper(&mock_system_call_wrapper_);
+    ON_CALL(mock_system_call_wrapper_, Open(_, _)).WillByDefault(Return(1));
+
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    EXPECT_CALL(mock_hci_router_client_agent_, RegisterRouterClient(NotNull()))
+        .WillOnce(Return(true));
+
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    ON_CALL(mock_hci_router_, Send(_)).WillByDefault(Return(true));
+    ON_CALL(mock_hci_router_, SendCommand(_, _)).WillByDefault(Return(true));
+
+    ccc_handler_ = new BluetoothCccHandlerTestInstance();
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mock_hci_router_client_agent_,
+                UnregisterRouterClient(ccc_handler_))
+        .WillOnce(Return(true));
+    delete (ccc_handler_);
+  }
+
+  void EnableBluetooth() {
+    ON_CALL(mock_hci_router_, GetHalState())
+        .WillByDefault(Return(HalState::kRunning));
+    ON_CALL(mock_system_call_wrapper_, Read(_, _, _)).WillByDefault(Return(0));
+
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(true));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+        .WillByDefault(Return(true));
+    ccc_handler_->EnableBluetooth();
+
+    ON_CALL(mock_system_call_wrapper_, Read(_, _, _))
+        .WillByDefault(
+            Invoke([&]([[maybe_unused]] int fd, void* buf, size_t count) {
+              size_t bytes_to_copy = std::min(count, sizeof(timestamp_data_));
+              std::memcpy(buf, timestamp_data_, bytes_to_copy);
+              return static_cast<int>(bytes_to_copy);
+            }));
+  }
+
+  void DisableBluetooth() {
+    ON_CALL(mock_hci_router_, GetHalState())
+        .WillByDefault(Return(HalState::kBtChipReady));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(false));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+        .WillByDefault(Return(false));
+    ccc_handler_->DisableBluetooth();
+  }
+
+  HalPacket GenerateTimesyncCommandCompleteEvent(bool success) {
+    uint8_t status = (success ? 0x00 : 0x01);
+    return HalPacket({0x04, 0x0E, 0x04, 0x01, 0x63, 0xFD, status});
+  }
+
+  BluetoothCccTimesyncEvent CreateTimesyncEvent(BluetoothAddress& address,
+                                                uint8_t toggle_count = 0x01) {
+    auto packet =
+        HalPacket({0x04,  // HCI Event (1 byte)
+                   0xFF,  // Vendor event code (1 byte)
+                   0x17,  // Length (1 byte - 23 decimal, payload length)
+                   0xD0,  // Time sync sub event code (1 byte)
+
+                   address[5], address[4], address[3], address[2], address[1],
+                   address[0],  // Address (6 bytes)
+
+                   0x01,  // AddressType (1 byte - Random)
+                   0x00,  // Direction (1 byte - Tx)
+
+                   // Timestamp (8 bytes - 0xAABBCCDDEEFF0011, little-endian)
+                   0x11, 0x00, 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA,
+
+                   0xFF,          // EventId (1 byte - EventIdConnInd)
+                   toggle_count,  // ToggleCount (1 byte)
+
+                   // Timesync offset (2 bytes - 0x1234, little-endian)
+                   0x34, 0x12,
+
+                   // Event count (2 bytes - 0x5678, little-endian)
+                   0x78, 0x56});
+
+    return BluetoothCccTimesyncEvent(packet);
+  }
+
+  MockHciRouter mock_hci_router_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+  MockSystemCallWrapper mock_system_call_wrapper_;
+  char timestamp_data_[20] = {'1', '0', '0', '0', '0', '0', '0', '0', '0', '0'};
+  BluetoothCccHandlerTestInstance* ccc_handler_;
+  BluetoothAddress address_ = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
+  BluetoothAddress different_address_ = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+};
+
+TEST_F(BluetoothCccHandlerTest, HandleRegisterForLmpEventsSuccess) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(2);
+  EXPECT_CALL(*mock_callback, OnRegistered(true)).Times(1);
+
+  EXPECT_FALSE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  EnableBluetooth();
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  EXPECT_TRUE(ccc_handler_->UnregisterLmpEvents(address_));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleRegisterForLmpEventsFailed) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(1);
+  EXPECT_CALL(*mock_callback, OnRegistered(false)).Times(1);
+
+  EXPECT_FALSE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  EnableBluetooth();
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(false));
+
+  // This UnregisterLmpEvents does not invoke SendCommand to the HciRouter due
+  // to the failure in the command complete event for the RegisterForLmpEvents.
+  EXPECT_FALSE(ccc_handler_->UnregisterLmpEvents(address_));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(false));
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleRegisterForLmpEventsEmptyLmpEvent) {
+  std::vector<CccLmpEventId> lmp_ids = {};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+  EnableBluetooth();
+  EXPECT_FALSE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleRegisterForLmpEventsTooManyLmpEvent) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd,
+                                        CccLmpEventId::kMax};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+  EnableBluetooth();
+  EXPECT_FALSE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleUnregisterLmpEventsDefault) {
+  EXPECT_FALSE(ccc_handler_->UnregisterLmpEvents(address_));
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleUnregisterLmpEventsWhenBluetoothOff) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(1);
+  EXPECT_CALL(*mock_callback, OnRegistered(true)).Times(1);
+
+  EnableBluetooth();
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  DisableBluetooth();
+  EXPECT_FALSE(ccc_handler_->UnregisterLmpEvents(address_));
+}
+
+TEST_F(BluetoothCccHandlerTest,
+       HandleUnregisterLmpEventsBeforeCommandComplete) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(2);
+  EXPECT_CALL(*mock_callback, OnRegistered(true)).Times(1);
+
+  EnableBluetooth();
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  std::thread event_thread([this]() {
+    std::this_thread::sleep_for(std::chrono::milliseconds(50));
+    ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+  });
+  event_thread.detach();
+  // The thread should be blocked in UnregisterLmpEvents until the command
+  // complete event is received.
+  EXPECT_TRUE(ccc_handler_->UnregisterLmpEvents(address_));
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleMonitoringTimeSyncEvent) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+  auto timesync_event = CreateTimesyncEvent(address_);
+
+  // One additional system wrapper invoke for Enabling BT
+  EXPECT_CALL(mock_system_call_wrapper_, Open(_, _)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Read(_, _, _)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(2);
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(2);
+  EXPECT_CALL(*mock_callback, OnRegistered(true)).Times(1);
+  EXPECT_CALL(*mock_callback, OnEventGenerated(_, address_, _, _, _)).Times(1);
+
+  // timesync event before register for LMP event, should not trigger a
+  // callback.
+  ccc_handler_->OnPacketCallback(timesync_event);
+
+  // Register LMP event for address_
+  EnableBluetooth();
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+
+  // timesync event before register complete, should not trigger a callback.
+  ccc_handler_->OnPacketCallback(timesync_event);
+
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  // timesync event after register complete, should trigger a callback.
+  ccc_handler_->OnPacketCallback(timesync_event);
+
+  EXPECT_TRUE(ccc_handler_->UnregisterLmpEvents(address_));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  // timesync event after unregistery, should not trigger a callback.
+  ccc_handler_->OnPacketCallback(timesync_event);
+}
+
+TEST_F(BluetoothCccHandlerTest,
+       HandleMonitoringTimeSyncEventWithDifferentAddress) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+  auto timesync_event = CreateTimesyncEvent(different_address_);
+
+  // One additional system wrapper invoke for Enabling BT
+  EXPECT_CALL(mock_system_call_wrapper_, Open(_, _)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Read(_, _, _)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(2);
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(1);
+  EXPECT_CALL(*mock_callback, OnRegistered(true)).Times(1);
+  EXPECT_CALL(*mock_callback, OnEventGenerated(_, _, _, _, _)).Times(0);
+
+  // Register LMP event for address_
+  EnableBluetooth();
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  // timesync event for different_address_, should trigger a callback.
+  ccc_handler_->OnPacketCallback(timesync_event);
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleMonitoringMultipleTimeSyncEvent) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback1 = std::make_shared<MockCallbackVerifier>();
+  auto mock_callback2 = std::make_shared<MockCallbackVerifier>();
+  auto timesync_event1 = CreateTimesyncEvent(address_, 1);
+  auto timesync_event2 = CreateTimesyncEvent(different_address_, 2);
+
+  // One additional system wrapper invoke for Enabling BT
+  EXPECT_CALL(mock_system_call_wrapper_, Open(_, _)).Times(3);
+  EXPECT_CALL(mock_system_call_wrapper_, Read(_, _, _)).Times(3);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(3);
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(2);
+  EXPECT_CALL(*mock_callback1, OnRegistered(true)).Times(1);
+  EXPECT_CALL(*mock_callback2, OnRegistered(true)).Times(1);
+  EXPECT_CALL(*mock_callback1, OnEventGenerated(_, address_, _, _, _)).Times(1);
+  EXPECT_CALL(*mock_callback2, OnEventGenerated(_, different_address_, _, _, _))
+      .Times(1);
+
+  EnableBluetooth();
+  // Register LMP event for address_
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback1)));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  // Register LMP event for different_address_
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(
+          different_address_, lmp_ids, mock_callback2)));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  // timesync events for each callback.
+  ccc_handler_->OnPacketCallback(timesync_event1);
+  ccc_handler_->OnPacketCallback(timesync_event2);
+}
+
+TEST_F(BluetoothCccHandlerTest, HandleMonitoringHighToggleCount) {
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+  auto mock_callback = std::make_shared<MockCallbackVerifier>();
+  auto timesync_event = CreateTimesyncEvent(address_, 10);  // toggle count = 10
+
+  // One additional system wrapper invoke for Enabling BT
+  EXPECT_CALL(mock_system_call_wrapper_, Open(_, _)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Read(_, _, _)).Times(11);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(2);
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(1);
+  EXPECT_CALL(*mock_callback, OnRegistered(true)).Times(1);
+  EXPECT_CALL(*mock_callback, OnEventGenerated(_, address_, _, _, _)).Times(1);
+
+  EnableBluetooth();
+  // Register LMP event for address_
+  EXPECT_TRUE(ccc_handler_->RegisterForLmpEvents(
+      std::make_unique<MockBluetoothCccHandlerCallback>(address_, lmp_ids,
+                                                        mock_callback)));
+  ccc_handler_->OnCommandCallback(GenerateTimesyncCommandCompleteEvent(true));
+
+  // timesync events for each callback.
+  ccc_handler_->OnPacketCallback(timesync_event);
+}
+
+}  // namespace
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.cc
new file mode 100644
index 0000000000..1a2eec9ac5
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.cc
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.h"
+
+#include <cstdint>
+#include <vector>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+namespace {
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+
+static constexpr uint8_t kHeaderSize =
+    4;  // H4 header(1) + opcode(2) + length(1)
+
+static void AppendFixedHeader(HalPacket& packet, uint8_t payload_length) {
+  packet.push_back(static_cast<uint8_t>(HciPacketType::kCommand));
+  packet.push_back(TimesyncConstants::kCommandOpCode & 0xFF);
+  packet.push_back((TimesyncConstants::kCommandOpCode >> 8) & 0xFF);
+  packet.push_back(payload_length);
+}
+
+}  // namespace
+
+HalPacket BluetoothCccTimesyncCommand::CreateAddCommand(
+    const BluetoothAddress& address, const AddressType address_type,
+    const CccDirection direction, const std::vector<CccLmpEventId>& lmp_ids) {
+  // Command Type (1) + Address (6) + Address Type (1) + Direction (1) + LmpId
+  // (X)
+  uint8_t payload_length =
+      TimesyncConstants::kCommandCommandTypeLength + address.size() +
+      TimesyncConstants::kCommandAddressTypeLength +
+      TimesyncConstants::kCommandDirectionLength + lmp_ids.size();
+
+  HalPacket packet;
+  packet.reserve(kHeaderSize + payload_length);  // Fixed header (4) + payload
+  AppendFixedHeader(packet, payload_length);
+
+  // Command-specific Payload
+  packet.push_back(
+      static_cast<uint8_t>(TimesyncCommandType::kAdd));  // Command Type: ADD
+  for (int i = address.size() - 1; i >= 0; --i) {
+    packet.push_back(address[i]);  // Address
+  }
+  packet.push_back(static_cast<uint8_t>(address_type));  // Address Type
+  packet.push_back(static_cast<uint8_t>(direction));     // Direction
+  for (CccLmpEventId id : lmp_ids) {
+    uint8_t byte;
+    switch (id) {
+      case CccLmpEventId::kConnectInd:
+        byte = static_cast<uint8_t>(CccLmpEventIdByte::kConnectInd);
+        break;
+      case CccLmpEventId::kLlPhyUpdateInd:
+        byte = static_cast<uint8_t>(CccLmpEventIdByte::kLlPhyUpdateInd);
+        break;
+      default:
+        byte = static_cast<uint8_t>(CccLmpEventIdByte::kUndefined);
+        break;
+    }
+    packet.push_back(byte);  // LmpId
+  }
+
+  return packet;
+}
+
+HalPacket BluetoothCccTimesyncCommand::CreateRemoveCommand(
+    const BluetoothAddress& address, const AddressType address_type) {
+  // Command Type (1) + Address (6) + AddressType (1)
+  uint8_t payload_length = TimesyncConstants::kCommandCommandTypeLength +
+                           address.size() +
+                           TimesyncConstants::kCommandAddressTypeLength;
+
+  HalPacket packet;
+  packet.reserve(kHeaderSize + payload_length);  // Fixed header (4) + payload
+  AppendFixedHeader(packet, payload_length);
+
+  // Command-specific Payload
+  packet.push_back(static_cast<uint8_t>(
+      TimesyncCommandType::kRemove));  // Command Type: REMOVE
+  for (int i = address.size() - 1; i >= 0; --i) {
+    packet.push_back(address[i]);  // Address
+  }
+  packet.push_back(static_cast<uint8_t>(address_type));  // Address Type
+
+  return packet;
+}
+
+HalPacket BluetoothCccTimesyncCommand::CreateClearCommand() {
+  // Command Type (1)
+  uint8_t payload_length = TimesyncConstants::kCommandCommandTypeLength;
+  HalPacket packet;
+  packet.reserve(kHeaderSize + payload_length);  // Fixed header (4) + payload
+  AppendFixedHeader(packet, payload_length);
+
+  // Command-specific Payload
+  packet.push_back(static_cast<uint8_t>(
+      TimesyncCommandType::kClear));  // Command Type: CLEAR
+
+  return packet;
+}
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command_test.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command_test.cc
new file mode 100644
index 0000000000..10131d9901
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command_test.cc
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.h"
+
+#include <vector>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+namespace {
+
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::bluetooth_hal::hci::HalPacket;
+
+// Test Suite for BluetoothCccTimesyncCommand
+TEST(BluetoothCccTimesyncCommandTest, CreateAddCommandBasic) {
+  BluetoothAddress address = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
+  AddressType addr_type = AddressType::kRandom;
+  CccDirection direction = CccDirection::kTx;
+  std::vector<CccLmpEventId> lmp_ids = {CccLmpEventId::kConnectInd,
+                                        CccLmpEventId::kLlPhyUpdateInd};
+
+  HalPacket command_packet = BluetoothCccTimesyncCommand::CreateAddCommand(
+      address, addr_type, direction, lmp_ids);
+
+  // Expected packet construction:
+  // Header (4 bytes): PacketType (0x01), Opcode LSB (0x63), Opcode MSB (0xFD),
+  // Payload Length (0x0B) Payload (11 bytes): CommandType::kAdd (0x01), Address
+  // (6 bytes), AddrType (0x01), Direction (0x00), LmpIds (0xFF, 0x18)
+  HalPacket expected_packet({
+      0x01, 0x63, 0xFD, 0x0B,  // Fixed Header: PacketType, Opcode (L,M), Length
+      0x01,                    // Command Type: kAdd
+      0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA,  // Address
+      0x01,                                // Address Type: kRandom
+      0x00,                                // Direction: kTx
+      0xFF, 0x18  // LMP IDs: kConnectInd (0xFF), kLlPhyUpdateInd (0x18)
+  });
+
+  EXPECT_EQ(command_packet.size(),
+            expected_packet.size());           // Sanity check length
+  EXPECT_EQ(command_packet, expected_packet);  // Compare entire packets
+}
+
+TEST(BluetoothCccTimesyncCommandTest, CreateAddCommandEmptyLmpIds) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  AddressType addr_type = AddressType::kPublic;
+  CccDirection direction = CccDirection::kRx;
+  std::vector<CccLmpEventId> lmp_ids = {};  // Empty LMP IDs
+
+  HalPacket command_packet = BluetoothCccTimesyncCommand::CreateAddCommand(
+      address, addr_type, direction, lmp_ids);
+
+  // Expected packet construction:
+  // Header (4 bytes): PacketType (0x01), Opcode LSB (0x63), Opcode MSB (0xFD),
+  // Payload Length (0x09) Payload (9 bytes): CommandType::kAdd (0x01), Address
+  // (6 bytes), AddrType (0x00), Direction (0x01)
+  HalPacket expected_packet({
+      0x01, 0x63, 0xFD, 0x09,  // Fixed Header: PacketType, Opcode (L,M), Length
+      0x01,                    // Command Type: kAdd
+      0x66, 0x55, 0x44, 0x33, 0x22, 0x11,  // Address
+      0x00,                                // Address Type: kPublic
+      0x01                                 // Direction: kRx
+  });
+
+  EXPECT_EQ(command_packet.size(), expected_packet.size());
+  EXPECT_EQ(command_packet, expected_packet);
+}
+
+TEST(BluetoothCccTimesyncCommandTest, CreateAddCommandUndefinedLmpIdMapping) {
+  BluetoothAddress address = {0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA};
+  AddressType addr_type = AddressType::kRandom;
+  CccDirection direction = CccDirection::kTx;
+  std::vector<CccLmpEventId> lmp_ids = {
+      CccLmpEventId::kUndefined};  // Test kUndefined mapping
+
+  HalPacket command_packet = BluetoothCccTimesyncCommand::CreateAddCommand(
+      address, addr_type, direction, lmp_ids);
+
+  // Expected packet construction:
+  // Header (4 bytes): PacketType (0x01), Opcode LSB (0x63), Opcode MSB (0xFD),
+  // Payload Length (0x0A) Payload (10 bytes): CommandType::kAdd (0x01), Address
+  // (6 bytes), AddrType (0x01), Direction (0x00), LmpId (0x00)
+  HalPacket expected_packet({
+      0x01, 0x63, 0xFD, 0x0A,  // Fixed Header: PacketType, Opcode (L,M), Length
+      0x01,                    // Command Type: kAdd
+      0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,  // Address
+      0x01,                                // Address Type: kRandom
+      0x00,                                // Direction: kTx
+      0x00                                 // LMP ID: kUndefined maps to 0x00
+  });
+
+  EXPECT_EQ(command_packet.size(), expected_packet.size());
+  EXPECT_EQ(command_packet, expected_packet);
+}
+
+TEST(BluetoothCccTimesyncCommandTest, CreateRemoveCommand) {
+  BluetoothAddress address = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
+  AddressType addr_type = AddressType::kPublic;
+
+  HalPacket command_packet =
+      BluetoothCccTimesyncCommand::CreateRemoveCommand(address, addr_type);
+
+  // Expected packet construction:
+  // Header (4 bytes): PacketType (0x01), Opcode LSB (0x63), Opcode MSB (0xFD),
+  // Payload Length (0x08) Payload (8 bytes): CommandType::kRemove (0x02),
+  // Address (6 bytes), AddressType (0x00)
+  HalPacket expected_packet({
+      0x01, 0x63, 0xFD, 0x08,  // Fixed Header: PacketType, Opcode (L,M), Length
+      0x02,                    // Command Type: kRemove
+      0x06, 0x05, 0x04, 0x03, 0x02, 0x01,  // Address
+      0x00                                 // Address Type: kPublic
+  });
+
+  EXPECT_EQ(command_packet.size(), expected_packet.size());
+  EXPECT_EQ(command_packet, expected_packet);
+}
+
+TEST(BluetoothCccTimesyncCommandTest, CreateClearCommand) {
+  HalPacket command_packet = BluetoothCccTimesyncCommand::CreateClearCommand();
+
+  // Expected packet construction:
+  // Header (4 bytes): PacketType (0x01), Opcode LSB (0x63), Opcode MSB (0xFD),
+  // Payload Length (0x01) Payload (1 byte): CommandType::kClear (0x03)
+  HalPacket expected_packet({
+      0x01, 0x63, 0xFD, 0x01,  // Fixed Header: PacketType, Opcode (L,M), Length
+      0x03                     // Command Type: kClear
+  });
+
+  EXPECT_EQ(command_packet.size(), expected_packet.size());
+  EXPECT_EQ(command_packet, expected_packet);
+}
+
+}  // namespace
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.cc
new file mode 100644
index 0000000000..4943aff4d5
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.cc
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h"
+
+#include <algorithm>
+#include <array>
+#include <cstdint>
+#include <vector>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+
+BluetoothCccTimesyncEvent::BluetoothCccTimesyncEvent(const HalPacket& packet)
+    : HalPacket(packet) {
+  // Format of the CCC Time Sync event:
+  //    [PacketType:1][EventCode:1][Length:1][SubEventCode:1][Address:6][AddressType:1][Direction:1]
+  //    [Timestamp:8][EventId:1][ToggleCount:1][TimesyncOffset:2][EventCount:2]
+
+  // Check length, and the bytes in the header (4 octets).
+  is_valid_ = (size() == TimesyncConstants::kEventLength &&
+               GetType() == HciPacketType::kEvent && IsVendorEvent() &&
+               At(TimesyncEventOffset::kSubEventCode) ==
+                   TimesyncConstants::kSubEventCode);
+
+  if (!is_valid_) {
+    return;
+  }
+
+  // Parse BluetoothAddress (6 octets, little-endian)
+  std::reverse_copy(
+      begin() + static_cast<uint8_t>(TimesyncEventOffset::kAddress),
+      begin() + static_cast<uint8_t>(TimesyncEventOffset::kAddress) +
+          address_.size(),
+      address_.begin());
+
+  // Parse address type (1 octet)
+  address_type_ = At(TimesyncEventOffset::kAddressType);
+
+  // Parse direction (1 octet)
+  direction_ = At(TimesyncEventOffset::kDirection);
+
+  // Parse Timestamp (8 octets, little-endian)
+  timestamp_ = AtUint64LittleEndian(TimesyncEventOffset::kTimestamp);
+
+  // Parse event ID (1 octet)
+  event_id_ = At(TimesyncEventOffset::kEventId);
+
+  // Parse toggle count (1 octet)
+  toggle_count_ = At(TimesyncEventOffset::kToggleCount);
+
+  // Parse Timesync Offset (2 octets, little-endian)
+  timesync_offset_ = AtUint16LittleEndian(TimesyncEventOffset::kTimesyncOffset);
+
+  // Parse Event Count (2 octets, little-endian)
+  event_count_ = AtUint16LittleEndian(TimesyncEventOffset::kEventCount);
+}
+
+bool BluetoothCccTimesyncEvent::IsValid() { return is_valid_; }
+
+BluetoothAddress BluetoothCccTimesyncEvent::GetAddress() const {
+  return address_;
+}
+
+uint8_t BluetoothCccTimesyncEvent::GetAddressType() const {
+  return address_type_;
+}
+
+CccDirection BluetoothCccTimesyncEvent::GetDirection() const {
+  if (!is_valid_) {
+    return CccDirection::kUndefined;
+  }
+  CccDirection direction = static_cast<CccDirection>(direction_);
+  return (direction <= CccDirection::kMax) ? direction
+                                           : CccDirection::kUndefined;
+}
+
+uint64_t BluetoothCccTimesyncEvent::GetTimestamp() const { return timestamp_; }
+
+CccLmpEventId BluetoothCccTimesyncEvent::GetEventId() const {
+  if (!is_valid_) {
+    return CccLmpEventId::kUndefined;
+  }
+  if (event_id_ == static_cast<uint8_t>(CccLmpEventIdByte::kConnectInd)) {
+    return CccLmpEventId::kConnectInd;
+  } else if (event_id_ ==
+             static_cast<uint8_t>(CccLmpEventIdByte::kLlPhyUpdateInd)) {
+    return CccLmpEventId::kLlPhyUpdateInd;
+  }
+  return CccLmpEventId::kUndefined;
+}
+
+uint8_t BluetoothCccTimesyncEvent::GetToggleCount() const {
+  return toggle_count_;
+}
+
+uint16_t BluetoothCccTimesyncEvent::GetTimesyncOffset() const {
+  return timesync_offset_;
+}
+
+uint16_t BluetoothCccTimesyncEvent::GetEventCount() const {
+  return event_count_;
+}
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event_test.cc b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event_test.cc
new file mode 100644
index 0000000000..189b728fb9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event_test.cc
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h"
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+namespace {
+
+using ::bluetooth_hal::hci::BluetoothAddress;
+using ::bluetooth_hal::hci::HalPacket;
+
+HalPacket CreateSamplePacket(BluetoothAddress& address) {
+  // Packet format:
+  // [Event:1][Eventcode:1][Length:1][Address:6][AddressType:1][Direction:1]
+  // [Timestamp:8][EventId:1][ToggleCount:1][Timesync offset:2][Event count:2]
+  // Total expected length: 25 bytes
+
+  return HalPacket({0x04,  // HCI Event (1 byte)
+                    0xFF,  // Vendor event code (1 byte)
+                    0x17,  // Length (1 byte - 23 decimal, payload length)
+                    0xD0,  // Time sync sub event code (1 byte)
+
+                    address[5], address[4], address[3], address[2], address[1],
+                    address[0],  // Address (6 bytes)
+
+                    0x01,  // AddressType (1 byte - Random)
+                    0x00,  // Direction (1 byte - Tx)
+
+                    // Timestamp (8 bytes - 0xAABBCCDDEEFF0011, little-endian)
+                    0x11, 0x00, 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA,
+
+                    0xFF,  // EventId (1 byte - EventIdConnInd)
+                    0x0B,  // ToggleCount (1 byte)
+
+                    // Timesync offset (2 bytes - 0x1234, little-endian)
+                    0x34, 0x12,
+
+                    // Event count (2 bytes - 0x5678, little-endian)
+                    0x78, 0x56});
+}
+
+void CheckEventDefaultValues(BluetoothCccTimesyncEvent& event) {
+  BluetoothAddress address = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+  ASSERT_FALSE(event.IsValid());
+  ASSERT_EQ(event.GetAddress(), address);
+  ASSERT_EQ(event.GetAddressType(), 0x00);
+  ASSERT_EQ(event.GetDirection(), CccDirection::kUndefined);
+  ASSERT_EQ(event.GetTimestamp(), 0x0000000000000000);
+  ASSERT_EQ(event.GetEventId(), CccLmpEventId::kUndefined);
+  ASSERT_EQ(event.GetToggleCount(), 0x00);
+  ASSERT_EQ(event.GetTimesyncOffset(), 0x0000);
+  ASSERT_EQ(event.GetEventCount(), 0x0000);
+}
+
+TEST(BluetoothCccTimesyncEventTest, ValidPacketParsing) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  BluetoothCccTimesyncEvent event(CreateSamplePacket(address));
+
+  ASSERT_TRUE(event.IsValid());
+  ASSERT_EQ(event.GetAddress(), address);
+  ASSERT_EQ(event.GetAddressType(), 0x01);
+  ASSERT_EQ(event.GetDirection(), CccDirection::kTx);
+  ASSERT_EQ(event.GetTimestamp(), 0xAABBCCDDEEFF0011);
+  ASSERT_EQ(event.GetEventId(), CccLmpEventId::kConnectInd);
+  ASSERT_EQ(event.GetToggleCount(), 0x0B);
+  ASSERT_EQ(event.GetTimesyncOffset(), 0x1234);
+  ASSERT_EQ(event.GetEventCount(), 0x5678);
+}
+
+TEST(BluetoothCccTimesyncEventTest, InvalidPacketParsingIncorrectLength) {
+  BluetoothCccTimesyncEvent event(HalPacket({0x01, 0x02, 0x03, 0x04}));
+  CheckEventDefaultValues(event);
+}
+
+TEST(BluetoothCccTimesyncEventTest, InvalidPacketParsingIncorrectPacketType) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  HalPacket packet = CreateSamplePacket(address);
+
+  // Set to the wrong packet type, should be 0x04 for HCI event.
+  packet.at(0) = 0x00;
+  BluetoothCccTimesyncEvent event(packet);
+
+  CheckEventDefaultValues(event);
+}
+
+TEST(BluetoothCccTimesyncEventTest, InvalidPacketParsingIncorrectEventCode) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  HalPacket packet = CreateSamplePacket(address);
+
+  // Set to the wrong event code, should be 0xFF for vendor event.
+  packet.at(1) = 0x00;
+  BluetoothCccTimesyncEvent event(packet);
+
+  CheckEventDefaultValues(event);
+}
+
+TEST(BluetoothCccTimesyncEventTest, InvalidPacketParsingIncorrectSubEventCode) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  HalPacket packet = CreateSamplePacket(address);
+
+  // Set to the wrong sub event code, should be 0xD0 for time sync event.
+  packet.at(3) = 0x00;
+  BluetoothCccTimesyncEvent event(packet);
+
+  CheckEventDefaultValues(event);
+}
+
+TEST(BluetoothCccTimesyncEventTest, HandleGetDirection) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  HalPacket packet = CreateSamplePacket(address);
+
+  // Set direction to TX.
+  packet.at(11) = 0x00;
+  BluetoothCccTimesyncEvent event1(packet);
+  ASSERT_EQ(event1.GetDirection(), CccDirection::kTx);
+
+  // Set direction to RX.
+  packet.at(11) = 0x01;
+  BluetoothCccTimesyncEvent event2(packet);
+  ASSERT_EQ(event2.GetDirection(), CccDirection::kRx);
+
+  // Set direction to a random value.
+  packet.at(11) = 0x99;
+  BluetoothCccTimesyncEvent event3(packet);
+  ASSERT_EQ(event3.GetDirection(), CccDirection::kUndefined);
+}
+
+TEST(BluetoothCccTimesyncEventTest, HandleGetEventId) {
+  BluetoothAddress address = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+  HalPacket packet = CreateSamplePacket(address);
+
+  // Set event id to Conn IND.
+  packet.at(20) = 0xFF;
+  BluetoothCccTimesyncEvent event1(packet);
+  ASSERT_EQ(event1.GetEventId(), CccLmpEventId::kConnectInd);
+
+  // Set event id to LL PHY Update IND.
+  packet.at(20) = 0x18;
+  BluetoothCccTimesyncEvent event2(packet);
+  ASSERT_EQ(event2.GetEventId(), CccLmpEventId::kLlPhyUpdateInd);
+
+  // Set event id to a random value.
+  packet.at(20) = 0x99;
+  BluetoothCccTimesyncEvent event3(packet);
+  ASSERT_EQ(event3.GetEventId(), CccLmpEventId::kUndefined);
+}
+
+}  // namespace
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.cc b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.cc
new file mode 100644
index 0000000000..17f3a3fa89
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.cc
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.h"
+
+#include <array>
+#include <cstdint>
+
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace channel_avoidance {
+
+using ::ndk::ScopedAStatus;
+
+ScopedAStatus BluetoothChannelAvoidance::setBluetoothChannelStatus(
+    const std::array<uint8_t, 10>& channel_map) {
+  bool status = handler_.SetBluetoothChannelStatus(channel_map);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+}  // namespace channel_avoidance
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.cc b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.cc
new file mode 100644
index 0000000000..d8e826fa27
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.cc
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.channel_avoidance"
+
+#include "bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h"
+
+#include <chrono>
+#include <cstdint>
+#include <iomanip>
+#include <sstream>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace channel_avoidance {
+namespace {
+
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::MonitorMode;
+
+constexpr uint16_t kHciChannelAvoidanceOpcode = 0x0c3f;
+constexpr uint8_t kHciChannelAvoidanceMapSize = 10;
+
+constexpr int kMaxCommandWaitTimeMs = 1000;
+
+template <typename TContainer>
+std::string BytesToHexString(const TContainer& container) {
+  std::ostringstream oss;
+  bool first = true;
+  for (uint8_t byte : container) {
+    if (!first) {
+      oss << " ";
+    }
+    oss << "0x" << std::hex << std::setw(2) << std::setfill('0')
+        << static_cast<int>(byte);
+    first = false;
+  }
+  return oss.str();
+}
+
+}  // namespace
+
+HalPacket BluetoothChannelAvoidanceHandler::BuildSetChannelAvoidanceCommand(
+    const std::array<uint8_t, 10>& channel_map) {
+  HalPacket command;
+
+  uint8_t cmd_length =
+      HciConstants::kHciCommandPreambleSize + kHciChannelAvoidanceMapSize;
+
+  command.reserve(1 + cmd_length);
+
+  command.push_back(static_cast<uint8_t>(HciPacketType::kCommand));
+
+  command.push_back(kHciChannelAvoidanceOpcode & 0xff);
+  command.push_back((kHciChannelAvoidanceOpcode >> 8) & 0xff);
+
+  // Param length.
+  command.push_back(kHciChannelAvoidanceMapSize);
+
+  command.insert(command.end(), channel_map.begin(), channel_map.end());
+
+  return command;
+}
+
+bool BluetoothChannelAvoidanceHandler::SetBluetoothChannelStatus(
+    const std::array<uint8_t, 10>& channel_map) {
+  std::scoped_lock<std::mutex> lock(command_mtx_);
+
+  if (!IsBluetoothEnabled()) {
+    LOG(WARNING) << __func__ << ": BT off, unable to set channel map <"
+                 << BytesToHexString(channel_map) << ">.";
+    return false;
+  }
+
+  LOG(INFO) << __func__ << ": Setting Channel Map <"
+            << BytesToHexString(channel_map) << ">.";
+
+  HalPacket command_packet = BuildSetChannelAvoidanceCommand(channel_map);
+
+  command_promise_ = std::promise<void>();
+  if (!SendCommand(command_packet)) {
+    LOG(ERROR) << __func__ << ": Failed to send HCI command.";
+    return false;
+  }
+
+  std::future<void> future = command_promise_.get_future();
+  if (future.wait_for(std::chrono::milliseconds(kMaxCommandWaitTimeMs)) !=
+      std::future_status::ready) {
+    LOG(ERROR) << __func__ << ": Command timed out.";
+    command_success_ = false;
+    return false;
+  }
+
+  return command_success_.load();
+}
+
+void BluetoothChannelAvoidanceHandler::OnCommandCallback(
+    const HalPacket& event_packet) {
+  bool success = (event_packet.GetCommandCompleteEventResult() ==
+                  static_cast<uint8_t>(EventResultCode::kSuccess));
+  command_success_ = success;
+
+  LOG(success ? INFO : WARNING)
+      << __func__ << ": Set Channel Avoidance VSE "
+      << (success ? "succeeded" : "failed") << ". Status: 0x" << std::hex
+      << static_cast<int>(event_packet.GetCommandCompleteEventResult());
+
+  command_promise_.set_value();
+}
+
+void BluetoothChannelAvoidanceHandler::OnMonitorPacketCallback(
+    [[maybe_unused]] MonitorMode mode,
+    [[maybe_unused]] const HalPacket& packet) {}
+
+}  // namespace channel_avoidance
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler_test.cc b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler_test.cc
new file mode 100644
index 0000000000..c2053fe9c4
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler_test.cc
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h"
+
+#include <array>
+#include <chrono>
+#include <cstdint>
+#include <future>
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "bluetooth_hal/hci_router_client_callback.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace channel_avoidance {
+namespace {
+
+using ::testing::_;
+using ::testing::Action;
+using ::testing::DoAll;
+using ::testing::ElementsAreArray;
+using ::testing::NotNull;
+using ::testing::Return;
+using ::testing::SaveArg;
+using ::testing::StrictMock;
+using ::testing::Test;
+using ::testing::Values;
+using ::testing::WithParamInterface;
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::hci::CommandOpCode;
+using ::bluetooth_hal::hci::EventCode;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::HciRouterCallback;
+using ::bluetooth_hal::hci::HciRouterClientCallback;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+
+constexpr uint16_t kTestHciChannelAvoidanceOpcode = 0x0c3f;
+constexpr uint8_t kTestHciChannelAvoidanceMapSize = 10;
+constexpr int kTestMaxCommandWaitTimeMs = 1000;
+
+class TestableBluetoothChannelAvoidanceHandler
+    : public BluetoothChannelAvoidanceHandler {
+ public:
+  TestableBluetoothChannelAvoidanceHandler() = default;
+
+  HalPacket BuildSetChannelAvoidanceCommandWrapper(
+      const std::array<uint8_t, kTestHciChannelAvoidanceMapSize>& channel_map) {
+    return BluetoothChannelAvoidanceHandler::BuildSetChannelAvoidanceCommand(
+        channel_map);
+  }
+};
+
+class BluetoothChannelAvoidanceHandlerTest : public Test {
+ protected:
+  void SetUp() override {
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    EXPECT_CALL(mock_hci_router_client_agent_, RegisterRouterClient(NotNull()))
+        .WillOnce(
+            DoAll(SaveArg<0>(&registered_callback_on_router_), Return(true)));
+
+    handler_ = std::make_unique<TestableBluetoothChannelAvoidanceHandler>();
+    ASSERT_NE(handler_, nullptr);
+    ASSERT_EQ(registered_callback_on_router_, handler_.get());
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mock_hci_router_client_agent_,
+                UnregisterRouterClient(handler_.get()))
+        .WillOnce(Return(true));
+    handler_.reset();
+    MockHciRouter::SetMockRouter(nullptr);
+  }
+
+  HalPacket CreateCommandCompleteEvent(uint16_t opcode,
+                                       EventResultCode status) {
+    std::vector<uint8_t> parameters;
+    parameters.push_back(static_cast<uint8_t>(HciPacketType::kCommand));
+    parameters.push_back(opcode & 0xFF);
+    parameters.push_back((opcode >> 8) & 0xFF);
+    parameters.push_back(static_cast<uint8_t>(status));
+
+    std::vector<uint8_t> event_data;
+    event_data.push_back(static_cast<uint8_t>(HciPacketType::kEvent));
+    event_data.push_back(static_cast<uint8_t>(EventCode::kCommandComplete));
+    event_data.push_back(static_cast<uint8_t>(parameters.size()));
+    event_data.insert(event_data.end(), parameters.begin(), parameters.end());
+    return HalPacket(event_data);
+  }
+
+  // Helper to set Bluetooth enabled/disabled state by simulating
+  // HciRouterClient behavior.
+  void SetBluetoothState(bool enabled) {
+    if (enabled) {
+      EXPECT_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+          .WillRepeatedly(Return(true));
+      EXPECT_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+          .WillRepeatedly(Return(true));
+      EXPECT_CALL(mock_hci_router_, GetHalState())
+          .WillRepeatedly(Return(HalState::kRunning));
+
+      registered_callback_on_router_->OnBluetoothChipReady();
+      registered_callback_on_router_->OnBluetoothEnabled();
+    } else {
+      EXPECT_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+          .WillRepeatedly(Return(false));
+      EXPECT_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+          .WillRepeatedly(Return(false));
+      EXPECT_CALL(mock_hci_router_, GetHalState())
+          .WillRepeatedly(Return(HalState::kShutdown));
+
+      registered_callback_on_router_->OnBluetoothDisabled();
+      registered_callback_on_router_->OnBluetoothChipClosed();
+    }
+  }
+
+  std::unique_ptr<TestableBluetoothChannelAvoidanceHandler> handler_;
+  StrictMock<MockHciRouter> mock_hci_router_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+  HciRouterClientCallback* registered_callback_on_router_ = nullptr;
+
+  std::array<uint8_t, kTestHciChannelAvoidanceMapSize> test_channel_map_ = {
+      {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A}};
+};
+
+TEST_F(BluetoothChannelAvoidanceHandlerTest, BuildCommandCorrectly) {
+  HalPacket command =
+      handler_->BuildSetChannelAvoidanceCommandWrapper(test_channel_map_);
+
+  ASSERT_EQ(command.GetType(), HciPacketType::kCommand);
+  ASSERT_EQ(command.size(), 1u + HciConstants::kHciCommandPreambleSize +
+                                kTestHciChannelAvoidanceMapSize);
+
+  uint16_t opcode = command[1] | (command[2] << 8);
+  ASSERT_EQ(opcode, kTestHciChannelAvoidanceOpcode);
+
+  uint8_t param_length = command[3];
+  ASSERT_EQ(param_length, kTestHciChannelAvoidanceMapSize);
+
+  std::vector<uint8_t> sent_map_data(command.begin() + 4, command.end());
+  ASSERT_EQ(sent_map_data.size(), kTestHciChannelAvoidanceMapSize);
+  EXPECT_THAT(sent_map_data, ElementsAreArray(test_channel_map_));
+}
+
+TEST_F(BluetoothChannelAvoidanceHandlerTest,
+       SetStatusWhenBluetoothDisabledReturnsFalse) {
+  SetBluetoothState(false);
+  ASSERT_FALSE(handler_->SetBluetoothChannelStatus(test_channel_map_));
+}
+
+TEST_F(BluetoothChannelAvoidanceHandlerTest,
+       SetStatusWhenSendCommandFailsReturnsFalse) {
+  SetBluetoothState(true);
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).WillOnce(Return(false));
+
+  ASSERT_FALSE(handler_->SetBluetoothChannelStatus(test_channel_map_));
+}
+
+TEST_F(BluetoothChannelAvoidanceHandlerTest,
+       SetStatusCommandTimeoutReturnsFalse) {
+  SetBluetoothState(true);
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).WillOnce(Return(true));
+
+  ASSERT_FALSE(handler_->SetBluetoothChannelStatus(test_channel_map_));
+}
+
+struct SetStatusTestParams {
+  EventResultCode command_complete_status;
+  bool expected_return_value;
+  std::string test_name_suffix;
+};
+
+// Helper Action to signal when SendCommand is called.
+ACTION_P(SignalPromise, p) {
+  p->set_value();
+  return true;
+}
+
+class BluetoothChannelAvoidanceHandlerSetStatusTest
+    : public BluetoothChannelAvoidanceHandlerTest,
+      public WithParamInterface<SetStatusTestParams> {};
+
+TEST_P(BluetoothChannelAvoidanceHandlerSetStatusTest, SetStatusAndVerify) {
+  SetBluetoothState(true);
+  const auto& params = GetParam();
+
+  std::promise<void> command_sent_promise;
+  std::future<void> command_sent_future = command_sent_promise.get_future();
+
+  HalPacket expected_command_packet =
+      handler_->BuildSetChannelAvoidanceCommandWrapper(test_channel_map_);
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_command_packet, _))
+      .WillOnce(SignalPromise(&command_sent_promise));
+
+  auto result_future = std::async(std::launch::async, [&]() {
+    return handler_->SetBluetoothChannelStatus(test_channel_map_);
+  });
+
+  ASSERT_EQ(command_sent_future.wait_for(
+                std::chrono::milliseconds(kTestMaxCommandWaitTimeMs)),
+            std::future_status::ready)
+      << "SendCommand was not called or timed out waiting for it.";
+
+  if (params.test_name_suffix != "Timeout") {
+    HalPacket complete_event = CreateCommandCompleteEvent(
+        kTestHciChannelAvoidanceOpcode, params.command_complete_status);
+    registered_callback_on_router_->OnCommandCallback(complete_event);
+  }
+
+  std::chrono::milliseconds wait_duration =
+      (params.test_name_suffix == "Timeout")
+          ? std::chrono::milliseconds(kTestMaxCommandWaitTimeMs + 200)
+          : std::chrono::milliseconds(kTestMaxCommandWaitTimeMs);
+
+  ASSERT_EQ(result_future.wait_for(wait_duration), std::future_status::ready)
+      << "SetBluetoothChannelStatus did not return as expected for test case: "
+      << params.test_name_suffix;
+  EXPECT_EQ(result_future.get(), params.expected_return_value);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    SetStatusCommandResults, BluetoothChannelAvoidanceHandlerSetStatusTest,
+    Values(SetStatusTestParams{EventResultCode::kSuccess, true, "Success"},
+           SetStatusTestParams{EventResultCode::kFailure, false, "Failure"},
+           SetStatusTestParams{EventResultCode::kFailure, false, "Timeout"}));
+
+}  // namespace
+}  // namespace channel_avoidance
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.cc b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.cc
new file mode 100644
index 0000000000..d39d275150
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.cc
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.aidl.channel_avoidance"
+
+#include "bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.h"
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/debug/vnd_snoop_logger.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace vendor {
+namespace google {
+namespace bluetooth_ext {
+namespace bt_channel_avoidance {
+namespace aidl {
+namespace implementation {
+
+using ::bluetooth_hal::debug::VndSnoopLogger;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+
+using VndLogDirection = ::bluetooth_hal::debug::VndSnoopLogger::Direction;
+
+// HCI_Set_AFH_Host_Channel_Classification: OGF 0x03 | OCF 0x003F
+constexpr uint16_t kHciChannelAvoidanceOpcode = 0x0c3f;
+constexpr uint8_t kHciCommandOpcodeLength = 2;
+constexpr uint8_t kHciChannelAvoidanceMapSize = 10;
+constexpr size_t kHciChannelAvoidanceCmdLength =
+    kHciCommandOpcodeLength + 1 + kHciChannelAvoidanceMapSize;
+
+constexpr uint8_t kCommandCompleteStatusOffset =
+    HciEventWatcher::kCommandCompleteOpcodeOffset + kHciCommandOpcodeLength;
+constexpr uint8_t kCommandCompleteStatusSucceed = 0x00;
+
+HciFlowControl* BTChannelAvoidance::hci_handle_ = nullptr;
+BTChannelAvoidance BTChannelAvoidance::instance_;
+
+BTChannelAvoidance::BTChannelAvoidance()
+    : HciEventWatcher(LOG_TAG, HciEventWatcher::kCommandCompleteEventCode,
+                      kHciChannelAvoidanceOpcode, false, true) {}
+
+ndk::ScopedAStatus BTChannelAvoidance::setBluetoothChannelStatus(
+    const std::array<uint8_t, 10>& channel_map) {
+  if (hci_handle_ == nullptr) {
+    LOG(WARNING) << __func__ << ": Unable to set channel map <"
+                 << channel_map.data() << ">";
+    return ndk::ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+  }
+  LOG(INFO) << __func__ << ": Channel Map <" << channel_map.data() << ">";
+  std::vector<uint8_t> packet_body;
+  packet_body.resize(kHciChannelAvoidanceCmdLength);
+  packet_body[0] = kHciChannelAvoidanceOpcode & 0xff;
+  packet_body[1] = (kHciChannelAvoidanceOpcode >> 8u) & 0xff;
+  packet_body[2] = kHciChannelAvoidanceMapSize;
+  for (int i = 0; i < kHciChannelAvoidanceMapSize; ++i) {
+    packet_body[3 + i] = channel_map[i];
+  }
+  HalPacket packet(static_cast<uint8_t>(HciPacketType::kCommand), packet_body);
+  ++(instance_.event_waiting_);
+  if (hci_handle_ != nullptr) {
+    hci_handle_->Send(static_cast<uint8_t>(packet.GetType()),
+                      packet_body.data(), packet_body.size());
+  } else {
+    LOG(WARNING) << __func__ << ": Unable to send channel map vsc";
+    return ndk::ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+  }
+  return ndk::ScopedAStatus::ok();
+}
+
+bool BTChannelAvoidance::OnEventReceive(const HalPacket& event) {
+  bool status =
+      event[kCommandCompleteStatusOffset] == kCommandCompleteStatusSucceed;
+  unsigned int waiting_count = event_waiting_.load(std::memory_order_relaxed);
+  if (status) {
+    LOG(INFO) << __func__ << ": (" << waiting_count << ") Recv Success VSE <"
+              << event.ToString() << ">";
+  } else {
+    LOG(WARNING) << __func__ << ": (" << waiting_count << ") Recv Failure VSE <"
+                 << event.ToString() << ">";
+  }
+  if (!waiting_count) return false;
+  --event_waiting_;
+  return true;
+}
+
+bool BTChannelAvoidance::OnEventPost(const HalPacket& event) {
+  (void)event;
+  return true;
+}
+
+void BTChannelAvoidance::OnBluetoothEnabled(HciFlowControl* handle) {
+  LOG(DEBUG) << __func__;
+  hci_handle_ = handle;
+  if (handle != nullptr) {
+    hci_handle_->RegisterEventWatcher(&instance_);
+  }
+}
+
+void BTChannelAvoidance::OnBluetoothDisabled() {
+  LOG(DEBUG) << __func__;
+  if (hci_handle_ != nullptr) {
+    hci_handle_->UnregisterEventWatcher(&instance_);
+    hci_handle_ = nullptr;
+  }
+}
+
+}  // namespace implementation
+}  // namespace aidl
+}  // namespace bt_channel_avoidance
+}  // namespace bluetooth_ext
+}  // namespace google
+}  // namespace vendor
diff --git a/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding.cc b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding.cc
new file mode 100644
index 0000000000..885a41d132
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding.cc
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.cs"
+
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding.h"
+
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "Eigen/Dense"
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/CsSecurityLevel.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSession.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/SessionType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android-base/logging.h"
+#include "android-base/properties.h"
+#include "android/binder_auto_utils.h"
+#include "android/binder_interface_utils.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+using ::aidl::android::hardware::bluetooth::ranging::
+    BluetoothChannelSoundingParameters;
+using ::aidl::android::hardware::bluetooth::ranging::CsSecurityLevel;
+using ::aidl::android::hardware::bluetooth::ranging::
+    IBluetoothChannelSoundingSession;
+using ::aidl::android::hardware::bluetooth::ranging::
+    IBluetoothChannelSoundingSessionCallback;
+using ::aidl::android::hardware::bluetooth::ranging::SessionType;
+using ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData;
+
+using ::android::base::GetProperty;
+using ::bluetooth_hal::Property;
+
+using ::ndk::ScopedAStatus;
+using ::ndk::SharedRefBase;
+
+ScopedAStatus BluetoothChannelSounding::getVendorSpecificData(
+    std::optional<std::vector<std::optional<VendorSpecificData>>>*
+        _aidl_return) {
+  bool status =
+      bluetooth_channel_sounding_handler_.GetVendorSpecificData(_aidl_return);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothChannelSounding::getSupportedSessionTypes(
+    std::optional<std::vector<SessionType>>* _aidl_return) {
+  std::vector<SessionType> supported_session_types = {
+      SessionType::SOFTWARE_STACK_DATA_PARSING};
+  bool status = bluetooth_channel_sounding_handler_.GetSupportedSessionTypes(
+      _aidl_return);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothChannelSounding::getMaxSupportedCsSecurityLevel(
+    CsSecurityLevel* _aidl_return) {
+  bool status =
+      bluetooth_channel_sounding_handler_.GetMaxSupportedCsSecurityLevel(
+          _aidl_return);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothChannelSounding::openSession(
+    const BluetoothChannelSoundingParameters& in_params,
+    const std::shared_ptr<IBluetoothChannelSoundingSessionCallback>&
+        in_callback,
+    std::shared_ptr<IBluetoothChannelSoundingSession>* _aidl_return) {
+  LOG(INFO) << __func__;
+
+  if (in_callback.get() == nullptr) {
+    return ScopedAStatus::fromExceptionCodeWithMessage(
+        EX_ILLEGAL_ARGUMENT, "Invalid nullptr callback");
+  }
+
+  bool status = bluetooth_channel_sounding_handler_.OpenSession(
+      in_params, in_callback, _aidl_return);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.cc b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.cc
new file mode 100644
index 0000000000..4cf9f092e6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.cc
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.cs"
+
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.h"
+
+#include <cstdint>
+#include <functional>
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/CsSecurityLevel.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSession.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/Reason.h"
+#include "aidl/android/hardware/bluetooth/ranging/SessionType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android-base/logging.h"
+#include "android/binder_interface_utils.h"
+#include "bluetooth_hal/config/cs_config_loader.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router.h"
+#include "bluetooth_hal/util/android_base_wrapper.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+namespace {
+
+using ::aidl::android::hardware::bluetooth::ranging::
+    BluetoothChannelSoundingParameters;
+using ::aidl::android::hardware::bluetooth::ranging::CsSecurityLevel;
+using ::aidl::android::hardware::bluetooth::ranging::
+    IBluetoothChannelSoundingSession;
+using ::aidl::android::hardware::bluetooth::ranging::
+    IBluetoothChannelSoundingSessionCallback;
+using ::aidl::android::hardware::bluetooth::ranging::Reason;
+using ::aidl::android::hardware::bluetooth::ranging::SessionType;
+using ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData;
+using ::bluetooth_hal::config::CsConfigLoader;
+
+using ::bluetooth_hal::config::CsConfigLoader;
+using ::bluetooth_hal::hci::EventCode;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciBleMetaEventMonitor;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciMonitor;
+using ::bluetooth_hal::hci::HciRouter;
+using ::bluetooth_hal::hci::MonitorMode;
+using ::bluetooth_hal::hci::MonitorType;
+using ::bluetooth_hal::util::AndroidBaseWrapper;
+
+using ::ndk::SharedRefBase;
+
+void SendFakeRasNotification(
+    const BluetoothChannelSoundingParameters& parameters,
+    int procedure_counter) {
+  HalPacket packet = BuildRasNotification(parameters, procedure_counter);
+  HciRouter::GetRouter().SendPacketToStack(packet);
+}
+
+}  // namespace
+
+BluetoothChannelSoundingHandler::BluetoothChannelSoundingHandler()
+    : cs_data_subevent_monitor_(kLeCsSubEventResultCode),
+      cs_procedure_enable_subevent_monitor_(kLeCsProcedureEnableCompleteCode) {
+  RegisterMonitor(cs_data_subevent_monitor_, MonitorMode::kMonitor);
+  RegisterMonitor(cs_procedure_enable_subevent_monitor_, MonitorMode::kMonitor);
+}
+
+BluetoothChannelSoundingHandler::~BluetoothChannelSoundingHandler() {
+  UnregisterMonitor(cs_data_subevent_monitor_);
+  UnregisterMonitor(cs_procedure_enable_subevent_monitor_);
+}
+
+bool BluetoothChannelSoundingHandler::GetVendorSpecificData(
+    std::optional<std::vector<std::optional<VendorSpecificData>>>*
+        return_value) {
+  *return_value = std::nullopt;
+  return true;
+}
+
+bool BluetoothChannelSoundingHandler::GetSupportedSessionTypes(
+    std::optional<std::vector<SessionType>>* return_value) {
+  *return_value = {SessionType::SOFTWARE_STACK_DATA_PARSING};
+  return true;
+}
+
+bool BluetoothChannelSoundingHandler::GetMaxSupportedCsSecurityLevel(
+    CsSecurityLevel* return_value) {
+  *return_value = CsSecurityLevel::ONE;
+  return true;
+}
+
+bool BluetoothChannelSoundingHandler::OpenSession(
+    const BluetoothChannelSoundingParameters& in_params,
+    const std::shared_ptr<IBluetoothChannelSoundingSessionCallback>&
+        in_callback,
+    std::shared_ptr<IBluetoothChannelSoundingSession>* return_value) {
+  if (in_params.vendorSpecificData.has_value()) {
+    for (auto& data : in_params.vendorSpecificData.value()) {
+      LOG(INFO) << "vendorSpecificData uuid:" << ToHex(data->characteristicUuid)
+                << ", data:" << ToHex(data->opaqueValue);
+    }
+  }
+
+  if (IsUuidMatched(in_params.vendorSpecificData) &&
+      in_params.vendorSpecificData.value()[0].value().opaqueValue[0] ==
+          kDataTypeReply) {
+    // Ignore vendor specific reply.
+    return true;
+  }
+
+  std::shared_ptr<BluetoothChannelSoundingSession> session =
+      SharedRefBase::make<BluetoothChannelSoundingSession>(
+          in_callback, Reason::LOCAL_STACK_REQUEST);
+  session->HandleVendorSpecificData(in_params.vendorSpecificData);
+  SessionTracker tracker{.parameters = in_params};
+
+  if (session->ShouldEnableFakeNotification()) {
+    LOG(INFO) << __func__ << " Enable fake notification";
+    tracker.is_fake_notification_enabled = true;
+  }
+
+  session_trackers_.insert_or_assign(in_params.aclHandle, tracker);
+
+  if (session->ShouldEnableMode0ChannelMap()) {
+    LOG(INFO) << __func__ << " Enable mode 0 channel map";
+    HalPacket command = BuildEnableMode0ChannelMapCommand(
+        static_cast<uint16_t>(in_params.aclHandle), kCommandValueEnable);
+    SendCommand(command);
+  }
+
+  *return_value = session;
+  in_callback->onOpened(Reason::LOCAL_STACK_REQUEST);
+
+  return true;
+}
+
+void BluetoothChannelSoundingHandler::OnBluetoothEnabled() {
+  auto& cs_loader = CsConfigLoader::GetLoader();
+  cs_loader.LoadConfig();
+  const std::vector<HalPacket>& calibration_commands =
+      cs_loader.GetCsCalibrationCommands();
+
+  if (calibration_commands.empty()) {
+    LOG(WARNING) << __func__ << ": No calibration commands are found.";
+    return;
+  }
+
+  for (const auto& command : calibration_commands) {
+    SendCommand(command);
+  }
+};
+
+void BluetoothChannelSoundingHandler::OnBluetoothDisabled() {};
+
+void BluetoothChannelSoundingHandler::OnCommandCallback(
+    const HalPacket& packet) {
+  // Currently, two command types are supported:
+  // 1) Calibration commands (opcode: 0xfd64).
+  // 2) Ranging setting commands (opcode: 0xff0b).
+
+  bool status = packet.GetCommandCompleteEventResult() ==
+                static_cast<uint8_t>(EventResultCode::kSuccess);
+
+  LOG(status ? INFO : WARNING)
+      << __func__ << ": Recv VSE <" << packet.ToString() << "> "
+      << (status ? "[Success]" : "[Failed]");
+
+  if (!status ||
+      packet.GetCommandOpcodeFromGeneratedEvent() !=
+          kHciVscSpecialRangingSettingOpcode ||
+      HciConstants::kHciCommandCompleteResultOffset + 1 >= packet.size()) {
+    return;
+  }
+
+  uint8_t sub_opcode =
+      packet[HciConstants::kHciCommandCompleteResultOffset + 1];
+
+  // Store the read local cap value for Stack to read via
+  // GetVendorSpecificData.
+  if (sub_opcode == kHciVscReadLocalCapabilitySubOpCode) {
+    local_capabilities_.clear();
+    for (int i = 0; i < kCommandCompleteReadLocalCapabilityValueLength; i++) {
+      local_capabilities_.push_back(
+          packet[kCommandCompleteReadLocalCapabilityOffset + i]);
+    }
+  }
+};
+
+void BluetoothChannelSoundingHandler::HandleCsSubevent(
+    const HalPacket& packet) {
+  // [event_type (1 byte)] [event_code (1 byte)] [length (1 byte)]
+  // [subevent_code (1 byte)] [connection_handle (2 bytes)].
+  uint8_t offset = HciConstants::kHciBleEventSubCodeOffset + 1;
+  uint16_t connection_handle =
+      packet[offset] + ((packet[offset + 1] << 8u) & 0xff00);
+
+  const auto tracker = GetTracker(connection_handle);
+  if (!tracker || !tracker->get().is_fake_notification_enabled) {
+    return;
+  }
+
+  // Skip config_id, start_acl_conn_event_counter.
+  offset += 5;
+  uint16_t procedure_counter =
+      packet[offset] + ((packet[offset + 1] << 8u) & 0xff00);
+
+  if (tracker->get().cur_procedure_counter == procedure_counter) {
+    LOG(DEBUG) << __func__
+               << "Skip duplicate fake notification, procedure_counter: "
+               << procedure_counter;
+    return;
+  }
+
+  LOG(DEBUG) << __func__ << "Send fake notification, connection_handle:"
+             << connection_handle
+             << ", procedure_counter:" << procedure_counter;
+
+  tracker->get().cur_procedure_counter = procedure_counter;
+  SendFakeRasNotification(tracker->get().parameters,
+                          tracker->get().cur_procedure_counter);
+}
+
+void BluetoothChannelSoundingHandler::HandleCsProcedureEnableCompleteEvent(
+    const HalPacket& packet) {
+  // [event_type (1 byte)] [event_code (1 byte)] [length (1 byte)]
+  // [subevent_code (1 byte)] [status (1 byte)][connection_handle (2
+  // bytes)].
+  uint8_t offset = HciConstants::kHciBleEventSubCodeOffset + 2;
+  uint16_t connection_handle =
+      packet[offset] + ((packet[offset + 1] << 8u) & 0xff00);
+
+  const auto tracker = GetTracker(connection_handle);
+  if (!tracker || !tracker->get().is_fake_notification_enabled) {
+    return;
+  }
+  tracker->get().cur_procedure_counter = kInitialProcedureCounter;
+}
+
+void BluetoothChannelSoundingHandler::OnMonitorPacketCallback(
+    [[maybe_unused]] MonitorMode mode, const HalPacket& packet) {
+  uint8_t subevent_code = packet.GetBleSubEventCode();
+  switch (subevent_code) {
+    case kLeCsSubEventResultCode:
+      HandleCsSubevent(packet);
+      break;
+    case kLeCsProcedureEnableCompleteCode:
+      HandleCsProcedureEnableCompleteEvent(packet);
+      break;
+    default:
+      break;
+  }
+};
+
+std::optional<
+    std::reference_wrapper<BluetoothChannelSoundingHandler::SessionTracker>>
+BluetoothChannelSoundingHandler::GetTracker(uint16_t connection_handle) {
+  auto it = session_trackers_.find(connection_handle);
+  if (it == session_trackers_.end()) {
+    return std::nullopt;
+  }
+  return it->second;
+}
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler_test.cc b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler_test.cc
new file mode 100644
index 0000000000..7e92b48979
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler_test.cc
@@ -0,0 +1,596 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.h"
+
+#include <cstdint>
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/BnBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/CsSecurityLevel.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSession.h"
+#include "aidl/android/hardware/bluetooth/ranging/RangingResult.h"
+#include "aidl/android/hardware/bluetooth/ranging/Reason.h"
+#include "aidl/android/hardware/bluetooth/ranging/ResultType.h"
+#include "aidl/android/hardware/bluetooth/ranging/SessionType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android/binder_auto_utils.h"
+#include "android/binder_interface_utils.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+#include "bluetooth_hal/test/mock/mock_cs_config_loader.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+namespace {
+
+using ::testing::_;
+using ::testing::Return;
+using ::testing::ReturnRef;
+using ::testing::Test;
+using ::testing::Values;
+using ::testing::WithParamInterface;
+
+using ::aidl::android::hardware::bluetooth::ranging::
+    BluetoothChannelSoundingParameters;
+using ::aidl::android::hardware::bluetooth::ranging::
+    BnBluetoothChannelSoundingSessionCallback;
+using ::aidl::android::hardware::bluetooth::ranging::CsSecurityLevel;
+using ::aidl::android::hardware::bluetooth::ranging::
+    IBluetoothChannelSoundingSession;
+using ::aidl::android::hardware::bluetooth::ranging::RangingResult;
+using ::aidl::android::hardware::bluetooth::ranging::Reason;
+using ::aidl::android::hardware::bluetooth::ranging::ResultType;
+using ::aidl::android::hardware::bluetooth::ranging::SessionType;
+using ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData;
+
+using ::bluetooth_hal::config::MockCsConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+using ::bluetooth_hal::util::MockAndroidBaseWrapper;
+
+using ::ndk::ScopedAStatus;
+using ::ndk::SharedRefBase;
+
+constexpr uint16_t kDefaultAclHandle = 0x1234;
+
+class MockBluetoothChannelSoundingSessionCallback
+    : public BnBluetoothChannelSoundingSessionCallback {
+ public:
+  MOCK_METHOD(ScopedAStatus, onOpened, (Reason reason), (override));
+  MOCK_METHOD(ScopedAStatus, onOpenFailed, (Reason reason), (override));
+  MOCK_METHOD(ScopedAStatus, onResult, (const RangingResult& in_result),
+              (override));
+  MOCK_METHOD(ScopedAStatus, onClose, (Reason reason), (override));
+  MOCK_METHOD(ScopedAStatus, onCloseFailed, (Reason reason), (override));
+};
+
+class TestBluetoothChannelSoundingHandler
+    : public BluetoothChannelSoundingHandler {
+ public:
+  std::optional<std::reference_wrapper<SessionTracker>> GetTrackerWrapper(
+      uint16_t connection_handle) {
+    return GetTracker(connection_handle);
+  }
+
+  void OnBluetoothEnabledWrapper() { OnBluetoothEnabled(); }
+};
+
+class BluetoothChannelSoundingHandlerTest : public Test {
+ protected:
+  void SetUp() override {
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper_);
+    MockCsConfigLoader::SetMockLoader(&mock_cs_config_loader_);
+
+    bluetooth_channel_sounding_handler_ =
+        std::make_unique<TestBluetoothChannelSoundingHandler>();
+    mock_session_callback_ =
+        SharedRefBase::make<MockBluetoothChannelSoundingSessionCallback>();
+  }
+
+  static BluetoothChannelSoundingParameters BuildParam(
+      bool is_fake_notification_enabled, bool is_mode_0_channel_map_enabled) {
+    BluetoothChannelSoundingParameters param;
+    // Default acl handle.
+    param.aclHandle = kDefaultAclHandle;
+    param.vendorSpecificData = std::vector<std::optional<VendorSpecificData>>();
+    param.vendorSpecificData->resize(2);
+    param.vendorSpecificData->at(0) = VendorSpecificData{
+        .characteristicUuid = kUuidSpecialRangingSettingCapability,
+        .opaqueValue = std::vector<uint8_t>{
+            0,
+            static_cast<uint8_t>(is_fake_notification_enabled |
+                                 (is_mode_0_channel_map_enabled) << 1),
+            0, 0, 0}};
+    param.vendorSpecificData->at(1) = VendorSpecificData{
+        .characteristicUuid = kUuidSpecialRangingSettingCommand};
+
+    return param;
+  }
+
+  static HalPacket BuildCsSubevent(uint16_t acl_handle,
+                                   uint16_t procedure_counter) {
+    return HalPacket({0x04, 0x3e, 0x09, kLeCsSubEventResultCode,
+                      static_cast<uint8_t>(acl_handle & 0xff),
+                      static_cast<uint8_t>((acl_handle >> 8) & 0xff), 0, 0, 0,
+                      static_cast<uint8_t>(procedure_counter & 0xff), 0, 0});
+  }
+
+  static HalPacket BuildCsProcedureEnableCompleteEvent(uint16_t acl_handle) {
+    return HalPacket({0x04, 0x3e, 0x09, kLeCsProcedureEnableCompleteCode, 0x00,
+                      static_cast<uint8_t>(acl_handle & 0xff),
+                      static_cast<uint8_t>((acl_handle >> 8) & 0xff), 0, 0});
+  }
+
+  std::shared_ptr<IBluetoothChannelSoundingSession> TestAndGetSession(
+      const BluetoothChannelSoundingParameters& param,
+      bool is_mode_0_channel_map_enabled, bool is_session_valid = true) {
+    std::shared_ptr<IBluetoothChannelSoundingSession> session;
+
+    HalPacket packet =
+        BuildEnableMode0ChannelMapCommand(param.aclHandle, kCommandValueEnable);
+    EXPECT_CALL(mock_hci_router_, SendCommand(packet, _))
+        .Times(is_mode_0_channel_map_enabled);
+    EXPECT_CALL(*mock_session_callback_, onOpened(Reason::LOCAL_STACK_REQUEST))
+        .Times(1);
+    EXPECT_TRUE(bluetooth_channel_sounding_handler_->OpenSession(
+        param, mock_session_callback_, &session));
+    EXPECT_EQ(session != nullptr, is_session_valid);
+
+    return session;
+  }
+
+  std::optional<
+      std::reference_wrapper<BluetoothChannelSoundingHandler::SessionTracker>>
+  TestAndGetSessionTracker(uint16_t acl_handlle, uint16_t procedure_counter,
+                           bool is_fake_notification_enabled) {
+    auto session_tracker =
+        bluetooth_channel_sounding_handler_->GetTrackerWrapper(acl_handlle);
+    EXPECT_TRUE(session_tracker.has_value());
+    EXPECT_EQ(session_tracker->get().cur_procedure_counter, procedure_counter);
+    EXPECT_EQ(session_tracker->get().is_fake_notification_enabled,
+              is_fake_notification_enabled);
+
+    return session_tracker;
+  }
+
+  void TestHandleCsSubeventAndFakeNotification(
+      uint16_t acl_handle, uint16_t cur_procedure_counter,
+      uint16_t updated_procedure_counter, bool is_fake_notification_enabled,
+      int expected_times) {
+    auto session_tracker = TestAndGetSessionTracker(
+        acl_handle, cur_procedure_counter, is_fake_notification_enabled);
+
+    HalPacket cs_subevent =
+        BuildCsSubevent(acl_handle, updated_procedure_counter);
+    HalPacket ras_notification = BuildRasNotification(
+        session_tracker->get().parameters, updated_procedure_counter);
+
+    EXPECT_CALL(mock_hci_router_, SendPacketToStack(ras_notification))
+        .Times(expected_times);
+    bluetooth_channel_sounding_handler_->OnPacketCallback(cs_subevent);
+
+    EXPECT_EQ(session_tracker->get().cur_procedure_counter,
+              updated_procedure_counter);
+    EXPECT_EQ(session_tracker->get().is_fake_notification_enabled,
+              is_fake_notification_enabled);
+  }
+
+  std::unique_ptr<TestBluetoothChannelSoundingHandler>
+      bluetooth_channel_sounding_handler_;
+  MockHciRouter mock_hci_router_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+  MockAndroidBaseWrapper mock_android_base_wrapper_;
+  MockCsConfigLoader mock_cs_config_loader_;
+  std::shared_ptr<MockBluetoothChannelSoundingSessionCallback>
+      mock_session_callback_;
+};
+
+TEST_F(BluetoothChannelSoundingHandlerTest, HandleCalibrationCommands) {
+  const auto calibration_commands = std::vector<HalPacket>{
+      HalPacket({0x01, 0x02, 0x03, 0x04}), HalPacket({0x01, 0x05, 0x06, 0x07})};
+  EXPECT_CALL(mock_cs_config_loader_, GetCsCalibrationCommands)
+      .Times(1)
+      .WillOnce(ReturnRef(calibration_commands));
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(2);
+
+  bluetooth_channel_sounding_handler_->OnBluetoothEnabledWrapper();
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest, HandleEmptyCalibrationCommands) {
+  std::vector<HalPacket> empty_calibration_commands;
+  EXPECT_CALL(mock_cs_config_loader_, GetCsCalibrationCommands)
+      .Times(1)
+      .WillOnce(ReturnRef(empty_calibration_commands));
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(0);
+
+  bluetooth_channel_sounding_handler_->OnBluetoothEnabledWrapper();
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest, GetVendorSpecificDataReturnEmpty) {
+  std::optional<std::vector<std::optional<VendorSpecificData>>> data;
+
+  EXPECT_TRUE(
+      bluetooth_channel_sounding_handler_->GetVendorSpecificData(&data));
+  EXPECT_FALSE(data.has_value());
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       GetSupportedSessionTypesReturnDefaultValue) {
+  std::optional<std::vector<SessionType>> session_types;
+
+  EXPECT_TRUE(bluetooth_channel_sounding_handler_->GetSupportedSessionTypes(
+      &session_types));
+  EXPECT_TRUE(session_types.has_value());
+  EXPECT_EQ(*session_types,
+            std::vector<SessionType>{SessionType::SOFTWARE_STACK_DATA_PARSING});
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       GetMaxSupportedCsSecurityLevelReturnDefaultValue) {
+  CsSecurityLevel level;
+
+  EXPECT_TRUE(
+      bluetooth_channel_sounding_handler_->GetMaxSupportedCsSecurityLevel(
+          &level));
+  EXPECT_EQ(level, CsSecurityLevel::ONE);
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       NotOpenSessionWithParamTypeVendorSpecificReply) {
+  BluetoothChannelSoundingParameters param;
+
+  // Build parameter for data reply type.
+  param.vendorSpecificData = std::vector<std::optional<VendorSpecificData>>();
+  param.vendorSpecificData->resize(2);
+  param.vendorSpecificData->at(0) = VendorSpecificData{
+      .characteristicUuid = kUuidSpecialRangingSettingCapability,
+      .opaqueValue = {kDataTypeReply, 0, 0, 0, 0}};
+  param.vendorSpecificData->at(1) = VendorSpecificData{
+      .characteristicUuid = kUuidSpecialRangingSettingCommand};
+
+  std::shared_ptr<IBluetoothChannelSoundingSession> session;
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _)).Times(0);
+  EXPECT_CALL(*mock_session_callback_, onOpened(_)).Times(0);
+  EXPECT_TRUE(bluetooth_channel_sounding_handler_->OpenSession(
+      param, mock_session_callback_, &session));
+  EXPECT_EQ(session, nullptr);
+}
+
+// Parameterized test for fake notification and mode 0 channel map enablement.
+struct OpenSessionTestParameters {
+  bool is_fake_notification_enabled;
+  bool is_mode_0_channel_map_enabled;
+  bool expected_fake_notification_value;
+};
+
+class OpenSessionParameterizedTest
+    : public BluetoothChannelSoundingHandlerTest,
+      public WithParamInterface<OpenSessionTestParameters> {};
+
+TEST_P(OpenSessionParameterizedTest, HandleNotificationAndMode0ChannelMap) {
+  const auto& [is_fake_notification_enabled, is_mode_0_channel_map_enabled,
+               expected_fake_notification_value] = GetParam();
+
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  TestAndGetSessionTracker(kDefaultAclHandle, kInitialProcedureCounter,
+                           expected_fake_notification_value);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    CsSession, OpenSessionParameterizedTest,
+    ::testing::Values(OpenSessionTestParameters{true, false, true},
+                      OpenSessionTestParameters{false, false, false},
+                      OpenSessionTestParameters{false, true, false},
+                      OpenSessionTestParameters{true, true, true}));
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       HandleCsSubEventButAclHandleNotMatched) {
+  // CS subevent with acl handle kDefaultAclHandle and procedure counter
+  // 0xffff.
+  HalPacket cs_subevent =
+      BuildCsSubevent(kDefaultAclHandle, kInitialProcedureCounter);
+
+  bluetooth_channel_sounding_handler_->OnPacketCallback(cs_subevent);
+  auto session_tracker =
+      bluetooth_channel_sounding_handler_->GetTrackerWrapper(kDefaultAclHandle);
+  EXPECT_FALSE(session_tracker.has_value());
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       HandleCsSubEventAndSendFakeNotification) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = false;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  uint16_t cur_procedure_counter = kInitialProcedureCounter;
+  uint16_t updated_procedure_counter = 0x01;
+  int expected_times = 1;
+  TestHandleCsSubeventAndFakeNotification(
+      kDefaultAclHandle, cur_procedure_counter, updated_procedure_counter,
+      is_fake_notification_enabled, expected_times);
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       HandleDuplicateCsSubEventAndNotSendSecondFakeNotification) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = false;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  uint16_t cur_procedure_counter = kInitialProcedureCounter;
+  uint16_t updated_procedure_counter = 0x01;
+  int expected_times = 1;
+  TestHandleCsSubeventAndFakeNotification(
+      kDefaultAclHandle, cur_procedure_counter, updated_procedure_counter,
+      is_fake_notification_enabled, expected_times);
+
+  // Proceed the second same cs subevent and skip sending notification.
+  cur_procedure_counter = 0x01;
+  expected_times = 0;
+  TestHandleCsSubeventAndFakeNotification(
+      kDefaultAclHandle, cur_procedure_counter, updated_procedure_counter,
+      is_fake_notification_enabled, expected_times);
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       HandleCsSubEventButFakeNotificationNotEnabled) {
+  bool is_fake_notification_enabled = false;
+  bool is_mode_0_channel_map_enabled = false;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  uint16_t cur_procedure_counter = kInitialProcedureCounter;
+  uint16_t updated_procedure_counter = kInitialProcedureCounter;
+  int expected_times = 0;
+  TestHandleCsSubeventAndFakeNotification(
+      kDefaultAclHandle, cur_procedure_counter, updated_procedure_counter,
+      is_fake_notification_enabled, expected_times);
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       HandleCsProcedureEnableCompleteAndResetCounter) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = true;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  uint16_t cur_procedure_counter = kInitialProcedureCounter;
+  uint16_t updated_procedure_counter = 0x01;
+  int expected_times = 1;
+  TestHandleCsSubeventAndFakeNotification(
+      kDefaultAclHandle, cur_procedure_counter, updated_procedure_counter,
+      is_fake_notification_enabled, expected_times);
+
+  // Subevent for cs procedure enable complete and reset counter from 0x01 to
+  // 0xffff.
+  HalPacket cs_procedure_complete_event =
+      BuildCsProcedureEnableCompleteEvent(kDefaultAclHandle);
+
+  bluetooth_channel_sounding_handler_->OnPacketCallback(
+      cs_procedure_complete_event);
+  // Counter is reset to 0xffff.
+  auto session_tracker =
+      bluetooth_channel_sounding_handler_->GetTrackerWrapper(kDefaultAclHandle);
+  EXPECT_EQ(session_tracker->get().cur_procedure_counter,
+            kInitialProcedureCounter);
+}
+
+TEST_F(BluetoothChannelSoundingHandlerTest,
+       HandleCsProcedureEnableCompleteButNotResetCounter) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = true;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  uint16_t cur_procedure_counter = kInitialProcedureCounter;
+  uint16_t updated_procedure_counter = 0x01;
+  int expected_times = 1;
+  TestHandleCsSubeventAndFakeNotification(
+      kDefaultAclHandle, cur_procedure_counter, updated_procedure_counter,
+      is_fake_notification_enabled, expected_times);
+
+  // Subevent for cs procedure enable complete for connection handle 0x1245.
+  HalPacket cs_procedure_complete_event =
+      BuildCsProcedureEnableCompleteEvent(0x1245);
+
+  bluetooth_channel_sounding_handler_->OnPacketCallback(
+      cs_procedure_complete_event);
+  // Counter is not changed.
+  auto session_tracker =
+      bluetooth_channel_sounding_handler_->GetTrackerWrapper(kDefaultAclHandle);
+  EXPECT_EQ(session_tracker->get().cur_procedure_counter,
+            updated_procedure_counter);
+}
+
+class BluetoothChannelSoundingSessionTest
+    : public BluetoothChannelSoundingHandlerTest {};
+
+TEST_F(BluetoothChannelSoundingSessionTest,
+       GetVendorSpecificRepliesWithUuidNotMatchedReturnEmpty) {
+  BluetoothChannelSoundingParameters param;
+  // Build parameter to not match with certain uuid.
+  param.aclHandle = kDefaultAclHandle;
+
+  bool is_mode_0_channel_map_enabled = false;
+  std::shared_ptr<IBluetoothChannelSoundingSession> session =
+      TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  std::optional<std::vector<std::optional<VendorSpecificData>>>
+      vendor_specific_data;
+  ScopedAStatus status =
+      session->getVendorSpecificReplies(&vendor_specific_data);
+  EXPECT_TRUE(status.isOk());
+  EXPECT_FALSE(vendor_specific_data.has_value());
+}
+
+struct VendorSpecificTestParams {
+  bool is_fake_notification_enabled;
+  bool is_mode_0_channel_map_enabled;
+  std::vector<std::optional<VendorSpecificData>> vendor_specific_data;
+};
+
+class VendorSpecificRepliesTest
+    : public BluetoothChannelSoundingSessionTest,
+      public WithParamInterface<VendorSpecificTestParams> {
+ public:
+  static std::vector<std::optional<VendorSpecificData>> BuildData(
+      bool is_fake_notification_enabled, bool is_mode_0_channel_map_enabled) {
+    uint8_t enable_one_side_pct = is_fake_notification_enabled
+                                      ? kCommandValueEnable
+                                      : kCommandValueIgnore;
+    uint8_t enable_cs_subevent_report = is_fake_notification_enabled
+                                            ? kCommandValueDisable
+                                            : kCommandValueIgnore;
+    uint8_t enable_mode_0_channel_map = is_mode_0_channel_map_enabled
+                                            ? kCommandValueEnable
+                                            : kCommandValueIgnore;
+
+    VendorSpecificData capability;
+    capability.characteristicUuid = kUuidSpecialRangingSettingCapability;
+    capability.opaqueValue = {kDataTypeReply, 0x00, 0x00, 0x00, 0x00};
+
+    VendorSpecificData command;
+    command.characteristicUuid = kUuidSpecialRangingSettingCommand;
+    command.opaqueValue = {kDataTypeReply, enable_one_side_pct,
+                           enable_cs_subevent_report,
+                           enable_mode_0_channel_map};
+
+    return {capability, command};
+  }
+};
+
+TEST_P(VendorSpecificRepliesTest, HandleDifferentVendorSpecificReplies) {
+  const auto& [is_fake_notification_enabled, is_mode_0_channel_map_enabled,
+               expected_vendor_specific_data] = GetParam();
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  std::shared_ptr<IBluetoothChannelSoundingSession> session =
+      TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  std::optional<std::vector<std::optional<VendorSpecificData>>>
+      vendor_specific_data;
+  ScopedAStatus status =
+      session->getVendorSpecificReplies(&vendor_specific_data);
+  EXPECT_TRUE(status.isOk());
+  EXPECT_TRUE(vendor_specific_data.has_value());
+  EXPECT_EQ(*vendor_specific_data, expected_vendor_specific_data);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    CsSession, VendorSpecificRepliesTest,
+    Values(
+        VendorSpecificTestParams{
+            .is_fake_notification_enabled = false,
+            .is_mode_0_channel_map_enabled = false,
+            .vendor_specific_data =
+                VendorSpecificRepliesTest::BuildData(false, false)},
+        VendorSpecificTestParams{
+            .is_fake_notification_enabled = false,
+            .is_mode_0_channel_map_enabled = true,
+            .vendor_specific_data = VendorSpecificRepliesTest::BuildData(false,
+                                                                         true)},
+        VendorSpecificTestParams{
+            .is_fake_notification_enabled = true,
+            .is_mode_0_channel_map_enabled = false,
+            .vendor_specific_data =
+                VendorSpecificRepliesTest::BuildData(true, false)},
+        VendorSpecificTestParams{
+            .is_fake_notification_enabled = true,
+            .is_mode_0_channel_map_enabled = true,
+            .vendor_specific_data =
+                VendorSpecificRepliesTest::BuildData(true, true)}));
+
+TEST_F(BluetoothChannelSoundingSessionTest,
+       GetSupportedResultTypesReturnDefaultTypes) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = false;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  std::shared_ptr<IBluetoothChannelSoundingSession> session =
+      TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  std::vector<ResultType> result_types;
+  ScopedAStatus status = session->getSupportedResultTypes(&result_types);
+  EXPECT_TRUE(status.isOk());
+  EXPECT_EQ(result_types, std::vector<ResultType>{ResultType::RESULT_METERS});
+}
+
+TEST_F(BluetoothChannelSoundingSessionTest, HandleIsAbortedProcedureRequired) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = false;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  std::shared_ptr<IBluetoothChannelSoundingSession> session =
+      TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  bool is_aborted_procedure_required = true;
+  ScopedAStatus status =
+      session->isAbortedProcedureRequired(&is_aborted_procedure_required);
+  EXPECT_TRUE(status.isOk());
+  EXPECT_FALSE(is_aborted_procedure_required);
+}
+
+TEST_F(BluetoothChannelSoundingSessionTest, CloseSession) {
+  bool is_fake_notification_enabled = true;
+  bool is_mode_0_channel_map_enabled = false;
+  BluetoothChannelSoundingParameters param =
+      BuildParam(is_fake_notification_enabled, is_mode_0_channel_map_enabled);
+
+  std::shared_ptr<IBluetoothChannelSoundingSession> session =
+      TestAndGetSession(param, is_mode_0_channel_map_enabled);
+
+  EXPECT_CALL(*mock_session_callback_, onClose(Reason::LOCAL_STACK_REQUEST))
+      .Times(1);
+  ScopedAStatus status = session->close(Reason::LOCAL_STACK_REQUEST);
+  EXPECT_TRUE(status.isOk());
+}
+
+}  // namespace
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.cc b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.cc
new file mode 100644
index 0000000000..8006c468c2
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.cc
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.cs"
+
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.h"
+
+#include <cstdint>
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/ChannelSoudingRawData.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/RangingResult.h"
+#include "aidl/android/hardware/bluetooth/ranging/Reason.h"
+#include "aidl/android/hardware/bluetooth/ranging/ResultType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android-base/logging.h"
+#include "android-base/properties.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_algorithm.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+using ::aidl::android::hardware::bluetooth::ranging::ChannelSoudingRawData;
+using ::aidl::android::hardware::bluetooth::ranging::
+    IBluetoothChannelSoundingSessionCallback;
+using ::aidl::android::hardware::bluetooth::ranging::RangingResult;
+using ::aidl::android::hardware::bluetooth::ranging::Reason;
+using ::aidl::android::hardware::bluetooth::ranging::ResultType;
+using ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData;
+
+using ::android::base::GetBoolProperty;
+using ::android::base::GetUintProperty;
+using ::bluetooth_hal::Property;
+
+using ::ndk::ScopedAStatus;
+
+// Feature.
+constexpr uint8_t kOneSidePct = 0x01;
+constexpr uint8_t kMode0ChannelMap = 0x02;
+
+static std::unique_ptr<ChannelSoundingAlgorithm> channel_sounding_algorithm =
+    nullptr;
+
+BluetoothChannelSoundingSession::BluetoothChannelSoundingSession(
+    std::shared_ptr<IBluetoothChannelSoundingSessionCallback> callback,
+    Reason /* reason */) {
+  callback_ = callback;
+  if (channel_sounding_algorithm == nullptr) {
+    channel_sounding_algorithm = std::make_unique<ChannelSoundingAlgorithm>();
+  }
+}
+
+ScopedAStatus BluetoothChannelSoundingSession::getVendorSpecificReplies(
+    std::optional<std::vector<std::optional<VendorSpecificData>>>*
+        _aidl_return) {
+  LOG(INFO) << __func__;
+
+  if (!uuid_matched_) {
+    LOG(INFO) << "UUID doesn't matched, ignore";
+    return ScopedAStatus::ok();
+  }
+
+  *_aidl_return =
+      std::make_optional<std::vector<std::optional<VendorSpecificData>>>();
+  VendorSpecificData capability;
+  capability.characteristicUuid = kUuidSpecialRangingSettingCapability;
+  capability.opaqueValue = {kDataTypeReply, 0x00, 0x00, 0x00, 0x00};
+  (*_aidl_return)->push_back(capability);
+
+  uint8_t enable_one_side_pct =
+      enable_fake_notification_ ? kCommandValueEnable : kCommandValueIgnore;
+  uint8_t enable_cs_subevent_report =
+      enable_fake_notification_ ? kCommandValueDisable : kCommandValueIgnore;
+  uint8_t enable_mode_0_channel_map =
+      enable_mode_0_channel_map_ ? kCommandValueEnable : kCommandValueIgnore;
+
+  VendorSpecificData command;
+  command.characteristicUuid = kUuidSpecialRangingSettingCommand;
+  command.opaqueValue = {kDataTypeReply, enable_one_side_pct,
+                         enable_cs_subevent_report, enable_mode_0_channel_map};
+  (*_aidl_return)->push_back(command);
+
+  for (auto& data : _aidl_return->value()) {
+    LOG(INFO) << "uuid:" << ToHex(data->characteristicUuid)
+              << ", data:" << ToHex(data->opaqueValue);
+  }
+
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothChannelSoundingSession::getSupportedResultTypes(
+    std::vector<ResultType>* _aidl_return) {
+  std::vector<ResultType> supported_result_types = {ResultType::RESULT_METERS};
+  *_aidl_return = supported_result_types;
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothChannelSoundingSession::isAbortedProcedureRequired(
+    bool* _aidl_return) {
+  *_aidl_return = false;
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothChannelSoundingSession::writeRawData(
+    const ChannelSoudingRawData& in_rawData) {
+  if (in_rawData.stepChannels.empty()) {
+    LOG(WARNING) << __func__ << " in_rawData.stepChannels is empty, skip";
+    return ScopedAStatus::ok();
+  }
+
+  RangingResult ranging_result;
+  channel_sounding_algorithm->reset_variables();
+  ranging_result.resultMeters =
+      channel_sounding_algorithm->estimate_distance(in_rawData);
+  ranging_result.confidenceLevel =
+      channel_sounding_algorithm->get_confidence_level() * 100;
+  callback_->onResult(ranging_result);
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothChannelSoundingSession::close(Reason in_reason) {
+  callback_->onClose(in_reason);
+  return ScopedAStatus::ok();
+}
+
+void BluetoothChannelSoundingSession::HandleVendorSpecificData(
+    const std::optional<std::vector<std::optional<VendorSpecificData>>>
+        vendor_specific_data) {
+  uuid_matched_ = IsUuidMatched(vendor_specific_data);
+  if (!uuid_matched_) {
+    return;
+  }
+
+  auto uuid0 = vendor_specific_data.value()[0];
+  uint8_t vendor_specific_data_byte_1 =
+      GetUintProperty(Property::kChannelSoundingVendorSpecificFirstDataByte,
+                      uuid0.value().opaqueValue[1]);
+  LOG(INFO) << __func__
+            << " vendor_specific_data_byte_1: " << vendor_specific_data_byte_1;
+
+  if ((vendor_specific_data_byte_1 & kOneSidePct) != 0) {
+    LOG(INFO) << __func__ << " support 1-side PCT";
+    enable_fake_notification_ = true;
+  } else {
+    LOG(INFO) << __func__ << " do not support 1-side PCT";
+    enable_fake_notification_ = false;
+  }
+  if ((vendor_specific_data_byte_1 & kMode0ChannelMap) != 0) {
+    LOG(INFO) << __func__ << " support mode 0 Channel Map";
+    enable_mode_0_channel_map_ = true;
+  } else {
+    LOG(INFO) << __func__ << " do not support mode 0 Channel Map";
+    enable_mode_0_channel_map_ = false;
+  }
+}
+
+bool BluetoothChannelSoundingSession::ShouldEnableFakeNotification() {
+  return enable_fake_notification_;
+}
+
+bool BluetoothChannelSoundingSession::ShouldEnableMode0ChannelMap() {
+  return enable_mode_0_channel_map_;
+}
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.cc b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.cc
new file mode 100644
index 0000000000..09989f9dbb
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.cc
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.cs"
+
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h"
+
+#include <cstdint>
+#include <iomanip>
+#include <ios>
+#include <optional>
+#include <span>
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+using ::aidl::android::hardware::bluetooth::ranging::
+    BluetoothChannelSoundingParameters;
+using ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData;
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+
+std::string ToHex(const std::span<const uint8_t> data) {
+  std::stringstream ss;
+  ss << std::hex << std::uppercase;
+  for (const uint8_t byte : data) {
+    ss << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
+  }
+  return ss.str();
+}
+
+bool IsUuidMatched(
+    const std::optional<std::vector<std::optional<VendorSpecificData>>>
+        vendor_specific_data) {
+  if (!vendor_specific_data.has_value()) {
+    LOG(WARNING) << __func__ << " no value";
+    return false;
+  }
+
+  const auto& data = *vendor_specific_data;
+
+  if (data.size() < kMinNumUuid) {
+    LOG(WARNING) << __func__ << " invalid size";
+    return false;
+  }
+
+  const auto uuid0 = data[0];
+  if (!uuid0.has_value() ||
+      uuid0->characteristicUuid != kUuidSpecialRangingSettingCapability) {
+    LOG(WARNING) << __func__
+                 << " uuid0 doesn't match kUuidSpecialRangingSettingCapability";
+    return false;
+  }
+
+  if (uuid0->opaqueValue.size() < 5) {
+    LOG(WARNING) << __func__
+                 << " invalid data for kUuidSpecialRangingSettingCapability";
+    return false;
+  }
+
+  const auto uuid1 = data[1];
+  if (!uuid1.has_value() ||
+      uuid1->characteristicUuid != kUuidSpecialRangingSettingCommand) {
+    LOG(WARNING) << __func__
+                 << " uuid0 doesn't match kUuidSpecialRangingSettingCommand";
+    return false;
+  }
+
+  return true;
+}
+
+HalPacket BuildReadLocalCapabilityCommand() {
+  HalPacket command;
+  command.resize(1 + 3 + kHciVscReadLocalCapabilityParamLength);
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscSpecialRangingSettingOpcode & 0xff;
+  command[2] = (kHciVscSpecialRangingSettingOpcode >> 8u) & 0xff;
+  command[3] = kHciVscReadLocalCapabilityParamLength;
+  command[4] = kHciVscReadLocalCapabilitySubOpCode;
+
+  return command;
+}
+
+HalPacket BuildEnableOneSidePctCommand(uint8_t enable) {
+  HalPacket command;
+  command.resize(1 + 3 + kHciVscEnableOneSidePctParamLength);
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscSpecialRangingSettingOpcode & 0xff;
+  command[2] = (kHciVscSpecialRangingSettingOpcode >> 8u) & 0xff;
+  command[3] = kHciVscEnableOneSidePctParamLength;
+  command[4] = kHciVscEnableOneSidePctSubOpCode;
+  command[5] = enable;
+
+  return command;
+}
+
+HalPacket BuildEnableCsSubeventReportCommand(uint16_t connection_handle,
+                                             uint8_t enable) {
+  HalPacket command;
+  command.resize(1 + 3 + kHciVscEnableCsSubeventReportParamLength);
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscSpecialRangingSettingOpcode & 0xff;
+  command[2] = (kHciVscSpecialRangingSettingOpcode >> 8u) & 0xff;
+  command[3] = kHciVscEnableCsSubeventReportParamLength;
+  command[4] = kHciVscEnableCsSubeventReportSubOpCode;
+  command[5] = connection_handle & 0xff;
+  command[6] = (connection_handle >> 8u) & 0xff;
+  command[7] = enable;
+
+  return command;
+}
+
+HalPacket BuildEnableMode0ChannelMapCommand(uint16_t connection_handle,
+                                            uint8_t enable) {
+  HalPacket command;
+  command.resize(1 + 3 + kHciVscEnableMode0ChannelMapParamLength);
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscSpecialRangingSettingOpcode & 0xff;
+  command[2] = (kHciVscSpecialRangingSettingOpcode >> 8u) & 0xff;
+  command[3] = kHciVscEnableMode0ChannelMapParamLength;
+  command[4] = kHciVscEnableMode0ChannelMapSubOpCode;
+  command[5] = connection_handle & 0xff;
+  command[6] = (connection_handle >> 8u) & 0xff;
+  command[7] = enable;
+
+  return command;
+}
+
+HalPacket BuildRasNotification(
+    const BluetoothChannelSoundingParameters& parameters,
+    int procedure_counter) {
+  uint16_t connection_handle = parameters.aclHandle;
+  connection_handle |= kFlagFirstAutomaticallyFlushablePacket;
+
+  HalPacket packet;
+  packet.resize(1 + kFakeRasDataLen);
+
+  uint16_t acl_data_len = kFakeRasDataLen - 4;
+  uint16_t l2cap_data_len = acl_data_len - 4;
+  uint16_t cid_att = 0x0004;
+  uint16_t start_acl_conn_event = 0x0053;
+  uint16_t frequency_compensation = 0x0000;
+
+  packet[0] = static_cast<uint8_t>(HciPacketType::kAclData);
+  packet[1] = connection_handle & 0xff;
+  packet[2] = (connection_handle >> 8u) & 0xff;
+  packet[3] = acl_data_len & 0xff;
+  packet[4] = (acl_data_len >> 8u) & 0xff;
+  packet[5] = l2cap_data_len & 0xff;
+  packet[6] = (l2cap_data_len >> 8u) & 0xff;
+  packet[7] = cid_att & 0xff;
+  packet[8] = (cid_att >> 8u) & 0xff;
+  packet[9] = kGattNotification;
+  packet[10] = parameters.realTimeProcedureDataAttHandle & 0xff;
+  packet[11] = (parameters.realTimeProcedureDataAttHandle >> 8u) & 0xff;
+  // RAS fragment data.
+  packet[12] = 0x03;  // segmentation_header, first and last fragment.
+  packet[13] = procedure_counter & 0xff;  // ranging counter.
+  packet[14] = ((procedure_counter >> 8u) & 0x0f) +
+               0x10;  // ranging_counter and configuration_id.
+  packet[15] = 0xe0;  // selected_tx_power.
+  packet[16] = 0x01;  // antenna_paths_mask, PctFormat.
+  packet[17] = start_acl_conn_event & 0xff;
+  packet[18] = (start_acl_conn_event >> 8u) & 0xff;
+  packet[19] = frequency_compensation & 0xff;
+  packet[20] = (frequency_compensation >> 8u) & 0xff;
+  packet[21] = 0x00;  // RangingDoneStatus, RangingDoneStatus.
+  packet[22] = 0x00;  // RangingAbortReason, SubeventAbortReason.
+  packet[23] = 0xe7;  // reference_power_level.
+  packet[24] = 0x00;  // num_steps_reported.
+
+  return packet;
+}
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext.cc b/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext.cc
new file mode 100644
index 0000000000..342e33c389
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext.cc
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ext/bluetooth_ext.h"
+
+#include <cstdint>
+#include <vector>
+
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/ext/bluetooth_ext_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ext {
+
+using ::ndk::ScopedAStatus;
+
+ScopedAStatus BluetoothExt::setBluetoothCmdPacket(
+    char16_t opcode, const std::vector<uint8_t>& params, bool* ret) {
+  bool status = handler_.SetBluetoothCmdPacket(opcode, params, ret);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+}  // namespace ext
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext_handler.cc b/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext_handler.cc
new file mode 100644
index 0000000000..6ad2f54ae9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext_handler.cc
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.ext"
+
+#include "bluetooth_hal/extensions/ext/bluetooth_ext_handler.h"
+
+#include <atomic>
+#include <chrono>
+#include <cstdint>
+#include <cstring>
+#include <future>
+#include <mutex>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ext {
+
+constexpr int kMaxCommandWaitTimeMs = 1000;
+
+using ::android::base::StringPrintf;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+
+bool BluetoothExtHandler::SetBluetoothCmdPacket(
+    char16_t opcode, const std::vector<uint8_t>& params, bool* ret) {
+  std::lock_guard<std::mutex> lock(cmd_mutex_);
+
+  // Reset promise and success state for the new command.
+  command_promise_ = std::promise<void>();
+  std::future<void> event_future = command_promise_.get_future();
+  command_success_.store(false, std::memory_order_relaxed);
+
+  uint8_t params_len = params.size();
+
+  HalPacket hci_cmd;
+  uint8_t cmd_length = HciConstants::kHciCommandPreambleSize + params_len;
+
+  hci_cmd.resize(1 + cmd_length);
+
+  hci_cmd[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  hci_cmd[1] = opcode & 0xff;
+  hci_cmd[2] = (opcode >> 8u) & 0xff;
+  hci_cmd[3] = params_len;
+
+  if (params_len > 0) {
+    // Parameters start after Type (1), Opcode (2), Length (1) = 4 bytes
+    memcpy(hci_cmd.data() + 1 + HciConstants::kHciCommandPreambleSize,
+           params.data(), params_len);
+  }
+
+  std::string submsg = StringPrintf("0x%04x LEN 0x%02x", opcode, params_len);
+  LOG(INFO) << __func__ << ": Inject hci_cmd: " << submsg;
+
+  SendCommand(hci_cmd);
+
+  std::future_status future_status =
+      event_future.wait_for(std::chrono::milliseconds(kMaxCommandWaitTimeMs));
+
+  if (future_status == std::future_status::timeout) {
+    LOG(WARNING) << __func__ << ": Wait for VSE 0x" << std::hex
+                 << static_cast<uint16_t>(opcode) << " timed out after "
+                 << kMaxCommandWaitTimeMs << "ms";
+    *ret = false;
+  } else if (future_status == std::future_status::deferred) {
+    LOG(ERROR) << __func__ << ": Future was deferred for VSE 0x" << std::hex
+               << static_cast<uint16_t>(opcode);
+    *ret = false;
+  } else {
+    *ret = command_success_.load(std::memory_order_relaxed);
+  }
+
+  return true;
+}
+
+void BluetoothExtHandler::OnCommandCallback(
+    const ::bluetooth_hal::hci::HalPacket& event) {
+  bool success = (event.GetCommandCompleteEventResult() ==
+                  static_cast<uint8_t>(EventResultCode::kSuccess));
+
+  LOG(success ? INFO : WARNING)
+      << __func__ << ": Recv VSE "
+      << (command_success_ ? "[Success]" : "[Failed]");
+
+  command_success_.store(success, std::memory_order_relaxed);
+  command_promise_.set_value();
+}
+
+}  // namespace ext
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext_handler_test.cc b/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext_handler_test.cc
new file mode 100644
index 0000000000..144568cb3e
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/ext/bluetooth_ext_handler_test.cc
@@ -0,0 +1,278 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/ext/bluetooth_ext_handler.h"
+
+#include <chrono>
+#include <cstdint>
+#include <cstring>
+#include <future>
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ext {
+namespace {
+
+using ::testing::_;
+using ::testing::Action;
+using ::testing::DoAll;
+using ::testing::Mock;
+using ::testing::NotNull;
+using ::testing::Return;
+using ::testing::SaveArg;
+using ::testing::StrictMock;
+using ::testing::Test;
+
+using ::bluetooth_hal::hci::EventCode;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::HciRouterCallback;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+using ::bluetooth_hal::hci::MonitorMode;
+
+// Helper Action to signal when SendCommand is called.
+ACTION_P(SignalPromise, p) { p->set_value(); }
+
+// Helper Action to save HalPacket argument.
+ACTION_P(SaveHalPacketArg, ptr) {
+  *ptr = arg0;  // Assuming arg0 is the HalPacket.
+}
+
+class BluetoothExtHandlerTest : public Test {
+ protected:
+  void SetUp() override {
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    EXPECT_CALL(mock_hci_router_client_agent_, RegisterRouterClient(NotNull()))
+        .WillOnce(DoAll(SaveArg<0>(&router_callback_), Return(true)));
+
+    handler_ = std::make_unique<BluetoothExtHandler>();
+
+    ON_CALL(mock_hci_router_, SendCommand(_, _)).WillByDefault(Return(true));
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mock_hci_router_client_agent_,
+                UnregisterRouterClient(handler_.get()))
+        .WillOnce(Return(true));
+    handler_.reset();
+    MockHciRouter::SetMockRouter(nullptr);
+  }
+
+  HalPacket CreateCommandCompleteEvent(uint16_t opcode,
+                                       EventResultCode status) {
+    HalPacket event_packet({
+        static_cast<uint8_t>(HciPacketType::kEvent),
+        static_cast<uint8_t>(EventCode::kCommandComplete),
+        0x04,  // Parameter Total Length (Num Packets(1) + OpCode(2) + Status(1)
+               // = 4)
+        0x01,  // Number of HCI command packets allowed to be sent.
+        static_cast<uint8_t>(opcode & 0xff),
+        static_cast<uint8_t>((opcode >> 8) & 0xff),
+        static_cast<uint8_t>(status),
+    });
+    return event_packet;
+  }
+
+  // Helper to build expected command packet
+  HalPacket BuildExpectedCommand(uint16_t opcode,
+                                 const std::vector<uint8_t>& params) {
+    HalPacket expected_cmd;
+    uint8_t params_len = params.size();
+    uint8_t cmd_length = HciConstants::kHciCommandPreambleSize + params_len;
+    expected_cmd.resize(1 + cmd_length);  // Type + Preamble + Params
+
+    expected_cmd[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+    expected_cmd[1] = opcode & 0xff;
+    expected_cmd[2] = (opcode >> 8u) & 0xff;
+    expected_cmd[3] = params_len;
+    if (params_len > 0) {
+      memcpy(expected_cmd.data() + 1 + HciConstants::kHciCommandPreambleSize,
+             params.data(), params_len);
+    }
+    return expected_cmd;
+  }
+
+  std::unique_ptr<BluetoothExtHandler> handler_;
+  HciRouterCallback* router_callback_ = nullptr;
+  StrictMock<MockHciRouter> mock_hci_router_;
+  StrictMock<MockHciRouterClientAgent> mock_hci_router_client_agent_;
+};
+
+TEST_F(BluetoothExtHandlerTest, SetBluetoothCmdPacketReturnSuccess) {
+  ASSERT_NE(router_callback_, nullptr);
+  const uint16_t test_opcode = 0xfc01;
+  const std::vector<uint8_t> test_params = {0x01, 0x02, 0x03};
+  bool result = false;
+
+  HalPacket expected_cmd = BuildExpectedCommand(test_opcode, test_params);
+  HalPacket sent_cmd;  // To capture the actual sent command
+
+  std::promise<void> cmd_sent_promise;
+  std::future<void> cmd_sent_future = cmd_sent_promise.get_future();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _))
+      .WillOnce(DoAll(SaveHalPacketArg(&sent_cmd),
+                      SignalPromise(&cmd_sent_promise), Return(true)));
+
+  auto future_result = std::async(std::launch::async, [&]() {
+    return handler_->SetBluetoothCmdPacket(test_opcode, test_params, &result);
+  });
+
+  // Wait for SendCommand to be called.
+  ASSERT_EQ(cmd_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready)
+      << "SendCommand was not called";
+
+  // Verify the sent command packet contents.
+  EXPECT_EQ(sent_cmd, expected_cmd);
+
+  // Simulate the success callback.
+  HalPacket success_event =
+      CreateCommandCompleteEvent(test_opcode, EventResultCode::kSuccess);
+  router_callback_->OnCommandCallback(success_event);
+
+  // Wait for SetBluetoothCmdPacket to finish and check results.
+  EXPECT_TRUE(
+      future_result.get());  // Check the return value of SetBluetoothCmdPacket.
+  EXPECT_TRUE(result);       // Check the output parameter 'ret'.
+}
+
+TEST_F(BluetoothExtHandlerTest,
+       SetBluetoothCmdPacketReturnSuccessWithNoParams) {
+  ASSERT_NE(router_callback_, nullptr);
+  const uint16_t test_opcode = 0xfc02;
+  const std::vector<uint8_t> test_params = {};
+  bool result = false;
+
+  HalPacket expected_cmd = BuildExpectedCommand(test_opcode, test_params);
+  HalPacket sent_cmd;
+
+  std::promise<void> cmd_sent_promise;
+  std::future<void> cmd_sent_future = cmd_sent_promise.get_future();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _))
+      .WillOnce(DoAll(SaveHalPacketArg(&sent_cmd),
+                      SignalPromise(&cmd_sent_promise), Return(true)));
+
+  auto future_result = std::async(std::launch::async, [&]() {
+    return handler_->SetBluetoothCmdPacket(test_opcode, test_params, &result);
+  });
+
+  ASSERT_EQ(cmd_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+
+  EXPECT_EQ(sent_cmd, expected_cmd);
+
+  HalPacket success_event =
+      CreateCommandCompleteEvent(test_opcode, EventResultCode::kSuccess);
+  router_callback_->OnCommandCallback(success_event);
+
+  EXPECT_TRUE(future_result.get());
+  EXPECT_TRUE(result);
+}
+
+TEST_F(BluetoothExtHandlerTest, SetBluetoothCmdPacketReturnCallbackFailure) {
+  ASSERT_NE(router_callback_, nullptr);
+  const uint16_t test_opcode = 0xfc03;
+  const std::vector<uint8_t> test_params = {0x0a, 0x0b};
+  bool result = true;  // Initialize to non-default
+
+  HalPacket expected_cmd = BuildExpectedCommand(test_opcode, test_params);
+  HalPacket sent_cmd;
+
+  std::promise<void> cmd_sent_promise;
+  std::future<void> cmd_sent_future = cmd_sent_promise.get_future();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _))
+      .WillOnce(DoAll(SaveHalPacketArg(&sent_cmd),
+                      SignalPromise(&cmd_sent_promise), Return(true)));
+
+  auto future_result = std::async(std::launch::async, [&]() {
+    return handler_->SetBluetoothCmdPacket(test_opcode, test_params, &result);
+  });
+
+  ASSERT_EQ(cmd_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+
+  EXPECT_EQ(sent_cmd, expected_cmd);
+
+  // Simulate the failure callback.
+  HalPacket failure_event =
+      CreateCommandCompleteEvent(test_opcode, EventResultCode::kFailure);
+  router_callback_->OnCommandCallback(failure_event);
+
+  // Wait for SetBluetoothCmdPacket to finish and check results.
+  EXPECT_TRUE(future_result.get());
+  EXPECT_FALSE(result);
+}
+
+TEST_F(BluetoothExtHandlerTest, SetBluetoothCmdPacketReturnCommandTimeout) {
+  ASSERT_NE(router_callback_, nullptr);
+  const uint16_t test_opcode = 0xfc04;
+  const std::vector<uint8_t> test_params = {0x0c};
+  bool result = true;  // Initialize to non-default
+
+  HalPacket expected_cmd = BuildExpectedCommand(test_opcode, test_params);
+  HalPacket sent_cmd;
+
+  std::promise<void> cmd_sent_promise;
+  std::future<void> cmd_sent_future = cmd_sent_promise.get_future();
+
+  EXPECT_CALL(mock_hci_router_, SendCommand(_, _))
+      .WillOnce(DoAll(SaveHalPacketArg(&sent_cmd),
+                      SignalPromise(&cmd_sent_promise), Return(true)));
+
+  // Run SetBluetoothCmdPacket. We expect it to block until timeout.
+  // kMaxCommandWaitTimeMs is 1000ms.
+  auto future_result = std::async(std::launch::async, [&]() {
+    return handler_->SetBluetoothCmdPacket(test_opcode, test_params, &result);
+  });
+
+  // Wait for SendCommand to be called.
+  ASSERT_EQ(cmd_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+
+  EXPECT_EQ(sent_cmd, expected_cmd);
+
+  std::future_status status = future_result.wait_for(
+      std::chrono::milliseconds(1500));  // Wait > 1000ms.
+
+  ASSERT_EQ(status, std::future_status::ready)
+      << "SetBluetoothCmdPacket did not return after expected timeout.";
+
+  // Check results after timeout.
+  EXPECT_TRUE(future_result.get());
+  EXPECT_FALSE(result);
+}
+
+}  // namespace
+}  // namespace ext
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder.cc b/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder.cc
new file mode 100644
index 0000000000..86543aeb81
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder.cc
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/finder/bluetooth_finder.h"
+
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/finder/Eid.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/finder/bluetooth_finder_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace finder {
+
+using ::aidl::android::hardware::bluetooth::finder::Eid;
+
+using ::ndk::ScopedAStatus;
+
+BluetoothFinder::BluetoothFinder()
+    : handler_(BluetoothFinderHandler::GetHandler()) {}
+
+ScopedAStatus BluetoothFinder::sendEids(const std::vector<Eid>& eids) {
+  bool status = handler_.SendEids(eids);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothFinder::setPoweredOffFinderMode(bool enable) {
+  bool status = handler_.SetPoweredOffFinderMode(enable);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothFinder::getPoweredOffFinderMode(bool* _aidl_return) {
+  bool status = handler_.GetPoweredOffFinderMode(_aidl_return);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+}  // namespace finder
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder_handler.cc b/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder_handler.cc
new file mode 100644
index 0000000000..506cc687c0
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder_handler.cc
@@ -0,0 +1,336 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.finder"
+
+#include "bluetooth_hal/extensions/finder/bluetooth_finder_handler.h"
+
+#include <chrono>
+#include <cstdint>
+#include <future>
+#include <mutex>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/finder/Eid.h"
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/android_base_wrapper.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace finder {
+
+using ::aidl::android::hardware::bluetooth::finder::Eid;
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::hci::CommandOpCode;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::MonitorMode;
+using ::bluetooth_hal::util::AndroidBaseWrapper;
+
+constexpr int kMaxCommandWaitTime = 1000;
+
+constexpr int kMaxKeyNumPerVsc = 12;
+constexpr int kBytesPerKey = 20;
+
+constexpr uint16_t kHciVscPofOpcode = 0xfd62;
+constexpr uint8_t kHciVscStartPofSubOpCode = 0x02;
+constexpr uint8_t kHciVscSetPrecomputedKeysPofSubOpCode = 0x01;
+
+constexpr uint16_t kAdvertisingIntervalDefault = 0x640;     // 2000 ms
+constexpr uint16_t kWaitTimeDefault = 0x5000;               // 20000 ms
+constexpr uint16_t kPrecomputedKeyRotatedInterval = 0x400;  // 1024 s
+
+BluetoothFinderHandler& BluetoothFinderHandler::GetHandler() {
+  static BluetoothFinderHandler handler;
+  return handler;
+}
+
+bool BluetoothFinderHandler::SendEids(const std::vector<Eid>& keys) {
+  std::scoped_lock<std::mutex> lock(finder_mtx_);
+
+  if (state_ != State::kIdle) {
+    LOG(WARNING)
+        << __func__
+        << ": Could not send keys while entering powered off finder mode.";
+    return false;
+  }
+
+  LOG(INFO) << __func__ << ": Send keys.";
+  keys_.assign(keys.begin(), keys.end());
+  // Reset key sending index if keys are updated while PoF is not started.
+  current_key_index_ = 0;
+
+  return true;
+}
+
+bool BluetoothFinderHandler::SetPoweredOffFinderMode(bool enable) {
+  std::scoped_lock<std::mutex> lock(finder_mtx_);
+
+  if (state_ != State::kIdle) {
+    LOG(WARNING)
+        << __func__
+        << ": Could not set mode while entering powered off finder mode.";
+    return false;
+  }
+
+  LOG(INFO) << __func__ << ": enable: " << enable << ".";
+  is_pof_enabled_ = enable;
+
+  if (!is_pof_enabled_) {
+    keys_.clear();
+    state_ = State::kIdle;
+  }
+
+  return true;
+}
+
+bool BluetoothFinderHandler::GetPoweredOffFinderMode(bool* return_value) {
+  std::scoped_lock<std::mutex> lock(finder_mtx_);
+
+  LOG(INFO) << __func__ << ": enable: " << is_pof_enabled_ << ".";
+  *return_value = is_pof_enabled_;
+  return true;
+}
+
+bool BluetoothFinderHandler::IsPoweredOffFinderEnabled() const {
+  return is_pof_enabled_;
+}
+
+bool BluetoothFinderHandler::StartPoweredOffFinderMode() {
+  std::scoped_lock<std::mutex> lock(finder_mtx_);
+
+  if (!is_pof_enabled_) {
+    LOG(WARNING) << __func__ << ": Powered off mode is not enabled.";
+    return false;
+  }
+
+  std::string shutdown_action = AndroidBaseWrapper::GetWrapper().GetProperty(
+      Property::kShutDownAction, "");
+  if (shutdown_action.empty()) {
+    LOG(WARNING) << __func__ << ": Device is not shutting down.";
+    return false;
+  }
+
+  if (state_ != State::kIdle) {
+    LOG(WARNING) << __func__ << ": Already entered powered off mode.";
+    return false;
+  }
+
+  if (!IsBluetoothChipReady()) {
+    LOG(WARNING) << __func__
+                 << ": Unable to start powered off mode: bluetooth is off.";
+    return false;
+  } else if (!keys_.size()) {
+    LOG(WARNING) << __func__ << ": Unable to start powered off mode: no key.";
+    return false;
+  }
+
+  // Reset key index and start the state machine.
+  current_key_index_ = 0;
+  HandleNextStep(State::kReset);
+
+  return state_ == State::kStarted;
+}
+
+void BluetoothFinderHandler::OnMonitorPacketCallback(
+    [[maybe_unused]] MonitorMode mode,
+    [[maybe_unused]] const HalPacket& packet) {
+  // Unused method.
+}
+
+void BluetoothFinderHandler::OnCommandCallback(const HalPacket& event) {
+  command_success_ = (event.GetCommandCompleteEventResult() ==
+                      static_cast<uint8_t>(EventResultCode::kSuccess));
+
+  LOG(command_success_ ? INFO : WARNING)
+      << __func__ << ": Recv VSE "
+      << (command_success_ ? "[Success]" : "[Failed]");
+
+  // Handle state transition based on the current state and command result.
+  if (!command_success_) {
+    LOG(ERROR) << __func__ << ": Command failed in state "
+               << static_cast<int>(state_.load());
+    // Reset state on failure.
+    state_ = State::kIdle;
+  }
+  command_promise_.set_value();
+}
+
+void BluetoothFinderHandler::HandleNextStep(State next_state) {
+  state_ = next_state;
+
+  switch (state_) {
+    case State::kReset: {
+      HalPacket command = BuildFinderResetCommand();
+      LOG(INFO) << __func__ << ": Sending Reset command.";
+
+      if (!SendCommandAndWait(command)) {
+        LOG(ERROR) << __func__ << ": Failed to send reset command.";
+        state_ = State::kIdle;
+        return;
+      }
+
+      HandleNextStep(State::kSendingKeys);
+
+      break;
+    }
+    case State::kSendingKeys: {
+      if (current_key_index_ >= keys_.size()) {
+        LOG(ERROR) << __func__ << ": Invalid state: No more keys to send.";
+        state_ = State::kIdle;
+        return;
+      }
+
+      HalPacket command = BuildPrecomputedKeyCommand(keys_, current_key_index_);
+      LOG(INFO) << __func__ << ": Sending keys starting from index "
+                << current_key_index_ << ".";
+
+      if (!SendCommandAndWait(command)) {
+        LOG(ERROR) << __func__ << ": Failed to send key command.";
+        state_ = State::kIdle;
+        return;
+      }
+
+      if (current_key_index_ >= keys_.size()) {
+        HandleNextStep(State::kStartingPof);
+      } else {
+        HandleNextStep(State::kSendingKeys);
+      }
+
+      break;
+    }
+    case State::kStartingPof: {
+      // Assuming key index 0 for start.
+      HalPacket command = BuildStartPoweredOffFinderModeCommand(0);
+      LOG(INFO) << __func__ << ": Sending Start POF command.";
+
+      if (!SendCommandAndWait(command)) {
+        LOG(ERROR) << __func__ << ": Failed to send start POF command.";
+        state_ = State::kIdle;
+        return;
+      }
+
+      HandleNextStep(State::kStarted);
+
+      break;
+    }
+    case State::kStarted:
+      LOG(INFO) << __func__ << ": Start powered off finder successfully.";
+      break;
+    default:
+      break;
+  }
+}
+
+HalPacket BluetoothFinderHandler::BuildPrecomputedKeyCommand(
+    const std::vector<Eid>& keys, uint_t cur_key_idx) {
+  HalPacket command;
+  uint8_t num_remaining_keys = keys.size() - cur_key_idx;
+  uint8_t num_keys_to_send =
+      (num_remaining_keys <= kMaxKeyNumPerVsc ? num_remaining_keys
+                                              : kMaxKeyNumPerVsc);
+
+  uint8_t param_length = 3 + num_keys_to_send * kBytesPerKey;
+  uint8_t cmd_length = HciConstants::kHciCommandPreambleSize + param_length;
+
+  command.resize(1 + cmd_length);
+
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscPofOpcode & 0xff;
+  command[2] = (kHciVscPofOpcode >> 8u) & 0xff;
+  command[3] = param_length;
+  command[4] = kHciVscSetPrecomputedKeysPofSubOpCode;
+  command[5] = cur_key_idx & 0xff;
+  command[6] = num_keys_to_send;
+
+  for (size_t i = 0; i < num_keys_to_send; ++i) {
+    const auto& key = keys[cur_key_idx + i].bytes;
+    std::copy_n(key.begin(), kBytesPerKey,
+                command.begin() + 7 + i * kBytesPerKey);
+  }
+
+  // Update the index for the next batch *after* building the command.
+  current_key_index_ += num_keys_to_send;
+
+  return command;
+}
+
+HalPacket BluetoothFinderHandler::BuildFinderResetCommand() {
+  HalPacket command;
+
+  uint8_t param_length = 0;
+  uint8_t cmd_length = HciConstants::kHciCommandPreambleSize + param_length;
+
+  command.resize(1 + cmd_length);
+
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = static_cast<uint16_t>(CommandOpCode::kHciReset) & 0xff;
+  command[2] = (static_cast<uint16_t>(CommandOpCode::kHciReset) >> 8u) & 0xff;
+  command[3] = param_length;
+
+  return command;
+}
+
+HalPacket BluetoothFinderHandler::BuildStartPoweredOffFinderModeCommand(
+    int32_t cur_key_idx) {
+  HalPacket command;
+
+  uint8_t param_length = 9;
+  uint8_t cmd_length = HciConstants::kHciCommandPreambleSize + param_length;
+
+  command.resize(1 + cmd_length);
+
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscPofOpcode & 0xff;
+  command[2] = (kHciVscPofOpcode >> 8u) & 0xff;
+  command[3] = param_length;
+  command[4] = kHciVscStartPofSubOpCode;
+  command[5] = kAdvertisingIntervalDefault & 0xff;
+  command[6] = (kAdvertisingIntervalDefault >> 8u) & 0xff;
+  command[7] = 0x0A;  // power level.
+  command[8] = kPrecomputedKeyRotatedInterval & 0xff;
+  command[9] = (kPrecomputedKeyRotatedInterval >> 8u) & 0xff;
+  command[10] = cur_key_idx & 0xff;
+  command[11] = kWaitTimeDefault & 0xff;
+  command[12] = (kWaitTimeDefault >> 8u) & 0xff;
+
+  return command;
+}
+
+bool BluetoothFinderHandler::SendCommandAndWait(const HalPacket& packet) {
+  if (!SendCommand(packet)) {
+    LOG(ERROR) << __func__ << "Failed to send command.";
+    return false;
+  }
+
+  std::future_status status = command_promise_.get_future().wait_for(
+      std::chrono::milliseconds(kMaxCommandWaitTime));
+  if (status != std::future_status::ready) {
+    LOG(ERROR) << __func__ << "Command timeout.";
+    return false;
+  }
+
+  command_promise_ = std::promise<void>();
+  return command_success_;  // Return the result set by OnCommandCallback.
+}
+
+}  // namespace finder
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder_handler_test.cc b/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder_handler_test.cc
new file mode 100644
index 0000000000..b784fd3b46
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/finder/bluetooth_finder_handler_test.cc
@@ -0,0 +1,603 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/finder/bluetooth_finder_handler.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <future>
+#include <memory>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/finder/Eid.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace finder {
+namespace {
+
+using ::testing::_;
+using ::testing::Action;
+using ::testing::DoAll;
+using ::testing::Mock;
+using ::testing::NotNull;
+using ::testing::Return;
+using ::testing::SaveArg;
+using ::testing::StrictMock;
+using ::testing::Test;
+
+using ::aidl::android::hardware::bluetooth::finder::Eid;
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::hci::CommandOpCode;
+using ::bluetooth_hal::hci::EventCode;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::HciRouterCallback;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+using ::bluetooth_hal::util::MockAndroidBaseWrapper;
+
+constexpr int kMaxKeyNumPerVsc = 12;
+constexpr int kBytesPerKey = 20;
+constexpr uint16_t kHciVscPofOpcode = 0xfd62;
+
+std::vector<Eid> CreateEids(size_t count, uint8_t start_value = 1) {
+  std::vector<Eid> eids;
+  eids.reserve(count);
+  for (size_t i = 0; i < count; ++i) {
+    Eid eid;
+    eid.bytes.fill(start_value + static_cast<uint8_t>(i));
+    eids.push_back(eid);
+  }
+  return eids;
+}
+
+class TestBluetoothFinderHandler : public BluetoothFinderHandler {
+ public:
+  TestBluetoothFinderHandler() = default;
+  ~TestBluetoothFinderHandler() override = default;
+
+  void SimulateBluetoothChipReady() { OnBluetoothChipReady(); }
+
+  void SimulateBluetoothChipNotReady() { OnBluetoothChipClosed(); }
+
+  HalPacket BuildFinderResetCommandWrapper() {
+    return BuildFinderResetCommand();
+  }
+
+  HalPacket BuildPrecomputedKeyCommandWrapper(const std::vector<Eid>& keys,
+                                              uint_t cur_key_idx) {
+    return BuildPrecomputedKeyCommand(keys, cur_key_idx);
+  }
+
+  HalPacket BuildStartPoweredOffFinderModeCommandWrapper(int32_t cur_key_idx) {
+    return BuildStartPoweredOffFinderModeCommand(cur_key_idx);
+  }
+
+  int GetCurrentKeyIndex() const { return current_key_index_; }
+
+  void SetCurrentKeyIndex(int index) { current_key_index_ = index; }
+
+  BluetoothFinderHandler::State GetState() const { return state_; }
+
+  void SetState(BluetoothFinderHandler::State state) { state_ = state; }
+
+  std::vector<Eid>& GetKeys() { return keys_; }
+};
+
+class BluetoothFinderHandlerTest : public Test {
+ protected:
+  void SetUp() override {
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper_);
+
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    EXPECT_CALL(mock_hci_router_client_agent_, RegisterRouterClient(NotNull()))
+        .WillOnce(DoAll(SaveArg<0>(&router_callback_), Return(true)));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(false));
+
+    handler_ = std::make_unique<TestBluetoothFinderHandler>();
+
+    ON_CALL(mock_hci_router_, SendCommand(_, _)).WillByDefault(Return(true));
+
+    test_keys_ = CreateEids(5);
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mock_hci_router_client_agent_,
+                UnregisterRouterClient(handler_.get()))
+        .WillOnce(Return(true));
+    handler_.reset();
+    MockHciRouter::SetMockRouter(nullptr);
+    MockAndroidBaseWrapper::SetMockWrapper(nullptr);
+  }
+
+  HalPacket CreateCommandCompleteEvent(uint16_t opcode,
+                                       EventResultCode status) {
+    HalPacket event_packet({
+        static_cast<uint8_t>(HciPacketType::kEvent),
+        static_cast<uint8_t>(EventCode::kCommandComplete),
+        0x04,  // Parameter Total Length (Num Packets(1) + OpCode(2) +
+               // Status(1) = 4)
+        0x01,  // Number of HCI command packets allowed to be sent.
+        static_cast<uint8_t>(opcode & 0xff),
+        static_cast<uint8_t>((opcode >> 8) & 0xff),
+        static_cast<uint8_t>(status),
+    });
+    return event_packet;
+  }
+
+  void SimulateBluetoothChipReady() {
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(true));
+    handler_->SimulateBluetoothChipReady();
+  }
+
+  void SimulateBluetoothChipNotReady() {
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(false));
+    handler_->SimulateBluetoothChipNotReady();
+  }
+
+  std::unique_ptr<TestBluetoothFinderHandler> handler_;
+  HciRouterCallback* router_callback_ = nullptr;
+  StrictMock<MockHciRouter> mock_hci_router_;
+  StrictMock<MockAndroidBaseWrapper> mock_android_base_wrapper_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+
+  std::vector<Eid> test_keys_;
+};
+
+// Helper Action to signal when SendCommand is called.
+ACTION_P(SignalPromise, p) {
+  p->set_value();
+  return true;
+}
+
+TEST_F(BluetoothFinderHandlerTest, InitialState) {
+  bool enabled = true;
+  EXPECT_TRUE(handler_->GetPoweredOffFinderMode(&enabled));
+  EXPECT_FALSE(enabled);
+  EXPECT_FALSE(handler_->IsPoweredOffFinderEnabled());
+}
+
+TEST_F(BluetoothFinderHandlerTest, SetModeOnAndGetMode) {
+  bool enabled = false;
+
+  // Enable POF.
+  EXPECT_TRUE(handler_->SetPoweredOffFinderMode(true));
+  EXPECT_TRUE(handler_->GetPoweredOffFinderMode(&enabled));
+  EXPECT_TRUE(enabled);
+  EXPECT_TRUE(handler_->IsPoweredOffFinderEnabled());
+}
+
+TEST_F(BluetoothFinderHandlerTest, SetOffAndGetMode) {
+  bool enabled = false;
+  handler_->SendEids(test_keys_);
+
+  EXPECT_TRUE(handler_->SetPoweredOffFinderMode(false));
+  EXPECT_TRUE(handler_->GetPoweredOffFinderMode(&enabled));
+  EXPECT_FALSE(enabled);
+  EXPECT_FALSE(handler_->IsPoweredOffFinderEnabled());
+  EXPECT_TRUE(handler_->GetKeys().empty());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(BluetoothFinderHandlerTest, SetModeWhenStarting) {
+  handler_->SetState(BluetoothFinderHandler::State::kStartingPof);
+
+  EXPECT_FALSE(handler_->SetPoweredOffFinderMode(true));
+}
+
+TEST_F(BluetoothFinderHandlerTest, SendEidsWhenIdle) {
+  handler_->SetState(BluetoothFinderHandler::State::kIdle);
+  handler_->SetCurrentKeyIndex(5);
+
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+  EXPECT_EQ(handler_->GetKeys().size(), test_keys_.size());
+  EXPECT_EQ(handler_->GetCurrentKeyIndex(), 0);
+}
+
+TEST_F(BluetoothFinderHandlerTest, SendEidsWhenStarting) {
+  handler_->SetState(BluetoothFinderHandler::State::kStartingPof);
+  handler_->SetCurrentKeyIndex(3);
+
+  EXPECT_FALSE(handler_->SendEids(test_keys_));
+  EXPECT_NE(handler_->GetKeys().size(), test_keys_.size());
+  EXPECT_EQ(handler_->GetCurrentKeyIndex(), 3);
+}
+
+class StartFinderProcessTest : public BluetoothFinderHandlerTest {
+ protected:
+  void SetUp() override {
+    BluetoothFinderHandlerTest::SetUp();
+    // Default enable finder.
+    handler_->SetPoweredOffFinderMode(true);
+    EXPECT_CALL(mock_android_base_wrapper_, GetProperty(_, _))
+        .WillRepeatedly(Return("shut_down_action"));
+  }
+};
+
+TEST_F(StartFinderProcessTest, StartPofButNotEnabled) {
+  SimulateBluetoothChipReady();
+  handler_->SetPoweredOffFinderMode(false);
+
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+  EXPECT_FALSE(handler_->StartPoweredOffFinderMode());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(StartFinderProcessTest, StartPofButNotShuttingDown) {
+  SimulateBluetoothChipReady();
+  EXPECT_CALL(mock_android_base_wrapper_, GetProperty(_, _))
+      .Times(1)
+      .WillOnce(Return(""));
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+  EXPECT_FALSE(handler_->StartPoweredOffFinderMode());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(StartFinderProcessTest, StartPofButAlreadyStarted) {
+  handler_->SetState(BluetoothFinderHandler::State::kStarted);
+
+  EXPECT_FALSE(handler_->StartPoweredOffFinderMode());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kStarted);
+}
+
+TEST_F(StartFinderProcessTest, StartPofButBluetoothOff) {
+  SimulateBluetoothChipNotReady();
+
+  EXPECT_FALSE(handler_->StartPoweredOffFinderMode());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(StartFinderProcessTest, StartPofButNoKeys) {
+  SimulateBluetoothChipReady();
+
+  EXPECT_FALSE(handler_->StartPoweredOffFinderMode());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(StartFinderProcessTest, StartPofWithSingleKeyBatchReturnSuccess) {
+  ASSERT_NE(router_callback_, nullptr) << "Callback was not captured";
+
+  SimulateBluetoothChipReady();
+  test_keys_ = CreateEids(5);
+
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+
+  // --- Promises for synchronization ---
+  std::promise<void> reset_sent_promise;
+  std::future<void> reset_sent_future = reset_sent_promise.get_future();
+  std::promise<void> keys_sent_promise;
+  std::future<void> keys_sent_future = keys_sent_promise.get_future();
+  std::promise<void> pof_sent_promise;
+  std::future<void> pof_sent_future = pof_sent_promise.get_future();
+
+  // --- Set Expectations with Signaling Actions ---
+  // 1. Expect Reset Command.
+  HalPacket expected_reset_cmd = handler_->BuildFinderResetCommandWrapper();
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_reset_cmd, _))
+      .WillOnce(SignalPromise(&reset_sent_promise));
+
+  // 2. Expect Set Keys Command (after Reset callback).
+  HalPacket expected_set_keys_cmd =
+      handler_->BuildPrecomputedKeyCommandWrapper(test_keys_, 0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_set_keys_cmd, _))
+      .WillOnce(SignalPromise(&keys_sent_promise));
+
+  // 3. Expect Start POF Command (after Set Keys callback).
+  HalPacket expected_start_pof_cmd =
+      handler_->BuildStartPoweredOffFinderModeCommandWrapper(0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_start_pof_cmd, _))
+      .WillOnce(SignalPromise(&pof_sent_promise));
+
+  // --- Start the process asynchronously ---
+  auto result_future = std::async(std::launch::async, [&]() {
+    return handler_->StartPoweredOffFinderMode();
+  });
+
+  // --- Simulation and Synchronization ---
+
+  // Wait for Reset command to be sent, then simulate its callback.
+  ASSERT_EQ(reset_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready)
+      << "Timeout waiting for Reset command";
+  HalPacket reset_success_event = CreateCommandCompleteEvent(
+      static_cast<uint16_t>(CommandOpCode::kHciReset),
+      EventResultCode::kSuccess);
+  router_callback_->OnCommandCallback(reset_success_event);
+
+  // Wait for Set Keys command to be sent, then simulate its callback.
+  ASSERT_EQ(keys_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready)
+      << "Timeout waiting for Set Keys command";
+  HalPacket set_keys_success_event = CreateCommandCompleteEvent(
+      static_cast<uint16_t>(kHciVscPofOpcode), EventResultCode::kSuccess);
+  router_callback_->OnCommandCallback(set_keys_success_event);
+
+  // Wait for Start POF command to be sent, then simulate its callback.
+  ASSERT_EQ(pof_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready)
+      << "Timeout waiting for Start POF command";
+  HalPacket start_pof_success_event = CreateCommandCompleteEvent(
+      static_cast<uint16_t>(kHciVscPofOpcode), EventResultCode::kSuccess);
+  router_callback_->OnCommandCallback(start_pof_success_event);
+
+  // --- Verification ---
+  // Wait for the async task to complete and verify the final state.
+  EXPECT_TRUE(result_future.get());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kStarted);
+  EXPECT_EQ(handler_->GetCurrentKeyIndex(), 5);
+}
+
+TEST_F(StartFinderProcessTest, StartPofWithMultipleKeyBatchesReturnSuccess) {
+  ASSERT_NE(router_callback_, nullptr) << "Callback was not captured";
+
+  SimulateBluetoothChipReady();
+
+  // Create more keys than fit in one VSC batch.
+  const size_t num_keys_first_batch = kMaxKeyNumPerVsc;
+  const size_t num_keys_second_batch = 5;
+  const size_t total_keys = num_keys_first_batch + num_keys_second_batch;
+  test_keys_ = CreateEids(total_keys);
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+
+  // --- Promises for synchronization ---
+  std::promise<void> reset_sent_promise;
+  std::future<void> reset_sent_future = reset_sent_promise.get_future();
+  std::promise<void> keys1_sent_promise;
+  std::future<void> keys1_sent_future = keys1_sent_promise.get_future();
+  std::promise<void> keys2_sent_promise;
+  std::future<void> keys2_sent_future = keys2_sent_promise.get_future();
+  std::promise<void> pof_sent_promise;
+  std::future<void> pof_sent_future = pof_sent_promise.get_future();
+
+  // --- Set Expectations with Signaling Actions ---
+  // 1. Expect Reset Command.
+  HalPacket expected_reset_cmd = handler_->BuildFinderResetCommandWrapper();
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_reset_cmd, _))
+      .WillOnce(SignalPromise(&reset_sent_promise));
+
+  // 2. Expect Set Keys Command (Batch 1).
+  HalPacket expected_set_keys1_cmd =
+      handler_->BuildPrecomputedKeyCommandWrapper(test_keys_, 0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_set_keys1_cmd, _))
+      .WillOnce(SignalPromise(&keys1_sent_promise));
+
+  // 3. Expect Set Keys Command (Batch 2).
+  // Note: BuildPrecomputedKeyCommandWrapper updates the internal index,
+  // so we call it again, and it should build the command for the next batch.
+  // We need to temporarily set the index back for the expectation setup.
+  handler_->SetCurrentKeyIndex(
+      num_keys_first_batch);  // Set index for expectation
+  HalPacket expected_set_keys2_cmd =
+      handler_->BuildPrecomputedKeyCommandWrapper(test_keys_,
+                                                  num_keys_first_batch);
+  handler_->SetCurrentKeyIndex(
+      0);  // Reset index before starting the actual flow
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_set_keys2_cmd, _))
+      .WillOnce(SignalPromise(&keys2_sent_promise));
+
+  // 4. Expect Start POF Command
+  HalPacket expected_start_pof_cmd =
+      handler_->BuildStartPoweredOffFinderModeCommandWrapper(0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_start_pof_cmd, _))
+      .WillOnce(SignalPromise(&pof_sent_promise));
+
+  // --- Start the process asynchronously ---
+  auto result_future = std::async(std::launch::async, [&]() {
+    return handler_->StartPoweredOffFinderMode();
+  });
+
+  // --- Simulation and Synchronization ---
+  // Simulate Reset success
+  ASSERT_EQ(reset_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(CreateCommandCompleteEvent(
+      static_cast<uint16_t>(CommandOpCode::kHciReset),
+      EventResultCode::kSuccess));
+
+  // Simulate Set Keys Batch 1 success.
+  ASSERT_EQ(keys1_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(
+      CreateCommandCompleteEvent(kHciVscPofOpcode, EventResultCode::kSuccess));
+
+  // Simulate Set Keys Batch 2 success.
+  ASSERT_EQ(keys2_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(
+      CreateCommandCompleteEvent(kHciVscPofOpcode, EventResultCode::kSuccess));
+
+  // Simulate Start POF success.
+  ASSERT_EQ(pof_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(
+      CreateCommandCompleteEvent(kHciVscPofOpcode, EventResultCode::kSuccess));
+
+  // --- Verification ---
+  EXPECT_TRUE(result_future.get());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kStarted);
+  // Verify the index was updated correctly after sending all keys.
+  EXPECT_EQ(handler_->GetCurrentKeyIndex(), total_keys);
+}
+
+TEST_F(StartFinderProcessTest, StartPofFailOnReset) {
+  ASSERT_NE(router_callback_, nullptr);
+  SimulateBluetoothChipReady();
+  test_keys_ = CreateEids(5);
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+
+  // --- Promises ---
+  std::promise<void> reset_sent_promise;
+  std::future<void> reset_sent_future = reset_sent_promise.get_future();
+
+  // --- Expectations ---
+  // Expect Reset Command.
+  HalPacket expected_reset_cmd = handler_->BuildFinderResetCommandWrapper();
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_reset_cmd, _))
+      .WillOnce(SignalPromise(&reset_sent_promise));
+  // Do NOT expect Set Keys or Start POF commands.
+
+  // --- Start Async ---
+  auto result_future = std::async(std::launch::async, [&]() {
+    // StartPoweredOffFinderMode should return false if any step fails.
+    return handler_->StartPoweredOffFinderMode();
+  });
+
+  // --- Simulation ---
+  // Wait for Reset command, then simulate FAILURE.
+  ASSERT_EQ(reset_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  HalPacket reset_failure_event = CreateCommandCompleteEvent(
+      static_cast<uint16_t>(CommandOpCode::kHciReset),
+      EventResultCode::kFailure);
+  router_callback_->OnCommandCallback(reset_failure_event);
+
+  // --- Verification ---
+  EXPECT_FALSE(result_future.get());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(StartFinderProcessTest, StartPofFailOnSetKeys) {
+  ASSERT_NE(router_callback_, nullptr);
+  SimulateBluetoothChipReady();
+  test_keys_ = CreateEids(5);
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+
+  // --- Promises ---
+  std::promise<void> reset_sent_promise;
+  std::future<void> reset_sent_future = reset_sent_promise.get_future();
+  std::promise<void> keys_sent_promise;
+  std::future<void> keys_sent_future = keys_sent_promise.get_future();
+
+  // --- Expectations ---
+  // 1. Expect Reset Command.
+  HalPacket expected_reset_cmd = handler_->BuildFinderResetCommandWrapper();
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_reset_cmd, _))
+      .WillOnce(SignalPromise(&reset_sent_promise));
+
+  // 2. Expect Set Keys Command.
+  HalPacket expected_set_keys_cmd =
+      handler_->BuildPrecomputedKeyCommandWrapper(test_keys_, 0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_set_keys_cmd, _))
+      .WillOnce(SignalPromise(&keys_sent_promise));
+  // Do NOT expect Start POF command.
+
+  // --- Start Async ---
+  auto result_future = std::async(std::launch::async, [&]() {
+    return handler_->StartPoweredOffFinderMode();
+  });
+
+  // --- Simulation ---
+  // Simulate Reset success.
+  ASSERT_EQ(reset_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(CreateCommandCompleteEvent(
+      static_cast<uint16_t>(CommandOpCode::kHciReset),
+      EventResultCode::kSuccess));
+
+  // Wait for Set Keys command, then simulate FAILURE.
+  ASSERT_EQ(keys_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  HalPacket set_keys_failure_event = CreateCommandCompleteEvent(
+      static_cast<uint16_t>(kHciVscPofOpcode), EventResultCode::kFailure);
+  router_callback_->OnCommandCallback(set_keys_failure_event);
+
+  // --- Verification ---
+  EXPECT_FALSE(result_future.get());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+TEST_F(StartFinderProcessTest, StartPofFailOnStartPof) {
+  ASSERT_NE(router_callback_, nullptr);
+  SimulateBluetoothChipReady();
+  test_keys_ = CreateEids(5);
+  EXPECT_TRUE(handler_->SendEids(test_keys_));
+
+  // --- Promises ---
+  std::promise<void> reset_sent_promise;
+  std::future<void> reset_sent_future = reset_sent_promise.get_future();
+  std::promise<void> keys_sent_promise;
+  std::future<void> keys_sent_future = keys_sent_promise.get_future();
+  std::promise<void> pof_sent_promise;
+  std::future<void> pof_sent_future = pof_sent_promise.get_future();
+
+  // --- Expectations ---
+  // 1. Expect Reset Command.
+  HalPacket expected_reset_cmd = handler_->BuildFinderResetCommandWrapper();
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_reset_cmd, _))
+      .WillOnce(SignalPromise(&reset_sent_promise));
+
+  // 2. Expect Set Keys Command.
+  HalPacket expected_set_keys_cmd =
+      handler_->BuildPrecomputedKeyCommandWrapper(test_keys_, 0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_set_keys_cmd, _))
+      .WillOnce(SignalPromise(&keys_sent_promise));
+
+  // 3. Expect Start POF Command.
+  HalPacket expected_start_pof_cmd =
+      handler_->BuildStartPoweredOffFinderModeCommandWrapper(0);
+  EXPECT_CALL(mock_hci_router_, SendCommand(expected_start_pof_cmd, _))
+      .WillOnce(SignalPromise(&pof_sent_promise));
+
+  // --- Start Async ---
+  auto result_future = std::async(std::launch::async, [&]() {
+    return handler_->StartPoweredOffFinderMode();
+  });
+
+  // --- Simulation ---
+  // Simulate Reset success.
+  ASSERT_EQ(reset_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(CreateCommandCompleteEvent(
+      static_cast<uint16_t>(CommandOpCode::kHciReset),
+      EventResultCode::kSuccess));
+
+  // Simulate Set Keys success.
+  ASSERT_EQ(keys_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  router_callback_->OnCommandCallback(CreateCommandCompleteEvent(
+      static_cast<uint16_t>(kHciVscPofOpcode), EventResultCode::kSuccess));
+
+  // Wait for Start POF command, then simulate FAILURE.
+  ASSERT_EQ(pof_sent_future.wait_for(std::chrono::seconds(1)),
+            std::future_status::ready);
+  HalPacket start_pof_failure_event = CreateCommandCompleteEvent(
+      static_cast<uint16_t>(kHciVscPofOpcode), EventResultCode::kFailure);
+  router_callback_->OnCommandCallback(start_pof_failure_event);
+
+  // --- Verification ---
+  EXPECT_FALSE(result_future.get());
+  EXPECT_EQ(handler_->GetState(), BluetoothFinderHandler::State::kIdle);
+}
+
+}  // namespace
+}  // namespace finder
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar.cc b/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar.cc
new file mode 100644
index 0000000000..a1db8f27f8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar.cc
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/sar/bluetooth_sar.h"
+
+#include <array>
+#include <cstdint>
+
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/sar/bluetooth_sar_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace sar {
+
+using ::ndk::ScopedAStatus;
+
+ScopedAStatus BluetoothSar::setBluetoothTxPowerCap(int8_t cap) {
+  bool status = bluetooth_sar_handler_.SetBluetoothTxPowerCap(cap);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothSar::setBluetoothTechBasedTxPowerCap(int8_t br_cap,
+                                                            int8_t edr_cap,
+                                                            int8_t ble_cap) {
+  bool status = bluetooth_sar_handler_.SetBluetoothTechBasedTxPowerCap(
+      br_cap, edr_cap, ble_cap);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothSar::setBluetoothModeBasedTxPowerCap(
+    const std::array<uint8_t, 3>& chain_0_cap,
+    const std::array<uint8_t, 3>& chain_1_cap,
+    const std::array<uint8_t, 6>& beamforming_cap) {
+  bool status = bluetooth_sar_handler_.SetBluetoothModeBasedTxPowerCap(
+      chain_0_cap, chain_1_cap, beamforming_cap);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+ScopedAStatus BluetoothSar::setBluetoothModeBasedTxPowerCapPlusHR(
+    const std::array<uint8_t, 4>& chain_0_cap,
+    const std::array<uint8_t, 4>& chain_1_cap,
+    const std::array<uint8_t, 8>& beamforming_cap) {
+  bool status = bluetooth_sar_handler_.SetBluetoothModeBasedTxPowerCapPlusHR(
+      chain_0_cap, chain_1_cap, beamforming_cap);
+  return status ? ScopedAStatus::ok()
+                : ScopedAStatus::fromServiceSpecificError(STATUS_BAD_VALUE);
+}
+
+ScopedAStatus BluetoothSar::setBluetoothAreaCode(
+    const std::array<uint8_t, 3>& /*area_code*/) {
+  return ScopedAStatus::ok();
+}
+
+}  // namespace sar
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar_handler.cc b/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar_handler.cc
new file mode 100644
index 0000000000..4389823511
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar_handler.cc
@@ -0,0 +1,269 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.extensions.sar"
+
+#include "bluetooth_hal/extensions/sar/bluetooth_sar_handler.h"
+
+#include <array>
+#include <cstdint>
+#include <string>
+
+#include "android-base/logging.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace sar {
+
+using ::android::base::StringPrintf;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::hci::EventResultCode;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::MonitorMode;
+
+std::string logPowerLimit(uint8_t br_cap, uint8_t edr_cap, uint8_t ble_cap) {
+  return StringPrintf("<br=%d, edr=%d, ble=%d>", br_cap, edr_cap, ble_cap);
+}
+
+std::string logPowerLimit(uint8_t br_cap, uint8_t edr_cap, uint8_t ble_cap,
+                          uint8_t hr_cap) {
+  return StringPrintf("<br=%d, edr=%d, ble=%d, hr=%d>", br_cap, edr_cap,
+                      ble_cap, hr_cap);
+}
+
+uint8_t scopeCap(uint8_t cap, bool high_resolution_cap) {
+  if (cap > 80) {
+    LOG(WARNING) << __func__ << ": cap " << +cap
+                 << " is greater than 80, set to 80";
+    cap = 80;
+  } else if (cap < 0) {
+    LOG(WARNING) << __func__ << ": cap " << +cap
+                 << " is smaller than 0, set to 0";
+    cap = 0;
+  }
+
+  if (high_resolution_cap) {
+    return cap;
+  } else {
+    return cap / kHciVscPowerCapScale;
+  }
+}
+
+HalPacket BluetoothSarHandler::BuildCommandHRMode(
+    const std::array<uint8_t, 4>& chain_0_cap,
+    const std::array<uint8_t, 4>& chain_1_cap,
+    const std::array<uint8_t, 8>& beamforming_cap, bool high_resolution_cap,
+    bool is_ble_non_connection_enabled) {
+  HalPacket command;
+  command.resize(kHciVscSetPowerCapCmdLengthPlusHR);
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscSetPowerCapOpcode & 0xff;
+  command[2] = (kHciVscSetPowerCapOpcode >> 8u) & 0xff;
+  command[3] = 1 /* sub op */ + 1 /* command version */ +
+               kHciVscSetPowerCapChain0PowerLimitSizePlusHR +
+               kHciVscSetPowerCapChain1PowerLimitSizePlusHR +
+               kHciVscSetPowerCapBeamformingPowerLimitSizePlusHR;
+  command[4] = is_ble_non_connection_enabled
+                   ? kHciVscSetPowerCapSubOpCodeLENonConnectionMode
+                   : kHciVscSetPowerCapSubOpCodeHRMode;
+  command[5] = kHciVscSetPowerCapPlusHRCommandVersion;
+  for (int i = 0; i < kHciVscSetPowerCapChain0PowerLimitSizePlusHR; i++) {
+    command[6 + i] = scopeCap(chain_0_cap[i], high_resolution_cap);
+  }
+  for (int i = 0; i < kHciVscSetPowerCapChain1PowerLimitSizePlusHR; i++) {
+    command[6 + kHciVscSetPowerCapChain0PowerLimitSizePlusHR + i] =
+        scopeCap(chain_1_cap[i], high_resolution_cap);
+  }
+  for (int i = 0; i < kHciVscSetPowerCapBeamformingPowerLimitSizePlusHR; i++) {
+    command[6 + (2 * kHciVscSetPowerCapChain0PowerLimitSizePlusHR) + i] =
+        scopeCap(beamforming_cap[i], high_resolution_cap);
+  }
+  return command;
+}
+
+HalPacket BluetoothSarHandler::BuildCommand(
+    const std::array<uint8_t, 3>& chain_0_cap,
+    const std::array<uint8_t, 3>& chain_1_cap,
+    const std::array<uint8_t, 6>& beamforming_cap, bool high_resolution_cap) {
+  HalPacket command;
+  command.resize(kHciVscSetPowerCapCmdLength);
+  command[0] = static_cast<uint8_t>(HciPacketType::kCommand);
+  command[1] = kHciVscSetPowerCapOpcode & 0xff;
+  command[2] = (kHciVscSetPowerCapOpcode >> 8u) & 0xff;
+  command[3] = 1 /* sub op */ + kHciVscSetPowerCapChain0PowerLimitSize +
+               kHciVscSetPowerCapChain1PowerLimitSize +
+               kHciVscSetPowerCapBeamformingPowerLimitSize;
+  if (high_resolution_cap) {
+    command[4] = kHciVscSetPowerCapSubOpCodeHighResolution;
+  } else {
+    command[4] = kHciVscSetPowerCapSubOpCode;
+  }
+  for (int i = 0; i < kHciVscSetPowerCapChain0PowerLimitSize; i++) {
+    command[5 + i] = scopeCap(chain_0_cap[i], high_resolution_cap);
+  }
+  for (int i = 0; i < kHciVscSetPowerCapChain1PowerLimitSize; i++) {
+    command[5 + kHciVscSetPowerCapChain0PowerLimitSize + i] =
+        scopeCap(chain_1_cap[i], high_resolution_cap);
+  }
+  for (int i = 0; i < kHciVscSetPowerCapBeamformingPowerLimitSize; i++) {
+    command[5 + (2 * kHciVscSetPowerCapChain0PowerLimitSize) + i] =
+        scopeCap(beamforming_cap[i], high_resolution_cap);
+  }
+  return command;
+}
+
+HalPacket BluetoothSarHandler::BuildCommand(uint8_t br_cap, uint8_t edr_cap,
+                                            uint8_t ble_cap,
+                                            bool high_resolution_cap) {
+  const std::array<uint8_t, 3> chain_cap({br_cap, edr_cap, ble_cap});
+  const std::array<uint8_t, 6> beamforming_cap(
+      {br_cap, edr_cap, ble_cap, br_cap, edr_cap, ble_cap});
+  return BuildCommand(chain_cap, chain_cap, beamforming_cap,
+                      high_resolution_cap);
+}
+
+bool BluetoothSarHandler::SetBluetoothTxPowerCap(int8_t cap) {
+  if (!IsBluetoothEnabled()) {
+    LOG(WARNING) << __func__ << ": Unable to set power cap " << +cap;
+    return false;
+  }
+  LOG(INFO) << __func__ << ": " << " Cap=" << +cap;
+  HalPacket set_power_cap = BuildCommand(cap, cap, cap, high_resolution_cap_);
+  return SendCommand(set_power_cap);
+}
+
+bool BluetoothSarHandler::SetBluetoothTechBasedTxPowerCap(int8_t br_cap,
+                                                          int8_t edr_cap,
+                                                          int8_t ble_cap) {
+  if (!IsBluetoothEnabled()) {
+    LOG(WARNING) << __func__ << ": Unable to set power cap "
+                 << logPowerLimit(br_cap, edr_cap, ble_cap);
+    return false;
+  }
+  LOG(INFO) << __func__ << ": " << logPowerLimit(br_cap, edr_cap, ble_cap);
+  HalPacket set_power_cap =
+      BuildCommand(br_cap, edr_cap, ble_cap, high_resolution_cap_);
+  return SendCommand(set_power_cap);
+}
+
+bool BluetoothSarHandler::SetBluetoothModeBasedTxPowerCap(
+    const std::array<uint8_t, 3>& chain_0_cap,
+    const std::array<uint8_t, 3>& chain_1_cap,
+    const std::array<uint8_t, 6>& beamforming_cap) {
+  if (!IsBluetoothEnabled()) {
+    LOG(WARNING) << __func__ << ": Unable to set power cap Chain 0:"
+                 << logPowerLimit(chain_0_cap[0], chain_0_cap[1],
+                                  chain_0_cap[2])
+                 << ", Chain 1:"
+                 << logPowerLimit(chain_1_cap[0], chain_1_cap[1],
+                                  chain_1_cap[2])
+                 << "Beamforming: Chain 0:"
+                 << logPowerLimit(beamforming_cap[0], beamforming_cap[1],
+                                  beamforming_cap[2])
+                 << ", Chain 1:"
+                 << logPowerLimit(beamforming_cap[3], beamforming_cap[4],
+                                  beamforming_cap[5]);
+    return false;
+  }
+  LOG(INFO) << __func__ << ": Chain 0 Power Cap:"
+            << logPowerLimit(chain_0_cap[0], chain_0_cap[1], chain_0_cap[2])
+            << ", Chain 1 Power Cap:"
+            << logPowerLimit(chain_1_cap[0], chain_1_cap[1], chain_1_cap[2])
+            << ", Beamforming Power Cap Chain 0: "
+            << logPowerLimit(beamforming_cap[0], beamforming_cap[1],
+                             beamforming_cap[2])
+            << ", Chain 1:"
+            << logPowerLimit(beamforming_cap[3], beamforming_cap[4],
+                             beamforming_cap[5]);
+
+  HalPacket set_power_cap = BuildCommand(chain_0_cap, chain_1_cap,
+                                         beamforming_cap, high_resolution_cap_);
+  return SendCommand(set_power_cap);
+}
+bool BluetoothSarHandler::SetBluetoothModeBasedTxPowerCapPlusHR(
+    const std::array<uint8_t, 4>& chain_0_cap,
+    const std::array<uint8_t, 4>& chain_1_cap,
+    const std::array<uint8_t, 8>& beamforming_cap) {
+  if (!IsBluetoothEnabled()) {
+    LOG(WARNING) << __func__ << ": Unable to set power cap Chain 0:"
+                 << logPowerLimit(chain_0_cap[0], chain_0_cap[1],
+                                  chain_0_cap[2], chain_0_cap[3])
+                 << ", Chain 1:"
+                 << logPowerLimit(chain_1_cap[0], chain_1_cap[1],
+                                  chain_1_cap[2], chain_1_cap[3])
+                 << "Beamforming: Chain 0:"
+                 << logPowerLimit(beamforming_cap[0], beamforming_cap[1],
+                                  beamforming_cap[2], beamforming_cap[3])
+                 << ", Chain 1:"
+                 << logPowerLimit(beamforming_cap[4], beamforming_cap[5],
+                                  beamforming_cap[6], beamforming_cap[7]);
+    return false;
+  }
+  LOG(INFO) << __func__ << ": Chain 0 Power Cap:"
+            << logPowerLimit(chain_0_cap[0], chain_0_cap[1], chain_0_cap[2],
+                             chain_0_cap[3])
+            << ", Chain 1 Power Cap:"
+            << logPowerLimit(chain_1_cap[0], chain_1_cap[1], chain_1_cap[2],
+                             chain_1_cap[3])
+            << ", Beamforming Power Cap Chain 0: "
+            << logPowerLimit(beamforming_cap[0], beamforming_cap[1],
+                             beamforming_cap[2], beamforming_cap[3])
+            << ", Chain 1:"
+            << logPowerLimit(beamforming_cap[4], beamforming_cap[5],
+                             beamforming_cap[6], beamforming_cap[7]);
+
+  HalPacket set_power_cap =
+      BuildCommandHRMode(chain_0_cap, chain_1_cap, beamforming_cap,
+                         high_resolution_cap_, is_ble_non_connection_enabled_);
+  return SendCommand(set_power_cap);
+}
+
+bool BluetoothSarHandler::SetBluetoothAreaCode(int32_t /*area_code*/) {
+  return true;
+}
+
+void BluetoothSarHandler::OnMonitorPacketCallback(
+    [[maybe_unused]] MonitorMode mode,
+    [[maybe_unused]] const HalPacket& packet) {
+  // Unused method
+}
+
+void BluetoothSarHandler::OnCommandCallback(const HalPacket& event) {
+  bool success = (event.GetCommandCompleteEventResult() ==
+                  static_cast<uint8_t>(EventResultCode::kSuccess));
+  LOG(success ? INFO : WARNING)
+      << __func__ << ": Recv VSE <" << event.ToString() << "> "
+      << (success ? "[Success]" : "[Failed]");
+}
+
+void BluetoothSarHandler::OnBluetoothEnabled() {
+  LOG(DEBUG) << __func__;
+  high_resolution_cap_ =
+      HalConfigLoader::GetLoader().IsSarBackoffHighResolutionEnabled();
+  is_ble_non_connection_enabled_ =
+      HalConfigLoader::GetLoader().IsBleNonConnectionSarEnabled();
+}
+
+void BluetoothSarHandler::OnBluetoothDisabled() { LOG(DEBUG) << __func__; }
+
+}  // namespace sar
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar_handler_test.cc b/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar_handler_test.cc
new file mode 100644
index 0000000000..ec3376cc52
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/sar/bluetooth_sar_handler_test.cc
@@ -0,0 +1,402 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/sar/bluetooth_sar_handler.h"
+
+#include <array>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <tuple>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_client_callback.h"
+#include "bluetooth_hal/test/mock/mock_hal_config_loader.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace sar {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::NotNull;
+using ::testing::Return;
+using ::testing::SaveArg;
+using ::testing::Test;
+using ::testing::Values;
+using ::testing::WithParamInterface;
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::config::MockHalConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciRouterClientCallback;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+
+class TestSarHandler : public BluetoothSarHandler {
+ public:
+  HalPacket BuildCommandHRModeWrapper(
+      const std::array<uint8_t, 4>& chain_0_cap,
+      const std::array<uint8_t, 4>& chain_1_cap,
+      const std::array<uint8_t, 8>& beamforming_cap, bool high_resolution_cap,
+      bool is_ble_non_connection_enabled) {
+    return BuildCommandHRMode(chain_0_cap, chain_1_cap, beamforming_cap,
+                              high_resolution_cap,
+                              is_ble_non_connection_enabled);
+  }
+
+  HalPacket BuildCommandWrapper(const std::array<uint8_t, 3>& chain_0_cap,
+                                const std::array<uint8_t, 3>& chain_1_cap,
+                                const std::array<uint8_t, 6>& beamforming_cap,
+                                bool high_resolution_cap) {
+    return BuildCommand(chain_0_cap, chain_1_cap, beamforming_cap,
+                        high_resolution_cap);
+  }
+
+  HalPacket BuildCommandWrapper(uint8_t br_cap, uint8_t edr_cap,
+                                uint8_t ble_cap, bool high_resolution_cap) {
+    return BuildCommand(br_cap, edr_cap, ble_cap, high_resolution_cap);
+  }
+};
+
+class BluetoothSarTest : public Test {
+ protected:
+  void SetUp() override {
+    MockHalConfigLoader::SetMockLoader(&mock_hal_config_loader_);
+
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    EXPECT_CALL(mock_hci_router_client_agent_, RegisterRouterClient(NotNull()))
+        .WillOnce(DoAll(SaveArg<0>(&router_client_callback_), Return(true)));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(false));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+        .WillByDefault(Return(false));
+
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    ON_CALL(mock_hci_router_, SendCommand(_, _)).WillByDefault(Return(true));
+
+    bluetooth_sar_handler_ = std::make_unique<TestSarHandler>();
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mock_hci_router_client_agent_,
+                UnregisterRouterClient(bluetooth_sar_handler_.get()))
+        .WillOnce(Return(true));
+    bluetooth_sar_handler_ = nullptr;
+  }
+
+  void EnableBluetooth() {
+    ASSERT_NE(router_client_callback_, nullptr) << "Callback was not captured";
+    ON_CALL(mock_hci_router_, GetHalState())
+        .WillByDefault(Return(HalState::kRunning));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+        .WillByDefault(Return(true));
+    ON_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+        .WillByDefault(Return(true));
+    router_client_callback_->OnBluetoothChipReady();
+    router_client_callback_->OnBluetoothEnabled();
+  }
+
+  std::unique_ptr<TestSarHandler> bluetooth_sar_handler_;
+  MockHciRouter mock_hci_router_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+  MockHalConfigLoader mock_hal_config_loader_;
+  HciRouterClientCallback* router_client_callback_ = nullptr;
+};
+
+class BleNonConnectionModeTest
+    : public BluetoothSarTest,
+      public WithParamInterface<std::tuple<bool, uint8_t>> {};
+
+TEST_P(BleNonConnectionModeTest, HandleModeWhenBuildCommandHRModeWrapper) {
+  const auto& [is_ble_non_connection_enabled, expected_sub_op_code] =
+      GetParam();
+  HalPacket command_hr = bluetooth_sar_handler_->BuildCommandHRModeWrapper(
+      {}, {}, {}, false, is_ble_non_connection_enabled);
+
+  EXPECT_EQ(command_hr[4], expected_sub_op_code);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    BleNonConnectionMode, BleNonConnectionModeTest,
+    Values(std::make_tuple(true,
+                           kHciVscSetPowerCapSubOpCodeLENonConnectionMode),
+           std::make_tuple(false, kHciVscSetPowerCapSubOpCodeHRMode)));
+
+TEST_F(BluetoothSarTest, HandleBuildCommandHRModeWrapper) {
+  // Create sample input data.
+  std::array<uint8_t, 4> chain0_cap = {10, 20, 30, 40};
+  std::array<uint8_t, 4> chain1_cap = {50, 60, 70, 80};
+  std::array<uint8_t, 8> beamforming_cap = {10, 20, 30, 40, 50, 60, 70, 80};
+
+  // Test with high resolution cap.
+  bool high_resolution_cap = true;
+  HalPacket command_hr = bluetooth_sar_handler_->BuildCommandHRModeWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, high_resolution_cap, false);
+
+  // Verify expected opcode and subopcode.
+  EXPECT_EQ(command_hr[0], 0x01);
+  EXPECT_EQ(command_hr[1], kHciVscSetPowerCapOpcode & 0xff);
+  EXPECT_EQ(command_hr[2], (kHciVscSetPowerCapOpcode >> 8u) & 0xff);
+  EXPECT_EQ(command_hr[4], kHciVscSetPowerCapSubOpCodeHRMode);
+  EXPECT_EQ(command_hr[5], kHciVscSetPowerCapPlusHRCommandVersion);
+
+  // Verify chain 0 cap values (no scaling expected in high resolution mode).
+  for (size_t i = 0; i < kHciVscSetPowerCapChain0PowerLimitSizePlusHR; i++) {
+    EXPECT_EQ(command_hr[6 + i], chain0_cap[i]);
+  }
+
+  // Verify chain 1 cap values (no scaling expected in high resolution mode).
+  for (size_t i = 0; i < kHciVscSetPowerCapChain1PowerLimitSizePlusHR; i++) {
+    EXPECT_EQ(command_hr[6 + kHciVscSetPowerCapChain0PowerLimitSizePlusHR + i],
+              chain1_cap[i]);
+  }
+
+  // Verify beamforming cap values (no scaling expected in high resolution
+  // mode).
+  for (size_t i = 0; i < kHciVscSetPowerCapBeamformingPowerLimitSizePlusHR;
+       i++) {
+    EXPECT_EQ(command_hr[6 + kHciVscSetPowerCapChain0PowerLimitSizePlusHR +
+                         kHciVscSetPowerCapChain1PowerLimitSizePlusHR + i],
+              beamforming_cap[i]);
+  }
+
+  // Test with low resolution cap.
+  high_resolution_cap = false;
+  HalPacket command_lr = bluetooth_sar_handler_->BuildCommandHRModeWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, high_resolution_cap, false);
+
+  // Verify cap values are scaled down for low resolution mode (assuming
+  // kHciVscPowerCapScale is 2 for this example).
+  for (size_t i = 0; i < kHciVscSetPowerCapChain0PowerLimitSizePlusHR; i++) {
+    EXPECT_EQ(command_lr[6 + i], chain0_cap[i] / kHciVscPowerCapScale);
+  }
+  for (size_t i = 0; i < kHciVscSetPowerCapChain1PowerLimitSizePlusHR; i++) {
+    EXPECT_EQ(command_lr[6 + kHciVscSetPowerCapChain0PowerLimitSizePlusHR + i],
+              chain1_cap[i] / kHciVscPowerCapScale);
+  }
+  for (size_t i = 0; i < kHciVscSetPowerCapBeamformingPowerLimitSizePlusHR;
+       i++) {
+    EXPECT_EQ(command_lr[6 + kHciVscSetPowerCapChain0PowerLimitSizePlusHR +
+                         kHciVscSetPowerCapChain1PowerLimitSizePlusHR + i],
+              beamforming_cap[i] / kHciVscPowerCapScale);
+  }
+}
+
+TEST_F(BluetoothSarTest, HandleBuildCommandHRModeBoundary) {
+  // Test with cap exceeding 80.
+  std::array<uint8_t, 4> chain0_cap = {100, 20, 30, 40};
+  std::array<uint8_t, 4> chain1_cap = {50, 60, 70, 80};
+  std::array<uint8_t, 8> beamforming_cap = {10, 20, 30, 40, 50, 60, 70, 80};
+  HalPacket command = bluetooth_sar_handler_->BuildCommandHRModeWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, true, false);
+  EXPECT_EQ(command[6], 80);
+}
+
+TEST_F(BluetoothSarTest, HandleBuildCommandWithArray) {
+  // Create sample input data.
+  std::array<uint8_t, 3> chain0_cap = {10, 20, 30};
+  std::array<uint8_t, 3> chain1_cap = {50, 60, 70};
+  std::array<uint8_t, 6> beamforming_cap = {10, 20, 30, 40, 50, 60};
+
+  // Test with high resolution cap.
+  bool high_resolution_cap = true;
+  HalPacket command_hr = bluetooth_sar_handler_->BuildCommandWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, high_resolution_cap);
+
+  // Verify expected opcode and subopcode.
+  EXPECT_EQ(command_hr[0], 0x01);
+  EXPECT_EQ(command_hr[1], kHciVscSetPowerCapOpcode & 0xff);
+  EXPECT_EQ(command_hr[2], (kHciVscSetPowerCapOpcode >> 8u) & 0xff);
+  EXPECT_EQ(command_hr[4], kHciVscSetPowerCapSubOpCodeHighResolution);
+
+  // Verify chain 0 cap values (no scaling expected in high resolution mode).
+  for (size_t i = 0; i < kHciVscSetPowerCapChain0PowerLimitSize; i++) {
+    EXPECT_EQ(command_hr[5 + i], chain0_cap[i]);
+  }
+
+  // Verify chain 1 cap values (no scaling expected in high resolution mode).
+  for (size_t i = 0; i < kHciVscSetPowerCapChain1PowerLimitSize; i++) {
+    EXPECT_EQ(command_hr[5 + kHciVscSetPowerCapChain0PowerLimitSize + i],
+              chain1_cap[i]);
+  }
+
+  // Verify beamforming cap values (no scaling expected in high resolution
+  // mode).
+  for (size_t i = 0; i < kHciVscSetPowerCapBeamformingPowerLimitSize; i++) {
+    EXPECT_EQ(command_hr[5 + kHciVscSetPowerCapChain0PowerLimitSize +
+                         kHciVscSetPowerCapChain1PowerLimitSize + i],
+              beamforming_cap[i]);
+  }
+
+  // Test with low resolution cap.
+  high_resolution_cap = false;
+  HalPacket command_lr = bluetooth_sar_handler_->BuildCommandWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, high_resolution_cap);
+
+  // Verify cap values are scaled down for low resolution mode (assuming
+  // kHciVscPowerCapScale is 2 for this example).
+  for (size_t i = 0; i < kHciVscSetPowerCapChain0PowerLimitSize; i++) {
+    EXPECT_EQ(command_lr[5 + i], chain0_cap[i] / kHciVscPowerCapScale);
+  }
+  for (size_t i = 0; i < kHciVscSetPowerCapChain1PowerLimitSize; i++) {
+    EXPECT_EQ(command_lr[5 + kHciVscSetPowerCapChain0PowerLimitSize + i],
+              chain1_cap[i] / kHciVscPowerCapScale);
+  }
+  for (size_t i = 0; i < kHciVscSetPowerCapBeamformingPowerLimitSize; i++) {
+    EXPECT_EQ(command_lr[5 + kHciVscSetPowerCapChain0PowerLimitSize +
+                         kHciVscSetPowerCapChain1PowerLimitSize + i],
+              beamforming_cap[i] / kHciVscPowerCapScale);
+  }
+}
+
+TEST_F(BluetoothSarTest, HandleBuildCommandWithArrayBoundary) {
+  // Test with cap exceeding 80 (should be clamped to 80).
+  std::array<uint8_t, 3> chain0_cap = {100, 20, 30};
+  std::array<uint8_t, 3> chain1_cap = {50, 60, 70};
+  std::array<uint8_t, 6> beamforming_cap = {10, 20, 30, 40, 50, 60};
+  HalPacket command = bluetooth_sar_handler_->BuildCommandWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, true);
+  EXPECT_EQ(command[5], 80);
+}
+
+TEST_F(BluetoothSarTest, HandleBuildCommand) {
+  // Create sample input data.
+  uint8_t br_cap = 10;
+  uint8_t edr_cap = 20;
+  uint8_t ble_cap = 30;
+
+  // Test with high resolution cap.
+  bool high_resolution_cap = true;
+  HalPacket command_hr = bluetooth_sar_handler_->BuildCommandWrapper(
+      br_cap, edr_cap, ble_cap, high_resolution_cap);
+
+  // Verify expected opcode and subopcode.
+  EXPECT_EQ(command_hr[0], 0x01);
+  EXPECT_EQ(command_hr[1], kHciVscSetPowerCapOpcode & 0xff);
+  EXPECT_EQ(command_hr[2], (kHciVscSetPowerCapOpcode >> 8u) & 0xff);
+  EXPECT_EQ(command_hr[4], kHciVscSetPowerCapSubOpCodeHighResolution);
+
+  // Verify chain 0 cap values (no scaling expected in high resolution mode).
+  EXPECT_EQ(command_hr[5], br_cap);
+  EXPECT_EQ(command_hr[6], edr_cap);
+  EXPECT_EQ(command_hr[7], ble_cap);
+
+  // Verify chain 1 cap values (no scaling expected in high resolution mode).
+  EXPECT_EQ(command_hr[8], br_cap);
+  EXPECT_EQ(command_hr[9], edr_cap);
+  EXPECT_EQ(command_hr[10], ble_cap);
+
+  // Verify beamforming cap values (no scaling expected in high resolution
+  // mode).
+  EXPECT_EQ(command_hr[11], br_cap);
+  EXPECT_EQ(command_hr[12], edr_cap);
+  EXPECT_EQ(command_hr[13], ble_cap);
+  EXPECT_EQ(command_hr[14], br_cap);
+  EXPECT_EQ(command_hr[15], edr_cap);
+  EXPECT_EQ(command_hr[16], ble_cap);
+
+  // Test with low resolution cap.
+  high_resolution_cap = false;
+  HalPacket command_lr = bluetooth_sar_handler_->BuildCommandWrapper(
+      br_cap, edr_cap, ble_cap, high_resolution_cap);
+
+  // Verify cap values are scaled down for low resolution mode (assuming
+  // kHciVscPowerCapScale is 2 for this example).
+  EXPECT_EQ(command_lr[5], br_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[6], edr_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[7], ble_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[8], br_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[9], edr_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[10], ble_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[11], br_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[12], edr_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[13], ble_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[14], br_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[15], edr_cap / kHciVscPowerCapScale);
+  EXPECT_EQ(command_lr[16], ble_cap / kHciVscPowerCapScale);
+}
+
+TEST_F(BluetoothSarTest, HandleSetBluetoothTxPowerCap) {
+  uint8_t cap = 10;
+  HalPacket command =
+      bluetooth_sar_handler_->BuildCommandWrapper(cap, cap, cap, false);
+  EXPECT_CALL(mock_hci_router_, SendCommand(command, _)).Times(1);
+
+  EXPECT_FALSE(bluetooth_sar_handler_->SetBluetoothTxPowerCap(cap));
+
+  EnableBluetooth();
+  EXPECT_TRUE(bluetooth_sar_handler_->SetBluetoothTxPowerCap(cap));
+}
+
+TEST_F(BluetoothSarTest, HandleSetBluetoothTechBasedTxPowerCap) {
+  uint8_t br_cap = 10;
+  uint8_t edr_cap = 20;
+  uint8_t ble_cap = 30;
+  HalPacket command = bluetooth_sar_handler_->BuildCommandWrapper(
+      br_cap, edr_cap, ble_cap, false);
+  EXPECT_CALL(mock_hci_router_, SendCommand(command, _)).Times(1);
+
+  EXPECT_FALSE(bluetooth_sar_handler_->SetBluetoothTechBasedTxPowerCap(
+      br_cap, edr_cap, ble_cap));
+
+  EnableBluetooth();
+  EXPECT_TRUE(bluetooth_sar_handler_->SetBluetoothTechBasedTxPowerCap(
+      br_cap, edr_cap, ble_cap));
+}
+
+TEST_F(BluetoothSarTest, SetBluetoothModeBasedTxPowerCap) {
+  std::array<uint8_t, 3> chain0_cap = {10, 20, 30};
+  std::array<uint8_t, 3> chain1_cap = {50, 60, 70};
+  std::array<uint8_t, 6> beamforming_cap = {10, 20, 30, 40, 50, 60};
+
+  HalPacket command = bluetooth_sar_handler_->BuildCommandWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, false);
+  EXPECT_CALL(mock_hci_router_, SendCommand(command, _)).Times(1);
+
+  EXPECT_FALSE(bluetooth_sar_handler_->SetBluetoothModeBasedTxPowerCap(
+      chain0_cap, chain1_cap, beamforming_cap));
+
+  EnableBluetooth();
+  EXPECT_TRUE(bluetooth_sar_handler_->SetBluetoothModeBasedTxPowerCap(
+      chain0_cap, chain1_cap, beamforming_cap));
+}
+
+TEST_F(BluetoothSarTest, SetBluetoothModeBasedTxPowerCapPlusHR) {
+  std::array<uint8_t, 4> chain0_cap = {10, 20, 30, 40};
+  std::array<uint8_t, 4> chain1_cap = {50, 60, 70, 80};
+  std::array<uint8_t, 8> beamforming_cap = {10, 20, 30, 40, 50, 60, 70, 80};
+
+  HalPacket command = bluetooth_sar_handler_->BuildCommandHRModeWrapper(
+      chain0_cap, chain1_cap, beamforming_cap, false, false);
+  EXPECT_CALL(mock_hci_router_, SendCommand(command, _)).Times(1);
+
+  EXPECT_FALSE(bluetooth_sar_handler_->SetBluetoothModeBasedTxPowerCapPlusHR(
+      chain0_cap, chain1_cap, beamforming_cap));
+
+  EnableBluetooth();
+  EXPECT_TRUE(bluetooth_sar_handler_->SetBluetoothModeBasedTxPowerCapPlusHR(
+      chain0_cap, chain1_cap, beamforming_cap));
+}
+
+}  // namespace sar
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/thread/socket_processor.cc b/bluetooth/bluetooth_hal/extensions/thread/socket_processor.cc
new file mode 100644
index 0000000000..b0b65baa2f
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/thread/socket_processor.cc
@@ -0,0 +1,499 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.thread_dispatcher.socket"
+
+#include "bluetooth_hal/extensions/thread/socket_processor.h"
+
+#include <grp.h>
+#include <sys/inotify.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+
+#include <cstdint>
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+using ::bluetooth_hal::hci::HalPacketCallback;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+enum class SocketDirection {
+  kSend = 0,
+  kRecv,
+};
+
+enum class ReadState {
+  kDataHeader,
+  kDataFlag,
+  kDataPayload,
+};
+
+class SocketProcessorImpl;
+SocketProcessorImpl* processor = nullptr;
+
+class SocketProcessorImpl : public SocketProcessor {
+ public:
+  SocketProcessorImpl(const std::string& socket_path,
+                      std::optional<HalPacketCallback> hal_packet_cb);
+
+  ~SocketProcessorImpl() override;
+
+  bool Send(const std::vector<uint8_t>& data) override;
+
+  bool Recv() override;
+
+  bool OpenServer() override;
+
+  void CloseServer() override;
+
+  void CloseClient() override;
+
+  int AcceptClient() override;
+
+  void SetServerSocket(int server_socket) override;
+
+  void SetClientSocket(int client_socket) override;
+
+  void SetSocketMode(SocketMode socket_mode) override;
+
+  int GetServerSocket() const override;
+
+  int GetClientSocket() const override;
+
+  bool IsSocketFileExisted() const override;
+
+  int OpenSocketFileMonitor() override;
+
+  void CloseSocketFileMonitor() override;
+
+  int GetSocketFileMonitor() override;
+
+ private:
+  static constexpr int kMaxWaitingConnectReq = 3;
+
+  bool SendPacket(const std::vector<uint8_t>& data);
+
+  bool RecvPacket();
+
+  bool SendStream(const std::vector<uint8_t>& data);
+
+  bool RecvStream();
+
+  bool RecvStreamWithFixLength(uint16_t length);
+
+  void ResetReadState();
+
+  bool CreateSocket();
+
+  bool BindSocket();
+
+  bool ListenForClients();
+
+  void PrintSocketErr(int ret_val, SocketDirection dir);
+
+  ReadState read_state_{ReadState::kDataHeader};
+  SocketMode socket_mode_ = SocketMode::kSockModeSeqPacket;
+  size_t payload_length_{0};
+  std::vector<uint8_t> packet_;
+  std::vector<uint8_t> data_;
+  int server_socket_;
+  int client_socket_;
+  int socket_file_monitor_fd_;
+  std::string socket_path_;
+  std::optional<HalPacketCallback> hal_packet_cb_;
+};
+
+SocketProcessorImpl::SocketProcessorImpl(
+    const std::string& socket_path,
+    std::optional<HalPacketCallback> hal_packet_cb)
+    : server_socket_(kInvalidFileDescriptor),
+      client_socket_(kInvalidFileDescriptor),
+      socket_file_monitor_fd_(kInvalidFileDescriptor),
+      socket_path_(socket_path),
+      hal_packet_cb_(hal_packet_cb) {}
+
+SocketProcessorImpl::~SocketProcessorImpl() {
+  SystemCallWrapper::GetWrapper().Unlink(socket_path_.c_str());
+}
+
+bool SocketProcessorImpl::Send(const std::vector<uint8_t>& data) {
+  LOG(DEBUG) << __func__ << ": Sending packet to client.";
+
+  if (socket_mode_ == SocketMode::kSockModeSeqPacket) {
+    return SendPacket(data);
+  }
+  if (socket_mode_ == SocketMode::kSockModeStream) {
+    return SendStream(data);
+  }
+  return false;
+}
+
+bool SocketProcessorImpl::Recv() {
+  LOG(DEBUG) << __func__ << ": Receiving packet from client.";
+
+  if (socket_mode_ == SocketMode::kSockModeSeqPacket) {
+    return RecvPacket();
+  }
+  if (socket_mode_ == SocketMode::kSockModeStream) {
+    return RecvStream();
+  }
+  return false;
+}
+
+bool SocketProcessorImpl::OpenServer() {
+  return CreateSocket() && BindSocket() && ListenForClients();
+}
+
+void SocketProcessorImpl::CloseServer() {
+  SystemCallWrapper::GetWrapper().Close(server_socket_);
+  SystemCallWrapper::GetWrapper().Unlink(socket_path_.c_str());
+  server_socket_ = kInvalidFileDescriptor;
+}
+
+void SocketProcessorImpl::CloseClient() {
+  SystemCallWrapper::GetWrapper().Close(client_socket_);
+  client_socket_ = kInvalidFileDescriptor;
+}
+
+int SocketProcessorImpl::AcceptClient() {
+  sockaddr_un client_address;
+  socklen_t client_address_len = sizeof(client_address);
+
+  if (server_socket_ == kInvalidFileDescriptor) {
+    return kInvalidFileDescriptor;
+  }
+
+  int new_client_socket = SystemCallWrapper::GetWrapper().Accept(
+      server_socket_, reinterpret_cast<struct sockaddr*>(&client_address),
+      &client_address_len);
+
+  return new_client_socket;
+}
+
+void SocketProcessorImpl::SetServerSocket(int server_socket) {
+  server_socket_ = server_socket;
+}
+
+void SocketProcessorImpl::SetClientSocket(int client_socket) {
+  client_socket_ = client_socket;
+}
+
+void SocketProcessorImpl::SetSocketMode(SocketMode socket_mode) {
+  if (server_socket_ != kInvalidFileDescriptor) {
+    return;
+  }
+
+  if (socket_mode != SocketMode::kSockModeSeqPacket &&
+      socket_mode != SocketMode::kSockModeStream) {
+    return;
+  }
+
+  socket_mode_ = socket_mode;
+}
+
+int SocketProcessorImpl::GetServerSocket() const { return server_socket_; }
+
+int SocketProcessorImpl::GetClientSocket() const { return client_socket_; }
+
+bool SocketProcessorImpl::IsSocketFileExisted() const {
+  struct stat st;
+  return (SystemCallWrapper::GetWrapper().Stat(socket_path_.c_str(), &st) ==
+          0) &&
+         SystemCallWrapper::GetWrapper().IsSocketFile(st.st_mode);
+}
+
+int SocketProcessorImpl::OpenSocketFileMonitor() {
+  if (socket_file_monitor_fd_ != kInvalidFileDescriptor) {
+    return socket_file_monitor_fd_;
+  }
+
+  socket_file_monitor_fd_ = SystemCallWrapper::GetWrapper().InotifyInit();
+  if (socket_file_monitor_fd_ == kInvalidFileDescriptor) {
+    LOG(WARNING) << __func__ << ": Error creating inotify processor.";
+    return socket_file_monitor_fd_;
+  }
+
+  int watch_fd = SystemCallWrapper::GetWrapper().InotifyAddWatch(
+      socket_file_monitor_fd_, kThreadDispatcherFolderPath, IN_DELETE);
+  if (watch_fd == kInvalidFileDescriptor) {
+    LOG(WARNING) << __func__ << ": Error adding watch to socket file.";
+    socket_file_monitor_fd_ = kInvalidFileDescriptor;
+    return socket_file_monitor_fd_;
+  }
+
+  return socket_file_monitor_fd_;
+}
+
+void SocketProcessorImpl::CloseSocketFileMonitor() {
+  SystemCallWrapper::GetWrapper().Close(socket_file_monitor_fd_);
+  socket_file_monitor_fd_ = kInvalidFileDescriptor;
+}
+
+int SocketProcessorImpl::GetSocketFileMonitor() {
+  return socket_file_monitor_fd_;
+}
+
+bool SocketProcessorImpl::SendPacket(const std::vector<uint8_t>& data) {
+  ssize_t bytes_sent = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Send(
+      client_socket_, data.data(), data.size(), 0));
+  if (bytes_sent <= 0) {
+    PrintSocketErr(bytes_sent, SocketDirection::kSend);
+    return false;
+  }
+  return true;
+}
+
+bool SocketProcessorImpl::RecvPacket() {
+  packet_.resize(kRadioSpinelRxFrameBufferSize);
+  ssize_t bytes_read = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Recv(
+      client_socket_, packet_.data(), packet_.size(), 0));
+  if (bytes_read <= 0) {
+    PrintSocketErr(bytes_read, SocketDirection::kRecv);
+    return false;
+  }
+
+  packet_.resize(bytes_read);
+  (*hal_packet_cb_)(packet_);
+  return true;
+}
+
+bool SocketProcessorImpl::SendStream(const std::vector<uint8_t>& data) {
+  uint8_t head_buffer[1] = {kSocketSpecificHeader};
+  ssize_t bytes_sent = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Send(
+      client_socket_, head_buffer, sizeof(head_buffer), 0));
+  if (bytes_sent <= 0) {
+    PrintSocketErr(bytes_sent, SocketDirection::kSend);
+    return false;
+  }
+
+  uint16_t packet_size = static_cast<uint16_t>(data.size());
+  uint8_t len_buffer[2] = {static_cast<uint8_t>(packet_size & 0xFF),
+                           static_cast<uint8_t>((packet_size >> 8) & 0xFF)};
+  bytes_sent = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Send(
+      client_socket_, len_buffer, sizeof(len_buffer), 0));
+  if (bytes_sent <= 0) {
+    PrintSocketErr(bytes_sent, SocketDirection::kSend);
+    return false;
+  }
+
+  size_t total_bytes_sent = 0;
+  while (total_bytes_sent < data.size()) {
+    ssize_t bytes_sent =
+        TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Send(
+            client_socket_, data.data() + total_bytes_sent,
+            data.size() - total_bytes_sent, 0));
+    if (bytes_sent <= 0) {
+      PrintSocketErr(bytes_sent, SocketDirection::kSend);
+      return false;
+    }
+    total_bytes_sent += bytes_sent;
+  }
+  return true;
+}
+
+bool SocketProcessorImpl::RecvStream() {
+  size_t read_len = 0;
+
+  switch (read_state_) {
+    case ReadState::kDataHeader:
+      read_len = 1;  // Header size is 1.
+      break;
+    case ReadState::kDataFlag:
+      read_len = 2;  // Length size is 2.
+      break;
+    case ReadState::kDataPayload:
+      read_len = payload_length_;
+      break;
+    default:
+      LOG(ERROR) << __func__ << ": Invalid read state.";
+      return false;
+  }
+
+  if (!RecvStreamWithFixLength(read_len)) {
+    return false;
+  }
+
+  switch (read_state_) {
+    case ReadState::kDataHeader: {
+      if (data_[0] != kSocketSpecificHeader) {
+        LOG(ERROR) << __func__ << ": Invalid header type.";
+        ResetReadState();
+        return false;
+      }
+      read_state_ = ReadState::kDataFlag;
+      break;
+    }
+
+    case ReadState::kDataFlag: {
+      uint16_t payload_size = static_cast<uint16_t>(data_[0]) |
+                              (static_cast<uint16_t>(data_[1]) << 8);
+      if (!payload_size) {
+        LOG(ERROR) << __func__ << ": Invalid payload size.";
+        ResetReadState();
+        return false;
+      }
+      packet_.resize(payload_size);
+      payload_length_ = payload_size;
+      read_state_ = ReadState::kDataPayload;
+      break;
+    }
+
+    case ReadState::kDataPayload: {
+      memcpy(packet_.data(), data_.data(), payload_length_);
+      (*hal_packet_cb_)(packet_);
+      ResetReadState();
+      break;
+    }
+  }
+
+  return true;
+}
+
+bool SocketProcessorImpl::RecvStreamWithFixLength(uint16_t length) {
+  if (!length) {
+    return false;
+  }
+
+  data_.resize(length);
+  size_t total_bytes_should_read = length;
+  ssize_t cur_idx = 0;
+
+  while (total_bytes_should_read > 0) {
+    ssize_t bytes_read =
+        TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Recv(
+            client_socket_, data_.data() + cur_idx, total_bytes_should_read,
+            0));
+    if (bytes_read <= 0) {
+      PrintSocketErr(bytes_read, SocketDirection::kRecv);
+      return false;
+    }
+    cur_idx += bytes_read;
+    total_bytes_should_read -= bytes_read;
+  }
+
+  return true;
+}
+
+void SocketProcessorImpl::ResetReadState() {
+  read_state_ = ReadState::kDataHeader;
+  payload_length_ = 0;
+}
+
+bool SocketProcessorImpl::CreateSocket() {
+  int new_server_socket = SystemCallWrapper::GetWrapper().Socket(
+      AF_UNIX, static_cast<int>(socket_mode_), 0);
+
+  if (new_server_socket == kInvalidFileDescriptor) {
+    LOG(ERROR) << __func__ << ": Unable to create the socket.";
+    return false;
+  }
+
+  server_socket_ = new_server_socket;
+  return true;
+}
+
+bool SocketProcessorImpl::BindSocket() {
+  SystemCallWrapper::GetWrapper().Unlink(socket_path_.c_str());
+  sockaddr_un server_address;
+  server_address.sun_family = AF_UNIX;
+  strcpy(server_address.sun_path, socket_path_.c_str());
+
+  if (SystemCallWrapper::GetWrapper().Bind(
+          server_socket_, reinterpret_cast<struct sockaddr*>(&server_address),
+          sizeof(server_address)) == -1) {
+    LOG(ERROR) << __func__ << ": Unable to bind the socket.";
+    CloseServer();
+    return false;
+  }
+
+  // Change the permission of the socket file.
+  const char* group_name = "system";
+  struct group* grp_info = getgrnam(group_name);
+  if (grp_info != nullptr) {
+    chown(socket_path_.c_str(), -1, grp_info->gr_gid);
+  }
+  chmod(socket_path_.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
+
+  return true;
+}
+
+bool SocketProcessorImpl::ListenForClients() {
+  if (SystemCallWrapper::GetWrapper().Listen(server_socket_,
+                                             kMaxWaitingConnectReq) == -1) {
+    LOG(ERROR) << __func__ << ": Unable to listen for clients.";
+    CloseServer();
+    return false;
+  }
+  return true;
+}
+
+void SocketProcessorImpl::PrintSocketErr(int ret_val, SocketDirection dir) {
+  if (ret_val == -1) {
+    LOG(WARNING) << __func__
+                 << ": Unable to receive Thread frames from the Thread HAL, "
+                 << "client socket: " << client_socket_
+                 << ", direction: " << static_cast<int>(dir);
+  } else if (ret_val == 0) {
+    LOG(WARNING) << __func__
+                 << ": Client connection is closed or send buffer is full, "
+                 << "direction: " << static_cast<int>(dir);
+  }
+}
+
+void SocketProcessor::Initialize(
+    const std::string& socket_path,
+    std::optional<HalPacketCallback> hal_packet_cb) {
+  if (processor) {
+    LOG(WARNING) << __func__ << "Already initialize the socket processor.";
+    return;
+  }
+  CHECK(hal_packet_cb != std::nullopt)
+      << __func__ << ": hal_packet_cb == nullptr";
+  processor = new SocketProcessorImpl(socket_path, hal_packet_cb);
+}
+
+void SocketProcessor::Cleanup() {
+  LOG(DEBUG) << __func__;
+  if (!processor) {
+    return;
+  }
+
+  SocketProcessorImpl* ptr = processor;
+  processor = nullptr;
+
+  delete ptr;
+}
+
+SocketProcessor* SocketProcessor::GetProcessor() {
+  if (!processor) {
+    LOG(FATAL) << __func__ << ": processor == nullptr.";
+  }
+  return processor;
+}
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/thread/socket_processor_test.cc b/bluetooth/bluetooth_hal/extensions/thread/socket_processor_test.cc
new file mode 100644
index 0000000000..8afbd08c23
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/thread/socket_processor_test.cc
@@ -0,0 +1,776 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/thread/socket_processor.h"
+
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/test/common/test_helper.h"
+#include "bluetooth_hal/test/mock/mock_system_call_wrapper.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace thread {
+namespace {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Invoke;
+using ::testing::Mock;
+using ::testing::Return;
+using ::testing::Test;
+
+using ::bluetooth_hal::util::MatcherFactory;
+using ::bluetooth_hal::util::MockPacketHandler;
+using ::bluetooth_hal::util::MockSystemCallWrapper;
+
+// Mocked data used for stream-based socket tests.
+std::vector<uint8_t> send_data = {0, 1, 2, 3, 4};
+constexpr uint8_t kHeaderBuffer[1] = {kSocketSpecificHeader};
+constexpr uint16_t kDataSize = 5;
+constexpr uint8_t kPayloadSizeBuffer[2] = {
+    static_cast<uint8_t>(kDataSize & 0xFF),
+    static_cast<uint8_t>((kDataSize >> 8) & 0xFF)};
+
+// Basic test class for socket processor.
+class SocketProcessorTestBase : public Test {
+ protected:
+  void SetUp() override {
+    MockSystemCallWrapper::SetMockWrapper(&mock_system_call_wrapper_);
+
+    SocketProcessor::Initialize(
+        test_socket_path_,
+        std::bind_front(&MockPacketHandler::HalPacketCallback,
+                        &mock_packet_handler_));
+    TestInit();
+  }
+
+  void TearDown() override { TestDeinit(); }
+
+  void TestInit() {
+    ASSERT_NE(SocketProcessor::GetProcessor(), nullptr);
+    // Socket fd should be initialized when creating the instance.
+    ASSERT_EQ(SocketProcessor::GetProcessor()->GetServerSocket(),
+              kInvalidFileDescriptor);
+    ASSERT_EQ(SocketProcessor::GetProcessor()->GetClientSocket(),
+              kInvalidFileDescriptor);
+  }
+
+  void TestDeinit() {
+    EXPECT_CALL(mock_system_call_wrapper_, Unlink(_)).Times(1);
+    ASSERT_NE(SocketProcessor::GetProcessor(), nullptr);
+    SocketProcessor::Cleanup();
+    // Instance should be null if we do not initialize after cleanup.
+    EXPECT_DEATH(SocketProcessor::GetProcessor(), "");
+  }
+
+  std::string test_socket_path_ = "/tmp/test/socket";
+  MockPacketHandler mock_packet_handler_;
+  MockSystemCallWrapper mock_system_call_wrapper_;
+};
+
+// Test class for sequence packet mode socket processor.
+class SocketProcessorTestSeqPacket : public SocketProcessorTestBase {
+ protected:
+  void SetUp() override {
+    SocketProcessorTestBase::SetUp();
+    SocketProcessor::GetProcessor()->SetSocketMode(
+        SocketMode::kSockModeSeqPacket);
+  }
+};
+
+// Test class for stream mode socket processor.
+class SocketProcessorTestStream : public SocketProcessorTestBase {
+ protected:
+  void SetUp() override {
+    SocketProcessorTestBase::SetUp();
+    SocketProcessor::GetProcessor()->SetSocketMode(SocketMode::kSockModeStream);
+  }
+};
+
+TEST_F(SocketProcessorTestBase, OpenServerReturnSuccess) {
+  ON_CALL(mock_system_call_wrapper_, Socket(_, _, _)).WillByDefault(Return(1));
+  ON_CALL(mock_system_call_wrapper_, Bind(_, _, _)).WillByDefault(Return(1));
+  ON_CALL(mock_system_call_wrapper_, Listen(_, _)).WillByDefault(Return(1));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Socket(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Unlink(_)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Bind(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Listen(_, _)).Times(1);
+
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->OpenServer());
+  ASSERT_NE(SocketProcessor::GetProcessor()->GetServerSocket(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, OpenServerCreateReturnFail) {
+  // Setting return value -1 of Socket() indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_, Socket(_, _, _)).WillByDefault(Return(-1));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Socket(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Unlink(_)).Times(0);
+  EXPECT_CALL(mock_system_call_wrapper_, Bind(_, _, _)).Times(0);
+  EXPECT_CALL(mock_system_call_wrapper_, Listen(_, _)).Times(0);
+
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->OpenServer());
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetServerSocket(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, OpenServerBindReturnFail) {
+  ON_CALL(mock_system_call_wrapper_, Socket(_, _, _)).WillByDefault(Return(1));
+  // Setting return value -1 of Bind() indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_, Bind(_, _, _)).WillByDefault(Return(-1));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Socket(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Unlink(_)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Bind(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Listen(_, _)).Times(0);
+
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->OpenServer());
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetServerSocket(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, OpenServerListenReturnFail) {
+  ON_CALL(mock_system_call_wrapper_, Socket(_, _, _)).WillByDefault(Return(1));
+  ON_CALL(mock_system_call_wrapper_, Bind(_, _, _)).WillByDefault(Return(1));
+  // Setting return value -1 of Listen() indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_, Listen(_, _)).WillByDefault(Return(-1));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Socket(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Unlink(_)).Times(2);
+  EXPECT_CALL(mock_system_call_wrapper_, Bind(_, _, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Listen(_, _)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(1);
+
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->OpenServer());
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetServerSocket(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, CloseServerCheckServerSocket) {
+  EXPECT_CALL(mock_system_call_wrapper_, Unlink(_)).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Close(1)).Times(1);
+
+  SocketProcessor::GetProcessor()->SetServerSocket(1);
+  SocketProcessor::GetProcessor()->CloseServer();
+
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetServerSocket(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, CloseClientCheckClientSocket) {
+  EXPECT_CALL(mock_system_call_wrapper_, Close(1)).Times(1);
+
+  SocketProcessor::GetProcessor()->SetClientSocket(1);
+  SocketProcessor::GetProcessor()->CloseClient();
+
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetClientSocket(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, AcceptClientReturnSuccess) {
+  ON_CALL(mock_system_call_wrapper_, Accept(_, _, _)).WillByDefault(Return(1));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Accept(_, _, _)).Times(1);
+
+  SocketProcessor::GetProcessor()->SetServerSocket(1);
+  ASSERT_NE(SocketProcessor::GetProcessor()->AcceptClient(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, AcceptClientWithInvalidServerSocketReturnFail) {
+  // We cannot accept a client without creating the server.
+  EXPECT_CALL(mock_system_call_wrapper_, Accept(_, _, _)).Times(0);
+
+  ASSERT_EQ(SocketProcessor::GetProcessor()->AcceptClient(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, AcceptClientReturnConnectionFail) {
+  // Setting return value -1 for Accept() indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_, Accept(_, _, _)).WillByDefault(Return(-1));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Accept(_, _, _)).Times(1);
+
+  SocketProcessor::GetProcessor()->SetServerSocket(1);
+  ASSERT_EQ(SocketProcessor::GetProcessor()->AcceptClient(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, SetServerSocketAndCheck) {
+  SocketProcessor::GetProcessor()->SetServerSocket(1);
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetServerSocket(), 1);
+}
+
+TEST_F(SocketProcessorTestBase, SetClientSocketAndCheck) {
+  SocketProcessor::GetProcessor()->SetClientSocket(1);
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetClientSocket(), 1);
+}
+
+TEST_F(SocketProcessorTestBase, SendWithUnknownSocketModeReturnFail) {
+  std::vector<uint8_t> data;
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Send(data));
+}
+
+TEST_F(SocketProcessorTestBase, RecvWithUnknownSocketModeReturnFail) {
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestBase, OpenSocketFileMonitorReturnNotifyFail) {
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyInit())
+      .Times(1)
+      .WillOnce(Return(-1));
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyAddWatch(_, _, _)).Times(0);
+
+  ASSERT_EQ(SocketProcessor::GetProcessor()->OpenSocketFileMonitor(),
+            kInvalidFileDescriptor);
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, OpenSocketFileMonitorReturnAddWatchFail) {
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyInit())
+      .Times(1)
+      .WillOnce(Return(1));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      InotifyAddWatch(
+          _, MatcherFactory::CreateStringMatcher(kThreadDispatcherFolderPath),
+          _))
+      .Times(1)
+      .WillOnce(Return(-1));
+
+  ASSERT_EQ(SocketProcessor::GetProcessor()->OpenSocketFileMonitor(),
+            kInvalidFileDescriptor);
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, OpenSocketFileMonitorReturnSuccess) {
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyInit())
+      .Times(1)
+      .WillOnce(Return(1));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      InotifyAddWatch(
+          _, MatcherFactory::CreateStringMatcher(kThreadDispatcherFolderPath),
+          _))
+      .Times(1)
+      .WillOnce(Return(1));
+
+  ASSERT_NE(SocketProcessor::GetProcessor()->OpenSocketFileMonitor(),
+            kInvalidFileDescriptor);
+  ASSERT_NE(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, OpenSocketFileMonitorTwice) {
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyInit())
+      .Times(1)
+      .WillOnce(Return(1));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      InotifyAddWatch(
+          _, MatcherFactory::CreateStringMatcher(kThreadDispatcherFolderPath),
+          _))
+      .Times(1)
+      .WillOnce(Return(1));
+
+  ASSERT_NE(SocketProcessor::GetProcessor()->OpenSocketFileMonitor(),
+            kInvalidFileDescriptor);
+  ASSERT_NE(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+
+  // We already have notify fd, so all system calls should not be executed.
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyInit()).Times(0);
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyAddWatch(_, _, _)).Times(0);
+
+  ASSERT_NE(SocketProcessor::GetProcessor()->OpenSocketFileMonitor(),
+            kInvalidFileDescriptor);
+  ASSERT_NE(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, CloseSocketFileMonitorReturnSuccess) {
+  EXPECT_CALL(mock_system_call_wrapper_, InotifyInit())
+      .Times(1)
+      .WillOnce(Return(1));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      InotifyAddWatch(
+          _, MatcherFactory::CreateStringMatcher(kThreadDispatcherFolderPath),
+          _))
+      .Times(1)
+      .WillOnce(Return(1));
+
+  ASSERT_NE(SocketProcessor::GetProcessor()->OpenSocketFileMonitor(),
+            kInvalidFileDescriptor);
+  ASSERT_NE(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+
+  EXPECT_CALL(mock_system_call_wrapper_,
+              Close(SocketProcessor::GetProcessor()->GetSocketFileMonitor()))
+      .Times(1);
+
+  SocketProcessor::GetProcessor()->CloseSocketFileMonitor();
+  ASSERT_EQ(SocketProcessor::GetProcessor()->GetSocketFileMonitor(),
+            kInvalidFileDescriptor);
+}
+
+TEST_F(SocketProcessorTestBase, CheckIfSocketFileExistedReturnFileExisted) {
+  EXPECT_CALL(mock_system_call_wrapper_,
+              Stat(MatcherFactory::CreateStringMatcher(test_socket_path_), _))
+      .Times(1)
+      .WillOnce(Return(0));
+  EXPECT_CALL(mock_system_call_wrapper_, IsSocketFile(_))
+      .Times(1)
+      .WillOnce(Return(true));
+
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->IsSocketFileExisted());
+}
+
+TEST_F(SocketProcessorTestBase, CheckIfSocketFileExistedReturnFileNotExisted) {
+  EXPECT_CALL(mock_system_call_wrapper_,
+              Stat(MatcherFactory::CreateStringMatcher(test_socket_path_), _))
+      .Times(1)
+      .WillOnce(Return(1));
+  EXPECT_CALL(mock_system_call_wrapper_, IsSocketFile(_)).Times(0);
+
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->IsSocketFileExisted());
+}
+
+TEST_F(SocketProcessorTestBase,
+       CheckIfSocketFileExistedReturnFileExistedButNotSocket) {
+  EXPECT_CALL(mock_system_call_wrapper_,
+              Stat(MatcherFactory::CreateStringMatcher(test_socket_path_), _))
+      .Times(1)
+      .WillOnce(Return(0));
+  EXPECT_CALL(mock_system_call_wrapper_, IsSocketFile(_))
+      .Times(1)
+      .WillOnce(Return(false));
+
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->IsSocketFileExisted());
+}
+
+TEST_F(SocketProcessorTestSeqPacket, SendPacketReturnSuccess) {
+  // We mock Send() to return 3, indicating successful sending of three bytes.
+  ON_CALL(mock_system_call_wrapper_, Send(_, _, _, _)).WillByDefault(Return(3));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Send(_, _, _, _)).Times(1);
+
+  std::vector<uint8_t> data;
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Send(data));
+}
+
+TEST_F(SocketProcessorTestSeqPacket, SendPacketReturnConnectionFail) {
+  // Setting return value of Send() <= 0 indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_, Send(_, _, _, _)).WillByDefault(Return(0));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Send(_, _, _, _)).Times(1);
+
+  std::vector<uint8_t> data;
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Send(data));
+}
+
+TEST_F(SocketProcessorTestSeqPacket, RecvPacketReturnSuccess) {
+  // We mock Recv() to return 5, indicating a successful receipt of five
+  // bytes.
+  ON_CALL(mock_system_call_wrapper_, Recv(_, _, _, _)).WillByDefault(Return(5));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, _, _)).Times(1);
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(1);
+
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestSeqPacket, RecvPacketReturnConnectionFail) {
+  // Setting return value of Recv() <= 0 indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_, Recv(_, _, _, _)).WillByDefault(Return(0));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, _, _)).Times(1);
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(0);
+
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, SendPayloadAtOneTimeSuccess) {
+  // Mock that the buffer is idle, so we can send the payload in one step.
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _, _))
+      .WillByDefault(Return(1));
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _))
+      .WillByDefault(Return(2));
+  ON_CALL(mock_system_call_wrapper_,
+          Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data(), 5),
+               _, _))
+      .WillByDefault(Return(5));
+
+  // Expect Send() to be called three times:
+  // 1. Send the header.
+  // 2. Send the payload size.
+  // 3. Send the payload (5 bytes in total).
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _,
+           _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data(), 5), _,
+           _));
+
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Send(send_data));
+}
+
+TEST_F(SocketProcessorTestStream, SendPayloadInMultipleTimesSuccess) {
+  // Mock that the buffer is busy, so we need to send the payload in multiple
+  // steps.
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _, _))
+      .WillByDefault(Return(1));
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _))
+      .WillByDefault(Return(2));
+  ON_CALL(mock_system_call_wrapper_,
+          Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data(), 5),
+               _, _))
+      .WillByDefault(Return(2));
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data() + 2, 3),
+           _, _))
+      .WillByDefault(Return(2));
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data() + 4, 1),
+           _, _))
+      .WillByDefault(Return(1));
+
+  // Expect Send() to be called five times:
+  // 1. Send the header.
+  // 2. Send the payload size.
+  // 3. Send the first 2 bytes of the payload.
+  // 4. Send the next 2 bytes of the payload.
+  // 5. Send the last 1 byte of the payload.
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _,
+           _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data(), 5), _,
+           _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data() + 2, 3),
+           _, _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data() + 4, 1),
+           _, _));
+
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Send(send_data));
+}
+
+TEST_F(SocketProcessorTestStream, SendHeaderReturnConnectionFail) {
+  // Mock connection failure when sending header. Setting return value of
+  // Send() <= 0 indicates a system call error.
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _, _))
+      .WillByDefault(Return(0));
+
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _, _))
+      .Times(1);
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Send(send_data));
+}
+
+TEST_F(SocketProcessorTestStream, SendPayloadSizeReturnConnectionFail) {
+  // Mock connection failure when sending payload size.
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _, _))
+      .WillByDefault(Return(1));
+
+  // Setting return value of Send() <= 0 indicates a system call error.
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _))
+      .WillByDefault(Return(0));
+
+  // Expect Send() to be called twice:
+  // 1. Send header successfully.
+  // 2. Send payload size fails.
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _,
+           _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _));
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Send(send_data));
+}
+
+TEST_F(SocketProcessorTestStream, SendPayloadReturnConnectionFail) {
+  // Mock connection failure when sending payload.
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _, _))
+      .WillByDefault(Return(1));
+  ON_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _))
+      .WillByDefault(Return(2));
+
+  // Setting return value of Send() <= 0 indicates a system call error.
+  ON_CALL(mock_system_call_wrapper_,
+          Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data(), 5),
+               _, _))
+      .WillByDefault(Return(0));
+
+  // Expect Send() to be called three times:
+  // 1. Send header successfully.
+  // 2. Send payload size successfully.
+  // 3. Sending payload fails.
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kHeaderBuffer, 1), _,
+           _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(kPayloadSizeBuffer, 2),
+           _, _));
+  EXPECT_CALL(
+      mock_system_call_wrapper_,
+      Send(_, MatcherFactory::CreateByteContentMatcher(send_data.data(), 5), _,
+           _));
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Send(send_data));
+}
+
+TEST_F(SocketProcessorTestStream, RecvPayloadAtOneTimeSuccess) {
+  // Header state: mock receiving header successfully, returning 1.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = kSocketSpecificHeader;
+                      }),
+                      Return(1)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Flag state: mock expected length size as 17.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 2, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = 17;
+                      }),
+                      Return(2)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Payload state: read full buffer at one time, returning 17 from recv().
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 17, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        std::fill(ptr, ptr + 17, 1);
+                      }),
+                      Return(17)));
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(1);
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, RecvPayloadInMultipleTimesSuccess) {
+  // Header state: return 1 as we receive the header successfully.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = kSocketSpecificHeader;
+                      }),
+                      Return(1)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Flag state: mock expected length as 17.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 2, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = 17;
+                      }),
+                      Return(2)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Payload state: expect to call Recv() three times.
+  // 1. Receive payload for the first 5 bytes.
+  // 2. Receive payload for the next 5 bytes.
+  // 3. Receive payload for the last 7 bytes.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 17, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        std::fill(ptr, ptr + 5, 1);
+                      }),
+                      Return(5)));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 12, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        std::fill(ptr, ptr + 5, 1);
+                      }),
+                      Return(5)));
+
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 7, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        std::fill(ptr, ptr + 7, 1);
+                      }),
+                      Return(7)));
+
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(1);
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, RecvHeaderReturnConnectionFail) {
+  // Header state: return value of Recv() <= 0 indicates a system call error.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _)).WillOnce(Return(0));
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, RecvHeaderReturnInvalidValueFail) {
+  // Header state: mock receiving an invalid header value when calling Recv().
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = 1;
+                      }),
+                      Return(1)));
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, RecvPayloadSizeReturnConnectionFail) {
+  // Header state: return 1 as we receive the header successfully.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = kSocketSpecificHeader;
+                      }),
+                      Return(1)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Flag state: return value of Recv() <= 0 indicates a system call error.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 2, _)).WillOnce(Return(0));
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, RecvPayloadSizeReturnZeroFail) {
+  // Header state.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = kSocketSpecificHeader;
+                      }),
+                      Return(1)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Flag state: mock an invalid payload size of 0 when calling Recv().
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 2, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = 0;
+                      }),
+                      Return(2)));
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+TEST_F(SocketProcessorTestStream, RecvPayloadReturnConnectionFail) {
+  // Header state.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 1, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = kSocketSpecificHeader;
+                      }),
+                      Return(1)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Flag state: mock an expected length size of 17.
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 2, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t length,
+                                [[maybe_unused]] int flags) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        *ptr = 17;
+                      }),
+                      Return(2)));
+  ASSERT_TRUE(SocketProcessor::GetProcessor()->Recv());
+
+  // Payload state: system call returns <= 0 when calling Recv().
+  EXPECT_CALL(mock_system_call_wrapper_, Recv(_, _, 17, _)).WillOnce(Return(0));
+
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(0);
+  ASSERT_FALSE(SocketProcessor::GetProcessor()->Recv());
+}
+
+}  // namespace
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/thread/thread_daemon.cc b/bluetooth/bluetooth_hal/extensions/thread/thread_daemon.cc
new file mode 100644
index 0000000000..fad3b933c2
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/thread/thread_daemon.cc
@@ -0,0 +1,405 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.thread_dispatcher.daemon"
+
+#include "bluetooth_hal/extensions/thread/thread_daemon.h"
+
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include <sys/inotify.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <atomic>
+#include <cstdint>
+#include <mutex>
+#include <string>
+#include <thread>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "android-base/properties.h"
+#include "android-base/stringprintf.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/extensions/thread/socket_processor.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::debug::DebugCentral;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+void ThreadDaemon::SendUplink(const HalPacket& packet) {
+  std::lock_guard<std::mutex> guard(client_mtx_);
+
+  if (!is_daemon_running_) {
+    LOG(WARNING) << __func__ << ": Daemon is not running.";
+    return;
+  }
+
+  if (!is_client_connected_) {
+    LOG(WARNING) << __func__ << ": Thread HAL is not connected.";
+    return;
+  }
+
+  if (packet.empty()) {
+    LOG(WARNING) << __func__ << ": Data is empty.";
+    return;
+  }
+
+  std::vector<uint8_t> spinel_packet = ExtractFromHalPacket(packet);
+  socket_processor_->Send(spinel_packet);
+}
+
+void ThreadDaemon::SendDownlink(const std::vector<uint8_t>& packet) {
+  if (!CheckIfHardwareReset(packet)) {
+    HalPacket vendor_packet = ConstructToHalPacket(packet);
+    (*hal_packet_cb_)(vendor_packet);
+    return;
+  }
+
+  // Handle hardware reset if a specific packet is received.
+  ANCHOR_LOG_WARNING(AnchorType::THREAD_HARDWARE_RESET)
+      << __func__ << ": Hardware reset from Thread HAL.";
+  SocketProcessor::Cleanup();
+  SystemCallWrapper::GetWrapper().Kill(getpid(), SIGKILL);
+}
+
+bool ThreadDaemon::IsDaemonRunning() const { return is_daemon_running_; }
+
+bool ThreadDaemon::Start() {
+  LOG(INFO) << __func__;
+
+  if (std::atomic_exchange(&is_daemon_running_, true)) {
+    LOG(WARNING)
+        << __func__
+        << ": Daemon is already started. Close it first before restarting.";
+    return false;
+  }
+
+  require_starting_ = true;
+  if (!StartDaemon()) {
+    LOG(ERROR) << __func__ << ": Failed to start the daemon.";
+    is_daemon_running_ = false;
+    require_starting_ = false;
+    return false;
+  }
+
+  return true;
+}
+
+bool ThreadDaemon::Stop() {
+  LOG(INFO) << __func__;
+
+  if (!std::atomic_exchange(&is_daemon_running_, false)) {
+    LOG(WARNING) << __func__
+                 << ": Daemon is already stopped. No need to close.";
+    return false;
+  }
+
+  StopDaemon();
+  require_starting_ = false;
+
+  return true;
+}
+
+void ThreadDaemon::ConfigureSocketProcessor() {
+  SocketProcessor::Initialize(
+      kThreadDispatcherSocketPath,
+      [this](const std::vector<uint8_t>& data) { SendDownlink(data); });
+
+  socket_processor_ = SocketProcessor::GetProcessor();
+
+  auto socket_mode = static_cast<SocketMode>(::android::base::GetIntProperty(
+      Property::kThreadDispatcherSocketMode,
+      static_cast<int>(SocketMode::kSockModeSeqPacket),
+      static_cast<int>(SocketMode::kSockModeStream),
+      static_cast<int>(SocketMode::kSockModeSeqPacket)));
+
+  LOG(INFO) << __func__ << ": socket mode: " << static_cast<int>(socket_mode);
+  socket_processor_->SetSocketMode(socket_mode);
+}
+
+bool ThreadDaemon::StartDaemon() {
+  LOG(INFO) << __func__;
+
+  int pipe_fds[2];
+  if (SystemCallWrapper::GetWrapper().CreatePipe(pipe_fds, O_NONBLOCK)) {
+    LOG(ERROR) << __func__ << ": Failed to create pipe.";
+    return false;
+  }
+
+  notification_listen_fd_ = pipe_fds[0];
+  notification_write_fd_ = pipe_fds[1];
+
+  server_thread_ = std::thread(&ThreadDaemon::DaemonRoutine, this);
+
+  if (!server_thread_.joinable()) {
+    LOG(ERROR) << __func__ << ": Server thread is not joinable.";
+    return false;
+  }
+
+  return true;
+}
+
+bool ThreadDaemon::StopDaemon() {
+  LOG(INFO) << __func__;
+
+  NotifyDaemonToStop();
+
+  if (server_thread_.joinable() &&
+      std::this_thread::get_id() != server_thread_.get_id()) {
+    server_thread_.join();
+  }
+
+  SystemCallWrapper::GetWrapper().Close(notification_listen_fd_);
+  SystemCallWrapper::GetWrapper().Close(notification_write_fd_);
+  notification_listen_fd_ = kInvalidFileDescriptor;
+  notification_write_fd_ = kInvalidFileDescriptor;
+
+  return true;
+}
+
+bool ThreadDaemon::NotifyDaemonToStop() {
+  LOG(INFO) << __func__;
+
+  uint8_t stub_buffer = 0;  // Notification buffer.
+
+  if (TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+          notification_write_fd_, &stub_buffer, sizeof(stub_buffer))) < 0) {
+    LOG(ERROR) << __func__ << ": Failed to write to notification pipe.";
+    return false;
+  }
+
+  return true;
+}
+
+bool ThreadDaemon::AcceptClient() {
+  DURATION_TRACKER(AnchorType::THREAD_ACCEPT_CLIENT,
+                   ::android::base::StringPrintf("Accept Thread client"));
+  LOG(DEBUG) << __func__ << ": Start processing connect request from client.";
+
+  int new_client_socket = socket_processor_->AcceptClient();
+
+  if (new_client_socket == kInvalidFileDescriptor) {
+    LOG(WARNING) << __func__ << ": Unable to accept client.";
+    return false;
+  }
+
+  if (socket_processor_->GetClientSocket() != kInvalidFileDescriptor ||
+      std::atomic_exchange(&is_client_connected_, true)) {
+    SystemCallWrapper::GetWrapper().Close(new_client_socket);
+    LOG(WARNING) << __func__ << ": Already connected to another client.";
+    return false;
+  }
+
+  std::lock_guard<std::mutex> guard(client_mtx_);
+  socket_processor_->SetClientSocket(new_client_socket);
+  LOG(INFO) << __func__ << ": Successfully accepted new client.";
+
+  return true;
+}
+
+void ThreadDaemon::MonitorSocket() {
+  LOG(DEBUG) << __func__
+             << ": Server socket: " << socket_processor_->GetServerSocket();
+
+  while (is_daemon_running_) {
+    fd_set monitor_fds;
+    PrepareFdsForMonitor(&monitor_fds);
+
+    LOG(DEBUG) << __func__ << ": Daemon is idle...";
+
+    int ret_val = SystemCallWrapper::GetWrapper().Select(
+        FD_SETSIZE, &monitor_fds, nullptr, nullptr, nullptr);
+    if (ret_val <= 0) {
+      continue;  // No activity or an error occurred, continue monitoring.
+    }
+
+    if (SystemCallWrapper::GetWrapper().FdIsSet(notification_listen_fd_,
+                                                &monitor_fds)) {
+      ANCHOR_LOG(AnchorType::THREAD_DADEMON_CLOSED)
+          << __func__ << ": Daemon is terminated by notification...";
+      LOG(DEBUG) << __func__ << ": Daemon is terminated by notification...";
+      uint8_t stub_buffer = 0;  // Reading one byte to clear the notification.
+      TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Read(
+          notification_listen_fd_, &stub_buffer, sizeof(stub_buffer)));
+      continue;
+    }
+
+    if (SystemCallWrapper::GetWrapper().FdIsSet(
+            socket_processor_->GetSocketFileMonitor(), &monitor_fds)) {
+      constexpr size_t kBufferSize = sizeof(inotify_event) + NAME_MAX + 1;
+      char buffer[kBufferSize] = {0};
+      ssize_t bytes_read = SystemCallWrapper::GetWrapper().Read(
+          socket_processor_->GetSocketFileMonitor(), &buffer, sizeof(buffer));
+
+      if (bytes_read > 0) {
+        inotify_event* event = reinterpret_cast<inotify_event*>(buffer);
+        if (event->mask & IN_DELETE &&
+            !socket_processor_->IsSocketFileExisted()) {
+          ANCHOR_LOG_DEBUG(AnchorType::THREAD_SOCKET_FILE_DELETED)
+              << __func__ << ": Socket file is deleted, need to restart...";
+          socket_processor_->CloseSocketFileMonitor();
+          require_starting_ = true;
+          break;
+        }
+      }
+    }
+
+    if (is_client_connected_ &&
+        SystemCallWrapper::GetWrapper().FdIsSet(
+            socket_processor_->GetClientSocket(), &monitor_fds)) {
+      if (!socket_processor_->Recv()) {
+        ANCHOR_LOG_ERROR(AnchorType::THREAD_CLIENT_ERROR)
+            << __func__ << ": Daemon receives from client failed...";
+        CleanUpClient();
+      }
+    }
+
+    if (SystemCallWrapper::GetWrapper().FdIsSet(
+            socket_processor_->GetServerSocket(), &monitor_fds)) {
+      ANCHOR_LOG_DEBUG(AnchorType::THREAD_CLIENT_CONNECT)
+          << __func__ << ": Daemon receives client connect request...";
+      AcceptClient();
+    }
+  }
+}
+
+void ThreadDaemon::DaemonRoutine() {
+  while (require_starting_) {
+    require_starting_ = false;
+    LOG(INFO) << __func__ << ": Daemon is open.";
+
+    if (socket_processor_->OpenServer()) {
+      if (socket_processor_->OpenSocketFileMonitor() ==
+          kInvalidFileDescriptor) {
+        LOG(WARNING) << __func__ << ": Unable to monitor socket file.";
+      }
+      MonitorSocket();
+    }
+
+    LOG(INFO) << __func__ << ": Daemon is closed.";
+
+    // Release resources.
+    CleanUpClient();
+    CleanUpServer();
+    socket_processor_->CloseSocketFileMonitor();
+  }
+}
+
+void ThreadDaemon::CleanUpServer() { socket_processor_->CloseServer(); }
+
+void ThreadDaemon::CleanUpClient() {
+  std::lock_guard<std::mutex> guard(client_mtx_);
+  is_client_connected_ = false;
+  socket_processor_->CloseClient();
+}
+
+bool ThreadDaemon::CheckIfHardwareReset(const std::vector<uint8_t>& packet) {
+  return packet.size() == kHardwareResetCommandSize &&
+         packet[0] == kSpinelHeader && packet[1] == kThreadCommandReset &&
+         packet[2] == kThreadCommandResetHardware;
+}
+
+void ThreadDaemon::PrepareFdsForMonitor(fd_set* monitor_fds) {
+  // Ensure the daemon thread will not become a zombie.
+  CHECK_NE(notification_listen_fd_, kInvalidFileDescriptor);
+
+  int server_fd = socket_processor_->GetServerSocket();
+  int client_fd = socket_processor_->GetClientSocket();
+  int monitor_fd = socket_processor_->GetSocketFileMonitor();
+
+  SystemCallWrapper::GetWrapper().FdZero(monitor_fds);
+
+  if (is_daemon_running_ && server_fd != kInvalidFileDescriptor) {
+    SystemCallWrapper::GetWrapper().FdSet(server_fd, monitor_fds);
+  }
+
+  if (is_client_connected_ && client_fd != kInvalidFileDescriptor) {
+    SystemCallWrapper::GetWrapper().FdSet(client_fd, monitor_fds);
+  }
+
+  if (monitor_fd != kInvalidFileDescriptor) {
+    SystemCallWrapper::GetWrapper().FdSet(monitor_fd, monitor_fds);
+  }
+
+  SystemCallWrapper::GetWrapper().FdSet(notification_listen_fd_, monitor_fds);
+}
+
+HalPacket ThreadDaemon::ConstructToHalPacket(
+    const std::vector<uint8_t>& packet) {
+  HalPacket hal_packet;
+
+  hal_packet.push_back(static_cast<uint8_t>(HciPacketType::kThreadData));
+
+  // Reserve two bytes for packet size.
+  hal_packet.push_back(0);  // Placeholder for first byte.
+  hal_packet.push_back(0);  // Placeholder for second byte.
+
+  uint16_t packet_size = static_cast<uint16_t>(packet.size());
+  hal_packet.push_back(static_cast<uint8_t>(packet_size & 0xFF));
+  hal_packet.push_back(static_cast<uint8_t>((packet_size >> 8) & 0xFF));
+
+  // Append the original packet data.
+  hal_packet.insert(hal_packet.end(), packet.begin(), packet.end());
+
+  return hal_packet;
+}
+
+std::vector<uint8_t> ThreadDaemon::ExtractFromHalPacket(
+    const HalPacket& packet) {
+  std::vector<uint8_t> raw_packet;
+  if (packet.size() < 1 + HciConstants::kHciThreadPreambleSize) {
+    LOG(WARNING) << __func__ << ": Invalid vendor data format.";
+    return raw_packet;
+  }
+
+  if (packet.GetType() != HciPacketType::kThreadData) {
+    return raw_packet;
+  }
+
+  uint16_t packet_size = static_cast<uint16_t>(packet[3]) |
+                         (static_cast<uint16_t>(packet[4]) << 8);
+
+  if (packet.size() != 1 + HciConstants::kHciThreadPreambleSize + packet_size) {
+    LOG(WARNING) << __func__
+                 << ": Data size does not match with the actual data.";
+    return raw_packet;
+  }
+
+  // Extract the raw packet data.
+  raw_packet.insert(raw_packet.end(),
+                    packet.begin() + 1 + HciConstants::kHciThreadPreambleSize,
+                    packet.end());
+
+  return raw_packet;
+}
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/thread/thread_daemon_test.cc b/bluetooth/bluetooth_hal/extensions/thread/thread_daemon_test.cc
new file mode 100644
index 0000000000..bed4be6a7e
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/thread/thread_daemon_test.cc
@@ -0,0 +1,744 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/thread/thread_daemon.h"
+
+#include <sys/inotify.h>
+
+#include <chrono>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/test/common/test_helper.h"
+#include "bluetooth_hal/test/mock/mock_socket_processor.h"
+#include "bluetooth_hal/test/mock/mock_system_call_wrapper.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace thread {
+namespace {
+
+using ::testing::_;
+using ::testing::AtLeast;
+using ::testing::Between;
+using ::testing::DoAll;
+using ::testing::Invoke;
+using ::testing::Mock;
+using ::testing::Return;
+using ::testing::Test;
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::util::MatcherFactory;
+using ::bluetooth_hal::util::MockPacketHandler;
+using ::bluetooth_hal::util::MockSystemCallWrapper;
+
+constexpr int kNotificationFd = 1;
+constexpr int kSocketMonitorFd = 2;
+constexpr int kServerFd = 3;
+constexpr int kClientFd = 4;
+
+constexpr int kSelectMockSleepTimeMs = 1000;
+constexpr int kDaemonThreadInitWaitTimeMs = 5;
+constexpr int kFullDaemonThreadSelectProcessWaitTimeMs = 2000;
+
+class ThreadDaemonTest : public Test {
+ protected:
+  void SetUp() override {
+    MockSystemCallWrapper::SetMockWrapper(&mock_system_call_wrapper_);
+    MockSocketProcessor::SetMockProcessor(&mock_socket_processor_);
+
+    // Default action for mocking functions.
+    ON_CALL(mock_system_call_wrapper_, Select(_, _, _, _, _))
+        .WillByDefault(Invoke(
+            []([[maybe_unused]] int nfds, [[maybe_unused]] fd_set* readfds,
+               [[maybe_unused]] fd_set* writefds,
+               [[maybe_unused]] fd_set* errorfds,
+               [[maybe_unused]] struct timeval* timeout) -> int {
+              std::this_thread::sleep_for(
+                  std::chrono::milliseconds(kSelectMockSleepTimeMs));
+              return 1;
+            }));
+
+    ON_CALL(mock_socket_processor_, GetServerSocket())
+        .WillByDefault(Return(kServerFd));
+
+    ON_CALL(mock_socket_processor_, OpenSocketFileMonitor())
+        .WillByDefault(Return(kSocketMonitorFd));
+
+    ON_CALL(mock_socket_processor_, GetClientSocket())
+        .WillByDefault(Return(kClientFd));
+
+    ON_CALL(mock_socket_processor_, GetSocketFileMonitor())
+        .WillByDefault(Return(kSocketMonitorFd));
+
+    TestInit();
+  }
+
+  void TearDown() override { TestCleanUp(); }
+
+  void TestInit() {
+    EXPECT_CALL(mock_socket_processor_, Initialize(_, _)).Times(1);
+    EXPECT_CALL(mock_socket_processor_, SetSocketMode(_)).Times(1);
+
+    thread_daemon_ = std::make_unique<ThreadDaemon>(
+        std::bind(&MockPacketHandler::HalPacketCallback, &mock_packet_handler_,
+                  std::placeholders::_1));
+  }
+
+  void TestCleanUp() {
+    SetUpDaemonStopExpectations();
+    EXPECT_CALL(mock_socket_processor_, Cleanup()).Times(1);
+
+    thread_daemon_ = nullptr;
+  }
+
+  void SetUpDaemonStartExpectations() {
+    EXPECT_CALL(mock_system_call_wrapper_, CreatePipe(_, _))
+        .Times(AtLeast(1))
+        .WillRepeatedly(
+            DoAll(Invoke([](int pipefd[2], [[maybe_unused]] int flags) -> void {
+                    pipefd[0] = kNotificationFd;
+                    pipefd[1] = kNotificationFd;
+                  }),
+                  Return(0)));
+
+    EXPECT_CALL(mock_socket_processor_, OpenServer())
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(true));
+  }
+
+  void SetUpDaemonStopExpectations() {
+    if (thread_daemon_->IsDaemonRunning()) {
+      // Main thread to notify daemon thread.
+      EXPECT_CALL(mock_system_call_wrapper_, Write(_, _, 1))
+          .Times(1)
+          .WillOnce(Return(1));
+
+      EXPECT_CALL(mock_system_call_wrapper_, Close(_)).Times(2);
+
+      // Simulate daemon is notified to stop.
+      EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kNotificationFd, _))
+          .Times(Between(0, 1))
+          .WillOnce(Return(1));
+
+      EXPECT_CALL(mock_socket_processor_, CloseClient()).Times(1);
+      EXPECT_CALL(mock_socket_processor_, CloseServer()).Times(1);
+      EXPECT_CALL(mock_socket_processor_, CloseSocketFileMonitor()).Times(1);
+    }
+  }
+
+  void SetUpClientConnectExpectations() {
+    // Simulate daemon thread receiving a client connect request.
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kNotificationFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kServerFd, _))
+        .WillOnce(Return(1))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kSocketMonitorFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kClientFd, _))
+        .WillRepeatedly(Return(0));
+  }
+
+  void SetupClientSignalReceptionExpectations() {
+    // Simulate receiving signal from client fd.
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kNotificationFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kServerFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kSocketMonitorFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kClientFd, _))
+        .WillOnce(Return(1))
+        .WillRepeatedly(Return(0));
+  }
+
+  void SetUpFileMonitorSignalReceptionExpectations() {
+    // Simulate receiving signal from file monitor fd.
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kNotificationFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kServerFd, _))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kSocketMonitorFd, _))
+        .WillOnce(Return(1))
+        .WillRepeatedly(Return(0));
+    EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kClientFd, _))
+        .WillRepeatedly(Return(0));
+  }
+
+  MockSocketProcessor mock_socket_processor_;
+  MockSystemCallWrapper mock_system_call_wrapper_;
+  MockPacketHandler mock_packet_handler_;
+  std::unique_ptr<ThreadDaemon> thread_daemon_;
+};
+
+TEST_F(ThreadDaemonTest, CheckDaemonReturnNotRunning) {
+  // Daemon should not run before Start() is called.
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, StartDaemonReturnSuccess) {
+  SetUpDaemonStartExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure the daemon thread reaches the blocking point.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kDaemonThreadInitWaitTimeMs));
+}
+
+TEST_F(ThreadDaemonTest, StartDaemonReturnFail) {
+  EXPECT_CALL(mock_system_call_wrapper_, CreatePipe(_, _))
+      .Times(1)
+      .WillOnce(Return(1));
+  EXPECT_CALL(mock_socket_processor_, OpenServer()).Times(0);
+
+  EXPECT_FALSE(thread_daemon_->Start());
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, StartDaemonTwiceReturnFail) {
+  SetUpDaemonStartExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure the daemon thread reaches the blocking point.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kDaemonThreadInitWaitTimeMs));
+
+  EXPECT_FALSE(thread_daemon_->Start());
+}
+
+TEST_F(ThreadDaemonTest, StopDaemonReturnSuccess) {
+  SetUpDaemonStartExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure the daemon thread reaches the blocking point.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kDaemonThreadInitWaitTimeMs));
+
+  SetUpDaemonStopExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Stop());
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, StopDaemonReturnFail) {
+  // Stop should fail if the daemon is not running.
+  EXPECT_FALSE(thread_daemon_->Stop());
+}
+
+TEST_F(ThreadDaemonTest, AcceptClientReturnSuccess) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  // Simulate successful client acceptance.
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure the daemon thread finishes the tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  SetUpDaemonStopExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Stop());
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, AcceptClientReturnAcceptFail) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  // Simulate client acceptance failure.
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kInvalidFileDescriptor));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(0);
+
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillRepeatedly(Return(kInvalidFileDescriptor));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure the daemon thread completes the tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  SetUpDaemonStopExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Stop());
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, AcceptClientReturnGetSocketFail) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  // Simulate client acceptance, then socket failure.
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+
+  // 1. kClientFd in PrepareFdsForMonitor() for a connected client.
+  // 2. kClientFd in AcceptClient() for the connected client.
+  // 3. Detect invalid state and clean up client, so it's
+  // kInvalidFileDescriptor.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kClientFd))
+      .WillOnce(Return(kClientFd))
+      .WillRepeatedly(Return(kInvalidFileDescriptor));
+
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(0);
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure the daemon thread completes the tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  SetUpDaemonStopExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Stop());
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, AcceptClientTwiceReturnFail) {
+  SetUpDaemonStartExpectations();
+
+  // Simulate daemon thread receiving two client connect requests.
+  EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kNotificationFd, _))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kServerFd, _))
+      .WillOnce(Return(1))
+      .WillOnce(Return(1))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kSocketMonitorFd, _))
+      .WillRepeatedly(Return(0));
+  EXPECT_CALL(mock_system_call_wrapper_, FdIsSet(kClientFd, _))
+      .WillRepeatedly(Return(0));
+
+  // Simulate accepting a client while one is already connected.
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(2)
+      .WillOnce(Return(kClientFd))
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Double the process time to account for two requests.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs) * 2);
+
+  SetUpDaemonStopExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Stop());
+  ASSERT_FALSE(thread_daemon_->IsDaemonRunning());
+}
+
+TEST_F(ThreadDaemonTest, ReceiveClientDisconnectSignal) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that, all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure daemon thread finishes the above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+
+  SetupClientSignalReceptionExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, Recv()).Times(1).WillOnce(Return(false));
+  EXPECT_CALL(mock_socket_processor_, CloseClient()).Times(1);
+
+  // Ensure daemon thread finishes the above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+}
+
+TEST_F(ThreadDaemonTest, ReceivePacketFromClientReturnSuccess) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that, all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Ensure daemon thread finishes the above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+
+  SetupClientSignalReceptionExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, Recv()).Times(1).WillOnce(Return(true));
+  EXPECT_CALL(mock_socket_processor_, CloseClient()).Times(0);
+
+  // Ensure daemon thread finishes the above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+}
+
+TEST_F(ThreadDaemonTest, SendUplinkWhenDaemonNotRunningReturnFail) {
+  EXPECT_CALL(mock_socket_processor_, Send(_)).Times(0);
+
+  std::vector<uint8_t> valid_hal_packet = {0x70, 0x00, 0x00, 0x05, 0x00,
+                                           0x00, 0x01, 0x02, 0x03, 0x04};
+  thread_daemon_->SendUplink(valid_hal_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendUplinkWhenNoClientConnectedReturnFail) {
+  SetUpDaemonStartExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread reaches blocking point.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kDaemonThreadInitWaitTimeMs));
+
+  EXPECT_CALL(mock_socket_processor_, Send(_)).Times(0);
+
+  std::vector<uint8_t> valid_hal_packet = {0x70, 0x00, 0x00, 0x05, 0x00,
+                                           0x00, 0x01, 0x02, 0x03, 0x04};
+  thread_daemon_->SendUplink(valid_hal_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendUplinkWithEmptyPacketReturnFail) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finishes above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  EXPECT_CALL(mock_socket_processor_, Send(_)).Times(0);
+
+  HalPacket empty_hal_packet;
+  thread_daemon_->SendUplink(empty_hal_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendUplinkWithInvalidHeaderSizeReturnFail) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finishes above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  std::vector<uint8_t> empty_packet;
+  EXPECT_CALL(mock_socket_processor_,
+              Send(MatcherFactory::CreateVectorMatcher(empty_packet)))
+      .Times(1);
+
+  std::vector<uint8_t> invalid_header_hal_packet = {0x00, 0x00, 0x05};
+  thread_daemon_->SendUplink(invalid_header_hal_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendUplinkWithInvalidPacketSizeReturnFail) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finishes above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  std::vector<uint8_t> empty_packet;
+  EXPECT_CALL(mock_socket_processor_,
+              Send(MatcherFactory::CreateVectorMatcher(empty_packet)))
+      .Times(1);
+
+  std::vector<uint8_t> invalid_packet_size_hal_packet = {
+      0x70, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x02, 0x03};
+  thread_daemon_->SendUplink(invalid_packet_size_hal_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendUplinkReturnSuccess) {
+  SetUpDaemonStartExpectations();
+  SetUpClientConnectExpectations();
+
+  EXPECT_CALL(mock_socket_processor_, AcceptClient())
+      .Times(1)
+      .WillOnce(Return(kClientFd));
+  EXPECT_CALL(mock_socket_processor_, SetClientSocket(kClientFd)).Times(1);
+
+  // 1. kInvalidFileDescriptor in PrepareFdsForMonitor() as no client connected.
+  // 2. kInvalidFileDescriptor in AcceptClient() for first connection.
+  // 3. After that all are kClientFd as one client is connected.
+  EXPECT_CALL(mock_socket_processor_, GetClientSocket())
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillOnce(Return(kInvalidFileDescriptor))
+      .WillRepeatedly(Return(kClientFd));
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finishes above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  std::vector<uint8_t> valid_spinel_packet = {0x00, 0x01, 0x02, 0x03, 0x04};
+  EXPECT_CALL(mock_socket_processor_,
+              Send(MatcherFactory::CreateVectorMatcher(valid_spinel_packet)))
+      .Times(1);
+
+  std::vector<uint8_t> valid_hal_packet = {0x70, 0x00, 0x00, 0x05, 0x00,
+                                           0x00, 0x01, 0x02, 0x03, 0x04};
+  thread_daemon_->SendUplink(valid_hal_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendDownlinkWithHardwareResetReturnCrash) {
+  SetUpDaemonStartExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread reach blocking point.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kDaemonThreadInitWaitTimeMs));
+
+  EXPECT_CALL(mock_socket_processor_, Cleanup()).Times(1);
+  EXPECT_CALL(mock_system_call_wrapper_, Kill(_, _)).Times(1);
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(0);
+
+  HalPacket valid_spinel_packet(
+      {kSpinelHeader, kThreadCommandReset, kThreadCommandResetHardware});
+  thread_daemon_->SendDownlink(valid_spinel_packet);
+}
+
+TEST_F(ThreadDaemonTest, SendDownlinkReturnSuccess) {
+  SetUpDaemonStartExpectations();
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread reach blocking point.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kDaemonThreadInitWaitTimeMs));
+
+  HalPacket valid_hal_packet(
+      {0x70, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04});
+  EXPECT_CALL(mock_packet_handler_,
+              HalPacketCallback(
+                  MatcherFactory::CreateHalPacketMatcher(valid_hal_packet)))
+      .Times(1);
+
+  std::vector<uint8_t> valid_spinel_packet = {0x00, 0x01, 0x02, 0x03, 0x04};
+  thread_daemon_->SendDownlink(valid_spinel_packet);
+}
+
+TEST_F(ThreadDaemonTest, ReceiveDeleteFileSignalButReadFail) {
+  SetUpDaemonStartExpectations();
+  SetUpFileMonitorSignalReceptionExpectations();
+
+  // Simulate read fail.
+  EXPECT_CALL(mock_system_call_wrapper_, Read(kSocketMonitorFd, _, _))
+      .Times(1)
+      .WillOnce(Return(0));
+  EXPECT_CALL(mock_socket_processor_, CloseSocketFileMonitor()).Times(0);
+  EXPECT_CALL(mock_socket_processor_, CloseClient()).Times(0);
+  EXPECT_CALL(mock_socket_processor_, CloseServer()).Times(0);
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finish above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+}
+
+TEST_F(ThreadDaemonTest, ReceiveDeleteFileSignalButNotSocketFile) {
+  SetUpDaemonStartExpectations();
+  SetUpFileMonitorSignalReceptionExpectations();
+
+  // Simulate socket file is deleted but not socket file.
+  EXPECT_CALL(mock_system_call_wrapper_, Read(kSocketMonitorFd, _, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t count) -> void {
+                        struct inotify_event* event =
+                            reinterpret_cast<struct inotify_event*>(buffer);
+                        event->mask |= IN_DELETE;
+                      }),
+                      Return(sizeof(struct inotify_event))));
+  EXPECT_CALL(mock_socket_processor_, IsSocketFileExisted())
+      .Times(1)
+      .WillOnce(Return(true));
+  EXPECT_CALL(mock_socket_processor_, CloseSocketFileMonitor()).Times(0);
+  EXPECT_CALL(mock_socket_processor_, CloseClient()).Times(0);
+  EXPECT_CALL(mock_socket_processor_, CloseServer()).Times(0);
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finish above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+}
+
+TEST_F(ThreadDaemonTest, ReceiveDeleteSocketFileSignalReturnDaemonRestart) {
+  SetUpDaemonStartExpectations();
+  SetUpFileMonitorSignalReceptionExpectations();
+
+  // Simulate socket file is deleted and daemon is restarted.
+  EXPECT_CALL(mock_system_call_wrapper_, Read(kSocketMonitorFd, _, _))
+      .WillOnce(DoAll(Invoke([]([[maybe_unused]] int fd, void* buffer,
+                                [[maybe_unused]] size_t count) -> void {
+                        struct inotify_event* event =
+                            reinterpret_cast<struct inotify_event*>(buffer);
+                        event->mask |= IN_DELETE;
+                      }),
+                      Return(sizeof(struct inotify_event))));
+  EXPECT_CALL(mock_socket_processor_, IsSocketFileExisted())
+      .Times(1)
+      .WillOnce(Return(false));
+  EXPECT_CALL(mock_socket_processor_, CloseSocketFileMonitor()).Times(2);
+  EXPECT_CALL(mock_socket_processor_, CloseClient()).Times(1);
+  EXPECT_CALL(mock_socket_processor_, CloseServer()).Times(1);
+
+  EXPECT_TRUE(thread_daemon_->Start());
+  ASSERT_TRUE(thread_daemon_->IsDaemonRunning());
+
+  // Make sure daemon thread finish above tasks.
+  std::this_thread::sleep_for(
+      std::chrono::milliseconds(kFullDaemonThreadSelectProcessWaitTimeMs));
+
+  Mock::VerifyAndClearExpectations(&mock_system_call_wrapper_);
+  Mock::VerifyAndClearExpectations(&mock_socket_processor_);
+}
+
+}  // namespace
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/thread/thread_handler.cc b/bluetooth/bluetooth_hal/extensions/thread/thread_handler.cc
new file mode 100644
index 0000000000..ee3e79cceb
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/thread/thread_handler.cc
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/thread/thread_handler.h"
+
+#include <memory>
+#include <mutex>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/extensions/thread/thread_daemon.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hci_monitor.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::hci::MonitorMode;
+using ::bluetooth_hal::thread::ThreadDaemon;
+
+std::mutex ThreadHandler::mutex_;
+std::unique_ptr<ThreadHandler> ThreadHandler::handler_ = nullptr;
+
+ThreadHandler::ThreadHandler() {
+  thread_daemon_ = std::make_unique<ThreadDaemon>(
+      [this](const ::bluetooth_hal::hci::HalPacket& packet) {
+        this->SendData(packet);
+      });
+  RegisterMonitor(thread_data_monitor_, MonitorMode::kIntercept);
+}
+
+ThreadHandler::~ThreadHandler() {
+  UnregisterMonitor(thread_data_monitor_);
+  thread_daemon_.reset();
+}
+
+void ThreadHandler::Initialize() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  if (!handler_) {
+    handler_ = std::make_unique<ThreadHandler>();
+  }
+}
+
+void ThreadHandler::Cleanup() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  if (!handler_) {
+    return;
+  }
+  handler_.reset();
+}
+
+bool ThreadHandler::IsHandlerRunning() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  return handler_ != nullptr;
+}
+
+ThreadHandler& ThreadHandler::GetHandler() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  if (!handler_) {
+    LOG(FATAL) << __func__ << ": handler == nullptr.";
+  }
+  return *handler_;
+}
+
+void ThreadHandler::OnCommandCallback(
+    [[maybe_unused]] const HalPacket& packet) {}
+
+void ThreadHandler::OnMonitorPacketCallback([[maybe_unused]] MonitorMode mode,
+                                            const HalPacket& packet) {
+  std::lock_guard<std::mutex> guard(mutex_);
+  if (packet.GetType() == HciPacketType::kThreadData && thread_daemon_) {
+    thread_daemon_->SendUplink(packet);
+  }
+}
+
+void ThreadHandler::OnBluetoothChipReady() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  if (thread_daemon_) {
+    thread_daemon_->Start();
+  }
+}
+
+void ThreadHandler::OnBluetoothChipClosed() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  if (thread_daemon_) {
+    thread_daemon_->Stop();
+  }
+}
+
+void ThreadHandler::OnBluetoothEnabled() {}
+
+void ThreadHandler::OnBluetoothDisabled() {}
+
+bool ThreadHandler::IsDaemonRunning() const {
+  if (thread_daemon_) {
+    return thread_daemon_->IsDaemonRunning();
+  }
+  return false;
+}
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/extensions/thread/thread_handler_test.cc b/bluetooth/bluetooth_hal/extensions/thread/thread_handler_test.cc
new file mode 100644
index 0000000000..68726c6022
--- /dev/null
+++ b/bluetooth/bluetooth_hal/extensions/thread/thread_handler_test.cc
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/extensions/thread/thread_handler.h"
+
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace thread {
+namespace {
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::hci::MockHciRouter;
+using ::bluetooth_hal::hci::MockHciRouterClientAgent;
+
+using ::testing::Test;
+
+class ThreadHandlerTest : public Test {
+ protected:
+  void SetUp() override {
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+  }
+
+  void TearDown() override { ThreadHandler::Cleanup(); }
+
+  MockHciRouter mock_hci_router_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+};
+
+TEST_F(ThreadHandlerTest, GetHandlerWithoutInitialization) {
+  EXPECT_DEATH(ThreadHandler::GetHandler(), "");
+}
+
+TEST_F(ThreadHandlerTest, HandleHandlerEnabled) {
+  ThreadHandler::Initialize();
+  EXPECT_TRUE(ThreadHandler::IsHandlerRunning());
+}
+
+TEST_F(ThreadHandlerTest, HandleHandlerDisabled) {
+  EXPECT_FALSE(ThreadHandler::IsHandlerRunning());
+}
+
+TEST_F(ThreadHandlerTest, HandleDaemonDisabledAfterBtChipClosed) {
+  ThreadHandler::Initialize();
+  EXPECT_FALSE(ThreadHandler::GetHandler().IsDaemonRunning());
+
+  ThreadHandler::GetHandler().OnBluetoothChipReady();
+  EXPECT_TRUE(ThreadHandler::GetHandler().IsDaemonRunning());
+
+  ThreadHandler::GetHandler().OnBluetoothChipClosed();
+  EXPECT_FALSE(ThreadHandler::GetHandler().IsDaemonRunning());
+}
+
+TEST_F(ThreadHandlerTest, IsSameHandler) {
+  ThreadHandler::Initialize();
+  EXPECT_EQ(&ThreadHandler::GetHandler(), &ThreadHandler::GetHandler());
+}
+
+}  // namespace
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hal_packet_test.cc b/bluetooth/bluetooth_hal/hal_packet_test.cc
new file mode 100644
index 0000000000..d1c86aa89d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hal_packet_test.cc
@@ -0,0 +1,370 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/hal_packet.h"
+
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace hci {
+namespace {
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+
+enum class TestEnumInt : int {
+  kTest = 0,
+  kOutOfBond = 99,
+};
+
+enum class TestEnumUint8 : uint8_t {
+  kTest = 0,
+  kOutOfBond = 99,
+};
+
+enum class TestEnumUint32 : uint32_t {
+  kTest = 0,
+  kOutOfBond = 99,
+};
+
+enum class TestEnumUint64 : uint64_t {
+  kTest = 0,
+  kOutOfBond = 99,
+};
+
+TEST(HalPacketTest, HandleAt) {
+  HalPacket packet({0x01, 0x02, 0x03, 0x04});
+  EXPECT_EQ(packet.At(0), 0x01);
+  EXPECT_EQ(packet.At(TestEnumInt::kTest), 0x01);
+  EXPECT_EQ(packet.At(TestEnumUint8::kTest), 0x01);
+  EXPECT_EQ(packet.At(TestEnumUint32::kTest), 0x01);
+  EXPECT_EQ(packet.At(TestEnumUint64::kTest), 0x01);
+
+  EXPECT_EQ(packet.At(99), 0);
+  EXPECT_EQ(packet.At(TestEnumInt::kOutOfBond), 0);
+  EXPECT_EQ(packet.At(TestEnumUint8::kOutOfBond), 0);
+  EXPECT_EQ(packet.At(TestEnumUint32::kOutOfBond), 0);
+  EXPECT_EQ(packet.At(TestEnumUint64::kOutOfBond), 0);
+}
+
+TEST(HalPacketTest, HandleAtUint16LittleEndian) {
+  HalPacket packet({0x01, 0x02, 0x03, 0x04});
+  EXPECT_EQ(packet.AtUint16LittleEndian(0), 0x0201);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumInt::kTest), 0x0201);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumUint8::kTest), 0x0201);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumUint32::kTest), 0x0201);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumUint64::kTest), 0x0201);
+
+  EXPECT_EQ(packet.AtUint16LittleEndian(99), 0);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumInt::kOutOfBond), 0);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumUint8::kOutOfBond), 0);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumUint32::kOutOfBond), 0);
+  EXPECT_EQ(packet.AtUint16LittleEndian(TestEnumUint64::kOutOfBond), 0);
+}
+
+TEST(HalPacketTest, HandleAtUint64LittleEndian) {
+  HalPacket packet({0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08});
+  EXPECT_EQ(packet.AtUint64LittleEndian(0), 0x0807060504030201);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumInt::kTest),
+            0x0807060504030201);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumUint8::kTest),
+            0x0807060504030201);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumUint32::kTest),
+            0x0807060504030201);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumUint64::kTest),
+            0x0807060504030201);
+
+  EXPECT_EQ(packet.AtUint64LittleEndian(99), 0);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumInt::kOutOfBond), 0);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumUint8::kOutOfBond), 0);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumUint32::kOutOfBond), 0);
+  EXPECT_EQ(packet.AtUint64LittleEndian(TestEnumUint64::kOutOfBond), 0);
+}
+
+TEST(HalPacketTest, HandleToString) {
+  HalPacket packet({0x01, 0x02, 0x03, 0x04});
+  std::string expected = "(4)[01 02 03 04]";
+  std::string actual = packet.ToString();
+  EXPECT_EQ(actual, expected);
+}
+
+TEST(HalPacketTest, HandleToStringEmpty) {
+  HalPacket packet;
+  std::string expected = "(0)[]";
+  std::string actual = packet.ToString();
+  EXPECT_EQ(actual, expected);
+}
+
+TEST(HalPacketTest, HandleConstructorWithType) {
+  // HCI Reset Command
+  uint8_t type = static_cast<uint8_t>(HciPacketType::kCommand);
+  std::vector<uint8_t> payload = {0x03, 0x0C, 0x00};
+
+  HalPacket packet(type, payload);
+
+  ASSERT_EQ(packet[0], type);
+  ASSERT_EQ(packet.size(), payload.size() + 1);
+  for (size_t i = 1; i < payload.size(); i++) {
+    ASSERT_EQ(packet[i + 1], payload[i]);
+  }
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kCommand);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0x0c03);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandlePacketInit) {
+  // Uninitialized packet
+  HalPacket packet;
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kUnknown);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleInvalidPacket) {
+  // Invalid packet with an unimplmeneted type 0xFF
+  HalPacket packet({0xFF, 0x00, 0x00, 0x01, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kUnknown);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleHciCommand) {
+  // HCI Reset Command
+  HalPacket packet({0x01, 0x03, 0x0c, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kCommand);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0x0c03);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleHciEvent) {
+  // Mode Change Event (event code = 0x14)
+  HalPacket packet({0x04, 0x14, 0x06, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kEvent);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0x14);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleHciCommandCompleteEvent) {
+  // HCI Reset Complete Event
+  HalPacket packet({0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kEvent);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0x0e);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_TRUE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kSuccess));
+  ASSERT_TRUE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0x0c03);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleHciCommandStatusEvent) {
+  // HCI Create Connection Status Event
+  HalPacket packet({0x04, 0x0f, 0x04, 0x00, 0x01, 0x05, 0x04});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kEvent);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0x0f);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_TRUE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kSuccess));
+  ASSERT_TRUE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0x0405);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleBleMetaEvent) {
+  // LE Connection Update Complete event (sub-event code = 0x03)
+  HalPacket packet({0x04, 0x3e, 0x0a, 0x03, 0x00, 0x40, 0x00, 0x00, 0x06, 0x00,
+                    0x00, 0x00, 0x0a});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kEvent);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0x3e);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_TRUE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0x03);
+}
+
+TEST(HalPacketTest, HandleAclData) {
+  // ACL data
+  HalPacket packet({0x02, 0x41, 0x00, 0x01, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kAclData);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleScoData) {
+  // SCO data
+  HalPacket packet({0x03, 0x41, 0x00, 0x01, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kScoData);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleIsoData) {
+  // ISO data
+  HalPacket packet({0x05, 0x41, 0x00, 0x01, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kIsoData);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleThreadData) {
+  // Thread data
+  HalPacket packet({0x70, 0x00, 0x00, 0x01, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kThreadData);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+TEST(HalPacketTest, HandleHdlcData) {
+  // HDLC data
+  HalPacket packet({0x7e, 0x00, 0x00, 0x01, 0x00});
+
+  ASSERT_EQ(packet.GetType(), HciPacketType::kHdlcData);
+  ASSERT_EQ(packet.GetCommandOpcode(), 0);
+  ASSERT_FALSE(packet.IsVendorCommand());
+  ASSERT_EQ(packet.GetEventCode(), 0);
+  ASSERT_FALSE(packet.IsVendorEvent());
+  ASSERT_FALSE(packet.IsCommandCompleteEvent());
+  ASSERT_FALSE(packet.IsCommandStatusEvent());
+  ASSERT_EQ(packet.GetCommandCompleteEventResult(),
+            static_cast<uint8_t>(EventResultCode::kFailure));
+  ASSERT_FALSE(packet.IsCommandCompleteStatusEvent());
+  ASSERT_EQ(packet.GetCommandOpcodeFromGeneratedEvent(), 0);
+  ASSERT_FALSE(packet.IsBleMetaEvent());
+  ASSERT_EQ(packet.GetBleSubEventCode(), 0);
+}
+
+}  // namespace
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_monitor_test.cc b/bluetooth/bluetooth_hal/hci_monitor_test.cc
new file mode 100644
index 0000000000..2943962d06
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_monitor_test.cc
@@ -0,0 +1,348 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/hci_monitor.h"
+
+#include <cstdint>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace hci {
+namespace {
+
+using ::bluetooth_hal::hci::HalPacket;
+
+class HciMonitorTest : public ::testing::Test {
+ protected:
+  void SetUp() override {}
+  void TearDown() override {}
+};
+
+TEST_F(HciMonitorTest, HciMonitorCommandEqual) {
+  // Command
+  uint16_t primary_code = 0x0c03;
+  HciMonitor monitor1(MonitorType::kCommand, primary_code);
+  HciMonitor monitor2(MonitorType::kCommand, primary_code);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciMonitorEventEqual) {
+  // Event
+  uint16_t primary_code = 0x02;
+  HciMonitor monitor1(MonitorType::kEvent, primary_code);
+  HciMonitor monitor2(MonitorType::kEvent, primary_code);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciMonitorTypeNotEqual) {
+  // Types not equal
+  uint16_t primary_code = 0x0c03;
+  HciMonitor monitor1(MonitorType::kCommand, primary_code);
+  HciMonitor monitor2(MonitorType::kEvent, primary_code);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciMonitorEventNotEqual) {
+  // primary_codes not equal
+  uint16_t code1 = 0x02;
+  uint16_t code2 = 0x03;
+  HciMonitor monitor1(MonitorType::kEvent, code1);
+  HciMonitor monitor2(MonitorType::kEvent, code2);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciMonitorCommandNotEqual) {
+  // Sub-codes not equal
+  uint16_t code1 = 0xfd2b;
+  uint16_t code2 = 0x1234;
+  HciMonitor monitor1(MonitorType::kCommand, code1);
+  HciMonitor monitor2(MonitorType::kCommand, code2);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketTypeNotEqual) {
+  // Type not equal
+  uint16_t primary_code = 0x0c03;
+  HciMonitor monitor(MonitorType::kEvent, primary_code);
+  HalPacket packet({0x01, 0x03, 0x0c, 0x00});
+  EXPECT_FALSE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketSubCodeNotEqual) {
+  // Sub-code not equal
+  uint16_t primary_code = 0xfd54;
+  uint16_t secondary_code = 0x02;  // should be 0x01
+  uint16_t offset = 4;
+  HciMonitor monitor(MonitorType::kCommand, primary_code);
+  monitor.MonitorOffset(secondary_code, offset);
+
+  // LE Multi ADV Command
+  HalPacket packet({0x01, 0x54, 0xfd, 0x18, 0x01, 0x90, 0x01, 0xc2, 0x01, 0x00,
+                    0x01, 0x9e, 0x46, 0x7e, 0x8f, 0x96, 0x66, 0x00, 0x00, 0x00,
+                    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x01, 0xf1});
+  EXPECT_FALSE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketPrimaryCodeNotEqual) {
+  // primary_code not equal
+  uint16_t primary_code = 0x15;  // should be 0x14
+  HciMonitor monitor(MonitorType::kEvent, primary_code);
+  HalPacket packet({0x04, 0x14, 0x06, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00});
+  EXPECT_FALSE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketOffsetNotEqual) {
+  // Offset not equal
+  uint16_t primary_code = 0x3e;
+  uint16_t secondary_code = 0x03;
+  uint16_t offset = 6;  // should be 3
+  HciMonitor monitor(MonitorType::kEvent, primary_code);
+  monitor.MonitorOffset(secondary_code, offset);
+
+  // LE Connection Update Complete event
+  HalPacket packet({0x04, 0x3e, 0x0a, 0x03, 0x00, 0x40, 0x00, 0x00, 0x06, 0x00,
+                    0x00, 0x00, 0x0a});
+  EXPECT_FALSE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketOverflowNotEqual) {
+  // Offset overflow
+  uint16_t primary_code = 0x3e;
+  uint16_t secondary_code = 0x03;
+  uint16_t offset = 999;  // should be 3
+  HciMonitor monitor(MonitorType::kEvent, primary_code);
+  monitor.MonitorOffset(secondary_code, offset);
+  // LE Connection Update Complete event
+  HalPacket packet({0x04, 0x3e, 0x0a, 0x03, 0x00, 0x40, 0x00, 0x00, 0x06, 0x00,
+                    0x00, 0x00, 0x0a});
+  EXPECT_FALSE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, HciEventMonitorWithEventCodeOnly) {
+  uint8_t event_code = 0xff;
+  HciEventMonitor monitor1(event_code);
+  HciEventMonitor monitor2(event_code);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciEventMonitorWithSubEventCode) {
+  // BLE Meta Event
+  uint8_t primary_code = 0x3e;
+  uint8_t secondary_code = 0x01;
+  int offset = 4;
+  HciEventMonitor monitor1(primary_code, secondary_code, offset);
+  HciEventMonitor monitor2(primary_code, secondary_code, offset);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciEventMonitorOffsetNotEqual) {
+  // Offsets not equal
+  uint8_t event_code = 0x12;
+  uint8_t sub_event_code = 0x34;
+  int offset1 = 5;
+  int offset2 = 6;
+  HciEventMonitor monitor1(event_code, sub_event_code, offset1);
+  HciEventMonitor monitor2(event_code, sub_event_code, offset2);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketEventEqual) {
+  // HCI Event
+  uint8_t event_code = 0x14;
+  HciEventMonitor monitor(event_code);
+  HalPacket packet({0x04, 0x14, 0x06, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00});
+  EXPECT_TRUE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketEventWithSubCodeEqual) {
+  // HCI Event with sub-code
+  uint8_t event_code = 0x3e;
+  uint8_t sub_event_code = 0x03;
+  int offset = 3;
+  HciEventMonitor monitor(event_code, sub_event_code, offset);
+  // LE Connection Update Complete event
+  HalPacket packet({0x04, 0x3e, 0x0a, 0x03, 0x00, 0x40, 0x00, 0x00, 0x06, 0x00,
+                    0x00, 0x00, 0x0a});
+  EXPECT_TRUE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, HciCommandMonitorWithOpcodeOnly) {
+  uint16_t opcode = 0xff;
+  HciCommandMonitor monitor1(opcode);
+  HciCommandMonitor monitor2(opcode);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciCommandMonitorWithSubOpcode) {
+  // Vendor Command
+  uint16_t primary_code = 0xfd2b;
+  uint8_t secondary_code = 0x01;
+  int offset = 5;
+  HciCommandMonitor monitor1(primary_code, secondary_code, offset);
+  HciCommandMonitor monitor2(primary_code, secondary_code, offset);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciCommandMonitorOffsetNotEqual) {
+  // Offsets not equal
+  uint16_t opcode = 0x1234;
+  uint8_t sub_opcode = 0x56;
+  int offset1 = 5;
+  int offset2 = 6;
+  HciCommandMonitor monitor1(opcode, sub_opcode, offset1);
+  HciCommandMonitor monitor2(opcode, sub_opcode, offset2);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketCommandEqual) {
+  // HCI Command
+  uint16_t opcode = 0x0c03;
+  HciCommandMonitor monitor(opcode);
+  HalPacket packet({0x01, 0x03, 0x0c, 0x00});
+  EXPECT_TRUE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketCommandWithSubCodeEqual) {
+  // HCI Command with sub-code
+  uint16_t opcode = 0xfd54;
+  uint8_t sub_opcode = 0x01;
+  int offset = 4;
+  HciCommandMonitor monitor(opcode, sub_opcode, offset);
+  // LE Multi ADV Command
+  HalPacket packet({0x01, 0x54, 0xfd, 0x18, 0x01, 0x90, 0x01, 0xc2, 0x01, 0x00,
+                    0x01, 0x9e, 0x46, 0x7e, 0x8f, 0x96, 0x66, 0x00, 0x00, 0x00,
+                    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x01, 0xf1});
+  EXPECT_TRUE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, HciBleMetaEventMonitorEqual) {
+  // LE Connection Update Complete event
+  uint8_t correct_ble_event = 0x03;
+  uint8_t incorrect_ble_event = 0x05;
+  HalPacket packet({0x04, 0x3e, 0x0a, 0x03, 0x00, 0x40, 0x00, 0x00, 0x06, 0x00,
+                    0x00, 0x00, 0x0a});
+
+  HciBleMetaEventMonitor monitor1(correct_ble_event);
+  HciBleMetaEventMonitor monitor2(incorrect_ble_event);
+
+  EXPECT_TRUE(monitor1 == monitor1);
+  EXPECT_TRUE(packet == monitor1);
+  EXPECT_FALSE(packet == monitor2);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciBqrEventMonitorEqual) {
+  // BQR root inflammation event
+  uint8_t root_inflammation_report_id = 0x05;
+  HalPacket correct_packet({0x04, 0xff, 0x04, 0x58, 0x05, 0x00, 0x01});
+  HalPacket incorrect_packet({0x01, 0x03, 0x0c, 0x00});
+
+  HciBqrEventMonitor monitor1;
+  HciBqrEventMonitor monitor2(root_inflammation_report_id);
+
+  EXPECT_TRUE(correct_packet == monitor1);
+  EXPECT_TRUE(correct_packet == monitor2);
+  EXPECT_FALSE(incorrect_packet == monitor1);
+  EXPECT_FALSE(incorrect_packet == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciCommandCompleteEventMonitorEqual) {
+  // HCI RESET command opcode
+  uint16_t opcode = 0x0c03;
+
+  // HCI RESET command complete event
+  HalPacket correct_packet({0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  HalPacket incorrect_packet({0x01, 0x03, 0x0c, 0x00});
+
+  HciCommandCompleteEventMonitor monitor(opcode);
+
+  EXPECT_TRUE(correct_packet == monitor);
+  EXPECT_FALSE(incorrect_packet == monitor);
+}
+
+TEST_F(HciMonitorTest, HciCommandStatusEventMonitorEqual) {
+  // HCI INQUIRY command opcode
+  uint16_t opcode = 0x0401;
+
+  // HCI INQUIRY command status event
+  HalPacket correct_packet({0x04, 0x0f, 0x04, 0x00, 0x01, 0x01, 0x04});
+  HalPacket incorrect_packet({0x01, 0x03, 0x0c, 0x00});
+
+  HciCommandStatusEventMonitor monitor(opcode);
+
+  EXPECT_TRUE(correct_packet == monitor);
+  EXPECT_FALSE(incorrect_packet == monitor);
+}
+
+TEST_F(HciMonitorTest, HciThreadMonitorEqual) {
+  // Default constructor.
+  HciThreadMonitor monitor1;
+  HciThreadMonitor monitor2;
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciThreadMonitorWithOffsetEqual) {
+  // Constructor with offset and data.
+  int offset = 2;
+  uint8_t data = 0xab;
+  HciThreadMonitor monitor1(offset, data);
+  HciThreadMonitor monitor2(offset, data);
+  EXPECT_TRUE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciThreadMonitorOffsetNotEqual) {
+  // Different offsets.
+  int offset1 = 2;
+  int offset2 = 3;
+  uint8_t data = 0xab;
+  HciThreadMonitor monitor1(offset1, data);
+  HciThreadMonitor monitor2(offset2, data);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, HciThreadMonitorDataNotEqual) {
+  // Different data at the same offset.
+  int offset = 2;
+  uint8_t data1 = 0xab;
+  uint8_t data2 = 0xcd;
+  HciThreadMonitor monitor1(offset, data1);
+  HciThreadMonitor monitor2(offset, data2);
+  EXPECT_FALSE(monitor1 == monitor2);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketThreadEqual) {
+  // Default thread monitor matches any thread packet.
+  HciThreadMonitor monitor;
+  HalPacket packet({0x70, 0x01, 0x02, 0x03});
+  EXPECT_TRUE(packet == monitor);
+}
+
+TEST_F(HciMonitorTest, BluetoothPacketThreadWithOffsetEqual) {
+  // Thread monitor with specific offset and data.
+  int offset = 2;
+  uint8_t data = 0xab;
+  HciThreadMonitor monitor(offset, data);
+  HalPacket packet({0x70, 0x01, 0xab, 0x03});
+  HalPacket wrong_data_packet({0x70, 0x01, 0xcd, 0x03});
+  EXPECT_TRUE(packet == monitor);
+  EXPECT_FALSE(wrong_data_packet == monitor);
+}
+
+}  // namespace
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_router.cc b/bluetooth/bluetooth_hal/hci_router.cc
new file mode 100644
index 0000000000..46a183e556
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_router.cc
@@ -0,0 +1,573 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.hci_router"
+
+#include "bluetooth_hal/hci_router.h"
+
+#include <stddef.h>
+
+#include <atomic>
+#include <functional>
+#include <future>
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+#include <unordered_set>
+
+#include "bluetooth_hal/chip/async_chip_provisioner.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/debug/vnd_snoop_logger.h"
+#include "bluetooth_hal/extensions/thread/thread_handler.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "bluetooth_hal/hci_router_client_agent.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "bluetooth_hal/util/power/wakelock.h"
+#include "bluetooth_hal/util/worker.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::chip::AsyncChipProvisioner;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::debug::VndSnoopLogger;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::thread::ThreadHandler;
+using ::bluetooth_hal::transport::TransportInterface;
+using ::bluetooth_hal::transport::TransportInterfaceCallback;
+using ::bluetooth_hal::util::power::ScopedWakelock;
+using ::bluetooth_hal::util::power::Wakelock;
+using ::bluetooth_hal::util::power::WakeSource;
+
+class TxTask {
+ public:
+  enum class TxTaskType : int {
+    kSendOrQueueCommand = 1,
+    kGetCommandCallback = 2,
+    kOnCommandCallbackCompleted = 3,
+    kSendToTransport = 4,
+  };
+
+  static TxTask SendOrQueueCommand(
+      HalPacket packet, const std::shared_ptr<HalPacketCallback> callback) {
+    return TxTask{TxTaskType::kSendOrQueueCommand, std::move(packet), callback,
+                  std::promise<std::shared_ptr<HalPacketCallback>>()};
+  }
+
+  static TxTask GetCommandCallback(
+      HalPacket packet,
+      std::promise<std::shared_ptr<HalPacketCallback>>&& promise) {
+    return TxTask{TxTaskType::kGetCommandCallback, std::move(packet), nullptr,
+                  std::move(promise)};
+  }
+
+  static TxTask OnCommandCallbackCompleted() {
+    return TxTask{TxTaskType::kOnCommandCallbackCompleted, HalPacket(), nullptr,
+                  std::promise<std::shared_ptr<HalPacketCallback>>()};
+  }
+
+  static TxTask SendToTransport(HalPacket packet) {
+    return TxTask{TxTaskType::kSendToTransport, std::move(packet), nullptr,
+                  std::promise<std::shared_ptr<HalPacketCallback>>()};
+  }
+
+  TxTaskType type;
+  HalPacket packet;
+  std::shared_ptr<HalPacketCallback> callback;
+  std::promise<std::shared_ptr<HalPacketCallback>>&& promise;
+
+ private:
+  TxTask(TxTaskType type, HalPacket&& packet,
+         std::shared_ptr<HalPacketCallback> callback,
+         std::promise<std::shared_ptr<HalPacketCallback>>&& promise)
+      : type(type),
+        packet(std::move(packet)),
+        callback(callback),
+        promise(std::move(promise)) {};
+};
+
+class TxHandler {
+ public:
+  TxHandler() {
+    tx_thread_ = std::make_unique<util::Worker<TxTask>>(
+        std::bind_front(&TxHandler::PacketDispatcher, this));
+  }
+
+  ~TxHandler() { SetBusy(false); }
+
+  void Post(TxTask task) { tx_thread_->Post(std::move(task)); }
+
+ private:
+  struct QueuedHciCommand {
+   public:
+    HalPacket command;
+    std::shared_ptr<HalPacketCallback> callback;
+  };
+
+  void PacketDispatcher(TxTask task) {
+    switch (task.type) {
+      case TxTask::TxTaskType::kSendOrQueueCommand:
+        SendOrQueueCommand(task.packet, task.callback);
+        break;
+      case TxTask::TxTaskType::kGetCommandCallback:
+        GetCommandCallback(task.packet, std::move(task.promise));
+        break;
+      case TxTask::TxTaskType::kOnCommandCallbackCompleted:
+        OnCommandCallbackCompleted();
+        break;
+      case TxTask::TxTaskType::kSendToTransport:
+        SendToTransport(task.packet);
+        break;
+      default:
+        LOG(ERROR) << "Unknown TxTask type: " << static_cast<int>(task.type);
+        break;
+    }
+  }
+
+  bool SendOrQueueCommand(const HalPacket& packet,
+                          const std::shared_ptr<HalPacketCallback> callback) {
+    bool is_queue_busy = !hci_cmd_queue_.empty();
+    hci_cmd_queue_.emplace(QueuedHciCommand(packet, callback));
+
+    if (is_queue_busy) {
+      // Queue the current command and wait for the previous command to be
+      // completed.
+      LOG(INFO) << "command queued: " << packet.ToString();
+      return true;
+    }
+
+    SetBusy(true);
+
+    SendToTransport(packet);
+    return true;
+  }
+
+  void GetCommandCallback(
+      const HalPacket& event,
+      std::promise<std::shared_ptr<HalPacketCallback>>&& promise) {
+    uint16_t opcode = event.GetCommandOpcodeFromGeneratedEvent();
+    if (hci_cmd_queue_.empty() ||
+        hci_cmd_queue_.front().command.GetCommandOpcode() != opcode) {
+      // TODO: b/387255243 - Check if this error requires an abort().
+      LOG(ERROR)
+          << "Unexpected command complete or command status event! opcode="
+          << opcode;
+      promise.set_value(nullptr);
+      return;
+    }
+    std::shared_ptr<HalPacketCallback> callback =
+        hci_cmd_queue_.front().callback;
+    promise.set_value(callback);
+  }
+
+  void OnCommandCallbackCompleted() {
+    if (hci_cmd_queue_.empty()) {
+      LOG(ERROR) << "Unexpected callback completed! "
+                 << "No command callback found in queue.";
+      return;
+    }
+    hci_cmd_queue_.pop();
+
+    bool has_queued_command = !hci_cmd_queue_.empty();
+    SetBusy(has_queued_command);
+    if (has_queued_command) {
+      HalPacket queued_command = hci_cmd_queue_.front().command;
+      SendToTransport(queued_command);
+    }
+  }
+
+  bool SendToTransport(const HalPacket& packet) {
+    ScopedWakelock wakelock(WakeSource::kTx);
+    if (!TransportInterface::GetTransport().IsTransportActive()) {
+      LOG(ERROR) << "Transport not active! packet: " << packet.ToString();
+      return false;
+    }
+
+    VndSnoopLogger::GetLogger().Capture(packet,
+                                        VndSnoopLogger::Direction::kOutgoing);
+
+    return TransportInterface::GetTransport().Send(packet);
+  }
+
+  void SetBusy(bool busy) {
+    if (busy) {
+      Wakelock::GetWakelock().Acquire(WakeSource::kHciBusy);
+    } else {
+      Wakelock::GetWakelock().Release(WakeSource::kHciBusy);
+    }
+
+    is_busy_ = busy;
+    TransportInterface::GetTransport().SetHciRouterBusy(busy);
+  }
+
+  std::queue<QueuedHciCommand> hci_cmd_queue_;
+  std::unique_ptr<util::Worker<TxTask>> tx_thread_;
+  std::atomic<bool> is_busy_;
+};
+
+class HciRouterImpl : virtual public HciRouter,
+                      virtual public TransportInterfaceCallback {
+ public:
+  HciRouterImpl();
+  bool Initialize(const std::shared_ptr<HciRouterCallback>& callback) override;
+  void Cleanup() override;
+  bool Send(const HalPacket& packet) override;
+  bool SendCommand(const HalPacket& packet,
+                   const HalPacketCallback& callback) override;
+  bool SendCommandNoAck(const HalPacket& packet) override;
+  HalState GetHalState() override;
+  void UpdateHalState(HalState state) override;
+  void SendPacketToStack(const HalPacket& packet) override;
+
+  void OnTransportClosed() override;
+  void OnTransportPacketReady(const HalPacket& packet) override;
+
+ protected:
+  bool InitializeModules();
+  bool SendToTransport(const HalPacket& packet);
+  void HandleCommandCompleteOrCommandStatusEvent(const HalPacket& event);
+  bool InitializeTransport();
+  bool IsHalStateValid(HalState new_state);
+  void HandleReceivedPacket(const HalPacket& packet);
+
+  // callback for the stack.
+  std::shared_ptr<HciRouterCallback> hci_callback_;
+  HalState hal_state_ = HalState::kShutdown;
+  std::unique_ptr<TxHandler> tx_handler_;
+  std::recursive_mutex mutex_;
+
+  static const std::unordered_map<HalState, std::unordered_set<HalState>>
+      kHalStateMachine;
+};
+
+/*
+ * kHalStateMachine contains the sequence of the HciRouter state machine.
+ * The Shutdown state, BtChipReady state and Running state are static states.
+ * The state machine stays in the Shutdown state if the Bluetooth chip is
+ * powered off. The state machine stays in the BtChipReady state if the
+ * controller is fully ready, including Bluetooth is off when the "Accelerate BT
+ * ON" feature is enabled. The state machine stays in the Running state after
+ * the Bluetooth stack sends the first HCI_RESET command, indicating the
+ * Bluetooth process is ready.
+ *
+ * All states can switch to the Shutdown state for error handling.
+ *
+ *                         
+ *                            v
+ *           kShutdown <
+ *                         ^                                    
+ *          v                                                   
+ *        kInit              kBtChipReady <> kRunning
+ *                                           ^
+ *          v                                 
+ *  kFirmwareDownloading kFirmwareReady
+ *                                           ^
+ *                                           
+ *          > kFirmwareDownloadCompleted 
+ *
+ * Format of the map: {CurrentState, {ValidNextState1, ValidNextState2, ...}}
+ */
+const std::unordered_map<HalState, std::unordered_set<HalState>>
+    HciRouterImpl::kHalStateMachine = {
+        {HalState::kShutdown, {HalState::kShutdown, HalState::kInit}},
+        {HalState::kInit,
+         {HalState::kShutdown, HalState::kFirmwareDownloading}},
+        {HalState::kFirmwareDownloading,
+         {HalState::kShutdown, HalState::kFirmwareDownloadCompleted}},
+        {HalState::kFirmwareDownloadCompleted,
+         {HalState::kShutdown, HalState::kFirmwareReady}},
+        {HalState::kFirmwareReady,
+         {HalState::kShutdown, HalState::kBtChipReady}},
+        {HalState::kBtChipReady,
+         {HalState::kShutdown, HalState::kBtChipReady, HalState::kRunning}},
+        {HalState::kRunning, {HalState::kShutdown, HalState::kBtChipReady}},
+};
+
+HciRouterImpl::HciRouterImpl() {
+  if (HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported()) {
+    // Power ON Bluetooth chip and download firmware if Accelerated BT ON
+    // feature is supported.
+    LOG(INFO) << "Powering ON Bluetooth chip for Accelerated BT ON.";
+    InitializeModules();
+  }
+}
+
+bool HciRouterImpl::Initialize(
+    const std::shared_ptr<HciRouterCallback>& callback) {
+  DURATION_TRACKER(AnchorType::BTHAL_PERFORM_INIT, __func__);
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  LOG(INFO) << "Initializing Bluetooth HCI Router.";
+  hci_callback_ = callback;
+  return InitializeModules();
+}
+
+bool HciRouterImpl::InitializeModules() {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  switch (hal_state_) {
+    case HalState::kRunning:
+      LOG(WARNING) << "HciRouter has already initialized!";
+      return false;
+    case HalState::kShutdown:
+      // Exit from the switch-case and continue the initialization process.
+      break;
+    case HalState::kBtChipReady:
+      if (HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported()) {
+#ifndef UNIT_TEST
+        AsyncChipProvisioner::GetProvisioner().PostResetFirmware();
+#endif
+        return true;
+      }
+      [[fallthrough]];
+    default:
+      LOG(WARNING) << "HciRouter is initializing!";
+      return true;
+  }
+
+  UpdateHalState(HalState::kInit);
+
+  // Initialize TX Handler to process TX packets.
+  tx_handler_ = std::make_unique<TxHandler>();
+
+  // Initialize transport.
+  if (!InitializeTransport()) {
+    LOG(ERROR) << "Failed to initialize transport!";
+    Cleanup();
+    return false;
+  }
+
+  LOG(INFO) << "Start downloading Bluetooth firmware.";
+#ifndef UNIT_TEST
+  AsyncChipProvisioner::GetProvisioner().PostInitialize(
+      std::bind_front(&HciRouterImpl::UpdateHalState, this));
+  AsyncChipProvisioner::GetProvisioner().PostDownloadFirmware();
+#endif
+
+  return true;
+}
+
+void HciRouterImpl::Cleanup() {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  if (hal_state_ == HalState::kRunning &&
+      HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported()) {
+    // Keep the Bluetooth chip powered on and only reset firmware if the
+    // Accelerated BT On feature is supported.
+#ifndef UNIT_TEST
+    AsyncChipProvisioner::GetProvisioner().PostResetFirmware();
+#endif
+    return;
+  }
+
+  if (tx_handler_) {
+    tx_handler_.reset();
+  }
+
+  // Cleanup Thread manager.
+  if (ThreadHandler::IsHandlerRunning()) {
+    ThreadHandler::Cleanup();
+  }
+
+  // Cleanup transport.
+  if (TransportInterface::GetTransport().IsTransportActive()) {
+    TransportInterface::GetTransport().Cleanup();
+  }
+
+  // Set HAL state back to the default state (kShutdown).
+  UpdateHalState(HalState::kShutdown);
+  hci_callback_ = nullptr;
+}
+
+bool HciRouterImpl::Send(const HalPacket& packet) {
+  if (packet.GetType() == HciPacketType::kCommand) {
+    // HCI commands require separate handling to manage command flow control.
+    // The events for the commands sent over Send() will be received by the
+    // stack through hci_callback_.
+    return SendCommand(
+        packet,
+        std::bind_front(&HciRouterCallback::OnCommandCallback, hci_callback_));
+  }
+  tx_handler_->Post(TxTask::SendToTransport(packet));
+  return true;
+}
+
+bool HciRouterImpl::SendCommand(const HalPacket& packet,
+                                const HalPacketCallback& callback) {
+  tx_handler_->Post(TxTask::SendOrQueueCommand(
+      packet, std::make_shared<HalPacketCallback>(callback)));
+  return true;
+}
+
+bool HciRouterImpl::SendCommandNoAck(const HalPacket& packet) {
+  tx_handler_->Post(TxTask::SendToTransport(packet));
+  return true;
+}
+
+HalState HciRouterImpl::GetHalState() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  return hal_state_;
+}
+
+void HciRouterImpl::SendPacketToStack(const HalPacket& packet) {
+  HandleReceivedPacket(packet);
+}
+
+bool HciRouterImpl::InitializeTransport() {
+  LOG(INFO) << "Initializing Bluetooth transport.";
+  return TransportInterface::GetTransport().Initialize(this);
+}
+
+void HciRouterImpl::UpdateHalState(HalState state) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  LOG(INFO) << "Bluetooth HAL state changed: " << static_cast<int>(hal_state_)
+            << " -> " << static_cast<int>(state);
+  if (!IsHalStateValid(state)) {
+    LOG(FATAL) << "Invalid Bluetooth HAL state changed! "
+               << static_cast<int>(hal_state_) << " -> "
+               << static_cast<int>(state);
+  }
+  HalState old_state = hal_state_;
+  hal_state_ = state;
+
+  std::shared_ptr<void> defer_task;
+
+  switch (state) {
+    case HalState::kShutdown:
+      VndSnoopLogger::GetLogger().StopRecording();
+      break;
+    case HalState::kInit:
+      // New recording for BT OFF.
+      VndSnoopLogger::GetLogger().StartNewRecording();
+      break;
+    case HalState::kFirmwareDownloading:
+    case HalState::kFirmwareDownloadCompleted:
+    case HalState::kFirmwareReady:
+      break;
+    case HalState::kBtChipReady:
+      if (HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported()) {
+        if (old_state == HalState::kRunning) {
+          // Bluetooth turned OFF with Accelerated BT ON enabled.
+          // New recording for BT OFF.
+          VndSnoopLogger::GetLogger().StartNewRecording();
+        } else if (old_state == HalState::kFirmwareReady) {
+          if (HalConfigLoader::GetLoader().IsThreadDispatcherEnabled()) {
+            LOG(INFO) << "Initialize Thread handler.";
+            ThreadHandler::Initialize();
+          }
+        }
+      }
+      if (old_state == HalState::kFirmwareReady && hci_callback_ != nullptr) {
+        // Once HAL changes to chip ready, it will automatically update to the
+        // running state if the stack had called Initialize.
+        defer_task = std::shared_ptr<void>(
+            nullptr, [this](void*) { UpdateHalState(HalState::kRunning); });
+      }
+      break;
+    case HalState::kRunning:
+      VndSnoopLogger::GetLogger().StartNewRecording();
+      if (HalConfigLoader::GetLoader().IsThreadDispatcherEnabled() &&
+          !HalConfigLoader::GetLoader().IsAcceleratedBtOnSupported()) {
+        LOG(INFO) << "Initialize Thread handler.";
+        ThreadHandler::Initialize();
+      }
+      break;
+    default:
+      break;
+  }
+
+  // The Bluetooth stack needs to be the first to know about the state change to
+  // avoid edge cases.
+  if (hci_callback_ != nullptr) {
+    hci_callback_->OnHalStateChanged(state, old_state);
+  }
+  HciRouterClientAgent::GetAgent().NotifyHalStateChange(state, old_state);
+
+  TransportInterface::GetTransport().NotifyHalStateChange(state);
+}
+
+bool HciRouterImpl::IsHalStateValid(HalState new_state) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  return kHalStateMachine.at(hal_state_).count(new_state) > 0;
+}
+
+void HciRouterImpl::HandleReceivedPacket(const HalPacket& packet) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  if (packet.IsCommandCompleteStatusEvent()) {
+    HandleCommandCompleteOrCommandStatusEvent(packet);
+    return;
+  }
+  if (HciRouterClientAgent::GetAgent().DispatchPacketToClients(packet) !=
+          MonitorMode::kIntercept &&
+      hci_callback_ != nullptr) {
+    hci_callback_->OnPacketCallback(packet);
+  }
+}
+
+void HciRouterImpl::HandleCommandCompleteOrCommandStatusEvent(
+    const HalPacket& event) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  uint16_t opcode = event.GetCommandOpcodeFromGeneratedEvent();
+
+  std::promise<std::shared_ptr<HalPacketCallback>> promise;
+  std::future<std::shared_ptr<HalPacketCallback>> future = promise.get_future();
+  tx_handler_->Post(TxTask::GetCommandCallback(event, std::move(promise)));
+
+  std::shared_ptr<HalPacketCallback> callback = future.get();
+  if (callback == nullptr || (*callback) == nullptr) {
+    LOG(ERROR) << "Command callback is null!";
+    if (hci_callback_ != nullptr) {
+      hci_callback_->OnPacketCallback(event);
+    }
+    return;
+  }
+
+  if (HciRouterClientAgent::GetAgent().DispatchPacketToClients(event) !=
+      MonitorMode::kIntercept) {
+    (*callback)(event);
+  }
+
+  tx_handler_->Post(TxTask::OnCommandCallbackCompleted());
+}
+
+void HciRouterImpl::OnTransportPacketReady(const HalPacket& packet) {
+  ScopedWakelock wakelock(WakeSource::kRx);
+
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  if (hal_state_ == HalState::kShutdown) {
+    LOG(WARNING) << __func__ << ": Hal is not ready to receive packets.";
+    return;
+  }
+
+  VndSnoopLogger::GetLogger().Capture(packet,
+                                      VndSnoopLogger::Direction::kIncoming);
+
+  HandleReceivedPacket(packet);
+}
+
+void HciRouterImpl::OnTransportClosed() {
+  LOG(INFO) << __func__ << ": Current transport is closed.";
+}
+
+HciRouter& HciRouter::GetRouter() {
+  static HciRouterImpl router;
+  return router;
+}
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_router_client.cc b/bluetooth/bluetooth_hal/hci_router_client.cc
new file mode 100644
index 0000000000..a8c002bf38
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_router_client.cc
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.router_client"
+
+#include "bluetooth_hal/hci_router_client.h"
+
+#include <algorithm>
+#include <functional>
+#include <map>
+#include <mutex>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router.h"
+#include "bluetooth_hal/hci_router_client_agent.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+using ::bluetooth_hal::HalState;
+
+HciRouterClient::HciRouterClient() {
+  HciRouterClientAgent::GetAgent().RegisterRouterClient(this);
+}
+
+HciRouterClient::~HciRouterClient() {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  monitors_.clear();
+  HciRouterClientAgent::GetAgent().UnregisterRouterClient(this);
+}
+
+MonitorMode HciRouterClient::OnPacketCallback(const HalPacket& packet) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  // Find the mode with the highest priority.
+  MonitorMode mode = MonitorMode::kNone;
+  for (const auto& it : monitors_) {
+    if (it.first == packet) {
+      mode = (it.second > mode) ? it.second : mode;
+    }
+  }
+
+  if (mode != MonitorMode::kNone) {
+    OnMonitorPacketCallback(mode, packet);
+  }
+  return mode;
+}
+
+bool HciRouterClient::IsBluetoothChipReady() {
+  return HciRouterClientAgent::GetAgent().IsBluetoothChipReady();
+}
+
+bool HciRouterClient::IsBluetoothEnabled() {
+  return HciRouterClientAgent::GetAgent().IsBluetoothEnabled();
+}
+
+bool HciRouterClient::RegisterMonitor(const HciMonitor& monitor,
+                                      MonitorMode mode) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  if (mode == MonitorMode::kNone) {
+    LOG(ERROR) << __func__ << ": Monitor mode cannot be kNone!";
+    return false;
+  }
+  auto it = std::find_if(
+      monitors_.begin(), monitors_.end(),
+      [&monitor](const auto& entry) { return entry.first == monitor; });
+  if (it != monitors_.end()) {
+    LOG(ERROR) << __func__ << ": The same monitor already exist!";
+    return false;
+  }
+  monitors_.insert({monitor, mode});
+  return true;
+}
+
+bool HciRouterClient::UnregisterMonitor(const HciMonitor& monitor) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  auto it = std::find_if(
+      monitors_.begin(), monitors_.end(),
+      [&monitor](const auto& entry) { return entry.first == monitor; });
+  if (it == monitors_.end()) {
+    LOG(ERROR) << __func__ << ": Monitor not registered!";
+    return false;
+  }
+  monitors_.erase(it);
+  return true;
+}
+
+bool HciRouterClient::SendCommand(const HalPacket& packet) {
+  if (packet.GetType() != HciPacketType::kCommand) {
+    return false;
+  }
+  return HciRouter::GetRouter().SendCommand(
+      packet, std::bind_front(&HciRouterClient::OnCommandCallback, this));
+}
+
+bool HciRouterClient::SendData(const HalPacket& packet) {
+  if (packet.GetType() == HciPacketType::kCommand) {
+    return false;
+  }
+  return HciRouter::GetRouter().Send(packet);
+}
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_router_client_agent.cc b/bluetooth/bluetooth_hal/hci_router_client_agent.cc
new file mode 100644
index 0000000000..2dd06fa724
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_router_client_agent.cc
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.router_client_agent"
+
+#include "bluetooth_hal/hci_router_client_agent.h"
+
+#include <mutex>
+#include <unordered_set>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HciRouterClientAgentImpl : public HciRouterClientAgent {
+ public:
+  HciRouterClientAgentImpl()
+      : current_state_(HalState::kShutdown),
+        is_bluetooth_chip_ready_(false),
+        is_bluetooth_enabled_(false) {};
+  bool RegisterRouterClient(HciRouterClientCallback* callback) override;
+  bool UnregisterRouterClient(HciRouterClientCallback* callback) override;
+  MonitorMode DispatchPacketToClients(const HalPacket& packet) override;
+  void NotifyHalStateChange(HalState new_state, HalState old_state) override;
+  bool IsBluetoothEnabled() override;
+  bool IsBluetoothChipReady() override;
+
+ private:
+  void HandleBluetoothEnable(const HalPacket& packet);
+  void NotifyClientsBluetoothDisabled();
+  void NotifyClientsBluetoothEnabled();
+  void NotifyClientsBluetoothChipClosed();
+  void NotifyClientsBluetoothChipReady();
+
+  std::recursive_mutex mutex_;
+  HalState current_state_;
+  bool is_bluetooth_chip_ready_;
+  bool is_bluetooth_enabled_;
+  std::unordered_set<HciRouterClientCallback*> router_clients_;
+};
+
+HciRouterClientAgent& HciRouterClientAgent::GetAgent() {
+  static HciRouterClientAgentImpl agent;
+  return agent;
+}
+
+bool HciRouterClientAgentImpl::RegisterRouterClient(
+    HciRouterClientCallback* client) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (router_clients_.count(client) > 0) {
+    LOG(WARNING) << "callback already registered!";
+    return false;
+  }
+  router_clients_.insert(client);
+
+  if (IsBluetoothChipReady()) {
+    client->OnBluetoothChipReady();
+  }
+  if (IsBluetoothEnabled()) {
+    client->OnBluetoothEnabled();
+  }
+  return true;
+}
+
+bool HciRouterClientAgentImpl::UnregisterRouterClient(
+    HciRouterClientCallback* callback) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (router_clients_.erase(callback) == 0) {
+    LOG(WARNING) << "callback was not registered!";
+    return false;
+  }
+  return true;
+}
+
+MonitorMode HciRouterClientAgentImpl::DispatchPacketToClients(
+    const HalPacket& packet) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (!IsBluetoothEnabled()) {
+    // Look for HCI_RESET complete event if Bluetooth is not enabled.
+    HandleBluetoothEnable(packet);
+  }
+
+  MonitorMode result = MonitorMode::kNone;
+  for (auto client : router_clients_) {
+    if (client == nullptr) {
+      LOG(WARNING) << "null router client callback in the registration list!";
+      continue;
+    }
+    MonitorMode mode = client->OnPacketCallback(packet);
+    result = (mode > result) ? mode : result;
+  }
+  return result;
+}
+
+void HciRouterClientAgentImpl::NotifyHalStateChange(HalState new_state,
+                                                    HalState old_state) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+
+#ifndef UNIT_TEST
+  if (current_state_ > old_state) {
+    LOG(FATAL) << __func__
+               << " (old_state, current_state_in_client) is mismatched! "
+                  "[ old_state("
+               << static_cast<int>(old_state) << ") -> new_state("
+               << static_cast<int>(new_state)
+               << ") ], current_state_in_client: "
+               << static_cast<int>(current_state_);
+    return;
+  }
+#endif
+
+  current_state_ = new_state;
+
+  switch (new_state) {
+    case HalState::kBtChipReady:
+      if (!is_bluetooth_chip_ready_) {
+        NotifyClientsBluetoothChipReady();
+      }
+      if (is_bluetooth_enabled_) {
+        NotifyClientsBluetoothDisabled();
+      }
+      is_bluetooth_chip_ready_ = true;
+      is_bluetooth_enabled_ = false;
+      break;
+    case HalState::kRunning:
+      if (!is_bluetooth_chip_ready_) {
+        NotifyClientsBluetoothChipReady();
+      }
+      // We do not handle is_bluetooth_enabled_ here because the clients have to
+      // wait for a HCI_RESET before they can send packets to the chip.
+      is_bluetooth_chip_ready_ = true;
+      break;
+    default:
+      if (is_bluetooth_chip_ready_) {
+        NotifyClientsBluetoothChipClosed();
+      }
+      if (is_bluetooth_enabled_) {
+        NotifyClientsBluetoothDisabled();
+      }
+      is_bluetooth_chip_ready_ = false;
+      is_bluetooth_enabled_ = false;
+      break;
+  }
+
+  for (auto client : router_clients_) {
+    if (client == nullptr) {
+      LOG(WARNING) << __func__
+                   << ": null router client callback in the registration list!";
+      continue;
+    }
+    client->OnHalStateChanged(new_state, old_state);
+  }
+}
+
+bool HciRouterClientAgentImpl::IsBluetoothEnabled() {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  return is_bluetooth_enabled_;
+}
+
+bool HciRouterClientAgentImpl::IsBluetoothChipReady() {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  return is_bluetooth_chip_ready_;
+}
+
+void HciRouterClientAgentImpl::HandleBluetoothEnable(const HalPacket& packet) {
+  if (current_state_ == HalState::kRunning &&
+      packet.GetCommandOpcodeFromGeneratedEvent() ==
+          static_cast<uint16_t>(CommandOpCode::kHciReset) &&
+      packet.GetCommandCompleteEventResult() ==
+          static_cast<uint8_t>(EventResultCode::kSuccess)) {
+    // Inform the client that Bluetooth has enabled after a HCI_RESET command is
+    // sent in kRunning state.
+    is_bluetooth_enabled_ = true;
+    NotifyClientsBluetoothEnabled();
+  }
+}
+
+void HciRouterClientAgentImpl::NotifyClientsBluetoothDisabled() {
+  for (auto client : router_clients_) {
+    if (client == nullptr) {
+      LOG(WARNING) << __func__
+                   << ": null router client callback in the registration list!";
+      continue;
+    }
+    client->OnBluetoothDisabled();
+  }
+}
+
+void HciRouterClientAgentImpl::NotifyClientsBluetoothEnabled() {
+  for (auto client : router_clients_) {
+    if (client == nullptr) {
+      LOG(WARNING) << __func__
+                   << ": null router client callback in the registration list!";
+      continue;
+    }
+    client->OnBluetoothEnabled();
+  }
+}
+
+void HciRouterClientAgentImpl::NotifyClientsBluetoothChipClosed() {
+  for (auto client : router_clients_) {
+    if (client == nullptr) {
+      LOG(WARNING) << __func__
+                   << ": null router client callback in the registration list!";
+      continue;
+    }
+    client->OnBluetoothChipClosed();
+  }
+}
+
+void HciRouterClientAgentImpl::NotifyClientsBluetoothChipReady() {
+  for (auto client : router_clients_) {
+    if (client == nullptr) {
+      LOG(WARNING) << __func__
+                   << ": null router client callback in the registration list!";
+      continue;
+    }
+    client->OnBluetoothChipReady();
+  }
+}
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_router_client_agent_test.cc b/bluetooth/bluetooth_hal/hci_router_client_agent_test.cc
new file mode 100644
index 0000000000..b77e6f0cf2
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_router_client_agent_test.cc
@@ -0,0 +1,348 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/hci_router_client_agent.h"
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_client_callback.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace hci {
+namespace {
+
+using ::testing::Return;
+using ::testing::Test;
+
+class MockHciRouterClient : public HciRouterClientCallback {
+ public:
+  MOCK_METHOD(void, OnCommandCallback, (const HalPacket& packet), (override));
+  MOCK_METHOD(MonitorMode, OnPacketCallback, (const HalPacket& packet),
+              (override));
+  MOCK_METHOD(void, OnHalStateChanged, (HalState new_state, HalState old_state),
+              (override));
+  MOCK_METHOD(void, OnBluetoothChipReady, (), (override));
+  MOCK_METHOD(void, OnBluetoothChipClosed, (), (override));
+  MOCK_METHOD(void, OnBluetoothEnabled, (), (override));
+  MOCK_METHOD(void, OnBluetoothDisabled, (), (override));
+};
+
+class HciRouterClientAgentTest : public Test {
+ protected:
+  static void SetUpTestSuite() {}
+
+  void SetUp() override {
+    agent_ = &HciRouterClientAgent::GetAgent();
+    ShutdownBluetooth();
+    EXPECT_FALSE(agent_->IsBluetoothEnabled());
+    EXPECT_FALSE(agent_->IsBluetoothChipReady());
+  }
+
+  void TearDown() override { agent_ = nullptr; }
+
+  void ShutdownBluetooth() {
+    agent_->NotifyHalStateChange(HalState::kInit, HalState::kShutdown);
+  }
+
+  void PowerOnBluetooth() {
+    agent_->NotifyHalStateChange(HalState::kBtChipReady,
+                                 HalState::kFirmwareReady);
+  }
+
+  void EnableBluetooth() {
+    HalPacket reset_packet({0x04, 0x0E, 0x04, 0x01, 0x03, 0x0C, 0x00});
+    agent_->NotifyHalStateChange(HalState::kRunning, HalState::kBtChipReady);
+    ASSERT_EQ(agent_->DispatchPacketToClients(reset_packet),
+              MonitorMode::kNone);
+  }
+
+  void DisableBluetooth() {
+    agent_->NotifyHalStateChange(HalState::kBtChipReady, HalState::kRunning);
+  }
+
+  HciRouterClientAgent* agent_;
+};
+
+TEST_F(HciRouterClientAgentTest, HandleDispatchPacketToClients) {
+  MonitorMode expected_mode = MonitorMode::kMonitor;
+  HalPacket packet({0x01, 0x02, 0x03, 0x04});
+  MockHciRouterClient mock_router_client;
+
+  ON_CALL(mock_router_client, OnPacketCallback(packet))
+      .WillByDefault(Return(expected_mode));
+  EXPECT_CALL(mock_router_client, OnPacketCallback).Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+  EXPECT_EQ(expected_mode, agent_->DispatchPacketToClients(packet));
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+  EXPECT_EQ(MonitorMode::kNone, agent_->DispatchPacketToClients(packet));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleDispatchPacketToClientsWithMultipleClients) {
+  HalPacket packet({0x01, 0x02, 0x03, 0x04});
+  MockHciRouterClient mock_router_client1;
+  MockHciRouterClient mock_router_client2;
+  MockHciRouterClient mock_router_client3;
+
+  ON_CALL(mock_router_client1, OnPacketCallback(packet))
+      .WillByDefault(Return(MonitorMode::kIntercept));
+  ON_CALL(mock_router_client2, OnPacketCallback(packet))
+      .WillByDefault(Return(MonitorMode::kMonitor));
+  ON_CALL(mock_router_client3, OnPacketCallback(packet))
+      .WillByDefault(Return(MonitorMode::kMonitor));
+  EXPECT_CALL(mock_router_client1, OnPacketCallback).Times(1);
+  EXPECT_CALL(mock_router_client2, OnPacketCallback).Times(1);
+  EXPECT_CALL(mock_router_client3, OnPacketCallback).Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client1));
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client2));
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client3));
+  EXPECT_EQ(MonitorMode::kIntercept, agent_->DispatchPacketToClients(packet));
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client1));
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client2));
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client3));
+  EXPECT_EQ(MonitorMode::kNone, agent_->DispatchPacketToClients(packet));
+}
+
+TEST_F(HciRouterClientAgentTest, HandleNotifyHalStateChangeShutdownToInit) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(mock_router_client,
+              OnHalStateChanged(HalState::kInit, HalState::kShutdown))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  agent_->NotifyHalStateChange(HalState::kInit, HalState::kShutdown);
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleNotifyHalStateChangeInitToFirmwareDownloading) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(
+      mock_router_client,
+      OnHalStateChanged(HalState::kFirmwareDownloading, HalState::kInit))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  agent_->NotifyHalStateChange(HalState::kFirmwareDownloading, HalState::kInit);
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(
+    HciRouterClientAgentTest,
+    HandleNotifyHalStateChangeFirmwaredownloadingToFirmwaredownloadCompleted) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(mock_router_client,
+              OnHalStateChanged(HalState::kFirmwareDownloadCompleted,
+                                HalState::kFirmwareDownloading))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  agent_->NotifyHalStateChange(HalState::kFirmwareDownloadCompleted,
+                               HalState::kFirmwareDownloading);
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleNotifyHalStateChangeFirmwaredownloadCompletedToFirmwareReady) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(mock_router_client,
+              OnHalStateChanged(HalState::kFirmwareReady,
+                                HalState::kFirmwareDownloadCompleted))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  agent_->NotifyHalStateChange(HalState::kFirmwareReady,
+                               HalState::kFirmwareDownloadCompleted);
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleNotifyHalStateChangeFirmwareReadyToBtChipReady) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnHalStateChanged(HalState::kBtChipReady,
+                                                    HalState::kFirmwareReady))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  agent_->NotifyHalStateChange(HalState::kBtChipReady,
+                               HalState::kFirmwareReady);
+  ASSERT_TRUE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleNotifyHalStateChangeBtChipReadyToRunning) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(mock_router_client,
+              OnHalStateChanged(HalState::kRunning, HalState::kBtChipReady))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  agent_->NotifyHalStateChange(HalState::kRunning, HalState::kBtChipReady);
+  ASSERT_TRUE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleNotifyHalStateChangeBtChipReadyToRunningWithReset) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(1);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+  EXPECT_CALL(mock_router_client,
+              OnHalStateChanged(HalState::kRunning, HalState::kBtChipReady))
+      .Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+  EnableBluetooth();
+  ASSERT_TRUE(agent_->IsBluetoothChipReady());
+  ASSERT_TRUE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+TEST_F(HciRouterClientAgentTest,
+       HandleNotifyHalStateChangeWithMultipleClients) {
+  MockHciRouterClient mock_router_client1;
+  EXPECT_CALL(mock_router_client1, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client1, OnBluetoothChipClosed()).Times(1);
+  EXPECT_CALL(mock_router_client1, OnBluetoothEnabled()).Times(1);
+  EXPECT_CALL(mock_router_client1, OnBluetoothDisabled()).Times(1);
+
+  MockHciRouterClient mock_router_client2;
+  EXPECT_CALL(mock_router_client2, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client2, OnBluetoothChipClosed()).Times(1);
+  EXPECT_CALL(mock_router_client2, OnBluetoothEnabled()).Times(1);
+  EXPECT_CALL(mock_router_client2, OnBluetoothDisabled()).Times(1);
+
+  MockHciRouterClient mock_router_client3;
+  EXPECT_CALL(mock_router_client3, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client3, OnBluetoothChipClosed()).Times(1);
+  EXPECT_CALL(mock_router_client3, OnBluetoothEnabled()).Times(1);
+  EXPECT_CALL(mock_router_client3, OnBluetoothDisabled()).Times(1);
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client1));
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client2));
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client3));
+
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  PowerOnBluetooth();
+  ASSERT_TRUE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EnableBluetooth();
+  ASSERT_TRUE(agent_->IsBluetoothChipReady());
+  ASSERT_TRUE(agent_->IsBluetoothEnabled());
+
+  DisableBluetooth();
+  ASSERT_TRUE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  ShutdownBluetooth();
+  ASSERT_FALSE(agent_->IsBluetoothChipReady());
+  ASSERT_FALSE(agent_->IsBluetoothEnabled());
+
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client1));
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client2));
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client3));
+}
+
+TEST_F(HciRouterClientAgentTest, HandleRegisterRouterClientWhenEnabled) {
+  MockHciRouterClient mock_router_client;
+  EXPECT_CALL(mock_router_client, OnBluetoothChipReady()).Times(1);
+  EXPECT_CALL(mock_router_client, OnBluetoothChipClosed()).Times(0);
+  EXPECT_CALL(mock_router_client, OnBluetoothEnabled()).Times(1);
+  EXPECT_CALL(mock_router_client, OnBluetoothDisabled()).Times(0);
+
+  EnableBluetooth();
+
+  EXPECT_TRUE(agent_->RegisterRouterClient(&mock_router_client));
+  EXPECT_TRUE(agent_->UnregisterRouterClient(&mock_router_client));
+}
+
+}  // namespace
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_router_client_test.cc b/bluetooth/bluetooth_hal/hci_router_client_test.cc
new file mode 100644
index 0000000000..81f8617ef9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_router_client_test.cc
@@ -0,0 +1,294 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/hci_router_client.h"
+
+#include <list>
+#include <utility>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace hci {
+namespace {
+
+using ::bluetooth_hal::HalState;
+
+using ::testing::_;
+using ::testing::Return;
+using ::testing::Test;
+
+class HciRouterClientTestInstance : public HciRouterClient {
+ public:
+  MOCK_METHOD(void, OnBluetoothChipReady, (), (override));
+  MOCK_METHOD(void, OnBluetoothChipClosed, (), (override));
+  MOCK_METHOD(void, OnBluetoothEnabled, (), (override));
+  MOCK_METHOD(void, OnBluetoothDisabled, (), (override));
+
+  void OnCommandCallback([[maybe_unused]] const HalPacket& packet) override {}
+
+  void OnMonitorPacketCallback(MonitorMode mode,
+                               const HalPacket& packet) override {
+    on_monitor_callbacks_.push_back(std::pair(mode, packet));
+  }
+
+  // Wrappers to access protected methods
+  bool IsBluetoothChipReady() {
+    return HciRouterClient::IsBluetoothChipReady();
+  }
+
+  bool RegisterMonitor(const HciMonitor& monitor, MonitorMode mode) {
+    return HciRouterClient::RegisterMonitor(monitor, mode);
+  }
+
+  bool UnregisterMonitor(const HciMonitor& monitor) {
+    return HciRouterClient::UnregisterMonitor(monitor);
+  }
+
+  bool SendCommand(const HalPacket& packet) {
+    return HciRouterClient::SendCommand(packet);
+  }
+
+  bool SendData(const HalPacket& packet) {
+    return HciRouterClient::SendData(packet);
+  }
+
+  bool IsBluetoothEnabled() { return HciRouterClient::IsBluetoothEnabled(); }
+
+  std::list<std::pair<MonitorMode, HalPacket>> on_monitor_callbacks_;
+};
+
+class HciRouterClientTest : public Test {
+ protected:
+  static void SetUpTestSuite() {}
+
+  void SetUp() override {
+    MockHciRouter::SetMockRouter(&mock_hci_router_);
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+
+    ON_CALL(mock_hci_router_, Send(_)).WillByDefault(Return(true));
+    ON_CALL(mock_hci_router_, SendCommand(_, _)).WillByDefault(Return(true));
+    ON_CALL(mock_hci_router_client_agent_, RegisterRouterClient(_))
+        .WillByDefault(Return(true));
+    ON_CALL(mock_hci_router_client_agent_, UnregisterRouterClient(_))
+        .WillByDefault(Return(true));
+    EXPECT_CALL(mock_hci_router_client_agent_, RegisterRouterClient(_))
+        .Times(1);
+
+    router_client_ = new HciRouterClientTestInstance();
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mock_hci_router_client_agent_, UnregisterRouterClient(_))
+        .Times(1);
+    delete (router_client_);
+  }
+
+  HalPacket GenerateHciResetCommand() {
+    return HalPacket(std::vector<uint8_t>{0x01, 0x03, 0x0C, 0x00});
+  }
+
+  HalPacket GenerateHciResetCompleteEvent() {
+    return HalPacket(
+        std::vector<uint8_t>{0x04, 0x0E, 0x04, 0x01, 0x03, 0x0C, 0x00});
+  }
+
+  HalPacket GenerateBleAdvReportEvent() {
+    return HalPacket(std::vector<uint8_t>{
+        0x04, 0x3E, 0x1D, 0x0D, 0x01, 0x12, 0x00, 0x01, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x01, 0x00, 0xFF, 0x7F, 0xC0, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x02});
+  }
+
+  HalPacket GenerateRandomPacket() {
+    return HalPacket(std::vector<uint8_t>{0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
+                                          0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
+                                          0x0D, 0x0E, 0x0F});
+  }
+
+  void TestHandleRegisterMonitor(HciMonitor monitor, MonitorMode mode,
+                                 HalPacket packet, int expect_call_count) {
+    HalPacket packet_random = GenerateRandomPacket();
+
+    ASSERT_TRUE(router_client_->RegisterMonitor(monitor, mode));
+    ASSERT_EQ(router_client_->OnPacketCallback(packet), mode);
+    ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), expect_call_count);
+    ASSERT_EQ(router_client_->OnPacketCallback(packet_random),
+              MonitorMode::kNone);
+    ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), expect_call_count);
+    ASSERT_TRUE(router_client_->UnregisterMonitor(monitor));
+    ASSERT_EQ(router_client_->OnPacketCallback(packet), MonitorMode::kNone);
+    ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), expect_call_count);
+    ASSERT_EQ(router_client_->OnPacketCallback(packet_random),
+              MonitorMode::kNone);
+    ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), expect_call_count);
+  }
+
+  HciRouterClientTestInstance* router_client_;
+  MockHciRouter mock_hci_router_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+  static constexpr uint16_t kHciResetCommandOpcode = 0x0C03;
+  static constexpr uint16_t kHciBleAdvSubCode = 0x0D;
+};
+
+TEST_F(HciRouterClientTest, HandleIsBluetoothEnabledAndIsBluetoothChipReady) {
+  ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+      .WillByDefault(Return(false));
+  ON_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+      .WillByDefault(Return(false));
+  ASSERT_FALSE(router_client_->IsBluetoothChipReady());
+  ASSERT_FALSE(router_client_->IsBluetoothEnabled());
+
+  ON_CALL(mock_hci_router_client_agent_, IsBluetoothChipReady())
+      .WillByDefault(Return(true));
+  ON_CALL(mock_hci_router_client_agent_, IsBluetoothEnabled())
+      .WillByDefault(Return(true));
+  ASSERT_TRUE(router_client_->IsBluetoothChipReady());
+  ASSERT_TRUE(router_client_->IsBluetoothEnabled());
+}
+
+TEST_F(HciRouterClientTest, HandleSendCommandWithValidInput) {
+  const HalPacket packet = GenerateHciResetCommand();
+  EXPECT_CALL(mock_hci_router_, SendCommand(packet, _)).Times(1);
+  ASSERT_TRUE(router_client_->SendCommand(packet));
+}
+
+TEST_F(HciRouterClientTest, HandleSendCommandWithInValidInput) {
+  const HalPacket packet({0x70, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00});
+  EXPECT_CALL(mock_hci_router_, SendCommand(packet, _)).Times(0);
+  ASSERT_FALSE(router_client_->SendCommand(packet));
+}
+
+TEST_F(HciRouterClientTest, HandleSendDataWithValidInput) {
+  const HalPacket packet({0x70, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00});
+  EXPECT_CALL(mock_hci_router_, Send(packet)).Times(1);
+  ASSERT_TRUE(router_client_->SendData(packet));
+}
+
+TEST_F(HciRouterClientTest, HandleSendDataWithInValidInput) {
+  const HalPacket packet = GenerateHciResetCommand();
+  EXPECT_CALL(mock_hci_router_, Send(packet)).Times(0);
+  ASSERT_FALSE(router_client_->SendData(packet));
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorCommandMonitor) {
+  HalPacket packet = GenerateHciResetCommand();
+  HciCommandMonitor monitor(kHciResetCommandOpcode);
+  MonitorMode mode = MonitorMode::kMonitor;
+  TestHandleRegisterMonitor(monitor, mode, packet, 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorCommandIntercept) {
+  HalPacket packet = GenerateHciResetCommand();
+  HciCommandMonitor monitor(kHciResetCommandOpcode);
+  MonitorMode mode = MonitorMode::kIntercept;
+  TestHandleRegisterMonitor(monitor, mode, packet, 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorEventMonitor) {
+  HalPacket packet = GenerateHciResetCompleteEvent();
+  HciEventMonitor monitor(static_cast<uint8_t>(EventCode::kCommandComplete));
+  MonitorMode mode = MonitorMode::kMonitor;
+  TestHandleRegisterMonitor(monitor, mode, packet, 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorEventIntercept) {
+  HalPacket packet = GenerateHciResetCompleteEvent();
+  HciEventMonitor monitor(static_cast<uint8_t>(EventCode::kCommandComplete));
+  MonitorMode mode = MonitorMode::kIntercept;
+  TestHandleRegisterMonitor(monitor, mode, packet, 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorEventMonitorWithEventCode) {
+  HalPacket packet = GenerateBleAdvReportEvent();
+  HciEventMonitor monitor(static_cast<uint8_t>(EventCode::kBleMeta),
+                          kHciBleAdvSubCode,
+                          HciConstants::kHciBleEventSubCodeOffset);
+  MonitorMode mode = MonitorMode::kMonitor;
+  TestHandleRegisterMonitor(monitor, mode, packet, 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorEventInterceptWithEventCode) {
+  HalPacket packet = GenerateBleAdvReportEvent();
+  HciEventMonitor monitor(static_cast<uint8_t>(EventCode::kBleMeta),
+                          kHciBleAdvSubCode,
+                          HciConstants::kHciBleEventSubCodeOffset);
+  MonitorMode mode = MonitorMode::kIntercept;
+  TestHandleRegisterMonitor(monitor, mode, packet, 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorHasOverlapDifferentMode) {
+  HalPacket packet = GenerateHciResetCompleteEvent();
+  HalPacket packet_random = GenerateRandomPacket();
+
+  HciEventMonitor monitor1(static_cast<uint8_t>(EventCode::kCommandComplete));
+  HciCommandCompleteEventMonitor monitor2(kHciResetCommandOpcode);
+
+  ASSERT_TRUE(router_client_->RegisterMonitor(monitor1, MonitorMode::kMonitor));
+  ASSERT_TRUE(
+      router_client_->RegisterMonitor(monitor2, MonitorMode::kIntercept));
+  ASSERT_EQ(router_client_->OnPacketCallback(packet), MonitorMode::kIntercept);
+  ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), 1);
+
+  ASSERT_EQ(router_client_->OnPacketCallback(packet_random),
+            MonitorMode::kNone);
+  ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorHasOverlapSameMode) {
+  HalPacket packet = GenerateHciResetCompleteEvent();
+  HalPacket packet_random = GenerateRandomPacket();
+
+  HciEventMonitor monitor1(static_cast<uint8_t>(EventCode::kCommandComplete));
+  HciCommandCompleteEventMonitor monitor2(kHciResetCommandOpcode);
+
+  ASSERT_TRUE(router_client_->RegisterMonitor(monitor1, MonitorMode::kMonitor));
+  ASSERT_TRUE(router_client_->RegisterMonitor(monitor2, MonitorMode::kMonitor));
+  ASSERT_EQ(router_client_->OnPacketCallback(packet), MonitorMode::kMonitor);
+  ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), 1);
+
+  ASSERT_EQ(router_client_->OnPacketCallback(packet_random),
+            MonitorMode::kNone);
+  ASSERT_EQ(router_client_->on_monitor_callbacks_.size(), 1);
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorWithModeNone) {
+  HciCommandCompleteEventMonitor monitor(kHciResetCommandOpcode);
+  ASSERT_FALSE(router_client_->RegisterMonitor(monitor, MonitorMode::kNone));
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorDoubleRegister) {
+  HciCommandCompleteEventMonitor monitor1(kHciResetCommandOpcode);
+  HciCommandCompleteEventMonitor monitor2(kHciResetCommandOpcode);
+  ASSERT_TRUE(router_client_->RegisterMonitor(monitor1, MonitorMode::kMonitor));
+  ASSERT_FALSE(
+      router_client_->RegisterMonitor(monitor2, MonitorMode::kMonitor));
+}
+
+TEST_F(HciRouterClientTest, HandleRegisterMonitorUnregisterWithoutRegister) {
+  HciCommandCompleteEventMonitor monitor(kHciResetCommandOpcode);
+  ASSERT_FALSE(router_client_->UnregisterMonitor(monitor));
+}
+
+}  // namespace
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/hci_router_test.cc b/bluetooth/bluetooth_hal/hci_router_test.cc
new file mode 100644
index 0000000000..31d633581d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/hci_router_test.cc
@@ -0,0 +1,684 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/hci_router.h"
+
+#include <chrono>
+#include <condition_variable>
+#include <cstdint>
+#include <future>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <utility>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "bluetooth_hal/test/mock/mock_hal_config_loader.h"
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+#include "bluetooth_hal/test/mock/mock_transport_interface.h"
+#include "bluetooth_hal/test/mock/mock_vnd_snoop_logger.h"
+#include "bluetooth_hal/test/mock/mock_wakelock.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace hci {
+namespace {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Invoke;
+using ::testing::Mock;
+using ::testing::Return;
+using ::testing::SaveArg;
+using ::testing::Test;
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::config::MockHalConfigLoader;
+using ::bluetooth_hal::debug::MockVndSnoopLogger;
+using ::bluetooth_hal::transport::MockTransportInterface;
+using ::bluetooth_hal::transport::TransportInterfaceCallback;
+using ::bluetooth_hal::util::power::MockWakelock;
+
+HalPacketCallback EmptyHalPacketCallback =
+    []([[maybe_unused]] const HalPacket& packet) {};
+
+class FakeHciRouterCallback : public HciRouterCallback {
+ public:
+  FakeHciRouterCallback() = default;
+  void OnCommandCallback(const HalPacket& packet) override {
+    OnPacketCallback(packet);
+  };
+  MOCK_METHOD(MonitorMode, OnPacketCallback, (const HalPacket& packet),
+              (override));
+  MOCK_METHOD(void, OnHalStateChanged,
+              (const HalState new_state, const HalState old_state), (override));
+};
+
+class HciRouterTest : public Test {
+ protected:
+  static void SetUpTestSuite() {}
+
+  void SetUp() override {
+    MockHciRouterClientAgent::SetMockAgent(&mock_hci_router_client_agent_);
+    fake_hci_callback_ = std::make_shared<FakeHciRouterCallback>();
+
+    ON_CALL(mock_transport_interface_, IsTransportActive())
+        .WillByDefault(Return(true));
+    ON_CALL(mock_transport_interface_, Send(_))
+        .WillByDefault(Invoke(this, &HciRouterTest::OnSendToTransport));
+    ON_CALL(mock_transport_interface_, Initialize(_))
+        .WillByDefault(Invoke(
+            [this](TransportInterfaceCallback* transport_interface_callback) {
+              this->transport_interface_callback_ =
+                  transport_interface_callback;
+              on_transport_packet_ready_ = [this](const HalPacket& packet) {
+                // The on_packet_ready should only be called after the
+                // command is sent to the transport.
+                WaitForCommandSent(packet);
+                // Drop this packet as the purpose of empty_packet_ is just
+                // to block the test, we don't have to actually send it.
+                if (packet != empty_packet_) {
+                  transport_interface_callback_->OnTransportPacketReady(packet);
+                }
+              };
+              return true;
+            }));
+    ON_CALL(mock_transport_interface_, SetHciRouterBusy(_))
+        .WillByDefault(
+            Invoke(this, &HciRouterTest::OnSetHciRouterBusyInTransport));
+    ON_CALL(mock_hal_config_loader_, IsAcceleratedBtOnSupported())
+        .WillByDefault(Return(false));
+    ON_CALL(*fake_hci_callback_, OnHalStateChanged(_, _))
+        .WillByDefault(DoAll(SaveArg<0>(&new_state_), SaveArg<1>(&old_state_)));
+    ON_CALL(*fake_hci_callback_, OnPacketCallback(_))
+        .WillByDefault(
+            DoAll(SaveArg<0>(&hal_packet_), Return(MonitorMode::kNone)));
+
+    MockTransportInterface::SetMockTransport(&mock_transport_interface_);
+    MockHalConfigLoader::SetMockLoader(&mock_hal_config_loader_);
+    MockWakelock::SetMockWakelock(&mock_wakelock_);
+    MockVndSnoopLogger::SetMockVndSnoopLogger(&mock_vnd_snoop_logger_);
+
+    router_ = &HciRouter::GetRouter();
+    InitializeHciRouter();
+  }
+
+  void TearDown() override {
+    CleanupHciRouter();
+    command_sent_promises_.clear();
+    command_sent_futures_.clear();
+  }
+
+  void InitializeHciRouter() {
+    EXPECT_CALL(mock_transport_interface_, Initialize(_)).Times(1);
+    router_->Initialize(fake_hci_callback_);
+    CompleteFirmwareDownloadAndStackInit();
+  }
+
+  void CleanupHciRouter() {
+    EXPECT_CALL(mock_transport_interface_, Cleanup()).Times(1);
+    router_->Cleanup();
+    ASSERT_EQ(new_state_, HalState::kShutdown);
+    ASSERT_EQ(router_->GetHalState(), HalState::kShutdown);
+  }
+
+  void OnSetHciRouterBusyInTransport(bool busy) {
+    {
+      std::lock_guard<std::mutex> lock(mutex_);
+      is_router_busy_ = busy;
+    }
+    cv_.notify_one();
+  }
+
+  /**
+   * @brief Get the HCI router busy state, waiting up to 100ms for updates.
+   *
+   * As HCI router busy state could be changed asynchronously, we wait a bit for
+   * `is_router_busy_` to change (notified by `OnSetHciRouterBusyInTransport`).
+   * Timeout may indicate the value was not set or has set earlier.
+   *
+   * @return The current or last known value of `is_router_busy_`.
+   *
+   */
+  bool GetIsRouterBusy() {
+    std::unique_lock<std::mutex> lock(mutex_);
+    cv_.wait_for(lock, std::chrono::milliseconds(10));
+    return is_router_busy_;
+  }
+
+  void CompleteFirmwareDownloadAndStackInit() {
+    // Mock the chip provisioner firmware download behaivor.
+    router_->UpdateHalState(HalState::kFirmwareDownloading);
+    router_->UpdateHalState(HalState::kFirmwareDownloadCompleted);
+    router_->UpdateHalState(HalState::kFirmwareReady);
+
+    Mock::VerifyAndClearExpectations(&(*fake_hci_callback_));
+
+    // Check state is Running.
+    std::vector<HalState> state_changes;
+    EXPECT_CALL(*fake_hci_callback_, OnHalStateChanged(_, _))
+        .Times(2)
+        .WillRepeatedly(Invoke(
+            [&](HalState new_state, [[maybe_unused]] HalState old_state) {
+              state_changes.push_back(new_state);
+            }));
+
+    router_->UpdateHalState(HalState::kBtChipReady);
+
+    EXPECT_EQ(state_changes.size(), 2);
+    EXPECT_EQ(state_changes[0], HalState::kBtChipReady);
+    EXPECT_EQ(state_changes[1], HalState::kRunning);
+
+    // Without accelerated BT enabled, once HAL changes to `kBtChipReady`, it
+    // will automatically update to the `kRunning`.
+    EXPECT_EQ(router_->GetHalState(), HalState::kRunning);
+
+    Mock::VerifyAndClearExpectations(&(*fake_hci_callback_));
+  }
+
+  void CompleteResetFirmwareWithAcceleratedBtOn() {
+    // Mock the chip provisioner reset behavior.
+    if (router_->GetHalState() != HalState::kBtChipReady &&
+        router_->GetHalState() != HalState::kRunning) {
+      return;
+    }
+
+    HalState target_state = router_->GetHalState() == HalState::kBtChipReady
+                                ? HalState::kRunning
+                                : HalState::kBtChipReady;
+    router_->UpdateHalState(target_state);
+
+    ASSERT_EQ(new_state_, target_state);
+    ASSERT_EQ(router_->GetHalState(), target_state);
+  }
+
+  std::pair<HalPacket, HalPacket> CreateCommandEventPacketsWithOrderEnsured(
+      std::vector<uint8_t> command, std::vector<uint8_t> event) {
+    HalPacket command_packet(command);
+    HalPacket event_packet(event);
+    // Use promise and future to synchronize the command and event.
+    std::promise<void> promise;
+    std::future<void> future = promise.get_future();
+    command_sent_promises_[command] = std::move(promise);
+    command_sent_futures_[event] = std::move(future);
+    return std::make_pair(command_packet, event_packet);
+  }
+
+  void MarkCommandAsSent(const HalPacket& command) {
+    auto it = command_sent_promises_.find(command);
+    if (it != command_sent_promises_.end()) {
+      it->second.set_value();
+    }
+  }
+
+  bool OnSendToTransport(const HalPacket& packet) {
+    // To let the on_packet_ready know the command is sent.
+    MarkCommandAsSent(packet);
+    return true;
+  }
+
+  void WaitForCommandSent(const HalPacket& event) {
+    auto it = command_sent_futures_.find(event);
+    if (it != command_sent_futures_.end()) {
+      it->second.get();
+    }
+  }
+
+  void ExpectHalStateChange(HalState new_state, HalState old_state,
+                            int count = 1) {
+    EXPECT_CALL(*fake_hci_callback_, OnHalStateChanged(new_state, old_state))
+        .Times(count);
+    EXPECT_CALL(mock_hci_router_client_agent_,
+                NotifyHalStateChange(new_state, old_state))
+        .Times(count);
+    EXPECT_CALL(mock_transport_interface_, NotifyHalStateChange(new_state))
+        .Times(count);
+  }
+
+  FakeHciRouterCallback fake_router_callback_;
+  std::shared_ptr<FakeHciRouterCallback> fake_hci_callback_;
+  HciRouter* router_;
+  std::mutex mutex_;
+  std::condition_variable cv_;
+  bool is_router_busy_ = false;
+  HalState new_state_;
+  HalState old_state_;
+  HalPacket hal_packet_;
+  // An empty RX for blocking the test until command has sent to transport.
+  HalPacket empty_packet_ = HalPacket({0x02, 0x00, 0x00, 0x00, 0x00});
+  HalPacketCallback on_transport_packet_ready_;
+  TransportInterfaceCallback* transport_interface_callback_;
+  MockTransportInterface mock_transport_interface_;
+  MockHalConfigLoader mock_hal_config_loader_;
+  MockWakelock mock_wakelock_;
+  MockVndSnoopLogger mock_vnd_snoop_logger_;
+  MockHciRouterClientAgent mock_hci_router_client_agent_;
+  std::map<HalPacket, std::promise<void>> command_sent_promises_;
+  std::map<HalPacket, std::future<void>> command_sent_futures_;
+};
+
+TEST_F(HciRouterTest, InitializeWithAcceleratedBtOn) {
+  // Power up the Bluetooth chip.
+  ON_CALL(mock_hal_config_loader_, IsAcceleratedBtOnSupported())
+      .WillByDefault(Return(true));
+
+  // Turn off Bluetooth, but without cleanup the transport layer.
+  router_->Cleanup();
+  CompleteResetFirmwareWithAcceleratedBtOn();
+
+  // Turn on Bluetooth from kBtChipReady state, skip firmware download.
+  router_->Initialize(fake_hci_callback_);
+  CompleteResetFirmwareWithAcceleratedBtOn();
+
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(1);
+  EXPECT_TRUE(router_->Send(cmd_reset));
+  EXPECT_TRUE(GetIsRouterBusy());
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_FALSE(GetIsRouterBusy());
+  EXPECT_EQ(hal_packet_, evt_reset);
+
+  // Disable Accelerated BT ON for test tear down.
+  ON_CALL(mock_hal_config_loader_, IsAcceleratedBtOnSupported())
+      .WillByDefault(Return(false));
+}
+
+TEST_F(HciRouterTest, HandleSendAclData) {
+  HalPacket acl_data({0x02, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  EXPECT_CALL(mock_transport_interface_, Send(acl_data)).Times(1);
+
+  EXPECT_TRUE(router_->Send(acl_data));
+  EXPECT_FALSE(GetIsRouterBusy());
+}
+
+TEST_F(HciRouterTest, HandleSendHciCommand) {
+  auto [cmd, blocker] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, empty_packet_);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd)).Times(1);
+
+  EXPECT_TRUE(router_->Send(cmd));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(blocker);
+}
+
+TEST_F(HciRouterTest, HandleSendHciCommandTwiceWithoutEvent) {
+  auto [cmd_reset, blocker] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, empty_packet_);
+  HalPacket cmd_set_host_le_support({0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00});
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(0);
+
+  EXPECT_TRUE(router_->Send(cmd_reset));
+  EXPECT_TRUE(GetIsRouterBusy());
+  EXPECT_TRUE(router_->Send(cmd_set_host_le_support));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(blocker);
+}
+
+TEST_F(HciRouterTest, HandleSendHciCommandTwiceWithEvent) {
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  auto [cmd_set_host_le_support, blocker] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00}, empty_packet_);
+
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(1);
+
+  // Send the first command.
+  EXPECT_TRUE(router_->Send(cmd_reset));
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Receive the event for the first command, and pass to the stack callback.
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_FALSE(GetIsRouterBusy());
+  EXPECT_EQ(hal_packet_, evt_reset);
+  // Send the second command.
+  EXPECT_TRUE(router_->Send(cmd_set_host_le_support));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(blocker);
+}
+
+TEST_F(HciRouterTest, HandleSendHciCommandTwiceWithLateEvent) {
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  auto [cmd_set_host_le_support, evt_set_host_le_support] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00},
+          {0x04, 0x0e, 0x04, 0x01, 0x6d, 0x0c, 0x00});
+
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(2);
+
+  // Send the first command.
+  EXPECT_TRUE(router_->Send(cmd_reset));
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Send the second command.
+  EXPECT_TRUE(router_->Send(cmd_set_host_le_support));
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Receive the event for the first command, and pass to the stack callback.
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_EQ(hal_packet_, evt_reset);
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Receive the event for the second command.
+  on_transport_packet_ready_(evt_set_host_le_support);
+  EXPECT_EQ(hal_packet_, evt_set_host_le_support);
+  EXPECT_FALSE(GetIsRouterBusy());
+}
+
+TEST_F(HciRouterTest, HandleSendCommandTwiceWithoutEvent) {
+  auto [cmd_reset, blocker] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, empty_packet_);
+  HalPacket cmd_set_host_le_support({0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00});
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(0);
+
+  EXPECT_TRUE(router_->SendCommand(cmd_reset, EmptyHalPacketCallback));
+  EXPECT_TRUE(GetIsRouterBusy());
+  EXPECT_TRUE(
+      router_->SendCommand(cmd_set_host_le_support, EmptyHalPacketCallback));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(blocker);
+}
+
+TEST_F(HciRouterTest, HandleSendCommandTwiceWithEvent) {
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  auto [cmd_set_host_le_support, blocker] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00}, empty_packet_);
+
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(0);
+
+  // Send the first command with a client callback.
+  HalPacket event;
+  EXPECT_TRUE(router_->SendCommand(
+      cmd_reset, [&event](const HalPacket& packet) { event = packet; }));
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Receive the event for the first command, check if the event is sent to
+  // the client callback.
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_FALSE(GetIsRouterBusy());
+  EXPECT_EQ(event, evt_reset);
+  // Send the second command.
+  EXPECT_TRUE(
+      router_->SendCommand(cmd_set_host_le_support, EmptyHalPacketCallback));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(blocker);
+}
+
+TEST_F(HciRouterTest, HandleSendCommandTwiceWithLateEvent) {
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  auto [cmd_set_host_le_support, evt_set_host_le_support] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00},
+          {0x04, 0x0e, 0x04, 0x01, 0x6d, 0x0c, 0x00});
+
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(0);
+
+  // Send the first command with a client callback.
+  HalPacket event;
+  EXPECT_TRUE(router_->SendCommand(
+      cmd_reset, [&event](const HalPacket& packet) { event = packet; }));
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Send the second command.
+  EXPECT_TRUE(
+      router_->SendCommand(cmd_set_host_le_support, EmptyHalPacketCallback));
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Receive the event for the first command, check if the event is sent to
+  // the client callback.
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_TRUE(GetIsRouterBusy());
+  EXPECT_EQ(event, evt_reset);
+  // Receive the event for the second command.
+  on_transport_packet_ready_(evt_set_host_le_support);
+  EXPECT_FALSE(GetIsRouterBusy());
+}
+
+TEST_F(HciRouterTest, HandleSendHciCommandInCallback) {
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  auto [cmd_set_host_le_support, evt_set_host_le_support] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00},
+          {0x04, 0x0e, 0x04, 0x01, 0x6d, 0x0c, 0x00});
+
+  // Expect both cmd_reset and cmd_set_host_le_support are sent to the
+  // transport layer, and no callback to the stack.
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(0);
+
+  // Send the first command with a client callback, and send the second
+  // command in the client callback.
+  HalPacket event;
+  EXPECT_TRUE(router_->SendCommand(cmd_reset, [&event, &cmd_set_host_le_support,
+                                               this](const HalPacket& packet) {
+    event = packet;
+    EXPECT_TRUE(
+        router_->SendCommand(cmd_set_host_le_support, EmptyHalPacketCallback));
+  }));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  // Receive the generated event for the first command, check if the second
+  // command is properly sent.
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_EQ(event, evt_reset);
+  EXPECT_TRUE(GetIsRouterBusy());
+  // Check the second command is properly handled.
+  on_transport_packet_ready_(evt_set_host_le_support);
+  EXPECT_FALSE(GetIsRouterBusy());
+}
+
+TEST_F(HciRouterTest, HandleSendHciCommandInCallbackAfterAnotherSendCommand) {
+  auto [cmd_reset, evt_reset] = CreateCommandEventPacketsWithOrderEnsured(
+      {0x01, 0x03, 0x0c, 0x00}, {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00});
+  auto [cmd_set_min_enc_key_size, evt_set_min_enc_key_size] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x84, 0x0c, 0x01, 0x07},
+          {0x04, 0x0e, 0x04, 0x01, 0x84, 0x0c, 0x00});
+  auto [cmd_set_host_le_support, evt_set_host_le_support] =
+      CreateCommandEventPacketsWithOrderEnsured(
+          {0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00},
+          {0x04, 0x0e, 0x04, 0x01, 0x6d, 0x0c, 0x00});
+
+  // Expect both cmd_reset and cmd_set_host_le_support are sent to the
+  // transport layer, and no callback to the stack.
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_min_enc_key_size))
+      .Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(0);
+
+  // Send the first command with a client callback, and send the second
+  // command in the client callback.
+  HalPacket event;
+  EXPECT_TRUE(router_->SendCommand(cmd_reset, [&event, &cmd_set_host_le_support,
+                                               this](const HalPacket& packet) {
+    event = packet;
+    EXPECT_TRUE(
+        router_->SendCommand(cmd_set_host_le_support, EmptyHalPacketCallback));
+  }));
+  EXPECT_TRUE(GetIsRouterBusy());
+  EXPECT_TRUE(router_->SendCommand(
+      cmd_set_min_enc_key_size,
+      [&event](const HalPacket& packet) { event = packet; }));
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  // Receive three generated events in order
+  on_transport_packet_ready_(evt_reset);
+  EXPECT_EQ(event, evt_reset);
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(evt_set_min_enc_key_size);
+  EXPECT_EQ(event, evt_set_min_enc_key_size);
+  EXPECT_TRUE(GetIsRouterBusy());
+
+  on_transport_packet_ready_(evt_set_host_le_support);
+  EXPECT_FALSE(GetIsRouterBusy());
+}
+
+TEST_F(HciRouterTest, HandleSendCommandNoAck) {
+  HalPacket cmd_reset({0x01, 0x03, 0x0c, 0x00});
+  HalPacket cmd_set_host_le_support({0x01, 0x6d, 0x0c, 0x02, 0x01, 0x00});
+
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_reset)).Times(1);
+  EXPECT_CALL(mock_transport_interface_, Send(cmd_set_host_le_support))
+      .Times(1);
+
+  // Send the first command.
+  EXPECT_TRUE(router_->SendCommandNoAck(cmd_reset));
+  EXPECT_FALSE(GetIsRouterBusy());
+  // Send the second command.
+  EXPECT_TRUE(router_->SendCommandNoAck(cmd_set_host_le_support));
+  EXPECT_FALSE(GetIsRouterBusy());
+}
+
+TEST_F(HciRouterTest, HandleDispatchPacketToClientsMonitorNone) {
+  HalPacket event({0x04, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  ON_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(_))
+      .WillByDefault(Return(MonitorMode::kNone));
+
+  // Check if the received event is dispatched to both callback and stack.
+  EXPECT_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(event))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(event)).Times(1);
+
+  on_transport_packet_ready_(event);
+  EXPECT_EQ(hal_packet_, event);
+}
+
+TEST_F(HciRouterTest, HandleDispatchPacketToClientsMonitorMonitor) {
+  HalPacket event({0x04, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  ON_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(_))
+      .WillByDefault(Return(MonitorMode::kMonitor));
+
+  // Check if the received event is dispatched to both callback and stack.
+  EXPECT_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(event))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(event)).Times(1);
+
+  on_transport_packet_ready_(event);
+  EXPECT_EQ(hal_packet_, event);
+}
+
+TEST_F(HciRouterTest, HandleDispatchPacketToClientsMonitorIntercept) {
+  HalPacket event({0x04, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  ON_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(_))
+      .WillByDefault(Return(MonitorMode::kIntercept));
+
+  // Check if the received event is only dispatched to the agent.
+  EXPECT_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(event))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(0);
+
+  on_transport_packet_ready_(event);
+}
+
+TEST_F(HciRouterTest, HandleOnAclDataCallback) {
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(1);
+  HalPacket packet({0x02, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  on_transport_packet_ready_(packet);
+  EXPECT_EQ(hal_packet_, packet);
+}
+
+TEST_F(HciRouterTest, HandleOnScoDataCallback) {
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(1);
+  HalPacket packet({0x03, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  on_transport_packet_ready_(packet);
+  EXPECT_EQ(hal_packet_, packet);
+}
+
+TEST_F(HciRouterTest, HandleOnIsoDataCallback) {
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(1);
+  HalPacket packet({0x05, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  on_transport_packet_ready_(packet);
+  EXPECT_EQ(hal_packet_, packet);
+}
+
+TEST_F(HciRouterTest, HandleDispatchPacketToClientsInterceptThreadData) {
+  FakeHciRouterCallback fake_router_callback;
+  HalPacket thread_data({0x70, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+
+  ON_CALL(mock_hci_router_client_agent_, DispatchPacketToClients(_))
+      .WillByDefault(Return(MonitorMode::kIntercept));
+
+  // Expect router callback is called, but stack callback is not.
+  EXPECT_CALL(mock_hci_router_client_agent_,
+              DispatchPacketToClients(thread_data))
+      .Times(1);
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(0);
+
+  on_transport_packet_ready_(thread_data);
+}
+
+TEST_F(HciRouterTest, HandleSendPacketToStack) {
+  EXPECT_CALL(*fake_hci_callback_, OnPacketCallback(_)).Times(1);
+  HalPacket packet({0x02, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07});
+  router_->SendPacketToStack(packet);
+  EXPECT_EQ(hal_packet_, packet);
+}
+
+TEST_F(HciRouterTest, HandleUpdateHalState) {
+  // A second shutdown is called in the test Cleanup.
+  ExpectHalStateChange(HalState::kShutdown, HalState::kRunning, 2);
+  ExpectHalStateChange(HalState::kInit, HalState::kShutdown);
+  ExpectHalStateChange(HalState::kFirmwareDownloading, HalState::kInit);
+  ExpectHalStateChange(HalState::kFirmwareDownloadCompleted,
+                       HalState::kFirmwareDownloading);
+  ExpectHalStateChange(HalState::kFirmwareReady,
+                       HalState::kFirmwareDownloadCompleted);
+  ExpectHalStateChange(HalState::kBtChipReady, HalState::kFirmwareReady);
+  ExpectHalStateChange(HalState::kRunning, HalState::kBtChipReady);
+  router_->UpdateHalState(HalState::kShutdown);
+  router_->UpdateHalState(HalState::kInit);
+  router_->UpdateHalState(HalState::kFirmwareDownloading);
+  router_->UpdateHalState(HalState::kFirmwareDownloadCompleted);
+  router_->UpdateHalState(HalState::kFirmwareReady);
+  // Without accelerated BT enabled, once HAL changes to `kBtChipReady`, it
+  // will automatically update to the `kRunning`.
+  router_->UpdateHalState(HalState::kBtChipReady);
+}
+
+}  // namespace
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_address.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_address.h
new file mode 100644
index 0000000000..c67afe198a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_address.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstddef>
+#include <cstdint>
+#include <iomanip>
+#include <sstream>
+#include <string>
+
+namespace bluetooth_hal {
+namespace hci {
+
+inline constexpr int kBluetoothAddressLength = 6;
+inline constexpr int kBluetoothAddressHiddenBytes = 4;
+
+class BluetoothAddress : public std::array<uint8_t, kBluetoothAddressLength> {
+ public:
+  std::string ToString() const {
+    std::stringstream ss;
+    ss << std::hex << std::uppercase << std::setfill('0');
+    for (size_t i = 0; i < kBluetoothAddressLength; ++i) {
+      if (i < kBluetoothAddressHiddenBytes) {
+        ss << "XX";
+      } else {
+        ss << std::setw(2) << static_cast<int>((*this)[i]);
+      }
+      if (i < kBluetoothAddressLength - 1) {
+        ss << ":";
+      }
+    }
+    return ss.str();
+  }
+
+  std::string ToFullString() const {
+    std::stringstream ss;
+    ss << std::hex << std::uppercase << std::setfill('0');
+    for (size_t i = 0; i < kBluetoothAddressLength; ++i) {
+      ss << std::setw(2) << static_cast<int>((*this)[i]);
+      if (i < kBluetoothAddressLength - 1) {
+        ss << ":";
+      }
+    }
+    return ss.str();
+  }
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/vibrator/1.0/default/service.cpp b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_hal.h
similarity index 59%
rename from vibrator/1.0/default/service.cpp
rename to bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_hal.h
index 7cc074461d..ac6802e017 100644
--- a/vibrator/1.0/default/service.cpp
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_hal.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "android.hardware.vibrator@1.0-service"
 
-#include <android/hardware/vibrator/1.0/IVibrator.h>
-#include <hidl/LegacySupport.h>
+#include <memory>
 
-using android::hardware::vibrator::V1_0::IVibrator;
-using android::hardware::defaultPassthroughServiceImplementation;
+#include "bluetooth_hal/transport/transport_interface.h"
 
-int main() {
-    return defaultPassthroughServiceImplementation<IVibrator>();
-}
+namespace bluetooth_hal {
+
+class BluetoothHal {
+ public:
+  static BluetoothHal& GetHal();
+  bool RegisterVendorTransport(
+      std::unique_ptr<::bluetooth_hal::transport::TransportInterface>
+          transport);
+  void Start();
+};
+
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_hci.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_hci.h
new file mode 100644
index 0000000000..b46015c7ac
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/bluetooth_hci.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <functional>
+#include <memory>
+
+#include "aidl/android/hardware/bluetooth/BnBluetoothHci.h"
+#include "aidl/android/hardware/bluetooth/IBluetoothHciCallbacks.h"
+#include "android/binder_auto_utils.h"
+#include "android/binder_status.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+
+class BluetoothHalDeathRecipient;
+
+class BluetoothHci
+    : public ::aidl::android::hardware::bluetooth::BnBluetoothHci {
+ public:
+  static BluetoothHci& GetHci();
+
+  BluetoothHci();
+  ::ndk::ScopedAStatus initialize(
+      const std::shared_ptr<
+          ::aidl::android::hardware::bluetooth::IBluetoothHciCallbacks>& cb)
+      override;
+  ::ndk::ScopedAStatus sendHciCommand(
+      const std::vector<uint8_t>& packet) override;
+  ::ndk::ScopedAStatus sendAclData(const std::vector<uint8_t>& data) override;
+  ::ndk::ScopedAStatus sendScoData(const std::vector<uint8_t>& data) override;
+  ::ndk::ScopedAStatus sendIsoData(const std::vector<uint8_t>& data) override;
+  ::ndk::ScopedAStatus close() override;
+  binder_status_t dump(int fd, const char** args, uint32_t numArgs) override;
+
+ private:
+  void DispatchPacketToStack(const ::bluetooth_hal::hci::HalPacket& packet);
+  void HandleHalStateChanged(::bluetooth_hal::HalState new_state,
+                             ::bluetooth_hal::HalState old_state);
+  void SendDataToController(const ::bluetooth_hal::hci::HalPacket& packet);
+  static void SigtermHandler(int signum);
+
+  std::shared_ptr<::aidl::android::hardware::bluetooth::IBluetoothHciCallbacks>
+      bluetooth_hci_callback_;
+  std::shared_ptr<BluetoothHalDeathRecipient> death_recipient_;
+  std::function<void(std::shared_ptr<BluetoothHalDeathRecipient>&)> unlink_cb_;
+  bool is_initializing_;
+  static std::atomic<bool> is_signal_handled_;
+};
+
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/chip/async_chip_provisioner.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/chip/async_chip_provisioner.h
new file mode 100644
index 0000000000..9f1ecbfb82
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/chip/async_chip_provisioner.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <functional>
+#include <memory>
+#include <variant>
+
+#include "bluetooth_hal/chip/chip_provisioner.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/worker.h"
+
+namespace bluetooth_hal {
+namespace chip {
+
+enum class ChipProvisionMessageType : int {
+  kInitialize = 0,
+  kDownloadFirmware,
+  kResetFirmware,
+};
+
+struct InitializePayload {
+  std::function<void(::bluetooth_hal::HalState)> on_hal_state_update;
+};
+
+struct DownloadFirmwarePayload {};
+
+struct ResetFirmwarePayload {};
+
+class ChipProvisionMessage {
+ public:
+  static ChipProvisionMessage CreateInitialize(InitializePayload payload);
+
+  static ChipProvisionMessage CreateDownloadFirmware();
+
+  static ChipProvisionMessage CreateResetFirmware();
+
+  ChipProvisionMessageType type;
+  std::variant<InitializePayload, DownloadFirmwarePayload, ResetFirmwarePayload>
+      payload;
+
+ private:
+  ChipProvisionMessage() = default;
+};
+
+class AsyncChipProvisioner {
+ public:
+  AsyncChipProvisioner();
+
+  static AsyncChipProvisioner& GetProvisioner();
+
+  /**
+   * @brief Posts an initialization request.
+   *
+   * @param on_hal_state_update Callback function for HAL state updates.
+   *
+   */
+  void PostInitialize(
+      const std::function<void(::bluetooth_hal::HalState)> on_hal_state_update);
+
+  /**
+   * @brief Posts a request to download firmware.
+   *
+   */
+  void PostDownloadFirmware();
+
+  /**
+   * @brief Posts a request to reset firmware.
+   *
+   */
+  void PostResetFirmware();
+
+ private:
+  void ProcessMessage(ChipProvisionMessage message);
+  void HandleInitialize(const InitializePayload& payload);
+  void HandleDownloadFirmware();
+  void HandleResetFirmware();
+
+  ::bluetooth_hal::util::Worker<ChipProvisionMessage> worker_;
+  std::unique_ptr<ChipProvisioner> chip_provisioner_;
+};
+
+}  // namespace chip
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/chip/chip_provisioner.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/chip/chip_provisioner.h
new file mode 100644
index 0000000000..f911c922b7
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/chip/chip_provisioner.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <future>
+#include <optional>
+
+#include "bluetooth_hal/config/firmware_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace chip {
+
+class ChipProvisioner : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  ChipProvisioner()
+      : config_loader_(
+            ::bluetooth_hal::config::FirmwareConfigLoader::GetLoader()) {}
+
+  /**
+   * Initializes the HAL state update mechanism.
+   *
+   * @param on_hal_state_update A callback function that is invoked
+   *        when the HAL state changes.
+   */
+  void Initialize(
+      const std::function<void(::bluetooth_hal::HalState)> on_hal_state_update);
+
+  /**
+   * Downloads the chip firmware.
+   *
+   * This function initiates the firmware download process for the chip.
+   * It is a blocking call and returns only after the firmware download
+   * has completed.
+   *
+   * @return `true` if the firmware download completes successfully.
+   *         `false` if the firmware download fails.
+   */
+  bool DownloadFirmware();
+
+  /**
+   * Resets the chip firmware.
+   *
+   * This function resets the firmware on the chip using an HCI reset command.
+   * It is a blocking call and returns only after receiving events from the
+   * chip.
+   *
+   * @return `true` if the firmware reset is successful.
+   *         `false` if the firmware reset fails.
+   */
+  bool ResetFirmware();
+
+ private:
+  void OnCommandCallback(const ::bluetooth_hal::hci::HalPacket& callback_event);
+
+  void OnBluetoothEnabled() override {};
+
+  void OnBluetoothDisabled() override {};
+
+  void OnBluetoothChipReady() override {};
+
+  void OnBluetoothChipClosed() override {};
+
+  void OnMonitorPacketCallback(
+      [[maybe_unused]] ::bluetooth_hal::hci::MonitorMode mode,
+      [[maybe_unused]] const ::bluetooth_hal::hci::HalPacket& packet) override {
+  };
+
+  void UpdateHalState(::bluetooth_hal::HalState state);
+  void HandleNextSetupStep(::bluetooth_hal::config::SetupCommandType command);
+  bool ExecuteCurrentSetupStep(
+      ::bluetooth_hal::config::SetupCommandType next_command_type);
+  bool SendCommandNoAck(const hci::HalPacket& packet);
+  bool SendCommandAndWait(const hci::HalPacket& packet);
+  bool ProvisionBluetoothAddress();
+  std::optional<hci::HalPacket> PrepareWriteBdAddressPacket();
+  bool WriteFwPatchramPacket();
+
+  std::optional<std::function<void(::bluetooth_hal::HalState)>>
+      on_hal_state_update_;
+  ::bluetooth_hal::config::FirmwareConfigLoader& config_loader_;
+  static constexpr size_t kBluetoothAddressLength = 6;
+  std::array<uint8_t, kBluetoothAddressLength> bdaddr_;
+
+  std::promise<void> command_promise_;
+  bool firmware_command_success_;
+};
+
+}  // namespace chip
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_constants.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_constants.h
new file mode 100644
index 0000000000..adf4ba2895
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_constants.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string_view>
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace config {
+namespace constants {
+
+inline constexpr ::bluetooth_hal::transport::TransportType
+    kDefaultBtTransportType =
+        ::bluetooth_hal::transport::TransportType::kUartH4;
+inline constexpr std::string_view kHalConfigFile =
+    "/vendor/etc/bluetooth/hal_config.json";
+inline constexpr int kDefaultBtRegOnDelay = 100;
+inline constexpr std::string_view kDefaultBtUartDevicePort = "/dev/ttySAC16";
+inline constexpr int kDefaultVendorTransportCrashIntervalSec = 3600;
+
+inline constexpr std::string_view kLpmEnableProcNode =
+    "/proc/bluetooth/sleep/lpm";
+inline constexpr std::string_view kLpmWakingProcNode =
+    "/proc/bluetooth/sleep/btwrite";
+inline constexpr std::string_view kLpmWakelockCtrlProcNode =
+    "/proc/bluetooth/sleep/wakelock_ctrl";
+inline constexpr std::string_view kRfkillFolderPrefix =
+    "/sys/class/rfkill/rfkill";
+inline constexpr std::string_view kRfkillTypeBluetooth = "bluetooth";
+
+}  // namespace constants
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_loader.h
new file mode 100644
index 0000000000..f9cf2c6f3d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_loader.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+#include <string_view>
+
+namespace bluetooth_hal {
+namespace config {
+
+class ConfigLoader {
+ public:
+  virtual ~ConfigLoader() = default;
+
+  /**
+   * @brief Loads the configuration using a custom-defined mechanism.
+   *
+   * This is a pure virtual function that must be implemented by all
+   * derived classes. It serves as the primary entry point for
+   * configuration loading, and can internally invoke other helper
+   * methods such as LoadConfigFromFile or LoadConfigFromString.
+   *
+   * @return true if configuration is loaded successfully, false otherwise.
+   */
+  virtual bool LoadConfig() = 0;
+
+  /**
+   * @brief Loads the configuration from a file.
+   *
+   * This function provides a default implementation for loading configuration
+   * from a given file path. Derived classes may override this method to provide
+   * specific file-based loading behavior if needed.
+   *
+   * @param path The path to the file to be read for loading the configuration.
+   * @return true if the configuration is successfully loaded from the file,
+   * false otherwise.
+   */
+  virtual bool LoadConfigFromFile(std::string_view path) {
+    (void)path;
+    return false;
+  }
+
+  /**
+   * @brief Loads the configuration from a string.
+   *
+   * This function provides a default implementation for loading configuration
+   * from a raw string (e.g., JSON content). Derived classes may override this
+   * method to support loading from string-based sources.
+   *
+   * @param content The string content to parse and load the configuration
+   * from.
+   * @return true if the configuration is successfully parsed and loaded, false
+   * otherwise.
+   */
+  virtual bool LoadConfigFromString(std::string_view content) {
+    (void)content;
+    return false;
+  }
+
+  /**
+   * @brief Dumps the current configuration state into a string.
+   *
+   * This pure virtual function must be implemented by derived classes to
+   * provide a string representation of their loaded configuration.
+   * @return A string containing the current configuration state.
+   */
+  virtual std::string DumpConfigToString() const = 0;
+};
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_util.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_util.h
new file mode 100644
index 0000000000..bfde21f28c
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/config_util.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+#include <string_view>
+
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/android_base_wrapper.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::util::AndroidBaseWrapper;
+
+inline void EnableTransportFallback() {
+  // Disable Accelerate Bluetooth On to re-initialize the UART.
+  AndroidBaseWrapper::GetWrapper().SetProperty(
+      Property::kIsAcceleratedBtOnEnabled, "false");
+  AndroidBaseWrapper::GetWrapper().SetProperty(
+      Property::kTransportFallbackEnabled, "true");
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/cs_config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/cs_config_loader.h
new file mode 100644
index 0000000000..a7e9cc39a0
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/cs_config_loader.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/config/config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+class CsConfigLoader : public ConfigLoader {
+ public:
+  virtual ~CsConfigLoader() = default;
+
+  virtual bool LoadConfig() override = 0;
+  virtual std::string DumpConfigToString() const override = 0;
+
+  virtual const std::vector<::bluetooth_hal::hci::HalPacket>&
+  GetCsCalibrationCommands() const = 0;
+
+  static CsConfigLoader& GetLoader();
+};
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/firmware_config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/firmware_config_loader.h
new file mode 100644
index 0000000000..875efbd1c1
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/firmware_config_loader.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <functional>
+#include <mutex>
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/config/config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+enum class FirmwarePacketType : int {
+  kSetupCommand = 0,
+  kData,
+};
+
+enum class SetupCommandType : int {
+  kReset = 0,
+  kReadChipId,
+  kUpdateChipBaudRate,
+  kSetFastDownload,
+  kDownloadMinidrv,
+  kLaunchRam,
+  kReadFwVersion,
+  kSetupLowPowerMode,
+  kWriteBdAddress,
+};
+
+enum class DataType : int { kDataFragment = 0, kDataEnd };
+
+class FirmwarePacket {
+ public:
+  FirmwarePacket(FirmwarePacketType packet_type, std::vector<uint8_t> payload)
+      : packet_type_(packet_type), payload_(std::move(payload)) {}
+
+  virtual ~FirmwarePacket() = default;
+
+  FirmwarePacketType GetPacketType() const { return packet_type_; }
+
+  const ::bluetooth_hal::hci::HalPacket& GetPayload() const { return payload_; }
+
+ protected:
+  FirmwarePacketType packet_type_;
+  ::bluetooth_hal::hci::HalPacket payload_;
+};
+
+class SetupCommandPacket : public FirmwarePacket {
+ public:
+  SetupCommandPacket(SetupCommandType command_type,
+                     std::vector<uint8_t> payload)
+      : FirmwarePacket(FirmwarePacketType::kSetupCommand, std::move(payload)),
+        command_type_(command_type) {}
+
+  SetupCommandType GetCommandType() const { return command_type_; }
+
+ private:
+  SetupCommandType command_type_;
+};
+
+class DataPacket : public FirmwarePacket {
+ public:
+  DataPacket(DataType data_type, std::vector<uint8_t> payload)
+      : FirmwarePacket(FirmwarePacketType::kData, std::move(payload)),
+        data_type_(data_type) {}
+
+  DataType GetDataType() const { return data_type_; }
+
+ private:
+  DataType data_type_;
+};
+
+/**
+ * @brief Manages the configuration and loading process for firmware.
+ *
+ * This class provides an interface for loading firmware data, retrieving
+ * setup commands, and managing the state of the firmware loading process.
+ * It follows the Singleton design pattern to ensure a single point of
+ * access for firmware configuration.
+ */
+class FirmwareConfigLoader : public ConfigLoader {
+ public:
+  virtual ~FirmwareConfigLoader() = default;
+
+  virtual bool LoadConfig() override = 0;
+  virtual std::string DumpConfigToString() const override = 0;
+
+  /**
+   * @brief Resets the state of the firmware data loading process.
+   *
+   * This function should be called before attempting to load firmware data
+   * using GetNextFirmwareData(). It reinitializes the internal state
+   * of the firmware loading mechanism, allowing for a fresh start. If the
+   * firmware file cannot be opened, this function will return false.
+   *
+   * @note If ResetFirmwareDataLoadingState() is not called,
+   * GetNextFirmwareData() will always return null.
+   * @note ResetFirmwareDataLoadingState() = false indicates that the
+   * firmware file could not be opened.
+   *
+   * @return True if the state was successfully reset, false otherwise.
+   */
+  virtual bool ResetFirmwareDataLoadingState() = 0;
+
+  /**
+   * @brief Retrieves the next chunk of firmware data.
+   *
+   * This function returns the next available chunk of data from the
+   * firmware file. It should be called repeatedly until it returns null,
+   * indicating that all firmware data has been read.
+   *
+   * @note This function will always return null if
+   * ResetFirmwareDataLoadingState() has not been called or if it has
+   * returned false.
+   * @note After all data from the firmware file has been read, this
+   * function will return null. To read the data again, you must call
+   * ResetFirmwareDataLoadingState().
+   *
+   * @return An optional DataPacket containing the next chunk of firmware
+   *         data, or null if no more data is available or if the loading
+   *         state has not been reset.
+   */
+  virtual std::optional<DataPacket> GetNextFirmwareData() = 0;
+
+  /**
+   * @brief Retrieves a specific setup command packet.
+   *
+   * This function returns the setup command packet associated with the
+   * given command type.
+   *
+   * @param command_type The type of the setup command to retrieve.
+   *
+   * @return An optional const reference to the SetupCommandPacket, or
+   *         nullopt if no command is found for the given type.
+   */
+  virtual std::optional<std::reference_wrapper<const SetupCommandPacket>>
+  GetSetupCommandPacket(SetupCommandType command_type) const = 0;
+
+  /**
+   * @brief Retrieves the delay in ms for loading the minidriver.
+   *
+   * @return The delay in milliseconds.
+   */
+  virtual int GetLoadMiniDrvDelayMs() const = 0;
+
+  /**
+   * @brief Retrieves the delay in ms for launching RAM.
+   *
+   * @return The delay in milliseconds.
+   */
+  virtual int GetLaunchRamDelayMs() const = 0;
+
+  static FirmwareConfigLoader& GetLoader();
+
+  static void ResetLoader();
+
+ private:
+  static FirmwareConfigLoader* loader_;
+  static std::mutex loader_mutex_;
+};
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/hal_config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/hal_config_loader.h
new file mode 100644
index 0000000000..08e7012994
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/config/hal_config_loader.h
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <mutex>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/config/config_loader.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+class HalConfigLoader : public ConfigLoader {
+ public:
+  virtual ~HalConfigLoader() = default;
+
+  virtual bool LoadConfig() override = 0;
+  virtual std::string DumpConfigToString() const override = 0;
+
+  /**
+   * @brief Checks if fast download is enabled.
+   *
+   * @return true if fast download is enabled, false otherwise.
+   */
+  virtual bool IsFastDownloadEnabled() const = 0;
+
+  /**
+   * @brief Checks if SAR backoff is enabled for high-resolution timing.
+   *
+   * @return true if high-resolution SAR backoff is enabled, false otherwise.
+   */
+  virtual bool IsSarBackoffHighResolutionEnabled() const = 0;
+
+  /**
+   * @brief Gets the Bluetooth regulator on delay in Milliseconds.
+   *
+   * @return The delay in Milliseconds for Bluetooth regulator on.
+   */
+  virtual int GetBtRegOnDelayMs() const = 0;
+
+  /**
+   * @brief Retrieves the Bluetooth UART device port.
+   *
+   * @return A constant reference to the string representing the Bluetooth UART
+   * device port.
+   */
+  virtual const std::string& GetBtUartDevicePort() const = 0;
+
+  /**
+   * @brief Gets the priority of transport types for Bluetooth communication.
+   *
+   * @return A constant reference to a vector containing transport type
+   * priorities.
+   */
+  virtual const std::vector< ::bluetooth_hal::transport::TransportType>&
+  GetTransportTypePriority() const = 0;
+
+  /**
+   * @brief Checks if accelerated Bluetooth on is supported.
+   *
+   * @return true if accelerated Bluetooth on is supported, false otherwise.
+   */
+  virtual bool IsAcceleratedBtOnSupported() const = 0;
+
+  /**
+   * @brief Checks if thread dispatcher is enabled.
+   *
+   * @return true if the thread dispatcher is enabled, false otherwise.
+   */
+  virtual bool IsThreadDispatcherEnabled() const = 0;
+
+  /**
+   * @brief Checks if the Bluetooth power pin is controlled by the Low Power
+   * Processor (LPP).
+   *
+   * @return True if LPP controls the Bluetooth power pin, false otherwise.
+   */
+  virtual bool IsBtPowerControlledByLpp() const = 0;
+
+  /**
+   * @brief Retrieves a list of hardware stages where the Bluetooth power pin
+   * is not controlled by the Low Power Processor (LPP).
+   *
+   * @return A constant reference to a vector of strings, each representing a
+   * hardware stage name where LPP does not control the Bluetooth power pin.
+   */
+  virtual const std::vector<std::string>&
+  GetHwStagesWithoutLppControlBtPowerPin() const = 0;
+
+  /**
+   * @brief Gets a list of hwardware stages that firmware does not support.
+   *
+   * @return A constant reference to a vector of strings containing unsupported
+   * hardware stages.
+   */
+  virtual const std::vector<std::string>& GetFwUnsupportedHwStages() const = 0;
+
+  /**
+   * @brief Gets the minimum interval between two vendor transport crashes in
+   * seconds.
+   *
+   * This value represents the minimum allowable time between two consecutive
+   * vendor transport crashes. It can be used to filter out repeated crash
+   * events that occur too closely together to be considered independent
+   * failures.
+   *
+   * @return The minimum interval between two vendor transport crashes, in
+   * seconds.
+   */
+  virtual int GetVendorTransportCrashIntervalSec() const = 0;
+
+  /**
+   * @brief Checks if skipping suspend for host processor (hp) UART is
+   * supported.
+   *
+   * @return true if hp UART suspend skip is supported, false otherwise.
+   */
+  virtual bool IsHpUartSkipSuspendSupported() const = 0;
+
+  /**
+   * @brief Checks if energy controller logging is supported.
+   *
+   * @return true if energy controller logging is supported, false otherwise.
+   */
+  virtual bool IsEnergyControllerLoggingSupported() const = 0;
+
+  /**
+   * @brief Checks if bt hal restarts for recovery is supported.
+   *
+   * @return true if bt hal restarts for recovery is supported, false
+   * otherwise.
+   */
+  virtual bool IsBtHalRestartRecoverySupported() const = 0;
+
+  /**
+   * @brief Checks whether SAR is enabled for BLE non-connection mode.
+   *
+   * @return true if BLE non-connection SAR is enabled; false otherwise.
+   */
+  virtual bool IsBleNonConnectionSarEnabled() const = 0;
+
+  /**
+   * @brief Gets the kernel rx wakelock time in milliseconds.
+   *
+   * @return The rx wakelock time in milliseconds for kernel.
+   */
+  virtual int GetKernelRxWakelockTimeMilliseconds() const = 0;
+
+  /**
+   * @brief Checks whether Low Power Mode is supported for Bluetooth chip.
+   *
+   * @return true if Low Power Mode is supported; false otherwise.
+   */
+  virtual bool IsLowPowerModeSupported() const = 0;
+
+  /**
+   * @brief Checks whether transport fallback is enabled.
+   *
+   * @return true if fallback is enabled; false otherwise.
+   */
+  virtual bool IsTranportFallbackEnabled() const = 0;
+
+  /**
+   * @brief Checks whether full Bluetooth snoop log mode is enabled.
+   *
+   * @return true if full mode is on; false otherwise.
+   */
+  virtual bool IsBtSnoopLogFullModeOn() const = 0;
+
+  /**
+   * @brief Gets the UART baud rate for the given transport type.
+   *
+   * @param type The transport type.
+   *
+   * @return The UART baud rate.
+   */
+  virtual ::bluetooth_hal::uart::BaudRate GetUartBaudRate(
+      ::bluetooth_hal::transport::TransportType type) const = 0;
+
+  /**
+   * @brief Checks whether the current build is userdebug or eng.
+   *
+   * @return true if build is userdebug or eng; false otherwise.
+   */
+  virtual bool IsUserDebugOrEngBuild() const = 0;
+
+  /**
+   * @brief Gets the proc node path for enabling Low Power Mode (LPM).
+   *
+   * @return A constant reference to the string representing the LPM enable
+   * proc node path.
+   */
+  virtual const std::string& GetLpmEnableProcNode() const = 0;
+
+  /**
+   * @brief Gets the proc node path for waking from Low Power Mode (LPM).
+   *
+   * @return A constant reference to the string representing the LPM waking
+   * proc node path.
+   */
+  virtual const std::string& GetLpmWakingProcNode() const = 0;
+
+  /**
+   * @brief Gets the proc node path for controlling LPM wakelock.
+   *
+   * @return A constant reference to the string representing the LPM wakelock
+   * control proc node path.
+   */
+  virtual const std::string& GetLpmWakelockCtrlProcNode() const = 0;
+
+  /**
+   * @brief Gets the rfkill folder prefix.
+   *
+   * @return A constant reference to the string representing the rfkill folder
+   * prefix.
+   */
+  virtual const std::string& GetRfkillFolderPrefix() const = 0;
+
+  /**
+   * @brief Gets the rfkill type for Bluetooth.
+   * @return A constant reference to the string representing the rfkill type for
+   * Bluetooth.
+   */
+  virtual const std::string& GetRfkillTypeBluetooth() const = 0;
+
+  static HalConfigLoader& GetLoader();
+
+  static void ResetLoader();
+
+ private:
+  static HalConfigLoader* loader_;
+  static std::mutex loader_mutex_;
+};
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/bluetooth_activity.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/bluetooth_activity.h
new file mode 100644
index 0000000000..1926d00fa9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/bluetooth_activity.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <fstream>
+#include <list>
+#include <map>
+
+#include "bluetooth_hal/hal_packet.h"
+
+typedef struct {
+  uint16_t connect_handle; /* connection handle */
+  std::string bd_addr;     /* Remote BD address */
+  std::string timestamp;   /* Connection Created Timestamp */
+  std::string status;
+  std::string rcvd_event; /* connect or disconnect */
+} tCONN_DEVICE;
+
+struct bthal_wakelock_stat_t {
+  std::string start_timestamp;
+  std::string end_timestamp;
+  uint32_t duration;
+  uint32_t tx_packet_count;
+  uint64_t total_tx_packet_count;
+};
+
+struct ble_adv_activities_t {
+  std::string start_timestamp;
+  std::string end_timestamp;
+  uint32_t duration;
+  uint32_t le_adv_count;
+  uint64_t total_le_adv_count;
+};
+
+struct acl_data_activities_t {
+  std::string start_timestamp;
+  std::string end_timestamp;
+  uint16_t acl_conn_handle;
+  uint32_t duration;
+  uint32_t acl_data_count;
+  uint32_t acl_tx_data_count;
+  uint32_t total_acl_tx_data_count;
+  uint32_t acl_rx_data_count;
+  uint32_t total_acl_rx_data_count;
+  uint64_t total_acl_data_count;
+};
+
+struct pkt_activities_t {
+  std::string start_timestamp;
+  std::string end_timestamp;
+  uint32_t duration;
+  uint32_t pkt_count;
+  uint64_t total_pkt_count;
+  std::vector<acl_data_activities_t> acl_data;
+  std::vector<ble_adv_activities_t> ble_stat;
+  uint32_t hci_command_count;
+  uint32_t hci_event_count;
+  uint32_t num_cmpl_pkt_evt_count;
+  uint32_t delta;
+};
+
+// Bluetooth Activity Packet Types
+enum class BtActivityPacketType : uint8_t {
+  COMMAND = 1,
+  EVENT = 2,
+  ACL_TX_DATA = 3,
+  ACL_RX_DATA = 4,
+};
+
+namespace bluetooth_hal {
+namespace debug {
+
+class BtActivitiesLogger {
+ public:
+  void OnBluetoothEnabled();
+  void OnBluetoothDisabled();
+  void StartLogging();
+  void StopLogging();
+  void ForceUpdating();
+  bool HasConnectedDevices();
+  void LogActivities(BtActivityPacketType type,
+                     const ::bluetooth_hal::hci::HalPacket& data);
+  void DumpBtActivitiesStatistics(int fd);
+  void UpdateBthalWakelockStat(const bthal_wakelock_stat_t& stat);
+  void UpdateAclDataStat(const acl_data_activities_t& stat);
+  void UpdateLeAdvStat(const ble_adv_activities_t& stat);
+  static void UpdateHciPacketStat(const pkt_activities_t& stat);
+  static BtActivitiesLogger* GetInstacne();
+
+ private:
+  int kMaxRecordHistory = 512;
+  std::list<ble_adv_activities_t> ble_adv_activities_recorder_;
+  std::list<acl_data_activities_t> acl_data_activities_recorder_;
+  std::list<bthal_wakelock_stat_t> bthal_tx_wakelock_recorder_;
+  std::list<tCONN_DEVICE> connection_history_;
+  std::map<uint16_t, std::string> connected_bda_;
+  std::string bt_activities_pkt_log_path_;
+  static std::ofstream pkt_activity_ostream_;
+
+  static void LeAdvTimeout();
+  static void AclDataTimeout();
+  static void HciPacketTimeout();
+  void handle_ble_meta_event(const ::bluetooth_hal::hci::HalPacket& data);
+  void handle_connect_complete_event(
+      const ::bluetooth_hal::hci::HalPacket& data);
+  void handle_disconnect_complete_event(
+      const ::bluetooth_hal::hci::HalPacket& data);
+  void update_connect_disconnect_history(const tCONN_DEVICE& device);
+  void open_new_hci_packet_log_file();
+};
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/bluetooth_bqr.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/bluetooth_bqr.h
new file mode 100644
index 0000000000..77e5d96c7a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/bluetooth_bqr.h
@@ -0,0 +1,868 @@
+/*
+ * Copyright 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <fstream>
+
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+/* Bluetooth Quality Report VSE sub event */
+#define HCI_VSE_SUBCODE_BQR_SUB_EVT 0x58
+/* The version supports ISO packets start from v1.01(257)*/
+#define BQR_VERSION_V4 257
+/* BQR v1.03(259)*/
+#define BQR_VERSION_V5 259
+/* BQR v1.04(260)*/
+#define BQR_VERSION_V6 260
+/* BQR v1.05(261)*/
+#define BQR_VERSION_V7 261
+
+/*BQR Advance RF stats event: Extension_info*/
+#define BQR_RFSTATS_EXT_INFO_V6 1
+
+// Report ID definition.
+enum class BqrQualityReportId : uint8_t {
+  kMonitorMode = 0x01,
+  kApproachLsto = 0x02,
+  kA2dpAudioChoppy = 0x03,
+  kScoVoiceChoppy = 0x04,
+  kRootInflammation = 0x05,
+  kEnergyMonitoring = 0x06,
+  kLeAudioChoppy = 0x07,
+  kConnectFail = 0x08,
+  kAdvanceRfStats = 0x09,
+  kAdvanceRfStatsPeriodic = 0x0A,
+  kControllerHealthMonitor = 0x0B,
+  kControllerHealthMonitorPeriodic = 0x0C,
+  kVendorSpecificQuality = 0x10,
+  kLmpLlMessageTrace = 0x11,
+  kBtSchedulingTrace = 0x12,
+  kControllerDbgInfo = 0x13,
+  kChreDbgInfo = 0x14,
+  kVendorSpecificTrace = 0x20,
+};
+
+// Vendor Report ID definition.
+enum class VendorReportId : uint8_t {
+  kA2dpLatencyMeasurement = 0x00,
+  kHrMode = 0x01,
+};
+
+// Packet Type definition.
+enum class BqrPacketType : uint8_t {
+  kId = 0x01,
+  kNull,
+  kPoll,
+  kFhs,
+  kHv1,
+  kHv2,
+  kHv3,
+  kDv,
+  kEv3,
+  kEv4,
+  kEv5,
+  k2Ev3,
+  k2Ev5,
+  k3Ev3,
+  k3Ev5,
+  kDm1,
+  kDh1,
+  kDm3,
+  kDh3,
+  kDm5,
+  kDh5,
+  kAux1,
+  k2Dh1,
+  k2Dh3,
+  k2Dh5,
+  k3Dh1,
+  k3Dh3,
+  k3Dh5,
+  k4Dh1 = 0x20,
+  k4Dh3,
+  k4Dh5,
+  k8Dh1,
+  k8Dh3,
+  k8Dh5,
+  k4Ev3,
+  k4Ev5,
+  k8Ev3,
+  k8Ev5,
+  kIso = 0x51,
+};
+
+// BQR Link quality related event v3 and backward
+typedef struct __attribute__((__packed__)) {
+  // Vendor Specific Event
+  uint8_t vendor_specific_event;
+  // Parameter Total Length
+  uint8_t parameter_total_length;
+  // sub-event code
+  uint8_t sub_event;
+
+  // Common parameters of Link quality related event
+  // Quality report ID.
+  uint8_t quality_report_id;
+  // Packet type of the connection.
+  uint8_t packet_types;
+  // Connection handle of the connection.
+  uint16_t connection_handle;
+  // Performing Role for the connection.
+  uint8_t connection_role;
+  // Current Transmit Power Level for the connection. This value is the same as
+  // the controller's response to the HCI_Read_Transmit_Power_Level HCI command.
+  int8_t tx_power_level;
+  // Received Signal Strength Indication (RSSI) value for the connection. This
+  // value is an absolute receiver signal strength value.
+  int8_t rssi;
+  // Signal-to-Noise Ratio (SNR) value for the connection. It is the average
+  // SNR of all the channels used by the link currently.
+  uint8_t snr;
+  // Indicates the number of unused channels in AFH_channel_map.
+  uint8_t unused_afh_channel_count;
+  // Indicates the number of the channels which are interfered and quality is
+  // bad but are still selected for AFH.
+  uint8_t afh_select_unideal_channel_count;
+  // Current Link Supervision Timeout Setting.
+  // Unit: N * 0.3125 ms (1 Bluetooth Clock)
+  uint16_t lsto;
+  // Piconet Clock for the specified Connection_Handle. This value is the same
+  // as the controller's response to HCI_Read_Clock HCI command with the
+  // parameter "Which_Clock" of 0x01 (Piconet Clock).
+  // Unit: N * 0.3125 ms (1 Bluetooth Clock)
+  uint32_t connection_piconet_clock;
+  // The count of retransmission.
+  uint32_t retransmission_count;
+  // The count of no RX.
+  uint32_t no_rx_count;
+  // The count of NAK (Negative Acknowledge).
+  uint32_t nak_count;
+  // Timestamp of last TX ACK.
+  // Unit: N * 0.3125 ms (1 Bluetooth Clock)
+  uint32_t last_tx_ack_timestamp;
+  // The count of Flow-off (STOP).
+  uint32_t flow_off_count;
+  // Timestamp of last Flow-on (GO).
+  // Unit: N * 0.3125 ms (1 Bluetooth Clock)
+  uint32_t last_flow_on_timestamp;
+  // Buffer overflow count (how many bytes of TX data are dropped) since the
+  // last event.
+  uint32_t buffer_overflow_bytes;
+  // Buffer underflow count (in byte).
+  uint32_t buffer_underflow_bytes;
+} BqrLinkQualityEventGenericV3AndBackward;
+
+// BQR Link quality related event v4
+typedef struct __attribute__((__packed__))
+    : BqrLinkQualityEventGenericV3AndBackward {
+  // The number of packets that are sent out.
+  uint32_t tx_total_packets;
+  // The number of packets that don't receive an acknowledgment.
+  uint32_t tx_unacked_packets;
+  // The number of packets that are not sent out by its flush point.
+  uint32_t tx_flushed_packets;
+  // The number of packets that Link Layer transmits a CIS Data PDU in the last
+  // subevent of a CIS event.
+  uint32_t tx_last_subevent_packets;
+  // The number of received packages with CRC error since the last event.
+  uint32_t crc_error_packets;
+  // The number of duplicate(retransmission) packages that are received since
+  // the last event.
+  uint32_t rx_duplicate_packets;
+
+} BqrLinkQualityEventGenericV4;
+
+// BQR Link quality related event v5
+typedef struct __attribute__((__packed__))
+    : BqrLinkQualityEventGenericV3AndBackward {
+  // remote BD addr
+  uint16_t remote_addr[3];
+  // Cal_Failed_Item_Count
+  uint8_t call_failed_item_count;
+  // The number of packets that are sent out.
+  uint32_t tx_total_packets;
+  // The number of packets that don't receive an acknowledgment.
+  uint32_t tx_unacked_packets;
+  // The number of packets that are not sent out by its flush point.
+  uint32_t tx_flushed_packets;
+  // The number of packets that Link Layer transmits a CIS Data PDU in the last
+  // subevent of a CIS event.
+  uint32_t tx_last_subevent_packets;
+  // The number of received packages with CRC error since the last event.
+  uint32_t crc_error_packets;
+  // The number of duplicate(retransmission) packages that are received since
+  // the last event.
+  uint32_t rx_duplicate_packets;
+
+} BqrLinkQualityEventGenericV5;
+
+// BQR Link quality related event v6
+typedef struct __attribute__((__packed__)) : BqrLinkQualityEventGenericV5 {
+  // The number of unreceived packets is the same as the parameter of LE Read
+  // ISO Link Quality command.
+  uint32_t rx_unreceived_packets;
+  // Set to indicate coex activities are suspected to be involved when this
+  // report is generated
+  uint16_t coex_info_mask;
+
+} BqrLinkQualityEventGenericV6;
+
+// BQR Link quality related event for vendor specific parameters
+typedef struct __attribute__((__packed__))
+    : BqrLinkQualityEventGenericV3AndBackward {
+  // Vendor Specific parameters
+  uint32_t req_cnt;
+  uint32_t grant_cnt;
+  uint32_t defer_cnt;
+  uint32_t dur_invalid_req;
+  uint32_t dur_acl_req;
+  uint32_t dur_sco_req;
+  uint32_t dur_esco_req;
+  uint32_t dur_a2dp_req;
+  uint32_t dur_sniff_req;
+  uint32_t dur_pagescan_req;
+  uint32_t dur_inqscan_req;
+  uint32_t dur_page_req;
+  uint32_t dur_inq_req;
+  uint32_t dur_crit10_req;
+  uint32_t dur_crit11_req;
+  uint32_t dur_rssi_req;
+  uint32_t dur_inqscan_sco_req;
+  uint32_t dur_pagescan_sco_req;
+  uint32_t dur_tpoll_req;
+  uint32_t dur_ant_req;
+  uint32_t dur_crit17_req;
+  uint32_t dur_crit18_req;
+  uint32_t dur_crit19_req;
+  uint32_t dur_ulpadv_req;
+  uint32_t dur_ulpscan_req;
+  uint32_t dur_ulpinit_req;
+  uint32_t dur_ulpconn_req;
+  uint32_t dur_ulplmp_req;
+  uint32_t dur_escoretran_req;
+  uint32_t dur_tbfcscan_req;
+  uint32_t dur_tbfcbcn_req;
+  uint32_t dur_mac154_req;
+  uint32_t dur_pred_req;
+  uint32_t dur_misc_req;
+
+  int8_t rssi_for_core0;
+  int8_t rssi_for_core1;
+  int8_t tx_power_for_core0;
+  int8_t retx_power_for_core0;
+  int8_t tx_power_for_core1;
+  int8_t retx_power_for_core1;
+
+  uint8_t bf_state_for_tx;
+  uint8_t bf_state_for_retx;
+  uint8_t div_state_for_tx;
+  uint8_t div_state_for_retx;
+} BqrLinkQualityEventV3AndBackward;
+
+// BQR Link quality related event for vendor specific parameters
+typedef struct __attribute__((__packed__)) : BqrLinkQualityEventGenericV4 {
+  // Vendor Specific parameters
+  uint32_t req_cnt;
+  uint32_t grant_cnt;
+  uint32_t defer_cnt;
+  uint32_t dur_acl_req;
+  uint32_t dur_sco_req;
+  uint32_t dur_esco_req;
+  uint32_t dur_a2dp_req;
+  uint32_t dur_sniff_req;
+  uint32_t dur_pagescan_req;
+  uint32_t dur_inqscan_req;
+  uint32_t dur_page_req;
+  uint32_t dur_inq_req;
+  uint32_t dur_rssi_req;
+  uint32_t dur_ulpadv_req;
+  uint32_t dur_ulpscan_req;
+  uint32_t dur_ulpinit_req;
+  uint32_t dur_ulpconn_req;
+  uint32_t dur_pred_req;
+  uint32_t dur_misc_req;
+
+  int8_t rssi_for_core0;
+  int8_t rssi_for_core1;
+  int8_t tx_power_for_core0;
+  int8_t retx_power_for_core0;
+  int8_t tx_power_for_core1;
+  int8_t retx_power_for_core1;
+
+  uint8_t bf_state_for_tx;
+  uint8_t bf_state_for_retx;
+  uint8_t div_state_for_tx;
+  uint8_t div_state_for_retx;
+
+  uint32_t total_tx_pkts;
+  uint32_t total_tx_pkts_core0;
+  uint32_t total_tx_pkts_core1;
+  uint32_t total_tx_pkts_epa;
+  uint32_t total_tx_pkts_beamforming;
+
+  // A2DP offload EWP info
+  uint16_t a2dp_offload_ewp_types;
+  // The total length for payload length is 6 bytes
+  uint16_t i2s_payload_len[3];
+  // The total length for current sequence number is 12 bytes
+  uint16_t curSeqN[6];
+  uint32_t drop_pkt_cnt;
+  uint8_t exceed_mtu_cnt;
+  uint8_t out_of_seq_cnt;
+  uint8_t drop_pkt_time_evnt_cnt;
+  uint8_t unused;
+
+  uint32_t i2s_in_pkt_rxd;
+  uint32_t i2s_in_err_sync_fail;
+  uint32_t i2s_in_err_mem_fail;
+  uint32_t i2s_in_err_len_fail;
+  uint32_t i2s_out_pkt_txd;
+
+  uint8_t overall_link_quality;
+  uint8_t tx_link_quality;
+  uint8_t rx_link_quality;
+
+  uint32_t ema_tx_acked_pkt_cnt;
+  uint32_t ema_tx_unacked_pkt_cnt;
+  uint32_t ema_rx_good_pkt_cnt;
+  uint32_t ema_rx_bad_pkt_cnt;
+} BqrLinkQualityEventV4;
+
+// BQR Link quality related event for vendor specific parameters
+typedef struct __attribute__((__packed__)) : BqrLinkQualityEventGenericV5 {
+  // Vendor Specific parameters
+  uint32_t req_cnt;
+  uint32_t grant_cnt;
+  uint32_t defer_cnt;
+
+  uint32_t dur_acl_req;
+  uint32_t dur_sco_esco_req;
+  uint32_t dur_a2dp_req;
+  uint32_t dur_sniff_req;
+  uint32_t dur_pagescan_inqscan__req;
+  uint32_t dur_page_inq_req;
+  uint32_t dur_rssi_req;
+  uint32_t dur_ulpadv_req;
+  uint32_t dur_ulpscan_ulpinit_req;
+  uint32_t dur_ulpconn_req;
+  uint32_t dur_pred_req;
+  uint32_t dur_misc_req;
+
+  int8_t rssi_for_core0;
+  int8_t rssi_for_core1;
+  int8_t tx_power_for_core0;
+  int8_t retx_power_for_core0;
+  int8_t tx_power_for_core1;
+  int8_t retx_power_for_core1;
+
+  uint8_t bf_state_for_tx;
+  uint8_t bf_state_for_retx;
+  uint8_t div_state_for_tx;
+  uint8_t div_state_for_retx;
+
+  uint32_t total_tx_pkts;
+  uint32_t total_tx_pkts_core0;
+  uint32_t total_tx_pkts_core1;
+  uint32_t total_tx_pkts_epa;
+  uint32_t total_tx_pkts_beamforming;
+
+  // A2DP offload EWP info
+  uint16_t a2dp_offload_ewp_types;
+  // The total length for payload length is 6 bytes
+  uint16_t i2s_payload_len[3];
+  // The total length for current sequence number is 12 bytes
+  uint16_t curSeqN[6];
+  uint32_t drop_pkt_cnt;
+  uint8_t exceed_mtu_cnt;
+  uint8_t out_of_seq_cnt;
+  uint8_t drop_pkt_time_evnt_cnt;
+  uint8_t unused;
+
+  uint32_t i2s_in_pkt_rxd;
+  uint32_t i2s_in_err_sync_fail;
+  uint32_t i2s_in_err_mem_fail;
+  uint32_t i2s_in_err_len_fail;
+  uint32_t i2s_out_pkt_txd;
+
+  uint8_t overall_link_quality;
+  uint8_t tx_link_quality;
+  uint8_t rx_link_quality;
+
+  uint32_t ema_tx_acked_pkt_cnt;
+  uint32_t ema_tx_unacked_pkt_cnt;
+  uint32_t ema_rx_good_pkt_cnt;
+  uint32_t ema_rx_bad_pkt_cnt;
+
+  uint8_t cis_sdulist_queue_length;
+  uint8_t cis_sdulist_overflow_cnt;
+  uint8_t rx_mrc_status;
+} BqrLinkQualityEventV5;
+
+// BQR Link quality related event for vendor specific parameters
+typedef struct __attribute__((__packed__)) : BqrLinkQualityEventGenericV6 {
+  // Vendor Specific parameters
+  uint32_t req_cnt;
+  uint32_t grant_cnt;
+  uint32_t defer_cnt;
+
+  uint32_t dur_acl_req;
+  uint32_t dur_sco_esco_req;
+  uint32_t dur_a2dp_req;
+  uint32_t dur_sniff_req;
+  uint32_t dur_pagescan_inqscan__req;
+  uint32_t dur_page_inq_req;
+  uint32_t dur_rssi_req;
+  uint32_t dur_ulpadv_req;
+  uint32_t dur_ulpscan_ulpinit_req;
+  uint32_t dur_ulpconn_req;
+  uint32_t dur_pred_req;
+  uint32_t dur_misc_req;
+
+  int8_t rssi_for_core0;
+  int8_t rssi_for_core1;
+  int8_t tx_power_for_core0;
+  int8_t retx_power_for_core0;
+  int8_t tx_power_for_core1;
+  int8_t retx_power_for_core1;
+
+  uint8_t bf_state_for_tx;
+  uint8_t bf_state_for_retx;
+  uint8_t div_state_for_tx;
+  uint8_t div_state_for_retx;
+
+  uint32_t total_tx_pkts;
+  uint32_t total_tx_pkts_core0;
+  uint32_t total_tx_pkts_core1;
+  uint32_t total_tx_pkts_epa;
+  uint32_t total_tx_pkts_beamforming;
+
+  // A2DP offload EWP info
+  uint16_t a2dp_offload_ewp_types;
+  // The total length for payload length is 6 bytes
+  uint16_t i2s_payload_len[3];
+  // The total length for current sequence number is 12 bytes
+  uint16_t curSeqN[6];
+  uint32_t drop_pkt_cnt;
+  uint8_t exceed_mtu_cnt;
+  uint8_t out_of_seq_cnt;
+  uint8_t drop_pkt_time_evnt_cnt;
+  uint8_t unused;
+
+  uint32_t i2s_in_pkt_rxd;
+  uint32_t i2s_in_err_sync_fail;
+  uint32_t i2s_in_err_mem_fail;
+  uint32_t i2s_in_err_len_fail;
+  uint32_t i2s_out_pkt_txd;
+
+  uint8_t overall_link_quality;
+  uint8_t tx_link_quality;
+  uint8_t rx_link_quality;
+
+  uint32_t ema_tx_acked_pkt_cnt;
+  uint32_t ema_tx_unacked_pkt_cnt;
+  uint32_t ema_rx_good_pkt_cnt;
+  uint32_t ema_rx_bad_pkt_cnt;
+
+  uint8_t cis_sdulist_queue_length;
+  uint8_t cis_sdulist_overflow_cnt;
+  uint8_t rx_mrc_status;
+} BqrLinkQualityEventV6;
+
+// Vendor BQR Vendor Specific Trace Event - A2DP Latency Measurement
+typedef struct __attribute__((__packed__)) {
+  // Unit: BT Slot
+  // Host packet reception time offset. This is the time offset from
+  // Base_Timestamp logged in this event
+  uint16_t packet_entry_time_offset;
+  // The first packet transmission by the controller. The delay measured between
+  // Packet_Entry_Time_Offset and First_Packet_Transmit_Delay.
+  uint16_t first_packet_transmit_delay;
+  // Time until the remote device responds with the first ACK or NACK. This is
+  // the delay measured between Packet_Entry_Time_Offset and
+  // First_Packet_Ack_Delay.
+  uint16_t first_packet_ack_delay;
+  // Time until the packet was either successfully transmitted or flushed by the
+  // controller. Delay measure between Packet_Entry_Time_Offset and
+  // Final_Packet_Transmit_Delay.
+  uint16_t final_packet_transmit_delay;
+} A2DPLatency;
+
+typedef struct __attribute__((__packed__)) {
+  // Vendor Specific Event
+  uint8_t vendor_specific_event;
+  // Parameter Total Length
+  uint8_t parameter_total_length;
+  // Sub-event code
+  uint8_t sub_event;
+
+  // Quality report ID.
+  uint8_t quality_report_id;
+
+  // Vendor Specific Parameters
+  uint8_t vendor_report_id;
+  // Connection handle of the connection for which the latency report is sent
+  uint16_t conn_handle;
+  // Number of Packets for which the latency is reported in this event
+  uint8_t num_packets_logged;
+  // Timestamp of the first packet logged in this event. Unit: BT CLK
+  uint32_t base_timestamp;
+  A2DPLatency a2dp_latencies[];
+} BqrVsteA2dpLatencyMeasurement;
+
+typedef struct __attribute__((__packed__)) {
+  // Vendor Specific Event
+  uint8_t vendor_specific_event;
+  // Parameter Total Length
+  uint8_t parameter_total_length;
+  // Sub-event code
+  uint8_t sub_event;
+
+  // Quality report ID.
+  uint8_t quality_report_id;
+
+  // Vendor Specific quality event id
+  uint8_t vendor_specific_quality_event_id;
+  // Connection handle of the connection for which the latency report is sent
+  uint16_t conn_handle;
+
+} BqrVendorSpecificEventGeneric;
+
+typedef struct __attribute__((__packed__)) : BqrVendorSpecificEventGeneric {
+  // Some simple statistic for Rx
+  uint32_t rx_null_cnt;
+  uint32_t rx_poll_cnt;
+  uint32_t rx_dm1_cnt;
+
+  // Some simple statistic for Tx
+  uint32_t tx_null_cnt;
+  uint32_t tx_poll_cnt;
+  uint32_t tx_dm1_cnt;
+
+  // Packet type statistic for Rx
+  uint32_t rx_hr_2dh1;
+  uint32_t rx_hr_4dh1;
+  uint32_t rx_hr_8dh1;
+  uint32_t rx_hr_2dh3;
+  uint32_t rx_hr_4dh3;
+  uint32_t rx_hr_8dh3;
+  uint32_t rx_hr_2dh5;
+  uint32_t rx_hr_4dh5;
+  uint32_t rx_hr_8dh5;
+
+  // Packet type statistic for Tx
+  uint32_t tx_hr_2dh1;
+  uint32_t tx_hr_4dh1;
+  uint32_t tx_hr_8dh1;
+  uint32_t tx_hr_2dh3;
+  uint32_t tx_hr_4dh3;
+  uint32_t tx_hr_8dh3;
+  uint32_t tx_hr_2dh5;
+  uint32_t tx_hr_4dh5;
+  uint32_t tx_hr_8dh5;
+} BqrVendorSpecificEventHRMode;
+
+// BQR Link Advance RF stats event
+typedef struct __attribute__((__packed__)) {
+  // Vendor Specific Event
+  uint8_t event;
+  // Parameter Total Length
+  uint8_t sub_code;
+  // sub-event code
+  uint8_t event_type;
+
+  // Quality_Report_Id = 0x09 or 0x0a
+  uint8_t report_id;
+  // Extension for Further usage = 0x01 for BQRv6
+  uint8_t ext_info;
+
+  // time period (ms)
+  uint32_t tm_period;
+
+  // Stats for TX Power
+  uint32_t tx_pw_ipa_bf;
+  uint32_t tx_pw_epa_bf;
+  uint32_t tx_pw_ipa_div;
+  uint32_t tx_pw_epa_div;
+
+  // Stats for RSSI_chain
+  uint32_t rssi_ch_50;
+  uint32_t rssi_ch_50_55;
+  uint32_t rssi_ch_55_60;
+  uint32_t rssi_ch_60_65;
+  uint32_t rssi_ch_65_70;
+  uint32_t rssi_ch_70_75;
+  uint32_t rssi_ch_75_80;
+  uint32_t rssi_ch_80_85;
+  uint32_t rssi_ch_85_90;
+  uint32_t rssi_ch_90;
+
+  // Stats for RSSI_delta
+  uint32_t rssi_delta_2_down;
+  uint32_t rssi_delta_2_5;
+  uint32_t rssi_delta_5_8;
+  uint32_t rssi_delta_8_11;
+  uint32_t rssi_delta_11_up;
+} BqrAdvanceRFStatsEvent;
+
+// BQR Controller Health Status Event
+typedef struct __attribute__((__packed__)) {
+  // Vendor Specific Event
+  uint8_t event;
+  // Parameter Total Length
+  uint8_t sub_code;
+  // sub-event code
+  uint8_t event_type;
+
+  // Quality_Report_Id = 0x0B
+  uint8_t report_id;
+  // Total count of packets sent from Host to Controller over HCI transport.
+  // This field is employed for the purpose of debugging HCI (e.g., UART)
+  // issues. Behavior: the counters reset when the controller received HCI
+  // reset.
+  uint32_t packet_count_host_to_controller;
+
+  // Total count of HCI + Spinel Event packets sent to Host.
+  // This field is employed for the purpose of debugging HCI (e.g., UART)
+  // issues. Behavior: the counters reset when the controller received HCI
+  // reset.
+  uint32_t packet_count_controller_to_host;
+
+  // Length of the last HCI packet received from Host UART.
+  // Note: HCI Packet Length max 2 octet (Include HCI, ACL, SCO, ISO)
+  uint16_t last_packet_length_controller_to_host;
+
+  // Length of the last HCI packet sent to Host UART.
+  // Note: HCI Packet Length max 2 octet (Include HCI, ACL, SCO, ISO)
+  uint16_t last_packet_length_host_to_controller;
+
+  // The aggregate tally of BT_Wake pin assertions by the Host entity.
+  // This field serves as a diagnostic tool for debugging power-related issues.
+  // Behavior: the counters reset when the controller received HCI reset.
+  uint32_t total_bt_wake_count;
+
+  // Aggregate calculation of Host_Wake pin assertions initiated by the
+  // Controller. This field serves as a diagnostic tool for debugging
+  // power-related issues. Behavior: the counters reset when the controller
+  // received HCI reset.
+  uint32_t total_host_wake_count;
+
+  // Last Timestamp when Host Asserted BT_Wake Pin.This field is implemented for
+  // the purpose of debugging Power issues.
+  uint32_t last_bt_wake_timestamp;
+
+  // The most recent timestamp when the controller asserted the Host_Wake pin.
+  // This field is used for debugging power issues.
+  uint32_t last_host_wake_timestamp;
+
+  // Timestamp indicating the completion of the most recent HCI Reset.
+  // This field is utilized for the express purpose of facilitating the
+  // resolution of timing-related issues. It should serve as the initial
+  // recording point against which all other items are referenced.
+  uint32_t reset_timestamp;
+
+  // The present time when this event is generated.
+  // This field is utilized for the purpose of troubleshooting timing
+  // discrepancies. It should serve as the trigger recording point that all
+  // other elements reference.
+  uint32_t current_timestamp;
+
+  // Flag to denote that this health status event is generated by the
+  // controller as an early warning of watch dog expiration.
+  // The current timestamp serves to indicate the time of occurrence.
+  uint32_t is_watchdog_timer_about_to_expire;
+
+  // Bit 0 - Reserved
+  // Bit 1 - WL 2G Radioactive: Set to indicate WLAN 2G Radio is active.
+  // Bit 2 - WL 2G Connected: Set to indicate WLAN 2G Radio is active and
+  // connected. Bit 3 - WL 5G/6G Radioactive: Set to indicate WLAN 5G/6G Radio
+  // is active. Bit 4 - Thread Radioactive status Bit 5-15 - Reserved
+  uint16_t coex_status_mask;
+
+  // Total link count of BR/EDR/LE in Active state.
+  uint8_t total_links_br_edr_le_active;
+
+  // Total link count of BR/EDR in Sniff/Idle state(a.k.a link layer power
+  // saving mode).
+  uint8_t total_links_br_edr_sniff;
+
+  // Total link count of ISO for le audio part.
+  uint8_t total_links_cis;
+
+  // Indicator to check if the SCO link is currently activated.
+  uint8_t is_sco_active;
+} BqrControllerHealthMonitorEvent;
+
+// Get a string representation of the Quality Report ID.
+//
+// @param quality_report_id The quality report ID to convert.
+// @return a string representation of the Quality Report ID.
+std::string QualityReportIdToString(uint8_t quality_report_id);
+
+// Parse the Link Quality related event.
+//
+// @param packet A pointer to the Vendor Specific Event packet.
+void ParseLinkQualityRelatedEvt(const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Update the controller capability
+//
+// @param packet A pointer to the LE Get Vendor Capabilities packet.
+void updateControllerCapability(const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Parse the vendor specific trace event.
+//
+// @param packet A pointer to the Vendor Specific Event packet.
+void ParseVendorSpecificTraceEvt(const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Parse the vendor specific trace event: A2DP latency measurement.
+//
+// @param packet A pointer to the Vendor Specific Event A2DP latency measurement
+// packet.
+void ParseA2DPLatencyMeasurement(const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Parse the vendor specific quality event.
+//
+// @param packet A pointer to the Vendor Specific Event packet.
+void ParseVendorSpecificQualityEvt(
+    const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Parse the vendor specific quality event: HR Mode statistic.
+//
+// @param packet A pointer to the Vendor Specific Event HR Mode statistic.
+// packet.
+void ParseHRModeStatisticLog(const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Parse the Advance RF Stats event.
+//
+// @param packet A pointer to the Advance RF Stats event packet.
+void ParseAdvanceRFStatsEvt(const ::bluetooth_hal::hci::HalPacket& packet);
+
+// Parse the Controller Health Monitor event.
+//
+// @param packet A pointer to the Controller Health Monitor event packet.
+void ParseControllerHealthMonitorEvt(
+    const ::bluetooth_hal::hci::HalPacket& health_monitor_event);
+
+// BQR Energy Monitoring Event Packet
+typedef struct __attribute__((__packed__)) {
+  // Average Current Consumption
+  uint16_t average_current_consumption;
+  // Idle Total Time
+  uint32_t idle_total_time;
+  // Idle State Enter Count
+  uint32_t idle_state_enter_count;
+  // Active Total Time
+  uint32_t active_total_time;
+  // Active State Enter Count
+  uint32_t active_state_enter_count;
+  // BR_EDR Tx Total Time
+  uint32_t br_edr_tx_total_time;
+  // BR_EDR Tx State Enter Count
+  uint32_t br_edr_tx_state_enter_count;
+  // BR_EDR_Tx_Average_Power_Level
+  int8_t br_edr_tx_average_power_level;
+  // BR_EDR_Rx_Total_Time
+  uint32_t br_edr_rx_total_time;
+  // BR_EDR_Rx_State_Enter_Count
+  uint32_t br_edr_rx_state_enter_count;
+  // LE_Tx_Total_Time
+  uint32_t le_tx_total_time;
+  // LE_Tx_State_Enter_Count
+  uint32_t le_tx_state_enter_count;
+  // LE_Tx_Average_Power_Level
+  int8_t le_tx_average_power_level;
+  // LE_Rx_Total_Time
+  uint32_t le_rx_total_time;
+  // LE_Rx_State_Enter_Count
+  uint32_t le_rx_state_enter_count;
+} BqrEnergyMonitoringEvent;
+
+// BQR Energy Monitoring Event Packet
+typedef struct __attribute__((__packed__)) : BqrEnergyMonitoringEvent {
+  // Report Time Duration (Total Time: ms)
+  uint32_t report_time_duration;
+  // RX Active One Chain Time (ms)
+  uint32_t rx_active_one_chain_time;
+  // RX Active Two Chain Time (ms)
+  uint32_t rx_active_two_chain_time;
+  // TX iPA Active One Chain Time (ms)
+  uint32_t tx_ipa_active_one_chain_time;
+  // TX iPA  Active Two Chain Time (ms)
+  uint32_t tx_ipa_active_two_chain_time;
+  // TX xPA Active One Chain Time (ms)
+  uint32_t tx_xpa_active_one_chain_time;
+  // TX xPA  Active Two Chain Time (ms)
+  uint32_t tx_xpa_active_two_chain_time;
+} BqrEnergyMonitoringEventV6;
+
+struct bt_energy_sector_t {
+  std::string timestamp;
+  BqrEnergyMonitoringEvent entries;
+};
+
+struct bt_energy_sectorv6_t {
+  std::string timestamp;
+  BqrEnergyMonitoringEventV6 entries;
+};
+
+class BtBqrEnergyRecoder {
+ public:
+  static BtBqrEnergyRecoder* GetInstacne();
+  void ParseBqrEnergyMonitorEvt(
+      const ::bluetooth_hal::hci::HalPacket& energy_event);
+  void StartLogging();
+  void StopLogging();
+
+ private:
+  uint16_t kMaxPacketsPerFile_ = 7200;
+  uint16_t packet_counter_ = 0;
+  std::string batt_level_{};
+  std::string bt_activities_bqr_energy_log_path_;
+  std::ofstream bqr_energy_activity_ostream_;
+  void open_new_energy_log_file();
+  void update_bqr_energy_report(bt_energy_sector_t& stat);
+  void update_bqr_energy_report(bt_energy_sectorv6_t& stat);
+};
+
+enum class BqrCmdScenario { ENABLE_BQR_BT_OFF = 0, DISABLE_BQR };
+
+enum class BqrReportAction : uint8_t {
+  kAdd = 0x00,
+  kDelete = 0x01,
+  kClear = 0x02,
+  kQuery = 0x03,
+};
+
+typedef struct {
+  BqrReportAction report_action;
+  uint32_t quality_event_mask;
+  uint16_t minimum_report_interval_ms;
+  uint32_t vnd_quality_mask;
+  uint32_t vnd_trace_mask;
+  uint32_t report_interval_multiple;
+} BqrV6CmdConfiguration;
+
+constexpr uint16_t kBqrHciCmdOpCode = 0xfd5e;
+constexpr uint8_t kBqrV6CmddSize = 0x13;
+
+std::vector<uint8_t> GetBqrV6Cmd(BqrCmdScenario type);
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/command_error_code.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/command_error_code.h
new file mode 100644
index 0000000000..80236c707a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/command_error_code.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+namespace bluetooth_hal {
+namespace debug {
+
+/* HCI connect/disconnect event result codes to human readable strings. */
+static const char* result_code_strings[] = {
+    "Success",                                                   // 0x00
+    "Unknown HCI Command",                                       // 0x01
+    "Unknown Connection Identifier",                             // 0x02
+    "Hardware Failure",                                          // 0x03
+    "Page Timeout",                                              // 0x04
+    "Authentication Failure",                                    // 0x05
+    "PIN or Key Missing",                                        // 0x06
+    "Memory Capacity Exceeded",                                  // 0x07
+    "Connection Timeout",                                        // 0x08
+    "Connection Limit Exceeded",                                 // 0x09
+    "Synchronous Connection Limit To A Device Exceeded",         // 0x0A
+    "Connection Already Exists",                                 // 0x0B
+    "Command Disallowed",                                        // 0x0C
+    "Connection Rejected due to Limited Resources",              // 0x0D
+    "Connection Rejected Due To Security Reasons",               // 0x0E
+    "Connection Rejected due to Unacceptable BD_ADDR",           // 0x0F
+    "Connection Accept Timeout Exceeded",                        // 0x10
+    "Unsupported Feature or Parameter Value",                    // 0x11
+    "Invalid HCI Command Parameters",                            // 0x12
+    "Remote User Terminated Connection",                         // 0x13
+    "Remote Device Terminated Connection due to Low Resources",  // 0x14
+    "Remote Device Terminated Connection due to Power Off",      // 0x15
+    "Connection Terminated By Local Host",                       // 0x16
+    "Repeated Attempts",                                         // 0x17
+    "Pairing Not Allowed",                                       // 0x18
+    "Unknown LMP PDU",                                           // 0x19
+    "Unknown result code"};                                      // 0x1A
+
+/*******************************************************************************
+ *
+ * Function         GetResultString
+ *
+ * Description      This function returns the human-readable string for a given
+ *                  result code.
+ *
+ * Returns          a pointer to the human-readable string for the given result.
+ *
+ ******************************************************************************/
+const char* GetResultString(const uint8_t result_code) {
+  if (result_code > 0x19) {
+    return result_code_strings[0x1A];
+  }
+
+  return result_code_strings[result_code];
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/debug_central.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/debug_central.h
new file mode 100644
index 0000000000..42c670bc34
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/debug_central.h
@@ -0,0 +1,369 @@
+/*
+ * Copyright 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <signal.h>
+
+#include <list>
+#include <map>
+#include <sstream>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+
+// Code Enter Point
+enum class AnchorType : uint8_t {
+  // For DURATION_TRACKER.
+  BTHAL_INIT = 0,
+  BTHAL_INIT_OUT,
+  BTHAL_PERFORM_INIT,
+  BTHAL_PERFORM_INIT_OUT,
+  SEND_HCI_CMD,
+  SEND_HCI_CMD_OUT,
+  SEND_ACL_DAT,
+  SEND_ACL_DAT_OUT,
+  SEND_SCO_DAT,
+  SEND_SCO_DAT_OUT,
+  SEND_ISO_DAT,
+  SEND_ISO_DAT_OUT,
+  THREAD_SEND_DAT_UPLINK,
+  THREAD_SEND_DAT_DOWNLINK,
+  THREAD_START_DAEMON,
+  THREAD_STOP_DAEMON,
+  THREAD_ACCEPT_CLIENT,
+  THREAD_DADEMON_CLOSED,
+  THREAD_SOCKET_FILE_DELETED,
+  THREAD_CLIENT_ERROR,
+  THREAD_CLIENT_CONNECT,
+  THREAD_HARDWARE_RESET,
+  CALLBACK_HCI_EVT,
+  CALLBACK_HCI_EVT_OUT,
+  CALLBACK_HCI_ACL,
+  CALLBACK_HCI_ACL_OUT,
+  CALLBACK_HCI_SCO,
+  CALLBACK_HCI_SCO_OUT,
+  CALLBACK_HCI_ISO,
+  CALLBACK_HCI_ISO_OUT,
+  USERIAL_OPEN,
+  USERIAL_OPEN_OUT,
+  USERIAL_CLOSE,
+  USERIAL_CLOSE_OUT,
+  POWER_CTRL,
+  POWER_CTRL_OUT,
+  HCI_RESET,
+  HCI_RESET_OUT,
+  CHANGE_BAUDRATE,
+  CHANGE_BAUDRATE_OUT,
+  FW_DOWNLOAD,
+  FW_DOWNLOAD_OUT,
+  READ_LOCAL_NAME,
+  READ_LOCAL_NAME_OUT,
+  // For ONE_TIME_LOGGER.
+  SERVICE_DIED = 46,
+  BTHAL_THD_INIT,
+  BTHAL_THD_REINIT,
+  BTHAL_CLOSE,
+  BTHAL_PERFORM_CLOSE,
+  BIG_HAMMER,
+  ACTIVITY_WATCHER_ERR,
+  BT_REDARY,
+  BTHAL_INIT_ERR,
+  BT_PREPARE,
+  BT_INIT,
+  USERIAL_INFO,
+  USERIAL_OPEN_ERR,
+  USERIAL_TTY_OPEN,
+  USERIAL_READY,
+  HCI_SOCKET,
+  POWER_STATE,
+  BAUDRATE_ERR,
+  LOCAL_NAME_ERR,
+  FW_FAST_DNLD,
+  FW_DNLD_ERR,
+  FW_DNLD_SELECT,
+  FW_DNLD_DONE,
+  BT_CHIP_ID,
+  BT_CMD_ERR,
+  WAKELOCK_ERR,
+  WAKELOCK_DUP,
+  WAKELOCK_ACQUIRE,
+  WAKELOCK_RELEASE,
+  WAKELOCK_VOTE,
+  WAKELOCK_UNVOTE,
+  WATCHDOG,
+  LPM_WAKEUP_ERR,
+  LPM_WAKEUP,
+  LPM_SUSPEND,
+  LPM_WAKEUP_TIMEOUT,
+  LPM_SETUP_ERR,
+  LPM_ENABLE,
+  LPM_DISABLE,
+  LPM_CLOSE_ERR,
+  BT_SHUTDOWN,
+  BTHAL_USERIAL_TYPE_SELECT,
+  H4_TX_ERR,
+  H4_RX_ERR,
+  H4_TX_CMD,
+  H4_RX_EVT,
+  BQR_ERR_MSG,
+  HW_ERR_EVT,
+  DEBUG_INFO,
+  BTHAL_EXT_INJECT,
+};
+
+/*
+ * ONE_TIME_LOGGER is used to record HAL log messages in any places in codes and
+ * send to DebugCentral.
+ * @deprecated
+ */
+#define ONE_TIME_LOGGER(type, fmt, ...)                \
+  do {                                                 \
+    char log[128] = {0};                               \
+    std::snprintf(log, sizeof(log), fmt, __VA_ARGS__); \
+    DebugCentral::Get()->UpdateRecord(type, log);      \
+  } while (0)
+
+/*
+ * DURATION_TRACKER is used to log the Enter and Exit of a HAL function and
+ * send to DebugCentral.
+ */
+#ifdef UNIT_TEST
+#define DURATION_TRACKER(type, anchor)
+#else
+#define DURATION_TRACKER(type, anchor)    \
+  ::bluetooth_hal::debug::DebugAnchor a = \
+      ::bluetooth_hal::debug::DebugCentral::Get()->SetAnchor(type, anchor);
+#endif
+
+/*
+ * ANCHOR_LOG* is used to log a message with a specific severity level
+ * and send it to DebugCentral. It takes an anchor type as input.
+ */
+#define ANCHOR_LOG(type)                            \
+  ([](auto&& logger) -> auto&& { return logger; })( \
+      ::bluetooth_hal::debug::LogHelper(type, ::android::base::VERBOSE))
+#define ANCHOR_LOG_DEBUG(type)                      \
+  ([](auto&& logger) -> auto&& { return logger; })( \
+      ::bluetooth_hal::debug::LogHelper(type, ::android::base::DEBUG))
+#define ANCHOR_LOG_INFO(type)                       \
+  ([](auto&& logger) -> auto&& { return logger; })( \
+      ::bluetooth_hal::debug::LogHelper(type, ::android::base::INFO))
+#define ANCHOR_LOG_WARNING(type)                    \
+  ([](auto&& logger) -> auto&& { return logger; })( \
+      ::bluetooth_hal::debug::LogHelper(type, ::android::base::WARNING))
+#define ANCHOR_LOG_ERROR(type)                      \
+  ([](auto&& logger) -> auto&& { return logger; })( \
+      ::bluetooth_hal::debug::LogHelper(type, ::android::base::ERROR))
+
+namespace bluetooth_hal {
+namespace debug {
+
+class DebugCentral;
+
+class DebugAnchor {
+ public:
+  DebugAnchor(AnchorType type, const std::string& anchor,
+              DebugCentral& debugcentral);
+
+  // Manually release the auto debug anchor.
+  ~DebugAnchor();
+
+ private:
+  DebugCentral* debugcentral_;
+  std::string anchor_;
+  AnchorType type_;
+};
+
+// BQR root inflammation vendor error codes
+enum class BqrErrorCode : uint8_t {
+  UART_PARSING = 0x01,
+  UART_INCOMPLETE_PACKET = 0x02,
+  FIRMWARE_CHECKSUM = 0x03,
+  FIRMWARE_HARD_FAULT = 0x10,
+  FIRMWARE_MEM_MANAGE_FAULT = 0x11,
+  FIRMWARE_BUS_FAULT = 0x12,
+  FIRMWARE_USAGE_FAULT = 0x13,
+  FIRMWARE_WATCHDOG_TIMEOUT = 0x14,
+  FIRMWARE_ASSERTION_FAILURE = 0x15,
+  FIRMWARE_MISCELLANEOUS = 0x16,
+  FIRMWARE_HOST_REQUEST_DUMP = 0x17,
+  FIRMWARE_MISCELLANEOUS_MAJOR_FAULT = 0x20,
+  FIRMWARE_MISCELLANEOUS_CRITICAL_FAULT = 0x21,
+  FIRMWARE_THREAD_GENERIC_ERROR = 0x40,
+  FIRMWARE_THREAD_INVALID_FRAME = 0x41,
+  FIRMWARE_THREAD_INVALID_PARAM = 0x42,
+  FIRMWARE_THREAD_UNSUPPORTED_FRAME = 0x43,
+  SOC_BIG_HAMMER_FAULT = 0x7F,
+  HOST_RX_THREAD_STUCK = 0x80,
+  HOST_HCI_COMMAND_TIMEOUT = 0x81,
+  HOST_INVALID_HCI_EVENT = 0x82,
+  HOST_UNIMPLEMENTED_PACKET_TYPE = 0x83,
+  HOST_HCI_H4_TX_ERROR = 0x84,
+  HOST_OPEN_USERIAL = 0x90,
+  HOST_POWER_UP_CONTROLLER = 0x91,
+  HOST_CHANGE_BAUDRATE = 0x92,
+  HOST_RESET_BEFORE_FW = 0x93,
+  HOST_DOWNLOAD_FW = 0x94,
+  HOST_RESET_AFTER_FW = 0x95,
+  HOST_BDADDR_FAULT = 0x96,
+  HOST_OPEN_COEX_DEVICE_ERROR = 0x97,
+  HOST_ACCEL_BT_INIT_FAILED = 0x98,
+  HOST_ACCEL_BT_SHUTDOWN_FAILED = 0x99,
+  CHRE_ARBITRATOR_ERR_BASE = 0xE0,
+  CHRE_ARBITRATOR_UNIMPLEMENTED_PACKET = 0xE0,
+  CHRE_ARBITRATOR_INVALID_PACKET_SIZE = 0xE1,
+};
+
+class DebugCentral {
+ public:
+  /*
+   * Get a singleton static instance of the debug central.
+   */
+  static DebugCentral* Get();
+
+  /*
+   * Get the stack callback function
+   */
+  void Prepare(::bluetooth_hal::hci::HalPacketCallback notify_cb) {
+    notify_cb_ = notify_cb;
+  }
+
+#if 0
+  /*
+   * Start to monitor error event
+   */
+  void StartMonitor(hci::HciFlowControl* handle);
+
+  /*
+   * Stop to monitor error event
+   */
+  void StopMonitor();
+#endif
+
+  /*
+   * Invokes when bugreport is triggered, dump all information to the debug fd.
+   */
+  void Dump(int fd);
+
+  /*
+   * Upadte if there is a client connect bthal.
+   */
+  void HasClientConnectWith(bool has_client);
+
+  /*
+   * set bluetooth serial port information.
+   */
+  void SetBtUartDebugPort(const std::string& uart_port);
+
+  /*
+   * Write debug message to logger.
+   */
+  void UpdateRecord(AnchorType type, const std::string& anchor);
+
+  /*
+   * Notify BtHal have detected error, we will collect debug log first then and
+   * report eror code to stack via BQR root inflammation event
+   */
+  void ReportBqrError(BqrErrorCode error, std::string extra_info);
+
+  /*
+   * Detect if current HCI command is host get controller debug dump opcode ?
+   */
+  bool IsControllerDebugDumpOpcode(const ::bluetooth_hal::hci::HalPacket& data);
+
+  /*
+   * Two kinds of debug anchor are supported to collect log messages.
+   * is_lifetime : true - we handle the debug anchor's life cycle,
+   * add [ Set] message in the constructor and [Free] message in the destructor
+   * to record the enter and exit timestamp of an invoked function.
+   * Usually, we put this kind debug anchor in begin of function, the purpose
+   * of this debug anchor usage is record time-consuming of a function.
+   * [Example]: initialize_impl [ Set]: 13:36:15:133
+   *            initialize_impl [Free]: 13:36:17:072
+   * is_lifetime : false - we record the timestamp that debug anchor appeared in
+   * code. Usually, we put this kind debug anchor at the exception occurred
+   * place or record informative messages in a function. [Example]: Received
+   * Hardware error event: 19:56:49:036 [Example]: firmware_download Done:
+   * 13:36:17:024
+   */
+  DebugAnchor SetAnchor(AnchorType type, const std::string& anchor) {
+    return DebugAnchor(type, anchor, instance_);
+  }
+
+ private:
+  static constexpr int kMaxHistory = 400;
+  static DebugCentral instance_;
+  // Determine if we should hijack the vendor debug event or not
+  bool hijack_event_ = false;
+  bool has_client_ = false;
+  ::bluetooth_hal::hci::HalPacketCallback notify_cb_;
+  std::string serial_debug_port_;
+  std::string crash_timestamp_;
+  std::recursive_mutex mutex_;
+  // std::vector<std::unique_ptr<hci::HciEventWatcher>> event_watchers_;
+  std::queue<std::vector<uint8_t>> socdump_;
+  std::queue<std::vector<uint8_t>> chredump_;
+  // BtHal Logger
+  std::list<std::pair<std::string, std::string>> history_record_;
+  std::map<AnchorType, std::pair<std::string, std::string>> lasttime_record_;
+
+  static void ForceGetCoredumpTimeout(union sigval sig);
+  bool report_ssr_crash(uint8_t vendor_error_code);
+  bool is_hw_stage_supported();
+  void dump_hal_log(int fd);
+  void handle_vendor_specific_event(
+      const ::bluetooth_hal::hci::HalPacket& packet);
+  void handle_bqr_fw_debug_data_dump(
+      const ::bluetooth_hal::hci::HalPacket& packet);
+  void handle_bqr_chre_debug_data_dump(
+      const ::bluetooth_hal::hci::HalPacket& packet);
+  void handle_debug_info_event(const ::bluetooth_hal::hci::HalPacket& packet);
+  void handle_bqr_event(const ::bluetooth_hal::hci::HalPacket& packet);
+  void start_crash_dump(bool slient_report, const std::string& reason);
+};
+
+class LogHelper {
+ public:
+  LogHelper(AnchorType type, ::android::base::LogSeverity severity)
+      : type_(type), severity_(severity) {}
+
+  template <typename T>
+  LogHelper& operator<<(const T& value) {
+    oss_ << value;
+    return *this;
+  }
+
+  ~LogHelper() {
+    std::string log_message = oss_.str();
+    if (!log_message.empty()) {
+#ifdef UNIT_TEST
+      (void)type_;
+#else
+      DebugCentral::Get()->UpdateRecord(type_, log_message);
+#endif
+      LOG(severity_) << log_message;
+    }
+  }
+
+ private:
+  AnchorType type_;
+  ::android::base::LogSeverity severity_;
+  std::ostringstream oss_;
+};
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/debug_event_watcher.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/debug_event_watcher.h
new file mode 100644
index 0000000000..2562ad4395
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/debug_event_watcher.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+class DebugEventWatcher : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  DebugEventWatcher();
+  ~DebugEventWatcher();
+
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override {};
+  void OnBluetoothDisabled() override {};
+  void OnCommandCallback(
+      [[maybe_unused]] const ::bluetooth_hal::hci::HalPacket& packet) override {
+  };
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+
+ private:
+  ::bluetooth_hal::hci::HciBqrEventMonitor bqr_event_monitor_;
+  ::bluetooth_hal::hci::HciCommandCompleteEventMonitor
+      google_vendor_capability_event_monitor_;
+};
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/vnd_snoop_logger.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/vnd_snoop_logger.h
new file mode 100644
index 0000000000..60a70dfe6b
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/debug/vnd_snoop_logger.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+class VndSnoopLogger {
+ public:
+  enum class Direction : int {
+    kIncoming,
+    kOutgoing,
+  };
+
+  virtual ~VndSnoopLogger() = default;
+
+  /**
+   * @brief Get the singleton instance of VndSnoopLogger.
+   *
+   * @return The singleton instance of VndSnoopLogger.
+   *
+   */
+  static VndSnoopLogger& GetLogger();
+
+  /**
+   * @brief Initiates the logging process for Bluetooth events.
+   *
+   * Starts logging to new log file.
+   */
+  virtual void StartNewRecording() = 0;
+
+  /**
+   * @brief Stops the ongoing recording process.
+   *
+   * Ends the logging of Bluetooth events and closes any open resources.
+   */
+  virtual void StopRecording() = 0;
+
+  /**
+   * @brief Captures an HCI packet for logging.
+   *
+   * @param packet The HCI packet data to capture.
+   * @param direction Specifies whether the packet is incoming or outgoing.
+   *
+   * Adds a Bluetooth HCI packet to the log, recording its metadata and type.
+   */
+  virtual void Capture(const ::bluetooth_hal::hci::HalPacket& packet,
+                       Direction direction) = 0;
+};
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc.h
new file mode 100644
index 0000000000..4f62acb756
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "aidl/hardware/google/bluetooth/ccc/BnBluetoothCcc.h"
+#include "aidl/hardware/google/bluetooth/ccc/IBluetoothCccCallback.h"
+#include "android/binder_auto_utils.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+class BluetoothCcc
+    : public ::aidl::hardware::google::bluetooth::ccc::BnBluetoothCcc {
+ public:
+  BluetoothCcc() = default;
+
+  ::ndk::ScopedAStatus registerForLmpEvents(
+      const std::shared_ptr<
+          ::aidl::hardware::google::bluetooth::ccc::IBluetoothCccCallback>&
+          callback,
+      const std::array<uint8_t, 6>& address,
+      const std::vector<::aidl::hardware::google::bluetooth::ccc::LmpEventId>&
+          lmpEventIds) override;
+
+  ::ndk::ScopedAStatus unregisterLmpEvents(
+      const std::array<uint8_t, 6>& address) override;
+};
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.h
new file mode 100644
index 0000000000..222378fb26
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <condition_variable>
+#include <deque>
+#include <list>
+#include <memory>
+#include <mutex>
+#include <vector>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_callback.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+class BluetoothCccHandler : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  BluetoothCccHandler();
+
+  static BluetoothCccHandler& GetHandler();
+
+  bool RegisterForLmpEvents(
+      const std::shared_ptr<BluetoothCccHandlerCallback>& callback);
+
+  bool UnregisterLmpEvents(
+      const ::bluetooth_hal::hci::BluetoothAddress& address);
+
+ protected:
+  void OnCommandCallback(
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override;
+  void OnBluetoothDisabled() override;
+
+ private:
+  uint64_t GetSystemTime(uint8_t current_toggle_count, uint16_t offse);
+
+  std::deque<std::shared_ptr<BluetoothCccHandlerCallback>>
+      pending_callbacks_deque_;
+  std::list<std::shared_ptr<BluetoothCccHandlerCallback>> monitor_callbacks_;
+  std::mutex mutex_;
+  std::condition_variable pending_callbacks_cv_;
+  uint8_t previous_toggle_count_;
+};
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_callback.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_callback.h
new file mode 100644
index 0000000000..0289fb99a8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_handler_callback.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <vector>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+class BluetoothCccHandlerCallback {
+ public:
+  BluetoothCccHandlerCallback(
+      const ::bluetooth_hal::hci::BluetoothAddress& address,
+      const std::vector<CccLmpEventId>& lmp_event_ids)
+      : address_(address), lmp_event_ids_(lmp_event_ids) {};
+  virtual ~BluetoothCccHandlerCallback() = default;
+  virtual void OnEventGenerated(
+      const CccTimestamp& timestamp,
+      const ::bluetooth_hal::hci::BluetoothAddress& address,
+      CccDirection direction, CccLmpEventId lmp_event_id,
+      uint8_t event_counter) = 0;
+
+  virtual void OnRegistered(bool status) = 0;
+
+  bool ContainsEventId(CccLmpEventId lmp_event_id) const {
+    return std::find(lmp_event_ids_.begin(), lmp_event_ids_.end(),
+                     lmp_event_id) != lmp_event_ids_.end();
+  }
+
+  bool IsAddressEqual(
+      const ::bluetooth_hal::hci::BluetoothAddress& address) const {
+    return (address_ == address);
+  }
+
+  const ::bluetooth_hal::hci::BluetoothAddress& GetAddress() const {
+    return address_;
+  }
+
+  const std::vector<CccLmpEventId>& GetLmpEventIds() const {
+    return lmp_event_ids_;
+  }
+
+ private:
+  const ::bluetooth_hal::hci::BluetoothAddress address_;
+  const std::vector<CccLmpEventId> lmp_event_ids_;
+};
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.h
new file mode 100644
index 0000000000..0003769512
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_command.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <vector>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+class BluetoothCccTimesyncCommand : public ::bluetooth_hal::hci::HalPacket {
+ public:
+  /**
+   * @brief Creates an ADD CCC Timesync Command packet.
+   *
+   * Format:
+   * [PacketType:1][Opcode:2][Length:1][ADD:1][Address:6][AddressType:1][Direction:1][LmpId:X]
+   *
+   * @param address The 6-byte Bluetooth address to add.
+   * @param lmp_ids The variable-length LMP ID. This can be empty if the LMP ID
+   * is not present.
+   * @return A `HalPacket` object representing the ADD command packet.
+   */
+  static ::bluetooth_hal::hci::HalPacket CreateAddCommand(
+      const ::bluetooth_hal::hci::BluetoothAddress& address,
+      const AddressType address_type, const CccDirection direction,
+      const std::vector<CccLmpEventId>& lmp_ids);
+
+  /**
+   * @brief Creates a REMOVE CCC Timesync Command packet.
+   *
+   * Format:
+   * [PacketType:1][Opcode:2][Length:1][REMOVE:1][Address:6][AddressType:1]
+   *
+   * @param address The 6-byte Bluetooth address to remove.
+   * @return A `HalPacket` object representing the REMOVE command packet.
+   */
+  static ::bluetooth_hal::hci::HalPacket CreateRemoveCommand(
+      const ::bluetooth_hal::hci::BluetoothAddress& address,
+      const AddressType address_type);
+
+  /**
+   * @brief Creates a CLEAR CCC Timesync Command packet.
+   *
+   * Format: [PacketType:1][Opcode:2][Length:1(1)][CLEAR:1]
+   *
+   * @return A `HalPacket` object representing the CLEAR command packet.
+   */
+  static ::bluetooth_hal::hci::HalPacket CreateClearCommand();
+};
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h
new file mode 100644
index 0000000000..70621bc542
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_timesync_event.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+#include "bluetooth_hal/bluetooth_address.h"
+#include "bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h"
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+class BluetoothCccTimesyncEvent : public ::bluetooth_hal::hci::HalPacket {
+ public:
+  /**
+   * @brief Constructs a BluetoothCccTimesyncEvent object from a raw packet.
+   *
+   * Parses the provided `HalPacket` data according to the CCC Timesync Event
+   * format. The `IsValid()` method can be used post-construction to check if
+   * parsing was successful.
+   *
+   * @param packet The raw `::bluetooth_hal::hci::HalPacket` containing the
+   * event data.
+   */
+  explicit BluetoothCccTimesyncEvent(
+      const ::bluetooth_hal::hci::HalPacket& packet);
+
+  /**
+   * @brief Check if the packet is a valid CCC time sync event.
+   *
+   * @return true if the packet is a CCC time sync event, otherwise false.
+   *
+   */
+  bool IsValid();
+
+  /**
+   * @brief Retrieves the Bluetooth address from the event packet.
+   *
+   * @return The 6-byte Bluetooth address as
+   * `::bluetooth_hal::hci::BluetoothAddress`.
+   */
+  ::bluetooth_hal::hci::BluetoothAddress GetAddress() const;
+
+  /**
+   * @brief Retrieves the address type from the event packet.
+   *
+   * @return The 1-byte address type.
+   */
+  uint8_t GetAddressType() const;
+
+  /**
+   * @brief Retrieves the direction of the event (Tx, Rx or Undefined).
+   *
+   * @return The direction as a `CccDirection` enum value.
+   */
+  CccDirection GetDirection() const;
+
+  /**
+   * @brief Retrieves the timestamp from the event packet.
+   *
+   * @return The 8-byte timestamp as a `uint64_t`.
+   */
+  uint64_t GetTimestamp() const;
+
+  /**
+   * @brief Retrieves the LMP (Link Manager Protocol) event ID.
+   *
+   * This ID is mapped from the raw byte in the packet to a `CccLmpEventId`
+   * enum. Specific raw byte values map to defined enum members, otherwise it's
+   * `kUndefined`.
+   *
+   * @return The LMP event ID as a `CccLmpEventId` enum value.
+   */
+  CccLmpEventId GetEventId() const;
+
+  /**
+   * @brief Retrieves the toggle count from the event packet.
+   *
+   * @return The 1-byte toggle count as a `uint8_t`.
+   */
+  uint8_t GetToggleCount() const;
+
+  /**
+   * @brief Retrieves the timesync offset from the event packet.
+   *
+   * @return The 2-byte timesync offset as a `uint16_t`.
+   */
+  uint16_t GetTimesyncOffset() const;
+
+  /**
+   * @brief Retrieves the event count from the event packet.
+   *
+   * @return The 2-byte event count as a `uint16_t`.
+   */
+  uint16_t GetEventCount() const;
+
+ private:
+  bool is_valid_;
+  ::bluetooth_hal::hci::BluetoothAddress address_;
+  uint8_t address_type_;
+  uint8_t direction_;
+  uint64_t timestamp_;
+  uint8_t event_id_;
+  uint8_t toggle_count_;
+  uint16_t timesync_offset_;
+  uint16_t event_count_;
+};
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h
new file mode 100644
index 0000000000..34917f53f9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ccc/bluetooth_ccc_util.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ccc {
+
+enum class CccDirection : uint8_t {
+  kTx = 0x00,
+  kRx = 0x01,
+  kMax = 0x01,
+  kUndefined = 0xFF,
+};
+
+struct CccTimestamp {
+  /**
+   * Timestamp in microsecond since system boot.
+   */
+  long system_time;
+  /**
+   * Timestamp in microsecond since Bluetooth controller power up.
+   */
+  long bluetooth_time;
+};
+
+enum class CccLmpEventId : uint8_t {
+  kConnectInd = 0x00,
+  kLlPhyUpdateInd = 0x01,
+  kMax,
+  kUndefined = 0xFF,
+};
+
+enum class CccLmpEventIdByte : uint8_t {
+  kConnectInd = 0xFF,
+  kLlPhyUpdateInd = 0x18,
+  kUndefined = 0x00,
+};
+
+// Define constants for the event offsets
+enum class TimesyncEventOffset : uint8_t {
+  kSubEventCode = 3,
+  kAddress = 4,
+  kAddressType = 10,
+  kDirection = 11,
+  kTimestamp = 12,
+  kEventId = 20,
+  kToggleCount = 21,
+  kTimesyncOffset = 22,
+  kEventCount = 24,
+};
+
+enum class AddressType : uint8_t {
+  kPublic = 0x00,
+  kRandom = 0x01,
+};
+
+enum class TimesyncCommandType : uint8_t {
+  kUndefined = 0x00,
+  kAdd,
+  kRemove,
+  kClear,
+};
+
+class TimesyncConstants {
+ public:
+  static constexpr int kEventLength = 26;
+  static constexpr int kEventTimestampLength = 8;
+  static constexpr int kCommandCommandTypeLength = 1;
+  static constexpr int kCommandAddressTypeLength = 1;
+  static constexpr int kCommandDirectionLength = 1;
+  static constexpr uint8_t kSubEventCode = 0xD0;
+  static constexpr uint16_t kCommandOpCode = 0xFD63;
+  static constexpr int kUint64MaxDigitInDec = 20;
+};
+
+}  // namespace ccc
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.h
new file mode 100644
index 0000000000..fdfe4b05d0
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstdint>
+
+#include "aidl/hardware/google/bluetooth/bt_channel_avoidance/BnBTChannelAvoidance.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace channel_avoidance {
+
+class BluetoothChannelAvoidance
+    : public ::aidl::hardware::google::bluetooth::bt_channel_avoidance::
+          BnBTChannelAvoidance {
+ public:
+  ::ndk::ScopedAStatus setBluetoothChannelStatus(
+      const std::array<uint8_t, 10>& channel_map) override;
+
+ private:
+  BluetoothChannelAvoidanceHandler handler_;
+};
+
+}  // namespace channel_avoidance
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h
new file mode 100644
index 0000000000..afb855d5f9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bluetooth_channel_avoidance_handler.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <atomic>
+#include <cstdint>
+#include <future>
+#include <mutex>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace channel_avoidance {
+
+class BluetoothChannelAvoidanceHandler
+    : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  BluetoothChannelAvoidanceHandler() = default;
+
+  bool SetBluetoothChannelStatus(const std::array<uint8_t, 10>& channel_map);
+
+ protected:
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override {};
+  void OnBluetoothDisabled() override {};
+  void OnCommandCallback(
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const bluetooth_hal::hci::HalPacket& packet) override;
+
+  ::bluetooth_hal::hci::HalPacket BuildSetChannelAvoidanceCommand(
+      const std::array<uint8_t, 10>& channel_map);
+
+ private:
+  std::mutex command_mtx_;
+  std::promise<void> command_promise_;
+  std::atomic<bool> command_success_{false};
+};
+
+}  // namespace channel_avoidance
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.h
new file mode 100644
index 0000000000..b2796a47a9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/channel_avoidance/bt_channel_avoidance.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "aidl/vendor/google/bluetooth_ext/BnBTChannelAvoidance.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "legacy/hci_flow_control.h"
+
+namespace vendor {
+namespace google {
+namespace bluetooth_ext {
+namespace bt_channel_avoidance {
+namespace aidl {
+namespace implementation {
+
+using ::aidl::vendor::google::bluetooth_ext::BnBTChannelAvoidance;
+using ::bluetooth_hal::hci::HciEventWatcher;
+using ::bluetooth_hal::hci::HciFlowControl;
+
+struct BTChannelAvoidance : public BnBTChannelAvoidance,
+                            public HciEventWatcher {
+ public:
+  BTChannelAvoidance();
+
+  ndk::ScopedAStatus setBluetoothChannelStatus(
+      const std::array<uint8_t, 10>& channel_map) override;
+  bool OnEventReceive(const ::bluetooth_hal::hci::HalPacket& event) override;
+  bool OnEventPost(const ::bluetooth_hal::hci::HalPacket& event) override;
+
+  static void OnBluetoothEnabled(HciFlowControl* handle);
+  static void OnBluetoothDisabled();
+
+ private:
+  static HciFlowControl* hci_handle_;
+  static BTChannelAvoidance instance_;
+  std::atomic_uint event_waiting_{0};
+};
+
+}  // namespace implementation
+}  // namespace aidl
+}  // namespace bt_channel_avoidance
+}  // namespace bluetooth_ext
+}  // namespace google
+}  // namespace vendor
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding.h
new file mode 100644
index 0000000000..870bdaa19a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/BnBluetoothChannelSounding.h"
+#include "aidl/android/hardware/bluetooth/ranging/CsSecurityLevel.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSession.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/SessionType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+class BluetoothChannelSounding : public ::aidl::android::hardware::bluetooth::
+                                     ranging::BnBluetoothChannelSounding {
+ public:
+  BluetoothChannelSounding() = default;
+  ~BluetoothChannelSounding() = default;
+
+  ::ndk::ScopedAStatus getVendorSpecificData(
+      std::optional<std::vector<std::optional<
+          ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData>>>*
+          _aidl_return) override;
+  ::ndk::ScopedAStatus getSupportedSessionTypes(
+      std::optional<std::vector<
+          ::aidl::android::hardware::bluetooth::ranging::SessionType>>*
+          _aidl_return) override;
+  ::ndk::ScopedAStatus getMaxSupportedCsSecurityLevel(
+      ::aidl::android::hardware::bluetooth::ranging::CsSecurityLevel*
+          _aidl_return) override;
+  ::ndk::ScopedAStatus openSession(
+      const ::aidl::android::hardware::bluetooth::ranging::
+          BluetoothChannelSoundingParameters& in_params,
+      const std::shared_ptr<::aidl::android::hardware::bluetooth::ranging::
+                                IBluetoothChannelSoundingSessionCallback>&
+          in_callback,
+      std::shared_ptr<::aidl::android::hardware::bluetooth::ranging::
+                          IBluetoothChannelSoundingSession>* _aidl_return)
+      override;
+
+ private:
+  BluetoothChannelSoundingHandler bluetooth_channel_sounding_handler_;
+};
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_algorithm.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_algorithm.h
new file mode 100644
index 0000000000..800a2093a2
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_algorithm.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "aidl/android/hardware/bluetooth/ranging/ChannelSoudingRawData.h"
+
+using ::aidl::android::hardware::bluetooth::ranging::ChannelSoudingRawData;
+
+class ChannelSoundingAlgorithm {
+ public:
+  void reset_variables() {};
+
+  double estimate_distance([[maybe_unused]] const ChannelSoudingRawData&) {
+    return 0;
+  }
+
+  double get_confidence_level() { return 0; }
+};
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.h
new file mode 100644
index 0000000000..f47b31dca4
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_handler.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <functional>
+#include <memory>
+#include <optional>
+#include <unordered_map>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/CsSecurityLevel.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSession.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/SessionType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+class BluetoothChannelSoundingHandler
+    : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  struct SessionTracker {
+    ::aidl::android::hardware::bluetooth::ranging::
+        BluetoothChannelSoundingParameters parameters;
+    uint16_t cur_procedure_counter{0xffff};
+    bool is_fake_notification_enabled{false};
+  };
+
+  BluetoothChannelSoundingHandler();
+  ~BluetoothChannelSoundingHandler();
+
+  bool GetVendorSpecificData(
+      std::optional<std::vector<std::optional<
+          ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData>>>*
+          return_value);
+  bool GetSupportedSessionTypes(
+      std::optional<std::vector<
+          ::aidl::android::hardware::bluetooth::ranging::SessionType>>*
+          return_value);
+  bool GetMaxSupportedCsSecurityLevel(
+      ::aidl::android::hardware::bluetooth::ranging::CsSecurityLevel*
+          return_value);
+  bool OpenSession(
+      const ::aidl::android::hardware::bluetooth::ranging::
+          BluetoothChannelSoundingParameters& in_params,
+      const std::shared_ptr<::aidl::android::hardware::bluetooth::ranging::
+                                IBluetoothChannelSoundingSessionCallback>&
+          in_callback,
+      std::shared_ptr<::aidl::android::hardware::bluetooth::ranging::
+                          IBluetoothChannelSoundingSession>* return_value);
+
+ protected:
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override;
+  void OnBluetoothDisabled() override;
+  void OnCommandCallback(
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+
+  std::optional<std::reference_wrapper<SessionTracker>> GetTracker(
+      uint16_t connection_handle);
+
+ private:
+  void HandleCsSubevent(const ::bluetooth_hal::hci::HalPacket& packet);
+  void HandleCsProcedureEnableCompleteEvent(
+      const ::bluetooth_hal::hci::HalPacket& packet);
+
+  ::bluetooth_hal::hci::HciBleMetaEventMonitor cs_data_subevent_monitor_;
+  ::bluetooth_hal::hci::HciBleMetaEventMonitor
+      cs_procedure_enable_subevent_monitor_;
+
+  std::vector<uint8_t> local_capabilities_;
+
+  std::unordered_map<uint16_t, SessionTracker> session_trackers_;
+};
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.h
new file mode 100644
index 0000000000..df352f0bed
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_session.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BnBluetoothChannelSoundingSession.h"
+#include "aidl/android/hardware/bluetooth/ranging/ChannelSoudingRawData.h"
+#include "aidl/android/hardware/bluetooth/ranging/IBluetoothChannelSoundingSessionCallback.h"
+#include "aidl/android/hardware/bluetooth/ranging/Reason.h"
+#include "aidl/android/hardware/bluetooth/ranging/ResultType.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "android/binder_auto_utils.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+class BluetoothChannelSoundingSession
+    : public ::aidl::android::hardware::bluetooth::ranging::
+          BnBluetoothChannelSoundingSession {
+ public:
+  BluetoothChannelSoundingSession(
+      std::shared_ptr<::aidl::android::hardware::bluetooth::ranging::
+                          IBluetoothChannelSoundingSessionCallback>
+          callback,
+      ::aidl::android::hardware::bluetooth::ranging::Reason reason);
+
+  ::ndk::ScopedAStatus getVendorSpecificReplies(
+      std::optional<std::vector<std::optional<
+          ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData>>>*
+          _aidl_return) override;
+  ::ndk::ScopedAStatus getSupportedResultTypes(
+      std::vector<::aidl::android::hardware::bluetooth::ranging::ResultType>*
+          _aidl_return) override;
+  ::ndk::ScopedAStatus isAbortedProcedureRequired(bool* _aidl_return) override;
+  ::ndk::ScopedAStatus writeRawData(
+      const ::aidl::android::hardware::bluetooth::ranging::
+          ChannelSoudingRawData& in_rawData) override;
+  ::ndk::ScopedAStatus close(
+      ::aidl::android::hardware::bluetooth::ranging::Reason in_reason) override;
+
+  void HandleVendorSpecificData(
+      const std::optional<std::vector<std::optional<
+          ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData>>>
+          vendor_specific_data);
+  bool ShouldEnableFakeNotification();
+  bool ShouldEnableMode0ChannelMap();
+
+ private:
+  std::shared_ptr<::aidl::android::hardware::bluetooth::ranging::
+                      IBluetoothChannelSoundingSessionCallback>
+      callback_;
+  bool uuid_matched_ = false;
+  bool enable_fake_notification_ = false;
+  bool enable_mode_0_channel_map_ = false;
+};
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h
new file mode 100644
index 0000000000..b233396ae3
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/cs/bluetooth_channel_sounding_util.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstdint>
+#include <optional>
+#include <span>
+#include <string>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/ranging/BluetoothChannelSoundingParameters.h"
+#include "aidl/android/hardware/bluetooth/ranging/VendorSpecificData.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace cs {
+
+constexpr std::array<uint8_t, 16> kUuidSpecialRangingSettingCapability = {
+    0x00, 0x00, 0x8f, 0x01, 0x00, 0x00, 0x10, 0x00,
+    0x80, 0x00, 0x00, 0x80, 0x5f, 0x9c, 0x35, 0xf1};
+
+constexpr std::array<uint8_t, 16> kUuidSpecialRangingSettingCommand = {
+    0x00, 0x00, 0x8f, 0x02, 0x00, 0x00, 0x10, 0x00,
+    0x80, 0x00, 0x00, 0x80, 0x5f, 0x9c, 0x35, 0xf1};
+
+constexpr uint8_t kMinNumUuid = 0x02;
+constexpr uint8_t kDataTypeData = 0x00;
+constexpr uint8_t kDataTypeReply = 0x01;
+constexpr uint8_t kCommandValueDisable = 0x00;
+constexpr uint8_t kCommandValueEnable = 0x01;
+constexpr uint8_t kCommandValueIgnore = 0x02;
+
+constexpr uint8_t kCommandCompleteSubOpcodeOffset =
+    ::bluetooth_hal::hci::HciConstants::kHciCommandCompleteResultOffset + 1;
+
+constexpr uint16_t kHciVscSpecialRangingSettingOpcode = 0xff0b;
+
+constexpr uint8_t kHciVscReadLocalCapabilityParamLength = 0x01;
+constexpr uint8_t kHciVscReadLocalCapabilitySubOpCode = 0x01;
+constexpr uint8_t kCommandCompleteReadLocalCapabilityOffset =
+    kCommandCompleteSubOpcodeOffset + 1;
+constexpr uint8_t kCommandCompleteReadLocalCapabilityValueLength = 4;
+
+constexpr uint8_t kHciVscEnableOneSidePctParamLength = 0x02;
+constexpr uint8_t kHciVscEnableOneSidePctSubOpCode = 0x02;
+
+constexpr uint8_t kHciVscEnableCsSubeventReportParamLength = 0x04;
+constexpr uint8_t kHciVscEnableCsSubeventReportSubOpCode = 0x03;
+
+constexpr uint8_t kHciVscEnableMode0ChannelMapSubOpCode = 0x04;
+constexpr uint8_t kHciVscEnableMode0ChannelMapParamLength = 0x04;
+
+constexpr uint8_t kLeCsProcedureEnableCompleteCode = 0x30;
+constexpr uint8_t kLeCsSubEventResultCode = 0x31;
+
+// Used for RAS notification.
+constexpr uint16_t kFlagFirstAutomaticallyFlushablePacket = 0x2000;
+constexpr uint8_t kFakeRasDataLen = 0x18;
+constexpr uint8_t kGattNotification = 0x1b;
+
+constexpr uint16_t kInitialProcedureCounter = 0xffff;
+
+std::string ToHex(const std::span<const uint8_t> data);
+
+bool IsUuidMatched(
+    const std::optional<std::vector<std::optional<
+        ::aidl::android::hardware::bluetooth::ranging::VendorSpecificData>>>
+        vendor_specific_data);
+
+::bluetooth_hal::hci::HalPacket BuildReadLocalCapabilityCommand();
+
+::bluetooth_hal::hci::HalPacket BuildEnableOneSidePctCommand(uint8_t enable);
+
+::bluetooth_hal::hci::HalPacket BuildEnableCsSubeventReportCommand(
+    uint16_t connection_handle, uint8_t enable);
+
+::bluetooth_hal::hci::HalPacket BuildEnableMode0ChannelMapCommand(
+    uint16_t connection_handle, uint8_t enable);
+
+::bluetooth_hal::hci::HalPacket BuildRasNotification(
+    const ::aidl::android::hardware::bluetooth::ranging::
+        BluetoothChannelSoundingParameters& parameters,
+    int procedure_counter);
+
+}  // namespace cs
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ext/bluetooth_ext.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ext/bluetooth_ext.h
new file mode 100644
index 0000000000..037b839a51
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ext/bluetooth_ext.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <vector>
+
+#include "aidl/hardware/google/bluetooth/ext/BnBluetoothExt.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/ext/bluetooth_ext_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ext {
+
+struct BluetoothExt
+    : public ::aidl::hardware::google::bluetooth::ext::BnBluetoothExt {
+ public:
+  ::ndk::ScopedAStatus setBluetoothCmdPacket(char16_t opcode,
+                                             const std::vector<uint8_t>& params,
+                                             bool* ret) override;
+
+ private:
+  BluetoothExtHandler handler_;
+};
+
+}  // namespace ext
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ext/bluetooth_ext_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ext/bluetooth_ext_handler.h
new file mode 100644
index 0000000000..2184b313a9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/ext/bluetooth_ext_handler.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <cstdint>
+#include <future>
+#include <mutex>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace ext {
+
+class BluetoothExtHandler : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  BluetoothExtHandler() = default;
+  ~BluetoothExtHandler() override = default;
+
+  bool SetBluetoothCmdPacket(char16_t opcode,
+                             const std::vector<uint8_t>& params, bool* ret);
+
+ protected:
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override {};
+  void OnBluetoothDisabled() override {};
+  void OnCommandCallback(const ::bluetooth_hal::hci::HalPacket& event) override;
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode /*mode*/,
+      const ::bluetooth_hal::hci::HalPacket& /*packet*/) override {};
+
+  std::mutex cmd_mutex_;
+
+  // For synchronizing command sending.
+  std::promise<void> command_promise_;
+  std::atomic<bool> command_success_{false};
+};
+
+}  // namespace ext
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/finder/bluetooth_finder.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/finder/bluetooth_finder.h
new file mode 100644
index 0000000000..9224944840
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/finder/bluetooth_finder.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/finder/BnBluetoothFinder.h"
+#include "aidl/android/hardware/bluetooth/finder/Eid.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/finder/bluetooth_finder_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace finder {
+
+class BluetoothFinder
+    : public ::aidl::android::hardware::bluetooth::finder::BnBluetoothFinder {
+ public:
+  BluetoothFinder();
+
+  ::ndk::ScopedAStatus sendEids(
+      const std::vector<::aidl::android::hardware::bluetooth::finder::Eid>&
+          eids) override;
+
+  ::ndk::ScopedAStatus setPoweredOffFinderMode(bool enable) override;
+
+  ::ndk::ScopedAStatus getPoweredOffFinderMode(bool* _aidl_return) override;
+
+ private:
+  BluetoothFinderHandler& handler_;
+};
+
+}  // namespace finder
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/finder/bluetooth_finder_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/finder/bluetooth_finder_handler.h
new file mode 100644
index 0000000000..9781948cc8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/finder/bluetooth_finder_handler.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <future>
+#include <mutex>
+#include <vector>
+
+#include "aidl/android/hardware/bluetooth/finder/Eid.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace finder {
+
+class BluetoothFinderHandler : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  enum class State {
+    kIdle,
+    kReset,
+    kSendingKeys,
+    kStartingPof,
+    kStarted,
+  };
+
+  bool SendEids(
+      const std::vector<::aidl::android::hardware::bluetooth::finder::Eid>&
+          keys);
+
+  bool SetPoweredOffFinderMode(bool enable);
+  bool GetPoweredOffFinderMode(bool* return_value);
+
+  bool IsPoweredOffFinderEnabled() const;
+  bool StartPoweredOffFinderMode();
+
+  static BluetoothFinderHandler& GetHandler();
+
+ protected:
+  BluetoothFinderHandler() = default;
+
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override {};
+  void OnBluetoothDisabled() override {};
+  void OnCommandCallback(const bluetooth_hal::hci::HalPacket& packet) override;
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const bluetooth_hal::hci::HalPacket& packet) override;
+
+  ::bluetooth_hal::hci::HalPacket BuildFinderResetCommand();
+  ::bluetooth_hal::hci::HalPacket BuildPrecomputedKeyCommand(
+      const std::vector<::aidl::android::hardware::bluetooth::finder::Eid>&
+          keys,
+      uint_t cur_key_idx);
+  ::bluetooth_hal::hci::HalPacket BuildStartPoweredOffFinderModeCommand(
+      int32_t cur_key_idx);
+
+  bool SendKeys();
+  bool StartPoweredOffFinderModeInternal();
+
+  void HandleNextStep(State next_state);
+  bool SendCommandAndWait(const ::bluetooth_hal::hci::HalPacket& packet);
+
+  std::vector<::aidl::android::hardware::bluetooth::finder::Eid> keys_;
+  bool is_pof_enabled_{false};
+  std::atomic<State> state_{State::kIdle};
+  size_t current_key_index_{0};
+
+  std::mutex finder_mtx_;
+
+  // For synchronizing command sending.
+  std::promise<void> command_promise_;
+  bool command_success_{false};
+};
+
+}  // namespace finder
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/sar/bluetooth_sar.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/sar/bluetooth_sar.h
new file mode 100644
index 0000000000..ee93c578e1
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/sar/bluetooth_sar.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstdint>
+
+#include "aidl/hardware/google/bluetooth/sar/BnBluetoothSar.h"
+#include "android/binder_auto_utils.h"
+#include "bluetooth_hal/extensions/sar/bluetooth_sar_handler.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace sar {
+
+class BluetoothSar
+    : public ::aidl::hardware::google::bluetooth::sar::BnBluetoothSar {
+ public:
+  BluetoothSar() = default;
+
+  ::ndk::ScopedAStatus setBluetoothTxPowerCap(int8_t cap) override;
+  ::ndk::ScopedAStatus setBluetoothTechBasedTxPowerCap(int8_t br_cap,
+                                                       int8_t edr_cap,
+                                                       int8_t ble_cap) override;
+  ::ndk::ScopedAStatus setBluetoothModeBasedTxPowerCap(
+      const std::array<uint8_t, 3>& chain_0_cap,
+      const std::array<uint8_t, 3>& chain_1_cap,
+      const std::array<uint8_t, 6>& beamforming_cap) override;
+  ::ndk::ScopedAStatus setBluetoothModeBasedTxPowerCapPlusHR(
+      const std::array<uint8_t, 4>& chain_0_cap,
+      const std::array<uint8_t, 4>& chain_1_cap,
+      const std::array<uint8_t, 8>& beamforming_cap) override;
+  ::ndk::ScopedAStatus setBluetoothAreaCode(
+      const std::array<uint8_t, 3>& area_code) override;
+
+ private:
+  ::bluetooth_hal::extensions::sar::BluetoothSarHandler bluetooth_sar_handler_;
+};
+
+}  // namespace sar
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/sar/bluetooth_sar_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/sar/bluetooth_sar_handler.h
new file mode 100644
index 0000000000..4ca7778665
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/sar/bluetooth_sar_handler.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstddef>
+#include <cstdint>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace extensions {
+namespace sar {
+
+// OGC 0x03 | OCF 0x0269
+constexpr uint16_t kHciVscSetPowerCapOpcode = 0xfe69;
+constexpr uint8_t kHciVscSetPowerCapSubOpCode = 0x01;
+constexpr uint8_t kHciVscSetPowerCapSubOpCodeHighResolution = 0x05;
+constexpr uint8_t kHciVscSetPowerCapSubOpCodeHRMode = 0x08;
+constexpr uint8_t kHciVscSetPowerCapSubOpCodeLENonConnectionMode = 0x0F;
+constexpr uint8_t kHciVscSetPowerCapPlusHRCommandVersion = 1;
+constexpr uint8_t kHciVscSetPowerCapChain0PowerLimitSize = 3;
+constexpr uint8_t kHciVscSetPowerCapChain1PowerLimitSize = 3;
+constexpr uint8_t kHciVscSetPowerCapBeamformingPowerLimitSize = 6;
+constexpr uint8_t kHciVscSetPowerCapChain0PowerLimitSizePlusHR = 4;
+constexpr uint8_t kHciVscSetPowerCapChain1PowerLimitSizePlusHR = 4;
+constexpr uint8_t kHciVscSetPowerCapBeamformingPowerLimitSizePlusHR = 8;
+constexpr size_t kHciVscSetPowerCapCmdLength =
+    1 /* Packet type */ +
+    ::bluetooth_hal::hci::HciConstants::kHciCommandPreambleSize +
+    1 /* Sub Opcode size*/
+    + kHciVscSetPowerCapChain0PowerLimitSize +
+    kHciVscSetPowerCapChain1PowerLimitSize +
+    kHciVscSetPowerCapBeamformingPowerLimitSize;
+constexpr size_t kHciVscSetPowerCapCmdLengthPlusHR =
+    1 /* Packet type */ +
+    ::bluetooth_hal::hci::HciConstants::kHciCommandPreambleSize +
+    1 /* Sub Opcode size*/ + 1 /* Command version size */
+    + kHciVscSetPowerCapChain0PowerLimitSizePlusHR +
+    kHciVscSetPowerCapChain1PowerLimitSizePlusHR +
+    kHciVscSetPowerCapBeamformingPowerLimitSizePlusHR;
+constexpr uint8_t kHciVscPowerCapScale = 4;
+
+class BluetoothSarHandler : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  bool SetBluetoothTxPowerCap(int8_t cap);
+  bool SetBluetoothTechBasedTxPowerCap(int8_t br_cap, int8_t edr_cap,
+                                       int8_t ble_cap);
+  bool SetBluetoothModeBasedTxPowerCap(
+      const std::array<uint8_t, 3>& chain_0_cap,
+      const std::array<uint8_t, 3>& chain_1_cap,
+      const std::array<uint8_t, 6>& beamforming_cap);
+  bool SetBluetoothModeBasedTxPowerCapPlusHR(
+      const std::array<uint8_t, 4>& chain_0_cap,
+      const std::array<uint8_t, 4>& chain_1_cap,
+      const std::array<uint8_t, 8>& beamforming_cap);
+  bool SetBluetoothAreaCode(int32_t area_code);
+
+ protected:
+  ::bluetooth_hal::hci::HalPacket BuildCommandHRMode(
+      const std::array<uint8_t, 4>& chain_0_cap,
+      const std::array<uint8_t, 4>& chain_1_cap,
+      const std::array<uint8_t, 8>& beamforming_cap, bool high_resolution_cap,
+      bool is_ble_non_connection_enabled);
+  ::bluetooth_hal::hci::HalPacket BuildCommand(
+      const std::array<uint8_t, 3>& chain_0_cap,
+      const std::array<uint8_t, 3>& chain_1_cap,
+      const std::array<uint8_t, 6>& beamforming_cap, bool high_resolution_cap);
+  ::bluetooth_hal::hci::HalPacket BuildCommand(uint8_t br_cap, uint8_t edr_cap,
+                                               uint8_t ble_cap,
+                                               bool high_resolution_cap);
+
+  void OnBluetoothChipReady() override {};
+  void OnBluetoothChipClosed() override {};
+  void OnBluetoothEnabled() override;
+  void OnBluetoothDisabled() override;
+  void OnCommandCallback(
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+
+ private:
+  bool high_resolution_cap_ = false;
+  bool is_ble_non_connection_enabled_ = false;
+};
+
+}  // namespace sar
+}  // namespace extensions
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/socket_processor.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/socket_processor.h
new file mode 100644
index 0000000000..adf780d354
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/socket_processor.h
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+enum class SocketMode : int {
+  kSockModeStream = 1,
+  kSockModeSeqPacket = 5,
+};
+
+/**
+ * @brief A base class for managing socket communication, providing an
+ * abstraction layer for sending, receiving data, and handling connections.
+ *
+ * It acts as an interface for concrete socket implementations, allowing
+ * different types of socket communication (e.g., Unix domain sockets, TCP/IP
+ * sockets) to be handled through a common set of methods.
+ *
+ * @note This class is designed to be extended. The behavior and functionality
+ * are defined by the derived classes that implement the pure virtual functions.
+ */
+class SocketProcessor {
+ public:
+  /**
+   * @brief Virtual destructor for proper cleanup in derived classes.
+   *
+   */
+  virtual ~SocketProcessor() = default;
+
+  /**
+   * @brief Initializes the socket processor.
+   *
+   * This function must be called before any other functions in this class are
+   * used.
+   *
+   * @param socket_path The path to the socket file (for Unix domain sockets).
+   * @param hal_packet_cb A callback function triggered when a packet is ready
+   * to be processed.
+   *
+   */
+  static void Initialize(
+      const std::string& socket_path,
+      std::optional<::bluetooth_hal::hci::HalPacketCallback> hal_packet_cb);
+
+  /**
+   * @brief Cleans up the socket processor resources.
+   *
+   * This function should be called when the socket processor is no longer
+   * needed.
+   *
+   */
+  static void Cleanup();
+
+  /**
+   * @brief Returns a pointer to the singleton instance of the SocketProcessor.
+   *
+   * @return A pointer to the singleton instance.
+   *
+   */
+  static SocketProcessor* GetProcessor();
+
+  /**
+   * @brief Sends data over the socket.
+   *
+   * @param data The data to send.
+   *
+   * @return True if the data was sent successfully, false otherwise.
+   *
+   */
+  virtual bool Send(const std::vector<uint8_t>& data) = 0;
+
+  /**
+   * @brief Receives data from the socket.
+   *
+   * @return True if data was received successfully, false otherwise.
+   */
+  virtual bool Recv() = 0;
+
+  /**
+   * @brief Opens a server socket for accepting connections.
+   *
+   * @return True if the server socket was opened successfully, false otherwise.
+   */
+  virtual bool OpenServer() = 0;
+
+  /**
+   * @brief Closes the server socket.
+   */
+  virtual void CloseServer() = 0;
+
+  /**
+   * @brief Closes the client socket.
+   *
+   */
+  virtual void CloseClient() = 0;
+
+  /**
+   * @brief Accepts a new client connection on the server socket.
+   *
+   * @return The file descriptor of the accepted client socket, or a negative
+   * value on error.
+   *
+   */
+  virtual int AcceptClient() = 0;
+
+  /**
+   * @brief Sets the file descriptor for the server socket.
+   *
+   * @param server_socket The file descriptor for the server socket.
+   *
+   */
+  virtual void SetServerSocket(int server_socket) = 0;
+
+  /**
+   * @brief Sets the file descriptor for the client socket.
+   *
+   * @param client_socket The file descriptor for the client socket.
+   *
+   */
+  virtual void SetClientSocket(int client_socket) = 0;
+
+  /**
+   * @brief Sets the socket mode (e.g., server or client).
+   *
+   * @param socket_mode The socket mode.
+   *
+   */
+  virtual void SetSocketMode(SocketMode socket_mode) = 0;
+
+  /**
+   * @brief Gets the file descriptor for the server socket.
+   *
+   * @return The file descriptor for the server socket.
+   *
+   */
+  virtual int GetServerSocket() const = 0;
+
+  /**
+   * @brief Gets the file descriptor for the client socket.
+   *
+   * @return The file descriptor for the client socket.
+   *
+   */
+  virtual int GetClientSocket() const = 0;
+
+  /**
+   * @brief Checks if the socket file exists.
+   *
+   * @return True if the socket file exists, false otherwise.
+   */
+  virtual bool IsSocketFileExisted() const = 0;
+
+  /**
+   * @brief Opens a file monitor to watch for changes in the socket file.
+   *
+   * @return The file descriptor for the socket file monitor, or a negative
+   * value on error.
+   *
+   */
+  virtual int OpenSocketFileMonitor() = 0;
+
+  /**
+   * @brief Closes the socket file monitor.
+   *
+   */
+  virtual void CloseSocketFileMonitor() = 0;
+
+  /**
+   * @brief Gets the file descriptor for the socket file monitor.
+   *
+   * @return The file descriptor for the socket file monitor.
+   *
+   */
+  virtual int GetSocketFileMonitor() = 0;
+};
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/thread_daemon.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/thread_daemon.h
new file mode 100644
index 0000000000..e8d97bbe97
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/thread_daemon.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <sys/select.h>
+
+#include <atomic>
+#include <mutex>
+#include <optional>
+#include <thread>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/extensions/thread/socket_processor.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+// A class representing a Thread daemon for transmitting/receiving packets from
+// Thread HAL to the controller or from the controller to Thread HAL.
+class ThreadDaemon {
+ public:
+  /**
+   * @brief Constructor for the ThreadDaemon class.
+   *
+   * Initializes the daemon with a callback function that will be invoked when a
+   * packet is received from the remote client.
+   *
+   * @param hal_packet_cb The callback function to be invoked when a packet is
+   * ready to be processed. Must not be nullopt.
+   *
+   * @throws std::runtime_error if hal_packet_cb is nullopt.
+   */
+  explicit ThreadDaemon(
+      std::optional<::bluetooth_hal::hci::HalPacketCallback> hal_packet_cb)
+      : is_daemon_running_(false),
+        is_client_connected_(false),
+        require_starting_(false),
+        notification_listen_fd_(kInvalidFileDescriptor),
+        notification_write_fd_(kInvalidFileDescriptor),
+        hal_packet_cb_(hal_packet_cb) {
+    CHECK(hal_packet_cb_ != std::nullopt)
+        << __func__ << ": hal_packet_cb == nullptr";
+    ConfigureSocketProcessor();
+  }
+
+  /**
+   * @brief Destructor for the ThreadDaemon class.
+   *
+   * Stops the daemon thread and cleans up any allocated resources.
+   *
+   */
+  ~ThreadDaemon() {
+    Stop();
+    SocketProcessor::Cleanup();
+  }
+
+  /**
+   * @brief Sends an uplink packet (to the Bluetooth controller/HAL).
+   *
+   * @param packet The packet to send.
+   *
+   */
+  void SendUplink(const ::bluetooth_hal::hci::HalPacket& packet);
+
+  /**
+   * @brief Sends a downlink packet (to the remote client).
+   *
+   * @param packet The packet to send.
+   *
+   */
+  void SendDownlink(const std::vector<uint8_t>& packet);
+
+  /**
+   * @brief Checks if the daemon thread is currently running.
+   *
+   * @return True if the daemon thread is running, false otherwise.
+   *
+   */
+  bool IsDaemonRunning() const;
+
+  /**
+   * @brief Starts the daemon service.
+   *
+   * Initializes resources, spawns the background thread, and starts listening
+   * for client connection requests.
+   *
+   * @return True if the daemon was successfully started, false otherwise.
+   *
+   */
+  bool Start();
+
+  /**
+   * @brief Stops the daemon service.
+   *
+   * Gracefully terminates the daemon thread, closes the client connection (if
+   * any), and releases resources.
+   *
+   * @return True if the daemon was successfully stopped, false otherwise.
+   *
+   */
+  bool Stop();
+
+ private:
+  // Configures the socket processor for communication with the daemon.
+  void ConfigureSocketProcessor();
+
+  // Starts the Thread daemon process.
+  // Returns true if the daemon was successfully started, false otherwise.
+  bool StartDaemon();
+
+  // Stops the Thread daemon process.
+  // Returns true if the daemon was successfully stopped, false otherwise.
+  bool StopDaemon();
+
+  // Notifies the daemon to stop gracefully.
+  // Returns true if the notification was successful, false otherwise.
+  bool NotifyDaemonToStop();
+
+  // Accepts a client connection from the Thread daemon.
+  // Returns true if a client connection was successfully accepted, false
+  // otherwise.
+  bool AcceptClient();
+
+  // Monitors the socket for incoming data and events.
+  void MonitorSocket();
+
+  // The main routine for the daemon thread, handling communication and events.
+  void DaemonRoutine();
+
+  // Cleans up server-side resources after the daemon is stopped.
+  void CleanUpServer();
+
+  // Cleans up client-side resources after the connection is closed.
+  void CleanUpClient();
+
+  // Checks if a received packet indicates a hardware reset event.
+  // Returns true if the packet indicates a hardware reset, false otherwise.
+  bool CheckIfHardwareReset(const std::vector<uint8_t>& packet);
+
+  // Prepares file descriptors for monitoring in the `select` system call.
+  void PrepareFdsForMonitor(fd_set* monitor_fds);
+
+  // Constructs a Hal packet from the given packet data.
+  ::bluetooth_hal::hci::HalPacket ConstructToHalPacket(
+      const std::vector<uint8_t>& packet);
+
+  // Extracts the original packet data from a Hal packet.
+  std::vector<uint8_t> ExtractFromHalPacket(
+      const ::bluetooth_hal::hci::HalPacket& packet);
+
+  std::atomic<bool> is_daemon_running_;
+  std::atomic<bool> is_client_connected_;
+  std::atomic<bool> require_starting_;
+  std::thread server_thread_;
+  int notification_listen_fd_;
+  int notification_write_fd_;
+  std::mutex client_mtx_;
+
+  SocketProcessor* socket_processor_;
+  std::optional<::bluetooth_hal::hci::HalPacketCallback> hal_packet_cb_;
+};
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/thread_handler.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/thread_handler.h
new file mode 100644
index 0000000000..789987a502
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/extensions/thread/thread_handler.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <mutex>
+
+#include "bluetooth_hal/extensions/thread/thread_daemon.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_client.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+/**
+ * @brief This class provides a handler for processing Thread packets and
+ * specifically designed for communication with a remote client.
+ *
+ * This class manages a dedicated thread (daemon) for handling incoming and
+ * outgoing Thread packets. The thread daemon is automatically started when
+ * the `OnBluetoothChipReady()` callback is triggered, signaling that the
+ * underlying Bluetooth chip is initialized and ready for operation. It
+ * continuously monitors for incoming packets and forwards them to the remote
+ * client. The thread daemon is stopped when the `OnBluetoothChipClosed()`
+ * callback is triggered, indicating that the Bluetooth chip is being shut down.
+ *
+ */
+class ThreadHandler : public ::bluetooth_hal::hci::HciRouterClient {
+ public:
+  ThreadHandler();
+
+  ~ThreadHandler() override;
+
+  /**
+   * @brief Initializes the thread handler and associated resources.
+   *
+   * This function should be called before any other functions in this class are
+   * used.
+   *
+   */
+  static void Initialize();
+
+  /**
+   * @brief Cleans up the thread handler and releases associated resources.
+   *
+   * This function should be called when the thread handler is no longer needed.
+   * It ensures that all resources are properly released and the handler is
+   * stopped gracefully.
+   *
+   */
+  static void Cleanup();
+
+  /**
+   * @brief Checks if the handler is initialized.
+   *
+   * @return True if the handler is initialized, false otherwise.
+   *
+   */
+  static bool IsHandlerRunning();
+
+  /**
+   * @brief Returns a reference to the ThreadHandler instance.
+   *
+   * This provides access to the underlying thread handler for advanced
+   * operations.
+   *
+   * @return A reference to the ThreadHandler instance.
+   *
+   */
+  static ThreadHandler& GetHandler();
+
+  /**
+   * @brief Called when a command packet is received. Not used in this
+   * implementation.
+   *
+   * @param packet The received command packet.
+   *
+   */
+  void OnCommandCallback(
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+
+  /**
+   * @brief Called when a monitor packet is received. Forwards the
+   * packet to the remote client.
+   *
+   * This function is the primary mechanism for receiving packets from the
+   * Bluetooth chip and transmitting them to a connected remote client for
+   * processing.
+   *
+   * @param mode The monitor mode.
+   * @param packet The received packet from the HCI router.
+   *
+   */
+  void OnMonitorPacketCallback(
+      ::bluetooth_hal::hci::MonitorMode mode,
+      const ::bluetooth_hal::hci::HalPacket& packet) override;
+
+  /**
+   * @brief Called when the Bluetooth chip is ready. Starts the handler's thread
+   * daemon.
+   *
+   * This function is invoked as a callback when the underlying Bluetooth chip
+   * signals that it has completed its initialization and is ready for
+   * operation. It triggers the start of the thread daemon, enabling packet
+   * processing.
+   *
+   */
+  void OnBluetoothChipReady() override;
+
+  /**
+   * @brief Called when the Bluetooth chip is closed. Stops the handler's thread
+   * daemon.
+   *
+   * This function is invoked as a callback when the underlying Bluetooth chip
+   * signals that it is being shut down. It triggers the stop of the handler's
+   * thread daemon, preventing further packet processing.
+   *
+   */
+  void OnBluetoothChipClosed() override;
+
+  /**
+   * @brief Called when Bluetooth is enabled. Not used in this implementation.
+   *
+   */
+  void OnBluetoothEnabled() override;
+
+  /**
+   * @brief Called when Bluetooth is disabled. Not used in this implementation.
+   *
+   */
+  void OnBluetoothDisabled() override;
+
+  /**
+   * @brief Checks if the Thread daemon is currently running.
+   *
+   * @return True if the daemon is running, false otherwise.
+   *
+   */
+  bool IsDaemonRunning() const;
+
+ private:
+  std::unique_ptr<ThreadDaemon> thread_daemon_;
+  static std::mutex mutex_;
+  static std::unique_ptr<ThreadHandler> handler_;
+  ::bluetooth_hal::hci::HciThreadMonitor thread_data_monitor_;
+};
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hal_packet.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hal_packet.h
new file mode 100644
index 0000000000..7511883995
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hal_packet.h
@@ -0,0 +1,364 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <algorithm>
+#include <cstdint>
+#include <iomanip>
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HalPacket : public std::vector<uint8_t> {
+ public:
+  static constexpr size_t kPartialStringSize = 16;
+  static constexpr size_t kFullStringSize = 10000;
+
+  /**
+   * @brief The default constructors from std::vector.
+   *
+   */
+  HalPacket() = default;
+  HalPacket(const std::vector<uint8_t>& other) : std::vector<uint8_t>(other) {}
+
+  /**
+   * @brief A constructor of creating a HalPacket with packet type
+   * and its payload.
+   *
+   * @param type The packet type.
+   * @param payload The packet payload.
+   *
+   */
+  HalPacket(uint8_t type, const std::vector<uint8_t>& payload) {
+    resize(payload.size() + 1);
+    at(0) = type;
+    std::copy(payload.begin(), payload.end(), begin() + 1);
+  }
+
+  /**
+   * @brief Support getting the byte at an offset with other types.
+   *
+   * @param offset Template of the offset, can be enum or other numeric types.
+   * @return the byte of the offset in uint8_t.
+   *
+   */
+  template <typename T>
+  uint8_t At(T offset) const {
+    size_t index = static_cast<size_t>(offset);
+
+    if (index > size()) {
+      return 0;
+    }
+
+    return at(index);
+  }
+
+  /**
+   * @brief Support getting two bytes starting at an offset in little endian.
+   * Can be used to get packet opcodes or event codes from the packet.
+   *
+   * @param offset Template of the offset, can be enum or other numeric types.
+   * @return the two bytes starting at the offset in little endian uint16_t.
+   *
+   */
+  template <typename T>
+  uint16_t AtUint16LittleEndian(T offset) const {
+    size_t start_index = static_cast<size_t>(offset);
+
+    if (start_index + 1 >= size()) {
+      return 0;
+    }
+
+    uint8_t byte1 = at(start_index);
+    uint8_t byte2 = at(start_index + 1);
+
+    return static_cast<uint16_t>((byte2 << 8) | byte1);
+  }
+
+  /**
+   * @brief Support getting eight bytes starting at an offset in little endian.
+   *
+   * @param offset Template of the offset, can be enum or other numeric types.
+   * @return the two bytes starting at the offset in little endian uint64_t.
+   *
+   */
+  template <typename T>
+  uint64_t AtUint64LittleEndian(T offset) const {
+    size_t start_index = static_cast<size_t>(offset);
+    constexpr int kNumOfBytes = sizeof(uint64_t);
+
+    if (start_index + (kNumOfBytes - 1) >= size()) {
+      return 0;
+    }
+
+    uint64_t result = 0;
+    for (int i = 0; i < kNumOfBytes; ++i) {
+      uint8_t byte = at(start_index + i);
+      result |= (static_cast<uint64_t>(byte) << (i * 8));
+    }
+
+    return result;
+  }
+
+  /**
+   * @brief Print the payload in the HalPacket. Used for debug purposes.
+   *
+   * @return The string payload in hexdecimal.
+   *
+   */
+  std::string ToFullString() const { return ToString(kFullStringSize); }
+
+  /**
+   * @brief Returns a string representation of the first 16 bytes of the packet.
+   * If the packet has less than 16 bytes, it returns the entire packet.
+   *
+   * @return A string containing the hexadecimal representation of the first 16
+   * bytes.
+   */
+  std::string ToString() const { return ToString(kPartialStringSize); }
+
+  /**
+   * @brief Get the type of the packet. The type is defined in HciPacketType.
+   *
+   * @return The type of the packet.
+   *
+   */
+  HciPacketType GetType() const {
+    if (empty()) {
+      return HciPacketType::kUnknown;
+    }
+    uint8_t type = front();
+    if ((type >= static_cast<uint8_t>(HciPacketType::kCommand) &&
+         type <= static_cast<uint8_t>(HciPacketType::kIsoData)) ||
+        type == static_cast<uint8_t>(HciPacketType::kThreadData) ||
+        type == static_cast<uint8_t>(HciPacketType::kHdlcData)) {
+      return static_cast<HciPacketType>(type);
+    }
+
+    return HciPacketType::kUnknown;
+  }
+
+  /**
+   * @brief Get the body of the packet without the first Type byte.
+   *
+   * @return The body payload in vector<uint8_t>.
+   *
+   */
+  std::vector<uint8_t> GetBody() const {
+    if (size() <= 1) {
+      return {};
+    }
+    return std::vector(begin() + 1, end());
+  }
+
+  /* APIs for HCI commands */
+
+  /**
+   * @brief Get the command opcode of the packet if it is a HCI command.
+   *
+   * @return The command opcode. 0 if the packet is not a valid HCI command.
+   *
+   */
+  uint16_t GetCommandOpcode() const {
+    if (GetType() != HciPacketType::kCommand) {
+      return 0;
+    }
+    return size() > HciConstants::kHciCommandOpcodeOffset + 1
+               ? AtUint16LittleEndian(HciConstants::kHciCommandOpcodeOffset)
+               : 0;
+  }
+
+  /**
+   * @brief Check if the packet is a vendor HCI command.
+   *
+   * @return true of it is a vendor command, otherwise false.
+   *
+   */
+  bool IsVendorCommand() const {
+    return (GetCommandOpcode() &
+            static_cast<uint16_t>(CommandOpCode::kVendorSpecific)) ==
+           static_cast<uint16_t>(CommandOpCode::kVendorSpecific);
+  }
+
+  /* APIs for HCI events */
+
+  /**
+   * @brief Get event code of the packet, if the packet is a HCI event.
+   *
+   * @return The event code of the packet. 0 if the packet is not a valid HCI
+   * event.
+   *
+   */
+  uint8_t GetEventCode() const {
+    if (GetType() != HciPacketType::kEvent ||
+        size() <= HciConstants::kHciEventCodeOffset) {
+      return 0;
+    }
+    return at(HciConstants::kHciEventCodeOffset);
+  }
+
+  /**
+   * @brief Check if the packet is a vendor HCI event.
+   *
+   * @return true if the packet is a vendor HCI event, otherwise false.
+   *
+   */
+  bool IsVendorEvent() const {
+    return GetEventCode() == static_cast<uint8_t>(EventCode::kVendorSpecific);
+  }
+
+  /**
+   * @brief Check if the packet is a command complete event.
+   *
+   * @return true if the packet is a command complete event, otherwise false.
+   *
+   */
+  bool IsCommandCompleteEvent() const {
+    return (GetEventCode() ==
+            static_cast<uint8_t>(EventCode::kCommandComplete)) &&
+           size() > HciConstants::kHciCommandCompleteResultOffset;
+  }
+
+  /**
+   * @brief Check if the packet is a command status event.
+   *
+   * @return true if the packet is a command status event, otherwise false.
+   *
+   */
+  bool IsCommandStatusEvent() const {
+    return GetEventCode() == static_cast<uint8_t>(EventCode::kCommandStatus) &&
+           size() > HciConstants::kHciCommandStatusResultOffset;
+  }
+
+  /**
+   * @brief Get the event result if the packet is a command complete event or a
+   * command status event
+   *
+   * @return The event result in uint8.
+   *
+   */
+  uint8_t GetCommandCompleteEventResult() const {
+    uint8_t result = static_cast<uint8_t>(EventResultCode::kFailure);
+    if (IsCommandCompleteEvent()) {
+      result = at(HciConstants::kHciCommandCompleteResultOffset);
+    } else if (IsCommandStatusEvent()) {
+      result = at(HciConstants::kHciCommandStatusResultOffset);
+    }
+    return result;
+  }
+
+  /**
+   * @brief Check if the packet is a command complete event or command status
+   * event.
+   *
+   * @return true if the packet is a command complete event or command status
+   * event, otherwise false.
+   *
+   */
+  bool IsCommandCompleteStatusEvent() const {
+    return (IsCommandCompleteEvent() || IsCommandStatusEvent());
+  }
+
+  /**
+   * @brief Get the command opcode from a command complete event or a command
+   * status event.
+   *
+   * @return The command opcode if the packet is a command complete event or
+   * command status event, otherwise return 0.
+   *
+   */
+  uint16_t GetCommandOpcodeFromGeneratedEvent() const {
+    if (!IsCommandCompleteStatusEvent()) {
+      return 0;
+    }
+
+    int offset = IsCommandCompleteEvent()
+                     ? HciConstants::kHciCommandCompleteCommandOpcodeOffset
+                     : HciConstants::kHciCommandStatusCommandOpcodeOffset;
+
+    return AtUint16LittleEndian(offset);
+  }
+
+  /* APIs for BLE events */
+
+  /**
+   * @brief Check if the packet is a BLE meta event.
+   *
+   * @return true if the packet is a BLE meta event, otherwise false.
+   *
+   */
+  bool IsBleMetaEvent() const {
+    return GetEventCode() == static_cast<uint8_t>(EventCode::kBleMeta);
+  }
+
+  /**
+   * @brief Get the BLE sub-event code if the packet is a BLE meta event.
+   *
+   * @return The BLE sub-event code of the packet. 0 if the packet is not a
+   * valid BLE meta event.
+   *
+   */
+  uint8_t GetBleSubEventCode() const {
+    if (!IsBleMetaEvent()) {
+      return 0;
+    }
+    return size() > HciConstants::kHciBleEventSubCodeOffset
+               ? at(HciConstants::kHciBleEventSubCodeOffset)
+               : 0;
+  }
+
+ private:
+  std::string ToString(size_t string_size) const {
+    std::stringstream ss;
+    size_t output_size = std::min(size(), string_size);
+    ss << "(" << size() << ")[";
+    for (size_t i = 0; i < output_size; ++i) {
+      ss << std::hex << std::setw(2) << std::setfill('0')
+         << static_cast<int>(at(i));
+      if (i < size() - 1) {
+        ss << " ";
+      }
+    }
+    if (output_size < size()) {
+      ss << "... ";
+    }
+    ss << "]";
+    return ss.str();
+  }
+};
+
+/**
+ * @brief Type alias for packet routing callbacks.
+ *
+ * This type alias defines the signature for all callback functions used
+ * in packet routing.  Any function that needs to be notified about
+ * new packets should be compatible with this type.
+ *
+ * The callback function should take a single argument: a constant
+ * reference to a `HalPacket` object, which represents the received packet.
+ * The callback function does not return any value.
+ *
+ */
+using HalPacketCallback = std::function<void(const HalPacket& packet)>;
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hal_types.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hal_types.h
new file mode 100644
index 0000000000..7a3077bb34
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hal_types.h
@@ -0,0 +1,319 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include <cstdint>
+
+namespace bluetooth_hal {
+
+class Property {
+ public:
+  // Config properties.
+  static constexpr char kBqrEventMask[] = "persist.bluetooth.bqr.event_mask";
+  static constexpr char kA2dpOffloadCap[] =
+      "persist.bluetooth.a2dp_offload.cap";
+  static constexpr char kOpusEnabled[] = "persist.bluetooth.opus.enabled";
+  static constexpr char kFinderEnable[] = "persist.bluetooth.finder.enable";
+  static constexpr char kLdacDefaultQualityMode[] =
+      "persist.bluetooth.a2dp_ldac.default_quality_mode";
+  static constexpr char kTransportFallbackEnabled[] =
+      "bluetooth.transport.fallback";
+  static constexpr char kIsAcceleratedBtOnEnabled[] =
+      "persist.bluetooth.accelerate.bt.on.enabled";
+  static constexpr char kCdtHwId[] = "ro.boot.cdt_hwid";
+  static constexpr char kProductName[] = "ro.product.name";
+  static constexpr char kBuildType[] = "ro.build.type";
+  static constexpr char kShutDownAction[] = "sys.shutdown.requested";
+
+  // Transport properties.
+  static constexpr char kUartPathOverride[] =
+      "persist.vendor.bluetooth.uart_path_override";
+  static constexpr char kBtSnoopLogMode[] = "persist.bluetooth.btsnooplogmode";
+  static constexpr char kLastUartPath[] = "bluetooth.uart.last_uart_path";
+
+  // Vendor logging properties.
+  static constexpr char kBtSnoopMaxPacketsPerFileProperty[] =
+      "persist.bluetooth.vendor.btsnoopsize";
+  static constexpr char kBtVendorSnoopEnabledProperty[] =
+      "persist.bluetooth.vendor.btsnoop";
+
+  // Extension properties.
+  static constexpr char kHrModeProperty[] = "persist.bluetooth.hr_mode";
+  static constexpr char kThreadDispatcherSocketMode[] =
+      "persist.bluetooth.thread_dispatcher.socket_mode";
+  static constexpr char kChannelSoundingChangAlgoConfig[] =
+      "bluetooth.vendor.cs.change_algo_config";
+  static constexpr char kChannelSoundingVendorSpecificFirstDataByte[] =
+      "bluetooth.vendor.cs.vendor_specific_data_byte_1";
+};
+
+enum class HalState : uint8_t {
+  // Initial state, HAL is not yet started.
+  kShutdown = 0,
+  // HAL service is initially started.
+  kInit,
+  // Firmware is currently being downloaded.
+  kFirmwareDownloading,
+  // Firmware download is complete, ready to be loaded into RAM.
+  kFirmwareDownloadCompleted,
+  // Firmware is loaded into RAM, ready for initialization.
+  kFirmwareReady,
+  // All preparatory work is complete, Bluetooth chip is ready.
+  kBtChipReady,
+  // HAL is running with Bluetooth enabled.
+  kRunning,
+};
+
+namespace hci {
+// HCI UART transport packet types (refer to Bluetooth Core Specification,
+// Volume 4, Part A, Section 2).
+enum class HciPacketType : uint8_t {
+  kUnknown = 0x00,
+  kCommand = 0x01,
+  kAclData = 0x02,
+  kScoData = 0x03,
+  kEvent = 0x04,
+  kIsoData = 0x05,
+  kThreadData = 0x70,  // Vendor-specific.
+  kHdlcData = 0x7e,    // Vendor-specific.
+};
+
+enum class MonitorMode : int {
+  kNone,
+  kMonitor,
+  kIntercept,
+};
+
+class HciConstants {
+ public:
+  // 1. Preamble includes bytes after the HCI packet type and ends at the
+  // parameter total length.
+  // 2. All offset constants below are indexed from the HCI packet type.
+
+  // Two bytes for opcode, and one byte for parameter length (refer to
+  // Bluetooth Core Specification 5.4, Volume 4, Part E, Section 5.4.1).
+  static constexpr size_t kHciCommandPreambleSize = 3;
+  static constexpr int kHciCommandOpcodeOffset = 1;
+  static constexpr size_t kHciCommandLengthOffset = 3;
+
+  // Two bytes are allocated for the handle and two bytes for the data length
+  // (refer to Bluetooth Core Specification 5.4, Volume 4, Part E,
+  // Section 5.4.2).
+  static constexpr size_t kHciAclPreambleSize = 4;
+  static constexpr size_t kHciAclLengthOffset = 3;
+
+  // This structure consists of 2 bytes for the handle and 1 byte for the data
+  // length, as defined in Bluetooth Core Specification 5.4, Volume 4, Part E,
+  // section 5.4.3.
+  static constexpr size_t kHciScoPreambleSize = 3;
+  static constexpr size_t kHciScoLengthOffset = 3;
+
+  // One byte for the event code and one byte for the parameter length (refer
+  // to Bluetooth Core Specification 5.4, Volume 4, Part E, Section 5.4.4).
+  static constexpr size_t kHciEventPreambleSize = 2;
+  static constexpr size_t kHciEventCodeOffset = 1;
+  static constexpr size_t kHciEventLengthOffset = 2;
+  static constexpr size_t kHciBleEventSubCodeOffset = 3;
+
+  // Two bytes are allocated for the handle and flags, and two bytes for the
+  // data length (refer to Bluetooth Core Specification 5.4, Volume 4, Part E,
+  // Section 5.4.5).
+  static constexpr size_t kHciIsoPreambleSize = 4;
+  static constexpr size_t kHciIsoLengthOffset = 3;
+
+  // Two bytes are reserved and two bytes are allocated for the data length.
+  static constexpr size_t kHciThreadPreambleSize = 4;
+  static constexpr size_t kHciThreadLengthOffset = 3;
+
+  static constexpr size_t kHciPreambleSizeMax = kHciAclPreambleSize;
+
+  // Command Complete Event Specific Constants.
+  static constexpr size_t kHciCommandCompleteResultOffset = 6;
+  static constexpr size_t kHciCommandCompleteCommandOpcodeOffset = 4;
+
+  // Command Status Event Specific Constants.
+  static constexpr size_t kHciCommandStatusResultOffset = 3;
+  static constexpr size_t kHciCommandStatusCommandOpcodeOffset = 5;
+
+  // BQR Events Constants.
+  static constexpr size_t kHciBqrEventSubCodeOffset = 3;
+  static constexpr size_t kHciBqrReportIdOffset = 4;
+
+  static constexpr size_t GetPreambleSize(HciPacketType type) {
+    switch (type) {
+      case HciPacketType::kCommand:
+        return kHciCommandPreambleSize;
+      case HciPacketType::kAclData:
+        return kHciAclPreambleSize;
+      case HciPacketType::kScoData:
+        return kHciScoPreambleSize;
+      case HciPacketType::kEvent:
+        return kHciEventPreambleSize;
+      case HciPacketType::kIsoData:
+        return kHciIsoPreambleSize;
+      case HciPacketType::kThreadData:
+        return kHciThreadPreambleSize;
+      default:
+        return 0;
+    }
+  }
+
+  static constexpr size_t GetPacketLengthOffset(HciPacketType type) {
+    switch (type) {
+      case HciPacketType::kCommand:
+        return kHciCommandLengthOffset;
+      case HciPacketType::kAclData:
+        return kHciAclLengthOffset;
+      case HciPacketType::kScoData:
+        return kHciScoLengthOffset;
+      case HciPacketType::kEvent:
+        return kHciEventLengthOffset;
+      case HciPacketType::kIsoData:
+        return kHciIsoLengthOffset;
+      case HciPacketType::kThreadData:
+        return kHciThreadLengthOffset;
+      default:
+        return 0;
+    }
+  }
+};
+
+// Event codes as defined in Bluetooth Core Specification 5.4 Volume 4,
+// Part E, section 7.7.
+enum class EventCode : uint8_t {
+  kCommandComplete = 0x0e,
+  kCommandStatus = 0x0f,
+  kBleMeta = 0x3e,
+  kVendorSpecific = 0xff,
+};
+
+enum class GoogleEventSubCode : uint8_t {
+  kControllerDebugInfo = 0x57,
+  kBqrEvent = 0x58,
+};
+
+enum class CommandOpCode : uint16_t {
+  // Command opcodes as defined in Bluetooth Core Specification 5.4 Volume 4,
+  // Part E, section 7.
+  kSetEventMask = 0x0c01,
+  kHciReset = 0x0c03,
+  kLeSetExtendedScanParam = 0x2041,
+  kLeScanEnable = 0x2042,
+  kLeExtCreateConnection = 0x2043,
+  kCreateConnection = 0x0405,
+  kDisconnection = 0x0406,
+  kVendorSpecific = 0xfc00,
+  // Vendor command opcodes defined by Google
+  kGoogleVendorCapability = 0xfd53,
+  kGoogleDebugInfo = 0xfd5b,
+};
+
+enum class EventResultCode : uint8_t {
+  kSuccess = 0x00,
+  kFailure = 0xff,
+};
+
+}  // namespace hci
+
+namespace uart {
+
+// This enum defines the various UART baud rates that the BT HAL must support.
+enum class BaudRate : int {
+  kRate115200 = 115200,
+  kRate3000000 = 3000000,
+  kRate4000000 = 4000000,
+  kRate6000000 = 6000000,
+  kRate9600000 = 9600000,
+};
+
+}  // namespace uart
+
+namespace thread {
+
+constexpr int kInvalidFileDescriptor = -1;
+
+// Maximum Spinel payload size
+constexpr uint16_t kRadioSpinelRxFrameBufferSize = 0x2000;
+
+// Spinel command Hardware reset size
+constexpr uint8_t kHardwareResetCommandSize = 0x03;
+
+// Socket specific header
+constexpr uint8_t kSocketSpecificHeader = 0x40;
+
+// Spinel header
+constexpr uint8_t kSpinelHeader = 0x80;
+
+// Command Type
+constexpr uint8_t kThreadCommandReset = 0x01;
+
+// Sub command Type
+constexpr uint8_t kThreadCommandResetHardware = 0x04;
+
+constexpr char kThreadDispatcherFolderPath[] = "/data/vendor/bluetooth";
+
+constexpr char kThreadDispatcherSocketPath[] =
+    "/data/vendor/bluetooth/thread_dispatcher_socket";
+
+}  // namespace thread
+
+namespace transport {
+
+constexpr int kMaxTransportTypes = 1000;
+
+enum class TransportType : int {
+  kUartH4 = 1,
+  kVendorStart = 100,
+  kVendorEnd = 199,  // Reserve types from 100 to 199 for vendors.
+  kUnknown = kMaxTransportTypes,
+};
+
+}  // namespace transport
+
+namespace util {
+namespace power {
+
+/**
+ * @brief Enumerates the sources that can trigger a "wake-up" event in the
+ * system.
+ *
+ * This enum defines the different components or processes that might need to
+ * signal a wake-up condition. Each enumerator represents a specific source
+ * and provides context for why a wake-up might be necessary.
+ *
+ * kTx: Used in all TX tasks, release after packet is written to transport.
+ * kRx: Used in all RX tasks, release when packet is despatched to the client.
+ * kHciBusy: Used to cover HCI command and event flow control.
+ * kTransport: Used by the transport layer. The use case can be variant based on
+ * it's requirement.
+ * kInitialize: Used during the initialization of the HAL.
+ * kClose: Used during the closing of the HAL.
+ */
+enum class WakeSource : uint8_t {
+  kTx,
+  kRx,
+  kHciBusy,
+  kTransport,
+  kInitialize,
+  kClose,
+};
+
+}  // namespace power
+}  // namespace util
+
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_monitor.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_monitor.h
new file mode 100644
index 0000000000..493c929d62
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_monitor.h
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <map>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+// Enum remains the same
+enum class MonitorType : int {
+  kNone,
+  kCommand,
+  kEvent,
+  kThread,
+};
+
+class HciMonitor {
+ public:
+  HciMonitor(MonitorType type, uint16_t primary_code)
+      : type_(type), primary_code_(primary_code) {}
+
+  void MonitorOffset(int offset, uint8_t data) {
+    monitor_offset_map_[offset] = data;
+  }
+
+  bool operator==(const HciMonitor& other) const {
+    return type_ == other.GetType() &&
+           primary_code_ == other.GetPrimaryCode() &&
+           monitor_offset_map_ == other.monitor_offset_map_;
+  }
+
+  bool operator==(const ::bluetooth_hal::hci::HalPacket& packet) const {
+    uint16_t packet_primary_code = 0;
+    bool type_match = false;
+
+    if (packet.GetType() == ::bluetooth_hal::hci::HciPacketType::kCommand &&
+        type_ == MonitorType::kCommand) {
+      type_match = true;
+      packet_primary_code = packet.GetCommandOpcode();
+    } else if (packet.GetType() ==
+                   ::bluetooth_hal::hci::HciPacketType::kEvent &&
+               type_ == MonitorType::kEvent) {
+      type_match = true;
+      packet_primary_code = packet.GetEventCode();
+    } else if (packet.GetType() ==
+                   ::bluetooth_hal::hci::HciPacketType::kThreadData &&
+               type_ == MonitorType::kThread) {
+      type_match = true;
+      // ThreadData packets don't have a primary code like opcode or event code.
+      // We only match based on type and potential offsets.
+      packet_primary_code = primary_code_;
+    }
+
+    if (!type_match) {
+      return false;
+    }
+
+    if (primary_code_ != packet_primary_code) {
+      return false;
+    }
+
+    for (const auto& pair : monitor_offset_map_) {
+      int offset = pair.first;
+      uint8_t expected_data = pair.second;
+      // Check bounds and data value
+      if (offset < 0 || static_cast<size_t>(offset) >= packet.size() ||
+          packet[offset] != expected_data) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  bool operator<(const HciMonitor& other) const {
+    if (type_ != other.type_) {
+      return type_ < other.type_;
+    }
+    if (primary_code_ != other.primary_code_) {
+      return primary_code_ < other.primary_code_;
+    }
+    return monitor_offset_map_ < other.monitor_offset_map_;
+  }
+
+ protected:
+  MonitorType GetType() const { return type_; }
+  uint16_t GetPrimaryCode() const { return primary_code_; }
+
+  const std::map<int, uint8_t>& GetMonitorOffsets() const {
+    return monitor_offset_map_;
+  }
+
+ private:
+  MonitorType type_;
+  uint16_t primary_code_;
+  std::map<int, uint8_t> monitor_offset_map_;
+};
+
+class HciEventMonitor : public HciMonitor {
+ public:
+  explicit HciEventMonitor(uint8_t event_code)
+      : HciMonitor(MonitorType::kEvent, static_cast<uint16_t>(event_code)) {}
+
+  HciEventMonitor(uint8_t event_code, uint8_t sub_event_code,
+                  int sub_event_offset)
+      : HciMonitor(MonitorType::kEvent, static_cast<uint16_t>(event_code)) {
+    MonitorOffset(sub_event_offset, sub_event_code);
+  }
+};
+
+class HciBleMetaEventMonitor : public HciEventMonitor {
+ public:
+  explicit HciBleMetaEventMonitor(uint8_t ble_event_code)
+      : HciEventMonitor(static_cast<uint8_t>(EventCode::kBleMeta),
+                        ble_event_code,
+                        HciConstants::kHciBleEventSubCodeOffset) {}
+};
+
+class HciBqrEventMonitor : public HciEventMonitor {
+ public:
+  HciBqrEventMonitor()
+      : HciEventMonitor(static_cast<uint8_t>(EventCode::kVendorSpecific),
+                        static_cast<uint8_t>(GoogleEventSubCode::kBqrEvent),
+                        HciConstants::kHciBqrEventSubCodeOffset) {}
+  explicit HciBqrEventMonitor(uint8_t report_id)
+      : HciEventMonitor(static_cast<uint8_t>(EventCode::kVendorSpecific),
+                        static_cast<uint8_t>(GoogleEventSubCode::kBqrEvent),
+                        HciConstants::kHciBqrEventSubCodeOffset) {
+    MonitorOffset(HciConstants::kHciBqrReportIdOffset, report_id);
+  }
+};
+
+class HciCommandCompleteEventMonitor : public HciEventMonitor {
+ public:
+  HciCommandCompleteEventMonitor(uint16_t command_opcode)
+      : HciEventMonitor(static_cast<uint8_t>(EventCode::kCommandComplete)) {
+    uint8_t byte1 = static_cast<uint8_t>(command_opcode);
+    uint8_t byte2 = static_cast<uint8_t>(command_opcode >> 8);
+    MonitorOffset(HciConstants::kHciCommandCompleteCommandOpcodeOffset, byte1);
+    MonitorOffset(HciConstants::kHciCommandCompleteCommandOpcodeOffset + 1,
+                  byte2);
+  }
+};
+
+class HciCommandStatusEventMonitor : public HciEventMonitor {
+ public:
+  HciCommandStatusEventMonitor(uint16_t command_opcode)
+      : HciEventMonitor(static_cast<uint8_t>(EventCode::kCommandStatus)) {
+    uint8_t byte1 = static_cast<uint8_t>(command_opcode);
+    uint8_t byte2 = static_cast<uint8_t>(command_opcode >> 8);
+    MonitorOffset(HciConstants::kHciCommandStatusCommandOpcodeOffset, byte1);
+    MonitorOffset(HciConstants::kHciCommandStatusCommandOpcodeOffset + 1,
+                  byte2);
+  }
+};
+
+class HciCommandMonitor : public HciMonitor {
+ public:
+  explicit HciCommandMonitor(uint16_t opcode)
+      : HciMonitor(MonitorType::kCommand, opcode) {}
+
+  HciCommandMonitor(uint16_t opcode, uint8_t sub_opcode, int sub_opcode_offset)
+      : HciMonitor(MonitorType::kCommand, opcode) {
+    MonitorOffset(sub_opcode_offset, sub_opcode);
+  }
+};
+
+class HciThreadMonitor : public HciMonitor {
+ public:
+  HciThreadMonitor() : HciMonitor(MonitorType::kThread, 0) {}
+
+  HciThreadMonitor(int offset, uint8_t data) : HciThreadMonitor() {
+    MonitorOffset(offset, data);
+  }
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router.h
new file mode 100644
index 0000000000..816c5442e6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_callback.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HciRouter {
+ public:
+  virtual ~HciRouter() = default;
+
+  /**
+   * @brief Get the singleton instance of HciRouter.
+   *
+   * @return The singleton instance of HciRouter.
+   *
+   */
+  static HciRouter& GetRouter();
+
+  /**
+   * @brief Initialize the HciRouter instance with callbacks from the Bluetooth
+   * stack. It also initializes the layers below the HciRouter.
+   *
+   * @return true if success, otherwise false.
+   *
+   */
+  virtual bool Initialize(
+      const std::shared_ptr<HciRouterCallback>& callback) = 0;
+
+  /**
+   * @brief Cleanup callbacks and de-initialize the lower layers.
+   */
+  virtual void Cleanup() = 0;
+
+  /**
+   * @brief Send data to the Bluetooth chip. Used for all types of data. The
+   * corresponding command complete/status event will be returned to the main
+   * HCI aidl client if the sent data is a command.
+   *
+   * @param packet The packet instance that was requested to be sent.
+   *
+   * @return true if the packet was sent successfully, otherwise false.
+   *
+   */
+  virtual bool Send(const HalPacket& packet) = 0;
+
+  /**
+   * @brief Send a HCI command to the Bluetooth chip. The corresponding command
+   * complete/status event will be returned to the HciRouterCallback instead
+   * of the main HCI aidl client.
+   *
+   * @param packet The HCI command that was requested to be sent.
+   * @param callback The callback for the corresponding event for the command.
+   *
+   * @return true if the command was sent successfully, otherwise false.
+   *
+   */
+  virtual bool SendCommand(const HalPacket& packet,
+                           const HalPacketCallback& callback) = 0;
+
+  /**
+   * @brief Send a HCI command to the Bluetooth chip. The command sent over this
+   * method skips the HCI flow control in the Bluetooth HAL. Used for some
+   * speicall vendor commands which do not return a command complete/status
+   * event.
+   *
+   * @param packet The HCI command that was requested to be sent.
+   *
+   * @return true if the command was sent successfully, otherwise false.
+   *
+   */
+  virtual bool SendCommandNoAck(const HalPacket& packet) = 0;
+
+  /**
+   * @brief Get the current state of the HciRouter state machine.
+   *
+   * @return The current state of the state machine.
+   *
+   */
+  virtual ::bluetooth_hal::HalState GetHalState() = 0;
+
+  /**
+   * @brief Update the current state of the HciRouter state machine.
+   *
+   * @param state The state to which the HCI router would change.
+   *
+   */
+  virtual void UpdateHalState(::bluetooth_hal::HalState state) = 0;
+
+  /**
+   * @brief Send the packet to the stack through HCI Router.
+   *
+   * All packets that are not from the controller and need to be sent to the
+   * stack must first be processed by the HCI router. This function ensures that
+   * the HCI router eventually routes them to the stack.
+   *
+   * @param packet The packet that would be sent to the stack.
+   *
+   */
+  virtual void SendPacketToStack(const HalPacket& packet) = 0;
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_callback.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_callback.h
new file mode 100644
index 0000000000..2989492e67
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_callback.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HciRouterCallback {
+ public:
+  virtual ~HciRouterCallback() = default;
+
+  /**
+   * @brief Callback for the command complete and command status events.
+   *
+   * @param packet The HCI event packet.
+   */
+  virtual void OnCommandCallback(const HalPacket& packet) = 0;
+
+  /**
+   * @brief Callback for the packets other than command complete and command
+   * status events
+   *
+   * @param packet The HCI event packet.
+   * @return The monitor mode of the callback handling the packet.
+   */
+  virtual MonitorMode OnPacketCallback(const HalPacket& packet) = 0;
+
+  /**
+   * @brief Callback for the HAL state change from the HciRouter.
+   *
+   * @param previous_state The previous HAL state.
+   * @param new_state The new HAL state.
+   */
+  virtual void OnHalStateChanged(const ::bluetooth_hal::HalState new_state,
+                                 const ::bluetooth_hal::HalState old_state) = 0;
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client.h
new file mode 100644
index 0000000000..a8f1019b84
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client.h
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <map>
+#include <mutex>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_client_callback.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HciRouterClient : public HciRouterClientCallback {
+ public:
+  HciRouterClient();
+  ~HciRouterClient();
+
+  /**
+   * @brief Called when the controller responds to a command.
+   *
+   * @param packet The HAL packet containing the response.
+   *
+   * @note Subclasses **must** implement this method to use the `send_command`
+   * function.
+   *
+   */
+  virtual void OnCommandCallback(const HalPacket& packet) override = 0;
+
+  /**
+   * @brief Called when the router client receives an HCI packet.
+   *
+   * @param packet The HAL packet containing the HCI event.
+   *
+   * @return A `MonitorMode` value indicating whether the packet should be
+   * processed by other clients.
+   *
+   * @note The default implementation allows each client to register HCI
+   * monitors to monitor/intercept HCI event. If a client does not require this
+   * functionality, it can directly override this method with its specific
+   * implementation.
+   *
+   */
+  MonitorMode OnPacketCallback(const HalPacket& packet) override;
+
+  /**
+   * @brief Called when the HAL state changes.
+   *
+   * @param old_state The old HAL state.
+   * @param new_state The new HAL state.
+   *
+   * @note It is **not recommended** to implement this method. The
+   * `HciRouterClientAgent` class handles all HAL state change logic. Instead,
+   * subclasses can use the following methods to determine the HAL state:
+   *        - `OnBluetoothChipReady()`
+   *        - `OnBluetoothChipClosed()`
+   *        - `OnBluetoothEnabled()`
+   *        - `OnBluetoothDisabled()`
+   *        - `IsBluetoothEnabled()`
+   *        - `IsBluetoothChipReady()`
+   *
+   */
+  void OnHalStateChanged(
+      [[maybe_unused]] ::bluetooth_hal::HalState new_state,
+      [[maybe_unused]] ::bluetooth_hal::HalState old_state) override {};
+
+ protected:
+  /**
+   * @brief Callback invoked when a received HCI packet matches a registered
+   * monitor.
+   *
+   * This method is invoked by the `HciRouterClient` class when an incoming HCI
+   * packet is received that matches the monitor mode registered by the
+   * `RegisterMonitor` method.
+   *
+   * @param mode The monitor mode that was triggered.
+   * @param packet The received HCI packet.
+   *
+   */
+  virtual void OnMonitorPacketCallback(MonitorMode mode,
+                                       const HalPacket& packet) = 0;
+
+  /**
+   * @brief Called when the Bluetooth chip is ready.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to `HalState::kBtChipReady`.
+   *
+   */
+  virtual void OnBluetoothChipReady() = 0;
+
+  /**
+   * @brief Called when the Bluetooth chip is closed.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to the state < `HalState::kBtChipReady`.
+   *
+   */
+  virtual void OnBluetoothChipClosed() = 0;
+
+  /**
+   * @brief Called when Bluetooth is enabled.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to `HalState::kRunning`.
+   *
+   */
+  virtual void OnBluetoothEnabled() = 0;
+
+  /**
+   * @brief Called when Bluetooth is enabled.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to the stat < `HalState::kRunning`.
+   *
+   */
+  virtual void OnBluetoothDisabled() = 0;
+
+  /**
+   * @brief Returns whether Bluetooth is enabled.
+   *
+   * @return `true` if Bluetooth is enabled, `false` otherwise.
+   *
+   */
+  bool IsBluetoothEnabled();
+
+  /**
+   * @brief Returns whether the Bluetooth chip is ready.
+   *
+   * @return `true` if the Bluetooth chip is ready, `false` otherwise.
+   *
+   */
+  bool IsBluetoothChipReady();
+
+  /**
+   * @brief Registers a monitor to receive HCI events.
+   *
+   * @param monitor The monitor to register.
+   * @param mode The monitor mode to register.
+   *
+   * @return `true` if the monitor was registered successfully, `false`
+   * otherwise.
+   *
+   */
+  bool RegisterMonitor(const HciMonitor& monitor, MonitorMode mode);
+
+  /**
+   * @brief Unregisters a monitor.
+   *
+   * @param monitor The monitor to unregister.
+   *
+   * @return `true` if the monitor was unregistered successfully, `false`
+   * otherwise.
+   *
+   */
+  bool UnregisterMonitor(const HciMonitor& monitor);
+
+  /**
+   * @brief Sends a command to the HCI router.
+   *
+   * This method should only be used to send HCI commands.
+   *
+   * @param packet The HAL packet containing the command.
+   *
+   * @return `true` if the command was sent successfully, `false` otherwise.
+   *
+   */
+  bool SendCommand(const HalPacket& packet);
+
+  /**
+   * @brief Sends data to the HCI router.
+   *
+   * This method can be used to send various types of packets to the HAL,
+   * excluding HCI commands and events.
+   *
+   * @param packet The HAL packet containing the data.
+   *
+   * @return `true` if the data was sent successfully, `false` otherwise.
+   *
+   */
+  bool SendData(const HalPacket& packet);
+
+ private:
+  std::map<HciMonitor, MonitorMode> monitors_;
+  std::recursive_mutex mutex_;
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client_agent.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client_agent.h
new file mode 100644
index 0000000000..e4b8e0b298
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client_agent.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_client_callback.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HciRouterClientAgent {
+ public:
+  virtual ~HciRouterClientAgent() = default;
+
+  /**
+   * @brief Get the singleton instance of HciRouterClientAgent.
+   *
+   * @return The singleton instance of HciRouterClientAgent.
+   *
+   */
+  static HciRouterClientAgent& GetAgent();
+
+  /**
+   * @brief Reigster HciRouterClientCallback for the agent to service.
+   *
+   * @param callback The callback for the HciRouter client.
+   * @return true if the callback is registered, otherwise false.
+   *
+   */
+  virtual bool RegisterRouterClient(HciRouterClientCallback* callback) = 0;
+
+  /**
+   * @brief Unreigster HciRouterClientCallback from the agent.
+   *
+   * @param callback The callback for the HciRouter client.
+   *
+   * @return true if the callback is registered, otherwise false.
+   *
+   */
+  virtual bool UnregisterRouterClient(HciRouterClientCallback* callback) = 0;
+
+  /**
+   * @brief Called when the router receives an HCI packet. The router agent will
+   * try to dispatch the packet to the interested clients.
+   *
+   * @param packet The HAL packet containing the HCI event.
+   *
+   * @return A `MonitorMode` value indicating whether the packet should be
+   * processed by other clients.
+   *
+   */
+  virtual MonitorMode DispatchPacketToClients(const HalPacket& packet) = 0;
+
+  /**
+   * @brief Called when the HAL state changes.
+   *
+   * @param old_state The old HAL state.
+   * @param new_state The new HAL state.
+   *
+   * @note The `HciRouterClientAgent` uses below method to inform
+   * HciRouterClients for HAL state changes.
+   *        - `OnBluetoothChipReady()`
+   *        - `OnBluetoothChipClosed()`
+   *        - `OnBluetoothEnabled()`
+   *        - `OnBluetoothDisabled()`
+   *
+   */
+  virtual void NotifyHalStateChange(HalState new_state, HalState old_state) = 0;
+
+  /**
+   * @brief Returns whether Bluetooth is enabled.
+   *
+   * @return `true` if Bluetooth is enabled, `false` otherwise.
+   *
+   */
+  virtual bool IsBluetoothEnabled() = 0;
+
+  /**
+   * @brief Returns whether the Bluetooth chip is ready.
+   *
+   * @return `true` if the Bluetooth chip is ready, `false` otherwise.
+   *
+   */
+  virtual bool IsBluetoothChipReady() = 0;
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client_callback.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client_callback.h
new file mode 100644
index 0000000000..d716477b3a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/hci_router_client_callback.h
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router_callback.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+class HciRouterClientCallback : public HciRouterCallback {
+ public:
+  virtual ~HciRouterClientCallback() = default;
+
+  /**
+   * @brief Called when the controller responds to a command.
+   *
+   * @param packet The HAL packet containing the response.
+   *
+   * @note Subclasses **must** implement this method to use the `send_command`
+   * function.
+   *
+   */
+  virtual void OnCommandCallback(const HalPacket& packet) override = 0;
+
+  /**
+   * @brief Called when the router client receives an HCI packet.
+   *
+   * @param packet The HAL packet containing the HCI event.
+   *
+   * @return A `MonitorMode` value indicating whether the packet should be
+   * processed by other clients.
+   *
+   * @note The default implementation allows each client to register HCI
+   * monitors to monitor/intercept HCI event. If a client does not require this
+   * functionality, it can directly override this method with its specific
+   * implementation.
+   *
+   */
+  virtual MonitorMode OnPacketCallback(const HalPacket& packet) override = 0;
+
+  /**
+   * @brief Called when the HAL state changes.
+   *
+   * @param old_state The old HAL state.
+   * @param new_state The new HAL state.
+   *
+   * @note It is **not recommended** to implement this method. The
+   * `HciRouterClientAgent` class handles all HAL state change logic. Instead,
+   * subclasses can use the following methods to determine the HAL state:
+   *        - `OnBluetoothChipReady()`
+   *        - `OnBluetoothChipClosed()`
+   *        - `OnBluetoothEnabled()`
+   *        - `OnBluetoothDisabled()`
+   *        - `IsBluetoothEnabled()`
+   *        - `IsBluetoothChipReady()`
+   *
+   */
+  virtual void OnHalStateChanged(HalState new_state,
+                                 HalState old_state) override = 0;
+
+  /**
+   * @brief Called when the Bluetooth chip is ready.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to `HalState::kBtChipReady`.
+   *
+   */
+  virtual void OnBluetoothChipReady() = 0;
+
+  /**
+   * @brief Called when the Bluetooth chip is closed.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to the state < `HalState::kBtChipReady`.
+   *
+   */
+  virtual void OnBluetoothChipClosed() = 0;
+
+  /**
+   * @brief Called when Bluetooth is enabled.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to `HalState::kRunning`.
+   *
+   */
+  virtual void OnBluetoothEnabled() = 0;
+
+  /**
+   * @brief Called when Bluetooth is enabled.
+   *
+   * This method is invoked by the `HciRouterClient` class when the HAL state
+   * changes to the stat < `HalState::kRunning`.
+   *
+   */
+  virtual void OnBluetoothDisabled() = 0;
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/common/test_helper.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/common/test_helper.h
new file mode 100644
index 0000000000..f7a5926748
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/common/test_helper.h
@@ -0,0 +1,335 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <algorithm>
+#include <cstddef>
+#include <cstdint>
+#include <optional>
+#include <ostream>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace util {
+
+class MockPacketHandler {
+ public:
+  MockPacketHandler() = default;
+  ~MockPacketHandler() = default;
+
+  MockPacketHandler(const MockPacketHandler&) = delete;
+  MockPacketHandler& operator=(const MockPacketHandler&) = delete;
+
+  MOCK_METHOD(void, HalPacketCallback,
+              (const ::bluetooth_hal::hci::HalPacket& packet));
+
+  MOCK_METHOD(void, PacketReadyCb, ());
+};
+
+template <typename ExpectedType, typename ActualType>
+class BaseMatcher : public ::testing::MatcherInterface<ActualType> {
+ public:
+  /**
+   * @brief Constructor for BaseMatcher.
+   *
+   * @param expected_content The expected value to be compared against.
+   * @param expected_size Optional size of the expected content (for byte
+   * comparison).
+   *
+   */
+  explicit BaseMatcher(ExpectedType expected_content,
+                       std::optional<size_t> expected_size = std::nullopt)
+      : expected_content_(expected_content), expected_size_(expected_size) {}
+
+  /**
+   * @brief Checks if the actual value matches the expected value and explains
+   * the result.
+   *
+   * This pure virtual function must be implemented by derived classes to define
+   * the specific matching logic.
+   *
+   * @param actual_value The actual value being compared.
+   * @param listener The listener to receive match result explanation.
+   *
+   * @return True if the actual value matches the expected value, false
+   * otherwise.
+   *
+   */
+  virtual bool MatchAndExplain(
+      ActualType actual_value,
+      ::testing::MatchResultListener* listener) const = 0;
+
+  /**
+   * @brief Describes the matcher (what it expects) to an output stream.
+   *
+   * This function is used to describe what the matcher expects in case of a
+   * mismatch.
+   *
+   * @param os The output stream to write the description to.
+   *
+   */
+  void DescribeTo([[maybe_unused]] std::ostream* os) const override {}
+
+  /**
+   * @brief Describes the negation of the matcher to an output stream.
+   *
+   * This function is used to describe what the matcher does not expect in case
+   * of a match.
+   *
+   * @param os The output stream to write the negation description to.
+   *
+   */
+  void DescribeNegationTo([[maybe_unused]] std::ostream* os) const override {}
+
+ protected:
+  ExpectedType expected_content_;
+  std::optional<size_t> expected_size_;
+};
+
+/**
+ * @brief A matcher class for comparing string values.
+ *
+ * This matcher compares two values as null-terminated C-style strings.
+ *
+ * @tparam ExpectedType The type of the expected value (typically const char*).
+ * @tparam ActualType The type of the actual value being compared (typically
+ * const char*).
+ *
+ */
+template <typename ExpectedType, typename ActualType>
+class StringMatcher : public BaseMatcher<ExpectedType, ActualType> {
+ public:
+  /**
+   * @brief Constructor for StringMatcher.
+   *
+   * @param expected_content The expected string value.
+   *
+   */
+  explicit StringMatcher(ExpectedType expected_content)
+      : BaseMatcher<ExpectedType, ActualType>(expected_content) {}
+
+  /**
+   * @brief Checks if the actual string matches the expected string and explains
+   * the result.
+   *
+   * @param actual_content The actual string value being compared.
+   * @param listener The listener to receive match result explanation (unused in
+   * this implementation).
+   *
+   * @return True if the actual string matches the expected string, false
+   * otherwise.
+   *
+   */
+  bool MatchAndExplain(ActualType actual_content,
+                       [[maybe_unused]] ::testing::MatchResultListener*
+                           listener) const override {
+    return std::string(this->expected_content_) == std::string(actual_content);
+  }
+};
+
+/**
+ * @brief A matcher class for comparing byte content.
+ *
+ * This matcher compares two byte arrays for equality.
+ *
+ * @tparam ExpectedType The type of the expected value (typically const
+ * uint8_t*).
+ * @tparam ActualType The type of the actual value being compared (typically
+ * const void*).
+ *
+ */
+template <typename ExpectedType, typename ActualType>
+class ByteContentMatcher : public BaseMatcher<ExpectedType, ActualType> {
+ public:
+  /**
+   * @brief Constructor for ByteContentMatcher.
+   *
+   * @param expected_content The expected byte content.
+   * @param expected_size The size of the expected byte content.
+   *
+   */
+  ByteContentMatcher(ExpectedType expected_content, size_t expected_size)
+      : BaseMatcher<ExpectedType, ActualType>(expected_content, expected_size) {
+  }
+
+  /**
+   * @brief Checks if the actual byte content matches the expected byte content
+   * and explains the result.
+   *
+   * @param actual_content The actual byte content being compared.
+   * @param listener The listener to receive match result explanation (unused in
+   * this implementation).
+   *
+   * @return True if the actual byte content matches the expected byte content,
+   * false otherwise.
+   *
+   */
+  bool MatchAndExplain(ActualType actual_content,
+                       [[maybe_unused]] ::testing::MatchResultListener*
+                           listener) const override {
+    const auto* actual_byte = reinterpret_cast<const uint8_t*>(actual_content);
+    return std::equal(actual_byte, actual_byte + this->expected_size_.value(),
+                      this->expected_content_);
+  }
+};
+
+/**
+ * @brief A matcher class for comparing vector values.
+ *
+ * This matcher compares two vectors for equality.
+ *
+ * @tparam ExpectedType The type of the expected value (typically
+ * std::vector<T>).
+ * @tparam ActualType The type of the actual value being compared (typically
+ * std::vector<T>).
+ *
+ */
+template <typename ExpectedType, typename ActualType>
+class VectorMatcher : public BaseMatcher<ExpectedType, ActualType> {
+ public:
+  /**
+   * @brief Constructor for VectorMatcher.
+   *
+   * @param expected_content The expected vector value.
+   *
+   */
+  explicit VectorMatcher(ExpectedType expected_content)
+      : BaseMatcher<ExpectedType, ActualType>(expected_content) {}
+
+  /**
+   * @brief Checks if the actual vector matches the expected vector and explains
+   * the result.
+   *
+   * @param actual_content The actual vector value being compared.
+   * @param listener The listener to receive match result explanation (unused in
+   * this implementation).
+   *
+   * @return True if the actual vector matches the expected vector, false
+   * otherwise.
+   *
+   */
+  bool MatchAndExplain(ActualType actual_content,
+                       [[maybe_unused]] ::testing::MatchResultListener*
+                           listener) const override {
+    return this->expected_content_ == actual_content;
+  }
+};
+
+/**
+ * @brief A factory class for creating various matcher objects.
+ *
+ * This class provides static factory methods for creating different types of
+ * matchers.
+ */
+class MatcherFactory {
+ public:
+  /**
+   * @brief Creates a StringMatcher for comparing string values.
+   *
+   * @tparam ExpectedType The type of the expected value (typically const
+   * char*).
+   * @tparam ActualType The type of the actual value being compared (defaults to
+   * const char*).
+   *
+   * @param expected_content The expected string value.
+   *
+   * @return A ::testing::Matcher object that can be used to compare string
+   * values.
+   *
+   */
+  template <typename ExpectedType, typename ActualType = const char*>
+  static ::testing::Matcher<ActualType> CreateStringMatcher(
+      ExpectedType expected_content) {
+    return ::testing::MakeMatcher(
+        new StringMatcher<ExpectedType, ActualType>(expected_content));
+  }
+
+  /**
+   * @brief Creates a ByteContentMatcher for comparing byte content.
+   *
+   * @tparam ExpectedType The type of the expected value (typically const
+   * uint8_t*).
+   * @tparam ActualType The type of the actual value being compared (defaults to
+   * const void*).
+   *
+   * @param expected_content The expected byte content.
+   * @param expected_size The size of the expected byte content.
+   *
+   * @return A ::testing::Matcher object that can be used to compare byte
+   * content.
+   *
+   */
+  template <typename ExpectedType, typename ActualType = const void*>
+  static ::testing::Matcher<ActualType> CreateByteContentMatcher(
+      ExpectedType expected_content, size_t expected_size) {
+    return ::testing::MakeMatcher(
+        new ByteContentMatcher<ExpectedType, ActualType>(expected_content,
+                                                         expected_size));
+  }
+
+  /**
+   * @brief Creates a VectorMatcher for comparing vector values.
+   *
+   * @tparam ExpectedType The type of the expected value (typically
+   * std::vector<T>).
+   * @tparam ActualType The type of the actual value being compared (defaults to
+   * const std::vector<uint8_t>&).
+   *
+   * @param expected_content The expected vector value.
+   *
+   * @return A ::testing::Matcher object that can be used to compare vector
+   * values.
+   *
+   */
+  template <typename ExpectedType,
+            typename ActualType = const std::vector<uint8_t>&>
+  static ::testing::Matcher<ActualType> CreateVectorMatcher(
+      ExpectedType expected_content) {
+    return ::testing::MakeMatcher(
+        new VectorMatcher<ExpectedType, ActualType>(expected_content));
+  }
+
+  /**
+   * @brief Creates a VectorMatcher for comparing HalPacket values.
+   *
+   * @tparam ExpectedType The type of the expected value (typically
+   * std::vector<T>).
+   * @tparam ActualType The type of the actual value being compared (defaults to
+   * const ::bluetooth_hal::hci::HalPacket&).
+   *
+   * @param expected_content The expected HalPacket value.
+   *
+   * @return A ::testing::Matcher object that can be used to compare HalPacket
+   * values.
+   *
+   */
+  template <typename ExpectedType,
+            typename ActualType = const ::bluetooth_hal::hci::HalPacket&>
+  static ::testing::Matcher<ActualType> CreateHalPacketMatcher(
+      ExpectedType expected_content) {
+    return ::testing::MakeMatcher(
+        new VectorMatcher<ExpectedType, ActualType>(expected_content));
+  }
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_android_base_wrapper.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_android_base_wrapper.h
new file mode 100644
index 0000000000..43703c9561
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_android_base_wrapper.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+
+#include "bluetooth_hal/util/android_base_wrapper.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace util {
+
+class MockAndroidBaseWrapper : public AndroidBaseWrapper {
+ public:
+  MOCK_METHOD(std::string, GetProperty,
+              (const std::string& key, const std::string& default_value),
+              (override));
+
+  MOCK_METHOD(bool, GetBoolProperty,
+              (const std::string& key, bool default_value), (override));
+
+  MOCK_METHOD(bool, SetProperty,
+              (const std::string& key, const std::string& value), (override));
+
+  MOCK_METHOD(bool, ParseUint,
+              (const std::string& s, uint8_t* out, uint8_t max), (override));
+
+  static void SetMockWrapper(MockAndroidBaseWrapper* wrapper);
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_cs_config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_cs_config_loader.h
new file mode 100644
index 0000000000..17d45225a8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_cs_config_loader.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <vector>
+
+#include "bluetooth_hal/config/cs_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+class MockCsConfigLoader;
+static MockCsConfigLoader* mock_cs_config_loader = nullptr;
+
+class MockCsConfigLoader : public CsConfigLoader {
+ public:
+  MOCK_METHOD(bool, LoadConfig, (), (override));
+
+  MOCK_METHOD(const std::vector<::bluetooth_hal::hci::HalPacket>&,
+              GetCsCalibrationCommands, (), (const, override));
+  MOCK_METHOD(std::string, DumpConfigToString, (), (const, override));
+
+  static CsConfigLoader& GetLoader();
+
+  static void SetMockLoader(MockCsConfigLoader* loader);
+};
+
+CsConfigLoader& CsConfigLoader::GetLoader() { return *mock_cs_config_loader; }
+
+void MockCsConfigLoader::SetMockLoader(MockCsConfigLoader* loader) {
+  mock_cs_config_loader = loader;
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_firmware_config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_firmware_config_loader.h
new file mode 100644
index 0000000000..29ab7dd47d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_firmware_config_loader.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <functional>
+#include <optional>
+
+#include "bluetooth_hal/config/firmware_config_loader.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+class MockFirmwareConfigLoader;
+static MockFirmwareConfigLoader* mock_firmware_config_loader = nullptr;
+
+class MockFirmwareConfigLoader : public FirmwareConfigLoader {
+ public:
+  MOCK_METHOD(bool, LoadConfig, (), (override));
+
+  MOCK_METHOD(bool, ResetFirmwareDataLoadingState, (), (override));
+
+  MOCK_METHOD(std::optional<DataPacket>, GetNextFirmwareData, (), (override));
+
+  MOCK_METHOD(std::optional<std::reference_wrapper<const SetupCommandPacket>>,
+              GetSetupCommandPacket, (SetupCommandType), (const, override));
+
+  MOCK_METHOD(int, GetLoadMiniDrvDelayMs, (), (const, override));
+
+  MOCK_METHOD(int, GetLaunchRamDelayMs, (), (const, override));
+
+  MOCK_METHOD(std::string, DumpConfigToString, (), (const, override));
+
+  static FirmwareConfigLoader& GetLoader();
+
+  static void ResetLoader();
+
+  static void SetMockLoader(MockFirmwareConfigLoader* loader);
+};
+
+FirmwareConfigLoader& FirmwareConfigLoader::GetLoader() {
+  return *mock_firmware_config_loader;
+}
+
+void MockFirmwareConfigLoader::SetMockLoader(MockFirmwareConfigLoader* loader) {
+  mock_firmware_config_loader = loader;
+}
+
+void FirmwareConfigLoader::ResetLoader() {
+  if (mock_firmware_config_loader != nullptr) {
+    delete mock_firmware_config_loader;
+    mock_firmware_config_loader = nullptr;
+  }
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hal_config_loader.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hal_config_loader.h
new file mode 100644
index 0000000000..5b0f165138
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hal_config_loader.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace config {
+
+class MockHalConfigLoader;
+static MockHalConfigLoader* mock_hal_config_loader = nullptr;
+
+class MockHalConfigLoader : public HalConfigLoader {
+ public:
+  MOCK_METHOD(bool, LoadConfig, (), (override));
+
+  MOCK_METHOD(bool, IsFastDownloadEnabled, (), (const, override));
+
+  MOCK_METHOD(bool, IsSarBackoffHighResolutionEnabled, (), (const, override));
+
+  MOCK_METHOD(int, GetBtRegOnDelayMs, (), (const, override));
+
+  MOCK_METHOD(const std::string&, GetBtUartDevicePort, (), (const, override));
+
+  MOCK_METHOD(const std::vector< ::bluetooth_hal::transport::TransportType>&,
+              GetTransportTypePriority, (), (const, override));
+
+  MOCK_METHOD(bool, IsAcceleratedBtOnSupported, (), (const, override));
+
+  MOCK_METHOD(bool, IsThreadDispatcherEnabled, (), (const, override));
+
+  MOCK_METHOD(bool, IsBtPowerControlledByLpp, (), (const, override));
+
+  MOCK_METHOD(const std::vector<std::string>&,
+              GetHwStagesWithoutLppControlBtPowerPin, (), (const, override));
+
+  MOCK_METHOD(const std::vector<std::string>&, GetFwUnsupportedHwStages, (),
+              (const, override));
+
+  MOCK_METHOD(int, GetVendorTransportCrashIntervalSec, (), (const, override));
+
+  MOCK_METHOD(bool, IsHpUartSkipSuspendSupported, (), (const, override));
+
+  MOCK_METHOD(bool, IsEnergyControllerLoggingSupported, (), (const, override));
+
+  MOCK_METHOD(bool, IsBtHalRestartRecoverySupported, (), (const, override));
+
+  MOCK_METHOD(bool, IsBleNonConnectionSarEnabled, (), (const, override));
+
+  MOCK_METHOD(int, GetKernelRxWakelockTimeMilliseconds, (), (const, override));
+
+  MOCK_METHOD(bool, IsLowPowerModeSupported, (), (const, override));
+
+  MOCK_METHOD(bool, IsTranportFallbackEnabled, (), (const, override));
+
+  MOCK_METHOD(bool, IsBtSnoopLogFullModeOn, (), (const, override));
+
+  MOCK_METHOD(::bluetooth_hal::uart::BaudRate, GetUartBaudRate,
+              (::bluetooth_hal::transport::TransportType type),
+              (const, override));
+
+  MOCK_METHOD(bool, IsUserDebugOrEngBuild, (), (const, override));
+
+  MOCK_METHOD(std::string, DumpConfigToString, (), (const, override));
+
+  MOCK_METHOD(const std::string&, GetLpmEnableProcNode, (), (const, override));
+
+  MOCK_METHOD(const std::string&, GetLpmWakingProcNode, (), (const, override));
+
+  MOCK_METHOD(const std::string&, GetLpmWakelockCtrlProcNode, (),
+              (const, override));
+
+  MOCK_METHOD(const std::string&, GetRfkillFolderPrefix, (), (const, override));
+
+  MOCK_METHOD(const std::string&, GetRfkillTypeBluetooth, (),
+              (const, override));
+
+  static void SetMockLoader(MockHalConfigLoader* loader);
+};
+
+HalConfigLoader& HalConfigLoader::GetLoader() {
+  return *mock_hal_config_loader;
+}
+
+void MockHalConfigLoader::SetMockLoader(MockHalConfigLoader* loader) {
+  mock_hal_config_loader = loader;
+}
+
+}  // namespace config
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hci_router.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hci_router.h
new file mode 100644
index 0000000000..c4c28f7a6b
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hci_router.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_router.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+// A mock implementation of the HciRouter class for testing purposes.
+class MockHciRouter : public HciRouter {
+ public:
+  static void SetMockRouter(MockHciRouter* mock_hci_router);
+
+  MOCK_METHOD(bool, Initialize,
+              (const std::shared_ptr<HciRouterCallback>& callback), (override));
+
+  MOCK_METHOD(void, Cleanup, (), (override));
+
+  MOCK_METHOD(bool, Send, (const HalPacket& packet), (override));
+
+  MOCK_METHOD(bool, SendCommand,
+              (const HalPacket& packet, const HalPacketCallback& callback),
+              (override));
+
+  MOCK_METHOD(bool, SendCommandNoAck, (const HalPacket& packet), (override));
+
+  MOCK_METHOD(::bluetooth_hal::HalState, GetHalState, (), (override));
+
+  MOCK_METHOD(void, UpdateHalState, (::bluetooth_hal::HalState state),
+              (override));
+
+  MOCK_METHOD(void, SendPacketToStack, (const HalPacket& packet), (override));
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hci_router_client_agent.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hci_router_client_agent.h
new file mode 100644
index 0000000000..84ca43dcf6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_hci_router_client_agent.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/hci_monitor.h"
+#include "bluetooth_hal/hci_router_callback.h"
+#include "bluetooth_hal/hci_router_client_agent.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+// A mock implementation of the HciRouterClientAgent class for testing purposes.
+class MockHciRouterClientAgent : public HciRouterClientAgent {
+ public:
+  static void SetMockAgent(MockHciRouterClientAgent* mock_agent);
+
+  MOCK_METHOD(bool, RegisterRouterClient, (HciRouterClientCallback * callback),
+              (override));
+  MOCK_METHOD(bool, UnregisterRouterClient,
+              (HciRouterClientCallback * callback), (override));
+  MOCK_METHOD(MonitorMode, DispatchPacketToClients, (const HalPacket& packet),
+              (override));
+  MOCK_METHOD(void, NotifyHalStateChange,
+              (HalState new_state, HalState old_state), (override));
+  MOCK_METHOD(bool, IsBluetoothEnabled, (), (override));
+  MOCK_METHOD(bool, IsBluetoothChipReady, (), (override));
+};
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_socket_processor.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_socket_processor.h
new file mode 100644
index 0000000000..9e0d85c532
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_socket_processor.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/extensions/thread/socket_processor.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+// A mock implementation of the SocketProcessor class for testing purposes.
+// This class provides mock methods for all the virtual functions defined
+// in the SocketProcessor base class, allowing for precise control and
+// verification of socket operations during testing.
+class MockSocketProcessor : public SocketProcessor {
+ public:
+  // Mocks the static Initialize and Cleanup methods of SocketProcessor.
+  MOCK_METHOD(
+      void, Initialize,
+      (const std::string& socket_path,
+       std::optional<::bluetooth_hal::hci::HalPacketCallback> hal_packet_cb));
+  MOCK_METHOD(void, Cleanup, ());
+
+  // Mocks the virtual socket operation methods, allowing their behavior to be
+  // customized and verified in tests.
+  MOCK_METHOD(bool, Send, (const std::vector<uint8_t>& data), (override));
+
+  MOCK_METHOD(bool, Recv, (), (override));
+
+  MOCK_METHOD(bool, OpenServer, (), (override));
+
+  MOCK_METHOD(void, CloseServer, (), (override));
+
+  MOCK_METHOD(void, CloseClient, (), (override));
+
+  MOCK_METHOD(int, AcceptClient, (), (override));
+
+  MOCK_METHOD(void, SetServerSocket, (int socket), (override));
+
+  MOCK_METHOD(void, SetClientSocket, (int socket), (override));
+
+  MOCK_METHOD(void, SetSocketMode, (SocketMode mode), (override));
+
+  MOCK_METHOD(int, GetServerSocket, (), (const, override));
+
+  MOCK_METHOD(int, GetClientSocket, (), (const, override));
+
+  MOCK_METHOD(bool, IsSocketFileExisted, (), (const, override));
+
+  MOCK_METHOD(int, OpenSocketFileMonitor, (), (override));
+
+  MOCK_METHOD(void, CloseSocketFileMonitor, (), (override));
+
+  MOCK_METHOD(int, GetSocketFileMonitor, (), (override));
+
+  // Static function to set the mock processor for testing.
+  static void SetMockProcessor(MockSocketProcessor* processor);
+};
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/automotive/audiocontrol/2.0/types.hal b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_subscriber.h
similarity index 56%
rename from automotive/audiocontrol/2.0/types.hal
rename to bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_subscriber.h
index 80d9ee1867..d31cab2ce3 100644
--- a/automotive/audiocontrol/2.0/types.hal
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_subscriber.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 The Android Open Source Project
+ * Copyright 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,20 @@
  * limitations under the License.
  */
 
-package android.hardware.automotive.audiocontrol@2.0;
+#pragma once
 
-/**
- * Changes in audio focus that can be experienced
- */
-enum AudioFocusChange : int32_t {
-    NONE = 0,
-    GAIN = 1,
-    GAIN_TRANSIENT = 2,
-    GAIN_TRANSIENT_MAY_DUCK = 3,
-    GAIN_TRANSIENT_EXCLUSIVE = 4,
-    LOSS = -1 * GAIN,
-    LOSS_TRANSIENT = -1 * GAIN_TRANSIENT,
-    LOSS_TRANSIENT_CAN_DUCK = -1 * GAIN_TRANSIENT_MAY_DUCK,
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/subscriber.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+class MockSubscriber : public Subscriber {
+ public:
+  MOCK_METHOD(void, NotifyHalStateChange, (::bluetooth_hal::HalState haL_state),
+              (override));
 };
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_system_call_wrapper.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_system_call_wrapper.h
new file mode 100644
index 0000000000..e781e190db
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_system_call_wrapper.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include <cstddef>
+#include <cstdint>
+
+#include "bluetooth_hal/util/system_call_wrapper.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace util {
+
+class MockSystemCallWrapper;
+static MockSystemCallWrapper* mock_system_call_wrapper = nullptr;
+
+class MockSystemCallWrapper : public SystemCallWrapper {
+ public:
+  MOCK_METHOD(int, Select,
+              (int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds,
+               struct timeval* timeout),
+              (override));
+
+  MOCK_METHOD(ssize_t, Send,
+              (int fd, const void* buffer, size_t length, int flags),
+              (override));
+
+  MOCK_METHOD(ssize_t, Recv, (int fd, void* buffer, size_t length, int flags),
+              (override));
+
+  MOCK_METHOD(ssize_t, Write, (int fd, const void* buffer, size_t count),
+              (override));
+
+  MOCK_METHOD(ssize_t, Writev, (int fd, const struct iovec* iov, int iovcnt),
+              (override));
+
+  MOCK_METHOD(ssize_t, Read, (int fd, void* buffer, size_t count), (override));
+
+  MOCK_METHOD(int, Accept,
+              (int fd, struct sockaddr* address, socklen_t* address_len),
+              (override));
+
+  MOCK_METHOD(int, Open, (const char* pathname, int flags), (override));
+
+  MOCK_METHOD(void, Close, (int fd), (override));
+
+  MOCK_METHOD(void, Unlink, (const char* path), (override));
+
+  MOCK_METHOD(int, InotifyInit, (), (override));
+
+  MOCK_METHOD(int, InotifyAddWatch,
+              (int fd, const char* pathname, uint32_t mask), (override));
+
+  MOCK_METHOD(int, Socket, (int domain, int type, int protocol), (override));
+
+  MOCK_METHOD(int, Bind,
+              (int fd, const struct sockaddr* address, socklen_t address_len),
+              (override));
+
+  MOCK_METHOD(int, Listen, (int fd, int backlog), (override));
+
+  MOCK_METHOD(int, Stat, (const char* path, struct stat* sb), (override));
+
+  MOCK_METHOD(bool, IsSocketFile, (int st_mode), (override));
+
+  MOCK_METHOD(int, CreatePipe, (int pipefd[2], int flags), (override));
+
+  MOCK_METHOD(int, FdIsSet, (int fd, fd_set* set), (override));
+
+  MOCK_METHOD(void, FdSet, (int fd, fd_set* set), (override));
+
+  MOCK_METHOD(void, FdZero, (fd_set * set), (override));
+
+  MOCK_METHOD(int, Kill, (pid_t pid, int signal), (override));
+
+  static void SetMockWrapper(MockSystemCallWrapper* wrapper);
+};
+
+SystemCallWrapper& SystemCallWrapper::GetWrapper() {
+  return *mock_system_call_wrapper;
+}
+
+void MockSystemCallWrapper::SetMockWrapper(MockSystemCallWrapper* wrapper) {
+  mock_system_call_wrapper = wrapper;
+}
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_transport_interface.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_transport_interface.h
new file mode 100644
index 0000000000..881140a3cd
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_transport_interface.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/subscriber.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+class MockTransportInterface : public TransportInterface {
+ public:
+  MOCK_METHOD(bool, UpdateTransportType, (TransportType requested_type), ());
+
+  MOCK_METHOD(TransportType, GetTransportType, (), ());
+
+  MOCK_METHOD(bool, RegisterVendorTransport,
+              (std::unique_ptr<TransportInterface> transport), ());
+
+  MOCK_METHOD(bool, UnregisterVendorTransport, (TransportType type), ());
+
+  MOCK_METHOD(void, SetHciRouterBusy, (bool is_busy), ());
+
+  MOCK_METHOD(void, NotifyHalStateChange, (::bluetooth_hal::HalState hal_state),
+              ());
+
+  MOCK_METHOD(void, Subscribe, (Subscriber & subscriber), ());
+
+  MOCK_METHOD(void, Unsubscribe, (Subscriber & subscriber), ());
+
+  MOCK_METHOD(bool, Initialize,
+              (TransportInterfaceCallback * transport_interface_callback),
+              (override));
+
+  MOCK_METHOD(void, Cleanup, (), (override));
+
+  MOCK_METHOD(bool, IsTransportActive, (), (const, override));
+
+  MOCK_METHOD(bool, Send, (const ::bluetooth_hal::hci::HalPacket& packet),
+              (override));
+
+  MOCK_METHOD(TransportType, GetInstanceTransportType, (), (const, override));
+
+  static void SetMockTransport(MockTransportInterface* transport);
+};
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_vnd_snoop_logger.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_vnd_snoop_logger.h
new file mode 100644
index 0000000000..91cff0128a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_vnd_snoop_logger.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/debug/vnd_snoop_logger.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace debug {
+
+class MockVndSnoopLogger : public VndSnoopLogger {
+ public:
+  MOCK_METHOD(void, StartNewRecording, (), (override));
+  MOCK_METHOD(void, StopRecording, (), (override));
+  MOCK_METHOD(void, Capture,
+              (const ::bluetooth_hal::hci::HalPacket& packet,
+               Direction direction),
+              (override));
+
+  static void SetMockVndSnoopLogger(MockVndSnoopLogger* logger);
+};
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_wakelock.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_wakelock.h
new file mode 100644
index 0000000000..c9f9822612
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/test/mock/mock_wakelock.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/power/wakelock.h"
+#include "gmock/gmock.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class MockWakelock : public Wakelock {
+ public:
+  MOCK_METHOD(void, Acquire, (WakeSource source), (override));
+  MOCK_METHOD(void, Release, (WakeSource source), (override));
+  MOCK_METHOD(bool, IsAcquired, (), (override));
+  MOCK_METHOD(bool, IsWakeSourceAcquired, (WakeSource source), (override));
+
+  static void SetMockWakelock(MockWakelock* wakelock);
+};
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/device_control/power_manager.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/device_control/power_manager.h
new file mode 100644
index 0000000000..6ba82ed17d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/device_control/power_manager.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "android-base/unique_fd.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+/**
+ * @brief The PowerManager class manages Bluetooth device power states and low
+ * power mode (LPM).
+ *
+ * This class configures Bluetooth device activity related to power management.
+ * Entering LPM puts the Bluetooth device into sleep mode to conserve power,
+ * while exiting LPM wakes it up for normal operation.
+ *
+ * Additionally, it controls the power supply to the Bluetooth chip, enabling or
+ * disabling the chip's power as needed.
+ */
+class PowerManager {
+ public:
+  virtual ~PowerManager() = default;
+
+  /**
+   * @brief Controls the Bluetooth chip's power state.
+   *
+   * Enables or disables power to the Bluetooth chip by writing to the rfkill
+   * interface. This effectively powers the device on or off.
+   *
+   * @param is_enabled Set to true to power on the Bluetooth chip, false to
+   * power it off.
+   *
+   * @return True if the operation succeeds, false otherwise.
+   *
+   */
+  virtual bool PowerControl(bool is_enabled);
+
+  /**
+   * @brief Prepares the system to enter Low Power Mode (LPM).
+   *
+   * Configures the necessary environment so the Bluetooth device can enter LPM,
+   * where it will enter a sleep state to save power.
+   *
+   * @return True if setup is successful, false otherwise.
+   *
+   */
+  virtual bool SetupLowPowerMode();
+
+  /**
+   * @brief Cleans up after exiting Low Power Mode (LPM).
+   *
+   * Releases resources or resets configurations used during LPM.
+   *
+   */
+  virtual void TeardownLowPowerMode();
+
+  /**
+   * @brief Wakes the Bluetooth device from Low Power Mode to active mode.
+   *
+   * Transitions the device from sleep back to full operation.
+   *
+   * @return True if resume succeeds, false otherwise.
+   *
+   */
+  virtual bool ResumeFromLowPowerMode();
+
+  /**
+   * @brief Puts the Bluetooth device into Low Power Mode (LPM).
+   *
+   * Transitions the device to a low power sleep state.
+   *
+   * @return True if suspend succeeds, false otherwise.
+   *
+   */
+  virtual bool SuspendToLowPowerMode();
+
+  /**
+   * @brief Checks if Low Power Mode setup has been completed.
+   *
+   * Determines if the device is properly configured to enter or exit LPM.
+   *
+   * @return True if LPM setup is complete, false otherwise.
+   *
+   */
+  virtual bool IsLowPowerModeSetupCompleted() const;
+
+  /**
+   * @brief Sets the RX wakelock duration in the kernel.
+   *
+   * Configures how long the RX wakelock holds the device awake after receiving
+   * data.
+   *
+   * @param duration Duration in milliseconds; must be positive.
+   *
+   * @return True if the duration is successfully configured, false otherwise.
+   *
+   */
+  virtual bool ConfigRxWakelockTime(int duration);
+
+ protected:
+  ::android::base::unique_fd lpm_fd_{-1};
+};
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/device_control/uart_manager.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/device_control/uart_manager.h
new file mode 100644
index 0000000000..256463e67b
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/device_control/uart_manager.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "android-base/unique_fd.h"
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+/**
+ * @brief The UartManager provides a default implementation that users, such as
+ * transport instances, can inherit. They can then use this default
+ * implementation or override it with their own proprietary implementation.
+ *
+ */
+class UartManager {
+ public:
+  virtual ~UartManager() = default;
+
+  /**
+   * @brief Opens the UART port.
+   *
+   * This function opens the UART port for communication.
+   *
+   * @return True if the port was opened successfully, false otherwise.
+   *
+   */
+  virtual bool Open();
+
+  /**
+   * @brief Closes the UART port.
+   *
+   * This function closes the UART port.
+   *
+   */
+  virtual void Close();
+
+  /**
+   * @brief Controls whether the UART should skip suspend.
+   *
+   * This function configures the UART to either skip or enter suspend mode.
+   *
+   * @param skip_suspend True to skip suspend, false to enter suspend.
+   *
+   * @return True if the operation was successful, false otherwise.
+   *
+   */
+  virtual bool SetUartSkipSuspend(bool skip_suspend);
+
+  /**
+   * @brief Change the baud rate of the UART port.
+   *
+   *
+   * @param rate The new baud rate for the UART port.
+   *
+   * @return True if the baud rate was successfully changed, false otherwise.
+   *
+   */
+  virtual void UpdateBaudRate(::bluetooth_hal::uart::BaudRate rate) const;
+
+  /**
+   * @brief Gets the file descriptor associated with the UART port.
+   *
+   * This function returns the file descriptor that can be used for
+   * low-level I/O operations on the UART port.
+   *
+   * @return The file descriptor.
+   *
+   */
+  virtual int GetFd();
+
+ protected:
+  ::android::base::unique_fd uart_fd_{-1};
+};
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/subscriber.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/subscriber.h
new file mode 100644
index 0000000000..0ae8fa4fbc
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/subscriber.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+class Subscriber {
+ public:
+  virtual ~Subscriber() = default;
+
+  bool operator==(const Subscriber& other) const { return this == &other; }
+
+  /**
+   * @brief Notifies the subscriber about a change in the HAL state.
+   *
+   * This function provides a mechanism for the subscriber to receive
+   * notifications about changes in the Bluetooth HAL state.
+   *
+   * @param hal_state The new state of the Bluetooth HAL.
+   *
+   */
+  virtual void NotifyHalStateChange(::bluetooth_hal::HalState hal_state) = 0;
+};
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/transport_interface.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/transport_interface.h
new file mode 100644
index 0000000000..fd15673c1d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/transport_interface.h
@@ -0,0 +1,256 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/subscriber.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+/**
+ * @brief Interface for handling transport-related events.
+ *
+ * This interface defines callbacks for handling transport events such as
+ * connection closure and packet readiness. Implementations of this interface
+ * should provide concrete behaviors for these events.
+ */
+class TransportInterfaceCallback {
+ public:
+  virtual ~TransportInterfaceCallback() = default;
+
+  /**
+   * @brief Called when the transport connection is closed.
+   *
+   * Implementations should handle any necessary cleanup or state updates when
+   * the transport is closed.
+   *
+   */
+  virtual void OnTransportClosed() = 0;
+
+  /**
+   * @brief Called when a packet is ready to be processed.
+   *
+   * @param packet The received packet that needs to be processed.
+   *
+   * Implementations should process the given packet accordingly. This method
+   * does not return a callback, meaning the implementation is expected to
+   * handle the packet directly within this function.
+   *
+   */
+  virtual void OnTransportPacketReady(
+      const ::bluetooth_hal::hci::HalPacket& packet) = 0;
+};
+
+/**
+ * @brief Abstracts the transport layer for devices, providing interfaces for
+ * control and data management.
+ *
+ * This class also manages subscriber lists to send messages or signals,
+ * notifying the underlying transport instances for further operations.
+ *
+ */
+class TransportInterface {
+ public:
+  virtual ~TransportInterface() = default;
+
+  /**
+   * @brief Initializes the transport interface with a transport callback.
+   *
+   * @param transport_interface_callback A pointer to a
+   * `TransportInterfaceCallback` responsible for handling transport layer
+   * events such as packet reception, connection closure, etc.
+   *
+   * @return True if initialization succeeds, false otherwise.
+   *
+   */
+  virtual bool Initialize(
+      TransportInterfaceCallback* transport_interface_callback) = 0;
+
+  /**
+   * @brief Cleans up resources and disconnects the transport interface.
+   *
+   */
+  virtual void Cleanup() = 0;
+
+  /**
+   * @brief Checks if the current transport is active and operational.
+   *
+   * @return `true` if the transport is active and communication is operational,
+   * `false` otherwise.
+   *
+   */
+  virtual bool IsTransportActive() const = 0;
+
+  /**
+   * @brief Sends a single packet with the specified type.
+   *
+   * @param packet The content of the packet to be transmitted.
+   *
+   * @return `true` if packet is sent successfully, `false` otherwise.
+   *
+   */
+  virtual bool Send(const ::bluetooth_hal::hci::HalPacket& packet) = 0;
+
+  /**
+   * @brief Retrieves the specific transport type of this instance.
+   *
+   * @return The TransportType of this concrete transport instance.
+   *
+   */
+  virtual TransportType GetInstanceTransportType() const = 0;
+
+  static TransportInterface& GetTransport();
+
+  /**
+   * Updates the current transport type for the TransportInterface.
+   *
+   * This method allows switching the transport type used by the
+   * TransportInterface. If the provided type differs from the currently set
+   * type, the internal transport type will be updated, and subsequent calls to
+   * GetTransport() will return the transport instance corresponding to the
+   * updated type.
+   *
+   * @param requested_type The new TransportType to set.
+   *
+   * @return `true` if the transport was successfully updated, `false`
+   * otherwise.
+   *
+   */
+  static bool UpdateTransportType(TransportType requested_type);
+
+  /**
+   * Retrieves the current transport type for the TransportInterface.
+   *
+   * This method returns the transport type that is currently configured. The
+   * transport type determines the transport instance that will be used when
+   * GetTransport() is called.
+   *
+   * @return The current TransportType.
+   *
+   */
+  static TransportType GetTransportType();
+
+  /**
+   * @brief Registers a vendor-specific transport implementation.
+   *
+   * This static method allows for the registration of a custom transport
+   * mechanism provided by a vendor. Once registered,
+   * this transport can potentially be selected and used by the Bluetooth HAL.
+   *
+   * @param transport A unique pointer to an aobject that implements the
+   * TransportInterface. The ownership of this object is
+   * transferred to this class. The provided transport should
+   * not be null.
+   *
+   * @return `true` if the vendor transport was successfully registered,
+   * `false` otherwise.
+   *
+   */
+  static bool RegisterVendorTransport(
+      std::unique_ptr<TransportInterface> transport);
+
+  /**
+   * @brief Unregisters a vendor-specific transport implementation.
+   *
+   * This static method allows for the removal of a previously registered
+   * custom transport mechanism.
+   *
+   * @param type The TransportType of the vendor transport to unregister.
+   *
+   * @return `true` if the vendor transport was successfully unregistered,
+   * `false` otherwise (e.g., if the transport type was not found,
+   * is not a vendor type, or is currently active).
+   *
+   */
+  static bool UnregisterVendorTransport(TransportType type);
+
+  /**
+   * @brief Updates the busy state of the hci router.
+   *
+   * This function sets the internal state to indicate whether the hci router is
+   * currently busy. This should be called by hci router.
+   *
+   * @param is_busy A boolean indicating the new busy state of the hci router.
+   * Pass true if the hci router is busy, or false otherwise.
+   *
+   */
+  static void SetHciRouterBusy(bool is_busy);
+
+  /**
+   * @brief Notifies the transport layer of a change in the HAL state.
+   *
+   * This function should be called whenever the HAL transitions to a new state.
+   * This should be called by hci router.
+   *
+   * @param hal_state The new state of the HAL.
+   *
+   */
+  static void NotifyHalStateChange(::bluetooth_hal::HalState hal_state);
+
+  /**
+   * @brief Subscribes a new subscriber to receive notifications.
+   *
+   * This function adds the given subscriber to the list of subscribers.
+   * Once subscribed, the subscriber will receive notifications when events
+   * occur.
+   *
+   * @param subscriber The subscriber to be added. It should be passed by
+   * constant reference.
+   *
+   */
+  static void Subscribe(Subscriber& subscriber);
+
+  /**
+   * @brief Unsubscribes an existing subscriber.
+   *
+   * This function removes the given subscriber from the list of subscribers.
+   * Once unsubscribed, the subscriber will no longer receive notifications.
+   *
+   * @param subscriber The subscriber to be removed. It should be passed by
+   * constant reference.
+   *
+   */
+  static void Unsubscribe(Subscriber& subscriber);
+
+ protected:
+  static std::atomic<bool> is_hci_router_busy_;
+  static std::atomic<::bluetooth_hal::HalState> hal_state_;
+  static std::vector<std::reference_wrapper<Subscriber>> subscribers_;
+
+ private:
+  static std::pair<std::unique_ptr<TransportInterface>, TransportType>
+  CreateOrAcquireTransport(TransportType requested_type);
+
+  static TransportType current_transport_type_;
+  static std::recursive_mutex transport_mutex_;
+  static std::unique_ptr<TransportInterface> current_transport_;
+  static std::unordered_map<TransportType, std::unique_ptr<TransportInterface>>
+      vendor_transports_;
+};
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/data_processor.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/data_processor.h
new file mode 100644
index 0000000000..1003d7dbdb
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/data_processor.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <span>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/transport/uart_h4/hci_packetizer.h"
+#include "bluetooth_hal/util/fd_watcher.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+class DataProcessor {
+ public:
+  DataProcessor(int fd, ::bluetooth_hal::hci::HalPacketCallback on_packet_ready)
+      : fd_(fd), hci_packetizer_(std::move(on_packet_ready)) {}
+
+  ~DataProcessor();
+
+  /**
+   * @brief Starts the data processing pipeline.
+   *
+   * This method initiates the listening thread of the FileDescriptor, starting
+   * the data monitoring process.
+   *
+   */
+  void StartProcessing();
+
+  /**
+   * @brief Sends a packet over a specified file descriptor.
+   *
+   * @param packet The packet to send.
+   
+   * @return The total number of bytes written.
+   *
+   */
+  size_t Send(std::span<const uint8_t> packet);
+
+  /**
+   * @brief Receives data from a file descriptor.
+   *
+   * This function reads data from a file descriptor, processes it into an HCI
+   * packet, and then invokes a callback to pass the packets to the upper layer.
+   *
+   * @param fd The file descriptor to receive data from.
+   *
+   */
+  void Recv(int fd);
+
+ private:
+  void ParseHciPacket(std::span<const uint8_t> buffer);
+
+  int fd_;
+
+  HciPacketizer hci_packetizer_;
+  ::bluetooth_hal::util::FdWatcher fd_watcher_;
+};
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/hci_packetizer.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/hci_packetizer.h
new file mode 100644
index 0000000000..da9dc7a956
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/hci_packetizer.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <span>
+
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+class HciPacketizer {
+ public:
+  explicit HciPacketizer(
+      ::bluetooth_hal::hci::HalPacketCallback on_packet_ready)
+      : on_packet_ready_(std::move(on_packet_ready)) {}
+
+  /**
+   * @brief Processes incoming data to construct an HCI packet.
+   *
+   * This function reads data from the input `data` span, appends it to the
+   * internal packet buffer, and attempts to assemble a complete HCI packet.
+   * If a complete packet is formed, the `packet_ready_callback_` (if set)
+   * is invoked with the complete packet. The function continues to process
+   * the input data until it's exhausted, potentially forming multiple
+   * packets.
+   *
+   * @param data A const span referencing the incoming data buffer. The data
+   * within this span is treated as read-only and is not modified.
+   *
+   * @return The number of bytes consumed from the `data` span. This might be
+   * less than `data.size()` if the function constructs a complete packet before
+   * the end of the input data, subsequent calls with the remaining data in
+   * `data` should be made to process it fully. Returns 0 if the packetizer
+   * cannot format packets based on the bluetooth spec.
+   *
+   */
+  size_t ProcessData(std::span<const uint8_t> data);
+
+ private:
+  enum class State : uint8_t {
+    kHciHeader,
+    kHciPreamble,
+    kHciPayload,
+  };
+
+  State state_{State::kHciHeader};
+
+  ::bluetooth_hal::hci::HalPacket packet_;
+
+  size_t payload_length_{0};
+  size_t total_bytes_read_{0};
+
+  ::bluetooth_hal::hci::HalPacketCallback on_packet_ready_;
+};
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/transport_uart_h4.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/transport_uart_h4.h
new file mode 100644
index 0000000000..ed48f6feac
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/transport/uart_h4/transport_uart_h4.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include <memory>
+#include <mutex>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/device_control/power_manager.h"
+#include "bluetooth_hal/transport/device_control/uart_manager.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "bluetooth_hal/transport/uart_h4/data_processor.h"
+#include "bluetooth_hal/util/timer_manager.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+class TransportUartH4 : virtual public TransportInterface,
+                        virtual public PowerManager,
+                        virtual public UartManager,
+                        virtual public Subscriber {
+ public:
+  TransportUartH4() = default;
+  TransportUartH4(const TransportUartH4&) = delete;
+  TransportUartH4& operator=(const TransportUartH4&) = delete;
+  ~TransportUartH4() override;
+
+  /**
+   * @brief Returns the transport type matching the UART H4 transport.
+   *
+   * @return The transport type corresponding to kUartH4.
+   */
+  TransportType GetInstanceTransportType() const override;
+
+  /**
+   * @brief Initializes the transport interface with a transport callback.
+   *
+   * Sets up the transport interface including initialization of the
+   * underlying device for operation.
+   *
+   * @param transport_interface_callback A pointer to a
+   * `TransportInterfaceCallback` responsible for handling transport layer
+   * events such as packet reception, connection closure, etc.
+   *
+   * @return True if initialization succeeds, false otherwise.
+   *
+   */
+  bool Initialize(
+      TransportInterfaceCallback* transport_interface_callback) override;
+
+  /**
+   * @brief Cleans up resources and disconnects the transport interface.
+   *
+   * Ensures that all allocated resources including the underlying device
+   * are released and any active connections are safely terminated.
+   *
+   */
+  void Cleanup() override;
+
+  /**
+   * @brief Checks if the current transport is active and operational.
+   *
+   * This method verifies if the underlying device is powered on and the
+   * communication link to the device is established and functional.
+   *
+   * @return `true` if the transport is active and communication is operational,
+   * false` otherwise.
+   *
+   */
+  bool IsTransportActive() const override;
+
+  /**
+   * @brief Sends a single data packet with the specified type.
+   *
+   * This function transmits a single data packet, specifying its type and
+   * content, and optionally requires an acknowledgment for the sent packet.
+   *
+   * @param packet The content of the data packet to be transmitted.
+   *
+   * @return `true` if data is sent successfully, `false` otherwise.
+   *
+   */
+  bool Send(const ::bluetooth_hal::hci::HalPacket& packet) override;
+
+  /**
+   * @brief Resumes the underlying device from Low Power Mode (LPM) to an
+   * active state.
+   *
+   * This method should be called to bring the underlying device back to
+   * full operation after being in LPM.
+   *
+   * @return True if the resume operation is successful, false otherwise.
+   *
+   */
+  bool ResumeFromLowPowerMode() override;
+
+  /**
+   * @brief Suspends the underlying device into Low Power Mode (LPM).
+   *
+   * This method should be called to transition underlying device to a low
+   * power state.
+   *
+   * @return True if the suspend operation is successful, false otherwise.
+   *
+   */
+  bool SuspendToLowPowerMode() override;
+
+  /**
+   * @brief Checks if the Low Power Mode (LPM) setup has been completed.
+   *
+   * This method checks whether the necessary setup for Low Power Mode (LPM)
+   * has been successfully completed. It helps to determine if the system or
+   * device is ready to enter or interact with LPM.
+   *
+   * @return True if the LPM setup is completed and the system is ready,
+   * false otherwise.
+   *
+   */
+  bool IsLowPowerModeSetupCompleted() const override;
+
+  /**
+   * @brief Adjusts the UART baud rate based on the current HAL state.
+   *
+   * This method is invoked to notify a change in the HAL (Hardware Abstraction
+   * Layer) state. Depending on the specified `hal_state`, it updates the UART
+   * baud rate to match the requirements of the firmware state.
+   *
+   * @param hal_state The current HAL state, which determines the desired baud
+   * rate.
+   *
+   */
+  void NotifyHalStateChange(::bluetooth_hal::HalState hal_state) override;
+
+ protected:
+  void EnableTransportWakelock(bool enable);
+  bool IsTransportWakelockEnabled();
+
+  TransportInterfaceCallback* transport_interface_callback_;
+
+ private:
+  bool InitializeDataPath();
+  void TerminateDataPath();
+
+  bool SetupLowPowerMode() override;
+  void TeardownLowPowerMode() override;
+
+  std::unique_ptr<DataProcessor> data_processor_;
+  std::recursive_mutex mutex_;
+  ::bluetooth_hal::util::Timer low_power_timer_;
+  bool is_lpm_resumed_ = false;
+  static constexpr int kLpmTimeoutMs = 500;
+  bool transport_wakelock_enabled_ = true;
+};
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/android_base_wrapper.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/android_base_wrapper.h
new file mode 100644
index 0000000000..e04f51fe7c
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/android_base_wrapper.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+
+namespace bluetooth_hal {
+namespace util {
+
+class AndroidBaseWrapper {
+ public:
+  virtual ~AndroidBaseWrapper() = default;
+
+  static AndroidBaseWrapper& GetWrapper();
+
+  /**
+   * @brief Retrieves a system property as a string.
+   *
+   * Given a property key, this function returns the corresponding value as a
+   * string. If the property is not set, it returns the specified default value.
+   *
+   * @param key The property key to look up.
+   * @param default_value The value to return if the property is not set.
+   *
+   * @return The property value as a string, or the default value if the
+   * property is unset.
+   *
+   */
+  virtual std::string GetProperty(const std::string& key,
+                                  const std::string& default_value) = 0;
+
+  /**
+   * @brief Retrieves a system property as a boolean.
+   *
+   * Given a property key, this function returns the corresponding value as a
+   * boolean. If the property is not set, it returns the specified default
+   * boolean value.
+   *
+   * @param key The property key to look up.
+   * @param default_value The boolean value to return if the property is not
+   * set.
+   *
+   * @return The property value as a boolean, or the default value if the
+   * property is unset.
+   *
+   */
+  virtual bool GetBoolProperty(const std::string& key, bool default_value) = 0;
+
+  /**
+   * @brief Sets a system property to the specified string value.
+   *
+   * This function attempts to set the value of the system property identified
+   * by the given key to the specified value. If the property cannot be set, it
+   * returns `false`.
+   *
+   * @param key The property key to set.
+   * @param value The value to set for the specified property key.
+   *
+   * @return `true` if the property was successfully set; otherwise, `false`.
+   *
+   */
+  virtual bool SetProperty(const std::string& key,
+                           const std::string& value) = 0;
+
+  /**
+   * @brief Parses an unsigned integer from a string.
+   *
+   * This function parses an unsigned integer from the given string.
+   * The parsed value is stored in the `out` parameter.
+   *
+   * @param s The string to parse.
+   * @param out A pointer to the variable where the parsed value will be stored.
+   * @param max The maximum allowed value for the parsed integer.
+   *
+   * @return `true` if the parsing was successful, `false` otherwise.
+   *
+   */
+  virtual bool ParseUint(const std::string& s, uint8_t* out, uint8_t max) = 0;
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/fd_watcher.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/fd_watcher.h
new file mode 100644
index 0000000000..36bb484b0e
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/fd_watcher.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <functional>
+
+namespace bluetooth_hal {
+namespace util {
+
+class FdWatcherImpl;
+
+class FdWatcher {
+ public:
+  FdWatcher();
+
+  FdWatcher(const FdWatcher&) = delete;
+  FdWatcher& operator=(const FdWatcher&) = delete;
+
+  ~FdWatcher();
+
+  /**
+   * @brief Starts watching a file descriptor.
+   *
+   * This function adds the specified file descriptor to the list of monitored
+   * file descriptors. When the file descriptor becomes ready for reading, the
+   * provided callback function is invoked.
+   *
+   * @note This is not a blocking call. The callback will be invoked
+   * asynchronously.
+   *
+   * @param fd The file descriptor to watch.
+   * @param on_read_fd_ready_callback The callback function to be invoked when
+   * the file descriptor is ready for reading.
+   *
+   * @return 0 on success, -1 on error.
+   *
+   */
+  int StartWatching(int fd,
+                    const std::function<void(int)>& on_read_fd_ready_callback);
+
+  /**
+   * @brief Stops watching all file descriptors and terminates the internal
+   * thread.
+   *
+   * This function should be called when the FdWatcher object is no longer
+   * needed.
+   *
+   */
+  void StopWatching();
+
+ private:
+  std::unique_ptr<FdWatcherImpl> impl_;
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/files.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/files.h
new file mode 100644
index 0000000000..f38d00ffd1
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/files.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <optional>
+
+namespace bluetooth_hal {
+namespace os {
+
+// Get FS Debug Dump
+bool GetFsDebugDump(int fd, const std::string& debugfs);
+
+// Get Battery Percentage
+bool GetBatteryPercentage(std::string& batt_level);
+
+// Return true if |path| exists on disk
+bool FileExists(const std::string& path);
+
+// Rename file from |from| to |to|
+bool RenameFile(const std::string& from, const std::string& to);
+
+// Implement ability to read a whole file from |path| into a C++ string, return
+// std::nullopt on failure
+//
+// Do not use this with large files
+std::optional<std::string> ReadSmallFile(const std::string& path);
+
+// Implement ability to safely write to a file. This function is needed because
+// of deficiencies in existing C++ file libraries, namely:
+// - The ability to open and sync directories with storage media
+// - The ability to block and sync file to storage media
+// Return true on success, false on failure
+bool WriteToFile(const std::string& path, const std::string& data);
+
+// Remove file and print error message if failed
+// Print error log when file is failed to be removed, hence user should make
+// sure file exists before calling this Return true on success, false on failure
+// (e.g. file not exist, failed to remove, etc)
+bool RemoveFile(const std::string& path);
+
+// Returns created time_point of given file, return std::nullopt on failure
+std::optional<std::chrono::time_point<std::chrono::system_clock,
+                                      std::chrono::nanoseconds>>
+FileCreatedTime(const std::string& path);
+
+std::string GetLastLogPath(std::string log_file_path);
+
+void CreateLogFile(const std::string& log_file_path,
+                   std::ofstream& log_file_stream);
+
+void CloseLogFileStream(std::ofstream& log_file_stream);
+
+// Delete the oldest files in `directory` that match `file_prefix` until only
+// `files_to_keep` files remain.
+void DeleteOldestFiles(std::string_view directory,
+                       std::optional<std::string_view> file_prefix,
+                       size_t files_to_keep);
+
+}  // namespace os
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/logging.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/logging.h
new file mode 100644
index 0000000000..70c4cef512
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/logging.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+
+namespace bluetooth_hal {
+namespace util {
+
+class Logger {
+ public:
+  /**
+   * @brief Generates a timestamp string suitable for log messages.
+   *
+   * The timestamp is formatted as HH:MM:SS:sss (hours, minutes, seconds,
+   * milliseconds). It represents the current local time with millisecond
+   * precision.
+   *
+   * @return A string representing the current local time in the format
+   * HH:MM:SS:sss.
+   *
+   */
+  static std::string GetLogFormatTimestamp();
+
+  /**
+   * @brief Generates a timestamp string suitable for record creation.
+   *
+   * The timestamp is formatted as YYYY-MM-DD_HH-MM-SS (year, month, day, hours,
+   * minutes, seconds). It represents the current local time.
+   *
+   * @return A string representing the current local time in the format
+   * YYYY-MM-DD_HH-MM-SS.
+   *
+   */
+  static std::string GetFileFormatTimestamp();
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/power_interface.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/power_interface.h
new file mode 100644
index 0000000000..4ac9ebc825
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/power_interface.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class PowerInterface {
+ public:
+  virtual ~PowerInterface() = default;
+
+  /**
+   * @brief Acquire a partial system wakelock from hardware_legacy.
+   *
+   * @return true if the wakelock is acquired, otherwise false.
+   *
+   */
+  virtual bool AcquireWakelock();
+
+  /**
+   * @brief Release the system wakelock acquired from hardware_legacy.
+   *
+   * @return true if the wakelock is acquired, otherwise false.
+   *
+   */
+  virtual bool ReleaseWakelock();
+
+  static PowerInterface& GetInterface();
+};
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock.h
new file mode 100644
index 0000000000..eda0e0752a
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class Wakelock {
+ public:
+  /**
+   * @brief Vote for acquiring wakelock from the system.
+   *
+   * @param source The source of the requester.
+   *
+   */
+  virtual void Acquire(WakeSource source) = 0;
+
+  /**
+   * @brief Un-vote for wakelock from the system.
+   *
+   * @param source The source of the requester.
+   *
+   */
+  virtual void Release(WakeSource source) = 0;
+
+  /**
+   * @brief Check if the wakelock is acquired.
+   *
+   * @return true if the wakelock is acquired, otherwise false.
+   *
+   */
+  virtual bool IsAcquired() = 0;
+
+  /**
+   * @brief Check if the wakelock is voted by a certain requester.
+   *
+   * @param source The source of the requester.
+   * @return true if the wakelock is acquired by the requester, otherwise
+   * false.
+   *
+   */
+  virtual bool IsWakeSourceAcquired(WakeSource source) = 0;
+
+  static Wakelock& GetWakelock();
+
+ protected:
+  virtual ~Wakelock() = default;
+};
+
+class ScopedWakelock {
+ public:
+  ScopedWakelock(WakeSource source) : source_(source) {
+    Wakelock::GetWakelock().Acquire(source_);
+  }
+
+  ~ScopedWakelock() { Wakelock::GetWakelock().Release(source_); }
+
+ private:
+  WakeSource source_;
+};
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock_util.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock_util.h
new file mode 100644
index 0000000000..d9ac0b7e12
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock_util.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class WakelockUtil {
+ public:
+  static std::string WakeSourceToString(WakeSource source) {
+    switch (source) {
+      case WakeSource::kTx:
+        return "TX";
+      case WakeSource::kRx:
+        return "RX";
+      case WakeSource::kHciBusy:
+        return "HciBusy";
+      case WakeSource::kTransport:
+        return "Transport";
+      case WakeSource::kInitialize:
+        return "Initialize";
+      case WakeSource::kClose:
+        return "Close";
+    }
+    return "Unknown";
+  }
+};
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock_watchdog.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock_watchdog.h
new file mode 100644
index 0000000000..fca7b6d527
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/power/wakelock_watchdog.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class WakelockWatchdog {
+ public:
+  /**
+   * @brief Start a watchdog timer for the WakeSource.
+   *
+   * @param source The source of the requester.
+   *
+   */
+  virtual void Start(WakeSource source) = 0;
+
+  /**
+   * @brief Stop the watchdog timer for a WakeSource.
+   *
+   * @param source The source of the requester.
+   *
+   */
+  virtual void Stop(WakeSource source) = 0;
+
+  static WakelockWatchdog& GetWatchdog();
+
+ protected:
+  virtual ~WakelockWatchdog() = default;
+};
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/system_call_wrapper.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/system_call_wrapper.h
new file mode 100644
index 0000000000..7e7f5e5673
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/system_call_wrapper.h
@@ -0,0 +1,343 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <cstddef>
+#include <cstdint>
+
+namespace bluetooth_hal {
+namespace util {
+
+/**
+ * @class SystemCallWrapper
+ * @brief A wrapper class providing an interface to system calls.
+ *
+ * This class abstracts the underlying system calls, allowing for
+ * potential mocking or customization in testing or different environments.
+ */
+class SystemCallWrapper {
+ public:
+  /**
+   * @brief Virtual destructor.
+   *
+   * Allows derived classes to clean up resources properly.
+   *
+   */
+  virtual ~SystemCallWrapper() = default;
+
+  /**
+   * @brief Gets a reference to the singleton instance of this class.
+   *
+   * @return A reference to the singleton SystemCallWrapper instance.
+   *
+   */
+  static SystemCallWrapper& GetWrapper();
+
+  /**
+   * @brief Monitors multiple file descriptors for readiness.
+   *
+   * @param nfds The highest-numbered file descriptor in any of the three sets,
+   * plus 1.
+   * @param readfds A pointer to an fd_set structure, or NULL. On return,
+   * readfds contains the file descriptors that are ready for reading.
+   * @param writefds A pointer to an fd_set structure, or NULL. On return,
+   * writefds contains the file descriptors that are ready for writing.
+   * @param errorfds A pointer to an fd_set structure, or NULL. On return,
+   * errorfds contains the file descriptors that have an error condition.
+   * @param timeout A pointer to a timeval structure, or NULL. If timeout is
+   * NULL, select() blocks indefinitely.
+   *
+   * @return On success, select() returns the number of file descriptors
+   * contained in the three returned descriptor sets. On error, -1 is returned,
+   * and errno is set to indicate the error.
+   *
+   */
+  virtual int Select(int nfds, fd_set* readfds, fd_set* writefds,
+                     fd_set* errorfds, struct timeval* timeout) = 0;
+
+  /**
+   * @brief Sends data over a connected socket.
+   *
+   * @param fd The socket file descriptor.
+   * @param buffer A pointer to the buffer containing the data to send.
+   * @param length The number of bytes to send.
+   * @param flags Specifies the type of message transmission.
+   *
+   * @return On success, the number of bytes sent is returned. On error, -1 is
+   * returned, and errno is set appropriately.
+   *
+   */
+  virtual ssize_t Send(int fd, const void* buffer, size_t length,
+                       int flags) = 0;
+
+  /**
+   * @brief Receives data from a connected socket.
+   *
+   * @param fd The socket file descriptor.
+   * @param buffer A pointer to the buffer to store the received data.
+   * @param length The maximum number of bytes to receive.
+   * @param flags Specifies the type of message reception.
+   *
+   * @return On success, the number of bytes received is returned. On error, -1
+   * is returned, and errno is set appropriately.
+   *
+   */
+  virtual ssize_t Recv(int fd, void* buffer, size_t length, int flags) = 0;
+
+  /**
+   * @brief Writes data to a file descriptor.
+   *
+   * @param fd The file descriptor to write to.
+   * @param buffer A pointer to the buffer containing the data to write.
+   * @param count The number of bytes to write.
+   *
+   * @return On success, the number of bytes written is returned. On error, -1
+   * is returned, and errno is set appropriately.
+   *
+   */
+  virtual ssize_t Write(int fd, const void* buffer, size_t count) = 0;
+
+  /**
+   * @brief Writes data to a file descriptor with multiple buffers.
+   *
+   * The `writev` system call writes data from multiple buffers to a file
+   * descriptor. The buffers are specified by an array of `iovec` structures.
+   *
+   * @param fd The file descriptor to write to.
+   * @param iov A pointer to an array of `iovec` structures. Each `iovec`
+   *            structure specifies a buffer to write data from.
+   * @param iovcnt The number of elements in the `iov` array.
+   *
+   * @return On success, returns the total number of bytes written. This should
+   * be the sum of the `iov_len` fields of all the `iovec` structures in the
+   * `iov` array, unless an error occurs. On error, returns -1 and sets `errno`
+   * appropriately.
+   *
+   */
+  virtual ssize_t Writev(int fd, const struct iovec* iov, int iovcnt) = 0;
+
+  /**
+   * @brief Reads data from a file descriptor.
+   *
+   * @param fd The file descriptor to read from.
+   * @param buffer A pointer to the buffer to store the read data.
+   * @param count The maximum number of bytes to read.
+   *
+   * @return On success, the number of bytes read is returned. On error, -1 is
+   * returned, and errno is set appropriately.
+   *
+   */
+  virtual ssize_t Read(int fd, void* buffer, size_t count) = 0;
+
+  /**
+   * @brief Accepts a new connection on a listening socket.
+   *
+   * @param fd The listening socket file descriptor.
+   * @param address A pointer to a sockaddr structure to store the address of
+   * the connecting client.
+   * @param address_len A pointer to a socklen_t variable that initially
+   * contains the size of the structure pointed to by address. On return, it
+   * contains the actual size of the client address.
+   *
+   * @return On success, a new file descriptor for the accepted connection is
+   * returned. On error, -1 is returned, and errno is set appropriately.
+   *
+   */
+  virtual int Accept(int fd, struct sockaddr* address,
+                     socklen_t* address_len) = 0;
+
+  /**
+   * @brief Open a file and return a file descriptor.
+   *
+   * @param pathname The path to the file to open.
+   * @param flags  bitwise OR combination of flags. The flags argument specifies
+   * how the file should be opened. It must include one of the following access
+   * modes: O_RDONLY, O_WRONLY, or O_RDWR.
+   *
+   * @return On success, a new file descriptor is returned. On error, -1 is
+   * returned, and errno is set appropriately.
+   *
+   */
+  virtual int Open(const char* pathname, int flags) = 0;
+
+  /**
+   * @brief Closes a file descriptor.
+   *
+   * @param fd The file descriptor to close.
+   *
+   */
+  virtual void Close(int fd) = 0;
+
+  /**
+   * @brief Deletes a file or directory.
+   *
+   * @param path The path to the file or directory to delete.
+   *
+   */
+  virtual void Unlink(const char* path) = 0;
+
+  /**
+   * @brief Initializes an inotify instance for monitoring file system events.
+   *
+   * @return On success, a new inotify file descriptor is returned. On error, -1
+   * is returned, and errno is set appropriately.
+   *
+   */
+  virtual int InotifyInit() = 0;
+
+  /**
+   * @brief Adds a watch to an inotify instance for a specific file or
+   * directory.
+   *
+   * @param fd The inotify file descriptor.
+   * @param pathname The path to the file or directory to watch.
+   * @param mask A bitmask specifying the events to watch for.
+   *
+   * @return On success, a unique watch descriptor is returned. On error, -1 is
+   * returned, and errno is set appropriately.
+   *
+   */
+  virtual int InotifyAddWatch(int fd, const char* pathname, uint32_t mask) = 0;
+
+  /**
+   * @brief Creates a new socket.
+   *
+   * @param domain The communication domain (e.g., AF_INET for IPv4, AF_INET6
+   * for IPv6).
+   * @param type The socket type (e.g., SOCK_STREAM for TCP, SOCK_DGRAM for
+   * UDP).
+   * @param protocol The protocol (e.g., 0 for the default protocol).
+   *
+   * @return On success, a new socket file descriptor is returned. On error, -1
+   * is returned, and errno is set appropriately.
+   *
+   */
+  virtual int Socket(int domain, int type, int protocol) = 0;
+
+  /**
+   * @brief Binds a socket to a specific address.
+   *
+   * @param fd The socket file descriptor.
+   * @param address A pointer to a sockaddr structure containing the address to
+   * bind to.
+   * @param address_len The size of the sockaddr structure.
+   *
+   * @return On success, 0 is returned. On error, -1 is returned, and errno is
+   * set appropriately.
+   *
+   */
+  virtual int Bind(int fd, const struct sockaddr* address,
+                   socklen_t address_len) = 0;
+
+  /**
+   * @brief Marks a socket as a passive socket, ready to accept connections.
+   *
+   * @param fd The socket file descriptor.
+   * @param backlog The maximum number of pending connections in the queue.
+   *
+   * @return On success, 0 is returned. On error, -1 is returned, and errno is
+   * set appropriately.
+   *
+   */
+  virtual int Listen(int fd, int backlog) = 0;
+
+  /**
+   * @brief Gets file status information.
+   *
+   * @param path The path to the file.
+   * @param sb A pointer to a stat structure to store the file status
+   * information.
+   *
+   * @return On success, 0 is returned. On error, -1 is returned, and errno is
+   * set appropriately.
+   *
+   */
+  virtual int Stat(const char* path, struct stat* sb) = 0;
+
+  /**
+   * @brief Checks if a file mode represents a socket file.
+   *
+   * @param st_mode The file mode.
+   *
+   * @return True if the file mode represents a socket file, false otherwise.
+   *
+   */
+  virtual bool IsSocketFile(int st_mode) = 0;
+
+  /**
+   * @brief Creates a pipe (unidirectional data channel).
+   *
+   * @param pipefd An array of two integers to store the read and write file
+   * descriptors of the pipe.
+   * @param flags Flags that can be used to modify the behavior of the pipe
+   * (e.g., O_NONBLOCK, O_CLOEXEC).
+   *
+   * @return On success, 0 is returned. On error, -1 is returned, and errno is
+   * set appropriately.
+   *
+   */
+  virtual int CreatePipe(int pipefd[2], int flags) = 0;
+
+  /**
+   * @brief Checks if a specific file descriptor is set in a file descriptor
+   * set.
+   *
+   * @param fd The file descriptor to check.
+   * @param set A pointer to the fd_set structure.
+   *
+   * @return 1 if the file descriptor is set, 0 otherwise.
+   *
+   */
+  virtual int FdIsSet(int fd, fd_set* set) = 0;
+
+  /**
+   * @brief Sets a specific file descriptor in a file descriptor set.
+   *
+   * @param fd The file descriptor to set.
+   * @param set A pointer to the fd_set structure.
+   *
+   */
+  virtual void FdSet(int fd, fd_set* set) = 0;
+
+  /**
+   * @brief Clears all file descriptors in a file descriptor set.
+   *
+   * @param set A pointer to the fd_set structure.
+   *
+   */
+  virtual void FdZero(fd_set* set) = 0;
+
+  /**
+   * @brief Sends a signal to a process.
+   *
+   * @param pid The process ID.
+   * @param signal The signal number.
+   *
+   * @return On success, 0 is returned. On error, -1 is returned, and errno is
+   * set appropriately.
+   *
+   */
+  virtual int Kill(pid_t pid, int signal) = 0;
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/timer_manager.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/timer_manager.h
new file mode 100644
index 0000000000..a88c7373e5
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/timer_manager.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <functional>
+
+namespace bluetooth_hal {
+namespace util {
+
+class Timer;
+
+class TimerManager {
+ public:
+  virtual ~TimerManager() = default;
+
+ private:
+  friend class Timer;
+
+  virtual bool Schedule(Timer* timer, const std::function<void()>& task,
+                        std::chrono::milliseconds delay) = 0;
+
+  virtual bool Cancel(Timer* timer) = 0;
+
+  virtual bool IsScheduled(Timer* timer) = 0;
+
+  static TimerManager& GetManager();
+};
+
+class Timer {
+ public:
+  ~Timer() { Cancel(); }
+
+  /**
+   * @brief Schedule a timer with a task and a delay. If there's already a task
+   * scheduled on this timer, then the previous task will be canceled.
+   *
+   * @param task The function to be run in the future.
+   * @param delay The delay in milliseconds, should be greater than 0ms.
+   * @return If true, the timer is scheduled successfully. Otherwise, false.
+   */
+  bool Schedule(const std::function<void()>& task,
+                std::chrono::milliseconds delay) {
+    if (delay <= std::chrono::milliseconds(0)) {
+      return false;
+    }
+    if (IsScheduled()) {
+      Cancel();
+    }
+    return TimerManager::GetManager().Schedule(this, task, delay);
+  }
+
+  /**
+   * @brief Cancel a timer. If there's no task scheduled on this timer, this is
+   * a no-op.
+   *
+   * @return If true, the timer is canceled successfully. Otherwise, false.
+   */
+  bool Cancel() { return TimerManager::GetManager().Cancel(this); }
+
+  /**
+   * @brief Check if the task on this timer is scheduled or not.
+   *
+   * @return If true, it means the task has been scheduled, and will be fired.
+   * If false, it means there's no task scheduled on this timer, or the task has
+   * been fired already.
+   */
+  bool IsScheduled() { return TimerManager::GetManager().IsScheduled(this); }
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/worker.h b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/worker.h
new file mode 100644
index 0000000000..767ceec399
--- /dev/null
+++ b/bluetooth/bluetooth_hal/include/public/bluetooth_hal/util/worker.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <condition_variable>
+#include <functional>
+#include <mutex>
+#include <queue>
+#include <thread>
+
+namespace bluetooth_hal {
+namespace util {
+
+constexpr size_t kDefaultMaxQueueSize = 10;
+constexpr std::chrono::seconds kPostTimeout{10};
+
+template <typename Message>
+class Worker {
+ public:
+  explicit Worker(std::function<void(Message)> handler,
+                  size_t max_queue_size = kDefaultMaxQueueSize)
+      : handler_(std::move(handler)),
+        kMaxQueueSize(max_queue_size),
+        running_(true) {
+    worker_thread_ = std::thread(&Worker::RunWorkerLoop, this);
+  };
+
+  ~Worker() {
+    Stop();
+    if (worker_thread_.joinable()) {
+      worker_thread_.join();
+    }
+  };
+
+  /**
+   * @brief Posts a message to the queue. Blocks if the queue is full.
+   *
+   * Waits until the queue has space available or the worker is stopped.
+   * If woken up because the worker stopped, the message is not posted.
+   *
+   * @param message The message to post.
+   */
+  bool Post(Message message) {
+    std::unique_lock<std::mutex> lock(mutex_);
+
+    producer_cv_.wait_for(lock, kPostTimeout, [&] {
+      return message_queue_.size() < kMaxQueueSize || !running_;
+    });
+    // If it still doen't meet the condition, then it means timeout.
+    if (message_queue_.size() >= kMaxQueueSize || !running_) {
+      return false;
+    }
+    message_queue_.push(std::move(message));
+    consumer_cv_.notify_one();
+    return true;
+  }
+
+  /**
+   * @brief Stops the worker loop and discards messages in the message queue.
+   */
+  void Stop() {
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (running_) {
+      running_ = false;
+      if (!message_queue_.empty()) {
+        std::queue<Message>().swap(message_queue_);
+      }
+      consumer_cv_.notify_one();
+      producer_cv_.notify_one();
+    }
+  }
+
+ private:
+  void RunWorkerLoop() {
+    while (running_) {
+      std::unique_lock<std::mutex> lock(mutex_);
+      consumer_cv_.wait(lock,
+                        [&] { return !message_queue_.empty() || !running_; });
+
+      if (!message_queue_.empty() && running_) {
+        Message task = std::move(message_queue_.front());
+        message_queue_.pop();
+        lock.unlock();
+        handler_(std::move(task));
+        producer_cv_.notify_one();
+      }
+    }
+  };
+
+  std::queue<Message> message_queue_;
+  std::mutex mutex_;
+  std::condition_variable producer_cv_;
+  std::condition_variable consumer_cv_;
+  std::thread worker_thread_;
+  std::function<void(Message)> handler_;
+  const size_t kMaxQueueSize;
+  bool running_;
+};
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/run_test.sh b/bluetooth/bluetooth_hal/run_test.sh
new file mode 100644
index 0000000000..69e7ae1c6f
--- /dev/null
+++ b/bluetooth/bluetooth_hal/run_test.sh
@@ -0,0 +1,171 @@
+#!/bin/bash
+
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[0;33m'
+NC='\033[0m' # No Color
+
+# Check for help flags
+if [[ "$1" == "-h" || "$1" == "--help" ]]; then
+  atest "$@"
+  exit $? # Exit with atest's exit code
+fi
+
+# Parse command-line arguments
+args=()
+host_filter=false
+while [[ $# -gt 0 ]]; do
+  if [[ "$1" == "--host" ]]; then
+    host_filter=true
+  fi
+  args+=("$1")
+  shift
+done
+
+android_bp_file="$(dirname "$0")/Android.bp"
+test_info=() # Array to store "name:host_supported" or "name:"
+
+# Use awk to extract test names and host_supported status
+# This awk script finds cc_test blocks, captures the name,
+# and checks for host_supported: false within the same block.
+# It outputs "name:true" if host_supported is true or missing,
+# and "name:false" if host_supported is false.
+readarray -t test_info < <(awk '
+/^cc_test \{/ {
+  in_test_block=1;
+  current_test_name="";
+  host_supported=1; # Assume true by default if not specified false
+  device_supported=1; # Assume true by default if not specified false
+}
+in_test_block {
+  if ($1 == "name:") {
+    match($0, /name: "([^"]+)"/, a);
+    if (a[1]) current_test_name=a[1];
+  }
+  # Check for explicit false
+  if ($1 == "host_supported:" && $2 == "false,") {
+    host_supported=0;
+  }
+  if ($1 == "device_supported:" && $2 == "false,") {
+    device_supported=0;
+  }
+  if ($1 == "}") {
+    if (current_test_name != "") {
+      print current_test_name ":" (host_supported ? "true" : "false") ":" (device_supported ? "true" : "false")
+    }
+    in_test_block=0;
+    current_test_name="";
+    host_supported=1; # Reset for next block
+    device_supported=1; # Reset for next block
+  }
+}
+' "$android_bp_file")
+
+test_count=${#test_info[@]}
+tests_to_run=()
+skipped_tests=() # Store name and reason for skipping
+
+# Modified filtering logic based on host_filter, host_supported, and device_supported
+if [[ "$test_count" -gt 0 ]]; then
+  echo ""
+  echo "====================================================="
+  echo "Found $test_count test cases:"
+  for info in "${test_info[@]}"; do
+    IFS=':' read -r name host_supported_status device_supported_status <<< "$info"
+    echo "  - $name" # Still list all found tests initially
+
+    skip_reason=""
+    should_skip=false
+
+    if [[ "$host_filter" == true && "$host_supported_status" == "false" ]]; then
+      should_skip=true
+      skip_reason="[host_supported: false] with [--host]"
+    elif [[ "$host_filter" == false && "$device_supported_status" == "false" ]]; then
+      should_skip=true
+      skip_reason="[device_supported: false] without [--host]"
+    fi
+
+    if [[ "$should_skip" == true ]]; then
+      skipped_tests+=("$name ($skip_reason)") # Store name and reason
+    else
+      tests_to_run+=("$name")
+    fi
+  done
+  echo "====================================================="
+  echo ""
+
+  # Modified skipped message printing to include reason
+  if [[ "${#skipped_tests[@]}" -gt 0 ]]; then
+      echo -e "${YELLOW}Skipping tests:"
+      for skipped_test_info in "${skipped_tests[@]}"; do
+          echo "  - $skipped_test_info"
+      done
+      echo -e "${NC}"
+  fi
+
+  if [[ "${#tests_to_run[@]}" -eq 0 ]]; then
+      echo "No tests to run after filtering."
+      # Print skipped tests here too if any were skipped
+      if [[ "${#skipped_tests[@]}" -gt 0 ]]; then
+          echo "Skipped tests:"
+          for skipped_test_info in "${skipped_tests[@]}"; do
+              echo "  - $skipped_test_info"
+          done
+      fi
+      exit 0
+  fi
+
+  # Build the atest command
+  test_command="atest"
+  for test_name in "${tests_to_run[@]}"; do
+    test_command+=" $test_name"
+  done
+  test_command+=" ${args[@]}"
+
+  echo ""
+  echo "Running test command:"
+  echo "  $test_command"
+  echo ""
+
+  # Run the combined atest command
+  eval "$test_command"
+  atest_exit_code=$?
+
+  # Print skipped tests after complete
+  if [[ "${#skipped_tests[@]}" -gt 0 ]]; then
+      echo -e "${YELLOW}"
+      echo "Skipped tests:"
+      for skipped_test_info in "${skipped_tests[@]}"; do
+          echo "  - $skipped_test_info"
+      done
+      echo ""
+  fi
+
+  if [[ $atest_exit_code -ne 0 ]]; then
+    echo -e "${RED}"
+    echo "       "
+    echo "     "
+    echo "       "
+    echo "       "
+    echo "       "
+    echo "       "
+    echo "                           "
+    echo "One or more tests failed!"
+    exit 1
+  else
+    echo -e "${GREEN}"
+    echo -e "   "
+    echo -e ""
+    echo -e ""
+    echo -e " "
+    echo -e "       "
+    echo -e "       "
+    echo "                                      "
+    echo -e "All tests completed successfully!${NC}"
+  fi
+else
+  echo "No matching cc_test names found in Android.bp."
+  exit 1
+fi
+
+exit 0
diff --git a/bluetooth/bluetooth_hal/test/Android.bp b/bluetooth/bluetooth_hal/test/Android.bp
new file mode 100644
index 0000000000..41469febc6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/Android.bp
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (c) 2025 The Android Open Source Project
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+filegroup {
+    name: "test_mock_transport_srcs",
+    srcs: [
+        "mock/mock_transport_interface.cc",
+    ],
+}
+
+filegroup {
+    name: "test_mock_router_srcs",
+    srcs: [
+        "mock/mock_hci_router.cc",
+        "mock/mock_hci_router_client_agent.cc",
+    ],
+}
+
+filegroup {
+    name: "test_mock_router_client_agent_srcs",
+    srcs: [
+        "mock/mock_hci_router_client_agent.cc",
+    ],
+}
+
+filegroup {
+    name: "test_mock_util_srcs",
+    srcs: [
+        "mock/mock_wakelock.cc",
+        "mock/mock_android_base_wrapper.cc",
+    ],
+}
+
+filegroup {
+    name: "test_mock_thread_srcs",
+    srcs: [
+        "mock/mock_socket_processor.cc",
+    ],
+}
+
+filegroup {
+    name: "test_mock_debug_srcs",
+    srcs: [
+        "mock/mock_vnd_snoop_logger.cc",
+    ],
+}
diff --git a/bluetooth/bluetooth_hal/test/mock/mock_android_base_wrapper.cc b/bluetooth/bluetooth_hal/test/mock/mock_android_base_wrapper.cc
new file mode 100644
index 0000000000..b9b31b3f47
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/mock/mock_android_base_wrapper.cc
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+
+namespace bluetooth_hal {
+namespace util {
+
+static MockAndroidBaseWrapper* mock_android_base_wrapper = nullptr;
+
+AndroidBaseWrapper& AndroidBaseWrapper::GetWrapper() {
+  return *mock_android_base_wrapper;
+}
+
+void MockAndroidBaseWrapper::SetMockWrapper(MockAndroidBaseWrapper* wrapper) {
+  mock_android_base_wrapper = wrapper;
+}
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/test/mock/mock_hci_router.cc b/bluetooth/bluetooth_hal/test/mock/mock_hci_router.cc
new file mode 100644
index 0000000000..6efc2b0b6b
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/mock/mock_hci_router.cc
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/test/mock/mock_hci_router.h"
+
+#include "bluetooth_hal/hci_router.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+static MockHciRouter* mock_hci_router_;
+
+HciRouter& HciRouter::GetRouter() { return *mock_hci_router_; }
+
+void MockHciRouter::SetMockRouter(MockHciRouter* router) {
+  mock_hci_router_ = router;
+}
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/test/mock/mock_hci_router_client_agent.cc b/bluetooth/bluetooth_hal/test/mock/mock_hci_router_client_agent.cc
new file mode 100644
index 0000000000..8eca689b37
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/mock/mock_hci_router_client_agent.cc
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/test/mock/mock_hci_router_client_agent.h"
+
+#include "bluetooth_hal/hci_router_client_agent.h"
+
+namespace bluetooth_hal {
+namespace hci {
+
+static MockHciRouterClientAgent* mock_agent_;
+
+HciRouterClientAgent& HciRouterClientAgent::GetAgent() { return *mock_agent_; }
+
+void MockHciRouterClientAgent::SetMockAgent(MockHciRouterClientAgent* agent) {
+  mock_agent_ = agent;
+}
+
+}  // namespace hci
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/test/mock/mock_socket_processor.cc b/bluetooth/bluetooth_hal/test/mock/mock_socket_processor.cc
new file mode 100644
index 0000000000..ef09e3114d
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/mock/mock_socket_processor.cc
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/test/mock/mock_socket_processor.h"
+
+#include <optional>
+#include <string>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/hal_packet.h"
+
+namespace bluetooth_hal {
+namespace thread {
+
+using ::bluetooth_hal::hci::HalPacketCallback;
+
+static MockSocketProcessor* mock_socket_processor = nullptr;
+
+void SocketProcessor::Initialize(
+    const std::string& socket_path,
+    std::optional<HalPacketCallback> hal_packet_cb) {
+  if (mock_socket_processor) {
+    mock_socket_processor->Initialize(socket_path, hal_packet_cb);
+  } else {
+    LOG(ERROR) << __func__ << ": mock_socket_processor is nullptr.";
+  }
+}
+
+void SocketProcessor::Cleanup() {
+  if (mock_socket_processor) {
+    mock_socket_processor->Cleanup();
+  } else {
+    LOG(ERROR) << __func__ << ": mock_socket_processor is nullptr.";
+  }
+}
+
+SocketProcessor* SocketProcessor::GetProcessor() {
+  if (!mock_socket_processor) {
+    LOG(FATAL) << __func__ << ": mock_socket_processor is nullptr.";
+  }
+  return mock_socket_processor;
+}
+
+void MockSocketProcessor::SetMockProcessor(MockSocketProcessor* processor) {
+  mock_socket_processor = processor;
+}
+
+}  // namespace thread
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/test/mock/mock_transport_interface.cc b/bluetooth/bluetooth_hal/test/mock/mock_transport_interface.cc
new file mode 100644
index 0000000000..b2cb9bfde8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/mock/mock_transport_interface.cc
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/test/mock/mock_transport_interface.h"
+
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+using ::bluetooth_hal::HalState;
+
+static MockTransportInterface* mock_transport_interface = nullptr;
+
+TransportInterface& TransportInterface::GetTransport() {
+  return *mock_transport_interface;
+}
+
+bool TransportInterface::UpdateTransportType(TransportType requested_type) {
+  return mock_transport_interface->UpdateTransportType(requested_type);
+}
+
+TransportType TransportInterface::GetTransportType() {
+  return mock_transport_interface->GetTransportType();
+}
+
+bool TransportInterface::RegisterVendorTransport(
+    std::unique_ptr<TransportInterface> transport) {
+  return mock_transport_interface->RegisterVendorTransport(
+      std::move(transport));
+}
+
+bool TransportInterface::UnregisterVendorTransport(TransportType type) {
+  return mock_transport_interface->UnregisterVendorTransport(type);
+}
+
+void TransportInterface::SetHciRouterBusy(bool is_busy) {
+  mock_transport_interface->SetHciRouterBusy(is_busy);
+}
+
+void TransportInterface::NotifyHalStateChange(HalState hal_state) {
+  mock_transport_interface->NotifyHalStateChange(hal_state);
+}
+
+void TransportInterface::Subscribe(Subscriber& subscriber) {
+  mock_transport_interface->Subscribe(subscriber);
+}
+
+void TransportInterface::Unsubscribe(Subscriber& subscriber) {
+  mock_transport_interface->Unsubscribe(subscriber);
+}
+
+void MockTransportInterface::SetMockTransport(
+    MockTransportInterface* transport) {
+  mock_transport_interface = transport;
+}
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/vibrator/1.3/types.hal b/bluetooth/bluetooth_hal/test/mock/mock_vnd_snoop_logger.cc
similarity index 53%
rename from vibrator/1.3/types.hal
rename to bluetooth/bluetooth_hal/test/mock/mock_vnd_snoop_logger.cc
index ceb62a5f66..0e035c437c 100644
--- a/vibrator/1.3/types.hal
+++ b/bluetooth/bluetooth_hal/test/mock/mock_vnd_snoop_logger.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 The Android Open Source Project
+ * Copyright 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,17 +14,20 @@
  * limitations under the License.
  */
 
-package android.hardware.vibrator@1.3;
+#include "bluetooth_hal/test/mock/mock_vnd_snoop_logger.h"
 
-import @1.2::Effect;
+#include "bluetooth_hal/debug/vnd_snoop_logger.h"
 
-enum Effect : @1.2::Effect {
-     /**
-      * A soft tick effect meant to be played as a texture.
-      *
-      * A soft, short sensation like the tick of a clock. Unlike regular effects, texture effects
-      * are expected to be played multiple times in quick succession, replicating a specific
-      * texture to the user as a form of haptic feedback.
-      */
-     TEXTURE_TICK
-};
+namespace bluetooth_hal {
+namespace debug {
+
+static MockVndSnoopLogger* mock_vnd_snoop_logger_;
+
+VndSnoopLogger& VndSnoopLogger::GetLogger() { return *mock_vnd_snoop_logger_; }
+
+void MockVndSnoopLogger::SetMockVndSnoopLogger(MockVndSnoopLogger* logger) {
+  mock_vnd_snoop_logger_ = logger;
+}
+
+}  // namespace debug
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/test/mock/mock_wakelock.cc b/bluetooth/bluetooth_hal/test/mock/mock_wakelock.cc
new file mode 100644
index 0000000000..b295ae91b8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/test/mock/mock_wakelock.cc
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/test/mock/mock_wakelock.h"
+
+#include "bluetooth_hal/util/power/wakelock.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+static MockWakelock* mock_wakelock_;
+
+Wakelock& Wakelock::GetWakelock() { return *mock_wakelock_; }
+
+void MockWakelock::SetMockWakelock(MockWakelock* wakelock) {
+  mock_wakelock_ = wakelock;
+}
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/device_control/power_manager.cc b/bluetooth/bluetooth_hal/transport/device_control/power_manager.cc
new file mode 100644
index 0000000000..30bb2dbed5
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/device_control/power_manager.cc
@@ -0,0 +1,295 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.device_control"
+
+#include "bluetooth_hal/transport/device_control/power_manager.h"
+
+#include <sys/types.h>
+
+#include <array>
+#include <chrono>
+#include <string>
+#include <string_view>
+#include <thread>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::android::base::unique_fd;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::debug::BqrErrorCode;
+using ::bluetooth_hal::debug::DebugCentral;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+// TODO: b/391226112 - Move to property config manager.
+constexpr std::chrono::milliseconds kLpmWakeupSettlementMs{10};
+
+std::string GetRfkillStatePath() {
+  std::string state_path;
+
+  for (int i = 0;; ++i) {
+    const std::string type_path =
+        HalConfigLoader::GetLoader().GetRfkillFolderPrefix() +
+        std::to_string(i) + "/type";
+    unique_fd fd(
+        SystemCallWrapper::GetWrapper().Open(type_path.c_str(), O_RDONLY));
+
+    if (!fd.ok()) {
+      LOG(INFO) << __func__ << ": Open(" << type_path
+                << "): " << strerror(errno) << " (" << errno << ").";
+      break;
+    }
+
+    std::array<char, 16> buffer{};
+    const ssize_t length =
+        TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Read(
+            fd.get(), buffer.data(), buffer.size() - 1));
+
+    if (length < 1) {
+      continue;
+    }
+
+    if (buffer[length - 1] == '\n') {
+      buffer[length - 1] = '\0';
+    }
+
+    LOG(DEBUG) << __func__ << ": rfkill candidate " << type_path << " is ["
+               << buffer.data() << "].";
+
+    if ((std::string_view(buffer.data()) ==
+         HalConfigLoader::GetLoader().GetRfkillTypeBluetooth())) {
+      state_path = HalConfigLoader::GetLoader().GetRfkillFolderPrefix() +
+                   std::to_string(i) + "/state";
+      LOG(INFO) << __func__ << ": Use rfkill " << state_path << ".";
+      break;
+    }
+  }
+
+  return state_path;
+}
+
+}  // namespace
+
+// TODO: b/421766932 - Add battery level query.
+
+bool PowerManager::PowerControl(bool is_enabled) {
+  DURATION_TRACKER(AnchorType::POWER_CTRL, __func__);
+
+  const std::string state_path = GetRfkillStatePath();
+  if (state_path.empty()) {
+    LOG(INFO) << __func__
+              << ": Power sequence is not controlled by Bluetooth HAL.";
+    return true;
+  }
+
+  unique_fd fd(
+      SystemCallWrapper::GetWrapper().Open(state_path.c_str(), O_WRONLY));
+  if (!fd.ok()) {
+    LOG(ERROR) << __func__ << ": Unable to open rfkill state {" << state_path
+               << "}: " << strerror(errno) << " (" << errno << ")";
+#ifndef UNIT_TEST
+    DebugCentral::Get()->ReportBqrError(BqrErrorCode::HOST_POWER_UP_CONTROLLER,
+                                        "Unable to open rfkill state");
+#endif
+    return false;
+  }
+
+  ANCHOR_LOG_INFO(AnchorType::POWER_STATE)
+      << __func__ << ": " << (is_enabled ? "Enabling" : "Disabling")
+      << ", state_path: " << state_path;
+
+  char power = is_enabled ? '1' : '0';
+  const ssize_t length =
+      SystemCallWrapper::GetWrapper().Write(fd.get(), &power, sizeof(power));
+
+  if (length < 1) {
+    LOG(ERROR) << __func__
+               << ": Failed to change rfkill state: " << strerror(errno) << " ("
+               << errno << ")";
+#ifndef UNIT_TEST
+    DebugCentral::Get()->ReportBqrError(BqrErrorCode::HOST_POWER_UP_CONTROLLER,
+                                        "Cannot write power control data");
+#endif
+    return false;
+  }
+
+  return true;
+}
+
+bool PowerManager::SetupLowPowerMode() {
+  ANCHOR_LOG_INFO(AnchorType::LPM_ENABLE) << __func__ << ": LPM enabling";
+
+  lpm_fd_.reset(SystemCallWrapper::GetWrapper().Open(
+      HalConfigLoader::GetLoader().GetLpmWakingProcNode().c_str(), O_WRONLY));
+  if (!lpm_fd_.ok()) {
+    LOG(WARNING) << __func__ << ": Unable to open LPM control port ("
+                 << HalConfigLoader::GetLoader().GetLpmWakingProcNode()
+                 << "): " << strerror(errno) << " (" << errno << ").";
+    ANCHOR_LOG(AnchorType::LPM_SETUP_ERR)
+        << __func__ << ": Unable to open LPM control port, " << strerror(errno)
+        << "(" << errno << ")";
+    return false;
+  }
+
+  // Enable Host LPM.
+  unique_fd enable_fd(SystemCallWrapper::GetWrapper().Open(
+      HalConfigLoader::GetLoader().GetLpmEnableProcNode().c_str(), O_WRONLY));
+  if (!enable_fd.ok()) {
+    ANCHOR_LOG_WARNING(AnchorType::LPM_SETUP_ERR)
+        << __func__ << ": Unable to open LPM driver, " << strerror(errno) << "("
+        << errno << ")";
+    return false;
+  }
+
+  constexpr char enable_cmd = '1';
+  ssize_t length = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+      enable_fd.get(), &enable_cmd, sizeof(enable_cmd)));
+  if (length < 1) {
+    LOG(WARNING) << __func__ << ": Unable to enable LPM driver ("
+                 << HalConfigLoader::GetLoader().GetLpmEnableProcNode()
+                 << "): " << strerror(errno) << " (" << errno << ").";
+    TeardownLowPowerMode();
+    return false;
+  }
+
+  length = TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+      lpm_fd_.get(), &enable_cmd, sizeof(enable_cmd)));
+  if (length < 1) {
+    ANCHOR_LOG_WARNING(AnchorType::LPM_SETUP_ERR)
+        << __func__ << ": Unable to wake up LPM:" << strerror(errno) << " ("
+        << errno << ").";
+    TeardownLowPowerMode();
+    return false;
+  }
+
+  return true;
+}
+
+void PowerManager::TeardownLowPowerMode() {
+  ANCHOR_LOG_INFO(AnchorType::LPM_DISABLE) << __func__ << ": LPM disabling.";
+
+  lpm_fd_.reset();
+
+  unique_fd disable_fd(SystemCallWrapper::GetWrapper().Open(
+      HalConfigLoader::GetLoader().GetLpmEnableProcNode().c_str(), O_WRONLY));
+  if (!disable_fd.ok()) {
+    ANCHOR_LOG_WARNING(AnchorType::LPM_CLOSE_ERR)
+        << __func__ << ": Unable to close LPM driver ("
+        << HalConfigLoader::GetLoader().GetLpmEnableProcNode()
+        << "): " << strerror(errno) << " (" << errno << ").";
+    return;
+  }
+
+  constexpr char disable_cmd = '0';
+  const ssize_t length = SystemCallWrapper::GetWrapper().Write(
+      disable_fd.get(), &disable_cmd, sizeof(disable_cmd));
+  if (length < 1) {
+    LOG(WARNING) << __func__ << ": Unable to disable LPM driver ("
+                 << HalConfigLoader::GetLoader().GetLpmEnableProcNode()
+                 << "): " << strerror(errno) << " (" << errno << ")";
+  }
+}
+
+bool PowerManager::ResumeFromLowPowerMode() {
+  if (!lpm_fd_.ok()) {
+    // LPM is not enabled.
+    return true;
+  }
+
+  constexpr char resume_cmd = '1';
+  const ssize_t length =
+      TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+          lpm_fd_.get(), &resume_cmd, sizeof(resume_cmd)));
+  if (length < 1) {
+    ANCHOR_LOG_ERROR(AnchorType::LPM_WAKEUP_ERR)
+        << __func__ << ": Unable to wake up LPM:" << strerror(errno) << " ("
+        << errno << ").";
+    return false;
+  }
+
+  std::this_thread::sleep_for(kLpmWakeupSettlementMs);
+  ANCHOR_LOG(AnchorType::LPM_WAKEUP) << __func__ << ": Assert";
+  return true;
+}
+
+bool PowerManager::SuspendToLowPowerMode() {
+  if (!lpm_fd_.ok()) {
+    // LPM is not enabled.
+    return true;
+  }
+
+  constexpr char suspend_cmd = '0';
+  const ssize_t length =
+      TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+          lpm_fd_.get(), &suspend_cmd, sizeof(suspend_cmd)));
+  if (length < 1) {
+    ANCHOR_LOG_ERROR(AnchorType::LPM_WAKEUP_ERR)
+        << __func__ << ": Unable to suspend LPM:" << strerror(errno) << " ("
+        << errno << ").";
+    return false;
+  }
+
+  ANCHOR_LOG(AnchorType::LPM_SUSPEND) << __func__ << ": Deassert";
+  return true;
+}
+
+bool PowerManager::IsLowPowerModeSetupCompleted() const { return lpm_fd_.ok(); }
+
+bool PowerManager::ConfigRxWakelockTime(int duration) {
+  if (duration == 0) {
+    return true;
+  }
+
+  if (duration < 0) {
+    LOG(WARNING) << __func__ << ": Invalid value: " << duration;
+    return false;
+  }
+
+  LOG(INFO) << __func__ << ": config rx wakelock time: " << duration;
+
+  unique_fd wake_ctrl_fd(SystemCallWrapper::GetWrapper().Open(
+      HalConfigLoader::GetLoader().GetLpmWakelockCtrlProcNode().c_str(),
+      O_WRONLY));
+  if (!wake_ctrl_fd.ok()) {
+    LOG(WARNING) << __func__
+                 << ": Unable to open Kernel Wakelock control port ("
+                 << HalConfigLoader::GetLoader().GetLpmWakelockCtrlProcNode()
+                 << "): " << strerror(errno) << " (" << errno << ").";
+    return false;
+  }
+
+  const ssize_t length =
+      TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+          wake_ctrl_fd.get(), &duration, sizeof(duration)));
+  if (length < 1) {
+    LOG(ERROR) << __func__
+               << ": Unable to config kernel wakelock time:" << strerror(errno)
+               << " (" << errno << ").";
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/device_control/uart_manager.cc b/bluetooth/bluetooth_hal/transport/device_control/uart_manager.cc
new file mode 100644
index 0000000000..24e528b271
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/device_control/uart_manager.cc
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.device_control"
+
+#include "bluetooth_hal/transport/device_control/uart_manager.h"
+
+#include <sys/types.h>
+#include <termios.h>
+
+#include <chrono>
+#include <string>
+#include <string_view>
+#include <thread>
+
+#include "android-base/logging.h"
+#include "android-base/unique_fd.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::android::base::unique_fd;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::debug::BqrErrorCode;
+using ::bluetooth_hal::debug::DebugCentral;
+using ::bluetooth_hal::uart::BaudRate;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+// TODO: b/391226112 - Move to property config manager.
+constexpr std::chrono::milliseconds kUartStartupSettlementMs{50};
+constexpr std::string_view kUartCtrlNode =
+    "/sys/devices/platform/155d0000.serial/uart_dbg";
+
+bool ConfigureUartPort(int fd) {
+  termios tty_attrs = {};
+  if (tcgetattr(fd, &tty_attrs) != 0) {
+    LOG(ERROR) << "Failed to get UART attributes: " << strerror(errno);
+    return false;
+  }
+
+  cfmakeraw(&tty_attrs);
+  // Enable RTS/CTS (hardware flow control).
+  tty_attrs.c_cflag |= CRTSCTS;
+
+  // Set baud rate to 115200.
+  if (cfsetspeed(&tty_attrs, B115200) != 0) {
+    LOG(ERROR) << "Failed to set baud rate: " << strerror(errno);
+    return false;
+  }
+
+  if (tcsetattr(fd, TCSANOW, &tty_attrs) != 0) {
+    LOG(ERROR) << "Failed to set UART attributes: " << strerror(errno);
+    return false;
+  }
+
+  // Flush input and output queues.
+  if (tcflush(fd, TCIOFLUSH) != 0) {
+    LOG(ERROR) << "Failed to flush UART port: " << strerror(errno);
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace
+
+bool UartManager::Open() {
+  DURATION_TRACKER(AnchorType::USERIAL_OPEN, __func__);
+
+  const std::string bt_uart_port =
+      HalConfigLoader::GetLoader().GetBtUartDevicePort();
+
+#ifndef UNIT_TEST
+  DebugCentral::Get()->SetBtUartDebugPort(bt_uart_port);
+#endif
+
+  ANCHOR_LOG(AnchorType::USERIAL_TTY_OPEN)
+      << __func__ << ": open " << bt_uart_port;
+
+  uart_fd_.reset(
+      SystemCallWrapper::GetWrapper().Open(bt_uart_port.c_str(), O_RDWR));
+  if (!uart_fd_.ok()) {
+#ifndef UNIT_TEST
+    DebugCentral::Get()->ReportBqrError(BqrErrorCode::HOST_OPEN_USERIAL,
+                                        "Host Open Port Error");
+#endif
+    return false;
+  }
+
+  if (!ConfigureUartPort(uart_fd_.get())) {
+    LOG(ERROR) << __func__
+               << ": Failed to configure UART port: " << strerror(errno) << " ("
+               << errno << ").";
+  }
+
+  // Wait for the device to power cycle and stabilize.
+  std::this_thread::sleep_for(kUartStartupSettlementMs);
+
+  return true;
+}
+
+void UartManager::Close() {
+  DURATION_TRACKER(AnchorType::USERIAL_CLOSE, __func__);
+  uart_fd_.reset();
+}
+
+bool UartManager::SetUartSkipSuspend(bool skip_suspend) {
+  LOG(INFO) << __func__ << ": Open UartCtrl device node.";
+
+  unique_fd ctrl_fd(
+      SystemCallWrapper::GetWrapper().Open(kUartCtrlNode.data(), O_WRONLY));
+  if (!ctrl_fd.ok()) {
+    LOG(WARNING) << __func__ << ": Unable to open UartCtrl port ("
+                 << kUartCtrlNode << "): " << strerror(errno) << " (" << errno
+                 << ").";
+    return false;
+  }
+
+  char skip_suspend_cmd = skip_suspend ? '8' : '9';
+  const ssize_t length =
+      TEMP_FAILURE_RETRY(SystemCallWrapper::GetWrapper().Write(
+          ctrl_fd.get(), &skip_suspend_cmd, sizeof(skip_suspend_cmd)));
+  if (length < 1) {
+    LOG(ERROR) << __func__ << ": Unable to set uart IOCTRL:" << strerror(errno)
+               << " (" << errno << ")";
+    return false;
+  }
+
+  LOG(INFO) << __func__ << ": Is enabled: " << skip_suspend;
+
+  return true;
+}
+
+void UartManager::UpdateBaudRate(BaudRate rate) const {
+  speed_t kernel_rate;
+  switch (rate) {
+    case BaudRate::kRate115200:
+      kernel_rate = B115200;
+      break;
+    case BaudRate::kRate3000000:
+      kernel_rate = B3000000;
+      break;
+    case BaudRate::kRate4000000:
+      kernel_rate = B4000000;
+      break;
+    default:
+      LOG(WARNING) << __func__ << ": Baud rate (" << static_cast<int>(rate)
+                   << ") unsupported";
+      return;
+  };
+
+  termios tty_attrs;
+  if (tcgetattr(uart_fd_.get(), &tty_attrs) != 0) {
+    LOG(ERROR) << __func__ << ": Failed to get terminal attributes: "
+               << std::strerror(errno);
+    return;
+  }
+
+  cfmakeraw(&tty_attrs);
+  cfsetspeed(&tty_attrs, kernel_rate);
+  if (tcsetattr(uart_fd_.get(), TCSANOW, &tty_attrs) != 0) {
+    LOG(ERROR) << __func__ << ": Failed to set terminal attributes: "
+               << std::strerror(errno);
+    return;
+  }
+
+  tcflush(uart_fd_, TCIOFLUSH);
+}
+
+int UartManager::GetFd() { return uart_fd_.get(); }
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/transport_interface.cc b/bluetooth/bluetooth_hal/transport/transport_interface.cc
new file mode 100644
index 0000000000..7aa875a5d9
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/transport_interface.cc
@@ -0,0 +1,265 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.transport_interface"
+
+#include "bluetooth_hal/transport/transport_interface.h"
+
+#include <algorithm>
+#include <atomic>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/config/config_constants.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/uart_h4/transport_uart_h4.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::config::HalConfigLoader;
+namespace cfg_consts = ::bluetooth_hal::config::constants;
+
+TransportType TransportInterface::current_transport_type_ =
+    cfg_consts::kDefaultBtTransportType;
+std::unique_ptr<TransportInterface> TransportInterface::current_transport_;
+std::unordered_map<TransportType, std::unique_ptr<TransportInterface>>
+    TransportInterface::vendor_transports_;
+std::recursive_mutex TransportInterface::transport_mutex_;
+std::atomic<bool> TransportInterface::is_hci_router_busy_ = false;
+std::atomic<HalState> TransportInterface::hal_state_ = HalState::kInit;
+std::vector<std::reference_wrapper<Subscriber>>
+    TransportInterface::subscribers_;
+
+TransportInterface& TransportInterface::GetTransport() {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+
+  const std::vector<TransportType>& current_transport_type_priorities =
+      HalConfigLoader::GetLoader().GetTransportTypePriority();
+
+  for (auto type : current_transport_type_priorities) {
+    if (UpdateTransportType(type)) {
+      return *current_transport_;
+    }
+  }
+
+  LOG(WARNING) << __func__
+               << ": No transport from priority list initialized. Falling back "
+                  "to UartH4.";
+  UpdateTransportType(TransportType::kUartH4);
+
+  return *current_transport_;
+}
+
+std::pair<std::unique_ptr<TransportInterface>, TransportType>
+TransportInterface::CreateOrAcquireTransport(TransportType requested_type) {
+  std::unique_ptr<TransportInterface> new_transport;
+  TransportType new_transport_type = requested_type;
+
+  switch (requested_type) {
+    case TransportType::kVendorStart... TransportType::kVendorEnd: {
+      auto it = vendor_transports_.find(requested_type);
+      if (it != vendor_transports_.end() && it->second) {
+        new_transport = std::move(it->second);
+      } else {
+        LOG(ERROR) << __func__
+                   << ": Vendor transport not found or is null for type: "
+                   << static_cast<int>(requested_type);
+        return {nullptr, requested_type};
+      }
+      break;
+    }
+    case TransportType::kUartH4: {
+      new_transport = std::make_unique<TransportUartH4>();
+      break;
+    }
+    case TransportType::kUnknown:
+    default:
+      LOG(WARNING) << __func__ << ": Requested unhandled or kUnknown type: "
+                   << static_cast<int>(requested_type)
+                   << ". Defaulting to kUartH4.";
+      new_transport_type = TransportType::kUartH4;
+      new_transport = std::make_unique<TransportUartH4>();
+      break;
+  }
+
+  return {std::move(new_transport), new_transport_type};
+}
+
+bool TransportInterface::UpdateTransportType(TransportType requested_type) {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+
+  if (current_transport_type_ == requested_type && current_transport_) {
+    return true;
+  }
+
+  auto [new_transport, new_transport_type] =
+      CreateOrAcquireTransport(requested_type);
+
+  // If the new transport instance could not be created or acquired.
+  if (!new_transport) {
+    LOG(ERROR) << __func__
+               << ": Failed to create or acquire new transport for type: "
+               << static_cast<int>(requested_type);
+    return false;
+  }
+
+  // New transport is ready. Now, cleanup and replace the old one.
+  if (current_transport_) {
+    current_transport_->Cleanup();
+    if (current_transport_type_ >= TransportType::kVendorStart &&
+        current_transport_type_ <= TransportType::kVendorEnd) {
+      // Move the old vendor transport back to the map.
+      vendor_transports_[current_transport_type_] =
+          std::move(current_transport_);
+      LOG(INFO) << __func__ << ": Moved back old vendor transport type: "
+                << static_cast<int>(current_transport_type_);
+    }
+  }
+
+  // Activate the new transport.
+  current_transport_ = std::move(new_transport);
+  current_transport_type_ = new_transport_type;
+
+  if (current_transport_) {
+    LOG(INFO) << __func__
+              << ": Successfully initialized transport for priority type: "
+              << static_cast<int>(current_transport_type_);
+  }
+
+  return current_transport_ != nullptr;
+}
+
+bool TransportInterface::RegisterVendorTransport(
+    std::unique_ptr<TransportInterface> transport) {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+
+  if (!transport) {
+    LOG(ERROR) << __func__ << ": Cannot register null transport.";
+    return false;
+  }
+
+  TransportType type = transport->GetInstanceTransportType();
+
+  if (current_transport_ && current_transport_type_ == type) {
+    LOG(WARNING) << __func__ << ": Current vendor transport is active for type "
+                 << static_cast<int>(type) << ", close it first.";
+    return false;
+  }
+
+  if (type < TransportType::kVendorStart || type > TransportType::kVendorEnd) {
+    LOG(ERROR) << __func__
+               << ": Invalid vendor transport type: " << static_cast<int>(type);
+    return false;
+  }
+
+  if (vendor_transports_.count(type)) {
+    LOG(WARNING) << __func__ << ": Vendor transport type already registered: "
+                 << static_cast<int>(type);
+  }
+
+  vendor_transports_[type] = std::move(transport);
+
+  return true;
+}
+
+bool TransportInterface::UnregisterVendorTransport(TransportType type) {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+
+  if (type < TransportType::kVendorStart || type > TransportType::kVendorEnd) {
+    LOG(ERROR) << __func__
+               << ": Invalid transport type for unregistration (not a vendor "
+                  "type): "
+               << static_cast<int>(type);
+    return false;
+  }
+
+  if (current_transport_ && current_transport_type_ == type) {
+    LOG(WARNING) << __func__ << ": Cannot unregister currently active "
+                 << "vendor transport type: " << static_cast<int>(type);
+    return false;
+  }
+
+  auto it = vendor_transports_.find(type);
+  if (it == vendor_transports_.end() || !it->second) {
+    LOG(WARNING) << __func__
+                 << ": Vendor transport not found or is null for type: "
+                 << static_cast<int>(type);
+    return false;
+  }
+
+  it->second->Cleanup();  // Ensure cleanup is called before removing.
+  vendor_transports_.erase(it);
+  LOG(INFO) << __func__ << ": Successfully unregistered vendor transport type: "
+            << static_cast<int>(type);
+  return true;
+}
+
+TransportType TransportInterface::GetTransportType() {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+  return current_transport_type_;
+}
+
+void TransportInterface::SetHciRouterBusy(bool is_busy) {
+  is_hci_router_busy_ = is_busy;
+}
+
+void TransportInterface::NotifyHalStateChange(HalState hal_state) {
+  if (hal_state_ == hal_state) {
+    return;
+  }
+
+  hal_state_ = hal_state;
+
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+  for (const std::reference_wrapper<Subscriber>& subscriber : subscribers_) {
+    subscriber.get().NotifyHalStateChange(hal_state);
+  }
+}
+
+void TransportInterface::Subscribe(Subscriber& subscriber) {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+  const auto it = std::find_if(
+      subscribers_.begin(), subscribers_.end(),
+      [&](const std::reference_wrapper<Subscriber>& member_wrapper) {
+        return subscriber == member_wrapper.get();
+      });
+  if (it == subscribers_.end()) {
+    subscribers_.push_back(std::ref(subscriber));
+  }
+}
+
+void TransportInterface::Unsubscribe(Subscriber& subscriber) {
+  std::lock_guard<std::recursive_mutex> lock(transport_mutex_);
+  const auto it = std::find_if(
+      subscribers_.begin(), subscribers_.end(),
+      [&](const std::reference_wrapper<Subscriber>& member_wrapper) {
+        return subscriber == member_wrapper.get();
+      });
+  if (it != subscribers_.end()) {
+    subscribers_.erase(it);
+  }
+}
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/transport_interface_test.cc b/bluetooth/bluetooth_hal/transport/transport_interface_test.cc
new file mode 100644
index 0000000000..ad479f006c
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/transport_interface_test.cc
@@ -0,0 +1,513 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/transport/transport_interface.h"
+
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/config/config_constants.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/mock/mock_hal_config_loader.h"
+#include "bluetooth_hal/test/mock/mock_subscriber.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::testing::_;
+using ::testing::Mock;
+using ::testing::Return;
+using ::testing::ReturnRef;
+using ::testing::StrictMock;
+using ::testing::Test;
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::config::MockHalConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+
+namespace cfg_consts = ::bluetooth_hal::config::constants;
+
+TEST(TransportInterfaceTest, GetTransportTypeReturnDefaultType) {
+  EXPECT_EQ(TransportInterface::GetTransportType(), TransportType::kUartH4);
+}
+
+TEST(TransportInterfaceTest, HalStateNotChangeAndNotNotifySubscriber) {
+  MockSubscriber subscriber;
+  TransportInterface::Subscribe(subscriber);
+
+  EXPECT_CALL(subscriber, NotifyHalStateChange(_)).Times(0);
+  TransportInterface::NotifyHalStateChange(HalState::kInit);
+}
+
+TEST(TransportInterfaceTest, HalStateChangeAndNotifySubscriber) {
+  MockSubscriber subscriber;
+  TransportInterface::Subscribe(subscriber);
+
+  EXPECT_CALL(subscriber, NotifyHalStateChange(HalState::kRunning)).Times(1);
+  TransportInterface::NotifyHalStateChange(HalState::kRunning);
+}
+
+TEST(TransportInterfaceTest, UnsubscribeAndNoSubscriberToNotify) {
+  MockSubscriber subscriber;
+  TransportInterface::Subscribe(subscriber);
+  TransportInterface::Unsubscribe(subscriber);
+
+  EXPECT_CALL(subscriber, NotifyHalStateChange(_)).Times(0);
+  TransportInterface::NotifyHalStateChange(HalState::kFirmwareReady);
+}
+
+TEST(TransportInterfaceTest, MultipleSubscribersReceiveNotification) {
+  MockSubscriber subscriber1;
+  MockSubscriber subscriber2;
+  MockSubscriber subscriber3;
+
+  TransportInterface::Subscribe(subscriber1);
+  TransportInterface::Subscribe(subscriber2);
+  TransportInterface::Subscribe(subscriber3);
+
+  EXPECT_CALL(subscriber1, NotifyHalStateChange(HalState::kRunning)).Times(1);
+  EXPECT_CALL(subscriber2, NotifyHalStateChange(HalState::kRunning)).Times(1);
+  EXPECT_CALL(subscriber3, NotifyHalStateChange(HalState::kRunning)).Times(1);
+
+  TransportInterface::NotifyHalStateChange(HalState::kRunning);
+
+  Mock::VerifyAndClearExpectations(&subscriber1);
+  Mock::VerifyAndClearExpectations(&subscriber2);
+  Mock::VerifyAndClearExpectations(&subscriber3);
+
+  TransportInterface::Unsubscribe(subscriber1);
+  TransportInterface::Unsubscribe(subscriber2);
+  TransportInterface::Unsubscribe(subscriber3);
+}
+
+TEST(TransportInterfaceTest, UnsubscribingOneOfMultipleStillNotifiesOthers) {
+  MockSubscriber subscriber1;
+  MockSubscriber subscriber2;
+  MockSubscriber subscriber3;
+
+  TransportInterface::Subscribe(subscriber1);
+  TransportInterface::Subscribe(subscriber2);
+  TransportInterface::Subscribe(subscriber3);
+
+  TransportInterface::Unsubscribe(subscriber2);
+
+  EXPECT_CALL(subscriber1, NotifyHalStateChange(HalState::kFirmwareReady))
+      .Times(1);
+  EXPECT_CALL(subscriber2, NotifyHalStateChange(_)).Times(0);
+  EXPECT_CALL(subscriber3, NotifyHalStateChange(HalState::kFirmwareReady))
+      .Times(1);
+
+  TransportInterface::NotifyHalStateChange(HalState::kFirmwareReady);
+
+  Mock::VerifyAndClearExpectations(&subscriber1);
+  Mock::VerifyAndClearExpectations(&subscriber2);
+  Mock::VerifyAndClearExpectations(&subscriber3);
+
+  TransportInterface::Unsubscribe(subscriber1);
+  TransportInterface::Unsubscribe(subscriber3);
+}
+
+TEST(TransportInterfaceTest,
+     SubscribingSameSubscriberMultipleTimesNotifiesOnce) {
+  MockSubscriber subscriber;
+
+  TransportInterface::Subscribe(subscriber);
+  TransportInterface::Subscribe(subscriber);
+  TransportInterface::Subscribe(subscriber);
+
+  EXPECT_CALL(subscriber, NotifyHalStateChange(HalState::kBtChipReady))
+      .Times(1);
+
+  TransportInterface::NotifyHalStateChange(HalState::kBtChipReady);
+
+  Mock::VerifyAndClearExpectations(&subscriber);
+
+  TransportInterface::Unsubscribe(subscriber);
+}
+
+class MockTransportInterfaceCallback : public TransportInterfaceCallback {
+ public:
+  MOCK_METHOD(void, OnTransportClosed, (), (override));
+  MOCK_METHOD(void, OnTransportPacketReady, (const HalPacket&), (override));
+};
+
+class MockVendorTransport : public TransportInterface {
+ public:
+  explicit MockVendorTransport(TransportType type)
+      : instance_type_(type), active_(false), initialized_(false) {}
+
+  bool Initialize(TransportInterfaceCallback* cb) override {
+    callback_ = cb;
+    initialized_ = MockedInitialize(cb);
+    active_ = initialized_;
+    return initialized_;
+  }
+
+  void Cleanup() override {
+    active_ = false;
+    initialized_ = false;
+    MockedCleanup();
+  }
+
+  bool IsTransportActive() const override {
+    return initialized_ && active_ && MockedIsTransportActive();
+  }
+
+  bool Send(const ::bluetooth_hal::hci::HalPacket& packet) override {
+    return MockedSend(packet);
+  }
+
+  TransportType GetInstanceTransportType() const override {
+    return instance_type_;
+  }
+
+  MOCK_METHOD(bool, MockedInitialize, (TransportInterfaceCallback*));
+  MOCK_METHOD(void, MockedCleanup, ());
+  MOCK_METHOD(bool, MockedIsTransportActive, (), (const));
+  MOCK_METHOD(bool, MockedSend, (const ::bluetooth_hal::hci::HalPacket&));
+
+ private:
+  TransportType instance_type_;
+  bool active_;
+  bool initialized_;
+  TransportInterfaceCallback* callback_ = nullptr;
+};
+
+class VendorTransportTest : public Test {
+ protected:
+  void SetUp() override {
+    TransportInterface::UpdateTransportType(TransportType::kUartH4);
+    MockHalConfigLoader::SetMockLoader(&mock_hal_config_loader_);
+
+    ON_CALL(mock_hal_config_loader_, GetRfkillFolderPrefix())
+        .WillByDefault(ReturnRef(rfkill_folder_prefix_str_));
+  }
+
+  void TearDown() override {
+    TransportInterface::UnregisterVendorTransport(kVendorType1);
+    TransportInterface::UnregisterVendorTransport(kVendorType2);
+  }
+
+  static constexpr TransportType kVendorType1 = TransportType::kVendorStart;
+  static constexpr TransportType kVendorType2 =
+      static_cast<TransportType>(static_cast<int>(kVendorType1) + 1);
+
+  MockHalConfigLoader mock_hal_config_loader_;
+  MockTransportInterfaceCallback mock_callback_;
+  std::string rfkill_folder_prefix_str_{cfg_consts::kRfkillFolderPrefix};
+};
+
+TEST_F(VendorTransportTest, RegisterNullVendorTransportReturnsFalse) {
+  EXPECT_FALSE(TransportInterface::RegisterVendorTransport(nullptr));
+}
+
+TEST_F(VendorTransportTest,
+       RegisterVendorTransportWithInvalidTypeTooLowReturnsFalse) {
+  auto vendor_transport = std::make_unique<MockVendorTransport>(
+      static_cast<TransportType>(99));  // Below kVendorStart.
+  EXPECT_FALSE(
+      TransportInterface::RegisterVendorTransport(std::move(vendor_transport)));
+}
+
+TEST_F(VendorTransportTest,
+       RegisterVendorTransportWithInvalidTypeTooHighReturnsFalse) {
+  auto vendor_transport = std::make_unique<MockVendorTransport>(
+      static_cast<TransportType>(200));  // Above kVendorEnd.
+  EXPECT_FALSE(
+      TransportInterface::RegisterVendorTransport(std::move(vendor_transport)));
+}
+
+TEST_F(VendorTransportTest, RegisterVendorTransportSuccessfully) {
+  auto vendor_transport = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport_raw_ptr = vendor_transport.get();
+  EXPECT_TRUE(
+      TransportInterface::RegisterVendorTransport(std::move(vendor_transport)));
+
+  std::vector<TransportType> priorities = {kVendorType1,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport_raw_ptr);
+  TransportInterface::GetTransport().Cleanup();
+}
+
+TEST_F(VendorTransportTest,
+       RegisterDuplicateVendorTransportTypeOverwritesBeforeInit) {
+  auto vendor_transport1 = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport1_raw_ptr = vendor_transport1.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport1)));
+
+  auto vendor_transport2 = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport2_raw_ptr = vendor_transport2.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport2)));
+
+  EXPECT_TRUE(TransportInterface::UpdateTransportType(kVendorType1));
+
+  std::vector<TransportType> priorities = {kVendorType1,
+                                           TransportType::kUartH4};
+
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+
+  EXPECT_EQ(TransportInterface::GetTransportType(), kVendorType1);
+  EXPECT_NE(&TransportInterface::GetTransport(), vendor_transport1_raw_ptr);
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport2_raw_ptr);
+  TransportInterface::GetTransport().Cleanup();
+}
+
+TEST_F(VendorTransportTest,
+       RegisterDuplicateVendorTransportTypeCannotOverwritesAfterInit) {
+  auto vendor_transport1 = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport1_raw_ptr = vendor_transport1.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport1)));
+
+  EXPECT_TRUE(TransportInterface::UpdateTransportType(kVendorType1));
+
+  auto vendor_transport2 = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport2_raw_ptr = vendor_transport2.get();
+  EXPECT_FALSE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport2)));
+
+  std::vector<TransportType> priorities = {kVendorType1,
+                                           TransportType::kUartH4};
+
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+
+  EXPECT_EQ(TransportInterface::GetTransportType(), kVendorType1);
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport1_raw_ptr);
+  EXPECT_NE(&TransportInterface::GetTransport(), vendor_transport2_raw_ptr);
+  TransportInterface::GetTransport().Cleanup();
+}
+
+TEST_F(VendorTransportTest, GetTransportSelectsHighestPriorityVendor) {
+  auto vendor_transport1 = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto vendor_transport2 = std::make_unique<MockVendorTransport>(kVendorType2);
+  auto* vendor_transport1_raw_ptr = vendor_transport1.get();
+  auto* vendor_transport2_raw_ptr = vendor_transport2.get();
+
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport1)));
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport2)));
+
+  std::vector<TransportType> priorities = {kVendorType2, kVendorType1,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+
+  TransportInterface& transport = TransportInterface::GetTransport();
+  EXPECT_EQ(transport.GetInstanceTransportType(), kVendorType2);
+  EXPECT_NE(&TransportInterface::GetTransport(), vendor_transport1_raw_ptr);
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport2_raw_ptr);
+  TransportInterface::GetTransport().Cleanup();
+}
+
+TEST_F(VendorTransportTest, UnregisterNonExistentVendorTransportReturnsFalse) {
+  EXPECT_FALSE(TransportInterface::UnregisterVendorTransport(
+      static_cast<TransportType>(150)));
+}
+
+TEST_F(VendorTransportTest, UnregisterInvalidVendorTransportTypeReturnsFalse) {
+  EXPECT_FALSE(
+      TransportInterface::UnregisterVendorTransport(TransportType::kUartH4));
+  EXPECT_FALSE(TransportInterface::UnregisterVendorTransport(
+      static_cast<TransportType>(99)));  // Below kVendorStart.
+  EXPECT_FALSE(TransportInterface::UnregisterVendorTransport(
+      static_cast<TransportType>(200)));  // Above kVendorEnd.
+}
+
+TEST_F(VendorTransportTest, UnregisterActiveVendorTransportReturnsFalse) {
+  auto vendor_transport = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport_raw_ptr = vendor_transport.get();
+  EXPECT_TRUE(
+      TransportInterface::RegisterVendorTransport(std::move(vendor_transport)));
+
+  std::vector<TransportType> priorities = {kVendorType1,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+
+  // Make it active.
+  EXPECT_TRUE(TransportInterface::UpdateTransportType(kVendorType1));
+  EXPECT_CALL(*vendor_transport_raw_ptr, MockedInitialize(_))
+      .WillOnce(Return(true));
+  TransportInterface::GetTransport().Initialize(&mock_callback_);
+
+  EXPECT_FALSE(TransportInterface::UnregisterVendorTransport(kVendorType1));
+  // Verify it's still active.
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport_raw_ptr);
+
+  Mock::VerifyAndClearExpectations(&mock_hal_config_loader_);
+}
+
+TEST_F(VendorTransportTest, UnregisterInactiveVendorTransportSuccessfully) {
+  auto vendor_transport1 = std::make_unique<MockVendorTransport>(kVendorType1);
+  auto* vendor_transport1_raw_ptr = vendor_transport1.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport1)));
+
+  auto vendor_transport2 = std::make_unique<MockVendorTransport>(kVendorType2);
+  auto* vendor_transport2_raw_ptr = vendor_transport2.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport2)));
+
+  std::vector<TransportType> priorities_2_then_default = {
+      kVendorType2, TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities_2_then_default));
+
+  EXPECT_TRUE(TransportInterface::UpdateTransportType(kVendorType2));
+  EXPECT_CALL(*vendor_transport2_raw_ptr, MockedInitialize(_))
+      .WillOnce(Return(true));
+  TransportInterface::GetTransport().Initialize(&mock_callback_);
+
+  // Unregister inactive vendor transport 1.
+  EXPECT_CALL(*vendor_transport1_raw_ptr, MockedCleanup()).Times(1);
+  EXPECT_TRUE(TransportInterface::UnregisterVendorTransport(kVendorType1));
+
+  Mock::VerifyAndClearExpectations(&mock_hal_config_loader_);
+
+  // Verify vendor transport 1 is gone.
+  std::vector<TransportType> priorities_1_then_default = {
+      kVendorType1, TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities_1_then_default));
+  // Since kVendorStart is unregistered, GetTransport should now return UartH4.
+  EXPECT_EQ(TransportInterface::GetTransport().GetInstanceTransportType(),
+            TransportType::kUartH4);
+
+  Mock::VerifyAndClearExpectations(&mock_hal_config_loader_);
+
+  // Verify vendor transport 2 is still active (by switching back to it if
+  // necessary, or checking current type).
+  EXPECT_TRUE(TransportInterface::UpdateTransportType(kVendorType2));
+  std::vector<TransportType> priorities_2 = {kVendorType2};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities_2));
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport2_raw_ptr);
+
+  Mock::VerifyAndClearExpectations(&mock_hal_config_loader_);
+}
+
+TEST_F(VendorTransportTest, UnregisterAndThenTryToUseReturnsFallback) {
+  auto vendor_transport = std::make_unique<MockVendorTransport>(kVendorType1);
+  EXPECT_TRUE(
+      TransportInterface::RegisterVendorTransport(std::move(vendor_transport)));
+
+  EXPECT_TRUE(TransportInterface::UnregisterVendorTransport(kVendorType1));
+
+  std::vector<TransportType> priorities = {kVendorType1,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+  EXPECT_EQ(TransportInterface::GetTransport().GetInstanceTransportType(),
+            TransportType::kUartH4);
+
+  Mock::VerifyAndClearExpectations(&mock_hal_config_loader_);
+}
+
+TEST_F(VendorTransportTest, SwitchToNonExistentVendorFailsAndPreservesCurrent) {
+  std::vector<TransportType> priorities = {kVendorType1, kVendorType2,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+
+  // Register kVendorType2 and switch to it.
+  auto vendor_transport2 = std::make_unique<MockVendorTransport>(kVendorType2);
+  MockVendorTransport* vendor_transport2_raw_ptr = vendor_transport2.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport2)));
+  ASSERT_EQ(TransportInterface::GetTransportType(), TransportType::kUartH4);
+
+  // Vendor transport 2 should not cleanup.
+  EXPECT_CALL(*vendor_transport2_raw_ptr, MockedCleanup()).Times(0);
+  ASSERT_EQ(&TransportInterface::GetTransport(), vendor_transport2_raw_ptr);
+  ASSERT_EQ(TransportInterface::GetTransportType(), kVendorType2);
+
+  Mock::VerifyAndClearExpectations(vendor_transport2_raw_ptr);
+
+  // Cleanup and moved back to the map.
+  EXPECT_CALL(*vendor_transport2_raw_ptr, MockedCleanup()).Times(1);
+  TransportInterface::UpdateTransportType(TransportType::kUartH4);
+
+  Mock::VerifyAndClearExpectations(vendor_transport2_raw_ptr);
+  Mock::VerifyAndClearExpectations(&mock_hal_config_loader_);
+}
+
+TEST_F(VendorTransportTest, RegisterTransportAfterInitSuccessfully) {
+  auto vendor_transport2 = std::make_unique<MockVendorTransport>(kVendorType2);
+  MockVendorTransport* vendor_transport2_raw_ptr = vendor_transport2.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport2)));
+
+  std::vector<TransportType> priorities = {kVendorType1, kVendorType2,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+
+  ASSERT_EQ(&TransportInterface::GetTransport(), vendor_transport2_raw_ptr);
+  EXPECT_EQ(TransportInterface::GetTransportType(), kVendorType2);
+
+  auto vendor_transport1 = std::make_unique<MockVendorTransport>(kVendorType1);
+  MockVendorTransport* vendor_transport1_raw_ptr = vendor_transport1.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport1)));
+
+  // Cleanup and moved back to the map.
+  EXPECT_CALL(*vendor_transport2_raw_ptr, MockedCleanup()).Times(1);
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport1_raw_ptr);
+  EXPECT_EQ(TransportInterface::GetTransportType(), kVendorType1);
+
+  Mock::VerifyAndClearExpectations(vendor_transport2_raw_ptr);
+
+  // Cleanup and moved back to the map.
+  EXPECT_CALL(*vendor_transport1_raw_ptr, MockedCleanup()).Times(1);
+  TransportInterface::UpdateTransportType(TransportType::kUartH4);
+
+  Mock::VerifyAndClearExpectations(vendor_transport1_raw_ptr);
+}
+
+TEST_F(VendorTransportTest, GetVendorTransportReturnSameInstance) {
+  std::vector<TransportType> priorities = {kVendorType1,
+                                           TransportType::kUartH4};
+  EXPECT_CALL(mock_hal_config_loader_, GetTransportTypePriority())
+      .WillRepeatedly(ReturnRef(priorities));
+  EXPECT_CALL(mock_hal_config_loader_, GetRfkillFolderPrefix())
+      .WillRepeatedly(ReturnRef(rfkill_folder_prefix_str_));
+
+  auto vendor_transport1 = std::make_unique<MockVendorTransport>(kVendorType1);
+  MockVendorTransport* vendor_transport1_raw_ptr = vendor_transport1.get();
+  EXPECT_TRUE(TransportInterface::RegisterVendorTransport(
+      std::move(vendor_transport1)));
+
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport1_raw_ptr);
+  EXPECT_EQ(TransportInterface::GetTransportType(), kVendorType1);
+
+  EXPECT_EQ(&TransportInterface::GetTransport(), vendor_transport1_raw_ptr);
+  EXPECT_EQ(TransportInterface::GetTransportType(), kVendorType1);
+}
+
+}  // namespace
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/uart_h4/data_processor.cc b/bluetooth/bluetooth_hal/transport/uart_h4/data_processor.cc
new file mode 100644
index 0000000000..876b595aa8
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/uart_h4/data_processor.cc
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.data_processor"
+
+#include "bluetooth_hal/transport/uart_h4/data_processor.h"
+
+#include <errno.h>
+#include <sys/uio.h>
+#include <unistd.h>
+
+#include <cstddef>
+#include <cstdint>
+#include <cstring>
+#include <span>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/fd_watcher.h"
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+using ::bluetooth_hal::debug::DebugCentral;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::FdWatcher;
+using ::bluetooth_hal::util::SystemCallWrapper;
+
+DataProcessor::~DataProcessor() { fd_watcher_.StopWatching(); }
+
+void DataProcessor::StartProcessing() {
+  fd_watcher_.StartWatching(fd_, std::bind_front(&DataProcessor::Recv, this));
+}
+
+size_t DataProcessor::Send(std::span<const uint8_t> packet) {
+  if (packet.empty()) {
+    return 0;
+  }
+
+  iovec iov;
+  iov.iov_base = const_cast<uint8_t*>(packet.data());
+  iov.iov_len = packet.size_bytes();
+
+  const size_t total_bytes = packet.size_bytes();
+  size_t bytes_written = 0;
+  size_t remaining_bytes = total_bytes;
+
+  while (remaining_bytes > 0) {
+    ssize_t ret = TEMP_FAILURE_RETRY(
+        SystemCallWrapper::GetWrapper().Writev(fd_, &iov, 1));
+    if (ret == -1) {
+      if (errno == EAGAIN) {
+        continue;
+      }
+      ANCHOR_LOG_ERROR(AnchorType::H4_TX_ERR)
+          << __func__ << ": Error writing to UART (" << strerror(errno) << ").";
+      break;
+    } else if (ret == 0) {
+      ANCHOR_LOG_ERROR(AnchorType::H4_TX_ERR)
+          << __func__ << ": Zero bytes written.";
+      break;
+    } else if (static_cast<size_t>(ret) == remaining_bytes) {
+      bytes_written += ret;
+      break;
+    }
+
+    bytes_written += ret;
+    remaining_bytes -= ret;
+    ANCHOR_LOG_WARNING(AnchorType::H4_TX_ERR)
+        << __func__ << ": " << bytes_written << " bytes written, "
+        << remaining_bytes << " bytes remaining.";
+
+    // Adjust iov to skip the written data.
+    iov.iov_base = static_cast<uint8_t*>(iov.iov_base) + ret;
+    iov.iov_len -= ret;
+  }
+
+  return bytes_written;
+}
+
+void DataProcessor::Recv(int fd) {
+  // The maximum length for ACL is 2 bytes, so the buffer size is set to 64 KB.
+  constexpr size_t max_len = 64 * 1024;
+  uint8_t buffer[max_len] = {0};
+
+  const ssize_t bytes_read = TEMP_FAILURE_RETRY(
+      SystemCallWrapper::GetWrapper().Read(fd, buffer, max_len));
+  if (bytes_read == 0) {
+    // This is only expected if the UART got closed when shutting down.
+    ANCHOR_LOG_WARNING(AnchorType::H4_RX_ERR)
+        << __func__ << ": Unexpected EOF reading the packet type!";
+    return;
+  } else if (bytes_read < 0) {
+    LOG(FATAL) << __func__ << ": Read packet type error: " << strerror(errno)
+               << ".";
+  }
+
+  ParseHciPacket(std::span<const uint8_t>(buffer, bytes_read));
+}
+
+void DataProcessor::ParseHciPacket(std::span<const uint8_t> buffer) {
+  while (!buffer.empty()) {
+    const size_t bytes_handled = hci_packetizer_.ProcessData(buffer);
+
+    if (!bytes_handled) {
+      LOG(FATAL) << __func__ << ": Cannot process data from hci packetizer!";
+    }
+
+    buffer = buffer.subspan(bytes_handled);
+  }
+}
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/uart_h4/data_processor_test.cc b/bluetooth/bluetooth_hal/transport/uart_h4/data_processor_test.cc
new file mode 100644
index 0000000000..13e1abd931
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/uart_h4/data_processor_test.cc
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/transport/uart_h4/data_processor.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/common/test_helper.h"
+#include "bluetooth_hal/test/mock/mock_system_call_wrapper.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::testing::_;
+using ::testing::DoAll;
+using ::testing::Invoke;
+using ::testing::Return;
+using ::testing::Test;
+using ::testing::Values;
+using ::testing::WithParamInterface;
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HalPacketCallback;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::MatcherFactory;
+using ::bluetooth_hal::util::MockPacketHandler;
+using ::bluetooth_hal::util::MockSystemCallWrapper;
+
+class DataProcessorTest : public Test {
+ protected:
+  void SetUp() override {
+    MockSystemCallWrapper::SetMockWrapper(&mock_system_call_wrapper_);
+    data_processor_ = std::make_unique<DataProcessor>(
+        test_fd_, std::bind_front(&MockPacketHandler::HalPacketCallback,
+                                  &mock_packet_handler_));
+  }
+
+  void TearDown() override {}
+
+  std::unique_ptr<DataProcessor> data_processor_;
+  MockSystemCallWrapper mock_system_call_wrapper_;
+  MockPacketHandler mock_packet_handler_;
+  int test_fd_ = 1;
+};
+
+TEST_F(DataProcessorTest, SendEmptyPacket) {
+  const std::vector<uint8_t> empty_packet;
+  EXPECT_EQ(data_processor_->Send(empty_packet), 0);
+}
+
+TEST_F(DataProcessorTest, SendPacketAtOnceReturnSuccess) {
+  const std::vector<uint8_t> packet = {0x00, 0x01, 0x02, 0x03};
+  EXPECT_CALL(mock_system_call_wrapper_, Writev(test_fd_, _, _))
+      .WillOnce(Return(packet.size()));
+
+  EXPECT_EQ(data_processor_->Send(packet), packet.size());
+}
+
+TEST_F(DataProcessorTest, SendPacketReturnFailWithSystemFailure) {
+  const std::vector<uint8_t> packet = {0x00, 0x01, 0x02, 0x03};
+  EXPECT_CALL(mock_system_call_wrapper_, Writev(test_fd_, _, _))
+      .WillOnce(Return(-1));
+
+  EXPECT_EQ(data_processor_->Send(packet), 0);
+}
+
+TEST_F(DataProcessorTest, SendPacketReturnFailWithEmptyWritten) {
+  const std::vector<uint8_t> packet = {0x00, 0x01, 0x02, 0x03};
+  EXPECT_CALL(mock_system_call_wrapper_, Writev(test_fd_, _, _))
+      .WillOnce(Return(0));
+
+  EXPECT_EQ(data_processor_->Send(packet), 0);
+}
+
+TEST_F(DataProcessorTest, SendPacketInMultiplePiecesReturnSuccess) {
+  const std::vector<uint8_t> packet = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
+  EXPECT_CALL(mock_system_call_wrapper_, Writev(test_fd_, _, _))
+      .WillOnce(Return(2))
+      .WillOnce(Return(2))
+      .WillOnce(Return(2));
+
+  EXPECT_EQ(data_processor_->Send(packet), packet.size());
+}
+
+TEST_F(DataProcessorTest, ReadDataWithSystemFailureNoCallbackInvoked) {
+  ON_CALL(mock_system_call_wrapper_, Read(test_fd_, _, _))
+      .WillByDefault(Return(-1));
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(0);
+
+  EXPECT_DEATH(data_processor_->Recv(test_fd_), "");
+}
+
+TEST_F(DataProcessorTest,
+       ReadDataReturnFailWithConnectionClosedNoCallbackInvoked) {
+  EXPECT_CALL(mock_system_call_wrapper_, Read(_, _, _)).WillOnce(Return(0));
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(0);
+
+  data_processor_->Recv(test_fd_);
+}
+
+TEST_F(DataProcessorTest, ReadInavlidHciPacketNoCallbackInvoked) {
+  std::vector<uint8_t> packet = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
+  ON_CALL(mock_system_call_wrapper_, Read(test_fd_, _, _))
+      .WillByDefault(DoAll(Invoke([&]([[maybe_unused]] int fd, void* buffer,
+                                      [[maybe_unused]] size_t count) {
+                             buffer = static_cast<void*>(packet.data());
+                           }),
+                           Return(6)));
+  EXPECT_CALL(mock_packet_handler_, HalPacketCallback(_)).Times(0);
+
+  EXPECT_DEATH(data_processor_->Recv(test_fd_), "");
+}
+
+struct HciPacketTestParam {
+  HciPacketType type;
+  std::vector<uint8_t> preamble;
+  std::vector<uint8_t> payload;
+};
+
+class HciPacketTest : public DataProcessorTest,
+                      public WithParamInterface<HciPacketTestParam> {};
+
+TEST_P(HciPacketTest, ReadValidHciPacketCallbackInvoked) {
+  const auto& [type, preamble, payload] = GetParam();
+  std::vector<uint8_t> test_buffer;
+  test_buffer.push_back(static_cast<uint8_t>(type));
+  test_buffer.insert(test_buffer.end(), preamble.begin(), preamble.end());
+  test_buffer.insert(test_buffer.end(), payload.begin(), payload.end());
+  EXPECT_CALL(mock_system_call_wrapper_, Read(test_fd_, _, _))
+      .WillOnce(DoAll(Invoke([&]([[maybe_unused]] int fd, void* buffer,
+                                 [[maybe_unused]] size_t count) {
+                        uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
+                        memcpy(buffer, test_buffer.data(), test_buffer.size());
+                      }),
+                      Return(test_buffer.size())));
+  HalPacket hal_packet(test_buffer);
+  EXPECT_CALL(
+      mock_packet_handler_,
+      HalPacketCallback(MatcherFactory::CreateHalPacketMatcher(hal_packet)))
+      .Times(1);
+
+  data_processor_->Recv(test_fd_);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    HandleValidPacketFromFd, HciPacketTest,
+    Values(
+        HciPacketTestParam{
+            .type = HciPacketType::kAclData,
+            .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03, 0x00},
+            .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{.type = HciPacketType::kScoData,
+                           .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03},
+                           .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{.type = HciPacketType::kEvent,
+                           .preamble = std::vector<uint8_t>{0x00, 0x03},
+                           .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{
+            .type = HciPacketType::kIsoData,
+            .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03, 0x00},
+            .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{
+            .type = HciPacketType::kThreadData,
+            .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03, 0x00},
+            .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}}));
+
+}  // namespace
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/uart_h4/hci_packetizer.cc b/bluetooth/bluetooth_hal/transport/uart_h4/hci_packetizer.cc
new file mode 100644
index 0000000000..e6a792b227
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/uart_h4/hci_packetizer.cc
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.hci_packetizer"
+
+#include "bluetooth_hal/transport/uart_h4/hci_packetizer.h"
+
+#include <algorithm>
+#include <cstddef>
+#include <cstdint>
+#include <functional>
+#include <ios>
+#include <span>
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "bluetooth_hal/hal_types.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::bluetooth_hal::hci::HciConstants;
+using ::bluetooth_hal::hci::HciPacketType;
+
+constexpr size_t kLogByteLimit = 6;
+
+std::string GenerateUnimplementedPacketLog(HciPacketType packet_type,
+                                           std::span<const uint8_t> buffer) {
+  std::ostringstream oss;
+  oss << "Host Received Unimplemented Packet Type: " << std::hex
+      << std::uppercase << static_cast<uint8_t>(packet_type)
+      << ", bytes_read: " << buffer.size() << ", packet:";
+
+  const unsigned long max_bytes_to_print =
+      std::min(buffer.size(), kLogByteLimit);
+  for (size_t i = 0; i < max_bytes_to_print; ++i) {
+    oss << " " << std::hex << std::uppercase << static_cast<int>(buffer[i]);
+  }
+  return oss.str();
+}
+
+bool IsValidHciPacketType(HciPacketType hci_packet_type) {
+  switch (hci_packet_type) {
+    case HciPacketType::kCommand:
+    case HciPacketType::kAclData:
+    case HciPacketType::kScoData:
+    case HciPacketType::kIsoData:
+    case HciPacketType::kEvent:
+    case HciPacketType::kThreadData:
+      return true;
+    default:
+      return false;
+  }
+}
+
+size_t GetPayloadLength(std::span<const uint8_t> packet) {
+  if (packet.empty()) {
+    return 0;
+  }
+
+  HciPacketType packet_type = static_cast<HciPacketType>(packet[0]);
+  if (packet.size() < 1 + HciConstants::GetPreambleSize(packet_type)) {
+    return 0;
+  }
+
+  const size_t offset = HciConstants::GetPacketLengthOffset(packet_type);
+
+  switch (packet_type) {
+    case HciPacketType::kAclData:
+    case HciPacketType::kThreadData:
+      return (static_cast<size_t>(packet[offset + 1]) << 8) | packet[offset];
+    case HciPacketType::kIsoData:
+      return ((static_cast<size_t>(packet[offset + 1]) & 0x3F) << 8) |
+             packet[offset];
+    default:
+      return packet[offset];
+  }
+}
+
+}  // namespace
+
+size_t HciPacketizer::ProcessData(std::span<const uint8_t> data) {
+  if (!data.size()) {
+    return 0;
+  }
+
+  size_t cur_bytes_read = 0;
+  const size_t len = data.size();
+
+  switch (state_) {
+    case State::kHciHeader: {
+      const auto hci_packet_type = static_cast<HciPacketType>(data[0]);
+      packet_.clear();
+
+      if (!IsValidHciPacketType(hci_packet_type)) {
+        const std::string err_msg =
+            GenerateUnimplementedPacketLog(hci_packet_type, data);
+      } else {
+        packet_.push_back(data[0]);
+
+        state_ = State::kHciPreamble;
+        cur_bytes_read = 1;
+      }
+      break;
+    }
+
+    case State::kHciPreamble: {
+      const size_t preamble_size =
+          HciConstants::GetPreambleSize(packet_.GetType());
+      const size_t to_read = std::min(len, preamble_size - total_bytes_read_);
+
+      packet_.insert(packet_.end(), data.begin(), data.begin() + to_read);
+
+      total_bytes_read_ += to_read;
+      cur_bytes_read = to_read;
+
+      if (total_bytes_read_ == preamble_size) {
+        state_ = State::kHciPayload;
+        payload_length_ = GetPayloadLength(std::span(packet_));
+        total_bytes_read_ = 0;
+      }
+      break;
+    }
+
+    case State::kHciPayload: {
+      const size_t to_read = std::min(len, payload_length_ - total_bytes_read_);
+
+      packet_.insert(packet_.end(), data.begin(), data.begin() + to_read);
+
+      total_bytes_read_ += to_read;
+      cur_bytes_read = to_read;
+
+      if (total_bytes_read_ == payload_length_) {
+        on_packet_ready_(packet_);
+
+        state_ = State::kHciHeader;
+        payload_length_ = 0;
+        total_bytes_read_ = 0;
+      }
+      break;
+    }
+  }
+
+  return cur_bytes_read;
+}
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/uart_h4/hci_packetizer_test.cc b/bluetooth/bluetooth_hal/transport/uart_h4/hci_packetizer_test.cc
new file mode 100644
index 0000000000..9470471329
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/uart_h4/hci_packetizer_test.cc
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/transport/uart_h4/hci_packetizer.h"
+
+#include <algorithm>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/common/test_helper.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::testing::Test;
+using ::testing::Values;
+using ::testing::WithParamInterface;
+
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HalPacketCallback;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::MatcherFactory;
+using ::bluetooth_hal::util::MockPacketHandler;
+
+struct HciPacketTestParam {
+  HciPacketType packet_type;
+  std::vector<uint8_t> preamble;
+  std::vector<uint8_t> payload;
+};
+
+std::vector<uint8_t> GenerateStreamWithHciPacket(
+    const HciPacketTestParam& param) {
+  const auto& [packet_type, preamble, payload] = param;
+
+  std::vector<uint8_t> data_stream;
+  data_stream.reserve(1 + preamble.size() + payload.size());
+
+  data_stream.push_back(static_cast<uint8_t>(packet_type));
+  data_stream.insert(data_stream.end(), preamble.begin(), preamble.end());
+  data_stream.insert(data_stream.end(), payload.begin(), payload.end());
+
+  return data_stream;
+}
+
+class HciPacketizerTest : public Test {
+ protected:
+  void SetUp() override {
+    test_hci_packetizer_ = std::make_unique<HciPacketizer>(std::bind_front(
+        &MockPacketHandler::HalPacketCallback, &mock_packet_handler_));
+  }
+
+  void TearDown() override {}
+
+  void ProcessDataStream(std::span<const uint8_t> data_stream,
+                         size_t chunk_size = 0) {
+    const size_t total_size = data_stream.size();
+
+    // Does not split packet into several small chunks.
+    if (!chunk_size) {
+      chunk_size = total_size;
+    }
+
+    while (data_stream.size()) {
+      size_t cur_chunk_size = std::min(data_stream.size(), chunk_size);
+      const size_t cur_bytes_read = test_hci_packetizer_->ProcessData(
+          data_stream.subspan(0, cur_chunk_size));
+      if (!cur_bytes_read) {
+        break;
+      }
+      data_stream = data_stream.subspan(cur_bytes_read);
+    }
+  }
+
+  std::unique_ptr<HciPacketizer> test_hci_packetizer_;
+  MockPacketHandler mock_packet_handler_;
+};
+
+class LargePacketTest : public HciPacketizerTest,
+                        public WithParamInterface<int> {};
+
+TEST_P(LargePacketTest, HandleLargeSizePacket) {
+  // Payload length is 243.
+  const int chunk_size = GetParam();
+  HciPacketTestParam test_param = {.packet_type = HciPacketType::kAclData,
+                                   .preamble = {0x00, 0x00, 0xF3, 0x00},
+                                   std::vector<uint8_t>(243)};
+
+  const std::vector<uint8_t> data_stream =
+      GenerateStreamWithHciPacket(test_param);
+
+  EXPECT_CALL(mock_packet_handler_,
+              HalPacketCallback(MatcherFactory::CreateHalPacketMatcher(
+                  HalPacket(data_stream))))
+      .Times(1);
+
+  ProcessDataStream(std::span(data_stream), chunk_size);
+}
+
+INSTANTIATE_TEST_SUITE_P(ChunkSizeTest, LargePacketTest,
+                         Values(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
+
+class HciPacketizerParameterizedTest
+    : public HciPacketizerTest,
+      public WithParamInterface<HciPacketTestParam> {};
+
+TEST_P(HciPacketizerParameterizedTest, HandlePacket) {
+  const std::vector<uint8_t> data_stream =
+      GenerateStreamWithHciPacket(GetParam());
+
+  EXPECT_CALL(mock_packet_handler_,
+              HalPacketCallback(MatcherFactory::CreateHalPacketMatcher(
+                  HalPacket(data_stream))))
+      .Times(1);
+
+  ProcessDataStream(std::span(data_stream));
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    HciPacketTests, HciPacketizerParameterizedTest,
+    Values(
+        HciPacketTestParam{.packet_type = HciPacketType::kCommand,
+                           .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03},
+                           .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{
+            .packet_type = HciPacketType::kAclData,
+            .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03, 0x00},
+            .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{.packet_type = HciPacketType::kScoData,
+                           .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03},
+                           .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{.packet_type = HciPacketType::kEvent,
+                           .preamble = std::vector<uint8_t>{0x00, 0x03},
+                           .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{
+            .packet_type = HciPacketType::kIsoData,
+            .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03, 0x00},
+            .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}},
+        HciPacketTestParam{
+            .packet_type = HciPacketType::kThreadData,
+            .preamble = std::vector<uint8_t>{0x00, 0x00, 0x03, 0x00},
+            .payload = std::vector<uint8_t>{0x01, 0x02, 0x03}}));
+
+}  // namespace
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/uart_h4/transport_uart_h4.cc b/bluetooth/bluetooth_hal/transport/uart_h4/transport_uart_h4.cc
new file mode 100644
index 0000000000..7c6ba9610f
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/uart_h4/transport_uart_h4.cc
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.transport.uart_h4"
+
+#include "bluetooth_hal/transport/uart_h4/transport_uart_h4.h"
+
+#include <memory>
+#include <mutex>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/config/hal_config_loader.h"
+#include "bluetooth_hal/hal_packet.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/transport/device_control/power_manager.h"
+#include "bluetooth_hal/transport/device_control/uart_manager.h"
+#include "bluetooth_hal/transport/transport_interface.h"
+#include "bluetooth_hal/transport/uart_h4/data_processor.h"
+#include "bluetooth_hal/util/android_base_wrapper.h"
+#include "bluetooth_hal/util/power/wakelock.h"
+#include "bluetooth_hal/util/timer_manager.h"
+
+namespace bluetooth_hal {
+namespace transport {
+
+using ::bluetooth_hal::HalState;
+using ::bluetooth_hal::Property;
+using ::bluetooth_hal::config::HalConfigLoader;
+using ::bluetooth_hal::hci::HalPacket;
+using ::bluetooth_hal::hci::HalPacketCallback;
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::uart::BaudRate;
+using ::bluetooth_hal::util::AndroidBaseWrapper;
+using ::bluetooth_hal::util::Timer;
+using ::bluetooth_hal::util::power::Wakelock;
+using ::bluetooth_hal::util::power::WakeSource;
+
+TransportUartH4::~TransportUartH4() {
+  if (transport_interface_callback_) {
+    transport_interface_callback_->OnTransportClosed();
+  }
+}
+
+TransportType TransportUartH4::GetInstanceTransportType() const {
+  return TransportType::kUartH4;
+}
+
+bool TransportUartH4::Initialize(
+    TransportInterfaceCallback* transport_interface_callback) {
+  TransportInterface::Subscribe(*this);
+
+  transport_interface_callback_ = transport_interface_callback;
+
+  // Power on the underlying device.
+  PowerManager::PowerControl(false);
+  if (!PowerManager::PowerControl(true)) {
+    LOG(ERROR) << __func__ << ": Cannot power on the device.";
+    Cleanup();
+    return false;
+  }
+
+  // Initialize data channel to the device.
+  if (!InitializeDataPath()) {
+    LOG(ERROR) << __func__ << ": Cannot initialize the data path.";
+    Cleanup();
+    return false;
+  }
+
+  PowerManager::ConfigRxWakelockTime(
+      HalConfigLoader::GetLoader().GetKernelRxWakelockTimeMilliseconds());
+
+  if (!IsTransportActive()) {
+    LOG(ERROR) << __func__ << ": Transport is not active.";
+    Cleanup();
+    return false;
+  }
+
+  AndroidBaseWrapper::GetWrapper().SetProperty(Property::kLastUartPath, "apc");
+
+  data_processor_ = std::make_unique<DataProcessor>(
+      uart_fd_.get(), [&](const HalPacket& packet) {
+        transport_interface_callback_->OnTransportPacketReady(packet);
+      });
+  data_processor_->StartProcessing();
+
+  LOG(INFO) << __func__ << ": Initialization is completed.";
+  return true;
+}
+
+void TransportUartH4::Cleanup() {
+  TransportInterface::Unsubscribe(*this);
+  data_processor_.reset();
+  TerminateDataPath();
+  TeardownLowPowerMode();
+  PowerManager::PowerControl(false);
+  if (transport_interface_callback_) {
+    transport_interface_callback_->OnTransportClosed();
+  }
+}
+
+bool TransportUartH4::IsTransportActive() const { return uart_fd_.ok(); }
+
+bool TransportUartH4::Send(const HalPacket& packet) {
+  // TODO: b/401131063 - Handle LPM here once the timer util is ready.
+  if (!data_processor_) {
+    return false;
+  }
+  ResumeFromLowPowerMode();
+  return data_processor_->Send(std::span(packet)) == packet.size();
+}
+
+bool TransportUartH4::ResumeFromLowPowerMode() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (!HalConfigLoader::GetLoader().IsLowPowerModeSupported() ||
+      !IsLowPowerModeSetupCompleted() || is_lpm_resumed_) {
+    return true;
+  }
+  if (IsTransportWakelockEnabled()) {
+    Wakelock::GetWakelock().Acquire(WakeSource::kTransport);
+  }
+  low_power_timer_.Schedule(
+      std::bind_front(&TransportUartH4::SuspendToLowPowerMode, this),
+      std::chrono::milliseconds{kLpmTimeoutMs});
+  if (!PowerManager::ResumeFromLowPowerMode()) {
+    return false;
+  }
+  is_lpm_resumed_ = true;
+  return true;
+}
+
+bool TransportUartH4::SuspendToLowPowerMode() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (!HalConfigLoader::GetLoader().IsLowPowerModeSupported() ||
+      !IsLowPowerModeSetupCompleted() || !is_lpm_resumed_) {
+    return true;
+  }
+  if (IsTransportWakelockEnabled()) {
+    Wakelock::GetWakelock().Release(WakeSource::kTransport);
+  }
+  if (!PowerManager::SuspendToLowPowerMode()) {
+    return false;
+  }
+  is_lpm_resumed_ = false;
+  return true;
+}
+
+bool TransportUartH4::IsLowPowerModeSetupCompleted() const {
+  return PowerManager::IsLowPowerModeSetupCompleted();
+}
+
+bool TransportUartH4::InitializeDataPath() { return UartManager::Open(); };
+
+void TransportUartH4::TerminateDataPath() { UartManager::Close(); };
+
+bool TransportUartH4::SetupLowPowerMode() {
+  if (!HalConfigLoader::GetLoader().IsLowPowerModeSupported()) {
+    return true;
+  }
+  return PowerManager::SetupLowPowerMode();
+};
+
+void TransportUartH4::TeardownLowPowerMode() {
+  if (!HalConfigLoader::GetLoader().IsLowPowerModeSupported()) {
+    return;
+  }
+  low_power_timer_.Cancel();
+  SuspendToLowPowerMode();
+  PowerManager::TeardownLowPowerMode();
+};
+
+void TransportUartH4::NotifyHalStateChange(HalState hal_state) {
+  switch (hal_state) {
+    case HalState::kFirmwareDownloading:
+      UartManager::UpdateBaudRate(
+          HalConfigLoader::GetLoader().GetUartBaudRate(TransportType::kUartH4));
+      break;
+    case HalState::kFirmwareDownloadCompleted:
+      UartManager::UpdateBaudRate(BaudRate::kRate115200);
+      break;
+    case HalState::kFirmwareReady:
+      UartManager::UpdateBaudRate(
+          HalConfigLoader::GetLoader().GetUartBaudRate(TransportType::kUartH4));
+      SetupLowPowerMode();
+      ResumeFromLowPowerMode();
+      break;
+    default:
+      break;
+  }
+}
+
+void TransportUartH4::EnableTransportWakelock(bool enable) {
+  transport_wakelock_enabled_ = enable;
+}
+
+bool TransportUartH4::IsTransportWakelockEnabled() {
+  return transport_wakelock_enabled_;
+}
+
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/transport/uart_h4/transport_uart_h4_test.cc b/bluetooth/bluetooth_hal/transport/uart_h4/transport_uart_h4_test.cc
new file mode 100644
index 0000000000..9318cbf0b0
--- /dev/null
+++ b/bluetooth/bluetooth_hal/transport/uart_h4/transport_uart_h4_test.cc
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/transport/uart_h4/transport_uart_h4.h"
+
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/test/mock/mock_android_base_wrapper.h"
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace transport {
+namespace {
+
+using ::testing::Test;
+
+using ::bluetooth_hal::hci::HciPacketType;
+using ::bluetooth_hal::util::MockAndroidBaseWrapper;
+
+TEST(TransportUartH4Test, GetTransportReturnSameInstance) {
+  MockAndroidBaseWrapper mock_android_base_wrapper;
+  MockAndroidBaseWrapper::SetMockWrapper(&mock_android_base_wrapper);
+  EXPECT_EQ(&TransportUartH4::GetTransport(), &TransportUartH4::GetTransport());
+}
+
+}  // namespace
+}  // namespace transport
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/android_base_wrapper.cc b/bluetooth/bluetooth_hal/util/android_base_wrapper.cc
new file mode 100644
index 0000000000..3afa29b4c6
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/android_base_wrapper.cc
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/util/android_base_wrapper.h"
+
+#include <string>
+
+#include "android-base/parseint.h"
+#include "android-base/properties.h"
+
+namespace bluetooth_hal {
+namespace util {
+
+class AndroidBaseWrapperImpl : public AndroidBaseWrapper {
+ public:
+  std::string GetProperty(const std::string& key,
+                          const std::string& default_value) override {
+    return ::android::base::GetProperty(key, default_value);
+  }
+
+  bool GetBoolProperty(const std::string& key, bool default_value) override {
+    return ::android::base::GetBoolProperty(key, default_value);
+  }
+
+  bool SetProperty(const std::string& key, const std::string& value) override {
+    return ::android::base::SetProperty(key, value);
+  }
+
+  bool ParseUint(const std::string& s, uint8_t* out, uint8_t max) override {
+    return ::android::base::ParseUint<uint8_t>(s, out, max);
+  }
+};
+
+AndroidBaseWrapper& AndroidBaseWrapper::GetWrapper() {
+  static AndroidBaseWrapperImpl wrapper;
+  return wrapper;
+}
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/fd_watcher.cc b/bluetooth/bluetooth_hal/util/fd_watcher.cc
new file mode 100644
index 0000000000..326b53e1c5
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/fd_watcher.cc
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.fd_watcher"
+
+#include "bluetooth_hal/util/fd_watcher.h"
+
+#include <fcntl.h>
+#include <sched.h>
+#include <sys/select.h>
+#include <unistd.h>
+
+#include <algorithm>
+#include <atomic>
+#include <cerrno>
+#include <cstdint>
+#include <cstring>
+#include <functional>
+#include <mutex>
+#include <thread>
+#include <unordered_map>
+#include <utility>
+
+#include "android-base/logging.h"
+#include "android-base/unique_fd.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace {
+
+using ::android::base::Pipe;
+using ::android::base::unique_fd;
+
+constexpr int kBtRtPriority = 1;
+
+}  // namespace
+
+class FdWatcherImpl {
+ public:
+  FdWatcherImpl() = default;
+  ~FdWatcherImpl();
+
+  int StartWatching(int fd,
+                    const std::function<void(int)>& on_read_fd_ready_callback);
+  void StopWatching();
+
+ private:
+  int StartThreadIfNeeded();
+  void StopThread();
+  void NotifyThread() const;
+  void ThreadRoutine();
+
+  std::atomic_bool running_{false};
+  std::thread thread_;
+
+  // Mutex to protect shared data related to watched FDs.
+  std::mutex watched_fds_mutex_;
+  std::unordered_map<int, std::function<void(int)>> watched_fds_;
+
+  // File descriptors for inter-thread communication using a pipe.
+  unique_fd notification_read_fd_;
+  unique_fd notification_write_fd_;
+};
+
+FdWatcherImpl::~FdWatcherImpl() { StopThread(); }
+
+int FdWatcherImpl::StartWatching(
+    int fd, const std::function<void(int)>& on_read_fd_ready_callback) {
+  {
+    std::scoped_lock lock(watched_fds_mutex_);
+    watched_fds_.emplace(fd, on_read_fd_ready_callback);
+  }
+
+  return StartThreadIfNeeded();
+}
+
+void FdWatcherImpl::StopWatching() { StopThread(); }
+
+int FdWatcherImpl::StartThreadIfNeeded() {
+  if (running_.exchange(true)) {
+    return 0;
+  }
+
+  unique_fd read_fd;
+  unique_fd write_fd;
+  if (!Pipe(&read_fd, &write_fd, O_NONBLOCK)) {
+    running_ = false;
+    return -1;
+  }
+
+  notification_read_fd_ = std::move(read_fd);
+  notification_write_fd_ = std::move(write_fd);
+
+  thread_ = std::thread([this]() { ThreadRoutine(); });
+  if (!thread_.joinable()) {
+    return -1;
+  }
+
+  return 0;
+}
+
+void FdWatcherImpl::StopThread() {
+  if (!running_.exchange(false)) {
+    return;
+  }
+
+  NotifyThread();
+
+  // Wait for the thread to finish if not the current thread.
+  if (thread_.joinable() && std::this_thread::get_id() != thread_.get_id()) {
+    thread_.join();
+  }
+
+  {
+    std::scoped_lock lock(watched_fds_mutex_);
+    watched_fds_.clear();
+  }
+}
+
+void FdWatcherImpl::NotifyThread() const {
+  uint8_t stub_buffer = 0;
+  const ssize_t ret = TEMP_FAILURE_RETRY(
+      write(notification_write_fd_.get(), &stub_buffer, sizeof(stub_buffer)));
+  if (ret < 0) {
+    LOG(ERROR) << __func__
+               << ": Failed to write to notification pipe: " << strerror(errno)
+               << ".";
+  }
+}
+
+void FdWatcherImpl::ThreadRoutine() {
+  sched_param rt_params{.sched_priority = kBtRtPriority};
+  if (sched_setscheduler(0, SCHED_FIFO, &rt_params) != 0) {
+    LOG(WARNING) << __func__
+                 << ": Failed to set SCHED_FIFO: " << strerror(errno) << ".";
+  }
+
+  while (running_) {
+    fd_set read_fds;
+    FD_ZERO(&read_fds);
+    FD_SET(notification_read_fd_, &read_fds);
+
+    int max_fd = notification_read_fd_.get();
+    {
+      std::scoped_lock lock(watched_fds_mutex_);
+      for (const auto& [fd, _] : watched_fds_) {
+        FD_SET(fd, &read_fds);
+        max_fd = std::max(max_fd, fd);
+      }
+    }
+
+    const int num_ready_fds =
+        select(max_fd + 1, &read_fds, nullptr, nullptr, nullptr);
+
+    if (num_ready_fds < 0) {
+      if (errno == EINTR) {
+        continue;
+      }
+
+      LOG(ERROR) << __func__ << ": select() failed: " << strerror(errno) << ".";
+      break;
+    }
+
+    if (FD_ISSET(notification_read_fd_.get(), &read_fds)) {
+      uint8_t stub_buffer;
+      TEMP_FAILURE_RETRY(
+          read(notification_read_fd_.get(), &stub_buffer, sizeof(stub_buffer)));
+      continue;
+    }
+
+    // Invoke the data ready callbacks if appropriate.
+    {
+      // Hold the mutex to make sure that the callbacks are still valid.
+      std::scoped_lock lock(watched_fds_mutex_);
+      for (const auto& [fd, ready_callback] : watched_fds_) {
+        if (FD_ISSET(fd, &read_fds)) {
+          ready_callback(fd);
+        }
+      }
+    }
+  }
+}
+
+FdWatcher::FdWatcher() : impl_(std::make_unique<FdWatcherImpl>()) {}
+
+FdWatcher::~FdWatcher() = default;
+
+int FdWatcher::StartWatching(
+    int fd, const std::function<void(int)>& on_read_fd_ready_callback) {
+  return impl_->StartWatching(fd, on_read_fd_ready_callback);
+}
+
+void FdWatcher::StopWatching() { impl_->StopWatching(); }
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/files.cc b/bluetooth/bluetooth_hal/util/files.cc
new file mode 100644
index 0000000000..e0ca75cd1b
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/files.cc
@@ -0,0 +1,367 @@
+/*
+ * Copyright 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/util/files.h"
+
+#include <assert.h>
+#include <fcntl.h>
+#include <libgen.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <cerrno>
+#include <cstring>
+#include <fstream>
+#include <string>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/util/logging.h"
+
+namespace {
+
+using ::bluetooth_hal::util::Logger;
+
+// device node for Battery percentage.
+constexpr char kBtteryPercentageNode[] =
+    "/sys/class/power_supply/battery/capacity";
+
+void HandleError(const std::string& temp_path, int* dir_fd, FILE** fp) {
+  // This indicates there is a write issue.  Unlink as partial data is not
+  // acceptable.
+  unlink(temp_path.c_str());
+  if (*fp) {
+    fclose(*fp);
+    *fp = nullptr;
+  }
+  if (*dir_fd != -1) {
+    close(*dir_fd);
+    *dir_fd = -1;
+  }
+}
+
+}  // namespace
+
+namespace bluetooth_hal {
+namespace os {
+
+bool GetFsDebugDump(int fd, const std::string& debugfs) {
+  std::stringstream ss;
+  std::ifstream file;
+
+  ss << "=============================================" << std::endl;
+  ss << "Debugfs:" << debugfs << std::endl;
+  ss << "=============================================" << std::endl;
+  file.open(debugfs);
+  if (file.is_open()) {
+    ss << file.rdbuf() << std::endl;
+  } else {
+    ss << "Fail to read debugfs: " << debugfs << std::endl;
+  }
+  ss << std::endl;
+  write(fd, ss.str().c_str(), ss.str().length());
+  return true;
+}
+
+bool GetBatteryPercentage(std::string& batt_level) {
+  int batt_ctl_fd = open(kBtteryPercentageNode, O_CREAT | O_RDONLY, S_IRGRP);
+  if (batt_ctl_fd < 0) {
+    LOG(ERROR) << __func__ << ": Unable to open Bttery Percentage device node ("
+               << kBtteryPercentageNode << "): " << strerror(errno) << " ("
+               << errno << ").";
+    return false;
+  }
+  ssize_t length;
+  char buffer[4] = {};
+  length = TEMP_FAILURE_RETRY(read(batt_ctl_fd, &buffer, sizeof(buffer) - 1));
+  close(batt_ctl_fd);
+
+  if (length < 1) {
+    return false;
+  }
+  if (buffer[length - 1] == '\n') {
+    buffer[length - 1] = '\0';
+  }
+  batt_level.assign(buffer);
+
+  return true;
+}
+
+std::string GetLastLogPath(std::string log_file_path) {
+  return log_file_path.append(".last");
+}
+
+void CreateLogFile(const std::string& log_file_path,
+                   std::ofstream& log_file_stream) {
+  LOG(INFO) << __func__ << ": log_file_path: " << log_file_path << ".";
+  std::string last_file_path = GetLastLogPath(log_file_path);
+
+  if (os::FileExists(log_file_path)) {
+    // Change the file's permissions to OWNER Read/Write, GROUP Read, OTHER Read
+    if (chmod(last_file_path.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) !=
+        0) {
+      LOG(ERROR) << __func__ << ": Unable to change file permissions "
+                 << last_file_path << ".";
+    }
+    if (!os::RenameFile(log_file_path, last_file_path)) {
+      LOG(ERROR) << __func__ << ": Unable to rename existing snoop log from \""
+                 << log_file_path << "\" to \"" << last_file_path << "\".";
+    }
+  } else {
+    LOG(INFO) << __func__ << ": Previous log file \"" << log_file_path
+              << "\" does not exist, skip renaming.";
+  }
+
+  // do not use std::ios::app as we want override the existing file
+  log_file_stream.open(log_file_path, std::ios::out);
+
+  // Change the file's permissions to OWNER Read/Write, GROUP Read, OTHER Read
+  if (chmod(log_file_path.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) !=
+      0) {
+    LOG(ERROR) << __func__ << ": Unable to change file permissions "
+               << log_file_path << ".";
+  }
+  if (!log_file_stream.good()) {
+    LOG(ERROR) << __func__ << ": Unable to open log at \"" << log_file_path
+               << "\", error: \"" << strerror(errno) << "\".";
+  }
+  log_file_stream << Logger::GetFileFormatTimestamp() << std::endl;
+}
+
+void CloseLogFileStream(std::ofstream& log_file_stream) {
+  if (log_file_stream.is_open()) {
+    log_file_stream.flush();
+    log_file_stream.close();
+  }
+}
+
+bool FileExists(const std::string& path) {
+  std::ifstream input(path, std::ios::binary | std::ios::ate);
+  return input.good();
+}
+
+bool RenameFile(const std::string& from, const std::string& to) {
+  if (std::rename(from.c_str(), to.c_str()) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to rename file from '" << from
+               << "' to '" << to << "', error: " << strerror(errno) << ".";
+    return false;
+  }
+  return true;
+}
+
+std::optional<std::string> ReadSmallFile(const std::string& path) {
+  std::ifstream input(path, std::ios::binary | std::ios::ate);
+  if (!input) {
+    LOG(WARNING) << __func__ << ": Failed to open file '" << path
+                 << "', error: " << strerror(errno) << ".";
+    return std::nullopt;
+  }
+  int file_size = input.tellg();
+  if (file_size < 0) {
+    LOG(WARNING) << __func__ << ": Failed to get file size for '" << path
+                 << "', error: " << strerror(errno) << ".";
+    return std::nullopt;
+  }
+  std::string result(file_size, '\0');
+  if (!input.seekg(0)) {
+    LOG(WARNING) << __func__ << ": Failed to go back to the beginning of file '"
+                 << path << "', error: " << strerror(errno) << ".";
+    return std::nullopt;
+  }
+  if (!input.read(result.data(), result.size())) {
+    LOG(WARNING) << __func__ << ": Failed to read file '" << path
+                 << "', error: " << strerror(errno) << ".";
+    return std::nullopt;
+  }
+  input.close();
+  return result;
+}
+
+bool WriteToFile(const std::string& path, const std::string& data) {
+  // TBD: ASSERT(!path.empty());
+  // Steps to ensure content of data gets to disk:
+  //
+  // 1) Open and write to temp file (e.g. bt_config.conf.new).
+  // 2) Flush the stream buffer to the temp file.
+  // 3) Sync the temp file to disk with fsync().
+  // 4) Rename temp file to actual config file (e.g. bt_config.conf).
+  //    This ensures atomic update.
+  // 5) Sync directory that has the conf file with fsync().
+  //    This ensures directory entries are up-to-date.
+  //
+  // We are using traditional C type file methods because C++ std::filesystem
+  // and std::ofstream do not support:
+  // - Operation on directories
+  // - fsync() to ensure content is written to disk
+
+  // Build temp config file based on config file (e.g. bt_config.conf.new).
+  const std::string temp_path = path + ".new";
+
+  // Extract directory from file path (e.g. /data/misc/bluedroid).
+  // libc++fs is not supported in APEX yet and hence cannot use
+  // std::filesystem::path::parent_path
+  std::string directory_path;
+  {
+    // Make a temporary variable as inputs to dirname() will be modified and
+    // return value points to input char array temp_path_for_dir must not be
+    // destroyed until results from dirname is appended to directory_path
+    std::string temp_path_for_dir(path);
+    directory_path.append(dirname(temp_path_for_dir.data()));
+  }
+  if (directory_path.empty()) {
+    LOG(ERROR) << __func__ << ": Error extracting directory from '" << path
+               << "', error: " << strerror(errno) << ".";
+    return false;
+  }
+
+  int dir_fd = open(directory_path.c_str(), O_RDONLY | O_DIRECTORY);
+  if (dir_fd < 0) {
+    LOG(ERROR) << __func__ << ": Unable to open dir '" << directory_path
+               << "', error: " << strerror(errno) << ".";
+    return false;
+  }
+
+  FILE* fp = std::fopen(temp_path.c_str(), "wt");
+  if (!fp) {
+    LOG(ERROR) << __func__ << ": Unable to write to file '" << temp_path
+               << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+
+  if (std::fprintf(fp, "%s", data.c_str()) < 0) {
+    LOG(ERROR) << __func__ << ": Unable to write to file '" << temp_path
+               << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+
+  // Flush the stream buffer to the temp file.
+  if (std::fflush(fp) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to write flush buffer to file '"
+               << temp_path << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+
+  // Sync written temp file out to disk. fsync() is blocking until data makes it
+  // to disk.
+  if (fsync(fileno(fp)) != 0) {
+    LOG(WARNING) << __func__ << ": Unable to fsync file '" << temp_path
+                 << "', error: " << strerror(errno) << ".";
+    // Allow fsync to fail and continue
+  }
+
+  if (std::fclose(fp) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to close file '" << temp_path
+               << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+  fp = nullptr;
+
+  // Change the file's permissions to Read/Write by User and Group
+  if (chmod(temp_path.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to change file permissions '"
+               << temp_path << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+
+  // Rename written temp file to the actual config file.
+  if (std::rename(temp_path.c_str(), path.c_str()) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to commit file from '" << temp_path
+               << "' to '" << path << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+
+  // This should ensure the directory is updated as well.
+  if (fsync(dir_fd) != 0) {
+    LOG(WARNING) << __func__ << ": Unable to fsync dir '" << directory_path
+                 << "', error: " << strerror(errno) << ".";
+  }
+
+  if (close(dir_fd) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to close dir '" << directory_path
+               << "', error: " << strerror(errno) << ".";
+    HandleError(temp_path, &dir_fd, &fp);
+    return false;
+  }
+  return true;
+}
+
+bool RemoveFile(const std::string& path) {
+  if (remove(path.c_str()) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to remove file '" << path
+               << "', error: " << strerror(errno) << ".";
+    return false;
+  }
+  return true;
+}
+
+std::optional<std::chrono::time_point<std::chrono::system_clock,
+                                      std::chrono::nanoseconds>>
+FileCreatedTime(const std::string& path) {
+  struct stat file_info;
+  if (stat(path.c_str(), &file_info) != 0) {
+    LOG(ERROR) << __func__ << ": Unable to read '" << path
+               << "' file metadata, error: " << strerror(errno) << ".";
+    return std::nullopt;
+  }
+
+  timespec created_ts = file_info.st_ctim;
+  std::chrono::duration d = std::chrono::seconds{created_ts.tv_sec} +
+                            std::chrono::nanoseconds{created_ts.tv_nsec};
+
+  return std::chrono::time_point<std::chrono::system_clock>(
+      duration_cast<std::chrono::system_clock::duration>(d));
+}
+
+void DeleteOldestFiles(std::string_view directory,
+                       std::optional<std::string_view> file_prefix,
+                       size_t files_to_keep) {
+  LOG(INFO) << __func__ << " (directory: " << directory.data()
+            << ", file_prefix: "
+            << (file_prefix.has_value() ? file_prefix.value().data() : "")
+            << ", files_to_keep: " << files_to_keep << ")";
+  std::vector<std::filesystem::directory_entry> files;
+
+  // Collect all regular files in the directory
+  for (const auto& entry : std::filesystem::directory_iterator(directory)) {
+    if (!entry.is_regular_file()) {
+      continue;
+    }
+    const std::string filename = entry.path().filename().string();
+    if (!file_prefix.has_value() || filename.starts_with(file_prefix.value())) {
+      files.emplace_back(entry);
+    }
+  }
+
+  // Sort files by their last write time
+  std::sort(files.begin(), files.end(), [](const auto& a, const auto& b) {
+    return std::filesystem::last_write_time(a) >
+           std::filesystem::last_write_time(b);
+  });
+
+  // Delete files, starting at starting_point
+  for (size_t i = files_to_keep; i < files.size(); ++i) {
+    std::filesystem::remove(files[i]);
+    LOG(INFO) << "Deleted: " << files[i].path().c_str();
+  }
+}
+
+}  // namespace os
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/logging.cc b/bluetooth/bluetooth_hal/util/logging.cc
new file mode 100644
index 0000000000..1c1556c797
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/logging.cc
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/util/logging.h"
+
+#include <chrono>
+#include <ctime>
+#include <iomanip>
+#include <sstream>
+#include <string>
+
+namespace bluetooth_hal {
+namespace util {
+namespace {
+
+// Helper function to format time with leading zeros.
+std::string FormatTimeComponent(int value, int width) {
+  std::stringstream ss;
+  ss << std::setw(width) << std::setfill('0') << value;
+  return ss.str();
+}
+
+}  // namespace
+
+std::string Logger::GetLogFormatTimestamp() {
+  const auto now = std::chrono::system_clock::now();
+  const auto now_ms =
+      std::chrono::time_point_cast<std::chrono::milliseconds>(now);
+  const std::chrono::duration value = now_ms.time_since_epoch();
+
+  // Get seconds and milliseconds separately.
+  const long long seconds =
+      std::chrono::duration_cast<std::chrono::seconds>(value).count();
+  const long long milliseconds = value.count() % 1000;
+
+  // Convert to local time.
+  const std::time_t now_c = static_cast<std::time_t>(seconds);
+  const std::tm* now_tm = std::localtime(&now_c);
+
+  std::stringstream ss;
+  ss << FormatTimeComponent(now_tm->tm_hour, 2) << ":"
+     << FormatTimeComponent(now_tm->tm_min, 2) << ":"
+     << FormatTimeComponent(now_tm->tm_sec, 2) << ":"
+     << FormatTimeComponent(static_cast<int>(milliseconds), 3);
+
+  return ss.str();
+}
+
+std::string Logger::GetFileFormatTimestamp() {
+  const auto now = std::chrono::system_clock::now();
+  const std::time_t now_c = std::chrono::system_clock::to_time_t(now);
+
+  // Convert to local time.
+  const std::tm* now_tm = std::localtime(&now_c);
+
+  std::stringstream ss;
+  ss << FormatTimeComponent(now_tm->tm_year + 1900, 4) << "-"
+     << FormatTimeComponent(now_tm->tm_mon + 1, 2) << "-"
+     << FormatTimeComponent(now_tm->tm_mday, 2) << "_"
+     << FormatTimeComponent(now_tm->tm_hour, 2) << "-"
+     << FormatTimeComponent(now_tm->tm_min, 2) << "-"
+     << FormatTimeComponent(now_tm->tm_sec, 2);
+
+  return ss.str();
+}
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/power/power_interface.cc b/bluetooth/bluetooth_hal/util/power/power_interface.cc
new file mode 100644
index 0000000000..4deec93f75
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/power/power_interface.cc
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/util/power/power_interface.h"
+
+#include "hardware_legacy/power.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+constexpr char kWakeLockName[] = "bthal_wakelock";
+
+bool PowerInterface::AcquireWakelock() {
+  return acquire_wake_lock(PARTIAL_WAKE_LOCK, kWakeLockName) == 0;
+}
+
+bool PowerInterface::ReleaseWakelock() {
+  return release_wake_lock(kWakeLockName) == 0;
+}
+
+PowerInterface& PowerInterface::GetInterface() {
+  static PowerInterface interface;
+  return interface;
+}
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/power/wakelock.cc b/bluetooth/bluetooth_hal/util/power/wakelock.cc
new file mode 100644
index 0000000000..8a25614518
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/power/wakelock.cc
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.wakelock"
+
+#include "bluetooth_hal/util/power/wakelock.h"
+
+#include <chrono>
+#include <mutex>
+#include <sstream>
+#include <string>
+#include <unordered_set>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/power/power_interface.h"
+#include "bluetooth_hal/util/power/wakelock_util.h"
+#include "bluetooth_hal/util/power/wakelock_watchdog.h"
+#include "bluetooth_hal/util/timer_manager.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class WakelockImpl : public Wakelock {
+ public:
+  void Acquire(WakeSource source) override;
+  void Release(WakeSource source) override;
+  bool IsAcquired() override;
+  bool IsWakeSourceAcquired(WakeSource source) override;
+
+ private:
+  void ReleaseWakelock();
+  void AcquireWakelock();
+  std::string ToString();
+
+  bool wakelock_acquired_;
+  std::recursive_mutex mutex_;
+  std::unordered_set<WakeSource> acquired_sources_;
+  Timer release_wakelock_timer_;
+
+  // TODO: b/382605673 - Read it from the config manager.
+  static constexpr int kWakelockTimeMilliseconds = 100;
+};
+
+void WakelockImpl::Acquire(WakeSource source) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (acquired_sources_.count(source) > 0) {
+    return;
+  }
+
+  if (acquired_sources_.empty()) {
+    if (release_wakelock_timer_.IsScheduled()) {
+      // Stop the timer of releasing wakelock.
+      release_wakelock_timer_.Cancel();
+    }
+    AcquireWakelock();
+  }
+  acquired_sources_.emplace(source);
+  WakelockWatchdog::GetWatchdog().Start(source);
+
+  ANCHOR_LOG(AnchorType::WAKELOCK_VOTE)
+      << "Wakelock VOTE for: " << WakelockUtil::WakeSourceToString(source)
+      << ", current wakelocks: " << ToString();
+}
+
+void WakelockImpl::Release(WakeSource source) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (acquired_sources_.erase(source) == 0) {
+    return;
+  }
+  WakelockWatchdog::GetWatchdog().Stop(source);
+
+  ANCHOR_LOG(AnchorType::WAKELOCK_UNVOTE)
+      << "Wakelock UNVOTE for: " << WakelockUtil::WakeSourceToString(source)
+      << ", current wakelocks: " << ToString();
+
+  if (acquired_sources_.empty()) {
+    // The wakelock list is empty, schedule a timer to release the wakelock.
+    release_wakelock_timer_.Schedule(
+        std::bind_front(&WakelockImpl::ReleaseWakelock, this),
+        std::chrono::milliseconds{kWakelockTimeMilliseconds});
+  }
+}
+
+bool WakelockImpl::IsAcquired() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  return !acquired_sources_.empty();
+}
+
+bool WakelockImpl::IsWakeSourceAcquired(WakeSource source) {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  return (acquired_sources_.count(source) > 0);
+}
+
+void WakelockImpl::AcquireWakelock() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (!wakelock_acquired_) {
+    ANCHOR_LOG_INFO(AnchorType::WAKELOCK_ACQUIRE) << "Acuqire system wakelock";
+    PowerInterface::GetInterface().AcquireWakelock();
+    wakelock_acquired_ = true;
+  }
+}
+
+void WakelockImpl::ReleaseWakelock() {
+  std::unique_lock<std::recursive_mutex> lock(mutex_);
+  if (wakelock_acquired_) {
+    ANCHOR_LOG_INFO(AnchorType::WAKELOCK_RELEASE) << "Release system wakelock";
+    PowerInterface::GetInterface().ReleaseWakelock();
+    wakelock_acquired_ = false;
+  }
+}
+
+std::string WakelockImpl::ToString() {
+  std::stringstream ss;
+  ss << "[";
+  bool first = true;
+  for (auto source : acquired_sources_) {
+    if (!first) {
+      ss << ", ";
+    }
+    ss << WakelockUtil::WakeSourceToString(source);
+    first = false;
+  }
+  ss << "]";
+  return ss.str();
+}
+
+Wakelock& Wakelock::GetWakelock() {
+  static WakelockImpl wakelock;
+  return wakelock;
+}
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/power/wakelock_watchdog.cc b/bluetooth/bluetooth_hal/util/power/wakelock_watchdog.cc
new file mode 100644
index 0000000000..cf1a98fc66
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/power/wakelock_watchdog.cc
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.wakelock_watchdog"
+
+#include "bluetooth_hal/util/power/wakelock_watchdog.h"
+
+#include <chrono>
+#include <functional>
+#include <mutex>
+#include <unordered_map>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/debug/debug_central.h"
+#include "bluetooth_hal/hal_types.h"
+#include "bluetooth_hal/util/power/wakelock_util.h"
+#include "bluetooth_hal/util/timer_manager.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace power {
+
+class WatchdogBiteHandler {
+ public:
+  // Intentionally crash in different methods to create crash reason
+  // individually.
+  void TxTimeout() {
+    LOG(FATAL) << __func__ << ": wakelock watchdog BITE due to TX timeout!";
+  }
+
+  void RxTimeout() {
+    LOG(FATAL) << __func__
+               << ": wakelock watchdog BITE due to unable to complete RX!";
+  }
+
+  void HciTimeout() {
+    LOG(FATAL) << __func__ << ": wakelock watchdog BITE due to HCI timeout!";
+  }
+
+  void InitializeTimeout() {
+    LOG(FATAL) << __func__
+               << ": wakelock watchdog BITE due to initialize timeout!";
+  }
+
+  void CloseTimeout() {
+    LOG(FATAL) << __func__ << ": wakelock watchdog BITE due to close timeout!";
+  }
+};
+
+class WakelockWatchdogImpl : public WakelockWatchdog {
+ public:
+  void Start(WakeSource source) override;
+  void Stop(WakeSource source) override;
+
+ private:
+  void WatchdogTimerExpired();
+  void Bark(WakeSource source, int remain_time);
+  void Bite(WakeSource source);
+
+  std::recursive_mutex mutex_;
+  Timer watchdog_timer_;
+  std::unordered_map<WakeSource, int> watchdog_map_;
+  static constexpr int kWatchdogBarkMs = 1000;
+  static const std::unordered_map<WakeSource, int> kWatchdogMs;
+};
+
+const std::unordered_map<WakeSource, int> WakelockWatchdogImpl::kWatchdogMs = {
+    {WakeSource::kTx, 5000},           //  5 seconds for TX timeout.
+    {WakeSource::kRx, 5000},           //  5 seconds for RX timeout.
+    {WakeSource::kHciBusy, 10000},     // 10 seconds for HCI timeout.
+    {WakeSource::kTransport, 20000},   // 20 seconds for Transport timeout.
+    {WakeSource::kInitialize, 20000},  // 20 seconds for HAL Initialization.
+    {WakeSource::kClose, 20000},       // 20 seconds for HAL Closing.
+};
+
+void WakelockWatchdogImpl::Start(WakeSource source) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  if (!watchdog_timer_.IsScheduled()) {
+    watchdog_timer_.Schedule(
+        std::bind_front(&WakelockWatchdogImpl::WatchdogTimerExpired, this),
+        std::chrono::milliseconds{kWatchdogBarkMs});
+  }
+  watchdog_map_[source] = kWatchdogMs.at(source);
+}
+
+void WakelockWatchdogImpl::Stop(WakeSource source) {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  watchdog_map_.erase(source);
+
+  if (watchdog_map_.empty() && watchdog_timer_.IsScheduled()) {
+    watchdog_timer_.Cancel();
+  }
+}
+
+void WakelockWatchdogImpl::WatchdogTimerExpired() {
+  std::scoped_lock<std::recursive_mutex> lock(mutex_);
+  if (watchdog_map_.empty()) {
+    return;
+  }
+
+  for (auto& it : watchdog_map_) {
+    WakeSource source = it.first;
+    it.second -= kWatchdogBarkMs;
+    int remain_time = it.second;
+
+    if (remain_time <= 0) {
+      Bite(source);
+      continue;
+    }
+    if (source != WakeSource::kTransport &&
+        remain_time <= (kWatchdogMs.at(source)) / 2) {
+      // Watchdog bark and print warning log when it is close to bite.
+      Bark(source, remain_time);
+    }
+  }
+
+  watchdog_timer_.Schedule(
+      std::bind_front(&WakelockWatchdogImpl::WatchdogTimerExpired, this),
+      std::chrono::milliseconds{kWatchdogBarkMs});
+}
+
+void WakelockWatchdogImpl::Bark(WakeSource source, int remain_time) {
+  ANCHOR_LOG_WARNING(AnchorType::WATCHDOG)
+      << ": Watchdog BARK! WakeSource = "
+      << WakelockUtil::WakeSourceToString(source)
+      << ", remain time = " << remain_time << "ms.";
+}
+
+void WakelockWatchdogImpl::Bite(WakeSource source) {
+  WatchdogBiteHandler watchdog_bite_handler;
+  switch (source) {
+    case WakeSource::kTx:
+      watchdog_bite_handler.TxTimeout();
+      break;
+    case WakeSource::kRx:
+      watchdog_bite_handler.RxTimeout();
+      break;
+    case WakeSource::kHciBusy:
+      watchdog_bite_handler.HciTimeout();
+      break;
+    case WakeSource::kTransport:
+      // Long Transport wakelock can happen in heavy BT traffic, print log here
+      // as a nice-to-have battery information instead of crash.
+      ANCHOR_LOG(AnchorType::WATCHDOG) << "Long transport wakelock detected.";
+      Start(source);
+      break;
+    case WakeSource::kInitialize:
+      watchdog_bite_handler.InitializeTimeout();
+      break;
+    case WakeSource::kClose:
+      watchdog_bite_handler.CloseTimeout();
+      break;
+  }
+}
+
+WakelockWatchdog& WakelockWatchdog::GetWatchdog() {
+  static WakelockWatchdogImpl watchdog;
+  return watchdog;
+}
+
+}  // namespace power
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/system_call_wrapper.cc b/bluetooth/bluetooth_hal/util/system_call_wrapper.cc
new file mode 100644
index 0000000000..597e82c5eb
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/system_call_wrapper.cc
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/util/system_call_wrapper.h"
+
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/inotify.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/un.h>
+#include <unistd.h>
+
+#include <cstddef>
+#include <cstdint>
+
+namespace bluetooth_hal {
+namespace util {
+
+class SystemCallWrapperImpl : public SystemCallWrapper {
+ public:
+  int Select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds,
+             struct timeval* timeout) override {
+    return select(nfds, readfds, writefds, errorfds, timeout);
+  }
+
+  ssize_t Send(int fd, const void* buffer, size_t length, int flags) override {
+    return send(fd, buffer, length, flags);
+  }
+
+  ssize_t Recv(int fd, void* buffer, size_t length, int flags) override {
+    return recv(fd, buffer, length, flags);
+  }
+
+  ssize_t Write(int fd, const void* buffer, size_t count) override {
+    return write(fd, buffer, count);
+  }
+
+  ssize_t Writev(int fd, const struct iovec* iov, int iovcnt) override {
+    return writev(fd, iov, iovcnt);
+  }
+
+  ssize_t Read(int fd, void* buffer, size_t count) override {
+    return read(fd, buffer, count);
+  }
+
+  int Accept(int fd, struct sockaddr* address,
+             socklen_t* address_len) override {
+    return accept(fd, address, address_len);
+  }
+
+  int Open(const char* pathname, int flags) override {
+    return open(pathname, flags);
+  }
+
+  void Close(int fd) override { close(fd); }
+
+  void Unlink(const char* path) override { unlink(path); }
+
+  int InotifyInit() override { return inotify_init(); }
+
+  int InotifyAddWatch(int fd, const char* pathname, uint32_t mask) override {
+    return inotify_add_watch(fd, pathname, mask);
+  }
+
+  int Socket(int domain, int type, int protocol) override {
+    return socket(domain, type, protocol);
+  }
+
+  int Bind(int fd, const struct sockaddr* address,
+           socklen_t address_len) override {
+    return bind(fd, address, address_len);
+  }
+
+  int Listen(int fd, int backlog) override { return listen(fd, backlog); }
+
+  int Stat(const char* path, struct stat* sb) override {
+    return stat(path, sb);
+  }
+
+  bool IsSocketFile(int st_mode) override { return S_ISSOCK(st_mode); }
+
+  int CreatePipe(int pipefd[2], int flags) override {
+    return pipe2(pipefd, flags);
+  }
+
+  int FdIsSet(int fd, fd_set* set) override { return FD_ISSET(fd, set); }
+
+  void FdSet(int fd, fd_set* set) override { FD_SET(fd, set); }
+
+  void FdZero(fd_set* set) override { FD_ZERO(set); }
+
+  int Kill(pid_t pid, int signal) override { return kill(pid, signal); }
+};
+
+SystemCallWrapper& SystemCallWrapper::GetWrapper() {
+  static SystemCallWrapperImpl wrapper;
+  return wrapper;
+}
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/timer_manager.cc b/bluetooth/bluetooth_hal/util/timer_manager.cc
new file mode 100644
index 0000000000..dd5bc55727
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/timer_manager.cc
@@ -0,0 +1,288 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bthal.timer_manager"
+
+#include "bluetooth_hal/util/timer_manager.h"
+
+#include <errno.h>
+#include <string.h>
+#include <sys/epoll.h>
+#include <sys/timerfd.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <atomic>
+#include <chrono>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <set>
+#include <unordered_map>
+
+#include "android-base/logging.h"
+#include "bluetooth_hal/util/worker.h"
+
+constexpr clockid_t GetAlarmClock() {
+#ifndef UNIT_TEST
+  return CLOCK_BOOTTIME_ALARM;
+#else
+  return CLOCK_BOOTTIME;
+#endif
+}
+
+constexpr long kMillisecondsPerSecond = 1000;
+constexpr long kNanosecondsPerMillisecond = 1000000;
+constexpr long kTearDownTimerInMillisecond = 10;
+constexpr long kDisarmTimerInMillisecond = 0;
+
+namespace bluetooth_hal {
+namespace util {
+
+class TimerManagerImpl : public TimerManager {
+ public:
+  TimerManagerImpl();
+  ~TimerManagerImpl() override;
+  bool Schedule(Timer* timer, const std::function<void()>& task,
+                std::chrono::milliseconds delay) override;
+  bool Cancel(Timer* timer) override;
+  bool IsScheduled(Timer* timer) override;
+
+ private:
+  enum class TimerMessage : int {
+    kWaitForExpiration = 1,
+  };
+
+  enum class TaskMessage : int {
+    kOnTimerExpired = 1,
+  };
+
+  class TimerEvent {
+   public:
+    Timer* timer_;
+    std::chrono::steady_clock::time_point expires_at_;
+    std::function<void()> task_;
+
+    bool operator<(const TimerEvent& other) const {
+      if (expires_at_ == other.expires_at_) {
+        return timer_ < other.timer_;
+      }
+      return expires_at_ < other.expires_at_;
+    }
+  };
+
+  inline int RunSyscallUntilNoIntr(std::function<int()> fn);
+  void OnTimerExpired();
+  bool RescheduleTimer();
+  bool WillBeTheFirstExpired(Timer* timer);
+  void EpollWaitTimer();
+  bool SetTimer(std::chrono::milliseconds delay);
+  std::unique_ptr<Worker<TimerMessage>> timer_thread_;
+  std::unique_ptr<Worker<TaskMessage>> task_thread_;
+  int timer_fd_;
+  int epoll_fd_;
+  std::unordered_map<Timer*, TimerEvent> timer_events_;
+  std::multiset<TimerEvent> ordered_timer_events_;
+  std::mutex mutex_;
+  std::atomic<bool> running_ = true;
+};
+
+TimerManagerImpl::TimerManagerImpl() {
+  timer_fd_ = timerfd_create(GetAlarmClock(), 0);
+  if (timer_fd_ < 0) {
+    LOG(ERROR) << "Failed to create timerfd: " << strerror(errno);
+    return;
+  }
+
+  epoll_fd_ = RunSyscallUntilNoIntr(std::bind(epoll_create1, 0));
+  if (epoll_fd_ < 0) {
+    LOG(ERROR) << "Failed to create epoll fd: " << strerror(errno);
+    close(timer_fd_);
+    return;
+  }
+  epoll_event event{.events = EPOLLIN, .data{.fd = timer_fd_}};
+  int result = RunSyscallUntilNoIntr([this, &event]() -> int {
+    return epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, timer_fd_, &event);
+  });
+  if (result < 0) {
+    LOG(ERROR) << "Failed to add timer fd to epoll: " << strerror(errno);
+    close(timer_fd_);
+    close(epoll_fd_);
+    return;
+  }
+
+  timer_thread_ =
+      std::make_unique<Worker<TimerMessage>>([this](TimerMessage message) {
+        if (message == TimerMessage::kWaitForExpiration) {
+          EpollWaitTimer();
+        } else {
+          LOG(ERROR) << "Unknown message: " << static_cast<int>(message);
+        }
+      });
+  task_thread_ =
+      std::make_unique<Worker<TaskMessage>>([this](TaskMessage message) {
+        if (message == TaskMessage::kOnTimerExpired) {
+          OnTimerExpired();
+        } else {
+          LOG(ERROR) << "Unknown message: " << static_cast<int>(message);
+        }
+      });
+  timer_thread_->Post(TimerMessage::kWaitForExpiration);
+}
+
+TimerManagerImpl::~TimerManagerImpl() {
+  std::lock_guard<std::mutex> lock(mutex_);
+  running_.store(false);
+  timer_events_.clear();
+  ordered_timer_events_.clear();
+  // TODO: b/419117083 - Fix this tricky SetTimer.
+  // Manually set a timer here to unblock the epoll_wait, so that EpollWaitTimer
+  // can proceed and exit.
+  SetTimer(std::chrono::milliseconds(kTearDownTimerInMillisecond));
+  timer_thread_.reset();
+  task_thread_.reset();
+  close(timer_fd_);
+  close(epoll_fd_);
+}
+
+bool TimerManagerImpl::Schedule(Timer* timer, const std::function<void()>& task,
+                                std::chrono::milliseconds delay) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  TimerEvent timer_event{timer, std::chrono::steady_clock::now() + delay,
+                         std::move(task)};
+  timer_events_[timer] = timer_event;
+  ordered_timer_events_.insert(timer_event);
+  if (WillBeTheFirstExpired(timer)) {
+    return RescheduleTimer();
+  }
+  return true;
+}
+
+bool TimerManagerImpl::Cancel(Timer* timer) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  auto it = timer_events_.find(timer);
+  if (it == timer_events_.end()) {
+    LOG(ERROR) << "Timer not found: " << timer;
+    return false;
+  }
+  bool need_to_reschedule = WillBeTheFirstExpired(it->second.timer_);
+  ordered_timer_events_.erase(it->second);
+  timer_events_.erase(it);
+  if (need_to_reschedule) {
+    return RescheduleTimer();
+  }
+  return true;
+}
+
+bool TimerManagerImpl::IsScheduled(Timer* timer) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  return timer_events_.find(timer) != timer_events_.end();
+}
+
+inline int TimerManagerImpl::RunSyscallUntilNoIntr(std::function<int()> fn) {
+  int result = fn();
+  while (result == -1 && errno == EINTR) {
+    result = fn();
+  }
+  return result;
+}
+
+bool TimerManagerImpl::RescheduleTimer() {
+  if (ordered_timer_events_.empty()) {
+    SetTimer(std::chrono::milliseconds(kDisarmTimerInMillisecond));
+    return true;
+  }
+  auto next_timer_event = ordered_timer_events_.begin();
+  std::chrono::milliseconds delay =
+      std::chrono::duration_cast<std::chrono::milliseconds>(
+          next_timer_event->expires_at_ - std::chrono::steady_clock::now());
+  if (delay.count() <= 0) {
+    task_thread_->Post(TaskMessage::kOnTimerExpired);
+    return true;
+  }
+  return SetTimer(delay);
+}
+
+bool TimerManagerImpl::SetTimer(std::chrono::milliseconds delay) {
+  itimerspec timer_spec{
+      .it_value = {
+          .tv_sec = static_cast<time_t>(delay.count() / kMillisecondsPerSecond),
+          .tv_nsec =
+              static_cast<long>((delay.count() % kMillisecondsPerSecond) *
+                                kNanosecondsPerMillisecond)}};
+  if (timerfd_settime(timer_fd_, 0, &timer_spec, nullptr) < 0) {
+    LOG(ERROR) << "Failed to set timerfd: " << strerror(errno);
+    return false;
+  }
+  return true;
+}
+
+bool TimerManagerImpl::WillBeTheFirstExpired(Timer* timer) {
+  if (ordered_timer_events_.empty()) {
+    return false;
+  }
+  return ordered_timer_events_.begin()->timer_ == timer;
+}
+
+void TimerManagerImpl::EpollWaitTimer() {
+  if (!running_.load()) {
+    return;
+  }
+  epoll_event event[1];
+  int event_count = RunSyscallUntilNoIntr(
+      [this, &event]() -> int { return epoll_wait(epoll_fd_, event, 1, -1); });
+  if (event_count > 0) {
+    uint64_t exp;
+    ssize_t size = read(event[0].data.fd, &exp, sizeof(exp));
+    if (size == sizeof(exp)) {
+      task_thread_->Post(TaskMessage::kOnTimerExpired);
+    }
+  } else if (event_count < 0) {
+    LOG(ERROR) << "epoll_wait error: " << strerror(errno);
+  }
+  timer_thread_->Post(TimerMessage::kWaitForExpiration);
+}
+
+void TimerManagerImpl::OnTimerExpired() {
+  std::function<void()> expired_task;
+  {
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (ordered_timer_events_.empty()) {
+      return;
+    }
+    auto it = ordered_timer_events_.begin();
+    // Ensure the timer has actually expired.
+    if (it->expires_at_ > std::chrono::steady_clock::now()) {
+      RescheduleTimer();
+      return;
+    }
+    // Take the expired task out and reschedule before executing them, and
+    // then unlock to allow the task to call `Schedule()`.
+    expired_task = std::move(it->task_);
+    timer_events_.erase(it->timer_);
+    ordered_timer_events_.erase(it);
+    RescheduleTimer();
+  }
+  expired_task();
+}
+
+TimerManager& TimerManager::GetManager() {
+  static TimerManagerImpl manager;
+  return manager;
+}
+
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/bluetooth/bluetooth_hal/util/timer_manager_test.cc b/bluetooth/bluetooth_hal/util/timer_manager_test.cc
new file mode 100644
index 0000000000..ad66a03460
--- /dev/null
+++ b/bluetooth/bluetooth_hal/util/timer_manager_test.cc
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_hal/util/timer_manager.h"
+
+#include <chrono>
+#include <functional>
+#include <future>
+#include <memory>
+
+#include "gtest/gtest.h"
+
+namespace bluetooth_hal {
+namespace util {
+namespace {
+
+using ::testing::Test;
+
+class TimerManagerTest : public Test {
+ protected:
+  /**
+   * @brief Returns a pair of promise and future. This is a helper for testing
+   * if a scheduled task on a timer is executed.
+   *
+   * Example:
+   *  auto [promise, future] = GetPromiseFuturePair();
+   *  timer.Schedule([&promise]() { promise->set_value(); }, milliseconds(10));
+   *  ASSERT_EQ(std::future_status::ready, future.wait_for(milliseconds(100)));
+   *
+   * @return A pair of promise and future.
+   */
+  std::pair<std::unique_ptr<std::promise<void>>, std::future<void>>
+  GetPromiseFuturePair() {
+    std::unique_ptr<std::promise<void>> promise =
+        std::make_unique<std::promise<void>>();
+    std::future<void> future = promise->get_future();
+    return std::make_pair(std::move(promise), std::move(future));
+  }
+};
+
+TEST_F(TimerManagerTest, ScheduleTask) {
+  Timer timer;
+  auto [promise, future] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule([&promise]() { promise->set_value(); },
+                             std::chrono::milliseconds(50)));
+  // The task should not be executed yet.
+  ASSERT_NE(std::future_status::ready,
+            future.wait_for(std::chrono::milliseconds(10)));
+  // The task should be executed after 50ms, set a timeout of 100ms.
+  ASSERT_EQ(std::future_status::ready,
+            future.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, CancelTask) {
+  Timer timer;
+  auto [promise, future] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule([&promise]() { promise->set_value(); },
+                             std::chrono::milliseconds(10)));
+  ASSERT_TRUE(timer.Cancel());
+  ASSERT_NE(std::future_status::ready,
+            future.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, CancelNonExistingTask) {
+  Timer timer;
+  ASSERT_FALSE(timer.Cancel());
+}
+
+TEST_F(TimerManagerTest, ScheduleMultipleTasks) {
+  Timer timer1, timer2;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer1.Schedule([&promise1]() { promise1->set_value(); },
+                              std::chrono::milliseconds(50)));
+  ASSERT_TRUE(timer2.Schedule([&promise2]() { promise2->set_value(); },
+                              std::chrono::milliseconds(100)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(150)));
+}
+
+TEST_F(TimerManagerTest, SecondTimerFiresFirst) {
+  Timer timer1, timer2;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer1.Schedule([&promise1]() { promise1->set_value(); },
+                              std::chrono::milliseconds(100)));
+  ASSERT_TRUE(timer2.Schedule([&promise2]() { promise2->set_value(); },
+                              std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(150)));
+}
+
+TEST_F(TimerManagerTest, ScheduleMultipleTasksFireAtTheSameTime) {
+  Timer timer1, timer2;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer1.Schedule([&promise1]() { promise1->set_value(); },
+                              std::chrono::milliseconds(50)));
+  ASSERT_TRUE(timer2.Schedule([&promise2]() { promise2->set_value(); },
+                              std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, ScheduleMultipleTasksWithCancel) {
+  Timer timer1, timer2;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer1.Schedule([&promise1]() { promise1->set_value(); },
+                              std::chrono::milliseconds(50)));
+  ASSERT_TRUE(timer2.Schedule([&promise2]() { promise2->set_value(); },
+                              std::chrono::milliseconds(60)));
+  ASSERT_TRUE(timer1.Cancel());
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, Reschedule) {
+  Timer timer;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule([&promise1]() { promise1->set_value(); },
+                             std::chrono::milliseconds(50)));
+  ASSERT_TRUE(timer.Schedule([&promise2]() { promise2->set_value(); },
+                             std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, WillNotCancelItself) {
+  Timer timer;
+  auto [promise, future] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule(
+      [&timer, &promise]() {
+        // This cancel will be a no-op since the task is already fired.
+        ASSERT_FALSE(timer.Cancel());
+        promise->set_value();
+      },
+      std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, CanScheduleAnotherTaskInTask) {
+  Timer timer;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule(
+      [&timer, &promise1, &promise2]() {
+        ASSERT_TRUE(timer.Schedule([&promise2]() { promise2->set_value(); },
+                                   std::chrono::milliseconds(10)));
+        promise1->set_value();
+      },
+      std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, ScheduleTaskOnAnotherTimerInTask) {
+  Timer timer1, timer2;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer1.Schedule(
+      [&timer2, &promise1, &promise2]() {
+        ASSERT_TRUE(timer2.Schedule([&promise2]() { promise2->set_value(); },
+                                    std::chrono::milliseconds(10)));
+        promise1->set_value();
+      },
+      std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_EQ(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, CancelTaskWhichSchedulesAnotherTask) {
+  Timer timer;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule(
+      [&timer, &promise1, &promise2]() {
+        ASSERT_TRUE(timer.Schedule([&promise2]() { promise2->set_value(); },
+                                   std::chrono::milliseconds(10)));
+        promise1->set_value();
+      },
+      std::chrono::milliseconds(10)));
+  ASSERT_TRUE(timer.Cancel());
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, CancelTaskScheduledInTask) {
+  Timer timer;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer.Schedule(
+      [&timer, &promise1, &promise2]() {
+        ASSERT_TRUE(timer.Schedule([&promise2]() { promise2->set_value(); },
+                                   std::chrono::milliseconds(20)));
+        promise1->set_value();
+      },
+      std::chrono::milliseconds(50)));
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  // First task should be fired after 50ms, and then we can cancel the second.
+  std::this_thread::sleep_for(std::chrono::milliseconds(50));
+  ASSERT_TRUE(timer.Cancel());
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, CancelTaskWhichCancelsAnotherTask) {
+  Timer timer1, timer2;
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  ASSERT_TRUE(timer1.Schedule([&promise1]() { promise1->set_value(); },
+                              std::chrono::milliseconds(50)));
+  ASSERT_TRUE(timer2.Schedule(
+      [&timer1, &promise2]() {
+        FAIL();
+        timer1.Cancel();
+        promise2->set_value();
+      },
+      std::chrono::milliseconds(50)));
+  ASSERT_TRUE(timer2.Cancel());
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, DestroyTimerBeforeExpire) {
+  auto [promise, future] = GetPromiseFuturePair();
+  {
+    Timer timer;
+    ASSERT_TRUE(timer.Schedule([&promise]() { promise->set_value(); },
+                               std::chrono::milliseconds(10)));
+  }
+  ASSERT_NE(std::future_status::ready,
+            future.wait_for(std::chrono::milliseconds(100)));
+}
+
+TEST_F(TimerManagerTest, FireTimerAfterTheEarlyOneThatHasDestroyed) {
+  auto [promise1, future1] = GetPromiseFuturePair();
+  auto [promise2, future2] = GetPromiseFuturePair();
+  Timer timer1;
+  ASSERT_TRUE(timer1.Schedule([&promise1]() { promise1->set_value(); },
+                              std::chrono::milliseconds(50)));
+  {
+    Timer timer2;
+    ASSERT_TRUE(timer2.Schedule([&promise2]() { promise2->set_value(); },
+                                std::chrono::milliseconds(5)));
+  }
+  ASSERT_NE(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(10)));
+  ASSERT_EQ(std::future_status::ready,
+            future1.wait_for(std::chrono::milliseconds(100)));
+  ASSERT_NE(std::future_status::ready,
+            future2.wait_for(std::chrono::milliseconds(100)));
+}
+
+}  // namespace
+}  // namespace util
+}  // namespace bluetooth_hal
diff --git a/boot/aidl/client/BootControlClient.cpp b/boot/aidl/client/BootControlClient.cpp
index 7aab5b420c..b212bb8d62 100644
--- a/boot/aidl/client/BootControlClient.cpp
+++ b/boot/aidl/client/BootControlClient.cpp
@@ -252,23 +252,12 @@ using namespace android::hardware::boot;
 
 class BootControlClientHIDL final : public BootControlClient {
   public:
-    BootControlClientHIDL(android::sp<V1_0::IBootControl> module_v1,
-                          android::sp<V1_1::IBootControl> module_v1_1,
-                          android::sp<V1_2::IBootControl> module_v1_2)
-        : module_v1_(module_v1), module_v1_1_(module_v1_1), module_v1_2_(module_v1_2) {
-        CHECK(module_v1_ != nullptr);
-    }
-    BootControlVersion GetVersion() const override {
-        if (module_v1_2_ != nullptr) {
-            return BootControlVersion::BOOTCTL_V1_2;
-        } else if (module_v1_1_ != nullptr) {
-            return BootControlVersion::BOOTCTL_V1_1;
-        } else {
-            return BootControlVersion::BOOTCTL_V1_0;
-        }
+    BootControlClientHIDL(android::sp<V1_2::IBootControl> module_v1_2) : module_(module_v1_2) {
+        CHECK(module_ != nullptr);
     }
+    BootControlVersion GetVersion() const override { return BootControlVersion::BOOTCTL_V1_2; }
     int32_t GetNumSlots() const override {
-        const auto ret = module_v1_->getNumberSlots();
+        const auto ret = module_->getNumberSlots();
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << " failed " << ret.description();
         }
@@ -276,7 +265,7 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
     int32_t GetCurrentSlot() const override {
-        const auto ret = module_v1_->getCurrentSlot();
+        const auto ret = module_->getCurrentSlot();
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << " failed " << ret.description();
         }
@@ -285,7 +274,7 @@ class BootControlClientHIDL final : public BootControlClient {
 
     std::string GetSuffix(int32_t slot) const override {
         std::string suffix;
-        const auto ret = module_v1_->getSuffix(
+        const auto ret = module_->getSuffix(
                 slot,
                 [&](const ::android::hardware::hidl_string& slotSuffix) { suffix = slotSuffix; });
         if (!ret.isOk()) {
@@ -295,7 +284,7 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
     std::optional<bool> IsSlotBootable(int32_t slot) const override {
-        const auto ret = module_v1_->isSlotBootable(slot);
+        const auto ret = module_->isSlotBootable(slot);
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << "(" << slot << ")" << " failed " << ret.description();
             return {};
@@ -309,11 +298,10 @@ class BootControlClientHIDL final : public BootControlClient {
 
     CommandResult MarkSlotUnbootable(int32_t slot) override {
         CommandResult result;
-        const auto ret =
-                module_v1_->setSlotAsUnbootable(slot, [&](const V1_0::CommandResult& error) {
-                    result.success = error.success;
-                    result.errMsg = error.errMsg;
-                });
+        const auto ret = module_->setSlotAsUnbootable(slot, [&](const V1_0::CommandResult& error) {
+            result.success = error.success;
+            result.errMsg = error.errMsg;
+        });
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << "(" << slot << ")" << " failed " << ret.description();
         }
@@ -322,7 +310,7 @@ class BootControlClientHIDL final : public BootControlClient {
 
     CommandResult SetActiveBootSlot(int32_t slot) override {
         CommandResult result;
-        const auto ret = module_v1_->setActiveBootSlot(slot, [&](const V1_0::CommandResult& error) {
+        const auto ret = module_->setActiveBootSlot(slot, [&](const V1_0::CommandResult& error) {
             result.success = error.success;
             result.errMsg = error.errMsg;
         });
@@ -334,7 +322,7 @@ class BootControlClientHIDL final : public BootControlClient {
 
     CommandResult MarkBootSuccessful() override {
         CommandResult result;
-        const auto ret = module_v1_->markBootSuccessful([&](const V1_0::CommandResult& error) {
+        const auto ret = module_->markBootSuccessful([&](const V1_0::CommandResult& error) {
             result.success = error.success;
             result.errMsg = error.errMsg;
         });
@@ -345,7 +333,7 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
     std::optional<bool> IsSlotMarkedSuccessful(int32_t slot) const override {
-        const auto ret = module_v1_->isSlotMarkedSuccessful(slot);
+        const auto ret = module_->isSlotMarkedSuccessful(slot);
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << "(" << slot << ")" << " failed " << ret.description();
             return {};
@@ -358,11 +346,11 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
     MergeStatus getSnapshotMergeStatus() const override {
-        if (module_v1_1_ == nullptr) {
+        if (module_ == nullptr) {
             LOG(ERROR) << __FUNCTION__ << " is unsupported, requires at least boot v1.1";
             return MergeStatus::UNKNOWN;
         }
-        const auto ret = module_v1_1_->getSnapshotMergeStatus();
+        const auto ret = module_->getSnapshotMergeStatus();
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << " failed " << ret.description();
         }
@@ -371,12 +359,12 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
     CommandResult SetSnapshotMergeStatus(MergeStatus merge_status) override {
-        if (module_v1_1_ == nullptr) {
+        if (module_ == nullptr) {
             return {.success = false,
                     .errMsg = "setSnapshotMergeStatus is unsupported, requires at least boot v1.1"};
         }
         const auto ret =
-                module_v1_1_->setSnapshotMergeStatus(static_cast<V1_1::MergeStatus>(merge_status));
+                module_->setSnapshotMergeStatus(static_cast<V1_1::MergeStatus>(merge_status));
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << "(" << merge_status << ")" << " failed "
                        << ret.description();
@@ -385,11 +373,11 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
     int32_t GetActiveBootSlot() const override {
-        if (module_v1_2_ == nullptr) {
+        if (module_ == nullptr) {
             LOG(ERROR) << __FUNCTION__ << " is unsupported, requires at least boot v1.2";
             return -1;
         }
-        const auto ret = module_v1_2_->getActiveBootSlot();
+        const auto ret = module_->getActiveBootSlot();
         if (!ret.isOk()) {
             LOG(ERROR) << __FUNCTION__ << " failed " << ret.description();
         }
@@ -397,9 +385,7 @@ class BootControlClientHIDL final : public BootControlClient {
     }
 
   private:
-    android::sp<V1_0::IBootControl> module_v1_;
-    android::sp<V1_1::IBootControl> module_v1_1_;
-    android::sp<V1_2::IBootControl> module_v1_2_;
+    android::sp<V1_2::IBootControl> module_;
 };
 
 std::unique_ptr<BootControlClient> BootControlClient::WaitForService() {
@@ -418,25 +404,19 @@ std::unique_ptr<BootControlClient> BootControlClient::WaitForService() {
     }
     LOG(INFO) << "AIDL IBootControl not available, falling back to HIDL.";
 
-    android::sp<V1_0::IBootControl> v1_0_module;
-    android::sp<V1_1::IBootControl> v1_1_module;
-    android::sp<V1_2::IBootControl> v1_2_module;
-    v1_0_module = V1_0::IBootControl::getService();
+    android::sp<V1_0::IBootControl> v1_0_module = V1_0::IBootControl::getService();
     if (v1_0_module == nullptr) {
         LOG(ERROR) << "Error getting bootctrl v1.0 module.";
         return nullptr;
     }
-    v1_1_module = V1_1::IBootControl::castFrom(v1_0_module);
-    v1_2_module = V1_2::IBootControl::castFrom(v1_0_module);
-    if (v1_2_module != nullptr) {
-        LOG(INFO) << "Using HIDL version 1.2 of IBootControl";
-    } else if (v1_1_module != nullptr) {
-        LOG(INFO) << "Using HIDL version 1.1 of IBootControl";
-    } else {
-        LOG(INFO) << "Using HIDL version 1.0 of IBootControl";
+    android::sp<V1_2::IBootControl> v1_2_module = V1_2::IBootControl::castFrom(v1_0_module);
+    if (v1_2_module == nullptr) {
+        LOG(ERROR) << "IBootControl HIDL versions 1.1 and earlier are no longer supported";
+        return nullptr;
     }
 
-    return std::make_unique<BootControlClientHIDL>(v1_0_module, v1_1_module, v1_2_module);
+    LOG(INFO) << "Using HIDL version 1.2 of IBootControl";
+    return std::make_unique<BootControlClientHIDL>(v1_2_module);
 }
 
 }  // namespace android::hal
diff --git a/boot/aidl/client/include/BootControlClient.h b/boot/aidl/client/include/BootControlClient.h
index 472e82e842..ae661899a5 100644
--- a/boot/aidl/client/include/BootControlClient.h
+++ b/boot/aidl/client/include/BootControlClient.h
@@ -32,7 +32,7 @@ struct CommandResult {
     constexpr bool IsOk() const { return success; }
 };
 
-enum class BootControlVersion { BOOTCTL_V1_0, BOOTCTL_V1_1, BOOTCTL_V1_2, BOOTCTL_AIDL };
+enum class BootControlVersion { BOOTCTL_V1_2, BOOTCTL_AIDL };
 
 class BootControlClient {
   public:
diff --git a/boot/aidl/default/Android.bp b/boot/aidl/default/Android.bp
index 2fd2dad615..9e24ff1810 100644
--- a/boot/aidl/default/Android.bp
+++ b/boot/aidl/default/Android.bp
@@ -50,6 +50,10 @@ cc_binary {
         "libboot_control",
     ],
 
+    vintf_fragment_modules: [
+        "android.hardware.boot-service.default.xml",
+    ],
+
     installable: false, // installed in APEX
 }
 
@@ -104,7 +108,4 @@ apex {
     prebuilts: [
         "android.hardware.boot-service.default.rc",
     ],
-    vintf_fragment_modules: [
-        "android.hardware.boot-service.default.xml",
-    ],
 }
diff --git a/broadcastradio/OWNERS b/broadcastradio/OWNERS
index 7c6aaca478..06634c9ac5 100644
--- a/broadcastradio/OWNERS
+++ b/broadcastradio/OWNERS
@@ -2,4 +2,3 @@
 
 ericjeong@google.com
 oscarazu@google.com
-xuweilin@google.com
diff --git a/broadcastradio/aidl/OWNERS b/broadcastradio/aidl/OWNERS
index 51a85e4883..11d686c7c4 100644
--- a/broadcastradio/aidl/OWNERS
+++ b/broadcastradio/aidl/OWNERS
@@ -1,3 +1,2 @@
-xuweilin@google.com
 oscarazu@google.com
 ericjeong@google.com
diff --git a/broadcastradio/aidl/android/hardware/broadcastradio/Metadata.aidl b/broadcastradio/aidl/android/hardware/broadcastradio/Metadata.aidl
index f1800dca0a..f693d8dbd2 100644
--- a/broadcastradio/aidl/android/hardware/broadcastradio/Metadata.aidl
+++ b/broadcastradio/aidl/android/hardware/broadcastradio/Metadata.aidl
@@ -72,8 +72,8 @@ union Metadata {
      *
      * <p>This is a generic field to cover any radio technology.
      *
-     * <p>Note: If the program name has the same content as dab*Name or ({@link Metadata#rdsPs},
-     * it may not be present, to preserve space - framework must repopulate
+     * <p>Note: If the program name has the same content as dab*Name, ({@link Metadata#rdsPs}
+     * or hd*Name*, it may not be present to preserve space - framework must repopulate
      * it on the client side.
      */
     String programName;
diff --git a/broadcastradio/aidl/vts/OWNERS b/broadcastradio/aidl/vts/OWNERS
index 51a85e4883..11d686c7c4 100644
--- a/broadcastradio/aidl/vts/OWNERS
+++ b/broadcastradio/aidl/vts/OWNERS
@@ -1,3 +1,2 @@
-xuweilin@google.com
 oscarazu@google.com
 ericjeong@google.com
diff --git a/camera/device/aidl/Android.bp b/camera/device/aidl/Android.bp
index 291ed0da84..f60f98058d 100644
--- a/camera/device/aidl/Android.bp
+++ b/camera/device/aidl/Android.bp
@@ -44,7 +44,7 @@ aidl_interface {
                 "android.hardware.common.fmq-V1",
                 "android.hardware.camera.common-V1",
                 "android.hardware.camera.metadata-V1",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
         {
@@ -54,7 +54,7 @@ aidl_interface {
                 "android.hardware.common.fmq-V1",
                 "android.hardware.camera.common-V1",
                 "android.hardware.camera.metadata-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
         {
@@ -64,7 +64,7 @@ aidl_interface {
                 "android.hardware.common.fmq-V1",
                 "android.hardware.camera.common-V1",
                 "android.hardware.camera.metadata-V3",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
 
diff --git a/camera/device/default/ExternalCameraDeviceSession.cpp b/camera/device/default/ExternalCameraDeviceSession.cpp
index 9c55ea9004..89cce11227 100644
--- a/camera/device/default/ExternalCameraDeviceSession.cpp
+++ b/camera/device/default/ExternalCameraDeviceSession.cpp
@@ -1099,10 +1099,13 @@ int ExternalCameraDeviceSession::configureV4l2StreamLocked(const SupportedV4L2Fo
     uint32_t bufferSize = fmt.fmt.pix.sizeimage;
     ALOGI("%s: V4L2 buffer size is %d", __FUNCTION__, bufferSize);
     uint32_t expectedMaxBufferSize = kMaxBytesPerPixel * fmt.fmt.pix.width * fmt.fmt.pix.height;
-    if ((bufferSize == 0) || (bufferSize > expectedMaxBufferSize)) {
-        ALOGE("%s: V4L2 buffer size: %u looks invalid. Expected maximum size: %u", __FUNCTION__,
-              bufferSize, expectedMaxBufferSize);
+    if (bufferSize == 0) {
+        ALOGE("%s: Invalid V4L2 buffer size = 0", __FUNCTION__);
         return -EINVAL;
+    } else if (bufferSize > expectedMaxBufferSize) {
+        ALOGW("%s: V4L2 buffer size: %u, larger than maximum size: %u, clamping to %u",
+              __FUNCTION__, bufferSize, expectedMaxBufferSize, expectedMaxBufferSize);
+        bufferSize = expectedMaxBufferSize;
     }
     mMaxV4L2BufferSize = bufferSize;
 
diff --git a/camera/device/default/ExternalCameraDeviceSession.h b/camera/device/default/ExternalCameraDeviceSession.h
index ed849316b4..7fee1a4588 100644
--- a/camera/device/default/ExternalCameraDeviceSession.h
+++ b/camera/device/default/ExternalCameraDeviceSession.h
@@ -153,7 +153,7 @@ class ExternalCameraDeviceSession : public BnCameraDeviceSession, public OutputT
         // when requesting 1st buffer from a stream.
         // TODO: consider a separate timeout for new vs. steady state?
         // TODO: or make sure framework is warming up the pipeline during configure new stream?
-        static const int kReqProcTimeoutMs = 66;
+        static const int kReqProcTimeoutMs = 132;
 
         static const int kReqWaitTimeoutMs = 33;
         static const int kReqWaitTimesWarn = 90;   // 33ms * 90 ~= 3 sec
diff --git a/compatibility_matrices/Android.bp b/compatibility_matrices/Android.bp
index 0d370607d3..1628cbc2d2 100644
--- a/compatibility_matrices/Android.bp
+++ b/compatibility_matrices/Android.bp
@@ -30,7 +30,20 @@ vintf_compatibility_matrix {
 }
 
 // Phony target that installs all system compatibility matrix files
-SYSTEM_MATRIX_DEPS = [
+// These are the FCMs for A17 devices. We drop support for FCM 5 from Android R
+// and drop support for HALs in FCM 6 from Android S.
+SYSTEM_MATRIX_DEPS_A17 = [
+    "framework_compatibility_matrix.6.android17.xml",
+    "framework_compatibility_matrix.7.xml",
+    "framework_compatibility_matrix.8.xml",
+    "framework_compatibility_matrix.202404.xml",
+    "framework_compatibility_matrix.202504.xml",
+    "framework_compatibility_matrix.202604.xml",
+    "framework_compatibility_matrix.device.xml",
+]
+
+// These are the FCMs for A16 that are still supported during QPRs
+SYSTEM_MATRIX_DEPS_A16 = [
     "framework_compatibility_matrix.5.xml",
     "framework_compatibility_matrix.6.xml",
     "framework_compatibility_matrix.7.xml",
@@ -42,14 +55,10 @@ SYSTEM_MATRIX_DEPS = [
 
 phony {
     name: "system_compatibility_matrix.xml",
-    required: SYSTEM_MATRIX_DEPS,
-    product_variables: {
-        release_aidl_use_unfrozen: {
-            required: [
-                "framework_compatibility_matrix.202604.xml",
-            ],
-        },
-    },
+    required: select(release_flag("RELEASE_AIDL_USE_UNFROZEN"), {
+        true: SYSTEM_MATRIX_DEPS_A17,
+        default: SYSTEM_MATRIX_DEPS_A16,
+    }),
 }
 
 // Product Compatibility Matrix
@@ -61,18 +70,15 @@ vintf_compatibility_matrix {
 }
 
 // Phony target that installs all framework compatibility matrix files (system + product)
-FRAMEWORK_MATRIX_DEPS = SYSTEM_MATRIX_DEPS + ["product_compatibility_matrix.xml"]
+FRAMEWORK_MATRIX_DEPS_A17 = SYSTEM_MATRIX_DEPS_A17 + ["product_compatibility_matrix.xml"]
+FRAMEWORK_MATRIX_DEPS_A16 = SYSTEM_MATRIX_DEPS_A16 + ["product_compatibility_matrix.xml"]
 
 phony {
     name: "framework_compatibility_matrix.xml",
-    required: FRAMEWORK_MATRIX_DEPS,
-    product_variables: {
-        release_aidl_use_unfrozen: {
-            required: [
-                "framework_compatibility_matrix.202604.xml",
-            ],
-        },
-    },
+    required: select(release_flag("RELEASE_AIDL_USE_UNFROZEN"), {
+        true: SYSTEM_MATRIX_DEPS_A17,
+        default: SYSTEM_MATRIX_DEPS_A16,
+    }),
 }
 
 ////////////////////////////////////////////
@@ -105,6 +111,19 @@ vintf_compatibility_matrix {
     ],
 }
 
+vintf_compatibility_matrix {
+    name: "framework_compatibility_matrix.6.android17.xml",
+    stem: "compatibility_matrix.6.android17.xml",
+    srcs: [
+        "compatibility_matrix.6.android17.xml",
+    ],
+    kernel_configs: [
+        "kernel_config_s_4.19",
+        "kernel_config_s_5.4",
+        "kernel_config_s_5.10",
+    ],
+}
+
 vintf_compatibility_matrix {
     name: "framework_compatibility_matrix.7.xml",
     stem: "compatibility_matrix.7.xml",
diff --git a/compatibility_matrices/build/vintf_compatibility_matrix.go b/compatibility_matrices/build/vintf_compatibility_matrix.go
index b8f2a14118..af3d5ce7b0 100644
--- a/compatibility_matrices/build/vintf_compatibility_matrix.go
+++ b/compatibility_matrices/build/vintf_compatibility_matrix.go
@@ -78,9 +78,8 @@ type vintfCompatibilityMatrixRule struct {
 	android.ModuleBase
 	properties vintfCompatibilityMatrixProperties
 
-	genFile                android.WritablePath
-	additionalDependencies android.WritablePaths
-	phonyOnly              bool
+	genFile   android.WritablePath
+	phonyOnly bool
 }
 
 func init() {
@@ -109,7 +108,7 @@ func (g *vintfCompatibilityMatrixRule) timestampFilePath(ctx android.ModuleConte
 	return android.GenPathWithExt(ctx, "vintf-xmllint", path, "ts")
 }
 
-func (g *vintfCompatibilityMatrixRule) generateValidateBuildAction(ctx android.ModuleContext, path android.Path, schema android.Path) {
+func (g *vintfCompatibilityMatrixRule) generateValidateBuildAction(ctx android.ModuleContext, path android.Path, schema android.Path) android.Path {
 	timestamp := g.timestampFilePath(ctx, path)
 	ctx.Build(pctx, android.BuildParams{
 		Rule:        xmllintXsd,
@@ -121,7 +120,7 @@ func (g *vintfCompatibilityMatrixRule) generateValidateBuildAction(ctx android.M
 			"xsd": schema.String(),
 		},
 	})
-	g.additionalDependencies = append(g.additionalDependencies, timestamp)
+	return timestamp
 }
 
 func (g *vintfCompatibilityMatrixRule) getSchema(ctx android.ModuleContext) android.OptionalPath {
@@ -166,9 +165,10 @@ func (g *vintfCompatibilityMatrixRule) GenerateAndroidBuildActions(ctx android.M
 		return
 	}
 
+	var validations android.Paths
 	inputPaths := android.PathsForModuleSrc(ctx, g.properties.Srcs)
 	for _, srcPath := range inputPaths {
-		g.generateValidateBuildAction(ctx, srcPath, schema.Path())
+		validations = append(validations, g.generateValidateBuildAction(ctx, srcPath, schema.Path()))
 	}
 
 	// No need to validate matrices from kernel configs because they are generated by
@@ -239,18 +239,19 @@ func (g *vintfCompatibilityMatrixRule) GenerateAndroidBuildActions(ctx android.M
 	g.genFile = android.PathForModuleGen(ctx, outputFilename)
 	frameworkRuleImplicits = append(frameworkRuleImplicits, inputPaths...)
 
+	validations = append(validations, g.generateValidateBuildAction(ctx, g.genFile, schema.Path()))
 	ctx.Build(pctx, android.BuildParams{
 		Rule:        assembleVintfRule,
 		Description: "Framework Compatibility Matrix",
 		Implicits:   frameworkRuleImplicits,
 		Output:      g.genFile,
+		Validations: validations,
 		Args: map[string]string{
 			"inputs":           strings.Join(inputPaths.Strings(), ":"),
 			"extraArgs":        strings.Join(extraArgs, " "),
 			"assembleVintfEnv": g.getAssembleVintfEnv(ctx),
 		},
 	})
-	g.generateValidateBuildAction(ctx, g.genFile, schema.Path())
 
 	ctx.InstallFile(android.PathForModuleInstall(ctx, "etc", relpath), outputFilename, g.genFile)
 }
@@ -297,9 +298,6 @@ func (g *vintfCompatibilityMatrixRule) AndroidMk() android.AndroidMkData {
 				if proptools.String(g.properties.Stem) != "" {
 					fmt.Fprintln(w, "LOCAL_MODULE_STEM :=", proptools.String(g.properties.Stem))
 				}
-				for _, path := range g.additionalDependencies {
-					fmt.Fprintln(w, "LOCAL_ADDITIONAL_DEPENDENCIES +=", path.String())
-				}
 			},
 		},
 	}
diff --git a/compatibility_matrices/compatibility_matrix.6.android17.xml b/compatibility_matrices/compatibility_matrix.6.android17.xml
new file mode 100644
index 0000000000..e8028a4d82
--- /dev/null
+++ b/compatibility_matrices/compatibility_matrix.6.android17.xml
@@ -0,0 +1,44 @@
+<compatibility-matrix version="1.0" type="framework" level="6">
+    <!--
+    Android 17 has special extended support for IRadio for devices launching
+    using FCM Level 6.
+    -->
+    <hal format="hidl">
+        <name>android.hardware.radio</name>
+        <version>1.6</version>
+        <interface>
+            <name>IRadio</name>
+            <instance>slot1</instance>
+            <instance>slot2</instance>
+            <instance>slot3</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.radio</name>
+        <version>1.2</version>
+        <interface>
+            <name>ISap</name>
+            <instance>slot1</instance>
+            <instance>slot2</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.radio.config</name>
+        <!--
+        See compatibility_matrix.4.xml on versioning of radio config HAL.
+        -->
+        <version>1.1</version>
+        <interface>
+            <name>IRadioConfig</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.radio.config</name>
+        <version>1.3</version>
+        <interface>
+            <name>IRadioConfig</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+</compatibility-matrix>
diff --git a/compatibility_matrices/exclude/fcm_exclude.cpp b/compatibility_matrices/exclude/fcm_exclude.cpp
index a2a13d1d17..efbdd0fd2d 100644
--- a/compatibility_matrices/exclude/fcm_exclude.cpp
+++ b/compatibility_matrices/exclude/fcm_exclude.cpp
@@ -100,14 +100,8 @@ bool ShouldCheckMissingHidlHalsInFcm(const std::string& packageAndVersion) {
             "android.hardware.power@1.1",
             "android.hardware.power@1.2",
             "android.hardware.power@1.3",
-            "android.hardware.vibrator@1.0",
-            "android.hardware.vibrator@1.1",
-            "android.hardware.vibrator@1.2",
-            "android.hardware.vibrator@1.3",
 
             // b/392700935 for HALs deprecated in R
-            "android.hardware.automotive.audiocontrol@1.0",
-            "android.hardware.automotive.audiocontrol@2.0",
             "android.hardware.boot@1.1",
             "android.hardware.contexthub@1.0",
             "android.hardware.contexthub@1.1",
@@ -120,12 +114,34 @@ bool ShouldCheckMissingHidlHalsInFcm(const std::string& packageAndVersion) {
             "android.hardware.soundtrigger@2.1",
             "android.hardware.soundtrigger@2.2",
             "android.hardware.tetheroffload.control@1.0",
-            "android.hardware.vr@1.0",
             "android.hardware.wifi.supplicant@1.0",
             "android.hardware.wifi.supplicant@1.1",
             "android.hardware.wifi@1.0",
             "android.hardware.wifi@1.1",
             "android.hardware.wifi@1.2",
+
+            // b/400531264 for HIDL HALs deprecated in S
+            "android.hardware.automotive.sv@1.0",
+            "android.hardware.bluetooth.audio@2.0",
+            "android.hardware.bluetooth.audio@2.1",
+            "android.hardware.contexthub@1.2",
+            "android.hardware.dumpstate@1.1",
+            "android.hardware.health@2.1",
+            "android.hardware.input.classifier@1.0",
+            "android.hardware.ir@1.0",
+            // TODO(b/410953636) these android.hardware.radio HALs
+            // are left in temporarily due to build failures. Uncomment when the
+            // bug is fixed.
+            //"android.hardware.radio.config@1.1",
+            //"android.hardware.radio.config@1.3",
+            //"android.hardware.radio@1.6",
+            "android.hardware.wifi.hostapd@1.0",
+            "android.hardware.wifi.hostapd@1.1",
+            "android.hardware.wifi.hostapd@1.2",
+            "android.hardware.wifi.hostapd@1.3",
+            "android.hardware.wifi.supplicant@1.2",
+            "android.hardware.wifi.supplicant@1.3",
+            "android.hardware.wifi.supplicant@1.4",
     };
 
     auto package_has_prefix = [&](const std::string& prefix) {
@@ -198,6 +214,12 @@ bool ShouldCheckMissingAidlHalsInFcm(const std::string& packageAndVersion) {
             // Deprecated HALs.
             "android.hardware.audio.sounddose@3",
             "android.hardware.bluetooth.audio@1",
+
+            // b/400531264 for AIDL HALs deprecated in S
+            "android.hardware.biometrics.face@1",
+            "android.hardware.biometrics.fingerprint@1",
+            "android.hardware.gnss@1",
+            "android.hardware.power@1",
     };
 
     auto package_has_prefix = [&](const std::string& prefix) {
diff --git a/contexthub/aidl/default/ContextHub.cpp b/contexthub/aidl/default/ContextHub.cpp
index 433617e9a3..5d77c0aeaf 100644
--- a/contexthub/aidl/default/ContextHub.cpp
+++ b/contexthub/aidl/default/ContextHub.cpp
@@ -245,11 +245,13 @@ ScopedAStatus ContextHub::HubInterface::registerEndpoint(const EndpointInfo& in_
     if (!mActive) {
         return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);
     }
+    if (in_endpoint.id.hubId != kInfo.hubId) {
+        return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
+    }
     std::unique_lock<std::mutex> lock(mEndpointMutex);
 
     for (const EndpointInfo& endpoint : mEndpoints) {
-        if ((endpoint.id.id == in_endpoint.id.id && endpoint.id.hubId == in_endpoint.id.hubId) ||
-            endpoint.name == in_endpoint.name) {
+        if (endpoint.id.id == in_endpoint.id.id || endpoint.name == in_endpoint.name) {
             return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
         }
     }
diff --git a/contexthub/aidl/vts/VtsAidlHalContextHubTargetTest.cpp b/contexthub/aidl/vts/VtsAidlHalContextHubTargetTest.cpp
index 900e6c9366..818faef667 100644
--- a/contexthub/aidl/vts/VtsAidlHalContextHubTargetTest.cpp
+++ b/contexthub/aidl/vts/VtsAidlHalContextHubTargetTest.cpp
@@ -96,6 +96,10 @@ class ContextHubEndpointAidl : public testing::TestWithParam<std::string> {
         mEndpointCb = sp<TestEndpointCallback>::make();
     }
 
+    void TearDown() override {
+        if (mHubInterface) mHubInterface->unregister();
+    }
+
     Status registerHub(int64_t id, sp<IEndpointCommunication>* hubInterface) {
         HubInfo info;
         info.hubId = id;
@@ -108,7 +112,7 @@ class ContextHubEndpointAidl : public testing::TestWithParam<std::string> {
             status.transactionError() == android::UNKNOWN_TRANSACTION) {
             return false;
         }
-        EXPECT_TRUE(status.isOk());
+        EXPECT_EQ(status.exceptionCode(), Status::EX_NONE);
         EXPECT_NE(mHubInterface, nullptr);
         if (!mHubInterface) {
             return false;
@@ -494,14 +498,25 @@ TEST_P(ContextHubTransactionTest, TestHostConnection) {
     hostEndpointInfo.type = HostEndpointInfo::Type::NATIVE;
     hostEndpointInfo.hostEndpointId = kHostEndpointId;
 
-    ASSERT_TRUE(mContextHub->onHostEndpointConnected(hostEndpointInfo).isOk());
-    ASSERT_TRUE(mContextHub->onHostEndpointDisconnected(kHostEndpointId).isOk());
+    Status status = mContextHub->onHostEndpointConnected(hostEndpointInfo);
+    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
+        status.transactionError() == android::UNKNOWN_TRANSACTION) {
+        GTEST_SKIP() << "Not supported -> old API; or not implemented";
+    } else {
+        ASSERT_TRUE(status.isOk());
+        ASSERT_TRUE(mContextHub->onHostEndpointDisconnected(kHostEndpointId).isOk());
+    }
 }
 
 TEST_P(ContextHubTransactionTest, TestInvalidHostConnection) {
     constexpr char16_t kHostEndpointId = 1;
-
-    ASSERT_TRUE(mContextHub->onHostEndpointDisconnected(kHostEndpointId).isOk());
+    Status status = mContextHub->onHostEndpointDisconnected(kHostEndpointId);
+    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
+        status.transactionError() == android::UNKNOWN_TRANSACTION) {
+        GTEST_SKIP() << "Not supported -> old API; or not implemented";
+    } else {
+      ASSERT_TRUE(status.isOk());
+    }
 }
 
 TEST_P(ContextHubTransactionTest, TestNanSessionStateChange) {
@@ -607,12 +622,12 @@ TEST_P(ContextHubEndpointAidlWithTestMode, RegisterHub) {
 
     sp<IEndpointCommunication> hub3;
     status = registerHub(kDefaultHubId + 1, &hub3);
-    ASSERT_FALSE(status.isOk());
     EXPECT_EQ(status.exceptionCode(), Status::EX_ILLEGAL_STATE);
 
     hub2->unregister();
     status = registerHub(kDefaultHubId + 1, &hub3);
     EXPECT_TRUE(status.isOk());
+    hub3->unregister();
 }
 
 TEST_P(ContextHubEndpointAidlWithTestMode, RegisterEndpoint) {
@@ -622,18 +637,29 @@ TEST_P(ContextHubEndpointAidlWithTestMode, RegisterEndpoint) {
 
     EndpointInfo endpointInfo;
     endpointInfo.id.id = 1;
-    endpointInfo.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo.id.hubId = kDefaultHubId;
     endpointInfo.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo.name = String16("Test host endpoint 1");
     endpointInfo.version = 42;
 
     Status status = mHubInterface->registerEndpoint(endpointInfo);
-    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
-        status.transactionError() == android::UNKNOWN_TRANSACTION) {
+    EXPECT_EQ(status.exceptionCode(), Status::EX_NONE);
+}
+
+TEST_P(ContextHubEndpointAidlWithTestMode, RegisterEndpointForDifferentHub) {
+    if (!registerDefaultHub()) {
         GTEST_SKIP() << "Not supported -> old API; or not implemented";
-    } else {
-        EXPECT_TRUE(status.isOk());
     }
+
+    EndpointInfo endpointInfo;
+    endpointInfo.id.id = 1;
+    endpointInfo.id.hubId = kDefaultHubId + 1;
+    endpointInfo.type = EndpointInfo::EndpointType::NATIVE;
+    endpointInfo.name = String16("Test host endpoint 1");
+    endpointInfo.version = 42;
+
+    Status status = mHubInterface->registerEndpoint(endpointInfo);
+    EXPECT_NE(status.exceptionCode(), Status::EX_NONE);
 }
 
 TEST_P(ContextHubEndpointAidlWithTestMode, RegisterEndpointSameNameFailure) {
@@ -643,26 +669,20 @@ TEST_P(ContextHubEndpointAidlWithTestMode, RegisterEndpointSameNameFailure) {
 
     EndpointInfo endpointInfo;
     endpointInfo.id.id = 2;
-    endpointInfo.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo.id.hubId = kDefaultHubId;
     endpointInfo.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo.name = String16("Test host endpoint 2");
     endpointInfo.version = 42;
 
     EndpointInfo endpointInfo2;
     endpointInfo2.id.id = 3;
-    endpointInfo2.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo2.id.hubId = kDefaultHubId;
     endpointInfo2.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo2.name = String16("Test host endpoint 2");
     endpointInfo2.version = 42;
 
     Status status = mHubInterface->registerEndpoint(endpointInfo);
-    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
-        status.transactionError() == android::UNKNOWN_TRANSACTION) {
-        GTEST_SKIP() << "Not supported -> old API; or not implemented";
-    } else {
-        EXPECT_TRUE(status.isOk());
-    }
-
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
     EXPECT_FALSE(mHubInterface->registerEndpoint(endpointInfo2).isOk());
 }
 
@@ -673,26 +693,20 @@ TEST_P(ContextHubEndpointAidlWithTestMode, RegisterEndpointSameIdFailure) {
 
     EndpointInfo endpointInfo;
     endpointInfo.id.id = 4;
-    endpointInfo.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo.id.hubId = kDefaultHubId;
     endpointInfo.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo.name = String16("Test host endpoint 4");
     endpointInfo.version = 42;
 
     EndpointInfo endpointInfo2;
     endpointInfo2.id.id = 4;
-    endpointInfo2.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo2.id.hubId = kDefaultHubId;
     endpointInfo2.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo2.name = String16("Test host endpoint - same ID test");
     endpointInfo2.version = 42;
 
     Status status = mHubInterface->registerEndpoint(endpointInfo);
-    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
-        status.transactionError() == android::UNKNOWN_TRANSACTION) {
-        GTEST_SKIP() << "Not supported -> old API; or not implemented";
-    } else {
-        EXPECT_TRUE(status.isOk());
-    }
-
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
     EXPECT_FALSE(mHubInterface->registerEndpoint(endpointInfo2).isOk());
 }
 
@@ -703,20 +717,15 @@ TEST_P(ContextHubEndpointAidlWithTestMode, UnregisterEndpoint) {
 
     EndpointInfo endpointInfo;
     endpointInfo.id.id = 6;
-    endpointInfo.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo.id.hubId = kDefaultHubId;
     endpointInfo.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo.name = String16("Test host endpoint 6");
     endpointInfo.version = 42;
 
     Status status = mHubInterface->registerEndpoint(endpointInfo);
-    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
-        status.transactionError() == android::UNKNOWN_TRANSACTION) {
-        GTEST_SKIP() << "Not supported -> old API; or not implemented";
-    } else {
-        EXPECT_TRUE(status.isOk());
-    }
-
-    EXPECT_TRUE(mHubInterface->unregisterEndpoint(endpointInfo).isOk());
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
+    status = mHubInterface->unregisterEndpoint(endpointInfo);
+    EXPECT_EQ(status.exceptionCode(), Status::EX_NONE);
 }
 
 TEST_P(ContextHubEndpointAidlWithTestMode, UnregisterEndpointNonexistent) {
@@ -726,18 +735,12 @@ TEST_P(ContextHubEndpointAidlWithTestMode, UnregisterEndpointNonexistent) {
 
     EndpointInfo endpointInfo;
     endpointInfo.id.id = 100;
-    endpointInfo.id.hubId = 0xCAFECAFECAFECAFE;
+    endpointInfo.id.hubId = kDefaultHubId;
     endpointInfo.type = EndpointInfo::EndpointType::NATIVE;
     endpointInfo.name = String16("Test host endpoint 100");
     endpointInfo.version = 42;
 
-    Status status = mHubInterface->unregisterEndpoint(endpointInfo);
-    if (status.exceptionCode() == Status::EX_UNSUPPORTED_OPERATION ||
-        status.transactionError() == android::UNKNOWN_TRANSACTION) {
-        GTEST_SKIP() << "Not supported -> old API; or not implemented";
-    } else {
-        EXPECT_FALSE(status.isOk());
-    }
+    EXPECT_FALSE(mHubInterface->unregisterEndpoint(endpointInfo).isOk());
 }
 
 TEST_P(ContextHubEndpointAidlWithTestMode, OpenEndpointSessionInvalidRange) {
@@ -748,11 +751,12 @@ TEST_P(ContextHubEndpointAidlWithTestMode, OpenEndpointSessionInvalidRange) {
     // Register the endpoint
     EndpointInfo initiatorEndpoint;
     initiatorEndpoint.id.id = 7;
-    initiatorEndpoint.id.hubId = 0xCAFECAFECAFECAFE;
+    initiatorEndpoint.id.hubId = kDefaultHubId;
     initiatorEndpoint.type = EndpointInfo::EndpointType::NATIVE;
     initiatorEndpoint.name = String16("Test host endpoint 7");
     initiatorEndpoint.version = 42;
-    EXPECT_TRUE(mHubInterface->registerEndpoint(initiatorEndpoint).isOk());
+    Status status = mHubInterface->registerEndpoint(initiatorEndpoint);
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
 
     // Find the destination, if it exists
     std::vector<EndpointInfo> endpoints;
@@ -773,7 +777,8 @@ TEST_P(ContextHubEndpointAidlWithTestMode, OpenEndpointSessionInvalidRange) {
     // Request the range
     constexpr int32_t requestedRange = 100;
     std::array<int32_t, 2> range;
-    ASSERT_TRUE(mHubInterface->requestSessionIdRange(requestedRange, &range).isOk());
+    status = mHubInterface->requestSessionIdRange(requestedRange, &range);
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
     EXPECT_EQ(range.size(), 2);
     EXPECT_GE(range[1] - range[0] + 1, requestedRange);
 
@@ -795,11 +800,12 @@ TEST_P(ContextHubEndpointAidlWithTestMode, OpenEndpointSessionAndSendMessageEcho
     // Register the endpoint
     EndpointInfo initiatorEndpoint;
     initiatorEndpoint.id.id = 8;
-    initiatorEndpoint.id.hubId = 0xCAFECAFECAFECAFE;
+    initiatorEndpoint.id.hubId = kDefaultHubId;
     initiatorEndpoint.type = EndpointInfo::EndpointType::NATIVE;
     initiatorEndpoint.name = String16("Test host endpoint 7");
     initiatorEndpoint.version = 42;
-    EXPECT_TRUE(mHubInterface->registerEndpoint(initiatorEndpoint).isOk());
+    Status status = mHubInterface->registerEndpoint(initiatorEndpoint);
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
 
     // Find the destination, if it exists
     std::vector<EndpointInfo> endpoints;
@@ -820,18 +826,18 @@ TEST_P(ContextHubEndpointAidlWithTestMode, OpenEndpointSessionAndSendMessageEcho
     // Request the range
     constexpr int32_t requestedRange = 100;
     std::array<int32_t, 2> range;
-    ASSERT_TRUE(mHubInterface->requestSessionIdRange(requestedRange, &range).isOk());
+    status = mHubInterface->requestSessionIdRange(requestedRange, &range);
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
     EXPECT_EQ(range.size(), 2);
     EXPECT_GE(range[1] - range[0] + 1, requestedRange);
 
     // Open the session
     mEndpointCb->resetWasOnEndpointSessionOpenCompleteCalled();
     int32_t sessionId = range[0];
-    ASSERT_TRUE(mHubInterface
-                        ->openEndpointSession(sessionId, destinationEndpoint->id,
-                                              initiatorEndpoint.id,
-                                              /* in_serviceDescriptor= */ kEchoServiceName)
-                        .isOk());
+    status = mHubInterface->openEndpointSession(sessionId, destinationEndpoint->id,
+                                                initiatorEndpoint.id,
+                                                /* in_serviceDescriptor= */ kEchoServiceName);
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
     mEndpointCb->getCondVar().wait(lock);
     EXPECT_TRUE(mEndpointCb->wasOnEndpointSessionOpenCompleteCalled());
 
@@ -840,7 +846,8 @@ TEST_P(ContextHubEndpointAidlWithTestMode, OpenEndpointSessionAndSendMessageEcho
     message.flags = 0;
     message.sequenceNumber = 0;
     message.content.push_back(42);
-    ASSERT_TRUE(mHubInterface->sendMessageToEndpoint(sessionId, message).isOk());
+    status = mHubInterface->sendMessageToEndpoint(sessionId, message);
+    ASSERT_EQ(status.exceptionCode(), Status::EX_NONE);
 
     // Check for echo
     mEndpointCb->getCondVar().wait(lock);
diff --git a/current.txt b/current.txt
index 754093f2b1..bb8fdb6338 100644
--- a/current.txt
+++ b/current.txt
@@ -154,9 +154,6 @@ dee83e5c864fbbee8f02448d0800be32f06856386b9f907bc5d952208c9434f9 android.hardwar
 4ef57499273f38bdbdd0c15e56ee7a4bc5f18a5644092170a531df3541d9e015 android.hardware.usb@1.0::IUsb
 4be7881e411ba42784bf5b7354c14ae0cf161004d39433aaecaab0d19ea99354 android.hardware.usb@1.0::IUsbCallback
 f7e6e747910a3cd0a35846141e3b990a6a612a297b2b70ccd5740b646a450a8c android.hardware.usb@1.0::types
-06ea64cc3565777f3b259e400ffa7100d07f3827ad9357b0c5d3c651384e5553 android.hardware.vibrator@1.0::IVibrator
-0fecd34ae64f32eff6aa615fd662349242c0b8b6e303ef05a7cb5776c732f413 android.hardware.vibrator@1.0::types
-4b962968a7df4ab104d1315d66a0a7348a713fecbb5d2c1b23688494458f37ce android.hardware.vr@1.0::IVr
 b9be36719a8ad534000a51ea07be91be94c405bf1e038ae825acf65087ffd378 android.hardware.wifi@1.0::IWifi
 ee0224ee18813506d9d6f13d8c8e4679f053c290a443a52a7c52a5d3c852262b android.hardware.wifi@1.0::IWifiApIface
 f3eecc489deb4c74892f59eb7adb769063bd5c354ac132b626a5f42b363d36bc android.hardware.wifi@1.0::IWifiChip
@@ -216,8 +213,6 @@ d8aae01606bfd34bf2fb9a59cadc016f46f318e56cddb8f15a945c5b3c1222bc android.hardwar
 b30ef02ef26ff804e2f6acf1201bc141b59e134e6a0338562284491102cb13e3 android.hardware.usb@1.1::IUsb
 13a580e35af01270a1e9774177c51db51d8672e6139ba00851e654e68a4d7dff android.hardware.usb@1.1::IUsbCallback
 f0ed667288908c08fced570bd1f3c4a0f236aa927938e805f0d9fece525da81e android.hardware.usb@1.1::types
-f95a1e85612f2d0d616eacd2eb63c52d10dfa889f165df57697c30e1f47b4785 android.hardware.vibrator@1.1::IVibrator
-246fb9d9e2b4800aeb0adc3cdbaa15d0321ebab54b7bd1ab87da5b67c7b0b064 android.hardware.vibrator@1.1::types
 9bc43413b80cd0c59a022e93da1448dcb82dd10c6dd31932df4659e4bdcb1368 android.hardware.weaver@1.0::IWeaver
 7728b0393a2ed9796537d4165c7d95407e9d8cb447a647b545fdfe06a28689e7 android.hardware.weaver@1.0::types
 bb7c96762d0aa3ddb874c8815bacdd3cbc8fb87ea2f82b928bc29e24a3593055 android.hardware.wifi.offload@1.0::IOffload
@@ -305,7 +300,6 @@ a91b547f5922f39fe4231d97fac1c3825c1c1b0c8ef7a5136689ceed37e8bfe9 android.hardwar
 e88e520f8c98a62fccd8d5316c6687808f775de145d1405a7a9a66587ee6a001 android.hardware.audio.effect@4.0::IVirtualizerEffect
 fe28829dab10d171783b79ac9cc45412739f8ff275e90228d7c6370ef189b859 android.hardware.audio.effect@4.0::IVisualizerEffect
 21c8a702579356480236c6851b5b2c16b9bd369ce12bdd6ffdc4626a89f34f73 android.hardware.audio.effect@4.0::types
-a0f93c768c353cecee6237fe479bce47404eb10b629fafe07e32a054fd67f2af android.hardware.automotive.audiocontrol@1.0::IAudioControl
 f2904a4c108ad1b93eb2fa4e43b82bd01ce1ff26156316e49d1d9fc80dfecaad android.hardware.automotive.evs@1.0::IEvsCamera
 94cba6ad04c83aa840de2ed52b74ba2126a26dd960225e61ac36703315279a80 android.hardware.automotive.evs@1.0::IEvsCameraStream
 5ea36fb043d9e3b413219de3dfd7b046b48af4fda39f167f3528652e986cb76d android.hardware.automotive.evs@1.0::IEvsDisplay
@@ -380,8 +374,6 @@ b4f507b4dc9b5cd5f0e4445926acb7d94525ae60dc307b3951142283632207b6 android.hardwar
 8ddfa7542772cc7bca19972b2d856264efa31914bfd098aeb7c2079d950194cb android.hardware.usb.gadget@1.0::IUsbGadget
 ad0a620cda08f01b151c30cb7afa23b0637cc84340cf8dec00ac8e32cf54a8db android.hardware.usb.gadget@1.0::IUsbGadgetCallback
 51fc20f223561ac3a32ace3217837ef3860265bd91c8b7ae3859532caef9bc39 android.hardware.usb.gadget@1.0::types
-1bfc9fd9536ed09f04bcaf222a332bc919f1565d4d08bddccdebe1bfca8f01b5 android.hardware.vibrator@1.2::IVibrator
-a0aefa29881235c21e4761d15c55edc35ef85c2e0d9e01d0966176d1dbf5f811 android.hardware.vibrator@1.2::types
 8bc75a0dfac15c6f87ffec950b76c7d7de30d516b54e8e0b1f3c0ff9c7c6873b android.hardware.wifi@1.2::IWifi
 780c16fdeda13b779d993953a67f7ca578c938a172a9424c1c715ae81bc40fd7 android.hardware.wifi@1.2::IWifiChip
 167af870fdb87e1cbbaa0fa62ef35e1031caad20dd1ba695983dedb1e9993486 android.hardware.wifi@1.2::IWifiChipEventCallback
@@ -427,7 +419,6 @@ e78cf871f9fd1c072874e481e06e18e2681763cf2aa38c1fd777d53bab4eb69b android.hardwar
 c28859a334c1f540dea0a7d4f0baef0551ba76a3232f53c936196543ee35bc4d android.hardware.sensors@1.0::types # b/133264933
 3d01e29e8129186f7567c4f9c8bee7480a0768e587b1be9b28adb0a6cbec6bf2 android.hardware.tv.cec@1.0::types
 1722ad002317b1fae1400de709e90f442d94ef22864e05f7a12af48c32e8edc8 android.hardware.usb@1.1::types
-29c8da7a13c40d488f569c812441d5754ee45bdcdb8ce6564f524b708d10a057 android.hardware.vibrator@1.1::types
 
 # HALs released in Android Q
 438dc52ab820befb7a11e953e82110f0d8c91cdf96ef62be921efc64f5a3d580 android.hardware.atrace@1.0::IAtraceDevice
@@ -568,8 +559,6 @@ b47f90302595874dfddb19bd05a054727bf18b3a930bc810ea14957b859ae8bf android.hardwar
 61bc302e7c974c59b25898c585c6e9685e8a81021b1bed3eedf5224198f2785a android.hardware.usb@1.2::IUsb
 46996cd2a1c66261a75a1f6ecada77eeb5861eb264fa39b996548fe0a7f22dd3 android.hardware.usb@1.2::IUsbCallback
 3bbaa8cbc5d6b1da21f5509b2b641e05fc7eeca1354751eb1bb3cf37f89aa32f android.hardware.usb@1.2::types
-0f7ff73793548d5154014059b7e0fe9ef6355d32218ace157954d02055f5248b android.hardware.vibrator@1.3::IVibrator
-2e313dc27a1327a29862ab3e085917f75c9e996f7c8df5a0ce37b9a0ed076b80 android.hardware.vibrator@1.3::types
 f19832856a3f53ced5ef91d3cc630a57fb7f4d4ce15f364dbed09099b89f6830 android.hardware.wifi@1.3::IWifi
 64be084b6e1ef330b75fa916593dc0b94b0ec7a16d5cfaa5a31e6c9143c8288d android.hardware.wifi@1.3::IWifiChip
 3bef30e8b61ab050c0f6fd26572712be5ebb7707d624c9aa6c74bbb9d6a5b4a9 android.hardware.wifi@1.3::IWifiStaIface
@@ -584,7 +573,6 @@ efbb061c969fa9553d243da6ee23b83fe5d4aa663a7b8896adc52e2b015bc2f3 android.hardwar
 cfa81f229b69f9011c58f48264fcb552447430fe68610eac514e811e65bc306a android.hardware.wifi.supplicant@1.2::types
 
 # ABI preserving changes to HALs during Android R
-c3ec182ce325862b7d79e526f3e170c02cfee1497ed309d7c60d0de4ca636b0b android.hardware.automotive.audiocontrol@1.0::IAudioControl
 1b6d0927615ddbf4c56a993fa1845bca15543e315fb6f48c77276e2fa2918ac5 android.hardware.automotive.evs@1.0::IEvsCamera
 3901859d36b7b4d32910d61cd1e8982b0ffeb8fb77b457ac6349e8bf1abcd595 android.hardware.automotive.evs@1.0::IEvsCameraStream
 578f640c653726d58f99c84a7e1bb63862e21ef7cbb4f7d95c3cc62de00dca35 android.hardware.automotive.evs@1.0::IEvsDisplay
@@ -643,11 +631,6 @@ dd377f404a8e71f6191d295e10067db629b0f0c28e594af906f2bea5d87fe2cc android.hardwar
 282193799d60bff27a84c65a36218c1e7d8f582f5828e2e059383d1b90aa56bd android.hardware.audio.effect@6.0::IVirtualizerEffect
 0868e00f7c5ee16723bda1a8f57099763d04100ae7126a1c2d3a9a87c844a7e8 android.hardware.audio.effect@6.0::IVisualizerEffect
 817930d58412d662cb45e641c50cb62c727e4a3e3ffe7029a53cad9677b97d58 android.hardware.audio.effect@6.0::types
-ca515ff4b63c80cf5ad7b3395c997c57d6c56157361f6c367d1c96f23cc4860a android.hardware.automotive.audiocontrol@1.0::types
-4bc4e8087f5c389f013370ed68bc8a1a29cb2f203237937697f35e005a5ad0b4 android.hardware.automotive.audiocontrol@2.0::IAudioControl
-37ef585d6687cb31e35c67ab456140d70edba9c4333ce5a6ddd70e636e985773 android.hardware.automotive.audiocontrol@2.0::ICloseHandle
-3cf3e5e48ba2642052bbccc1aa4e8bb142933ac960ff40eeedd16e4fe452e7a5 android.hardware.automotive.audiocontrol@2.0::IFocusListener
-44c03f3341939524b5f5acb6680f8a91924d02e335a32840d56597616db7f1ea android.hardware.automotive.audiocontrol@2.0::types
 949a2582c9efa3f6f631f56120eae3f02313f251dbf9246c327e419cdf0652a2 android.hardware.automotive.can@1.0::ICanBus
 43cddb1907a30343bced68946884416ea25ab14ae2df4709357528b2bedba84c android.hardware.automotive.can@1.0::ICanController
 272e826492b27b0dbdeda408e84a41ae43e98f29e57995b6452ded270aae4eee android.hardware.automotive.can@1.0::ICanErrorListener
diff --git a/drm/OWNERS b/drm/OWNERS
index c06472a330..8cf60e1111 100644
--- a/drm/OWNERS
+++ b/drm/OWNERS
@@ -1,5 +1,5 @@
 # Bug component: 49079
-
+# Please assign bugs to android-drm-team@
 conglin@google.com
 fredgc@google.com
 juce@google.com
diff --git a/drm/aidl/vts/AndroidTest.xml b/drm/aidl/vts/AndroidTest.xml
index 9e5b41a048..e6ead4c231 100644
--- a/drm/aidl/vts/AndroidTest.xml
+++ b/drm/aidl/vts/AndroidTest.xml
@@ -20,6 +20,10 @@
 
     <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
 
+    <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
+      <option name="run-command" value="svc wifi enable" />
+    </target_preparer>
+
     <target_preparer class="com.android.tradefed.targetprep.WifiPreparer" >
         <option name="verify-only" value="true" />
     </target_preparer>
diff --git a/gatekeeper/aidl/android/hardware/gatekeeper/IGatekeeper.aidl b/gatekeeper/aidl/android/hardware/gatekeeper/IGatekeeper.aidl
index 215c6e6860..e8b3d018bf 100644
--- a/gatekeeper/aidl/android/hardware/gatekeeper/IGatekeeper.aidl
+++ b/gatekeeper/aidl/android/hardware/gatekeeper/IGatekeeper.aidl
@@ -70,10 +70,14 @@ interface IGatekeeper {
      * or password, with the private key used only for enrolling authentication
      * factor data.
      *
-     * If there was already a password enrolled, current password handle must be
-     * passed in currentPasswordHandle, and current password must be passed in
-     * currentPassword. Valid currentPassword must verify() against
-     * currentPasswordHandle.
+     * If an already-enrolled password handle is included in currentPasswordHandle (a "trusted
+     * re-enroll"), then currentPassword must also be included, and must verify() against
+     * currentPasswordHandle.  On success, the response must re-use the same secure user ID as
+     * in the previous enrollment.
+     *
+     * If currentPasswordHandle and currentHandle are empty, then the desiredPassword
+     * should be enrolled (an "untrusted re-enroll"), even if there is an existing enrollment
+     * for the user.  A fresh secure user ID must be returned in the response.
      *
      * Service status return:
      *
@@ -111,6 +115,10 @@ interface IGatekeeper {
      * Implementations of this module may retain the result of this call
      * to attest to the recency of authentication.
      *
+     * Verification of a correct providedPassword and enrolledPasswordHandle
+     * should succeed even after factory reset, provided that deleteAllUsers()
+     * has not been invoked, to support factory reset protection.
+     *
      * On success, returns verification token in response.data, which shall be
      * usable to attest password verification to other trusted services.
      *
diff --git a/gatekeeper/aidl/software/Android.bp b/gatekeeper/aidl/software/Android.bp
index d24446118e..616ff8336e 100644
--- a/gatekeeper/aidl/software/Android.bp
+++ b/gatekeeper/aidl/software/Android.bp
@@ -7,6 +7,12 @@ package {
     default_applicable_licenses: ["hardware_interfaces_license"],
 }
 
+// A non-secure implementation of Gatekeeper in C++, which also implements the
+// `ISharedSecret` HAL.
+//
+// A real device is required to run the TA code in a secure environment, as
+// per CDD 9.11 [C-1-3]: "MUST perform the lock screen authentication in the
+// isolated execution environment".
 cc_binary {
     name: "android.hardware.gatekeeper-service.nonsecure",
     cflags: [
diff --git a/gatekeeper/aidl/software/rust/Android.bp b/gatekeeper/aidl/software/rust/Android.bp
new file mode 100644
index 0000000000..bb7112e89c
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/Android.bp
@@ -0,0 +1,80 @@
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "hardware_interfaces_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["hardware_interfaces_license"],
+}
+
+// A non-secure implementation of Gatekeeper in Rust, which also implements the
+// `ISharedSecret` HAL.
+//
+// DO NOT USE ON A REAL DEVICE!
+//
+// A real device is required to run the TA code in a secure environment, as
+// per CDD 9.11 [C-1-3]: "MUST perform the lock screen authentication in the
+// isolated execution environment".
+rust_binary {
+    name: "android.hardware.gatekeeper-service.rust.nonsecure",
+    installable: false, // installed in APEX
+    relative_install_path: "hw",
+    rustlibs: [
+        "libandroid_logger",
+        "libbinder_rs",
+        "liblog_rust",
+        "libgk_hal_with_sharedsecret",
+        "libgk_ta_nonsecure",
+    ],
+    srcs: [
+        "main.rs",
+    ],
+    vendor: true,
+}
+
+prebuilt_etc {
+    name: "gatekeeper_rust_nonsecure_vintf",
+    srcs: [
+        "android.hardware.gatekeeper-service.nonsecure.xml",
+        "android.hardware.security.sharedsecret-gatekeeper.xml",
+    ],
+    sub_dir: "vintf",
+    installable: false,
+}
+
+prebuilt_etc {
+    name: "android.hardware.gatekeeper-service.rust.nonsecure.rc",
+    src: "android.hardware.gatekeeper-service.rust.nonsecure.rc",
+    installable: false,
+}
+
+apex {
+    name: "com.android.hardware.gatekeeper.rust.nonsecure",
+    binaries: ["android.hardware.gatekeeper-service.rust.nonsecure"],
+    certificate: ":com.google.cf.apex.certificate",
+    file_contexts: "file_contexts",
+    key: "com.google.cf.apex.key",
+    manifest: "manifest.json",
+    prebuilts: [
+        "gatekeeper_nonsecure_vintf",
+        "android.hardware.gatekeeper-service.rust.nonsecure.rc",
+    ],
+    updatable: false,
+    vendor: true,
+}
+
+rust_library {
+    name: "libgk_ta_nonsecure",
+    crate_name: "gk_ta_nonsecure",
+    vendor_available: true,
+    host_supported: true,
+    lints: "android",
+    rustlibs: [
+        "liblibc",
+        "liblog_rust",
+        "libgk_boringssl",
+        "libgk_ta",
+        "libgk_wire",
+    ],
+    srcs: ["ta/lib.rs"],
+}
diff --git a/gatekeeper/aidl/software/rust/android.hardware.gatekeeper-service.nonsecure.xml b/gatekeeper/aidl/software/rust/android.hardware.gatekeeper-service.nonsecure.xml
new file mode 100644
index 0000000000..c35421ea27
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/android.hardware.gatekeeper-service.nonsecure.xml
@@ -0,0 +1,10 @@
+<manifest version="1.0" type="device">
+    <hal format="aidl">
+        <name>android.hardware.gatekeeper</name>
+        <version>1</version>
+        <interface>
+            <name>IGatekeeper</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+</manifest>
diff --git a/gatekeeper/aidl/software/rust/android.hardware.gatekeeper-service.rust.nonsecure.rc b/gatekeeper/aidl/software/rust/android.hardware.gatekeeper-service.rust.nonsecure.rc
new file mode 100644
index 0000000000..0593168e80
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/android.hardware.gatekeeper-service.rust.nonsecure.rc
@@ -0,0 +1,8 @@
+on post-fs-data
+    mkdir /data/vendor/gatekeeper 0700 system system
+    mkdir /data/vendor/gatekeeper/nonsecure 0700 system system
+
+service vendor.gatekeeper_nonsecure /apex/com.android.hardware.gatekeeper/bin/hw/android.hardware.gatekeeper-service.rust.nonsecure
+    class hal
+    user system
+    group system
diff --git a/gatekeeper/aidl/software/rust/android.hardware.security.sharedsecret-gatekeeper.xml b/gatekeeper/aidl/software/rust/android.hardware.security.sharedsecret-gatekeeper.xml
new file mode 100644
index 0000000000..5d94985004
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/android.hardware.security.sharedsecret-gatekeeper.xml
@@ -0,0 +1,6 @@
+<manifest version="1.0" type="device">
+    <hal format="aidl">
+        <name>android.hardware.security.sharedsecret</name>
+        <fqname>ISharedSecret/gatekeeper</fqname>
+    </hal>
+</manifest>
diff --git a/gatekeeper/aidl/software/rust/file_contexts b/gatekeeper/aidl/software/rust/file_contexts
new file mode 100644
index 0000000000..61a2eed7fe
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/file_contexts
@@ -0,0 +1,3 @@
+(/.*)?                                                          u:object_r:vendor_file:s0
+/etc(/.*)?                                                      u:object_r:vendor_configs_file:s0
+/bin/hw/android\.hardware\.gatekeeper-service\.rust\.nonsecure  u:object_r:hal_gatekeeper_default_exec:s0
diff --git a/gatekeeper/aidl/software/rust/main.rs b/gatekeeper/aidl/software/rust/main.rs
new file mode 100644
index 0000000000..00fd026ca6
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/main.rs
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//! Default (insecure) implementation of the Gatekeeper HAL.
+//!
+//! This implementation of the HAL is only intended to allow testing and policy compliance.  A real
+//! implementation **must implement the TA in a secure environment**, as per CDD 9.11 [C-1-3]: "MUST
+//! perform the lock screen authentication in the isolated execution environment".
+//!
+//! The additional device-specific components that are required for a real implementation of
+//! Gatekeeper that is based on the Rust reference implementation are described in
+//! system/gatekeeper/rust/README.md.
+
+use gk_hal::channel::SerializedChannel;
+use log::{error, info, warn};
+use std::fs;
+use std::sync::{mpsc, Arc, Mutex};
+
+/// Location of Gatekeeper failure records.  This directory must exist for this implementation of
+/// Gatekeeper to run.
+static GK_DIR: &str = "/data/vendor/gatekeeper/nonsecure";
+
+/// Name of `IGatekeeper` binder device instance.
+static GK_INSTANCE: &str = "default";
+/// Name of Gatekeeper `ISharedSecret` binder device instance.
+static SS_INSTANCE: &str = "gatekeeper";
+
+static GK_SERVICE: &str = "android.hardware.gatekeeper.IGatekeeper";
+static SECRET_SERVICE: &str = "android.hardware.security.sharedsecret.ISharedSecret";
+
+/// Local error type for failures in the HAL service.
+#[derive(Debug, Clone)]
+struct HalServiceError(String);
+
+impl From<String> for HalServiceError {
+    fn from(s: String) -> Self {
+        Self(s)
+    }
+}
+
+fn main() {
+    if let Err(HalServiceError(e)) = inner_main() {
+        panic!("HAL service failed: {:?}", e);
+    }
+}
+
+fn inner_main() -> Result<(), HalServiceError> {
+    // Initialize Android logging.
+    android_logger::init_once(
+        android_logger::Config::default()
+            .with_tag("gatekeeper-hal-nonsecure")
+            .with_max_level(log::LevelFilter::Info)
+            .with_log_buffer(android_logger::LogId::System),
+    );
+    // Redirect panic messages to logcat.
+    std::panic::set_hook(Box::new(|panic_info| {
+        error!("{}", panic_info);
+    }));
+
+    warn!("Insecure Gatekeeper HAL service is starting.");
+
+    info!("Starting thread pool");
+    binder::ProcessState::start_thread_pool();
+
+    // Store failure records on disk under a pre-existing directory.
+    //
+    // This is insecure because it allows a root user in Android to reset failure counts, allowing
+    // infinite password retries.
+    let dir = std::path::PathBuf::from(GK_DIR);
+    let exists = fs::exists(&dir)
+        .map_err(|e| HalServiceError(format!("Failed to determine if {dir:?} exists: {e:?}")))?;
+    if !exists {
+        return Err(HalServiceError(format!(
+            "Required directory {dir:?} does not exist!"
+        )));
+    }
+    if !dir.is_dir() {
+        return Err(HalServiceError(format!(
+            "Required directory {dir:?} is not a directory!"
+        )));
+    }
+
+    // Create a TA in-process, which acts as a local channel for communication.
+    let channel = Arc::new(Mutex::new(LocalInsecureTa::new(dir)));
+
+    let ss_service = gk_hal::sharedsecret::SharedSecretService::new_as_binder(channel.clone());
+    let service_name = format!("{SECRET_SERVICE}/{SS_INSTANCE}");
+    binder::add_service(&service_name, ss_service.as_binder()).map_err(|e| {
+        HalServiceError(format!("Failed to register service {service_name}: {e:?}"))
+    })?;
+
+    let gk_service = gk_hal::GatekeeperService::new_as_binder(channel);
+    let service_name = format!("{GK_SERVICE}/{GK_INSTANCE}");
+    binder::add_service(&service_name, gk_service.as_binder()).map_err(|e| {
+        HalServiceError(format!("Failed to register service {service_name}: {e:?}"))
+    })?;
+
+    info!("Successfully registered Gatekeeper HAL service");
+    binder::ProcessState::join_thread_pool();
+    info!("Gatekeeper HAL service is terminating"); // should not reach here
+    Ok(())
+}
+
+/// Implementation of the Gatekeeper TA that runs locally in-process (and which is therefore
+/// insecure).
+#[derive(Debug)]
+pub struct LocalInsecureTa {
+    in_tx: mpsc::Sender<Vec<u8>>,
+    out_rx: mpsc::Receiver<Vec<u8>>,
+}
+
+impl LocalInsecureTa {
+    /// Create a new (insecure) instance.
+    pub fn new(dir: std::path::PathBuf) -> Self {
+        // Create a pair of channels to communicate with the TA thread.
+        let (in_tx, in_rx) = mpsc::channel();
+        let (out_tx, out_rx) = mpsc::channel();
+
+        // The TA code expects to run single threaded, so spawn a thread to run it in.
+        std::thread::spawn(move || {
+            let mut ta = gk_ta_nonsecure::build_ta(&dir);
+            loop {
+                let req_data: Vec<u8> = in_rx.recv().expect("failed to receive next req");
+                let rsp_data = ta.process(&req_data);
+                out_tx.send(rsp_data).expect("failed to send out rsp");
+            }
+        });
+        Self { in_tx, out_rx }
+    }
+}
+
+impl SerializedChannel for LocalInsecureTa {
+    const MAX_SIZE: usize = usize::MAX;
+
+    fn execute(&mut self, req_data: &[u8]) -> binder::Result<Vec<u8>> {
+        self.in_tx
+            .send(req_data.to_vec())
+            .expect("failed to send in request");
+        Ok(self.out_rx.recv().expect("failed to receive response"))
+    }
+}
diff --git a/gatekeeper/aidl/software/rust/manifest.json b/gatekeeper/aidl/software/rust/manifest.json
new file mode 100644
index 0000000000..d0def3666d
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/manifest.json
@@ -0,0 +1,5 @@
+{
+    "name": "com.android.hardware.gatekeeper",
+    "version": 1,
+    "vendorBootstrap": true
+}
diff --git a/gatekeeper/aidl/software/rust/ta/lib.rs b/gatekeeper/aidl/software/rust/ta/lib.rs
new file mode 100644
index 0000000000..60f292e9af
--- /dev/null
+++ b/gatekeeper/aidl/software/rust/ta/lib.rs
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//! Local in-process implementation of the KeyMint TA. This is insecure and should
+//! only be used for testing purposes.
+
+use gk_boringssl as boring;
+use gk_ta::{traits, traits::SecureFilesystem, Error};
+use gk_wire::MillisecondsSinceEpoch;
+use log::{error, info, warn};
+use std::fs;
+
+/// Build a [`gk_ta::GatekeeperTa`] instance for nonsecure use.
+pub fn build_ta(dir: &std::path::Path) -> gk_ta::GatekeeperTa {
+    info!("Building NON-SECURE Gatekeeper Rust TA");
+
+    let rng = boring::Rng;
+    let clock = StdClock::default();
+    let auth_key = traits::ExplicitAuthKey::new(Box::new(boring::HmacSha256));
+
+    // Store failure records on the filesystem under the given directory. This is not secure.
+    let std_fs = StdFilesystem {
+        dir: std::path::PathBuf::from(dir),
+    };
+
+    // Pre-shared key of all-zeros for `ISharedSecret` agreement, matching:
+    // - `kFakeAgreementKey` in `system/keymaster/km_openssl/soft_keymaster_enforcement.cpp`
+    // - `Keys::kak` in `hardware/interfaces/security/keymint/aidl/default/ta/soft.rs`
+    const SS_PRESHARED_KEY: traits::Aes256Key = [0; 32];
+
+    let imp = traits::Implementation {
+        rng: Box::new(rng),
+        clock: Box::new(clock),
+        compare: Box::new(boring::ConstEq),
+        hmac: Box::new(boring::HmacSha256),
+        password: Box::new(NonsecurePasswordKey),
+        auth_key: Box::new(auth_key),
+        failures: Box::new(std_fs),
+        shared_secret: Some(traits::SharedSecretImplementation {
+            preshared_key: Box::new(traits::FixedPresharedKey(SS_PRESHARED_KEY)),
+            derive: Box::new(boring::BoringAesCmac),
+        }),
+    };
+    gk_ta::GatekeeperTa::new(imp)
+}
+
+/// Monotonic clock which relies on Linux's clock_gettime(2) via `libc`.
+#[derive(Default)]
+pub struct StdClock;
+
+impl traits::MonotonicClock for StdClock {
+    fn now(&self) -> MillisecondsSinceEpoch {
+        let mut time = libc::timespec {
+            tv_sec: 0,
+            tv_nsec: 0,
+        };
+        // Use `CLOCK_BOOTTIME` for consistency with the times used by the Cuttlefish C++
+        // implementation of Gatekeeper (and because it includes time when the system is suspended,
+        // unlike `CLOCK_MONOTONIC`).
+        let rc =
+        // SAFETY: `time` is a valid structure whose lifetime extends beyond the call, and has
+        // exclusive mutable access.
+            unsafe { libc::clock_gettime(libc::CLOCK_BOOTTIME, &mut time as *mut libc::timespec) };
+        if rc < 0 {
+            log::warn!("failed to get time!");
+            return MillisecondsSinceEpoch(0);
+        }
+        MillisecondsSinceEpoch(((time.tv_sec * 1000) + (time.tv_nsec / 1000 / 1000)).into())
+    }
+}
+
+/// Fake password key.
+struct NonsecurePasswordKey;
+
+impl traits::PasswordKeyRetrieval for NonsecurePasswordKey {
+    fn key(&self) -> Result<traits::OpaqueOr<traits::HmacKey>, gk_ta::Error> {
+        let fake_key = vec![0; 32];
+        Ok(traits::OpaqueOr::Explicit(traits::HmacKey(fake_key)))
+    }
+}
+
+/// Representation of a flat directory for files.
+struct StdFilesystem {
+    dir: std::path::PathBuf,
+}
+
+impl SecureFilesystem for StdFilesystem {
+    type Iter = StdDirIterator;
+    fn read(&self, filename: &str) -> Result<Vec<u8>, Error> {
+        let mut path = self.dir.clone();
+        path.push(filename);
+        fs::read(&path).map_err(|e| {
+            info!("failed to read {path:?}: {e:?}");
+            Error::NotFound
+        })
+    }
+    fn write(&self, filename: &str, data: &[u8]) -> Result<(), Error> {
+        let mut path = self.dir.clone();
+        path.push(filename);
+        fs::write(&path, data).map_err(|e| {
+            error!("failed to write to {path:?}: {e:?}");
+            Error::Internal
+        })
+    }
+    fn delete(&self, filename: &str) -> Result<(), Error> {
+        let mut path = self.dir.clone();
+        path.push(filename);
+        fs::remove_file(&path).map_err(|e| {
+            warn!("failed to delete {path:?}: {e:?}");
+            Error::NotFound
+        })
+    }
+    fn list(&self) -> Result<Self::Iter, Error> {
+        let iter = fs::read_dir(&self.dir).map_err(|e| {
+            error!("failed to list {:?}: {e:?}", self.dir);
+            Error::Internal
+        })?;
+        Ok(StdDirIterator { iter })
+    }
+}
+
+struct StdDirIterator {
+    iter: std::fs::ReadDir,
+}
+
+impl Iterator for StdDirIterator {
+    type Item = String;
+    fn next(&mut self) -> Option<Self::Item> {
+        let next = self.iter.next();
+        match next {
+            Some(Ok(entry)) => match entry.file_name().to_str() {
+                Some(filename) => Some(filename.to_string()),
+                None => {
+                    error!("directory entry {entry:?} does not have a String filename!");
+                    None
+                }
+            },
+            Some(Err(e)) => {
+                error!("failed to get next directory entry: {e:?}");
+                None
+            }
+            None => None,
+        }
+    }
+}
diff --git a/gatekeeper/aidl/vts/functional/VtsHalGatekeeperTargetTest.cpp b/gatekeeper/aidl/vts/functional/VtsHalGatekeeperTargetTest.cpp
index 032f7e2475..bf40d5abac 100644
--- a/gatekeeper/aidl/vts/functional/VtsHalGatekeeperTargetTest.cpp
+++ b/gatekeeper/aidl/vts/functional/VtsHalGatekeeperTargetTest.cpp
@@ -60,7 +60,7 @@ static void verifyAuthToken(GatekeeperVerifyResponse& rsp) {
 
     EXPECT_EQ(HW_AUTH_PASSWORD, auth_type);
     EXPECT_NE(UINT64_C(~0), auth_tstamp);
-    ALOGI("Authenticator ID: %016" PRIX64, rsp.hardwareAuthToken.authenticatorId);
+    ALOGI("Secure user ID:   %016" PRIX64, rsp.hardwareAuthToken.userId);
     EXPECT_NE(UINT32_C(0), rsp.hardwareAuthToken.userId);
 }
 
@@ -115,40 +115,54 @@ class GatekeeperAidlTest : public ::testing::TestWithParam<std::string> {
         }
     }
 
-    void checkVerify(GatekeeperVerifyResponse& rsp, Status& ret, uint64_t challenge,
-                     bool expectSuccess) {
-        if (expectSuccess) {
-            EXPECT_TRUE(ret.isOk());
-            EXPECT_GE(rsp.statusCode, IGatekeeper::STATUS_OK);
-            EXPECT_LE(rsp.statusCode, IGatekeeper::STATUS_REENROLL);
-
-            verifyAuthToken(rsp);
-            EXPECT_EQ(challenge, rsp.hardwareAuthToken.challenge);
-        } else {
-            EXPECT_EQ(IGatekeeper::ERROR_GENERAL_FAILURE, getReturnStatusCode(ret));
-        }
+    void enrollNewPasswordFails(std::vector<uint8_t>& password) {
+        enrollNewPassword(password, /* expectSuccess= */ false);
     }
 
-    void enrollNewPassword(std::vector<uint8_t>& password, GatekeeperEnrollResponse& rsp,
-                           bool expectSuccess) {
+    std::vector<uint8_t> enrollNewPassword(std::vector<uint8_t>& password,
+                                           bool expectSuccess = true) {
         GatekeeperRequest req;
         req.newPwd = password;
+        GatekeeperEnrollResponse rsp;
         Status ret = doEnroll(req, rsp);
         checkEnroll(rsp, ret, expectSuccess);
+        return rsp.data;
+    }
+
+    void verifyPasswordSucceeds(std::vector<uint8_t>& password,
+                                std::vector<uint8_t>& passwordHandle, uint64_t challenge,
+                                GatekeeperVerifyResponse& verifyRsp) {
+        verifyPassword(password, passwordHandle, challenge, verifyRsp,
+                       /* expectSuccess= */ true);
+    }
+
+    void verifyPasswordFails(std::vector<uint8_t>& password, std::vector<uint8_t>& passwordHandle,
+                             uint64_t challenge) {
+        GatekeeperVerifyResponse verifyRsp;
+        verifyPassword(password, passwordHandle, challenge, verifyRsp,
+                       /* expectSuccess= */ false);
     }
 
     void verifyPassword(std::vector<uint8_t>& password, std::vector<uint8_t>& passwordHandle,
                         uint64_t challenge, GatekeeperVerifyResponse& verifyRsp,
                         bool expectSuccess) {
+        // Assemble the arguments into the verify request.
         GatekeeperRequest verifyReq;
-
-        // build verify request for the same password (we want it to succeed)
         verifyReq.newPwd = password;
-        // use enrolled password handle we've got
         verifyReq.curPwdHandle = passwordHandle;
         verifyReq.challenge = challenge;
+
         Status ret = doVerify(verifyReq, verifyRsp);
-        checkVerify(verifyRsp, ret, challenge, expectSuccess);
+        if (expectSuccess) {
+            EXPECT_TRUE(ret.isOk());
+            EXPECT_GE(verifyRsp.statusCode, IGatekeeper::STATUS_OK);
+            EXPECT_LE(verifyRsp.statusCode, IGatekeeper::STATUS_REENROLL);
+
+            verifyAuthToken(verifyRsp);
+            EXPECT_EQ(challenge, verifyRsp.hardwareAuthToken.challenge);
+        } else {
+            EXPECT_EQ(IGatekeeper::ERROR_GENERAL_FAILURE, getReturnStatusCode(ret));
+        }
     }
 
     int32_t getReturnStatusCode(const Status& result) {
@@ -181,11 +195,10 @@ class GatekeeperAidlTest : public ::testing::TestWithParam<std::string> {
  * Ensure we can enroll new password
  */
 TEST_P(GatekeeperAidlTest, EnrollSuccess) {
-    std::vector<uint8_t> password;
-    GatekeeperEnrollResponse rsp;
     ALOGI("Testing Enroll (expected success)");
+    std::vector<uint8_t> password;
     generatePassword(password, 0);
-    enrollNewPassword(password, rsp, true);
+    enrollNewPassword(password);
     ALOGI("Testing Enroll done");
 }
 
@@ -193,10 +206,9 @@ TEST_P(GatekeeperAidlTest, EnrollSuccess) {
  * Ensure we can not enroll empty password
  */
 TEST_P(GatekeeperAidlTest, EnrollNoPassword) {
+    ALOGI("Testing Enroll(empty) (expected failure)");
     std::vector<uint8_t> password;
-    GatekeeperEnrollResponse rsp;
-    ALOGI("Testing Enroll (expected failure)");
-    enrollNewPassword(password, rsp, false);
+    enrollNewPasswordFails(password);
     ALOGI("Testing Enroll done");
 }
 
@@ -204,19 +216,18 @@ TEST_P(GatekeeperAidlTest, EnrollNoPassword) {
  * Ensure we can successfully verify previously enrolled password
  */
 TEST_P(GatekeeperAidlTest, VerifySuccess) {
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
-    std::vector<uint8_t> password;
-
     ALOGI("Testing Enroll+Verify (expected success)");
+    std::vector<uint8_t> password;
     generatePassword(password, 0);
-    enrollNewPassword(password, enrollRsp, true);
-    verifyPassword(password, enrollRsp.data, 1, verifyRsp, true);
+
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(password);
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(password, passwordHandle, 1, verifyRsp);
 
     ALOGI("Testing unenrolled password doesn't verify");
-    verifyRsp = {0, 0, {}};
-    generatePassword(password, 1);
-    verifyPassword(password, enrollRsp.data, 1, verifyRsp, false);
+    std::vector<uint8_t> wrongPassword;
+    generatePassword(wrongPassword, 1);
+    verifyPasswordFails(wrongPassword, passwordHandle, 1);
     ALOGI("Testing Enroll+Verify done");
 }
 
@@ -224,17 +235,15 @@ TEST_P(GatekeeperAidlTest, VerifySuccess) {
  * Ensure that passwords containing a NUL byte aren't truncated
  */
 TEST_P(GatekeeperAidlTest, PasswordIsBinaryData) {
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
-    std::vector<uint8_t> rightPassword = {'A', 'B', 'C', '\0', 'D', 'E', 'F'};
-    std::vector<uint8_t> wrongPassword = {'A', 'B', 'C', '\0', '\0', '\0', '\0'};
-
     ALOGI("Testing Enroll+Verify of password with embedded NUL (expected success)");
-    enrollNewPassword(rightPassword, enrollRsp, true);
-    verifyPassword(rightPassword, enrollRsp.data, 1, verifyRsp, true);
+    std::vector<uint8_t> rightPassword = {'A', 'B', 'C', '\0', 'D', 'E', 'F'};
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(rightPassword);
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(rightPassword, passwordHandle, 1, verifyRsp);
 
     ALOGI("Testing Verify of wrong password (expected failure)");
-    verifyPassword(wrongPassword, enrollRsp.data, 1, verifyRsp, false);
+    std::vector<uint8_t> wrongPassword = {'A', 'B', 'C', '\0', '\0', '\0', '\0'};
+    verifyPasswordFails(wrongPassword, passwordHandle, 1);
 
     ALOGI("PasswordIsBinaryData test done");
 }
@@ -243,20 +252,18 @@ TEST_P(GatekeeperAidlTest, PasswordIsBinaryData) {
  * Ensure that long passwords aren't truncated
  */
 TEST_P(GatekeeperAidlTest, LongPassword) {
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
+    ALOGI("Testing Enroll+Verify of long password (expected success)");
     std::vector<uint8_t> password;
-
     password.resize(64);  // maximum length used by Android
     memset(password.data(), 'A', password.size());
 
-    ALOGI("Testing Enroll+Verify of long password (expected success)");
-    enrollNewPassword(password, enrollRsp, true);
-    verifyPassword(password, enrollRsp.data, 1, verifyRsp, true);
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(password);
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(password, passwordHandle, 1, verifyRsp);
 
     ALOGI("Testing Verify of wrong password (expected failure)");
     password[password.size() - 1] ^= 1;
-    verifyPassword(password, enrollRsp.data, 1, verifyRsp, false);
+    verifyPasswordFails(password, passwordHandle, 1);
 
     ALOGI("LongPassword test done");
 }
@@ -266,61 +273,59 @@ TEST_P(GatekeeperAidlTest, LongPassword) {
  * secure user_id) if we prove we know old password
  */
 TEST_P(GatekeeperAidlTest, TrustedReenroll) {
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperRequest reenrollReq;
-    GatekeeperEnrollResponse reenrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
-    GatekeeperVerifyResponse reenrollVerifyRsp;
-    std::vector<uint8_t> password;
-    std::vector<uint8_t> newPassword;
+    ALOGI("Testing Trusted Reenroll (expected success)");
 
+    std::vector<uint8_t> password;
     generatePassword(password, 0);
 
-    ALOGI("Testing Trusted Reenroll (expected success)");
-    enrollNewPassword(password, enrollRsp, true);
-    verifyPassword(password, enrollRsp.data, 0, verifyRsp, true);
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(password);
+
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(password, passwordHandle, 0, verifyRsp);
     ALOGI("Primary Enroll+Verify done");
+    verifyAuthToken(verifyRsp);
 
+    std::vector<uint8_t> newPassword;
     generatePassword(newPassword, 1);
+    GatekeeperRequest reenrollReq;
     reenrollReq.newPwd = newPassword;
     reenrollReq.curPwd = password;
-    reenrollReq.curPwdHandle = enrollRsp.data;
+    reenrollReq.curPwdHandle = passwordHandle;
 
+    GatekeeperEnrollResponse reenrollRsp;
     Status ret = doEnroll(reenrollReq, reenrollRsp);
     checkEnroll(reenrollRsp, ret, true);
-    verifyPassword(newPassword, reenrollRsp.data, 0, reenrollVerifyRsp, true);
-    ALOGI("Trusted ReEnroll+Verify done");
+    std::vector<uint8_t> newPasswordHandle = reenrollRsp.data;
 
-    verifyAuthToken(verifyRsp);
+    GatekeeperVerifyResponse reenrollVerifyRsp;
+    verifyPasswordSucceeds(newPassword, newPasswordHandle, 0, reenrollVerifyRsp);
+    ALOGI("Trusted ReEnroll+Verify done");
     verifyAuthToken(reenrollVerifyRsp);
     EXPECT_EQ(verifyRsp.hardwareAuthToken.userId, reenrollVerifyRsp.hardwareAuthToken.userId);
     ALOGI("Testing Trusted Reenroll done");
 }
 
 /**
- * Ensure we can update password (and get new
- * secure user_id) if we don't know old password
+ * Ensure we can update password (and get new secure user_id) if we don't know old password
  */
 TEST_P(GatekeeperAidlTest, UntrustedReenroll) {
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperEnrollResponse reenrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
-    GatekeeperVerifyResponse reenrollVerifyRsp;
-    std::vector<uint8_t> password;
-    std::vector<uint8_t> newPassword;
-
     ALOGI("Testing Untrusted Reenroll (expected success)");
+    std::vector<uint8_t> password;
     generatePassword(password, 0);
-    enrollNewPassword(password, enrollRsp, true);
-    verifyPassword(password, enrollRsp.data, 0, verifyRsp, true);
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(password);
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(password, passwordHandle, 0, verifyRsp);
+    verifyAuthToken(verifyRsp);
     ALOGI("Primary Enroll+Verify done");
 
+    std::vector<uint8_t> newPassword;
     generatePassword(newPassword, 1);
-    enrollNewPassword(newPassword, reenrollRsp, true);
-    verifyPassword(newPassword, reenrollRsp.data, 0, reenrollVerifyRsp, true);
+    std::vector<uint8_t> newPasswordHandle = enrollNewPassword(newPassword);
+
+    GatekeeperVerifyResponse reenrollVerifyRsp;
+    verifyPasswordSucceeds(newPassword, newPasswordHandle, 0, reenrollVerifyRsp);
     ALOGI("Untrusted ReEnroll+Verify done");
 
-    verifyAuthToken(verifyRsp);
     verifyAuthToken(reenrollVerifyRsp);
     EXPECT_NE(verifyRsp.hardwareAuthToken.userId, reenrollVerifyRsp.hardwareAuthToken.userId);
     ALOGI("Testing Untrusted Reenroll done");
@@ -330,12 +335,10 @@ TEST_P(GatekeeperAidlTest, UntrustedReenroll) {
  * Ensure we don't get successful verify with invalid data
  */
 TEST_P(GatekeeperAidlTest, VerifyNoData) {
+    ALOGI("Testing Verify (expected failure)");
     std::vector<uint8_t> password;
     std::vector<uint8_t> passwordHandle;
-    GatekeeperVerifyResponse verifyRsp;
-
-    ALOGI("Testing Verify (expected failure)");
-    verifyPassword(password, passwordHandle, 0, verifyRsp, false);
+    verifyPasswordFails(password, passwordHandle, 0);
     ALOGI("Testing Verify done");
 }
 
@@ -343,22 +346,22 @@ TEST_P(GatekeeperAidlTest, VerifyNoData) {
  * Ensure we can not verify password after we enrolled it and then deleted user
  */
 TEST_P(GatekeeperAidlTest, DeleteUserTest) {
-    std::vector<uint8_t> password;
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
     ALOGI("Testing deleteUser (expected success)");
     setUid(10001);
+    std::vector<uint8_t> password;
     generatePassword(password, 0);
-    enrollNewPassword(password, enrollRsp, true);
-    verifyPassword(password, enrollRsp.data, 0, verifyRsp, true);
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(password);
+
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(password, passwordHandle, 0, verifyRsp);
     ALOGI("Enroll+Verify done");
+
     auto result = doDeleteUser();
     EXPECT_TRUE(result.isOk() ||
                 (getReturnStatusCode(result) == IGatekeeper::ERROR_NOT_IMPLEMENTED));
     ALOGI("DeleteUser done");
     if (result.isOk()) {
-        verifyRsp = {0, 0, {}};
-        verifyPassword(password, enrollRsp.data, 0, verifyRsp, false);
+        verifyPasswordFails(password, passwordHandle, 0);
         ALOGI("Verify after Delete done (must fail)");
     }
     ALOGI("Testing deleteUser done: rsp=%" PRIi32, getReturnStatusCode(result));
@@ -368,14 +371,13 @@ TEST_P(GatekeeperAidlTest, DeleteUserTest) {
  * Ensure we can not delete a user that does not exist
  */
 TEST_P(GatekeeperAidlTest, DeleteInvalidUserTest) {
-    std::vector<uint8_t> password;
-    GatekeeperEnrollResponse enrollRsp;
-    GatekeeperVerifyResponse verifyRsp;
     ALOGI("Testing deleteUser (expected failure)");
     setUid(10002);
+    std::vector<uint8_t> password;
     generatePassword(password, 0);
-    enrollNewPassword(password, enrollRsp, true);
-    verifyPassword(password, enrollRsp.data, 0, verifyRsp, true);
+    std::vector<uint8_t> passwordHandle = enrollNewPassword(password);
+    GatekeeperVerifyResponse verifyRsp;
+    verifyPasswordSucceeds(password, passwordHandle, 0, verifyRsp);
     ALOGI("Enroll+Verify done");
 
     // Delete the user
@@ -400,7 +402,7 @@ TEST_P(GatekeeperAidlTest, DeleteAllUsersTest) {
     struct UserData {
         uint32_t userId;
         std::vector<uint8_t> password;
-        GatekeeperEnrollResponse enrollRsp;
+        std::vector<uint8_t> passwordHandle;
         GatekeeperVerifyResponse verifyRsp;
         UserData(int id) { userId = id; }
     } users[3]{10001, 10002, 10003};
@@ -410,14 +412,14 @@ TEST_P(GatekeeperAidlTest, DeleteAllUsersTest) {
     for (size_t i = 0; i < sizeof(users) / sizeof(users[0]); ++i) {
         setUid(users[i].userId);
         generatePassword(users[i].password, (i % 255) + 1);
-        enrollNewPassword(users[i].password, users[i].enrollRsp, true);
+        users[i].passwordHandle = enrollNewPassword(users[i].password);
     }
     ALOGI("Multiple users enrolled");
 
     // verify multiple users
     for (size_t i = 0; i < sizeof(users) / sizeof(users[0]); ++i) {
         setUid(users[i].userId);
-        verifyPassword(users[i].password, users[i].enrollRsp.data, 0, users[i].verifyRsp, true);
+        verifyPasswordSucceeds(users[i].password, users[i].passwordHandle, 0, users[i].verifyRsp);
     }
     ALOGI("Multiple users verified");
 
@@ -430,9 +432,7 @@ TEST_P(GatekeeperAidlTest, DeleteAllUsersTest) {
         // verify multiple users after they are deleted; all must fail
         for (size_t i = 0; i < sizeof(users) / sizeof(users[0]); ++i) {
             setUid(users[i].userId);
-            users[i].verifyRsp = {0, 0, {}};
-            verifyPassword(users[i].password, users[i].enrollRsp.data, 0, users[i].verifyRsp,
-                           false);
+            verifyPasswordFails(users[i].password, users[i].passwordHandle, 0);
         }
         ALOGI("Multiple users verified after delete (all must fail)");
     }
diff --git a/gnss/aidl/Android.bp b/gnss/aidl/Android.bp
index 31d246c09c..5cf3e9754c 100644
--- a/gnss/aidl/Android.bp
+++ b/gnss/aidl/Android.bp
@@ -26,6 +26,7 @@ package {
 aidl_interface {
     name: "android.hardware.gnss",
     vendor_available: true,
+    host_supported: true,
     srcs: [
         "android/hardware/gnss/*.aidl",
         "android/hardware/gnss/measurement_corrections/*.aidl",
diff --git a/gnss/aidl/vts/gnss_hal_test_cases.cpp b/gnss/aidl/vts/gnss_hal_test_cases.cpp
index 8a1e5d304a..70511a61f6 100644
--- a/gnss/aidl/vts/gnss_hal_test_cases.cpp
+++ b/gnss/aidl/vts/gnss_hal_test_cases.cpp
@@ -792,6 +792,7 @@ TEST_P(GnssHalTest, BlocklistIndividualSatellites) {
     status = gnss_configuration_hal->setBlocklist(sources);
     ASSERT_TRUE(status.isOk());
 
+    const int kLocationsToAwaitForReacquisition = 7;
     bool strongest_sv_is_reobserved = false;
     // do several loops awaiting a few locations, allowing non-immediate reacquisition strategies
     int unblocklist_loops_remaining = kRetriesToUnBlocklist;
@@ -805,7 +806,7 @@ TEST_P(GnssHalTest, BlocklistIndividualSatellites) {
             aidl_gnss_cb_->sv_info_list_cbq_.reset();
             aidl_gnss_cb_->location_cbq_.reset();
         }
-        StartAndCheckLocations(kLocationsToAwait);
+        StartAndCheckLocations(kLocationsToAwaitForReacquisition);
 
         // early exit loop if test is being run with insufficient signal
         location_called_count = (aidl_gnss_hal_->getInterfaceVersion() <= 1)
diff --git a/graphics/Android.bp b/graphics/Android.bp
index 2213f15b1c..b837bf3f30 100644
--- a/graphics/Android.bp
+++ b/graphics/Android.bp
@@ -64,14 +64,14 @@ cc_defaults {
 aidl_interface_defaults {
     name: "android.hardware.graphics.common-latest",
     imports: [
-        "android.hardware.graphics.common-V6",
+        "android.hardware.graphics.common-V7",
     ],
 }
 
 rust_defaults {
     name: "android.hardware.graphics.common-latest-rust",
     rustlibs: [
-        "android.hardware.graphics.common-V6-rust",
+        "android.hardware.graphics.common-V7-rust",
     ],
 }
 
@@ -80,7 +80,7 @@ cc_defaults {
     target: {
         linux: {
             static_libs: [
-                "android.hardware.graphics.common-V6-ndk",
+                "android.hardware.graphics.common-V7-ndk",
             ],
         },
     },
@@ -91,7 +91,7 @@ cc_defaults {
     target: {
         linux: {
             shared_libs: [
-                "android.hardware.graphics.common-V6-ndk",
+                "android.hardware.graphics.common-V7-ndk",
             ],
         },
     },
diff --git a/graphics/allocator/aidl/Android.bp b/graphics/allocator/aidl/Android.bp
index 3f74b23a13..b2d53abdf4 100644
--- a/graphics/allocator/aidl/Android.bp
+++ b/graphics/allocator/aidl/Android.bp
@@ -45,7 +45,7 @@ aidl_interface {
             version: "2",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
 
diff --git a/graphics/allocator/aidl/vts/VtsHalGraphicsAllocatorAidl_TargetTest.cpp b/graphics/allocator/aidl/vts/VtsHalGraphicsAllocatorAidl_TargetTest.cpp
index 22ad5f0f3a..c460dc3e78 100644
--- a/graphics/allocator/aidl/vts/VtsHalGraphicsAllocatorAidl_TargetTest.cpp
+++ b/graphics/allocator/aidl/vts/VtsHalGraphicsAllocatorAidl_TargetTest.cpp
@@ -204,11 +204,8 @@ class GraphicsTestsBase {
         }
         if (!status.isOk()) {
             status_t error = status.getExceptionCode();
-            if (error == EX_SERVICE_SPECIFIC) {
-                error = status.getServiceSpecificError();
-                EXPECT_NE(OK, error) << "Failed to set error properly";
-            } else {
-                EXPECT_EQ(OK, error) << "Allocation transport failure";
+            if (raise_failure) {
+                ADD_FAILURE() << "Allocation transport failure: " << error;
             }
             return nullptr;
         } else {
@@ -357,7 +354,7 @@ TEST_P(GraphicsAllocatorAidlTests, RejectsUnknownUsages) {
     // Now add the unknown bit and verify it's rejected
     info.usage |= invalidUsage;
     EXPECT_FALSE(isSupported(info)) << "isSupported() returned true for unknown-to-HAL usage";
-    EXPECT_FALSE(allocate(info)) << "allocate succeeded for unknown-to-HAL usage";
+    EXPECT_FALSE(allocate(info, false)) << "allocate succeeded for unknown-to-HAL usage";
 }
 
 TEST_P(GraphicsAllocatorAidlTests, RejectsUnknownOptions) {
@@ -378,7 +375,7 @@ TEST_P(GraphicsAllocatorAidlTests, RejectsUnknownOptions) {
     info.additionalOptions.push_back({"android.hardware.graphics.common.NotARealOption", 1});
 
     EXPECT_FALSE(isSupported(info)) << "isSupported() returned true for unknown-to-HAL option";
-    EXPECT_FALSE(allocate(info)) << "allocate succeeded for unknown-to-HAL option";
+    EXPECT_FALSE(allocate(info, false)) << "allocate succeeded for unknown-to-HAL option";
 }
 
 TEST_P(GraphicsFrontBufferTests, FrontBufferGpuToCpu) {
diff --git a/graphics/common/aidl/Android.bp b/graphics/common/aidl/Android.bp
index 7bd776f854..7729b8745c 100644
--- a/graphics/common/aidl/Android.bp
+++ b/graphics/common/aidl/Android.bp
@@ -43,7 +43,7 @@ aidl_interface {
             enabled: true,
         },
     },
-    frozen: true,
+    frozen: false,
     versions_with_info: [
         {
             version: "1",
diff --git a/graphics/common/aidl/aidl_api/android.hardware.graphics.common/current/android/hardware/graphics/common/PixelFormat.aidl b/graphics/common/aidl/aidl_api/android.hardware.graphics.common/current/android/hardware/graphics/common/PixelFormat.aidl
index 54a9d8dcc9..658a53e8f0 100644
--- a/graphics/common/aidl/aidl_api/android.hardware.graphics.common/current/android/hardware/graphics/common/PixelFormat.aidl
+++ b/graphics/common/aidl/aidl_api/android.hardware.graphics.common/current/android/hardware/graphics/common/PixelFormat.aidl
@@ -69,4 +69,11 @@ enum PixelFormat {
   RG_1616_UINT = 0x3a,
   RGBA_10101010 = 0x3b,
   YCBCR_P210 = 0x3c,
+  R_12_UINT = 0x3d,
+  R_14_UINT = 0x3e,
+  RG_1212_UINT = 0x3f,
+  RG_1414_UINT = 0x40,
+  RGBA_12121212_UINT = 0x41,
+  RGBA_14141414_UINT = 0x42,
+  BGRA_1010102 = 0x43,
 }
diff --git a/graphics/common/aidl/android/hardware/graphics/common/PixelFormat.aidl b/graphics/common/aidl/android/hardware/graphics/common/PixelFormat.aidl
index 55be4d256c..c24fb5daf8 100644
--- a/graphics/common/aidl/android/hardware/graphics/common/PixelFormat.aidl
+++ b/graphics/common/aidl/android/hardware/graphics/common/PixelFormat.aidl
@@ -319,7 +319,7 @@ enum PixelFormat {
 
     /**
      * 32-bit packed format that has 2-bit A, 10-bit B, G, and R components,
-     * in that order, from the most-sigfinicant bits to the least-significant
+     * in that order, from the most-significant bits to the least-significant
      * bits.
      *
      * The component values are unsigned normalized to the range [0, 1], whose
@@ -553,4 +553,90 @@ enum PixelFormat {
      * or with IMapper::lock.
      */
     YCBCR_P210 = 0x3c,
+
+    /**
+     * 16 bit format with a single 12-bit component. The format is 16 bits
+     * unsigned integer that has 12 bits of R component in the top 12 bits
+     * of the 16-bit word with the bottom 4 bits unused.
+     *
+     * The component values are unsigned integers, whose interpretation is
+     * defined by the dataspace.
+     */
+    R_12_UINT = 0x3d,
+
+    /**
+     * 16 bit format with a single 14-bit component. The format is 16-bit
+     * unsigned integer that has 14 bits of R component in the top 14 bits
+     * of the 16-bit word with the bottom 2 bits unused.
+     *
+     * The component values are unsigned integers, whose interpretation is
+     * defined by the dataspace.
+     */
+    R_14_UINT = 0x3e,
+
+    /**
+     * 32-bit format that has 12-bit R and G components, in that order,
+     * from the lowest memory address to the highest memory address. The
+     * format is 32-bit unsigned integer that has a 12-bit R component
+     * in the top 12 bits of the word in bytes 0..1, and a 12-bit G
+     * component in the top 12 bits of the word in bytes 2..3, with the
+     * bottom 4 bits of each word unused.
+     *
+     * The component values are unsigned integers, whose interpretation is
+     * defined by the dataspace.
+     */
+    RG_1212_UINT = 0x3f,
+
+    /**
+     * 32-bit format that has 14-bit R and G components, in that order,
+     * from the lowest memory address to the highest memory address. The
+     * format is 32-bit unsigned integer that has a 14-bit R component
+     * in the top 14 bits of the word in bytes 0..1, and a 14-bit G
+     * component in the top 14 bits of the word in bytes 2..3, with the
+     * bottom 2 bits of each word unused.
+     *
+     * The component values are unsigned integers, whose interpretation is
+     * defined by the dataspace.
+     */
+    RG_1414_UINT = 0x40,
+
+    /**
+     * 64-bit format that has 12-bit R, G, B, and A components, in that order,
+     * from the lowest memory address to the highest memory address. The
+     * format is 64-bit unsigned integer that has a 12-bit R component in
+     * the top 12 bits of the word in bytes 0..1, a 12-bit G component in
+     * the top 12 bits of the word in bytes 2..3, a 12-bit B component in
+     * the top 12 bits of the word in bytes 4..5, and a 12-bit A component
+     * in the top 12 bits of the word in bytes 6..7, with the bottom 4 bits
+     * of each word unused.
+     *
+     * The component values are unsigned integers, whose interpretation is
+     * defined by the dataspace.
+     */
+    RGBA_12121212_UINT = 0x41,
+
+    /**
+     * 64-bit format that has 14-bit R, G, B, and A components, in that order,
+     * from the lowest memory address to the highest memory address. The
+     * format is 64-bit unsigned integer that has a 14-bit R component in
+     * the top 14 bits of the word in bytes 0..1, a 14-bit G component in
+     * the top 14 bits of the word in bytes 2..3, a 14-bit B component in
+     * the top 14 bits of the word in bytes 4..5, and a 14-bit A component
+     * in the top 14 bits of the word in bytes 6..7, with the bottom 2 bits
+     * of each word unused.
+     *
+     * The component values are unsigned integers, whose interpretation is
+     * defined by the dataspace.
+     */
+    RGBA_14141414_UINT = 0x42,
+
+    /**
+     * 32-bit packed format that has 2-bit A, 10-bit R, G, and B components,
+     * in that order, from the most-significant bits to the least-significant
+     * bits.
+     *
+     * The component values are unsigned normalized to the range [0, 1], whose
+     * interpretation is defined by the dataspace.
+     */
+    BGRA_1010102 = 0x43,
 }
diff --git a/graphics/composer/aidl/Android.bp b/graphics/composer/aidl/Android.bp
index 5d713ae7d7..894c8d4d95 100644
--- a/graphics/composer/aidl/Android.bp
+++ b/graphics/composer/aidl/Android.bp
@@ -59,28 +59,28 @@ aidl_interface {
         {
             version: "1",
             imports: [
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
                 "android.hardware.common-V2",
             ],
         },
         {
             version: "2",
             imports: [
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
                 "android.hardware.common-V2",
             ],
         },
         {
             version: "3",
             imports: [
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
                 "android.hardware.common-V2",
             ],
         },
         {
             version: "4",
             imports: [
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
                 "android.hardware.common-V2",
                 "android.hardware.drm.common-V1",
             ],
diff --git a/graphics/composer/aidl/android/hardware/graphics/composer3/Luts.aidl b/graphics/composer/aidl/android/hardware/graphics/composer3/Luts.aidl
index 6ff1db2392..36d6d1965b 100644
--- a/graphics/composer/aidl/android/hardware/graphics/composer3/Luts.aidl
+++ b/graphics/composer/aidl/android/hardware/graphics/composer3/Luts.aidl
@@ -40,16 +40,21 @@ parcelable Luts {
      * For data precision, 32-bit float is used to specify a Lut by both the HWC and
      * the platform.
      *
-     * Assuming that we have a 3D array `ORIGINAL[WIDTH, HEIGHT, DEPTH]`, we would turn it into
-     * `FLAT[WIDTH * HEIGHT * DEPTH]` by
+     * For 1D LUTs:
+     * -   Values should also be normalized for fixed-point pixel formats.
+     * -   Floating-point pixel formats and extended-range buffers are currently unsupported.
      *
-     * `FLAT[z + DEPTH * (y + HEIGHT * x)] = ORIGINAL[x, y, z]`
-     *
-     * Note that 1D Lut(s) should be gain curve ones and 3D Lut(s) should be pure color lookup
-     * ones. For 3D Luts buffer,the values of the lut buffer should be normalized, ranging from 0.0
-     * to 1.0, inclusively and the data is organized in the order of R, G, B channels.
-     * For 1D Luts, the lut's values should be also normalized for fixed point pixel formats,
-     * and we now ignore floating point pixel formats + extended range buffers.
+     * For 3D LUT buffers:
+     * -   Values must be normalized to the range [0.0, 1.0], inclusive. 1.0 is the maximum panel luminance.
+     * -   If N is the size of each dimension, the data is arranged in RGB order:
+     *     R(0, 0, 0), R(0, 0, 1), ..., R(0, 0, N - 1),
+     *     R(0, 1, 0), ..., R(0, 1, N - 1), ..., R(0, N - 1, N - 1),
+     *     R(1, 0, 0), ..., R(1, 0, N - 1), ..., R(1, N - 1, N - 1), ..., R(N - 1, N - 1, N - 1),
+     *     G(0, 0, 0), ..., G(N - 1, N - 1, N - 1),
+     *     B(0, 0, 0), ..., B(N - 1, N - 1, N - 1)
+     * -   When a GPU shader samples 3D Lut data, it's accessed in a flat, one-dimensional arrangement.
+     *     Assuming that we have a 3D array ORIGINAL[N][N][N],
+     *     then ORIGINAL[x][y][z] is mapped to FLAT[z + N * (y + N * x)].
      */
     @nullable ParcelFileDescriptor pfd;
 
diff --git a/graphics/composer/aidl/include/android/hardware/graphics/composer3/ComposerClientReader.h b/graphics/composer/aidl/include/android/hardware/graphics/composer3/ComposerClientReader.h
index f12bce3fbb..c3b2fa8d88 100644
--- a/graphics/composer/aidl/include/android/hardware/graphics/composer3/ComposerClientReader.h
+++ b/graphics/composer/aidl/include/android/hardware/graphics/composer3/ComposerClientReader.h
@@ -268,9 +268,7 @@ class ComposerClientReader {
         LOG_ALWAYS_FATAL_IF(mDisplay && displayLuts.display != *mDisplay);
         auto& data = mReturnData[displayLuts.display];
         for (auto& [layerId, luts] : displayLuts.layerLuts) {
-            if (luts.pfd.get() >= 0) {
-                data.layerLuts.push_back({layerId, std::move(luts)});
-            }
+            data.layerLuts.push_back({layerId, std::move(luts)});
         }
     }
 
diff --git a/graphics/composer/aidl/libhwc_aidl_test/Android.bp b/graphics/composer/aidl/libhwc_aidl_test/Android.bp
index 1955fcf8ab..62d9197418 100644
--- a/graphics/composer/aidl/libhwc_aidl_test/Android.bp
+++ b/graphics/composer/aidl/libhwc_aidl_test/Android.bp
@@ -37,6 +37,7 @@ cc_library_static {
         "GraphicsComposerCallback.cpp",
         "Readback.cpp",
         "RenderEngine.cpp",
+        "TestLayer.cpp",
     ],
     shared_libs: [
         "libEGL",
diff --git a/graphics/composer/aidl/libhwc_aidl_test/Readback.cpp b/graphics/composer/aidl/libhwc_aidl_test/Readback.cpp
index 2aded73503..8f9953f4fd 100644
--- a/graphics/composer/aidl/libhwc_aidl_test/Readback.cpp
+++ b/graphics/composer/aidl/libhwc_aidl_test/Readback.cpp
@@ -16,31 +16,113 @@
 
 #include "Readback.h"
 #include <aidl/android/hardware/graphics/common/BufferUsage.h>
+#include <renderengine/impl/ExternalTexture.h>
 #include "RenderEngine.h"
-#include "renderengine/impl/ExternalTexture.h"
+#include "android-base/stringprintf.h"
 
 namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test {
 
+namespace {
+void saveAsImage(const std::string& prefix, void* bufferData, uint32_t bytesPerPixel,
+                 uint32_t stride, uint32_t height, uint32_t width) {
+    std::string filename = ::android::base::StringPrintf(
+            "/data/local/tmp/%s_%ld.ppm", prefix.c_str(), static_cast<long>(time(nullptr)));
+    FILE* file = fopen(filename.c_str(), "wb");
+    if (!file) {
+        ALOGE("Failed to open file %s for writing", filename.c_str());
+        return;
+    }
+
+    // PPM header (P6 format - binary RGB)
+    // TODO(b/329149798): Add support for 1010102 buffers
+    fprintf(file, "P6\n%d %d\n255\n", width, height);
+
+    for (uint32_t y = 0; y < height; y++) {
+        std::vector<uint8_t> rowData(width * 3);
+        for (uint32_t x = 0; x < width; x++) {
+            uint8_t* srcData = static_cast<uint8_t*>(bufferData);
+            uint32_t srcOffset = y * stride * bytesPerPixel + x * bytesPerPixel;
+            uint32_t dstOffset = x * 3;
+
+            rowData[dstOffset + 0] = srcData[srcOffset + 0];  // R
+            rowData[dstOffset + 1] = srcData[srcOffset + 1];  // G
+            rowData[dstOffset + 2] = srcData[srcOffset + 2];  // B
+        }
+        fwrite(rowData.data(), 3, width, file);
+    }
+
+    fclose(file);
+}
+
+#define ASSERT_APPROX_EQ(val1, val2, error) \
+    ASSERT_NEAR(static_cast<double>(val1), static_cast<double>(val2), static_cast<double>(error))
+}  // namespace
+
 const std::vector<ColorMode> ReadbackHelper::colorModes = {ColorMode::SRGB, ColorMode::DISPLAY_P3};
 const std::vector<Dataspace> ReadbackHelper::dataspaces = {common::Dataspace::SRGB,
                                                            common::Dataspace::DISPLAY_P3};
 
-void TestLayer::write(ComposerClientWriter& writer) {
-    writer.setLayerDisplayFrame(mDisplay, mLayer, mDisplayFrame);
-    writer.setLayerSourceCrop(mDisplay, mLayer, mSourceCrop);
-    writer.setLayerZOrder(mDisplay, mLayer, mZOrder);
-    writer.setLayerSurfaceDamage(mDisplay, mLayer, mSurfaceDamage);
-    writer.setLayerTransform(mDisplay, mLayer, mTransform);
-    writer.setLayerPlaneAlpha(mDisplay, mLayer, mAlpha);
-    writer.setLayerBlendMode(mDisplay, mLayer, mBlendMode);
-    writer.setLayerBrightness(mDisplay, mLayer, mBrightness);
-    writer.setLayerDataspace(mDisplay, mLayer, mDataspace);
-    Luts luts{
-            .pfd = ::ndk::ScopedFileDescriptor(dup(mLuts.pfd.get())),
-            .offsets = mLuts.offsets,
-            .lutProperties = mLuts.lutProperties,
-    };
-    writer.setLayerLuts(mDisplay, mLayer, luts);
+DisplayProperties ReadbackHelper::setupDisplayProperty(
+        const DisplayWrapper& display,
+        const std::shared_ptr<ComposerClientWrapper>& composerClient) {
+    int64_t displayId = display.getDisplayId();
+
+    // Set testColorModes
+    const auto& [status, modes] = composerClient->getColorModes(displayId);
+    EXPECT_TRUE(status.isOk());
+    if (!status.isOk()) {
+        abort();
+    }
+    std::vector<ColorMode> testColorModes;
+    for (ColorMode mode : modes) {
+        if (std::find(colorModes.begin(), colorModes.end(), mode) != colorModes.end()) {
+            testColorModes.push_back(mode);
+        }
+    }
+
+    // Set pixelFormat and dataspace
+    auto [readbackStatus, readBackBufferAttributes] =
+            composerClient->getReadbackBufferAttributes(displayId);
+    if (!readbackStatus.isOk()) {
+        EXPECT_EQ(readbackStatus.getExceptionCode(), EX_SERVICE_SPECIFIC);
+        EXPECT_EQ(readbackStatus.getServiceSpecificError(), IComposerClient::EX_UNSUPPORTED);
+    }
+
+    // Set testRenderEngine and clientCompositionDisplaySettings
+    EXPECT_TRUE(composerClient->setPowerMode(displayId, PowerMode::ON).isOk());
+    const auto format = readbackStatus.isOk() ? readBackBufferAttributes.format
+                                              : common::PixelFormat::RGBA_8888;
+    std::unique_ptr<TestRenderEngine> testRenderEngine;
+    EXPECT_NO_FATAL_FAILURE(
+            testRenderEngine = std::unique_ptr<TestRenderEngine>(new TestRenderEngine(
+                    ::android::renderengine::RenderEngineCreationArgs::Builder()
+                            .setPixelFormat(static_cast<int>(format))
+                            .setImageCacheSize(TestRenderEngine::sMaxFrameBufferAcquireBuffers)
+                            .setEnableProtectedContext(false)
+                            .setPrecacheToneMapperShaderOnly(false)
+                            .setContextPriority(
+                                    ::android::renderengine::RenderEngine::ContextPriority::HIGH)
+                            .build())));
+
+    ::android::renderengine::DisplaySettings clientCompositionDisplaySettings;
+    clientCompositionDisplaySettings.physicalDisplay =
+            ::android::Rect(display.getDisplayWidth(), display.getDisplayHeight());
+    clientCompositionDisplaySettings.clip = clientCompositionDisplaySettings.physicalDisplay;
+
+    testRenderEngine->initGraphicBuffer(
+            static_cast<uint32_t>(display.getDisplayWidth()),
+            static_cast<uint32_t>(display.getDisplayHeight()),
+            /*layerCount*/ 1U,
+            static_cast<uint64_t>(static_cast<uint64_t>(common::BufferUsage::CPU_READ_OFTEN) |
+                                  static_cast<uint64_t>(common::BufferUsage::CPU_WRITE_OFTEN) |
+                                  static_cast<uint64_t>(common::BufferUsage::GPU_RENDER_TARGET)));
+    testRenderEngine->setDisplaySettings(clientCompositionDisplaySettings);
+
+    DisplayProperties displayProperties(displayId, testColorModes, std::move(testRenderEngine),
+                                        std::move(clientCompositionDisplaySettings),
+                                        std::move(readBackBufferAttributes.format),
+                                        std::move(readBackBufferAttributes.dataspace));
+    return displayProperties;
 }
 
 std::string ReadbackHelper::getColorModeString(ColorMode mode) {
@@ -78,57 +160,6 @@ Dataspace ReadbackHelper::getDataspaceForColorMode(ColorMode mode) {
     }
 }
 
-LayerSettings TestLayer::toRenderEngineLayerSettings() {
-    LayerSettings layerSettings;
-
-    layerSettings.alpha = ::android::half(mAlpha);
-    layerSettings.disableBlending = mBlendMode == BlendMode::NONE;
-    layerSettings.source.buffer.isOpaque = mBlendMode == BlendMode::NONE;
-    layerSettings.geometry.boundaries = ::android::FloatRect(
-            static_cast<float>(mDisplayFrame.left), static_cast<float>(mDisplayFrame.top),
-            static_cast<float>(mDisplayFrame.right), static_cast<float>(mDisplayFrame.bottom));
-
-    const ::android::mat4 translation = ::android::mat4::translate(::android::vec4(
-            (static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_H)
-                     ? static_cast<float>(-mDisplayFrame.right)
-                     : 0.0f),
-            (static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_V)
-                     ? static_cast<float>(-mDisplayFrame.bottom)
-                     : 0.0f),
-            0.0f, 1.0f));
-
-    const ::android::mat4 scale = ::android::mat4::scale(::android::vec4(
-            static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_H) ? -1.0f
-                                                                                         : 1.0f,
-            static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_V) ? -1.0f
-                                                                                         : 1.0f,
-            1.0f, 1.0f));
-
-    layerSettings.geometry.positionTransform = scale * translation;
-    layerSettings.whitePointNits = mWhitePointNits;
-    layerSettings.sourceDataspace = static_cast<::android::ui::Dataspace>(mDataspace);
-    if (mLuts.pfd.get() >= 0 && mLuts.offsets) {
-        std::vector<int32_t> dimensions;
-        std::vector<int32_t> sizes;
-        std::vector<int32_t> keys;
-        dimensions.reserve(mLuts.lutProperties.size());
-        sizes.reserve(mLuts.lutProperties.size());
-        keys.reserve(mLuts.lutProperties.size());
-
-        for (auto& l : mLuts.lutProperties) {
-            dimensions.emplace_back(static_cast<int32_t>(l.dimension));
-            sizes.emplace_back(static_cast<int32_t>(l.size));
-            keys.emplace_back(static_cast<int32_t>(l.samplingKeys[0]));
-        }
-
-        layerSettings.luts = std::make_shared<::android::gui::DisplayLuts>(
-                ::android::base::unique_fd(dup(mLuts.pfd.get())), *mLuts.offsets, dimensions, sizes,
-                keys);
-    }
-
-    return layerSettings;
-}
-
 int32_t ReadbackHelper::GetBitsPerChannel(common::PixelFormat pixelFormat) {
     switch (pixelFormat) {
         case common::PixelFormat::RGBA_1010102:
@@ -141,6 +172,14 @@ int32_t ReadbackHelper::GetBitsPerChannel(common::PixelFormat pixelFormat) {
     }
 }
 
+int32_t ReadbackHelper::GetTolerance(int32_t bitsPerChannel) {
+    if (bitsPerChannel > 8) {
+        return 3;
+    } else {
+        return 0;
+    }
+}
+
 int32_t ReadbackHelper::GetAlphaBits(common::PixelFormat pixelFormat) {
     switch (pixelFormat) {
         case common::PixelFormat::RGBA_8888:
@@ -239,9 +278,11 @@ void ReadbackHelper::compareColorBuffers(const std::vector<Color>& expectedColor
                                          common::PixelFormat pixelFormat) {
     int32_t bitsPerChannel = GetBitsPerChannel(pixelFormat);
     int32_t alphaBits = GetAlphaBits(pixelFormat);
+    int32_t tolerance = GetTolerance(bitsPerChannel);
     ASSERT_GT(bytesPerPixel, 0);
     ASSERT_NE(-1, alphaBits);
     ASSERT_NE(-1, bitsPerChannel);
+    ASSERT_GE(tolerance, 0);
     uint32_t maxValue = (1 << bitsPerChannel) - 1;
     uint32_t maxAlphaValue = (1 << alphaBits) - 1;
     for (uint32_t row = 0; row < height; row++) {
@@ -276,11 +317,11 @@ void ReadbackHelper::compareColorBuffers(const std::vector<Color>& expectedColor
                 uint32_t actualBlue = (*pixelStart >> (32 - alphaBits - bitsPerChannel)) & maxValue;
                 uint32_t actualAlpha = (*pixelStart >> (32 - alphaBits)) & maxAlphaValue;
 
-                ASSERT_EQ(expectedRed, actualRed)
+                ASSERT_APPROX_EQ(expectedRed, actualRed, tolerance)
                         << "Red channel mismatch at (" << row << ", " << col << ")";
-                ASSERT_EQ(expectedGreen, actualGreen)
+                ASSERT_APPROX_EQ(expectedGreen, actualGreen, tolerance)
                         << "Green channel mismatch at (" << row << ", " << col << ")";
-                ASSERT_EQ(expectedBlue, actualBlue)
+                ASSERT_APPROX_EQ(expectedBlue, actualBlue, tolerance)
                         << "Blue channel mismatch at (" << row << ", " << col << ")";
             }
         }
@@ -293,9 +334,11 @@ void ReadbackHelper::compareColorBuffers(void* expectedBuffer, void* actualBuffe
                                          common::PixelFormat pixelFormat) {
     int32_t bitsPerChannel = GetBitsPerChannel(pixelFormat);
     int32_t alphaBits = GetAlphaBits(pixelFormat);
+    int32_t tolerance = GetTolerance(bitsPerChannel);
     ASSERT_GT(bytesPerPixel, 0);
     ASSERT_NE(-1, alphaBits);
     ASSERT_NE(-1, bitsPerChannel);
+    ASSERT_GE(tolerance, 0);
     uint32_t maxValue = (1 << bitsPerChannel) - 1;
     uint32_t maxAlphaValue = (1 << alphaBits) - 1;
     for (uint32_t row = 0; row < height; row++) {
@@ -331,11 +374,11 @@ void ReadbackHelper::compareColorBuffers(void* expectedBuffer, void* actualBuffe
                         (*actualStart >> (32 - alphaBits - bitsPerChannel)) & maxValue;
                 uint32_t actualAlpha = (*actualStart >> (32 - alphaBits)) & maxAlphaValue;
 
-                ASSERT_EQ(expectedRed, actualRed)
+                ASSERT_APPROX_EQ(expectedRed, actualRed, tolerance)
                         << "Red channel mismatch at (" << row << ", " << col << ")";
-                ASSERT_EQ(expectedGreen, actualGreen)
+                ASSERT_APPROX_EQ(expectedGreen, actualGreen, tolerance)
                         << "Green channel mismatch at (" << row << ", " << col << ")";
-                ASSERT_EQ(expectedBlue, actualBlue)
+                ASSERT_APPROX_EQ(expectedBlue, actualBlue, tolerance)
                         << "Blue channel mismatch at (" << row << ", " << col << ")";
             }
         }
@@ -379,7 +422,7 @@ void ReadbackBuffer::setReadbackBuffer() {
     EXPECT_TRUE(mComposerClient->setReadbackBuffer(mDisplay, bufferHandle, fence).isOk());
 }
 
-void ReadbackBuffer::checkReadbackBuffer(const std::vector<Color>& expectedColors) {
+void ReadbackBuffer::checkReadbackBuffer(const std::vector<Color>& expectedColors, bool saveImage) {
     ASSERT_NE(nullptr, mGraphicBuffer);
     // lock buffer for reading
     const auto& [fenceStatus, bufferFence] = mComposerClient->getReadbackBufferFence(mDisplay);
@@ -399,6 +442,13 @@ void ReadbackBuffer::checkReadbackBuffer(const std::vector<Color>& expectedColor
                                     : mGraphicBuffer->getStride();
     ReadbackHelper::compareColorBuffers(expectedColors, bufData, stride, bytesPerPixel, mWidth,
                                         mHeight, mPixelFormat);
+
+    // If requested, save the buffer as an image while it's still locked
+    if (saveImage) {
+        std::string prefix = "readback_display" + std::to_string(mDisplay);
+        saveAsImage(prefix, bufData, static_cast<uint32_t>(bytesPerPixel), stride, mHeight, mWidth);
+    }
+
     status = mGraphicBuffer->unlock();
     EXPECT_EQ(::android::OK, status);
 }
diff --git a/graphics/composer/aidl/libhwc_aidl_test/RenderEngine.cpp b/graphics/composer/aidl/libhwc_aidl_test/RenderEngine.cpp
index 6715ea478d..af8bdac196 100644
--- a/graphics/composer/aidl/libhwc_aidl_test/RenderEngine.cpp
+++ b/graphics/composer/aidl/libhwc_aidl_test/RenderEngine.cpp
@@ -15,6 +15,7 @@
  */
 
 #include "RenderEngine.h"
+#include "Readback.h"
 #include "renderengine/impl/ExternalTexture.h"
 
 namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test {
diff --git a/graphics/composer/aidl/libhwc_aidl_test/TestLayer.cpp b/graphics/composer/aidl/libhwc_aidl_test/TestLayer.cpp
new file mode 100644
index 0000000000..9096c90188
--- /dev/null
+++ b/graphics/composer/aidl/libhwc_aidl_test/TestLayer.cpp
@@ -0,0 +1,90 @@
+/**
+ * Copyright (c) 2025, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "TestLayer.h"
+
+namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test {
+
+void TestLayer::write(ComposerClientWriter& writer) {
+    writer.setLayerDisplayFrame(mDisplay, mLayer, mDisplayFrame);
+    writer.setLayerSourceCrop(mDisplay, mLayer, mSourceCrop);
+    writer.setLayerZOrder(mDisplay, mLayer, mZOrder);
+    writer.setLayerSurfaceDamage(mDisplay, mLayer, mSurfaceDamage);
+    writer.setLayerTransform(mDisplay, mLayer, mTransform);
+    writer.setLayerPlaneAlpha(mDisplay, mLayer, mAlpha);
+    writer.setLayerBlendMode(mDisplay, mLayer, mBlendMode);
+    writer.setLayerBrightness(mDisplay, mLayer, mBrightness);
+    writer.setLayerDataspace(mDisplay, mLayer, mDataspace);
+    Luts luts{
+            .pfd = ::ndk::ScopedFileDescriptor(dup(mLuts.pfd.get())),
+            .offsets = mLuts.offsets,
+            .lutProperties = mLuts.lutProperties,
+    };
+    writer.setLayerLuts(mDisplay, mLayer, luts);
+}
+
+LayerSettings TestLayer::toRenderEngineLayerSettings() {
+    LayerSettings layerSettings;
+
+    layerSettings.alpha = ::android::half(mAlpha);
+    layerSettings.disableBlending = mBlendMode == BlendMode::NONE;
+    layerSettings.source.buffer.isOpaque = mBlendMode == BlendMode::NONE;
+    layerSettings.geometry.boundaries = ::android::FloatRect(
+            static_cast<float>(mDisplayFrame.left), static_cast<float>(mDisplayFrame.top),
+            static_cast<float>(mDisplayFrame.right), static_cast<float>(mDisplayFrame.bottom));
+
+    const ::android::mat4 translation = ::android::mat4::translate(::android::vec4(
+            (static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_H)
+                     ? static_cast<float>(-mDisplayFrame.right)
+                     : 0.0f),
+            (static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_V)
+                     ? static_cast<float>(-mDisplayFrame.bottom)
+                     : 0.0f),
+            0.0f, 1.0f));
+
+    const ::android::mat4 scale = ::android::mat4::scale(::android::vec4(
+            static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_H) ? -1.0f
+                                                                                         : 1.0f,
+            static_cast<uint64_t>(mTransform) & static_cast<uint64_t>(Transform::FLIP_V) ? -1.0f
+                                                                                         : 1.0f,
+            1.0f, 1.0f));
+
+    layerSettings.geometry.positionTransform = scale * translation;
+    layerSettings.whitePointNits = mWhitePointNits;
+    layerSettings.sourceDataspace = static_cast<::android::ui::Dataspace>(mDataspace);
+    if (mLuts.pfd.get() >= 0 && mLuts.offsets) {
+        std::vector<int32_t> dimensions;
+        std::vector<int32_t> sizes;
+        std::vector<int32_t> keys;
+        dimensions.reserve(mLuts.lutProperties.size());
+        sizes.reserve(mLuts.lutProperties.size());
+        keys.reserve(mLuts.lutProperties.size());
+
+        for (auto& l : mLuts.lutProperties) {
+            dimensions.emplace_back(static_cast<int32_t>(l.dimension));
+            sizes.emplace_back(static_cast<int32_t>(l.size));
+            keys.emplace_back(static_cast<int32_t>(l.samplingKeys[0]));
+        }
+
+        layerSettings.luts = std::make_shared<::android::gui::DisplayLuts>(
+                ::android::base::unique_fd(dup(mLuts.pfd.get())), *mLuts.offsets, dimensions, sizes,
+                keys);
+    }
+
+    return layerSettings;
+}
+
+}  // namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test
\ No newline at end of file
diff --git a/graphics/composer/aidl/libhwc_aidl_test/include/Readback.h b/graphics/composer/aidl/libhwc_aidl_test/include/Readback.h
index 9fdb4d37d0..96645ec5bc 100644
--- a/graphics/composer/aidl/libhwc_aidl_test/include/Readback.h
+++ b/graphics/composer/aidl/libhwc_aidl_test/include/Readback.h
@@ -23,8 +23,11 @@
 #include <android/hardware/graphics/composer3/ComposerClientWriter.h>
 #include <renderengine/RenderEngine.h>
 #include <ui/GraphicBuffer.h>
+#include <ui/PixelFormat.h>
 #include <memory>
 #include "ComposerClientWrapper.h"
+#include "RenderEngine.h"
+#include "TestLayer.h"
 
 using aidl::android::hardware::graphics::composer3::Luts;
 
@@ -48,69 +51,6 @@ static const Color LIGHT_RED = {0.5f, 0.0f, 0.0f, 1.0f};
 static const Color LIGHT_GREEN = {0.0f, 0.5f, 0.0f, 1.0f};
 static const Color LIGHT_BLUE = {0.0f, 0.0f, 0.5f, 1.0f};
 
-class TestRenderEngine;
-
-class TestLayer {
-  public:
-    TestLayer(const std::shared_ptr<ComposerClientWrapper>& client, int64_t display,
-              ComposerClientWriter& writer)
-        : mDisplay(display) {
-        const auto& [status, layer] = client->createLayer(display, kBufferSlotCount, &writer);
-        EXPECT_TRUE(status.isOk());
-        mLayer = layer;
-    }
-
-    // ComposerClient will take care of destroying layers, no need to explicitly
-    // call destroyLayers here
-    virtual ~TestLayer() {};
-
-    virtual void write(ComposerClientWriter& writer);
-    virtual LayerSettings toRenderEngineLayerSettings();
-
-    void setDisplayFrame(Rect frame) { mDisplayFrame = frame; }
-    void setSourceCrop(FRect crop) { mSourceCrop = crop; }
-    void setZOrder(uint32_t z) { mZOrder = z; }
-    void setWhitePointNits(float whitePointNits) { mWhitePointNits = whitePointNits; }
-    void setBrightness(float brightness) { mBrightness = brightness; }
-
-    void setSurfaceDamage(std::vector<Rect> surfaceDamage) {
-        mSurfaceDamage = std::move(surfaceDamage);
-    }
-
-    void setDataspace(Dataspace dataspace) { mDataspace = dataspace; }
-
-    void setTransform(Transform transform) { mTransform = transform; }
-    void setAlpha(float alpha) { mAlpha = alpha; }
-    void setBlendMode(BlendMode blendMode) { mBlendMode = blendMode; }
-    void setLuts(Luts luts) { mLuts = std::move(luts); }
-
-    BlendMode getBlendMode() const { return mBlendMode; }
-
-    uint32_t getZOrder() const { return mZOrder; }
-
-    float getAlpha() const { return mAlpha; }
-
-    int64_t getLayer() const { return mLayer; }
-
-    float getBrightness() const { return mBrightness; }
-
-  protected:
-    int64_t mDisplay;
-    int64_t mLayer;
-    Rect mDisplayFrame = {0, 0, 0, 0};
-    float mBrightness = 1.f;
-    float mWhitePointNits = -1.f;
-    std::vector<Rect> mSurfaceDamage;
-    Transform mTransform = static_cast<Transform>(0);
-    FRect mSourceCrop = {0, 0, 0, 0};
-    static constexpr uint32_t kBufferSlotCount = 64;
-    float mAlpha = 1.0;
-    BlendMode mBlendMode = BlendMode::NONE;
-    uint32_t mZOrder = 0;
-    Dataspace mDataspace = Dataspace::UNKNOWN;
-    Luts mLuts;
-};
-
 class TestColorLayer : public TestLayer {
   public:
     TestColorLayer(const std::shared_ptr<ComposerClientWrapper>& client, int64_t display,
@@ -168,8 +108,34 @@ class TestBufferLayer : public TestLayer {
     ::android::sp<::android::GraphicBuffer> allocateBuffer();
 };
 
+struct DisplayProperties {
+    DisplayProperties(int64_t displayId, std::vector<ColorMode> testColorModes,
+                      std::unique_ptr<TestRenderEngine> testRenderEngine,
+                      ::android::renderengine::DisplaySettings clientCompositionDisplaySettings,
+                      common::PixelFormat pixelFormat, common::Dataspace dataspace)
+        : testColorModes(testColorModes),
+          pixelFormat(pixelFormat),
+          dataspace(dataspace),
+          testRenderEngine(std::move(testRenderEngine)),
+          clientCompositionDisplaySettings(std::move(clientCompositionDisplaySettings)),
+          writer(displayId),
+          reader(displayId) {}
+
+    std::vector<ColorMode> testColorModes = {};
+    common::PixelFormat pixelFormat = common::PixelFormat::UNSPECIFIED;
+    common::Dataspace dataspace = common::Dataspace::UNKNOWN;
+    std::unique_ptr<TestRenderEngine> testRenderEngine = nullptr;
+    ::android::renderengine::DisplaySettings clientCompositionDisplaySettings = {};
+    ComposerClientWriter writer;
+    ComposerClientReader reader;
+};
+
 class ReadbackHelper {
   public:
+    static DisplayProperties setupDisplayProperty(
+            const DisplayWrapper& display,
+            const std::shared_ptr<ComposerClientWrapper>& composerClient);
+
     static std::string getColorModeString(ColorMode mode);
 
     static std::string getDataspaceString(Dataspace dataspace);
@@ -177,6 +143,7 @@ class ReadbackHelper {
     static Dataspace getDataspaceForColorMode(ColorMode mode);
 
     static int32_t GetBitsPerChannel(PixelFormat pixelFormat);
+    static int32_t GetTolerance(int32_t bitsPerChannel);
     static int32_t GetAlphaBits(PixelFormat pixelFormat);
 
     static void fillBuffer(uint32_t width, uint32_t height, uint32_t stride, int32_t bytesPerPixel,
@@ -211,7 +178,7 @@ class ReadbackBuffer {
 
     void setReadbackBuffer();
 
-    void checkReadbackBuffer(const std::vector<Color>& expectedColors);
+    void checkReadbackBuffer(const std::vector<Color>& expectedColors, bool saveImage = false);
 
     ::android::sp<::android::GraphicBuffer> getBuffer();
 
diff --git a/graphics/composer/aidl/libhwc_aidl_test/include/RenderEngine.h b/graphics/composer/aidl/libhwc_aidl_test/include/RenderEngine.h
index 6b8b82f210..de30ab9862 100644
--- a/graphics/composer/aidl/libhwc_aidl_test/include/RenderEngine.h
+++ b/graphics/composer/aidl/libhwc_aidl_test/include/RenderEngine.h
@@ -23,7 +23,7 @@
 #include <ui/PixelFormat.h>
 #include <ui/Rect.h>
 #include <ui/Region.h>
-#include "Readback.h"
+#include "TestLayer.h"
 
 namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test {
 
diff --git a/graphics/composer/aidl/libhwc_aidl_test/include/TestLayer.h b/graphics/composer/aidl/libhwc_aidl_test/include/TestLayer.h
new file mode 100644
index 0000000000..109a1a9f87
--- /dev/null
+++ b/graphics/composer/aidl/libhwc_aidl_test/include/TestLayer.h
@@ -0,0 +1,87 @@
+/**
+ * Copyright (c) 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <renderengine/RenderEngine.h>
+#include "ComposerClientWrapper.h"
+
+namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test {
+
+using ::android::renderengine::LayerSettings;
+
+class TestLayer {
+  public:
+    TestLayer(const std::shared_ptr<ComposerClientWrapper>& client, int64_t display,
+              ComposerClientWriter& writer)
+        : mDisplay(display) {
+        const auto& [status, layer] = client->createLayer(display, kBufferSlotCount, &writer);
+        EXPECT_TRUE(status.isOk());
+        mLayer = layer;
+    }
+
+    // ComposerClient will take care of destroying layers, no need to explicitly
+    // call destroyLayers here
+    virtual ~TestLayer() {};
+
+    virtual void write(ComposerClientWriter& writer);
+    virtual LayerSettings toRenderEngineLayerSettings();
+
+    void setDisplayFrame(Rect frame) { mDisplayFrame = frame; }
+    void setSourceCrop(FRect crop) { mSourceCrop = crop; }
+    void setZOrder(uint32_t z) { mZOrder = z; }
+    void setWhitePointNits(float whitePointNits) { mWhitePointNits = whitePointNits; }
+    void setBrightness(float brightness) { mBrightness = brightness; }
+
+    void setSurfaceDamage(std::vector<Rect> surfaceDamage) {
+        mSurfaceDamage = std::move(surfaceDamage);
+    }
+
+    void setDataspace(Dataspace dataspace) { mDataspace = dataspace; }
+
+    void setTransform(Transform transform) { mTransform = transform; }
+    void setAlpha(float alpha) { mAlpha = alpha; }
+    void setBlendMode(BlendMode blendMode) { mBlendMode = blendMode; }
+    void setLuts(Luts luts) { mLuts = std::move(luts); }
+
+    BlendMode getBlendMode() const { return mBlendMode; }
+
+    uint32_t getZOrder() const { return mZOrder; }
+
+    float getAlpha() const { return mAlpha; }
+
+    int64_t getLayer() const { return mLayer; }
+
+    float getBrightness() const { return mBrightness; }
+
+  protected:
+    int64_t mDisplay;
+    int64_t mLayer;
+    Rect mDisplayFrame = {0, 0, 0, 0};
+    float mBrightness = 1.f;
+    float mWhitePointNits = -1.f;
+    std::vector<Rect> mSurfaceDamage;
+    Transform mTransform = static_cast<Transform>(0);
+    FRect mSourceCrop = {0, 0, 0, 0};
+    static constexpr uint32_t kBufferSlotCount = 64;
+    float mAlpha = 1.0;
+    BlendMode mBlendMode = BlendMode::NONE;
+    uint32_t mZOrder = 0;
+    Dataspace mDataspace = Dataspace::UNKNOWN;
+    Luts mLuts;
+};
+
+}  // namespace aidl::android::hardware::graphics::composer3::libhwc_aidl_test
\ No newline at end of file
diff --git a/graphics/composer/aidl/vts/Android.bp b/graphics/composer/aidl/vts/Android.bp
index 6ff51bf7f5..d2d6f9b715 100644
--- a/graphics/composer/aidl/vts/Android.bp
+++ b/graphics/composer/aidl/vts/Android.bp
@@ -76,5 +76,6 @@ cc_test {
     test_suites: [
         "general-tests",
         "vts",
+        "dts",
     ],
 }
diff --git a/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_ReadbackTest.cpp b/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_ReadbackTest.cpp
index 7810213de7..3877bea941 100644
--- a/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_ReadbackTest.cpp
+++ b/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_ReadbackTest.cpp
@@ -23,10 +23,10 @@
 #include <cutils/ashmem.h>
 #include <gtest/gtest.h>
 #include <ui/DisplayId.h>
-#include <ui/DisplayIdentification.h>
 #include <ui/GraphicBuffer.h>
 #include <ui/PixelFormat.h>
 #include <ui/Rect.h>
+#include <algorithm>
 #include <cstdint>
 #include <unordered_map>
 #include "ComposerClientWrapper.h"
@@ -86,78 +86,20 @@ class GraphicsCompositionTestBase : public ::testing::Test {
 
     void setUpDisplayProperties() {
         for (const auto& display : mAllDisplays) {
-            int64_t displayId = display.getDisplayId();
-
-            // Set testColorModes
-            const auto& [status, modes] = mComposerClient->getColorModes(displayId);
-            ASSERT_TRUE(status.isOk());
-            std::vector<ColorMode> testColorModes;
-            for (ColorMode mode : modes) {
-                if (std::find(ReadbackHelper::colorModes.begin(), ReadbackHelper::colorModes.end(),
-                              mode) != ReadbackHelper::colorModes.end()) {
-                    testColorModes.push_back(mode);
-                }
-            }
-
-            // Set pixelFormat and dataspace
-            auto [readbackStatus, readBackBufferAttributes] =
-                    mComposerClient->getReadbackBufferAttributes(displayId);
-            if (readbackStatus.isOk()) {
-            } else {
-                EXPECT_NO_FATAL_FAILURE(assertServiceSpecificError(
-                        readbackStatus, IComposerClient::EX_UNSUPPORTED));
-            }
-
-            // Set testRenderEngine and clientCompositionDisplaySettings
-            EXPECT_TRUE(mComposerClient->setPowerMode(displayId, PowerMode::ON).isOk());
-            const auto format = readbackStatus.isOk() ? readBackBufferAttributes.format
-                                                      : common::PixelFormat::RGBA_8888;
-            std::unique_ptr<TestRenderEngine> testRenderEngine;
-            ASSERT_NO_FATAL_FAILURE(
-                    testRenderEngine = std::unique_ptr<TestRenderEngine>(new TestRenderEngine(
-                            ::android::renderengine::RenderEngineCreationArgs::Builder()
-                                    .setPixelFormat(static_cast<int>(format))
-                                    .setImageCacheSize(
-                                            TestRenderEngine::sMaxFrameBufferAcquireBuffers)
-                                    .setEnableProtectedContext(false)
-                                    .setPrecacheToneMapperShaderOnly(false)
-                                    .setContextPriority(::android::renderengine::RenderEngine::
-                                                                ContextPriority::HIGH)
-                                    .build())));
-
-            ::android::renderengine::DisplaySettings clientCompositionDisplaySettings;
-            clientCompositionDisplaySettings.physicalDisplay =
-                    Rect(display.getDisplayWidth(), display.getDisplayHeight());
-            clientCompositionDisplaySettings.clip =
-                    clientCompositionDisplaySettings.physicalDisplay;
-
-            testRenderEngine->initGraphicBuffer(
-                    static_cast<uint32_t>(display.getDisplayWidth()),
-                    static_cast<uint32_t>(display.getDisplayHeight()),
-                    /*layerCount*/ 1U,
-                    static_cast<uint64_t>(
-                            static_cast<uint64_t>(common::BufferUsage::CPU_READ_OFTEN) |
-                            static_cast<uint64_t>(common::BufferUsage::CPU_WRITE_OFTEN) |
-                            static_cast<uint64_t>(common::BufferUsage::GPU_RENDER_TARGET)));
-            testRenderEngine->setDisplaySettings(clientCompositionDisplaySettings);
-
-            DisplayProperties displayProperties(displayId, testColorModes,
-                                                std::move(testRenderEngine),
-                                                std::move(clientCompositionDisplaySettings),
-                                                std::move(readBackBufferAttributes.format));
-
-            mDisplayProperties.emplace(displayId, std::move(displayProperties));
+            auto props = ReadbackHelper::setupDisplayProperty(display, mComposerClient);
+            mDisplayProperties.emplace(display.getDisplayId(), std::move(props));
         }
     }
 
-    // Get the dataspace and check if readback is supported given the default pixel format and the
-    // current dataspace. Dataspace can get updated after calls to
+    // Gets and Updates the dataspace and check if readback is supported given the default pixel
+    // format and the current dataspace. Dataspace can get updated after calls to
     // ComposerClientWrapper::setColorMode so it's essential to get the latest dataspace.
     std::pair<common::Dataspace, bool> GetDataspaceAndIfReadBackSupported(int64_t displayId) {
         auto [status, readBackBufferAttributes] =
                 mComposerClient->getReadbackBufferAttributes(displayId);
         if (status.isOk()) {
             auto dataspace = readBackBufferAttributes.dataspace;
+            mDisplayProperties.at(displayId).dataspace = dataspace;
 
             // We are making an assumption that Pixel Format never changes, so assert for this
             // assumption. If this is not the case on any display, then we should stop caching it.
@@ -218,26 +160,6 @@ class GraphicsCompositionTestBase : public ::testing::Test {
         mDisplayProperties.at(displayId).reader.parse(std::move(results));
     }
 
-    struct DisplayProperties {
-        DisplayProperties(int64_t displayId, std::vector<ColorMode> testColorModes,
-                          std::unique_ptr<TestRenderEngine> testRenderEngine,
-                          ::android::renderengine::DisplaySettings clientCompositionDisplaySettings,
-                          common::PixelFormat pixelFormat)
-            : testColorModes(testColorModes),
-              pixelFormat(pixelFormat),
-              testRenderEngine(std::move(testRenderEngine)),
-              clientCompositionDisplaySettings(std::move(clientCompositionDisplaySettings)),
-              writer(displayId),
-              reader(displayId) {}
-
-        std::vector<ColorMode> testColorModes = {};
-        common::PixelFormat pixelFormat = common::PixelFormat::UNSPECIFIED;
-        std::unique_ptr<TestRenderEngine> testRenderEngine = nullptr;
-        ::android::renderengine::DisplaySettings clientCompositionDisplaySettings = {};
-        ComposerClientWriter writer;
-        ComposerClientReader reader;
-    };
-
     std::shared_ptr<ComposerClientWrapper> mComposerClient;
     std::vector<DisplayWrapper> mAllDisplays;
     std::unordered_map<int64_t, DisplayProperties> mDisplayProperties;
@@ -686,6 +608,24 @@ TEST_P(GraphicsCompositionTest, Luts) {
         GTEST_SKIP();
     }
 
+    bool supportsHlg = false;
+    for (const auto& i : properties.combinations) {
+        bool supportsBt2020Gamut =
+                std::any_of(i.standards.cbegin(), i.standards.cend(), [](const auto& standard) {
+                    return standard == common::Dataspace::STANDARD_BT2020;
+                });
+        bool supportsHlgTransfer = std::any_of(
+                i.transfers.cbegin(), i.transfers.cend(),
+                [](const auto& transfer) { return transfer == common::Dataspace::TRANSFER_HLG; });
+        bool supportsFullRange = std::any_of(
+                i.ranges.cbegin(), i.ranges.cend(),
+                [](const auto& range) { return range == common::Dataspace::RANGE_FULL; });
+        supportsHlg = supportsBt2020Gamut && supportsHlgTransfer && supportsFullRange;
+        if (supportsHlg) {
+            break;
+        }
+    }
+
     for (const DisplayWrapper display : mAllDisplays) {
         ASSERT_TRUE(
                 mComposerClient
@@ -729,7 +669,10 @@ TEST_P(GraphicsCompositionTest, Luts) {
                             mDisplayProperties.at(display.getDisplayId()).writer);
                     layer->setDisplayFrame(coloredSquare);
                     layer->setZOrder(10);
-                    layer->setDataspace(Dataspace::SRGB);
+                    // Fallback to sRGB support if the device doesn't support HLG
+                    // This is to accommodate nascent devices that support LUTs but only for HDR
+                    // formats, without compromising test coverage of the LUT feature altogether
+                    layer->setDataspace(supportsHlg ? Dataspace::BT2020_HLG : Dataspace::SRGB);
 
                     Luts luts;
                     generateLuts(&luts, l.dimension, l.size, key);
@@ -754,12 +697,9 @@ TEST_P(GraphicsCompositionTest, Luts) {
                                                     ComposerClientWriter::kNoTimestamp,
                                                     ComposerClientWrapper::kNoFrameIntervalNs);
                     execute(display.getDisplayId());
-                    if (!mDisplayProperties.at(display.getDisplayId())
-                                 .reader.takeChangedCompositionTypes(display.getDisplayId())
-                                 .empty()) {
-                        continue;
-                    }
 
+                    // We should be guaranteed to use DPU composition here
+                    ASSERT_TRUE(supportsHlg);
                     auto changedCompositionTypes =
                             mDisplayProperties.at(display.getDisplayId())
                                     .reader.takeChangedCompositionTypes(display.getDisplayId());
@@ -782,6 +722,9 @@ TEST_P(GraphicsCompositionTest, Luts) {
                     testRenderEngine->setRenderLayers(layers);
                     ASSERT_NO_FATAL_FAILURE(testRenderEngine->drawLayers());
                     ASSERT_NO_FATAL_FAILURE(testRenderEngine->checkColorBuffer(expectedColors));
+                    mComposerClient->destroyLayer(
+                            display.getDisplayId(), layer->getLayer(),
+                            &mDisplayProperties.at(display.getDisplayId()).writer);
                 }
             }
         }
@@ -879,6 +822,11 @@ TEST_P(GraphicsCompositionTest, MixedColorSpaces) {
                             .reader.takeChangedCompositionTypes(display.getDisplayId());
             ASSERT_TRUE(changedCompositionTypes.empty());
             ASSERT_TRUE(mDisplayProperties.at(display.getDisplayId()).reader.takeErrors().empty());
+
+            mComposerClient->destroyLayer(display.getDisplayId(), srgbLayer->getLayer(),
+                    &mDisplayProperties.at(display.getDisplayId()).writer);
+            mComposerClient->destroyLayer(display.getDisplayId(), displayP3Layer->getLayer(),
+                    &mDisplayProperties.at(display.getDisplayId()).writer);
         }
     }
 }
diff --git a/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_TargetTest.cpp b/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_TargetTest.cpp
index 6c58b4c8e9..01a0860497 100644
--- a/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_TargetTest.cpp
+++ b/graphics/composer/aidl/vts/VtsHalGraphicsComposer3_TargetTest.cpp
@@ -2369,7 +2369,7 @@ TEST_P(GraphicsComposerAidlCommandTest, DisplayDecoration) {
 
         const auto format = (error.isOk() && support) ? support->format
                         : aidl::android::hardware::graphics::common::PixelFormat::RGBA_8888;
-        const auto decorBuffer = allocate(display.getDisplayHeight(), display.getDisplayWidth(),
+        const auto decorBuffer = allocate(display.getDisplayWidth(), display.getDisplayHeight(),
                                           static_cast<::android::PixelFormat>(format));
         ASSERT_NE(nullptr, decorBuffer);
         if (::android::OK != decorBuffer->initCheck()) {
@@ -3577,6 +3577,7 @@ TEST_P(GraphicsComposerAidlCommandV4Test, GetLuts) {
 
 TEST_P(GraphicsComposerAidlCommandV4Test, SetUnsupportedLayerLuts) {
     for (const DisplayWrapper& display : mDisplays) {
+        EXPECT_TRUE(mComposerClient->setPowerMode(display.getDisplayId(), PowerMode::ON).isOk());
         auto& writer = getWriter(display.getDisplayId());
         const auto& [layerStatus, layer] =
                 mComposerClient->createLayer(display.getDisplayId(), kBufferSlotCount, &writer);
diff --git a/graphics/mapper/4.0/utils/vts/Android.bp b/graphics/mapper/4.0/utils/vts/Android.bp
index 1be460ee85..d33ef46ea6 100644
--- a/graphics/mapper/4.0/utils/vts/Android.bp
+++ b/graphics/mapper/4.0/utils/vts/Android.bp
@@ -48,7 +48,7 @@ cc_library_static {
     ],
     export_static_lib_headers: [
         "android.hardware.graphics.allocator@4.0",
-        "android.hardware.graphics.common-V6-ndk",
+        "android.hardware.graphics.common-V7-ndk",
         "android.hardware.graphics.mapper@4.0",
     ],
     export_include_dirs: ["include"],
diff --git a/graphics/mapper/stable-c/vts/VtsHalGraphicsMapperStableC_TargetTest.cpp b/graphics/mapper/stable-c/vts/VtsHalGraphicsMapperStableC_TargetTest.cpp
index cfd3173ae8..0d9bd8949e 100644
--- a/graphics/mapper/stable-c/vts/VtsHalGraphicsMapperStableC_TargetTest.cpp
+++ b/graphics/mapper/stable-c/vts/VtsHalGraphicsMapperStableC_TargetTest.cpp
@@ -37,6 +37,7 @@
 #include <drm/drm_fourcc.h>
 #include <gtest/gtest.h>
 #include <vndksupport/linker.h>
+#include <cstdlib>
 #include <initializer_list>
 #include <optional>
 #include <string>
@@ -180,16 +181,14 @@ class GraphicsTestsBase {
     AIMapper_loadIMapperFn getIMapperLoader() const { return mIMapperLoader; }
     int32_t* getHalVersion() const { return mIMapperHALVersion; }
 
-    std::unique_ptr<BufferAllocation> allocate(const BufferDescriptorInfo& descriptorInfo) {
+    std::unique_ptr<BufferAllocation> allocate(const BufferDescriptorInfo& descriptorInfo,
+                                               bool raise_failure = true) {
         AllocationResult result;
         ::ndk::ScopedAStatus status = mAllocator->allocate2(descriptorInfo, 1, &result);
         if (!status.isOk()) {
             status_t error = status.getExceptionCode();
-            if (error == EX_SERVICE_SPECIFIC) {
-                error = status.getServiceSpecificError();
-                EXPECT_NE(OK, error) << "Failed to set error properly";
-            } else {
-                EXPECT_EQ(OK, error) << "Allocation transport failure";
+            if (raise_failure) {
+                ADD_FAILURE() << "Allocation transport failure: " << error;
             }
             return nullptr;
         } else {
@@ -268,66 +267,49 @@ class GraphicsTestsBase {
                                                 buffer.data(), sizeRequired);
     }
 
-    void verifyRGBA8888PlaneLayouts(const std::vector<PlaneLayout>& planeLayouts) {
+    void verifyRGBATypePlaneLayouts(const std::vector<PlaneLayout>& planeLayouts,
+                                    PixelFormat format) {
         ASSERT_EQ(1, planeLayouts.size());
-
         const auto& planeLayout = planeLayouts.front();
 
-        ASSERT_EQ(4, planeLayout.components.size());
-
-        int64_t offsetInBitsR = -1;
-        int64_t offsetInBitsG = -1;
-        int64_t offsetInBitsB = -1;
-        int64_t offsetInBitsA = -1;
+        auto planesToValidate = requiredPlanes(format);
+        ASSERT_EQ(planesToValidate.size(), planeLayout.components.size());
 
         for (const auto& component : planeLayout.components) {
-            if (!gralloc4::isStandardPlaneLayoutComponentType(component.type)) {
-                continue;
-            }
-            EXPECT_EQ(8, component.sizeInBits);
-            if (component.type.value == gralloc4::PlaneLayoutComponentType_R.value) {
-                offsetInBitsR = component.offsetInBits;
-            }
-            if (component.type.value == gralloc4::PlaneLayoutComponentType_G.value) {
-                offsetInBitsG = component.offsetInBits;
-            }
-            if (component.type.value == gralloc4::PlaneLayoutComponentType_B.value) {
-                offsetInBitsB = component.offsetInBits;
-            }
-            if (component.type.value == gralloc4::PlaneLayoutComponentType_A.value) {
-                offsetInBitsA = component.offsetInBits;
-            }
+            auto it = std::find(planesToValidate.begin(), planesToValidate.end(), component.type);
+            ASSERT_TRUE(it != planesToValidate.end());
+            planesToValidate.erase(it);
+
+            EXPECT_EQ(expectedChannelSizeInBits(format, component.type), component.sizeInBits);
+            EXPECT_EQ(expectedOffsetInBits(format, component.type), component.offsetInBits);
         }
 
-        EXPECT_EQ(0, offsetInBitsR);
-        EXPECT_EQ(8, offsetInBitsG);
-        EXPECT_EQ(16, offsetInBitsB);
-        EXPECT_EQ(24, offsetInBitsA);
+        ASSERT_TRUE(planesToValidate.empty()) << "Missing required planes";
 
         EXPECT_EQ(0, planeLayout.offsetInBytes);
-        EXPECT_EQ(32, planeLayout.sampleIncrementInBits);
+        EXPECT_EQ(bytesPerSample(format) * 8, planeLayout.sampleIncrementInBits);
         // Skip testing stride because any stride is valid
-        EXPECT_LE(planeLayout.widthInSamples * planeLayout.heightInSamples * 4,
+        EXPECT_LE(planeLayout.widthInSamples * planeLayout.heightInSamples * bytesPerSample(format),
                   planeLayout.totalSizeInBytes);
         EXPECT_EQ(1, planeLayout.horizontalSubsampling);
         EXPECT_EQ(1, planeLayout.verticalSubsampling);
     }
 
-    void fillRGBA8888(uint8_t* data, uint32_t height, size_t strideInBytes, size_t widthInBytes) {
+    void fillRGBAType(uint8_t* data, uint32_t height, size_t strideInBytes, size_t widthInBytes) {
         for (uint32_t y = 0; y < height; y++) {
             memset(data, y, widthInBytes);
             data += strideInBytes;
         }
     }
 
-    void verifyRGBA8888(const buffer_handle_t bufferHandle, const uint8_t* data, uint32_t height,
-                        size_t strideInBytes, size_t widthInBytes) {
+    void verifyRGBAType(const buffer_handle_t bufferHandle, const uint8_t* data, uint32_t height,
+                        size_t strideInBytes, size_t widthInBytes, PixelFormat format) {
         auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);
         ASSERT_TRUE(decodeResult.has_value());
         const auto& planeLayouts = *decodeResult;
         ASSERT_TRUE(planeLayouts.size() > 0);
 
-        verifyRGBA8888PlaneLayouts(planeLayouts);
+        verifyRGBATypePlaneLayouts(planeLayouts, format);
 
         for (uint32_t y = 0; y < height; y++) {
             for (size_t i = 0; i < widthInBytes; i++) {
@@ -550,6 +532,292 @@ class GraphicsTestsBase {
         EXPECT_NE(nullptr, yCbCr_10bit.yCbCr.cr);
         return yCbCr_10bit;
     }
+
+    std::vector<ExtendableType> requiredPlanes(PixelFormat format) {
+        switch (format) {
+            case PixelFormat::RGBX_8888:
+            case PixelFormat::RGB_888:
+            case PixelFormat::RGB_565:
+                return {gralloc4::PlaneLayoutComponentType_R, gralloc4::PlaneLayoutComponentType_G,
+                        gralloc4::PlaneLayoutComponentType_B};
+            case PixelFormat::RGBA_8888:
+            case PixelFormat::BGRA_8888:
+            case PixelFormat::RGBA_10101010:
+            case PixelFormat::RGBA_1010102:
+            case PixelFormat::RGBA_FP16:
+            case PixelFormat::RGBA_12121212_UINT:
+            case PixelFormat::RGBA_14141414_UINT:
+
+            case PixelFormat::BGRA_1010102:
+                return {gralloc4::PlaneLayoutComponentType_R, gralloc4::PlaneLayoutComponentType_G,
+                        gralloc4::PlaneLayoutComponentType_B, gralloc4::PlaneLayoutComponentType_A};
+
+            case PixelFormat::R_8:
+            case PixelFormat::R_16_UINT:
+            case PixelFormat::R_12_UINT:
+            case PixelFormat::R_14_UINT:
+                return {gralloc4::PlaneLayoutComponentType_R};
+            case PixelFormat::RG_1616_UINT:
+            case PixelFormat::RG_1212_UINT:
+            case PixelFormat::RG_1414_UINT:
+                return {gralloc4::PlaneLayoutComponentType_R, gralloc4::PlaneLayoutComponentType_G};
+            case PixelFormat::UNSPECIFIED:
+            case PixelFormat::YCBCR_422_SP:
+            case PixelFormat::YCRCB_420_SP:
+            case PixelFormat::YCBCR_422_I:
+            case PixelFormat::RAW16:
+            case PixelFormat::BLOB:
+            case PixelFormat::IMPLEMENTATION_DEFINED:
+            case PixelFormat::YCBCR_420_888:
+            case PixelFormat::RAW_OPAQUE:
+            case PixelFormat::RAW10:
+            case PixelFormat::RAW12:
+            case PixelFormat::Y8:
+            case PixelFormat::Y16:
+            case PixelFormat::YV12:
+            case PixelFormat::DEPTH_16:
+            case PixelFormat::DEPTH_24:
+            case PixelFormat::DEPTH_24_STENCIL_8:
+            case PixelFormat::DEPTH_32F:
+            case PixelFormat::DEPTH_32F_STENCIL_8:
+            case PixelFormat::STENCIL_8:
+            case PixelFormat::YCBCR_P010:
+            case PixelFormat::YCBCR_P210:
+            case PixelFormat::HSV_888:
+                return {};
+        }
+    }
+
+    int32_t expectedChannelSizeInBits(PixelFormat format, ExtendableType channel) {
+        switch (format) {
+            case PixelFormat::RGB_565:
+                if (channel == gralloc4::PlaneLayoutComponentType_R ||
+                    channel == gralloc4::PlaneLayoutComponentType_B) {
+                    return 5;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 6;
+                } else {
+                    return 0;
+                }
+            case PixelFormat::RGBA_8888:
+            case PixelFormat::BGRA_8888:
+            case PixelFormat::RGB_888:
+            case PixelFormat::RGBX_8888:
+            case PixelFormat::R_8:
+                return 8;
+            case PixelFormat::RGBA_10101010:
+                return 10;
+            case PixelFormat::RGBA_1010102:
+            case PixelFormat::BGRA_1010102:
+                if (channel == gralloc4::PlaneLayoutComponentType_A) {
+                    return 2;
+                } else {
+                    return 10;
+                }
+            case PixelFormat::R_12_UINT:
+            case PixelFormat::RG_1212_UINT:
+            case PixelFormat::RGBA_12121212_UINT:
+                return 12;
+            case PixelFormat::R_14_UINT:
+            case PixelFormat::RG_1414_UINT:
+            case PixelFormat::RGBA_14141414_UINT:
+                return 14;
+            case PixelFormat::R_16_UINT:
+            case PixelFormat::RG_1616_UINT:
+            case PixelFormat::RGBA_FP16:
+                return 16;
+            case PixelFormat::UNSPECIFIED:
+            case PixelFormat::YCBCR_422_SP:
+            case PixelFormat::YCRCB_420_SP:
+            case PixelFormat::YCBCR_422_I:
+            case PixelFormat::RAW16:
+            case PixelFormat::BLOB:
+            case PixelFormat::IMPLEMENTATION_DEFINED:
+            case PixelFormat::YCBCR_420_888:
+            case PixelFormat::RAW_OPAQUE:
+            case PixelFormat::RAW10:
+            case PixelFormat::RAW12:
+            case PixelFormat::Y8:
+            case PixelFormat::Y16:
+            case PixelFormat::YV12:
+            case PixelFormat::DEPTH_16:
+            case PixelFormat::DEPTH_24:
+            case PixelFormat::DEPTH_24_STENCIL_8:
+            case PixelFormat::DEPTH_32F:
+            case PixelFormat::DEPTH_32F_STENCIL_8:
+            case PixelFormat::STENCIL_8:
+            case PixelFormat::YCBCR_P010:
+            case PixelFormat::YCBCR_P210:
+            case PixelFormat::HSV_888:
+                return -1;
+        }
+    }
+
+    int32_t expectedOffsetInBits(PixelFormat format, ExtendableType channel) {
+        switch (format) {
+            case PixelFormat::RGB_565:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 11;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 5;
+                } else {
+                    return 0;
+                }
+            case PixelFormat::RGBA_8888:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 0;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 8;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_B) {
+                    return 16;
+                } else {
+                    return 24;
+                }
+            case PixelFormat::BGRA_8888:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 16;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 8;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_B) {
+                    return 0;
+                } else {
+                    return 24;
+                }
+            case PixelFormat::RGB_888:
+            case PixelFormat::RGBX_8888:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 0;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 8;
+                } else {
+                    return 16;
+                }
+            case PixelFormat::RGBA_1010102:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 0;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 10;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_B) {
+                    return 20;
+                } else {
+                    return 30;
+                }
+            case PixelFormat::BGRA_1010102:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 20;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 10;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_B) {
+                    return 0;
+                } else {
+                    return 30;
+                }
+            case PixelFormat::R_8:
+            case PixelFormat::R_12_UINT:
+            case PixelFormat::R_14_UINT:
+            case PixelFormat::R_16_UINT:
+                return 0;
+            case PixelFormat::RG_1212_UINT:
+            case PixelFormat::RG_1414_UINT:
+            case PixelFormat::RG_1616_UINT:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 0;
+                } else {
+                    return 16;
+                }
+            case PixelFormat::RGBA_12121212_UINT:
+            case PixelFormat::RGBA_14141414_UINT:
+            case PixelFormat::RGBA_10101010:
+            case PixelFormat::RGBA_FP16:
+                if (channel == gralloc4::PlaneLayoutComponentType_R) {
+                    return 0;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_G) {
+                    return 16;
+                } else if (channel == gralloc4::PlaneLayoutComponentType_B) {
+                    return 32;
+                } else {
+                    return 48;
+                }
+            case PixelFormat::UNSPECIFIED:
+            case PixelFormat::YCBCR_422_SP:
+            case PixelFormat::YCRCB_420_SP:
+            case PixelFormat::YCBCR_422_I:
+            case PixelFormat::RAW16:
+            case PixelFormat::BLOB:
+            case PixelFormat::IMPLEMENTATION_DEFINED:
+            case PixelFormat::YCBCR_420_888:
+            case PixelFormat::RAW_OPAQUE:
+            case PixelFormat::RAW10:
+            case PixelFormat::RAW12:
+            case PixelFormat::Y8:
+            case PixelFormat::Y16:
+            case PixelFormat::YV12:
+            case PixelFormat::DEPTH_16:
+            case PixelFormat::DEPTH_24:
+            case PixelFormat::DEPTH_24_STENCIL_8:
+            case PixelFormat::DEPTH_32F:
+            case PixelFormat::DEPTH_32F_STENCIL_8:
+            case PixelFormat::STENCIL_8:
+            case PixelFormat::YCBCR_P010:
+            case PixelFormat::YCBCR_P210:
+            case PixelFormat::HSV_888:
+                return -1;
+        }
+    }
+
+    int32_t bytesPerSample(PixelFormat format) {
+        switch (format) {
+            case PixelFormat::R_8:
+                return 1;
+            case PixelFormat::RGB_565:
+            case PixelFormat::R_12_UINT:
+            case PixelFormat::R_14_UINT:
+            case PixelFormat::R_16_UINT:
+                return 2;
+            case PixelFormat::RGB_888:
+                return 3;
+            case PixelFormat::RGBA_8888:
+            case PixelFormat::BGRA_8888:
+            case PixelFormat::RGBX_8888:
+            case PixelFormat::RGBA_1010102:
+            case PixelFormat::BGRA_1010102:
+            case PixelFormat::RG_1212_UINT:
+            case PixelFormat::RG_1414_UINT:
+            case PixelFormat::RG_1616_UINT:
+                return 4;
+
+            case PixelFormat::RGBA_10101010:
+            case PixelFormat::RGBA_FP16:
+
+            case PixelFormat::RGBA_12121212_UINT:
+            case PixelFormat::RGBA_14141414_UINT:
+                return 8;
+            case PixelFormat::UNSPECIFIED:
+            case PixelFormat::YCBCR_422_SP:
+            case PixelFormat::YCRCB_420_SP:
+            case PixelFormat::YCBCR_422_I:
+            case PixelFormat::RAW16:
+            case PixelFormat::BLOB:
+            case PixelFormat::IMPLEMENTATION_DEFINED:
+            case PixelFormat::YCBCR_420_888:
+            case PixelFormat::RAW_OPAQUE:
+            case PixelFormat::RAW10:
+            case PixelFormat::RAW12:
+            case PixelFormat::Y8:
+            case PixelFormat::Y16:
+            case PixelFormat::YV12:
+            case PixelFormat::DEPTH_16:
+            case PixelFormat::DEPTH_24:
+            case PixelFormat::DEPTH_24_STENCIL_8:
+            case PixelFormat::DEPTH_32F:
+            case PixelFormat::DEPTH_32F_STENCIL_8:
+            case PixelFormat::STENCIL_8:
+            case PixelFormat::YCBCR_P010:
+            case PixelFormat::YCBCR_P210:
+            case PixelFormat::HSV_888:
+                return -1;
+        }
+    }
 };
 
 class GraphicsMapperStableCTests
@@ -561,6 +829,66 @@ class GraphicsMapperStableCTests
     void TearDown() override {}
 };
 
+class GraphicsMapperStableCRgbaLockTests
+    : public GraphicsTestsBase,
+      public ::testing::TestWithParam<
+              std::tuple<std::tuple<std::string, std::shared_ptr<IAllocator>>, PixelFormat>> {
+  public:
+    void SetUp() override { Initialize(std::get<1>(std::get<0>(GetParam()))); }
+
+    void TearDown() override {}
+
+    PixelFormat getFormat() { return std::get<1>(GetParam()); }
+
+    bool isMandatory() {
+        switch (getFormat()) {
+            case PixelFormat::RGBA_8888:
+            case PixelFormat::RGBX_8888:
+            case PixelFormat::RGB_888:
+            case PixelFormat::RGB_565:
+            case PixelFormat::BGRA_8888:
+                return true;
+            case PixelFormat::UNSPECIFIED:
+            case PixelFormat::YCBCR_422_SP:
+            case PixelFormat::YCRCB_420_SP:
+            case PixelFormat::YCBCR_422_I:
+            case PixelFormat::RGBA_FP16:
+            case PixelFormat::RAW16:
+            case PixelFormat::BLOB:
+            case PixelFormat::IMPLEMENTATION_DEFINED:
+            case PixelFormat::YCBCR_420_888:
+            case PixelFormat::RAW_OPAQUE:
+            case PixelFormat::RAW10:
+            case PixelFormat::RAW12:
+            case PixelFormat::RGBA_1010102:
+            case PixelFormat::Y8:
+            case PixelFormat::Y16:
+            case PixelFormat::YV12:
+            case PixelFormat::DEPTH_16:
+            case PixelFormat::DEPTH_24:
+            case PixelFormat::DEPTH_24_STENCIL_8:
+            case PixelFormat::DEPTH_32F:
+            case PixelFormat::DEPTH_32F_STENCIL_8:
+            case PixelFormat::STENCIL_8:
+            case PixelFormat::YCBCR_P010:
+            case PixelFormat::HSV_888:
+            case PixelFormat::R_8:
+            case PixelFormat::R_16_UINT:
+            case PixelFormat::RG_1616_UINT:
+            case PixelFormat::RGBA_10101010:
+            case PixelFormat::YCBCR_P210:
+            case PixelFormat::R_12_UINT:
+            case PixelFormat::R_14_UINT:
+            case PixelFormat::RG_1212_UINT:
+            case PixelFormat::RG_1414_UINT:
+            case PixelFormat::RGBA_12121212_UINT:
+            case PixelFormat::RGBA_14141414_UINT:
+            case PixelFormat::BGRA_1010102:
+                return false;
+        }
+    }
+};
+
 TEST_P(GraphicsMapperStableCTests, VersionChecks) {
     ASSERT_NE(nullptr, getHalVersion()) << "Resolving ANDROID_HAL_MAPPER_VERSION symbol failed";
     int32_t halVersion = *getHalVersion();
@@ -708,13 +1036,14 @@ TEST_P(GraphicsMapperStableCTests, FreeBufferNegative) {
  * Test IMapper::lock and IMapper::unlock.
  */
 TEST_P(GraphicsMapperStableCTests, LockUnlockBasic) {
+    constexpr auto format = PixelFormat::RGBA_8888;
     constexpr auto usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN;
     auto buffer = allocate({
             .name = {"VTS_TEMP"},
             .width = 64,
             .height = 64,
             .layerCount = 1,
-            .format = PixelFormat::RGBA_8888,
+            .format = format,
             .usage = usage,
             .reservedSize = 0,
     });
@@ -729,8 +1058,7 @@ TEST_P(GraphicsMapperStableCTests, LockUnlockBasic) {
     ASSERT_EQ(AIMAPPER_ERROR_NONE,
               mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region, -1, (void**)&data));
 
-    // RGBA_8888
-    fillRGBA8888(data, info.height, stride * 4, info.width * 4);
+    fillRGBAType(data, info.height, stride * 4, info.width * 4);
 
     int releaseFence = -1;
     ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));
@@ -740,7 +1068,8 @@ TEST_P(GraphicsMapperStableCTests, LockUnlockBasic) {
                                                      releaseFence, (void**)&data));
     releaseFence = -1;
 
-    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888(*handle, data, info.height, stride * 4, info.width * 4));
+    ASSERT_NO_FATAL_FAILURE(
+            verifyRGBAType(*handle, data, info.height, stride * 4, info.width * 4, format));
 
     releaseFence = -1;
     ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));
@@ -795,7 +1124,7 @@ TEST_P(GraphicsMapperStableCTests, Lock_YCRCB_420_SP) {
             .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,
             .reservedSize = 0,
     };
-    auto buffer = allocate(info);
+    auto buffer = allocate(info, false);
     if (!buffer) {
         ASSERT_FALSE(isSupported(info));
         GTEST_SUCCEED() << "YCRCB_420_SP format is unsupported";
@@ -1016,7 +1345,7 @@ TEST_P(GraphicsMapperStableCTests, Lock_RAW10) {
             .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,
             .reservedSize = 0,
     };
-    auto buffer = allocate(info);
+    auto buffer = allocate(info, false);
     if (!buffer) {
         ASSERT_FALSE(isSupported(info));
         GTEST_SUCCEED() << "RAW10 format is unsupported";
@@ -1066,7 +1395,7 @@ TEST_P(GraphicsMapperStableCTests, Lock_RAW12) {
             .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,
             .reservedSize = 0,
     };
-    auto buffer = allocate(info);
+    auto buffer = allocate(info, false);
     if (!buffer) {
         ASSERT_FALSE(isSupported(info));
         GTEST_SUCCEED() << "RAW12 format is unsupported";
@@ -1116,7 +1445,7 @@ TEST_P(GraphicsMapperStableCTests, Lock_YCBCR_P010) {
             .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,
             .reservedSize = 0,
     };
-    auto buffer = allocate(info);
+    auto buffer = allocate(info, false);
     if (!buffer) {
         ASSERT_FALSE(isSupported(info));
         GTEST_SUCCEED() << "YCBCR_P010 format is unsupported";
@@ -1163,7 +1492,7 @@ TEST_P(GraphicsMapperStableCTests, Lock_YCBCR_P210) {
         .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,
         .reservedSize = 0,
     };
-    auto buffer = allocate(info);
+    auto buffer = allocate(info, false);
     if (!buffer) {
         ASSERT_FALSE(isSupported(info));
         GTEST_SUCCEED() << "YCBCR_P210 format is unsupported";
@@ -1301,13 +1630,13 @@ TEST_P(GraphicsMapperStableCTests, FlushRereadBasic) {
               mapper()->v5.lock(*readHandle, static_cast<uint64_t>(BufferUsage::CPU_READ_OFTEN),
                                 region, -1, (void**)&readData));
 
-    fillRGBA8888(writeData, info.height, stride * 4, info.width * 4);
+    fillRGBAType(writeData, info.height, stride * 4, info.width * 4);
 
     EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.flushLockedBuffer(*writeHandle));
     EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.rereadLockedBuffer(*readHandle));
 
-    ASSERT_NO_FATAL_FAILURE(
-            verifyRGBA8888(*readHandle, readData, info.height, stride * 4, info.width * 4));
+    ASSERT_NO_FATAL_FAILURE(verifyRGBAType(*readHandle, readData, info.height, stride * 4,
+                                           info.width * 4, PixelFormat::RGBA_8888));
 
     int releaseFence = -1;
 
@@ -1500,7 +1829,7 @@ TEST_P(GraphicsMapperStableCTests, GetProtectedContent) {
             .usage = BufferUsage::PROTECTED | BufferUsage::COMPOSER_OVERLAY,
             .reservedSize = 0,
     };
-    auto buffer = allocate(info);
+    auto buffer = allocate(info, false);
     if (!buffer) {
         ASSERT_FALSE(isSupported(info))
                 << "Allocation of trivial sized buffer failed, so isSupported() must be false";
@@ -1553,7 +1882,7 @@ TEST_P(GraphicsMapperStableCTests, GetPlaneLayouts) {
     ASSERT_TRUE(bufferHandle);
     auto value = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*bufferHandle);
     ASSERT_TRUE(value.has_value());
-    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888PlaneLayouts(*value));
+    ASSERT_NO_FATAL_FAILURE(verifyRGBATypePlaneLayouts(*value, PixelFormat::RGBA_8888));
 }
 
 TEST_P(GraphicsMapperStableCTests, GetCrop) {
@@ -1862,6 +2191,59 @@ TEST_P(GraphicsMapperStableCTests, GetUnsupportedMetadata) {
     EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);
 }
 
+TEST_P(GraphicsMapperStableCRgbaLockTests, Lock_RGB_Format) {
+    const auto format = getFormat();
+    constexpr auto usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN;
+    auto buffer = allocate(
+            {
+                    .name = {"VTS_TEMP"},
+                    .width = 64,
+                    .height = 64,
+                    .layerCount = 1,
+                    .format = format,
+                    .usage = usage,
+                    .reservedSize = 0,
+            },
+            isMandatory());
+
+    if (isMandatory()) {
+        ASSERT_NE(nullptr, buffer.get());
+    } else if (buffer.get() == nullptr) {
+        GTEST_SKIP() << "Format not supported: " << toString(format);
+        return;
+    }
+
+    // lock buffer for writing
+    const auto& info = buffer->info();
+    const auto stride = buffer->stride();
+    const ARect region{0, 0, info.width, info.height};
+    auto handle = buffer->import();
+    uint8_t* data = nullptr;
+    ASSERT_EQ(AIMAPPER_ERROR_NONE,
+              mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region, -1, (void**)&data));
+
+    const int32_t bps = bytesPerSample(format);
+
+    fillRGBAType(data, info.height, stride * bps, info.width * bps);
+
+    int releaseFence = -1;
+    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));
+
+    // lock again for reading
+    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region,
+                                                     releaseFence, (void**)&data));
+    releaseFence = -1;
+
+    ASSERT_NO_FATAL_FAILURE(
+            verifyRGBAType(*handle, data, info.height, stride * bps, info.width * bps, format));
+
+    releaseFence = -1;
+    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));
+    if (releaseFence != -1) {
+        close(releaseFence);
+    }
+}
+
 std::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> getIAllocatorsAtLeastVersion(
         int32_t minVersion) {
     auto instanceNames = getAidlHalInstanceNames(IAllocator::descriptor);
@@ -1887,4 +2269,23 @@ INSTANTIATE_TEST_CASE_P(PerInstance, GraphicsMapperStableCTests,
                             std::string name =
                                     std::to_string(info.index) + "/" + std::get<0>(info.param);
                             return Sanitize(name);
-                        });
\ No newline at end of file
+                        });
+GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(GraphicsMapperStableCRgbaLockTests);
+INSTANTIATE_TEST_CASE_P(
+        PerInstance, GraphicsMapperStableCRgbaLockTests,
+        testing::Combine(testing::ValuesIn(getIAllocatorsAtLeastVersion(2)),
+                         testing::Values(PixelFormat::RGBA_8888, PixelFormat::RGBX_8888,
+                                         PixelFormat::RGB_888, PixelFormat::RGB_565,
+                                         PixelFormat::BGRA_8888, PixelFormat::RGBA_FP16,
+                                         PixelFormat::RGBA_1010102, PixelFormat::R_8,
+                                         PixelFormat::R_16_UINT, PixelFormat::RG_1616_UINT,
+                                         PixelFormat::RGBA_10101010, PixelFormat::R_12_UINT,
+                                         PixelFormat::R_14_UINT, PixelFormat::RG_1212_UINT,
+                                         PixelFormat::RG_1414_UINT, PixelFormat::RGBA_12121212_UINT,
+                                         PixelFormat::RGBA_14141414_UINT,
+                                         PixelFormat::BGRA_1010102)),
+        [](auto info) -> std::string {
+            std::string name =
+                    std::to_string(info.index) + "/" + std::get<0>(std::get<0>(info.param));
+            return Sanitize(name);
+        });
\ No newline at end of file
diff --git a/health/aidl/vts/functional/VtsHalHealthTargetTest.cpp b/health/aidl/vts/functional/VtsHalHealthTargetTest.cpp
index fc735f7626..a646be30a1 100644
--- a/health/aidl/vts/functional/VtsHalHealthTargetTest.cpp
+++ b/health/aidl/vts/functional/VtsHalHealthTargetTest.cpp
@@ -24,6 +24,7 @@
 #include <aidl/Vintf.h>
 #include <aidl/android/hardware/health/BnHealthInfoCallback.h>
 #include <aidl/android/hardware/health/IHealth.h>
+#include <android-base/properties.h>
 #include <android/binder_auto_utils.h>
 #include <android/binder_enums.h>
 #include <android/binder_interface_utils.h>
@@ -88,7 +89,7 @@ MATCHER(IsValidSerialNumber, "") {
     if (!arg) {
         return true;
     }
-    if (arg->size() < 6) {
+    if (arg->size() < 4) {
         return false;
     }
     for (const auto& c : *arg) {
@@ -326,7 +327,13 @@ TEST_P(HealthAidl, getBatteryHealthData) {
 
     BatteryHealthData value;
     status = health->getBatteryHealthData(&value);
-    ASSERT_THAT(status, AnyOf(IsOk(), ExceptionIs(EX_UNSUPPORTED_OPERATION)));
+    // This operation is required in Android 17+
+    auto apiLevel = ::android::base::GetIntProperty<int32_t>("ro.vendor.api_level", 0);
+    if (apiLevel < 202604) {
+        ASSERT_THAT(status, AnyOf(IsOk(), ExceptionIs(EX_UNSUPPORTED_OPERATION)));
+    } else {
+        ASSERT_THAT(status, IsOk());
+    }
     if (!status.isOk()) return;
     ASSERT_THAT(value, IsValidHealthData(version));
 }
diff --git a/health/utils/libhealthloop/Android.bp b/health/utils/libhealthloop/Android.bp
index 08b3180325..762c4e81c5 100644
--- a/health/utils/libhealthloop/Android.bp
+++ b/health/utils/libhealthloop/Android.bp
@@ -24,12 +24,30 @@ package {
 bpf {
     name: "filterPowerSupplyEvents.o_non_vendor",
     srcs: ["filterPowerSupplyEvents.c"],
+    include_dirs: [
+        "system/bpf/include/defs",
+    ],
     visibility: ["//visibility:private"],
 }
 
 bpf {
     name: "filterPowerSupplyEvents.o",
     srcs: ["filterPowerSupplyEvents.c"],
+    include_dirs: [
+        "system/bpf/include/defs",
+    ],
+    // "vendor: true" because all binaries that use this BPF filter are vendor
+    // binaries.
+    vendor: true,
+}
+
+libbpf_prog {
+    name: "filterPowerSupplyEvents.bpf",
+    srcs: ["filterPowerSupplyEvents.c"],
+    header_libs: [
+        "android_bpf_defs",
+    ],
+
     // "vendor: true" because all binaries that use this BPF filter are vendor
     // binaries.
     vendor: true,
diff --git a/health/utils/libhealthloop/filterPowerSupplyEvents.c b/health/utils/libhealthloop/filterPowerSupplyEvents.c
index 5296993177..62560492bc 100644
--- a/health/utils/libhealthloop/filterPowerSupplyEvents.c
+++ b/health/utils/libhealthloop/filterPowerSupplyEvents.c
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-#include <bpf_helpers.h>    // load_word()
-#include <linux/bpf.h>      // struct __sk_buff
-#include <linux/netlink.h>  // struct nlmsghdr
-#include <stdint.h>         // uint32_t
+#include <android_bpf_defs.h>  // load_word()
+#include <linux/bpf.h>         // struct __sk_buff
+#include <linux/netlink.h>     // struct nlmsghdr
+#include <stdint.h>            // uint32_t
 
 // M4: match 4 bytes. Returns 0 if all bytes match.
 static inline uint32_t M4(struct __sk_buff* skb, unsigned int offset, uint8_t c0, uint8_t c1,
@@ -51,7 +51,7 @@ static inline uint32_t match_power_supply(struct __sk_buff* skb, unsigned int of
 
 // The Linux kernel 5.4 BPF verifier rejects this program, probably because of its size. Hence the
 // restriction that the kernel version must be at least 5.10.
-DEFINE_BPF_PROG_KVER("skfilter/power_supply", AID_ROOT, AID_SYSTEM, filterPowerSupplyEvents,
+DEFINE_BPF_PROG_KVER("skfilter/power_supply", AID_ROOT, AID_SYSTEM, skfilter_power_supply,
                      KVER(5, 10, 0))
 (struct __sk_buff* skb) {
     uint32_t i;
diff --git a/media/omx/1.0/vts/functional/common/media_hidl_test_common.h b/media/omx/1.0/vts/functional/common/media_hidl_test_common.h
index 6caac63100..33c5bcc539 100644
--- a/media/omx/1.0/vts/functional/common/media_hidl_test_common.h
+++ b/media/omx/1.0/vts/functional/common/media_hidl_test_common.h
@@ -165,6 +165,10 @@ struct CodecObserver : public IOmxObserver {
                     // event.
                     if (msg->data.eventData.event == OMX_EventBufferFlag)
                         continue;
+                    // Ignore vendor specific events.
+                    if (msg->data.eventData.event >= OMX_EventVendorStartUnused &&
+                        msg->data.eventData.event < OMX_EventMax)
+                        continue;
                     return ::android::hardware::media::omx::V1_0::Status::OK;
                 } else if (it->type == android::hardware::media::omx::V1_0::
                                            Message::Type::FILL_BUFFER_DONE) {
diff --git a/memtrack/aidl/default/Memtrack.cpp b/memtrack/aidl/default/Memtrack.cpp
index 49a6582989..a0123a3edf 100644
--- a/memtrack/aidl/default/Memtrack.cpp
+++ b/memtrack/aidl/default/Memtrack.cpp
@@ -21,17 +21,18 @@ namespace android {
 namespace hardware {
 namespace memtrack {
 
-ndk::ScopedAStatus Memtrack::getMemory(int pid, MemtrackType type,
-                                       std::vector<MemtrackRecord>* _aidl_return) {
-    if (pid < 0) {
-        return ndk::ScopedAStatus(AStatus_fromExceptionCode(EX_ILLEGAL_ARGUMENT));
-    }
-    if (type != MemtrackType::OTHER && type != MemtrackType::GL && type != MemtrackType::GRAPHICS &&
-        type != MemtrackType::MULTIMEDIA && type != MemtrackType::CAMERA) {
-        return ndk::ScopedAStatus(AStatus_fromExceptionCode(EX_UNSUPPORTED_OPERATION));
-    }
-    _aidl_return->clear();
-    return ndk::ScopedAStatus::ok();
+namespace {
+
+// LINT.IfChange
+constexpr char kMemtrackDefaultMsg[] = "memtrack default implementation";
+// LINT.ThenChange(/frameworks/native/services/memtrackproxy/MemtrackProxy.cpp)
+
+}  // namespace
+
+ndk::ScopedAStatus Memtrack::getMemory([[maybe_unused]] int pid, [[maybe_unused]] MemtrackType type,
+                                       [[maybe_unused]] std::vector<MemtrackRecord>* _aidl_return) {
+    return ndk::ScopedAStatus::fromExceptionCodeWithMessage(EX_UNSUPPORTED_OPERATION,
+                                                            kMemtrackDefaultMsg);
 }
 
 ndk::ScopedAStatus Memtrack::getGpuDeviceInfo(std::vector<DeviceInfo>* _aidl_return) {
diff --git a/memtrack/aidl/vts/VtsHalMemtrackTargetTest.cpp b/memtrack/aidl/vts/VtsHalMemtrackTargetTest.cpp
index 8905f50eaf..e1d1b35a33 100644
--- a/memtrack/aidl/vts/VtsHalMemtrackTargetTest.cpp
+++ b/memtrack/aidl/vts/VtsHalMemtrackTargetTest.cpp
@@ -31,6 +31,13 @@ using android::vintf::KernelVersion;
 using android::vintf::RuntimeInfo;
 using android::vintf::VintfObject;
 
+constexpr char kMemtrackDefaultMsg[] = "memtrack default implementation";
+
+static inline bool isMemtrackDefaultImpl(const ndk::ScopedAStatus& status) {
+    return !status.isOk() && status.getExceptionCode() == EX_UNSUPPORTED_OPERATION &&
+           strcmp(status.getMessage(), kMemtrackDefaultMsg) == 0;
+}
+
 class MemtrackAidlTest : public testing::TestWithParam<std::string> {
   public:
     virtual void SetUp() override {
@@ -52,6 +59,11 @@ TEST_P(MemtrackAidlTest, GetMemoryInvalidPid) {
 
         auto status = memtrack_->getMemory(pid, type, &records);
 
+        if (isMemtrackDefaultImpl(status)) {
+            ASSERT_TRUE(true);
+            return;
+        }
+
         EXPECT_EQ(status.getExceptionCode(), EX_ILLEGAL_ARGUMENT);
     }
 }
@@ -63,7 +75,12 @@ TEST_P(MemtrackAidlTest, GetMemoryInvalidType) {
 
     auto status = memtrack_->getMemory(pid, type, &records);
 
-    EXPECT_EQ(status.getExceptionCode(), EX_UNSUPPORTED_OPERATION);
+    if (isMemtrackDefaultImpl(status)) {
+        ASSERT_TRUE(true);
+        return;
+    }
+
+    EXPECT_EQ(status.getExceptionCode(), EX_ILLEGAL_ARGUMENT);
 }
 
 TEST_P(MemtrackAidlTest, GetMemory) {
@@ -73,6 +90,11 @@ TEST_P(MemtrackAidlTest, GetMemory) {
 
         auto status = memtrack_->getMemory(pid, type, &records);
 
+        if (isMemtrackDefaultImpl(status)) {
+            ASSERT_TRUE(true);
+            return;
+        }
+
         EXPECT_TRUE(status.isOk());
     }
 }
diff --git a/neuralnetworks/aidl/Android.bp b/neuralnetworks/aidl/Android.bp
index e7583aa6a1..eb9b0f9577 100644
--- a/neuralnetworks/aidl/Android.bp
+++ b/neuralnetworks/aidl/Android.bp
@@ -42,28 +42,28 @@ aidl_interface {
             version: "1",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
         {
             version: "2",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
         {
             version: "3",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
         {
             version: "4",
             imports: [
                 "android.hardware.common-V2",
-                "android.hardware.graphics.common-V6",
+                "android.hardware.graphics.common-V7",
             ],
         },
 
diff --git a/nfc/aidl/Android.bp b/nfc/aidl/Android.bp
index 93f8a87140..68148af7bf 100644
--- a/nfc/aidl/Android.bp
+++ b/nfc/aidl/Android.bp
@@ -33,9 +33,13 @@ aidl_interface {
             enabled: false,
         },
         java: {
-            enabled: false,
+            enabled: true,
             sdk_version: "module_current",
             min_sdk_version: "35",
+            apex_available: [
+                "//apex_available:platform",
+                "com.android.nfcservices",
+            ],
         },
         ndk: {
             enabled: true,
diff --git a/nfc/aidl/vts/functional/VtsNfcBehaviorChangesTest.cpp b/nfc/aidl/vts/functional/VtsNfcBehaviorChangesTest.cpp
index d3fcbb3b74..b8597e82bd 100644
--- a/nfc/aidl/vts/functional/VtsNfcBehaviorChangesTest.cpp
+++ b/nfc/aidl/vts/functional/VtsNfcBehaviorChangesTest.cpp
@@ -287,6 +287,25 @@ protected:
         }
 
         ASSERT_TRUE(sIsNfaEnabled) << "Could not initialize NFC controller";
+
+        // Disable polling.
+        uint8_t rf_discovery_cmd[] = {0x21, 0x03, 0x07, 0x03, 0x80, 0x01, 0x81, 0x01, 0x82, 0x01};
+        NFA_SendRawVsCommand(sizeof(rf_discovery_cmd), rf_discovery_cmd, nfaVSCallback);
+        usleep(10000);
+
+        uint8_t cmd[] = {NCI_ANDROID_SET_PASSIVE_OBSERVER_TECH, 0x0B};
+        status = NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, sizeof(cmd), cmd, nfaVSCallback);
+        if (status == NFA_STATUS_OK) {
+            if (!sNfaVsCommand.wait(1000)) {
+                LOG(WARNING) << "Timeout waiting for observemode response";
+            }
+        }
+    }
+
+    static void TearDownTestSuite() {
+        uint8_t rf_deactivate_cmd[] = {0x21, 0x06, 0x01, 0x00};
+        NFA_SendRawVsCommand(sizeof(rf_deactivate_cmd), rf_deactivate_cmd, nfaVSCallback);
+        usleep(10000);
     }
 };
 
@@ -338,11 +357,15 @@ TEST_P(NfcBehaviorChanges, SetPassiveObserverTech_allOnAndOff) {
         GTEST_SKIP() << "Skipping test for board API level < 202504";
     }
 
-    tNFC_STATUS status = nfaSetPassiveObserverTech(0x0F);
+    tNFC_STATUS status = nfaSetPassiveObserverTech(NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_A |
+                                                   NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_B |
+                                                   NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_V);
     ASSERT_EQ(status, NFA_STATUS_OK);
     status = nfaQueryObserveModeState();
     ASSERT_EQ(status, NFA_STATUS_OK);
-    ASSERT_EQ(sObserveModeState, 0x0F);
+    ASSERT_EQ(sObserveModeState, NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_A |
+                                         NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_B |
+                                         NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_V);
 
     status = nfaSetPassiveObserverTech(0x00);
     ASSERT_EQ(status, NFA_STATUS_OK);
@@ -363,7 +386,9 @@ TEST_P(NfcBehaviorChanges, SetPassiveObserverTech_testThroughput) {
     }
 
     for (int i = 0; i < 100; ++i) {
-        tNFC_STATUS status = nfaSetPassiveObserverTech(0x0F);
+        tNFC_STATUS status = nfaSetPassiveObserverTech(NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_A |
+                                                       NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_B |
+                                                       NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_V);
         ASSERT_EQ(status, NFA_STATUS_OK);
 
         status = nfaSetPassiveObserverTech(0x00);
diff --git a/power/1.1/vts/OWNERS b/power/1.1/vts/OWNERS
index 3a64da73f8..9a765b9e3d 100644
--- a/power/1.1/vts/OWNERS
+++ b/power/1.1/vts/OWNERS
@@ -1,2 +1,3 @@
 # Bug component: 158088
-wvw@google.com
+guibing@google.com
+jimmyshiu@google.com
diff --git a/power/aidl/android/hardware/power/CpuHeadroomResult.aidl b/power/aidl/android/hardware/power/CpuHeadroomResult.aidl
index e7ed8b66ec..7f3a519d56 100644
--- a/power/aidl/android/hardware/power/CpuHeadroomResult.aidl
+++ b/power/aidl/android/hardware/power/CpuHeadroomResult.aidl
@@ -19,8 +19,11 @@ package android.hardware.power;
 /**
  * Headroom value result depending on the request params.
  *
- * Each value is ranged from [0, 100], where 0 indicates no CPU resources were left
- * during the calculation interval and the app may expect low resources to be granted.
+ * Each value is either NaN or ranged from [0, 100], where NaN indicates that the result is
+ * temporarily unavailable (e.g. there is not enough util data to compute or the variance is too
+ * high to be actionable) such that the caller may not take any action until a non-NaN value is
+ * returned, while value 0 indicates no resources were left during the calculation interval
+ * and the caller may expect low resources to be granted.
  */
 @VintfStability
 @JavaDerive(equals=true, toString=true)
diff --git a/power/aidl/android/hardware/power/GpuHeadroomResult.aidl b/power/aidl/android/hardware/power/GpuHeadroomResult.aidl
index ef3257dea1..e083c574b4 100644
--- a/power/aidl/android/hardware/power/GpuHeadroomResult.aidl
+++ b/power/aidl/android/hardware/power/GpuHeadroomResult.aidl
@@ -19,8 +19,11 @@ package android.hardware.power;
 /**
  * Headroom value result depending on the request params.
  *
- * Each value is ranged from [0, 100], where 0 indicates no GPU resources were left
- * during the calculation interval and the app may expect low resources to be granted.
+ * Each value is either NaN or ranged from [0, 100], where NaN indicates that the result is
+ * temporarily unavailable (e.g. there is not enough util data to compute or the variance is too
+ * high to be actionable) such that the caller may not take any action until a non-NaN value is
+ * returned, while value 0 indicates no resources were left during the calculation interval
+ * and the caller may expect low resources to be granted.
  */
 @VintfStability
 @JavaDerive(equals=true, toString=true)
diff --git a/power/aidl/vts/VtsHalPowerTargetTest.cpp b/power/aidl/vts/VtsHalPowerTargetTest.cpp
index 93b7c38b10..18965a22f6 100644
--- a/power/aidl/vts/VtsHalPowerTargetTest.cpp
+++ b/power/aidl/vts/VtsHalPowerTargetTest.cpp
@@ -321,8 +321,11 @@ TEST_P(PowerAidl, getCpuHeadroom) {
     ASSERT_GE(mSupportInfo->headroom.cpuMaxCalculationWindowMillis, 10000);
     ASSERT_GE(mSupportInfo->headroom.cpuMaxTidCount, 5);
     ASSERT_EQ(headroom.getTag(), CpuHeadroomResult::globalHeadroom);
-    ASSERT_GE(headroom.get<CpuHeadroomResult::globalHeadroom>(), 0.0f);
-    ASSERT_LE(headroom.get<CpuHeadroomResult::globalHeadroom>(), 100.00f);
+    float val = headroom.get<CpuHeadroomResult::globalHeadroom>();
+    if (!isnan(val)) {
+        ASSERT_GE(val, 0.0f);
+        ASSERT_LE(val, 100.00f);
+    }
 }
 
 TEST_P(PowerAidl, getGpuHeadroom) {
@@ -341,8 +344,11 @@ TEST_P(PowerAidl, getGpuHeadroom) {
     ASSERT_LE(mSupportInfo->headroom.gpuMinCalculationWindowMillis, 50);
     ASSERT_GE(mSupportInfo->headroom.gpuMaxCalculationWindowMillis, 10000);
     ASSERT_EQ(headroom.getTag(), GpuHeadroomResult::globalHeadroom);
-    ASSERT_GE(headroom.get<GpuHeadroomResult::globalHeadroom>(), 0.0f);
-    ASSERT_LE(headroom.get<GpuHeadroomResult::globalHeadroom>(), 100.00f);
+    float val = headroom.get<GpuHeadroomResult::globalHeadroom>();
+    if (!isnan(val)) {
+        ASSERT_GE(val, 0.0f);
+        ASSERT_LE(val, 100.00f);
+    }
 }
 
 // FIXED_PERFORMANCE mode is required for all devices which ship on Android 11
diff --git a/power/stats/aidl/OWNERS b/power/stats/aidl/OWNERS
index e0d66d720b..da57da2e97 100644
--- a/power/stats/aidl/OWNERS
+++ b/power/stats/aidl/OWNERS
@@ -1,3 +1,4 @@
+# Bug component: 709877
 darrenhsu@google.com
 joaodias@google.com
 krossmo@google.com
diff --git a/radio/1.5/Android.bp b/radio/1.5/Android.bp
index a36f296c2b..99fa6045b8 100644
--- a/radio/1.5/Android.bp
+++ b/radio/1.5/Android.bp
@@ -28,5 +28,4 @@ hidl_interface {
         "android.hidl.safe_union@1.0",
     ],
     gen_java: true,
-    system_ext_specific: true,
 }
diff --git a/radio/1.6/Android.bp b/radio/1.6/Android.bp
index 2137e8d7d9..4b79c0a43e 100644
--- a/radio/1.6/Android.bp
+++ b/radio/1.6/Android.bp
@@ -29,5 +29,4 @@ hidl_interface {
         "android.hidl.safe_union@1.0",
     ],
     gen_java: true,
-    system_ext_specific: true,
 }
diff --git a/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/DataNetworkState.aidl b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/DataNetworkState.aidl
new file mode 100644
index 0000000000..cad1b9416c
--- /dev/null
+++ b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/DataNetworkState.aidl
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.radio.data;
+/* @hide */
+@Backing(type="int") @JavaDerive(toString=true) @VintfStability
+enum DataNetworkState {
+  UNKNOWN = (-1) /* -1 */,
+  DISCONNECTED = 0,
+  CONNECTING = 1,
+  CONNECTED = 2,
+  DISCONNECTING = 4,
+}
diff --git a/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioData.aidl b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioData.aidl
index 3888c627e7..8ffece5db9 100644
--- a/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioData.aidl
+++ b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioData.aidl
@@ -51,4 +51,7 @@ interface IRadioData {
   oneway void startHandover(in int serial, in int callId);
   oneway void startKeepalive(in int serial, in android.hardware.radio.data.KeepaliveRequest keepalive);
   oneway void stopKeepalive(in int serial, in int sessionHandle);
+  oneway void setUserDataEnabled(in int serial, in boolean enabled);
+  oneway void setUserDataRoamingEnabled(in int serial, in boolean enabled);
+  oneway void notifyImsDataNetwork(in int serial, in android.hardware.radio.AccessNetwork accessNetwork, in android.hardware.radio.data.DataNetworkState dataNetworkState, in android.hardware.radio.data.TransportType physicalTransportType, in int physicalNetworkModemId);
 }
diff --git a/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioDataResponse.aidl b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioDataResponse.aidl
index dc44454f3f..6b4b133e65 100644
--- a/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioDataResponse.aidl
+++ b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/IRadioDataResponse.aidl
@@ -50,4 +50,7 @@ interface IRadioDataResponse {
   oneway void startHandoverResponse(in android.hardware.radio.RadioResponseInfo info);
   oneway void startKeepaliveResponse(in android.hardware.radio.RadioResponseInfo info, in android.hardware.radio.data.KeepaliveStatus status);
   oneway void stopKeepaliveResponse(in android.hardware.radio.RadioResponseInfo info);
+  oneway void setUserDataEnabledResponse(in android.hardware.radio.RadioResponseInfo info);
+  oneway void setUserDataRoamingEnabledResponse(in android.hardware.radio.RadioResponseInfo info);
+  oneway void notifyImsDataNetworkResponse(in android.hardware.radio.RadioResponseInfo info);
 }
diff --git a/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/TransportType.aidl b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/TransportType.aidl
new file mode 100644
index 0000000000..b2289e8fb3
--- /dev/null
+++ b/radio/aidl/aidl_api/android.hardware.radio.data/current/android/hardware/radio/data/TransportType.aidl
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.radio.data;
+/* @hide */
+@Backing(type="int") @JavaDerive(toString=true) @VintfStability
+enum TransportType {
+  WWAN = 1,
+  WLAN = 2,
+}
diff --git a/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioIms.aidl b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioIms.aidl
index 6018a4b904..98735354de 100644
--- a/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioIms.aidl
+++ b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioIms.aidl
@@ -43,4 +43,5 @@ interface IRadioIms {
   oneway void setResponseFunctions(in android.hardware.radio.ims.IRadioImsResponse radioImsResponse, in android.hardware.radio.ims.IRadioImsIndication radioImsIndication);
   oneway void sendAnbrQuery(int serial, android.hardware.radio.ims.ImsStreamType mediaType, android.hardware.radio.ims.ImsStreamDirection direction, int bitsPerSecond);
   oneway void updateImsCallStatus(int serial, in android.hardware.radio.ims.ImsCall[] imsCalls);
+  oneway void updateAllowedServices(in int serial, in android.hardware.radio.ims.ImsService[] imsServices);
 }
diff --git a/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioImsResponse.aidl b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioImsResponse.aidl
index fbb1bfc66c..3bcc253737 100644
--- a/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioImsResponse.aidl
+++ b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/IRadioImsResponse.aidl
@@ -42,4 +42,5 @@ interface IRadioImsResponse {
   oneway void triggerEpsFallbackResponse(in android.hardware.radio.RadioResponseInfo info);
   oneway void sendAnbrQueryResponse(in android.hardware.radio.RadioResponseInfo info);
   oneway void updateImsCallStatusResponse(in android.hardware.radio.RadioResponseInfo info);
+  oneway void updateAllowedServicesResponse(in android.hardware.radio.RadioResponseInfo info);
 }
diff --git a/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/ImsService.aidl b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/ImsService.aidl
new file mode 100644
index 0000000000..2dbf73a27f
--- /dev/null
+++ b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/ImsService.aidl
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.radio.ims;
+/* @hide */
+@JavaDerive(toString=true) @RustDerive(Clone=true, Eq=true, PartialEq=true) @VintfStability
+parcelable ImsService {
+  android.hardware.radio.ims.ImsServiceType serviceType = android.hardware.radio.ims.ImsServiceType.INVALID;
+  android.hardware.radio.ims.ImsService.RoamingType roamingType = android.hardware.radio.ims.ImsService.RoamingType.ANY;
+  @Backing(type="int")
+  enum RoamingType {
+    ANY = 0,
+    HOME_ONLY = 1,
+  }
+}
diff --git a/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/ImsServiceType.aidl b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/ImsServiceType.aidl
new file mode 100644
index 0000000000..a728d7dce9
--- /dev/null
+++ b/radio/aidl/aidl_api/android.hardware.radio.ims/current/android/hardware/radio/ims/ImsServiceType.aidl
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.radio.ims;
+/* @hide */
+@Backing(type="int") @JavaDerive(toString=true) @VintfStability
+enum ImsServiceType {
+  INVALID = 0,
+  VOLTE = 1,
+  VOWIFI = 2,
+  VONR = 3,
+}
diff --git a/radio/aidl/android/hardware/radio/data/DataNetworkState.aidl b/radio/aidl/android/hardware/radio/data/DataNetworkState.aidl
new file mode 100644
index 0000000000..419655b78a
--- /dev/null
+++ b/radio/aidl/android/hardware/radio/data/DataNetworkState.aidl
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.hardware.radio.data;
+
+/**
+ * Represents the state of a data network connection.
+ * This is designed to have a direct one-to-one mapping with the states
+ * defined in {@link android.telephony.TelephonyManager.DataState}.
+ *
+ * @hide
+ */
+@VintfStability
+@Backing(type="int")
+@JavaDerive(toString=true)
+enum DataNetworkState {
+    /**
+     * Data network state is unknown.
+     */
+    UNKNOWN = -1,
+    /**
+     * Data network state is disconnected.
+     */
+    DISCONNECTED = 0,
+    /**
+     * Data network state is connecting.
+     */
+    CONNECTING = 1,
+    /**
+     * Data network state is connected.
+     */
+    CONNECTED = 2,
+    /**
+     * Data network state is disconnecting.
+     */
+    DISCONNECTING = 4,
+}
diff --git a/radio/aidl/android/hardware/radio/data/IRadioData.aidl b/radio/aidl/android/hardware/radio/data/IRadioData.aidl
index a73616ac18..a4d020a04e 100644
--- a/radio/aidl/android/hardware/radio/data/IRadioData.aidl
+++ b/radio/aidl/android/hardware/radio/data/IRadioData.aidl
@@ -17,6 +17,7 @@
 package android.hardware.radio.data;
 
 import android.hardware.radio.AccessNetwork;
+import android.hardware.radio.data.DataNetworkState;
 import android.hardware.radio.data.DataProfileInfo;
 import android.hardware.radio.data.DataRequestReason;
 import android.hardware.radio.data.DataThrottlingAction;
@@ -26,6 +27,7 @@ import android.hardware.radio.data.KeepaliveRequest;
 import android.hardware.radio.data.LinkAddress;
 import android.hardware.radio.data.SliceInfo;
 import android.hardware.radio.data.TrafficDescriptor;
+import android.hardware.radio.data.TransportType;
 
 /**
  * This interface is used by telephony and telecom to talk to cellular radio for data APIs.
@@ -305,4 +307,48 @@ oneway interface IRadioData {
      * This is available when android.hardware.telephony.data is defined.
      */
     void stopKeepalive(in int serial, in int sessionHandle);
+
+    /**
+     * Set the user data setting to the modem. This API is for informational purposes. The modem
+     * must not block any subsequent setup data call requests.
+     *
+     * @param serial Serial number of request.
+     * @param enabled Whether the user mobile data is enabled.
+     *
+     * Response function is IRadioDataResponse.setUserDataEnabledResponse()
+     *
+     * This is available when android.hardware.telephony.data is defined.
+     */
+    void setUserDataEnabled(in int serial, in boolean enabled);
+
+    /**
+     * Set the user data roaming setting to the modem. This API is for informational purposes. The
+     * modem must not block any subsequent setup data call requests.
+     *
+     * @param serial Serial number of request.
+     * @param enabled Whether the user mobile data roaming is enabled.
+     *
+     * Response function is IRadioDataResponse.setUserDataRoamingEnabledResponse()
+     *
+     * This is available when android.hardware.telephony.data is defined.
+     */
+    void setUserDataRoamingEnabled(in int serial, in boolean enabled);
+
+    /**
+     * Notify IMS data network to the modem.
+     *
+     * @param serial Serial number of request.
+     * @param accessNetwork The access network type.
+     * @param dataNetworkState The data network connection state.
+     * @param physicalTransportType The physical transport type of the data network.
+     * @param physicalNetworkModemId The logic modem ID while the physical transport type is WWAN.
+     *        If the physical transport type is WLAN, this modem ID will be -1.
+     *
+     * Response function is IRadioDataResponse.notifyImsDataNetworkResponse()
+     *
+     * This is available when android.hardware.telephony.data is defined.
+     */
+    void notifyImsDataNetwork(in int serial, in AccessNetwork accessNetwork,
+            in DataNetworkState dataNetworkState, in TransportType physicalTransportType,
+            in int physicalNetworkModemId);
 }
diff --git a/radio/aidl/android/hardware/radio/data/IRadioDataResponse.aidl b/radio/aidl/android/hardware/radio/data/IRadioDataResponse.aidl
index 76246063f4..e26a1e784f 100644
--- a/radio/aidl/android/hardware/radio/data/IRadioDataResponse.aidl
+++ b/radio/aidl/android/hardware/radio/data/IRadioDataResponse.aidl
@@ -240,4 +240,43 @@ oneway interface IRadioDataResponse {
      *   RadioError:INVALID_ARGUMENTS
      */
     void stopKeepaliveResponse(in RadioResponseInfo info);
+
+    /**
+     * @param info Response info struct containing response type, serial no. and error
+     *
+     * Valid errors returned:
+     *   RadioError:REQUEST_NOT_SUPPORTED when android.hardware.telephony.ims is not defined
+     *   RadioError:NONE
+     *   RadioError:RADIO_NOT_AVAILABLE
+     *   RadioError:INTERNAL_ERR
+     *   RadioError:NO_RESOURCES
+     *   RadioError:INVALID_CALL_ID
+     */
+    void setUserDataEnabledResponse(in RadioResponseInfo info);
+
+    /**
+     * @param info Response info struct containing response type, serial no. and error
+     *
+     * Valid errors returned:
+     *   RadioError:REQUEST_NOT_SUPPORTED when android.hardware.telephony.ims is not defined
+     *   RadioError:NONE
+     *   RadioError:RADIO_NOT_AVAILABLE
+     *   RadioError:INTERNAL_ERR
+     *   RadioError:NO_RESOURCES
+     *   RadioError:INVALID_CALL_ID
+     */
+    void setUserDataRoamingEnabledResponse(in RadioResponseInfo info);
+
+    /**
+     * @param info Response info struct containing response type, serial no. and error
+     *
+     * Valid errors returned:
+     *   RadioError:REQUEST_NOT_SUPPORTED when android.hardware.telephony.data is not defined
+     *   RadioError:NONE
+     *   RadioError:RADIO_NOT_AVAILABLE
+     *   RadioError:INTERNAL_ERR
+     *   RadioError:NO_RESOURCES
+     *   RadioError:INVALID_CALL_ID
+     */
+    void notifyImsDataNetworkResponse(in RadioResponseInfo info);
 }
diff --git a/radio/aidl/android/hardware/radio/data/SetupDataCallResult.aidl b/radio/aidl/android/hardware/radio/data/SetupDataCallResult.aidl
index 8f13050275..475658655e 100644
--- a/radio/aidl/android/hardware/radio/data/SetupDataCallResult.aidl
+++ b/radio/aidl/android/hardware/radio/data/SetupDataCallResult.aidl
@@ -115,11 +115,17 @@ parcelable SetupDataCallResult {
     String[] pcscf;
     /**
      * MTU received from network for IPv4.
+     * It is an unsigned 16-bit integer, meaning its valid range is from 0 to 65535.
+     * Additionally, the MTU must be an even number. If an odd value is received,
+     * it will be rounded down.
      * Value <= 0 means network has either not sent a value or sent an invalid value.
      */
     int mtuV4;
     /**
      * MTU received from network for IPv6.
+     * It is an unsigned 16-bit integer, meaning its valid range is from 0 to 65535.
+     * Additionally, the MTU must be an even number. If an odd value is received,
+     * it will be rounded down.
      * Value <= 0 means network has either not sent a value or sent an invalid value.
      */
     int mtuV6;
diff --git a/vibrator/1.1/types.hal b/radio/aidl/android/hardware/radio/data/TransportType.aidl
similarity index 59%
rename from vibrator/1.1/types.hal
rename to radio/aidl/android/hardware/radio/data/TransportType.aidl
index 72deb4a7e9..c4b68e1b7b 100644
--- a/vibrator/1.1/types.hal
+++ b/radio/aidl/android/hardware/radio/data/TransportType.aidl
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,19 @@
  * limitations under the License.
  */
 
-package android.hardware.vibrator@1.1;
+package android.hardware.radio.data;
 
-import @1.0::Effect;
-
-// NOTE: suffix '_1_1' is for legacy ABI compatibility. It cannot be
-// changed to 'Effect' which the convention dictates.
-@export
-enum Effect_1_1 : @1.0::Effect {
+/** @hide */
+@VintfStability
+@Backing(type="int")
+@JavaDerive(toString=true)
+enum TransportType {
+    /**
+     * Transport type for Wireless Wide Area Networks (i.e. Cellular)
+     */
+    WWAN = 1,
     /**
-     * A tick effect.
-     *
-     * This effect should produce a soft, short sensation, like the tick of a clock.
+     * Transport type for Wireless Local Area Networks (i.e. Wifi)
      */
-    TICK
-};
+    WLAN = 2,
+}
diff --git a/radio/aidl/android/hardware/radio/ims/IRadioIms.aidl b/radio/aidl/android/hardware/radio/ims/IRadioIms.aidl
index 90792f7f88..8861f16424 100644
--- a/radio/aidl/android/hardware/radio/ims/IRadioIms.aidl
+++ b/radio/aidl/android/hardware/radio/ims/IRadioIms.aidl
@@ -22,6 +22,7 @@ import android.hardware.radio.ims.IRadioImsIndication;
 import android.hardware.radio.ims.IRadioImsResponse;
 import android.hardware.radio.ims.ImsCall;
 import android.hardware.radio.ims.ImsRegistration;
+import android.hardware.radio.ims.ImsService;
 import android.hardware.radio.ims.ImsStreamDirection;
 import android.hardware.radio.ims.ImsStreamType;
 import android.hardware.radio.ims.ImsTrafficType;
@@ -166,4 +167,17 @@ oneway interface IRadioIms {
      * This is available when android.hardware.telephony.ims is defined.
      */
     void updateImsCallStatus(int serial, in ImsCall[] imsCalls);
+
+    /**
+     * Update allowed IMS services to the modem. The modem can use the information for 3GPP
+     * specifications and carriers' requirements e.g. system determination.
+     *
+     * @param serial Serial number of request.
+     * @param imsServices The list of allowed services
+     *
+     * Response function is IRadioImsResponse.updateAllowedServicesResponse()
+     *
+     * This is available when android.hardware.telephony.ims is defined.
+     */
+    void updateAllowedServices(in int serial, in ImsService[] imsServices);
 }
diff --git a/radio/aidl/android/hardware/radio/ims/IRadioImsResponse.aidl b/radio/aidl/android/hardware/radio/ims/IRadioImsResponse.aidl
index ca33d071b7..2b4d6241db 100644
--- a/radio/aidl/android/hardware/radio/ims/IRadioImsResponse.aidl
+++ b/radio/aidl/android/hardware/radio/ims/IRadioImsResponse.aidl
@@ -146,4 +146,21 @@ oneway interface IRadioImsResponse {
      *   RadioError:NO_RESOURCES
      */
     void updateImsCallStatusResponse(in RadioResponseInfo info);
+
+    /**
+     * @param info Response info struct containing response type, serial no. and error
+     *
+     * Valid errors returned:
+     *   RadioError:REQUEST_NOT_SUPPORTED when android.hardware.telephony.ims is not defined
+     *   RadioError:NONE
+     *   RadioError:RADIO_NOT_AVAILABLE
+     *   RadioError:INVALID_STATE
+     *   RadioError:NO_MEMORY
+     *   RadioError:SYSTEM_ERR
+     *   RadioError:MODEM_ERR
+     *   RadioError:INTERNAL_ERR
+     *   RadioError:INVALID_ARGUMENTS
+     *   RadioError:NO_RESOURCES
+     */
+    void updateAllowedServicesResponse(in RadioResponseInfo info);
 }
diff --git a/radio/aidl/android/hardware/radio/ims/ImsService.aidl b/radio/aidl/android/hardware/radio/ims/ImsService.aidl
new file mode 100644
index 0000000000..22167b1ab9
--- /dev/null
+++ b/radio/aidl/android/hardware/radio/ims/ImsService.aidl
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.hardware.radio.ims;
+
+import android.hardware.radio.ims.ImsServiceType;
+
+/** @hide */
+@VintfStability
+@JavaDerive(toString=true)
+@RustDerive(Clone=true, Eq=true, PartialEq=true)
+parcelable ImsService {
+    @Backing(type="int")
+    enum RoamingType {
+        /** Any roaming type */
+        ANY = 0,
+        /** Home only */
+        HOME_ONLY = 1,
+    }
+    /** The type of the service */
+    ImsServiceType serviceType = ImsServiceType.INVALID;
+    /** The roaming type of the service */
+    RoamingType roamingType = RoamingType.ANY;
+}
diff --git a/radio/aidl/android/hardware/radio/ims/ImsServiceType.aidl b/radio/aidl/android/hardware/radio/ims/ImsServiceType.aidl
new file mode 100644
index 0000000000..bfe5f46282
--- /dev/null
+++ b/radio/aidl/android/hardware/radio/ims/ImsServiceType.aidl
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.hardware.radio.ims;
+
+/** @hide */
+@VintfStability
+@Backing(type="int")
+@JavaDerive(toString=true)
+enum ImsServiceType {
+    /**
+     * Do not use it.
+     */
+    INVALID = 0,
+    /**
+     * Voice over LTE.
+     */
+    VOLTE = 1,
+    /**
+     * Voice over IWLAN.
+     */
+    VOWIFI = 2,
+    /**
+     * Voice over NR.
+     */
+    VONR = 3,
+}
diff --git a/radio/aidl/android/hardware/radio/modem/IRadioModemIndication.aidl b/radio/aidl/android/hardware/radio/modem/IRadioModemIndication.aidl
index ba3c510589..9f654c7f9a 100644
--- a/radio/aidl/android/hardware/radio/modem/IRadioModemIndication.aidl
+++ b/radio/aidl/android/hardware/radio/modem/IRadioModemIndication.aidl
@@ -72,7 +72,7 @@ oneway interface IRadioModemIndication {
     void radioStateChanged(in RadioIndicationType type, in RadioState radioState);
 
     /**
-     * Indicates the ril connects and returns the version
+     * Indicates the ril connects to the modem.
      *
      * @param type Type of radio indication
      */
diff --git a/radio/aidl/android/hardware/radio/network/SecurityAlgorithmUpdate.aidl b/radio/aidl/android/hardware/radio/network/SecurityAlgorithmUpdate.aidl
index 59b5f6e68f..08cbad1c2d 100644
--- a/radio/aidl/android/hardware/radio/network/SecurityAlgorithmUpdate.aidl
+++ b/radio/aidl/android/hardware/radio/network/SecurityAlgorithmUpdate.aidl
@@ -42,8 +42,7 @@ parcelable SecurityAlgorithmUpdate {
      */
     SecurityAlgorithm integrity = SecurityAlgorithm.A50;
     /**
-     * Whether or not this connection event is associated with an
-     * unauthenticated / unencrypted emergency session
+     * Whether or not an emergency session is ongoing and current connection is unprotected.
      */
     boolean isUnprotectedEmergency;
 }
diff --git a/radio/aidl/compat/libradiocompat/data/RadioData.cpp b/radio/aidl/compat/libradiocompat/data/RadioData.cpp
index 51f5543420..33e79fea0b 100644
--- a/radio/aidl/compat/libradiocompat/data/RadioData.cpp
+++ b/radio/aidl/compat/libradiocompat/data/RadioData.cpp
@@ -182,4 +182,24 @@ ScopedAStatus RadioData::stopKeepalive(int32_t serial, int32_t sessionHandle) {
     return ok();
 }
 
+ScopedAStatus RadioData::setUserDataEnabled(int32_t serial, bool enabled) {
+    LOG_CALL << serial << " " << enabled;
+    respond()->setUserDataEnabledResponse(notSupported(serial));
+    return ok();
+}
+
+ScopedAStatus RadioData::setUserDataRoamingEnabled(int32_t serial, bool enabled) {
+    LOG_CALL << serial << " " << enabled;
+    respond()->setUserDataRoamingEnabledResponse(notSupported(serial));
+    return ok();
+}
+
+ScopedAStatus RadioData::notifyImsDataNetwork(int32_t serial, aidlCommon::AccessNetwork,
+                                              aidl::DataNetworkState, aidl::TransportType,
+                                              int32_t /* physicalNetworkModemId */) {
+    LOG_CALL << serial;
+    respond()->notifyImsDataNetworkResponse(notSupported(serial));
+    return ok();
+}
+
 }  // namespace android::hardware::radio::compat
diff --git a/radio/aidl/compat/libradiocompat/ims/RadioIms.cpp b/radio/aidl/compat/libradiocompat/ims/RadioIms.cpp
index d2bdfff954..307815aa83 100644
--- a/radio/aidl/compat/libradiocompat/ims/RadioIms.cpp
+++ b/radio/aidl/compat/libradiocompat/ims/RadioIms.cpp
@@ -76,6 +76,12 @@ ScopedAStatus RadioIms::updateImsCallStatus(
     LOG(ERROR) << " updateImsCallStatus is unsupported by HIDL HALs";
     return ok();
 }
+ScopedAStatus RadioIms::updateAllowedServices(
+        int32_t serial, const std::vector<aidl::ImsService>& /*imsServices*/) {
+    LOG_CALL << serial;
+    LOG(ERROR) << " updateAllowedServices is unsupported by HIDL HALs";
+    return ok();
+}
 
 ScopedAStatus RadioIms::setResponseFunctions(
         const std::shared_ptr<aidl::IRadioImsResponse>& response,
diff --git a/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioData.h b/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioData.h
index da19811605..638555250d 100644
--- a/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioData.h
+++ b/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioData.h
@@ -62,6 +62,13 @@ class RadioData : public RadioCompatBase, public aidl::android::hardware::radio:
             int32_t serial,
             const ::aidl::android::hardware::radio::data::KeepaliveRequest& keepalive) override;
     ::ndk::ScopedAStatus stopKeepalive(int32_t serial, int32_t sessionHandle) override;
+    ::ndk::ScopedAStatus setUserDataEnabled(int32_t serial, bool enabled) override;
+    ::ndk::ScopedAStatus setUserDataRoamingEnabled(int32_t serial, bool enabled) override;
+    ::ndk::ScopedAStatus notifyImsDataNetwork(
+            int32_t serial, ::aidl::android::hardware::radio::AccessNetwork accessNetwork,
+            ::aidl::android::hardware::radio::data::DataNetworkState dataNetworkState,
+            ::aidl::android::hardware::radio::data::TransportType physicalTransportType,
+            int32_t physicalNetworkModemId) override;
 
   protected:
     std::shared_ptr<::aidl::android::hardware::radio::data::IRadioDataResponse> respond();
diff --git a/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioIms.h b/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioIms.h
index 0dbc565c0e..03c4f30a30 100644
--- a/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioIms.h
+++ b/radio/aidl/compat/libradiocompat/include/libradiocompat/RadioIms.h
@@ -45,6 +45,10 @@ class RadioIms : public RadioCompatBase, public aidl::android::hardware::radio::
     ::ndk::ScopedAStatus updateImsCallStatus(
             int32_t serial,
             const std::vector<::aidl::android::hardware::radio::ims::ImsCall>& imsCalls) override;
+    ::ndk::ScopedAStatus updateAllowedServices(
+            int32_t serial,
+            const std::vector<::aidl::android::hardware::radio::ims::ImsService>& imsServices)
+            override;
 
     ::ndk::ScopedAStatus setResponseFunctions(
             const std::shared_ptr<::aidl::android::hardware::radio::ims::IRadioImsResponse>&
diff --git a/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/Android.bp b/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/Android.bp
new file mode 100644
index 0000000000..4788f0c07c
--- /dev/null
+++ b/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/Android.bp
@@ -0,0 +1,26 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+runtime_resource_overlay {
+    name: "ConnectivityOverlayMinradio",
+    sdk_version: "current",
+    product_specific: true,
+}
+
+override_runtime_resource_overlay {
+    name: "ConnectivityOverlayMinradioGoogle",
+    base: "ConnectivityOverlayMinradio",
+    package_name: "com.google.android.connectivity.resources.minradio",
+    target_package_name: "com.google.android.connectivity.resources",
+}
diff --git a/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/AndroidManifest.xml b/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/AndroidManifest.xml
new file mode 100644
index 0000000000..8cfe703630
--- /dev/null
+++ b/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        package="com.google.android.connectivity.resources.minradio">
+    <application android:hasCode="false"/>
+    <overlay
+        android:targetPackage="com.android.connectivity.resources"
+        android:targetName="ServiceConnectivityResourcesConfig"
+        android:priority="0"
+        android:isStatic="true" />
+</manifest>
diff --git a/vr/1.0/default/service.cpp b/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/res/values/config.xml
similarity index 59%
rename from vr/1.0/default/service.cpp
rename to radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/res/values/config.xml
index 22fb7d10e7..be2d35abe5 100644
--- a/vr/1.0/default/service.cpp
+++ b/radio/aidl/minradio/libminradio/include/libminradio/overlays/ConnectivityOverlay/res/values/config.xml
@@ -1,5 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +15,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "android.hardware.vr@1.0-service"
-
-#include <android/hardware/vr/1.0/IVr.h>
-#include <hidl/LegacySupport.h>
-
-// Generated HIDL files
-using android::hardware::vr::V1_0::IVr;
-using android::hardware::defaultPassthroughServiceImplementation;
-
-int main() {
-    return defaultPassthroughServiceImplementation<IVr>();
-}
+-->
+<resources>
+    <!-- Do not support cellular keepalive, so only
+         specify the one required SocketKeepalive for Wi-Fi. -->
+    <string-array translatable="false" name="config_networkSupportedKeepaliveCount">
+        <item>1,3</item>
+    </string-array>
+</resources>
diff --git a/radio/aidl/minradio/libminradio/network/structs.cpp b/radio/aidl/minradio/libminradio/network/structs.cpp
index 2366c186fa..b6d17dc4b5 100644
--- a/radio/aidl/minradio/libminradio/network/structs.cpp
+++ b/radio/aidl/minradio/libminradio/network/structs.cpp
@@ -143,7 +143,7 @@ int32_t rssiToSignalStrength(int32_t rssi) {
 
 int32_t validateRsrp(int32_t rsrp) {
     // 3GPP TS 27.007 8.69
-    if (rsrp < -140 || rsrp > -44) return RadioConst::VALUE_UNAVAILABLE;
+    if (rsrp < -140 || rsrp > -44) return 140;  // CellInfoTest: RSRP Must be valid for LTE
     return -rsrp;
 }
 
diff --git a/radio/aidl/minradio/libminradio/sim/IccUtils.cpp b/radio/aidl/minradio/libminradio/sim/IccUtils.cpp
index 9458760d33..e5e2359b66 100644
--- a/radio/aidl/minradio/libminradio/sim/IccUtils.cpp
+++ b/radio/aidl/minradio/libminradio/sim/IccUtils.cpp
@@ -88,12 +88,19 @@ std::vector<uint8_t> hexStringToBytes(std::string_view str) {
 }
 
 // com.android.internal.telephony.uicc.IccUtils.bchToString (inversion)
+// com.android.internal.telephony.uicc.euicc.padTrailingFs
 // NOTE: BCH is a nibble-swizzled bytes reprezentation
 std::vector<uint8_t> hexStringToBch(std::string_view str) {
-    CHECK(str.size() % 2 == 0) << "Hex string length not even";
-    std::vector<uint8_t> bch(str.size() / 2);
+    std::vector<uint8_t> bch((str.size() + 1) / 2);
     for (size_t i = 0; i < bch.size(); i++) {
-        bch[i] = charToByte(str[i * 2]) | charToByte(str[i * 2 + 1]) << 4;
+        size_t inpos = i * 2;
+        uint8_t encoded = charToByte(str[inpos]);
+        if (inpos + 1 < str.size()) {
+            encoded |= charToByte(str[inpos + 1]) << 4;
+        } else {
+            encoded |= 0xF0;
+        }
+        bch[i] = encoded;
     }
     return bch;
 }
diff --git a/radio/aidl/minradio/minradio-example/Android.bp b/radio/aidl/minradio/minradio-example/Android.bp
index 70519724d5..31daed6bfe 100644
--- a/radio/aidl/minradio/minradio-example/Android.bp
+++ b/radio/aidl/minradio/minradio-example/Android.bp
@@ -68,6 +68,11 @@ apex {
         "minradio-example.rc",
     ],
     overrides: ["rild"],
+    // TODO(b/415983829): for some reason, neither of these gets loaded
+    //rros: [
+    //    "ConnectivityOverlayMinradio",
+    //    "ConnectivityOverlayMinradioGoogle",
+    //],
 }
 
 prebuilt_etc {
diff --git a/radio/aidl/minradio/minradio-example/impl/RadioConfig.cpp b/radio/aidl/minradio/minradio-example/impl/RadioConfig.cpp
index 12e8edeeae..cf78f5b5b0 100644
--- a/radio/aidl/minradio/minradio-example/impl/RadioConfig.cpp
+++ b/radio/aidl/minradio/minradio-example/impl/RadioConfig.cpp
@@ -37,7 +37,7 @@ ScopedAStatus RadioConfig::getSimSlotsStatus(int32_t serial) {
             .atr = "",
             .eid = "eUICC-simslot1",
             .portInfo = {{
-                    .iccId = "12345678901234567890",
+                    .iccId = "9868308146200231837",
                     .logicalSlotId = 0,
                     .portActive = true,
             }},
diff --git a/radio/aidl/minradio/minradio-example/impl/RadioSim.cpp b/radio/aidl/minradio/minradio-example/impl/RadioSim.cpp
index a5e11679ff..0b78c289aa 100644
--- a/radio/aidl/minradio/minradio-example/impl/RadioSim.cpp
+++ b/radio/aidl/minradio/minradio-example/impl/RadioSim.cpp
@@ -32,7 +32,7 @@ constexpr auto ok = &ScopedAStatus::ok;
 
 RadioSim::RadioSim(std::shared_ptr<minimal::SlotContext> context) : minimal::RadioSim(context) {
     addCtsCertificate();  // do NOT call on real device's production build
-    setIccid("98683081462002318379");
+    setIccid("9868308146200231837");
     mFilesystem->write(minimal::sim::paths::msisdn, minimal::sim::encodeMsisdn("+16500000000"));
 }
 
diff --git a/radio/aidl/vts/radio_data_response.cpp b/radio/aidl/vts/radio_data_response.cpp
index 8d51760295..f7b05dacfb 100644
--- a/radio/aidl/vts/radio_data_response.cpp
+++ b/radio/aidl/vts/radio_data_response.cpp
@@ -112,3 +112,21 @@ ndk::ScopedAStatus RadioDataResponse::stopKeepaliveResponse(const RadioResponseI
     parent_data.notify(info.serial);
     return ndk::ScopedAStatus::ok();
 }
+
+ndk::ScopedAStatus RadioDataResponse::setUserDataEnabledResponse(const RadioResponseInfo& info) {
+    rspInfo = info;
+    parent_data.notify(info.serial);
+    return ndk::ScopedAStatus::ok();
+}
+ndk::ScopedAStatus RadioDataResponse::setUserDataRoamingEnabledResponse(
+        const RadioResponseInfo& info) {
+    rspInfo = info;
+    parent_data.notify(info.serial);
+    return ndk::ScopedAStatus::ok();
+}
+
+ndk::ScopedAStatus RadioDataResponse::notifyImsDataNetworkResponse(const RadioResponseInfo& info) {
+    rspInfo = info;
+    parent_data.notify(info.serial);
+    return ndk::ScopedAStatus::ok();
+}
diff --git a/radio/aidl/vts/radio_data_test.cpp b/radio/aidl/vts/radio_data_test.cpp
index 7de0187fae..d91daefb4c 100644
--- a/radio/aidl/vts/radio_data_test.cpp
+++ b/radio/aidl/vts/radio_data_test.cpp
@@ -640,3 +640,242 @@ TEST_P(RadioDataTest, setDataAllowed) {
         EXPECT_EQ(RadioError::NONE, radioRsp_data->rspInfo.error);
     }
 }
+
+/*
+ * Test IRadioData.setUserDataEnabled() for the response returned.
+ */
+TEST_P(RadioDataTest, setUserDataEnabled) {
+    int32_t aidl_version;
+    ndk::ScopedAStatus aidl_status = radio_data->getInterfaceVersion(&aidl_version);
+    ASSERT_OK(aidl_status);
+    if (aidl_version < 5) {
+        ALOGI("Skipped the test since"
+              " setUserDataEnabled is not supported on version < 5");
+        GTEST_SKIP();
+    }
+    if (!deviceSupportsFeature(FEATURE_TELEPHONY_DATA)) {
+        GTEST_SKIP() << "Skipping setUserDataEnabled "
+                        "due to undefined FEATURE_TELEPHONY_DATA";
+    }
+
+    serial = GetRandomSerialNumber();
+    bool enabled = false;
+
+    radio_data->setUserDataEnabled(serial, enabled);
+
+    EXPECT_EQ(std::cv_status::no_timeout, wait());
+    EXPECT_EQ(RadioResponseType::SOLICITED, radioRsp_data->rspInfo.type);
+    EXPECT_EQ(serial, radioRsp_data->rspInfo.serial);
+
+    if (cardStatus.cardState == CardStatus::STATE_ABSENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(radioRsp_data->rspInfo.error,
+                                     {RadioError::SIM_ABSENT, RadioError::RADIO_NOT_AVAILABLE,
+                                      RadioError::REQUEST_NOT_SUPPORTED}));
+    } else if (cardStatus.cardState == CardStatus::STATE_PRESENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(radioRsp_data->rspInfo.error,
+                                     {RadioError::NONE, RadioError::RADIO_NOT_AVAILABLE,
+                                      RadioError::REQUEST_NOT_SUPPORTED}));
+    }
+
+    // Test setUserDataEnabled(false) should not block setupDataCall
+    serial = GetRandomSerialNumber();
+
+    AccessNetwork accessNetwork = AccessNetwork::EUTRAN;
+
+    DataProfileInfo dataProfileInfo;
+    memset(&dataProfileInfo, 0, sizeof(dataProfileInfo));
+    dataProfileInfo.profileId = DataProfileInfo::ID_DEFAULT;
+    dataProfileInfo.apn = std::string("internet");
+    dataProfileInfo.protocol = PdpProtocolType::IP;
+    dataProfileInfo.roamingProtocol = PdpProtocolType::IP;
+    dataProfileInfo.authType = ApnAuthType::NO_PAP_NO_CHAP;
+    dataProfileInfo.user = std::string("username");
+    dataProfileInfo.password = std::string("password");
+    dataProfileInfo.type = DataProfileInfo::TYPE_3GPP;
+    dataProfileInfo.maxConnsTime = 300;
+    dataProfileInfo.maxConns = 20;
+    dataProfileInfo.waitTime = 0;
+    dataProfileInfo.enabled = true;
+    dataProfileInfo.supportedApnTypesBitmap =
+            static_cast<int32_t>(ApnTypes::IMS) | static_cast<int32_t>(ApnTypes::IA);
+    dataProfileInfo.bearerBitmap = static_cast<int32_t>(RadioAccessFamily::GPRS) |
+                                   static_cast<int32_t>(RadioAccessFamily::EDGE) |
+                                   static_cast<int32_t>(RadioAccessFamily::UMTS) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSDPA) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSUPA) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSPA) |
+                                   static_cast<int32_t>(RadioAccessFamily::LTE) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSPAP) |
+                                   static_cast<int32_t>(RadioAccessFamily::IWLAN);
+    dataProfileInfo.mtuV4 = 0;
+    dataProfileInfo.mtuV6 = 0;
+    dataProfileInfo.preferred = true;
+    dataProfileInfo.persistent = false;
+
+    bool roamingAllowed = false;
+
+    std::vector<LinkAddress> addresses = {};
+    std::vector<std::string> dnses = {};
+
+    DataRequestReason reason = DataRequestReason::NORMAL;
+    SliceInfo sliceInfo;
+    bool matchAllRuleAllowed = true;
+
+    ndk::ScopedAStatus res =
+            radio_data->setupDataCall(serial, accessNetwork, dataProfileInfo, roamingAllowed,
+                                      reason, addresses, dnses, -1, sliceInfo, matchAllRuleAllowed);
+    ASSERT_OK(res);
+
+    EXPECT_EQ(std::cv_status::no_timeout, wait());
+    EXPECT_EQ(RadioResponseType::SOLICITED, radioRsp_data->rspInfo.type);
+    EXPECT_EQ(serial, radioRsp_data->rspInfo.serial);
+
+    if (cardStatus.cardState == CardStatus::STATE_ABSENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(
+                radioRsp_data->rspInfo.error,
+                {RadioError::SIM_ABSENT, RadioError::RADIO_NOT_AVAILABLE,
+                 RadioError::OP_NOT_ALLOWED_BEFORE_REG_TO_NW, RadioError::REQUEST_NOT_SUPPORTED}));
+    } else if (cardStatus.cardState == CardStatus::STATE_PRESENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(
+                radioRsp_data->rspInfo.error,
+                {RadioError::NONE, RadioError::RADIO_NOT_AVAILABLE,
+                 RadioError::OP_NOT_ALLOWED_BEFORE_REG_TO_NW, RadioError::REQUEST_NOT_SUPPORTED}));
+    }
+}
+
+/*
+ * Test IRadioData.setUserDataRoamingEnabled() for the response returned.
+ */
+TEST_P(RadioDataTest, setUserDataRoamingEnabled) {
+    int32_t aidl_version;
+    ndk::ScopedAStatus aidl_status = radio_data->getInterfaceVersion(&aidl_version);
+    ASSERT_OK(aidl_status);
+    if (aidl_version < 5) {
+        ALOGI("Skipped the test since"
+              " setUserDataRoamingEnabled is not supported on version < 5");
+        GTEST_SKIP();
+    }
+    if (!deviceSupportsFeature(FEATURE_TELEPHONY_DATA)) {
+        GTEST_SKIP() << "Skipping setUserDataRoamingEnabled "
+                        "due to undefined FEATURE_TELEPHONY_DATA";
+    }
+
+    serial = GetRandomSerialNumber();
+    bool enabled = false;
+
+    radio_data->setUserDataRoamingEnabled(serial, enabled);
+
+    EXPECT_EQ(std::cv_status::no_timeout, wait());
+    EXPECT_EQ(RadioResponseType::SOLICITED, radioRsp_data->rspInfo.type);
+    EXPECT_EQ(serial, radioRsp_data->rspInfo.serial);
+
+    if (cardStatus.cardState == CardStatus::STATE_ABSENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(radioRsp_data->rspInfo.error,
+                                     {RadioError::SIM_ABSENT, RadioError::RADIO_NOT_AVAILABLE,
+                                      RadioError::REQUEST_NOT_SUPPORTED}));
+    } else if (cardStatus.cardState == CardStatus::STATE_PRESENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(radioRsp_data->rspInfo.error,
+                                     {RadioError::NONE, RadioError::RADIO_NOT_AVAILABLE,
+                                      RadioError::REQUEST_NOT_SUPPORTED}));
+    }
+
+    // Test setUserDataRoamingEnabled(false) should not block setupDataCall
+    serial = GetRandomSerialNumber();
+
+    AccessNetwork accessNetwork = AccessNetwork::EUTRAN;
+
+    DataProfileInfo dataProfileInfo;
+    memset(&dataProfileInfo, 0, sizeof(dataProfileInfo));
+    dataProfileInfo.profileId = DataProfileInfo::ID_DEFAULT;
+    dataProfileInfo.apn = std::string("internet");
+    dataProfileInfo.protocol = PdpProtocolType::IP;
+    dataProfileInfo.roamingProtocol = PdpProtocolType::IP;
+    dataProfileInfo.authType = ApnAuthType::NO_PAP_NO_CHAP;
+    dataProfileInfo.user = std::string("username");
+    dataProfileInfo.password = std::string("password");
+    dataProfileInfo.type = DataProfileInfo::TYPE_3GPP;
+    dataProfileInfo.maxConnsTime = 300;
+    dataProfileInfo.maxConns = 20;
+    dataProfileInfo.waitTime = 0;
+    dataProfileInfo.enabled = true;
+    dataProfileInfo.supportedApnTypesBitmap =
+            static_cast<int32_t>(ApnTypes::IMS) | static_cast<int32_t>(ApnTypes::IA);
+    dataProfileInfo.bearerBitmap = static_cast<int32_t>(RadioAccessFamily::GPRS) |
+                                   static_cast<int32_t>(RadioAccessFamily::EDGE) |
+                                   static_cast<int32_t>(RadioAccessFamily::UMTS) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSDPA) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSUPA) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSPA) |
+                                   static_cast<int32_t>(RadioAccessFamily::LTE) |
+                                   static_cast<int32_t>(RadioAccessFamily::HSPAP) |
+                                   static_cast<int32_t>(RadioAccessFamily::IWLAN);
+    dataProfileInfo.mtuV4 = 0;
+    dataProfileInfo.mtuV6 = 0;
+    dataProfileInfo.preferred = true;
+    dataProfileInfo.persistent = false;
+
+    bool roamingAllowed = true;
+
+    std::vector<LinkAddress> addresses = {};
+    std::vector<std::string> dnses = {};
+
+    DataRequestReason reason = DataRequestReason::NORMAL;
+    SliceInfo sliceInfo;
+    bool matchAllRuleAllowed = true;
+
+    ndk::ScopedAStatus res =
+            radio_data->setupDataCall(serial, accessNetwork, dataProfileInfo, roamingAllowed,
+                                      reason, addresses, dnses, -1, sliceInfo, matchAllRuleAllowed);
+    ASSERT_OK(res);
+
+    EXPECT_EQ(std::cv_status::no_timeout, wait());
+    EXPECT_EQ(RadioResponseType::SOLICITED, radioRsp_data->rspInfo.type);
+    EXPECT_EQ(serial, radioRsp_data->rspInfo.serial);
+
+    if (cardStatus.cardState == CardStatus::STATE_ABSENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(
+                radioRsp_data->rspInfo.error,
+                {RadioError::SIM_ABSENT, RadioError::RADIO_NOT_AVAILABLE,
+                 RadioError::OP_NOT_ALLOWED_BEFORE_REG_TO_NW, RadioError::REQUEST_NOT_SUPPORTED}));
+    } else if (cardStatus.cardState == CardStatus::STATE_PRESENT) {
+        ASSERT_TRUE(CheckAnyOfErrors(
+                radioRsp_data->rspInfo.error,
+                {RadioError::NONE, RadioError::RADIO_NOT_AVAILABLE,
+                 RadioError::OP_NOT_ALLOWED_BEFORE_REG_TO_NW, RadioError::REQUEST_NOT_SUPPORTED}));
+    }
+}
+
+/*
+ * Test IRadioData.notifyImsDataNetwork() for the response returned.
+ */
+TEST_P(RadioDataTest, notifyImsDataNetwork) {
+    int32_t aidl_version;
+    ndk::ScopedAStatus aidl_status = radio_data->getInterfaceVersion(&aidl_version);
+    ASSERT_OK(aidl_status);
+    if (aidl_version < 5) {
+        ALOGI("Skipped the test since"
+              " notifyImsDataNetwork is not supported on version < 5");
+        GTEST_SKIP();
+    }
+    if (!deviceSupportsFeature(FEATURE_TELEPHONY_DATA)) {
+        GTEST_SKIP() << "Skipping notifyImsDataNetwork "
+                        "due to undefined FEATURE_TELEPHONY_DATA";
+    }
+
+    serial = GetRandomSerialNumber();
+    AccessNetwork accessNetwork = AccessNetwork::EUTRAN;
+    DataNetworkState dataNetworkState = DataNetworkState::CONNECTED;
+    TransportType physicalTransportType = TransportType::WWAN;
+    int physicalNetworkModemId = 0;
+
+    radio_data->notifyImsDataNetwork(serial, accessNetwork, dataNetworkState, physicalTransportType,
+                                     physicalNetworkModemId);
+
+    EXPECT_EQ(std::cv_status::no_timeout, wait());
+    EXPECT_EQ(RadioResponseType::SOLICITED, radioRsp_data->rspInfo.type);
+    EXPECT_EQ(serial, radioRsp_data->rspInfo.serial);
+
+    if (cardStatus.cardState == CardStatus::STATE_ABSENT) {
+        EXPECT_EQ(RadioError::NONE, radioRsp_data->rspInfo.error);
+    }
+}
diff --git a/radio/aidl/vts/radio_data_utils.h b/radio/aidl/vts/radio_data_utils.h
index 0959207cf6..4aae50c1d1 100644
--- a/radio/aidl/vts/radio_data_utils.h
+++ b/radio/aidl/vts/radio_data_utils.h
@@ -74,6 +74,13 @@ class RadioDataResponse : public BnRadioDataResponse {
                                                       const KeepaliveStatus& status) override;
 
     virtual ndk::ScopedAStatus stopKeepaliveResponse(const RadioResponseInfo& info) override;
+
+    virtual ndk::ScopedAStatus setUserDataEnabledResponse(const RadioResponseInfo& info) override;
+
+    virtual ndk::ScopedAStatus setUserDataRoamingEnabledResponse(
+            const RadioResponseInfo& info) override;
+
+    virtual ndk::ScopedAStatus notifyImsDataNetworkResponse(const RadioResponseInfo& info) override;
 };
 
 /* Callback class for radio data indication */
diff --git a/radio/aidl/vts/radio_ims_response.cpp b/radio/aidl/vts/radio_ims_response.cpp
index c6d62dce69..12bdb5e88d 100644
--- a/radio/aidl/vts/radio_ims_response.cpp
+++ b/radio/aidl/vts/radio_ims_response.cpp
@@ -62,3 +62,9 @@ ndk::ScopedAStatus RadioImsResponse::updateImsCallStatusResponse(const RadioResp
     parent_ims.notify(info.serial);
     return ndk::ScopedAStatus::ok();
 }
+
+ndk::ScopedAStatus RadioImsResponse::updateAllowedServicesResponse(const RadioResponseInfo& info) {
+    rspInfo = info;
+    parent_ims.notify(info.serial);
+    return ndk::ScopedAStatus::ok();
+}
diff --git a/radio/aidl/vts/radio_ims_test.cpp b/radio/aidl/vts/radio_ims_test.cpp
index 1938e0a8b6..9b56db8cd6 100644
--- a/radio/aidl/vts/radio_ims_test.cpp
+++ b/radio/aidl/vts/radio_ims_test.cpp
@@ -240,6 +240,33 @@ TEST_P(RadioImsTest, updateImsCallStatus) {
     verifyError(radioRsp_ims->rspInfo.error);
 }
 
+/*
+ * Test IRadioIms.updateAllowedServices() for the response returned.
+ */
+TEST_P(RadioImsTest, updateAllowedServices) {
+    if (!deviceSupportsFeature(FEATURE_TELEPHONY_IMS)) {
+        ALOGI("Skipping updateAllowedServices because ims is not supported in device");
+        return;
+    } else {
+        ALOGI("Running updateAllowedServices because ims is supported in device");
+    }
+
+    serial = GetRandomSerialNumber();
+
+    ImsService imsService;
+
+    ndk::ScopedAStatus res = radio_ims->updateAllowedServices(serial, {imsService});
+    ASSERT_OK(res);
+    EXPECT_EQ(std::cv_status::no_timeout, wait());
+    EXPECT_EQ(RadioResponseType::SOLICITED, radioRsp_ims->rspInfo.type);
+    EXPECT_EQ(serial, radioRsp_ims->rspInfo.serial);
+
+    ALOGI("updateAllowedServices, rspInfo.error = %s\n",
+          toString(radioRsp_ims->rspInfo.error).c_str());
+
+    verifyError(radioRsp_ims->rspInfo.error);
+}
+
 void RadioImsTest::verifyError(RadioError resp) {
     switch (resp) {
         case RadioError::NONE:
diff --git a/radio/aidl/vts/radio_ims_utils.h b/radio/aidl/vts/radio_ims_utils.h
index 208c94b05c..ae63b971fa 100644
--- a/radio/aidl/vts/radio_ims_utils.h
+++ b/radio/aidl/vts/radio_ims_utils.h
@@ -54,6 +54,9 @@ class RadioImsResponse : public BnRadioImsResponse {
     virtual ndk::ScopedAStatus sendAnbrQueryResponse(const RadioResponseInfo& info) override;
 
     virtual ndk::ScopedAStatus updateImsCallStatusResponse(const RadioResponseInfo& info) override;
+
+    virtual ndk::ScopedAStatus updateAllowedServicesResponse(
+            const RadioResponseInfo& info) override;
 };
 
 /* Callback class for radio ims indication */
diff --git a/radio/config/1.1/Android.bp b/radio/config/1.1/Android.bp
index 8aa8a4dcd4..59ab5b6387 100644
--- a/radio/config/1.1/Android.bp
+++ b/radio/config/1.1/Android.bp
@@ -25,5 +25,4 @@ hidl_interface {
         "android.hidl.base@1.0",
     ],
     gen_java: true,
-    system_ext_specific: true,
 }
diff --git a/radio/config/1.2/Android.bp b/radio/config/1.2/Android.bp
index e58ac0b746..915f7e1f1b 100644
--- a/radio/config/1.2/Android.bp
+++ b/radio/config/1.2/Android.bp
@@ -25,5 +25,4 @@ hidl_interface {
         "android.hidl.base@1.0",
     ],
     gen_java: true,
-    system_ext_specific: true,
 }
diff --git a/radio/config/1.3/Android.bp b/radio/config/1.3/Android.bp
index c39984c38f..fd28556b8b 100644
--- a/radio/config/1.3/Android.bp
+++ b/radio/config/1.3/Android.bp
@@ -26,5 +26,4 @@ hidl_interface {
         "android.hidl.base@1.0",
     ],
     gen_java: true,
-    system_ext_specific: true,
 }
diff --git a/secure_element/aidl/Android.bp b/secure_element/aidl/Android.bp
index 1145305364..34875f2cae 100644
--- a/secure_element/aidl/Android.bp
+++ b/secure_element/aidl/Android.bp
@@ -21,6 +21,13 @@ aidl_interface {
         java: {
             sdk_version: "system_current",
         },
+        rust: {
+            enabled: true,
+            gen_mockall: true,
+            additional_rustlibs: [
+                "libmockall",
+            ],
+        },
     },
     versions_with_info: [
         {
diff --git a/security/keymint/aidl/android/hardware/security/keymint/IKeyMintDevice.aidl b/security/keymint/aidl/android/hardware/security/keymint/IKeyMintDevice.aidl
index 0ae4b96fa1..ce78a7b804 100644
--- a/security/keymint/aidl/android/hardware/security/keymint/IKeyMintDevice.aidl
+++ b/security/keymint/aidl/android/hardware/security/keymint/IKeyMintDevice.aidl
@@ -977,7 +977,8 @@ interface IKeyMintDevice {
      *
      * @return error ErrorCode::MODULE_HASH_ALREADY_SET if this is not the first time
      *         setAdditionalAttestationInfo is called with Tag::MODULE_HASH, and the associated
-     *         KeyParamValue of the current call doesn't match the KeyParamValue of the first call.
+     *         KeyParameterValue of the current call doesn't match the KeyParameterValue of the
+     *         first call.
      */
     void setAdditionalAttestationInfo(in KeyParameter[] info);
 }
diff --git a/security/keymint/aidl/android/hardware/security/keymint/KeyCreationResult.aidl b/security/keymint/aidl/android/hardware/security/keymint/KeyCreationResult.aidl
index 2d2f307ec9..22fbd4f34f 100644
--- a/security/keymint/aidl/android/hardware/security/keymint/KeyCreationResult.aidl
+++ b/security/keymint/aidl/android/hardware/security/keymint/KeyCreationResult.aidl
@@ -110,13 +110,15 @@ parcelable KeyCreationResult {
      * o It must contain the notBefore and notAfter date-times specified in
      *   Tag::CERTIFICATE_NOT_BEFORE and Tag::CERTIFICATE_NOT_AFTER, respectively.
      *
-     * o It must contain a Key Usage extension with:
-     *
-     *    - the digitalSignature bit set iff the attested key has KeyPurpose::SIGN,
-     *    - the dataEncipherment bit set iff the attested key has KeyPurpose::DECRYPT,
-     *    - the keyEncipherment bit set iff the attested key has KeyPurpose::WRAP_KEY,
-     *    - the keyAgreement bit set iff the attested key has KeyPurpose::AGREE_KEY, and
-     *    - the keyCertSignBit set iff the attested key has KeyPurpose::ATTEST_KEY.
+     * o It must contain a Key Usage extension with the following bits set:
+     *
+     *    - digitalSignature: if the attested key has KeyPurpose::SIGN
+     *         - this bit may also be set for a key with KeyPurpose::VERIFY
+     *    - dataEncipherment: if the attested key has KeyPurpose::DECRYPT or KeyPurpose::ENCRYPT
+     *    - keyEncipherment: if the attested key has KeyPurpose::WRAP_KEY, KeyPurpose::DECRYPT,
+     *      or KeyPurpose::ENCRYPT
+     *    - keyAgreement: iff the attested key has KeyPurpose::AGREE_KEY
+     *    - keyCertSignBit: iff the attested key has KeyPurpose::ATTEST_KEY
      *
      * In the attestation cases (1 and 2 above), the first certificate must contain a
      * KeyDescription attestation extension with OID 1.3.6.1.4.1.11129.2.1.17.
diff --git a/security/keymint/aidl/android/hardware/security/keymint/KeyMintHardwareInfo.aidl b/security/keymint/aidl/android/hardware/security/keymint/KeyMintHardwareInfo.aidl
index b82dee626b..3efa337a85 100644
--- a/security/keymint/aidl/android/hardware/security/keymint/KeyMintHardwareInfo.aidl
+++ b/security/keymint/aidl/android/hardware/security/keymint/KeyMintHardwareInfo.aidl
@@ -32,21 +32,27 @@ parcelable KeyMintHardwareInfo {
      */
     int versionNumber;
 
-    /* securityLevel is the security level of the IKeyMintDevice implementation accessed
-     * through this aidl package.  */
+    /**
+     * securityLevel is the security level of the IKeyMintDevice implementation accessed
+     * through this aidl package.
+     */
     SecurityLevel securityLevel = SecurityLevel.SOFTWARE;
 
-    /* keyMintName is the name of the IKeyMintDevice implementation.  */
+    /**
+     * keyMintName is the name of the IKeyMintDevice implementation. The name must not be empty.
+     */
     @utf8InCpp String keyMintName;
 
-    /* keyMintAuthorName is the name of the author of the IKeyMintDevice implementation
-     *         (organization name, not individual). This name is implementation defined,
-     *         so it can be used to distinguish between different implementations from the
-     *         same author.
+    /**
+     * keyMintAuthorName is the name of the author of the IKeyMintDevice implementation
+     * (organization name, not individual). This name is implementation defined, so it can be used
+     * to distinguish between different implementations from the same author. The name must not be
+     * empty.
      */
     @utf8InCpp String keyMintAuthorName;
 
-    /* The timestampTokenRequired is a boolean flag, which when true reflects that IKeyMintDevice
+    /**
+     * The timestampTokenRequired is a boolean flag, which when true reflects that IKeyMintDevice
      * instance will expect a valid TimeStampToken with various operations. This will typically
      * required by the StrongBox implementations that generally don't have secure clock hardware to
      * generate timestamp tokens.
diff --git a/security/keymint/aidl/vts/functional/Android.bp b/security/keymint/aidl/vts/functional/Android.bp
index a8ccabfc70..e32be97894 100644
--- a/security/keymint/aidl/vts/functional/Android.bp
+++ b/security/keymint/aidl/vts/functional/Android.bp
@@ -51,7 +51,6 @@ cc_defaults {
         "libcppcose_rkp",
         "libfs_mgr",
         "libjsoncpp",
-        "libkeymint",
         "libkeymint_remote_prov_support",
         "libkeymint_support",
     ],
diff --git a/security/keymint/aidl/vts/functional/AuthTest.cpp b/security/keymint/aidl/vts/functional/AuthTest.cpp
index f435513221..b3bf4d3104 100644
--- a/security/keymint/aidl/vts/functional/AuthTest.cpp
+++ b/security/keymint/aidl/vts/functional/AuthTest.cpp
@@ -28,6 +28,7 @@
 #include <aidl/android/hardware/security/secureclock/ISecureClock.h>
 #include <android-base/logging.h>
 #include <android/binder_manager.h>
+#include <vendorsupport/api_level.h>
 
 using aidl::android::hardware::gatekeeper::GatekeeperEnrollResponse;
 using aidl::android::hardware::gatekeeper::GatekeeperVerifyResponse;
@@ -540,6 +541,92 @@ TEST_P(AuthTest, AuthPerOperation) {
               Finish(message, {} /* signature */, &ciphertext, dodgy_hat.value()));
 }
 
+// Test use of a key with large message that requires an auth token for each action on the
+// operation, with a per-operation challenge value included.
+TEST_P(AuthTest, AuthPerOperationLargeMessage) {
+    if (!GatekeeperAvailable()) {
+        GTEST_SKIP() << "No Gatekeeper available";
+    }
+    if (SecLevel() == SecurityLevel::STRONGBOX &&
+        get_vendor_api_level() <= AVendorSupport_getVendorApiLevelOf(__ANDROID_API_V__)) {
+        // Certain Strongbox implementations incorrectly handle Auth-bound key
+        // operations with large input messages, leading to VERIFICATION_FAILED
+        // error. This test is skipped for these older implementations.
+        GTEST_SKIP() << "Skip test on StrongBox device with vendor-api-level <= __ANDROID_API_V__";
+    }
+
+    // Create an AES key that requires authentication per-action.
+    auto builder = AuthorizationSetBuilder()
+                           .AesEncryptionKey(256)
+                           .BlockMode(BlockMode::CBC)
+                           .Padding(PaddingMode::PKCS7)
+                           .Authorization(TAG_USER_SECURE_ID, sid_)
+                           .Authorization(TAG_USER_AUTH_TYPE, HardwareAuthenticatorType::PASSWORD);
+    vector<uint8_t> keyblob;
+    vector<KeyCharacteristics> key_characteristics;
+    vector<Certificate> cert_chain;
+    ASSERT_EQ(ErrorCode::OK,
+              GenerateKey(builder, std::nullopt, &keyblob, &key_characteristics, &cert_chain));
+
+    vector<vector<size_t>> chunk_sizes = {
+            {2048},
+            {2048, 0},
+            {1024, 1024},
+            {1024, 1024, 0},
+            {512, 512, 512, 512},
+            {512, 512, 512, 512, 0},
+    };
+    auto params = AuthorizationSetBuilder().BlockMode(BlockMode::CBC).Padding(PaddingMode::PKCS7);
+
+    for (const auto& chunks : chunk_sizes) {
+        AuthorizationSet out_params;
+        ASSERT_EQ(ErrorCode::OK, Begin(KeyPurpose::ENCRYPT, keyblob, params, &out_params));
+        auto iv = out_params.GetTagValue(TAG_NONCE);
+        EXPECT_TRUE(iv);
+
+        // Get a HAT with the challenge from an in-progress operation.
+        auto hat = doVerify(challenge_, handle_, password_);
+        ASSERT_TRUE(hat.has_value());
+        ASSERT_EQ(hat->userId, sid_);
+
+        // Encrypt in the given chunk sizes.
+        string message;
+        string ciphertext;
+        for (int i = 0; i < chunks.size(); i++) {
+            SCOPED_TRACE(testing::Message()
+                         << "chunk[" << i << "] of " << chunks.size() << ", size " << chunks[i]);
+            string msg_chunk = string(chunks[i], 'A');
+            string ct_chunk;
+            if (i < chunks.size() - 1) {
+                // Pass in n-1 chunks to `update()`
+                std::cerr << "Update(size=" << chunks[i] << ")\n";
+                ASSERT_EQ(ErrorCode::OK, Update(msg_chunk, &ct_chunk, hat.value(), {}));
+            } else {
+                // Pass the final chunk to `finish()`
+                std::cerr << "Finish(size=" << chunks[i] << ")\n";
+                ASSERT_EQ(ErrorCode::OK,
+                          Finish(msg_chunk, {} /* signature */, &ct_chunk, hat.value()));
+            }
+            message += msg_chunk;
+            ciphertext += ct_chunk;
+        }
+
+        auto params_iv = AuthorizationSetBuilder().Authorizations(params).Authorization(TAG_NONCE,
+                                                                                        iv->get());
+        out_params.Clear();
+        // Decrypt in one go
+        ASSERT_EQ(ErrorCode::OK, Begin(KeyPurpose::DECRYPT, keyblob, params_iv, &out_params));
+        hat = doVerify(challenge_, handle_, password_);
+        ASSERT_TRUE(hat.has_value());
+        ASSERT_EQ(hat->userId, sid_);
+
+        string plaintext;
+        ASSERT_EQ(ErrorCode::OK, Finish(ciphertext, {} /* signature */, &plaintext, hat.value()));
+
+        EXPECT_EQ(message, plaintext);
+    }
+}
+
 // Test use of a key that requires an auth token for each action on the operation, with
 // a per-operation challenge value included, with multiple secure IDs allowed.
 TEST_P(AuthTest, AuthPerOperationMultiSid) {
diff --git a/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.cpp b/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.cpp
index 0ec76a51df..6ad23b4bac 100644
--- a/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.cpp
+++ b/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.cpp
@@ -155,6 +155,11 @@ void check_crl_distribution_points_extension_not_present(X509* certificate) {
 }
 
 void check_attestation_version(uint32_t attestation_version, int32_t aidl_version) {
+    if (get_vendor_api_level() > AVendorSupport_getVendorApiLevelOf(36)) {
+        EXPECT_EQ(attestation_version, (aidl_version * 100));
+        return;
+    }
+
     // Version numbers in attestation extensions should be a multiple of 100.
     EXPECT_EQ(attestation_version % 100, 0);
 
@@ -730,7 +735,9 @@ ErrorCode KeyMintAidlTestBase::UpdateAad(const string& input) {
                                              {} /* verificationToken */));
 }
 
-ErrorCode KeyMintAidlTestBase::Update(const string& input, string* output) {
+ErrorCode KeyMintAidlTestBase::Update(const string& input, string* output,
+                                      std::optional<HardwareAuthToken> hat,
+                                      std::optional<secureclock::TimeStampToken> time_token) {
     SCOPED_TRACE("Update");
 
     Status result;
@@ -740,7 +747,7 @@ ErrorCode KeyMintAidlTestBase::Update(const string& input, string* output) {
     if (!op_) return ErrorCode::UNEXPECTED_NULL_POINTER;
 
     std::vector<uint8_t> o_put;
-    result = op_->update(vector<uint8_t>(input.begin(), input.end()), {}, {}, &o_put);
+    result = op_->update(vector<uint8_t>(input.begin(), input.end()), hat, time_token, &o_put);
 
     if (result.isOk()) {
         output->append(o_put.begin(), o_put.end());
@@ -1861,6 +1868,19 @@ int get_vendor_api_level() {
     return std::min(product_api_level, vendor_api_level);
 }
 
+int get_first_vendor_api_level() {
+    // `ro.board.first_api_level` is only populated for GRF chipsets.
+    int first_vendor_api_level = ::android::base::GetIntProperty("ro.board.first_api_level", -1);
+    if (first_vendor_api_level != -1) {
+        return first_vendor_api_level;
+    }
+
+    // `ro.product.first_api_level` is always populated.
+    first_vendor_api_level = ::android::base::GetIntProperty("ro.product.first_api_level", -1);
+    EXPECT_NE(first_vendor_api_level, -1) << "Could not find ro.product.first_api_level";
+    return AVendorSupport_getVendorApiLevelOf(first_vendor_api_level);
+}
+
 bool is_gsi_image() {
     std::ifstream ifs("/system/system_ext/etc/init/init.gsi.rc");
     return ifs.good();
diff --git a/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.h b/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.h
index 6c327bbca5..86e7ba59b2 100644
--- a/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.h
+++ b/security/keymint/aidl/vts/functional/KeyMintAidlTestBase.h
@@ -173,7 +173,9 @@ class KeyMintAidlTestBase : public ::testing::TestWithParam<string> {
     ErrorCode Begin(KeyPurpose purpose, const AuthorizationSet& in_params);
 
     ErrorCode UpdateAad(const string& input);
-    ErrorCode Update(const string& input, string* output);
+    ErrorCode Update(const string& input, string* output) { return Update(input, output, {}, {}); }
+    ErrorCode Update(const string& input, string* output, std::optional<HardwareAuthToken> hat,
+                     std::optional<secureclock::TimeStampToken> time_token);
 
     ErrorCode Finish(const string& message, const string& signature, string* output,
                      std::optional<HardwareAuthToken> hat = std::nullopt,
@@ -409,6 +411,9 @@ void add_tag_from_prop(AuthorizationSetBuilder* tags, TypedTag<TagType::BYTES, t
 // Return the vendor API level for this device.
 int get_vendor_api_level();
 
+// Return the vendor API level when the device shipped.
+int get_first_vendor_api_level();
+
 // Indicate whether the test is running on a GSI image.
 bool is_gsi_image();
 
diff --git a/security/keymint/aidl/vts/functional/KeyMintTest.cpp b/security/keymint/aidl/vts/functional/KeyMintTest.cpp
index 5a6eea1209..a3cf2aa7df 100644
--- a/security/keymint/aidl/vts/functional/KeyMintTest.cpp
+++ b/security/keymint/aidl/vts/functional/KeyMintTest.cpp
@@ -4600,6 +4600,34 @@ TEST_P(ImportKeyTest, AesSuccess) {
     EXPECT_EQ(message, plaintext);
 }
 
+/*
+ * ImportKeyTest.AesKeyMaterialEncrypted
+ *
+ * Verifies that the keyblob for an imported AES key does not have visible plaintext key material.
+ */
+TEST_P(ImportKeyTest, AesKeyMaterialEncrypted) {
+    string key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    for (int i = 0; i < 32; i++) {
+        key[i] = static_cast<char>(random() % 256);
+    }
+    ASSERT_EQ(ErrorCode::OK, ImportKey(AuthorizationSetBuilder()
+                                               .Authorization(TAG_NO_AUTH_REQUIRED)
+                                               .AesEncryptionKey(key.size() * 8)
+                                               .EcbMode()
+                                               .Padding(PaddingMode::PKCS7),
+                                       KeyFormat::RAW, key));
+    CheckCryptoParam(TAG_ALGORITHM, Algorithm::AES);
+    CheckCryptoParam(TAG_KEY_SIZE, 256U);
+    CheckOrigin();
+
+    // The keyblob should not contain the plaintext key material.
+    string keyblob(key_blob_.begin(), key_blob_.end());
+    ASSERT_EQ(keyblob.find(key), string::npos)
+            << "keyblob data " << bin2hex(key_blob_) << " contains the raw key material "
+            << bin2hex(std::vector<uint8_t>(key.begin(), key.end()));
+}
+
 /*
  * ImportKeyTest.AesFailure
  *
@@ -8198,6 +8226,18 @@ TEST_P(GetHardwareInfoTest, GetHardwareInfo) {
     EXPECT_EQ(info, info2);
 }
 
+TEST_P(GetHardwareInfoTest, GetHardwareInfoNonEmptyNames) {
+    KeyMintHardwareInfo info;
+    ASSERT_TRUE(keyMint().getHardwareInfo(&info).isOk());
+    int vendor_api_level = get_vendor_api_level();
+    if (vendor_api_level <= 202504) {
+        GTEST_SKIP() << "Applies only to vendor API level > 202504, but this device is: "
+                     << vendor_api_level;
+    }
+    EXPECT_NE(info.keyMintName, "");
+    EXPECT_NE(info.keyMintAuthorName, "");
+}
+
 INSTANTIATE_KEYMINT_AIDL_TEST(GetHardwareInfoTest);
 
 typedef KeyMintAidlTestBase AddEntropyTest;
diff --git a/security/keymint/aidl/vts/performance/Android.bp b/security/keymint/aidl/vts/performance/Android.bp
index 6179c99bc0..7297d61304 100644
--- a/security/keymint/aidl/vts/performance/Android.bp
+++ b/security/keymint/aidl/vts/performance/Android.bp
@@ -36,7 +36,6 @@ cc_benchmark {
     shared_libs: [
         "libbinder_ndk",
         "libcrypto",
-        "libkeymint",
         "libkeymint_support",
     ],
     static_libs: [
diff --git a/security/rkp/aidl/android/hardware/security/keymint/generateCertificateRequestV2.cddl b/security/rkp/aidl/android/hardware/security/keymint/generateCertificateRequestV2.cddl
index c519086555..8da31cbace 100644
--- a/security/rkp/aidl/android/hardware/security/keymint/generateCertificateRequestV2.cddl
+++ b/security/rkp/aidl/android/hardware/security/keymint/generateCertificateRequestV2.cddl
@@ -114,6 +114,7 @@ DiceChainEntryPayload = {                    ; CWT [RFC8392]
 }
 
 ConfigurationDescriptor = {                  ; Configuration Descriptor
+    ; NOTE: Component name is required as of Vendor Software Requirements 202504
     ? -70002 : tstr,                         ; Component name
     ? -70003 : int / tstr,                   ; Component version
     ? -70004 : null,                         ; Resettable
diff --git a/security/rkp/aidl/vts/functional/VtsRemotelyProvisionedComponentTests.cpp b/security/rkp/aidl/vts/functional/VtsRemotelyProvisionedComponentTests.cpp
index ccc9f7c1f3..7af55f0e54 100644
--- a/security/rkp/aidl/vts/functional/VtsRemotelyProvisionedComponentTests.cpp
+++ b/security/rkp/aidl/vts/functional/VtsRemotelyProvisionedComponentTests.cpp
@@ -60,6 +60,8 @@ constexpr uint8_t MAX_CHALLENGE_SIZE = 64;
 const string KEYMINT_STRONGBOX_INSTANCE_NAME =
         "android.hardware.security.keymint.IKeyMintDevice/strongbox";
 
+const string FEATURE_AUTOMOTIVE = "android.hardware.type.automotive";
+
 constexpr std::string_view kVerifiedBootState = "ro.boot.verifiedbootstate";
 constexpr std::string_view kDeviceState = "ro.boot.vbmeta.device_state";
 constexpr std::string_view kDefaultValue = "";
@@ -269,22 +271,26 @@ TEST(NonParameterizedTests, eachRpcHasAUniqueId) {
 }
 
 /**
- * Verify that the default implementation supports DICE if there is a StrongBox KeyMint instance
- * on the device.
+ * Verify that the default implementation supports DICE if the device supports protected VMs.
  */
 // @VsrTest = 3.10-015
 // @VsrTest = 3.10-018.001
 TEST(NonParameterizedTests, requireDiceOnDefaultInstanceIfProtectedVmSupported) {
-    int vendor_api_level = get_vendor_api_level();
-    if (vendor_api_level < __ANDROID_API_V__) {
-        GTEST_SKIP() << "Applies only to vendor API level >= 202404, but this device is: "
-                     << vendor_api_level;
+    int first_vendor_api_level = get_first_vendor_api_level();
+    if (first_vendor_api_level < 202504) {
+        GTEST_SKIP() << "Applies only to devices that shipped with vendor API level >= 202504, but "
+                     << "this device shipped with: " << first_vendor_api_level;
     }
 
     if (!::android::base::GetBoolProperty("ro.boot.hypervisor.protected_vm.supported", false)) {
         GTEST_SKIP() << "DICE is only required when protected VMs are supported";
     }
 
+    // Skip on auto due to GAS requirement G-SH-917.
+    if (check_feature(FEATURE_AUTOMOTIVE)) {
+        GTEST_SKIP() << "This is an automotive device.";
+    }
+
     auto rpc = getHandle<IRemotelyProvisionedComponent>(DEFAULT_INSTANCE_NAME);
     ASSERT_NE(rpc, nullptr);
 
diff --git a/security/secretkeeper/aidl/vts/Android.bp b/security/secretkeeper/aidl/vts/Android.bp
index 4353ca5029..8c7f624da3 100644
--- a/security/secretkeeper/aidl/vts/Android.bp
+++ b/security/secretkeeper/aidl/vts/Android.bp
@@ -58,8 +58,8 @@ rust_test {
         "libexplicitkeydice",
         "liblog_rust",
         "libsecretkeeper_client",
-        "libsecretkeeper_comm_nostd",
-        "libsecretkeeper_core_nostd",
+        "libsecretkeeper_comm",
+        "libsecretkeeper_core",
         "libsecretkeeper_test",
     ],
     require_root: true,
@@ -83,7 +83,7 @@ rust_binary {
         "libhex",
         "liblog_rust",
         "libsecretkeeper_client",
-        "libsecretkeeper_comm_nostd",
+        "libsecretkeeper_comm",
         "libsecretkeeper_test",
     ],
 }
diff --git a/security/secretkeeper/default/Android.bp b/security/secretkeeper/default/Android.bp
index 134afc9cce..a88c90c608 100644
--- a/security/secretkeeper/default/Android.bp
+++ b/security/secretkeeper/default/Android.bp
@@ -37,8 +37,8 @@ rust_library {
         "libbinder_rs",
         "libcoset",
         "liblog_rust",
-        "libsecretkeeper_core_nostd",
-        "libsecretkeeper_comm_nostd",
+        "libsecretkeeper_core",
+        "libsecretkeeper_comm",
     ],
 }
 
diff --git a/security/secureclock/aidl/vts/functional/Android.bp b/security/secureclock/aidl/vts/functional/Android.bp
index 4e54561923..7017249de2 100644
--- a/security/secureclock/aidl/vts/functional/Android.bp
+++ b/security/secureclock/aidl/vts/functional/Android.bp
@@ -44,7 +44,6 @@ cc_test {
     ],
     static_libs: [
         "android.hardware.security.secureclock-V1-ndk",
-        "libkeymint",
     ],
     test_suites: [
         "general-tests",
diff --git a/security/see/OWNERS b/security/see/OWNERS
index d1a606f9f8..377412a9ba 100644
--- a/security/see/OWNERS
+++ b/security/see/OWNERS
@@ -1,5 +1,4 @@
 # include OWNERS from the top level trusty repo
 include trusty:main:/OWNERS
 
-paulcrowley@google.com
 swillden@google.com
diff --git a/security/see/hwcrypto/aidl/vts/functional/hwcryptokey_tests.rs b/security/see/hwcrypto/aidl/vts/functional/hwcryptokey_tests.rs
index 8b4d924dd3..3ada2b9eeb 100644
--- a/security/see/hwcrypto/aidl/vts/functional/hwcryptokey_tests.rs
+++ b/security/see/hwcrypto/aidl/vts/functional/hwcryptokey_tests.rs
@@ -22,9 +22,13 @@ use android_hardware_security_see_hwcrypto::aidl::android::hardware::security::s
 };
 use android_hardware_security_see_hwcrypto::aidl::android::hardware::security::see::hwcrypto::types::{
     HalErrorCode, AesKey::AesKey, ExplicitKeyMaterial::ExplicitKeyMaterial, KeyType::KeyType, KeyLifetime::KeyLifetime, KeyUse::KeyUse,
-    HmacKey::HmacKey, ProtectionId::ProtectionId,
+    HmacOperationParameters::HmacOperationParameters,
+    HmacKey::HmacKey, OperationData::OperationData, ProtectionId::ProtectionId,
+};
+use android_hardware_security_see_hwcrypto::aidl::android::hardware::security::see::hwcrypto::{
+    CryptoOperation::CryptoOperation, CryptoOperationSet::CryptoOperationSet, KeyPolicy::KeyPolicy,
+    OperationParameters::OperationParameters,
 };
-use android_hardware_security_see_hwcrypto::aidl::android::hardware::security::see::hwcrypto::KeyPolicy::KeyPolicy;
 use hwcryptohal_common;
 use rdroidtest::{ignore_if, rdroidtest};
 
@@ -97,7 +101,7 @@ fn test_hwcrypto_token_export_import() {
         .expect("Couldn't get back a hwcryptokey binder object");
     let clear_key = ExplicitKeyMaterial::Hmac(HmacKey::Sha256([0; 32]));
     let policy = KeyPolicy {
-        usage: KeyUse::DERIVE,
+        usage: KeyUse::SIGN,
         keyLifetime: KeyLifetime::PORTABLE,
         keyPermissions: Vec::new(),
         keyManagementKey: false,
@@ -108,9 +112,58 @@ fn test_hwcrypto_token_export_import() {
     let token =
         key.getShareableToken(dice_policy.as_slice()).expect("Couldn't get shareable token");
     let imported_key = hw_crypto_key
-        .keyTokenImport(&token, dice_policy.as_slice());
-    assert!(imported_key.is_ok(), "Couldn't import shareable token");
-    // TODO: Use operations to verify that the keys match
+        .keyTokenImport(&token, dice_policy.as_slice())
+        .expect("Couldn't import shareable token");
+
+    let policy = imported_key.getKeyPolicy();
+    assert!(policy.is_ok(), "Couldn't get token key policy");
+
+    let hw_crypto_operations = hw_crypto_key
+        .getHwCryptoOperations()
+        .expect("Couldn't get back a hwcryptokey operations binder object");
+
+    // Using operations to verify that the keys match
+    let hmac_parameters = HmacOperationParameters { key: Some(key) };
+    let op_parameters = OperationParameters::Hmac(hmac_parameters);
+    let mut cmd_list = Vec::<CryptoOperation>::new();
+    let data_output = OperationData::DataBuffer(Vec::new());
+    cmd_list.push(CryptoOperation::DataOutput(data_output));
+    cmd_list.push(CryptoOperation::SetOperationParameters(op_parameters));
+    let input_data = OperationData::DataBuffer("text to be mac'ed".as_bytes().to_vec());
+    cmd_list.push(CryptoOperation::DataInput(input_data));
+    cmd_list.push(CryptoOperation::Finish(None));
+    let crypto_op_set = CryptoOperationSet { context: None, operations: cmd_list };
+    let mut crypto_sets = Vec::new();
+    crypto_sets.push(crypto_op_set);
+    hw_crypto_operations.processCommandList(&mut crypto_sets).expect("couldn't process commands");
+    // Extracting the vector from the command list because of ownership
+    let CryptoOperation::DataOutput(OperationData::DataBuffer(mac)) =
+        crypto_sets.remove(0).operations.remove(0)
+    else {
+        panic!("not reachable, we created this object above on the test");
+    };
+
+    // creating a key with the imported key to compare
+    let hmac_parameters = HmacOperationParameters { key: Some(imported_key) };
+    let op_parameters = OperationParameters::Hmac(hmac_parameters);
+    let mut cmd_list = Vec::<CryptoOperation>::new();
+    let data_output = OperationData::DataBuffer(Vec::new());
+    cmd_list.push(CryptoOperation::DataOutput(data_output));
+    cmd_list.push(CryptoOperation::SetOperationParameters(op_parameters));
+    let input_data = OperationData::DataBuffer("text to be mac'ed".as_bytes().to_vec());
+    cmd_list.push(CryptoOperation::DataInput(input_data));
+    cmd_list.push(CryptoOperation::Finish(None));
+    let crypto_op_set = CryptoOperationSet { context: None, operations: cmd_list };
+    let mut crypto_sets = Vec::new();
+    crypto_sets.push(crypto_op_set);
+    hw_crypto_operations.processCommandList(&mut crypto_sets).expect("couldn't process commands");
+    // Extracting the vector from the command list because of ownership
+    let CryptoOperation::DataOutput(OperationData::DataBuffer(mac2)) =
+        crypto_sets.remove(0).operations.remove(0)
+    else {
+        panic!("not reachable, we created this object above on the test");
+    };
+    assert_eq!(mac, mac2, "got a different mac");
 }
 
 #[rdroidtest]
@@ -130,27 +183,21 @@ fn test_hwcrypto_android_invalid_calls() {
     let protections = Vec::new();
     let res = key.setProtectionId(ProtectionId::WIDEVINE_OUTPUT_BUFFER, &protections);
     assert_eq!(
-        res.err()
-            .expect("should not be call this function from the host")
-            .service_specific_error(),
+        res.err().expect("should not be able to call this function from the host").service_specific_error(),
         HalErrorCode::UNAUTHORIZED,
         "wrong error type received"
     );
     let derivation_key = DiceBoundDerivationKey::OpaqueKey(Some(key));
     let res = hw_crypto_key.deriveCurrentDicePolicyBoundKey(&derivation_key);
     assert_eq!(
-        res.err()
-            .expect("should not be call this function from the host")
-            .service_specific_error(),
+        res.err().expect("should not be able to call this function from the host").service_specific_error(),
         HalErrorCode::UNAUTHORIZED,
         "wrong error type received"
     );
     let fake_policy = Vec::new();
     let res = hw_crypto_key.deriveDicePolicyBoundKey(&derivation_key, &fake_policy);
     assert_eq!(
-        res.err()
-            .expect("should not be call this function from the host")
-            .service_specific_error(),
+        res.err().expect("should not be able to call this function from the host").service_specific_error(),
         HalErrorCode::UNAUTHORIZED,
         "wrong error type received"
     );
@@ -163,9 +210,7 @@ fn test_hwcrypto_android_invalid_calls() {
     };
     let res = hw_crypto_key.deriveKey(&derived_parameters);
     assert_eq!(
-        res.err()
-            .expect("should not be call this function from the host")
-            .service_specific_error(),
+        res.err().expect("should not be able to call this function from the host").service_specific_error(),
         HalErrorCode::UNAUTHORIZED,
         "wrong error type received"
     );
diff --git a/security/see/hwcrypto/default/hwcryptolib.cpp b/security/see/hwcrypto/default/hwcryptolib.cpp
index a7ecca122a..00c05e26d0 100644
--- a/security/see/hwcrypto/default/hwcryptolib.cpp
+++ b/security/see/hwcrypto/default/hwcryptolib.cpp
@@ -579,51 +579,33 @@ class HwCryptoOperationsNdk : public ndk_hwcrypto::BnHwCryptoOperations {
             return convertStatus(Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT));
         }
         for (unsigned setIdx = 0; setIdx < cppOperationSets.size(); ++setIdx) {
-            if (cppOperationSets[setIdx].operations.size() !=
-                (*operationSets)[setIdx].operations.size()) {
-                LOG(ERROR) << "ndk and cpp operations on set " << setIdx
-                           << " had a different number of elements";
-                return convertStatus(Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT));
-            }
-            for (unsigned operationIdx = 0;
-                 operationIdx < cppOperationSets[setIdx].operations.size(); ++operationIdx) {
-                if (cppOperationSets[setIdx].operations[operationIdx].getTag() ==
-                    cpp_hwcrypto::CryptoOperation::dataOutput) {
-                    if ((*operationSets)[setIdx].operations[operationIdx].getTag() !=
-                        ndk_hwcrypto::CryptoOperation::dataOutput) {
-                        LOG(ERROR)
-                                << "ndk and cpp operations on set " << setIdx << " and operation "
-                                << operationIdx << " had a different operation type";
-                        return convertStatus(
-                                Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT));
-                    }
-                    if (cppOperationSets[setIdx]
-                                .operations[operationIdx]
-                                .get<cpp_hwcrypto::CryptoOperation::dataOutput>()
-                                .getTag() == cpp_hwcrypto::types::OperationData::dataBuffer) {
-                        // This is the only case on which we need to move the data backto the
-                        // original array
-                        if ((*operationSets)[setIdx]
-                                    .operations[operationIdx]
-                                    .get<ndk_hwcrypto::CryptoOperation::dataOutput>()
-                                    .getTag() != ndk_hwcrypto::types::OperationData::dataBuffer) {
-                            LOG(ERROR) << "ndk and cpp operations on set " << setIdx
-                                       << " and operation " << operationIdx
-                                       << " had a different operation data output type";
-                            return convertStatus(
-                                    Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT));
-                        }
-                        (*operationSets)[setIdx]
-                                .operations[operationIdx]
-                                .get<ndk_hwcrypto::CryptoOperation::dataOutput>()
-                                .set<ndk_hwcrypto::types::OperationData::dataBuffer>(
-                                        cppOperationSets[setIdx]
-                                                .operations[operationIdx]
-                                                .get<cpp_hwcrypto::CryptoOperation::dataOutput>()
-                                                .get<cpp_hwcrypto::types::OperationData::
-                                                             dataBuffer>());
-                    }
+            // We will get rid of all inputs on the operation set parameter and then copy the return
+            // results. This will contain only the operations that contain generated outputs from
+            // the service.
+            (*operationSets)[setIdx].operations.clear();
+            int operationIdx = 0;
+            for (auto& cppOperation : cppOperationSets[setIdx].operations) {
+                if (cppOperation.getTag() != cpp_hwcrypto::CryptoOperation::dataOutput) {
+                    LOG(ERROR) << "cpp operations on set " << setIdx << " and operation "
+                               << operationIdx << " is not CryptoOperation::dataOutput";
+                    return convertStatus(Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT));
                 }
+                auto cppDataOperation =
+                        cppOperation.get<cpp_hwcrypto::CryptoOperation::dataOutput>();
+                if (cppDataOperation.getTag() != cpp_hwcrypto::types::OperationData::dataBuffer) {
+                    LOG(ERROR) << "cpp operations on set " << setIdx << " and operation "
+                               << operationIdx
+                               << " is not CryptoOperation::dataOutput(OperationData::dataBuffer)";
+                    return convertStatus(Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT));
+                }
+                ndk_hwcrypto::types::OperationData ndkOperationData;
+                ndkOperationData.set<ndk_hwcrypto::types::OperationData::dataBuffer>(
+                        cppDataOperation.get<cpp_hwcrypto::types::OperationData::dataBuffer>());
+                ndk_hwcrypto::CryptoOperation ndkOperation;
+                ndkOperation.set<ndk_hwcrypto::CryptoOperation::dataOutput>(
+                        std::move(ndkOperationData));
+                (*operationSets)[setIdx].operations.push_back(std::move(ndkOperation));
+                ++operationIdx;
             }
         }
         return convertStatus(status);
@@ -716,6 +698,19 @@ class OpaqueKeyNdk : public ndk_hwcrypto::BnOpaqueKey {
     }
 };
 
+static void create_key_mapping_if_success(Status status,
+                                          sp<cpp_hwcrypto::IOpaqueKey>& binder_return,
+                                          std::shared_ptr<ndk_hwcrypto::IOpaqueKey>* aidl_return) {
+    if (status.isOk()) {
+        if ((binder_return != nullptr)) {
+            insertBinderMapping<cpp_hwcrypto::IOpaqueKey, ndk_hwcrypto::IOpaqueKey, OpaqueKeyNdk,
+                                keyMapping>(binder_return, aidl_return);
+        } else {
+            *aidl_return = nullptr;
+        }
+    }
+}
+
 Result<void> HwCryptoKey::connectToTrusty(const char* tipcDev) {
     assert(!mSession);
     auto session_initializer = [](sp<RpcSession>& session) {
@@ -810,14 +805,7 @@ ndk::ScopedAStatus HwCryptoKey::importClearKey(
         return convertStatus(status);
     }
     status = mHwCryptoServer->importClearKey(explicitKeyCpp.value(), cppKeyPolicy, &binder_return);
-    if (status.isOk()) {
-        if ((binder_return != nullptr)) {
-            insertBinderMapping<cpp_hwcrypto::IOpaqueKey, ndk_hwcrypto::IOpaqueKey, OpaqueKeyNdk,
-                                keyMapping>(binder_return, aidl_return);
-        } else {
-            *aidl_return = nullptr;
-        }
-    }
+    create_key_mapping_if_success(status, binder_return, aidl_return);
     return convertStatus(status);
 }
 
@@ -840,10 +828,7 @@ ndk::ScopedAStatus HwCryptoKey::keyTokenImport(
     // trying first a shallow copy of the vector
     requestedKeyCpp.keyToken = requestedKey.keyToken;
     status = mHwCryptoServer->keyTokenImport(requestedKeyCpp, sealingDicePolicy, &binder_return);
-    if (status.isOk()) {
-        std::shared_ptr<ndk_hwcrypto::IOpaqueKey> opaqueKey = OpaqueKeyNdk::Create(binder_return);
-        *aidl_return = opaqueKey;
-    }
+    create_key_mapping_if_success(status, binder_return, aidl_return);
     return convertStatus(status);
 }
 
diff --git a/security/sharedsecret/aidl/vts/functional/Android.bp b/security/sharedsecret/aidl/vts/functional/Android.bp
index eedd3251bc..ef668a3092 100644
--- a/security/sharedsecret/aidl/vts/functional/Android.bp
+++ b/security/sharedsecret/aidl/vts/functional/Android.bp
@@ -44,7 +44,6 @@ cc_test {
     ],
     static_libs: [
         "android.hardware.security.sharedsecret-V1-ndk",
-        "libkeymint",
     ],
     test_suites: [
         "general-tests",
diff --git a/sensors/aidl/android/hardware/sensors/AdditionalInfo.aidl b/sensors/aidl/android/hardware/sensors/AdditionalInfo.aidl
index 9fe2d39700..56e655df4b 100644
--- a/sensors/aidl/android/hardware/sensors/AdditionalInfo.aidl
+++ b/sensors/aidl/android/hardware/sensors/AdditionalInfo.aidl
@@ -223,6 +223,8 @@ parcelable AdditionalInfo {
 
         /**
          * Custom information
+         *
+         * Custom information must only contain float data. It may have variable size.
          */
         AINFO_CUSTOM_START = 0x10000000,
 
diff --git a/sensors/aidl/convert/convert.cpp b/sensors/aidl/convert/convert.cpp
index 2dc7a177a0..940699c831 100644
--- a/sensors/aidl/convert/convert.cpp
+++ b/sensors/aidl/convert/convert.cpp
@@ -418,10 +418,21 @@ void convertFromSensorEvent(const sensors_event_t& src, Event* dst) {
             info.type = (AdditionalInfo::AdditionalInfoType)srcInfo.type;
             info.serial = srcInfo.serial;
 
-            AdditionalInfo::AdditionalInfoPayload::Int32Values data;
-            CHECK_EQ(data.values.size() * sizeof(int32_t), sizeof(srcInfo.data_int32));
-            memcpy(data.values.data(), srcInfo.data_int32, sizeof(srcInfo.data_int32));
-            info.payload.set<AdditionalInfo::AdditionalInfoPayload::Tag::dataInt32>(data);
+            // AdditionalInfo operation environment parameters section
+            if (info.type == AdditionalInfo::AdditionalInfoType::AINFO_LOCAL_GEOMAGNETIC_FIELD ||
+                info.type == AdditionalInfo::AdditionalInfoType::AINFO_LOCAL_GRAVITY ||
+                (info.type >= AdditionalInfo::AdditionalInfoType::AINFO_CUSTOM_START &&
+                 info.type < AdditionalInfo::AdditionalInfoType::AINFO_DEBUGGING_START)) {
+                AdditionalInfo::AdditionalInfoPayload::FloatValues data;
+                CHECK_EQ(data.values.size() * sizeof(float), sizeof(srcInfo.data_float));
+                memcpy(data.values.data(), srcInfo.data_float, sizeof(srcInfo.data_float));
+                info.payload.set<AdditionalInfo::AdditionalInfoPayload::Tag::dataFloat>(data);
+            } else {
+                AdditionalInfo::AdditionalInfoPayload::Int32Values data;
+                CHECK_EQ(data.values.size() * sizeof(int32_t), sizeof(srcInfo.data_int32));
+                memcpy(data.values.data(), srcInfo.data_int32, sizeof(srcInfo.data_int32));
+                info.payload.set<AdditionalInfo::AdditionalInfoPayload::Tag::dataInt32>(data);
+            }
 
             dst->payload.set<Event::EventPayload::Tag::additional>(info);
             break;
diff --git a/sensors/aidl/default/multihal/ConvertUtils.cpp b/sensors/aidl/default/multihal/ConvertUtils.cpp
index bf56ed52a3..9f28a8107a 100644
--- a/sensors/aidl/default/multihal/ConvertUtils.cpp
+++ b/sensors/aidl/default/multihal/ConvertUtils.cpp
@@ -31,11 +31,7 @@ using V2_1SensorInfo = ::android::hardware::sensors::V2_1::SensorInfo;
 using V2_1Event = ::android::hardware::sensors::V2_1::Event;
 using V2_1SensorType = ::android::hardware::sensors::V2_1::SensorType;
 
-namespace aidl {
-namespace android {
-namespace hardware {
-namespace sensors {
-namespace implementation {
+namespace aidl::android::hardware::sensors::implementation {
 
 AidlSensorInfo convertSensorInfo(const V2_1SensorInfo& sensorInfo) {
     AidlSensorInfo aidlSensorInfo;
@@ -120,6 +116,7 @@ void convertToHidlEvent(const AidlEvent& aidlEvent, V2_1Event* hidlEvent) {
         case AidlSensorType::HEART_BEAT:
         case AidlSensorType::LOW_LATENCY_OFFBODY_DETECT:
         case AidlSensorType::HINGE_ANGLE:
+        case AidlSensorType::MOISTURE_INTRUSION:
             hidlEvent->u.scalar = aidlEvent.payload.get<Event::EventPayload::scalar>();
             break;
         case AidlSensorType::STEP_COUNTER:
@@ -195,6 +192,39 @@ void convertToHidlEvent(const AidlEvent& aidlEvent, V2_1Event* hidlEvent) {
             *(reinterpret_cast<int32_t*>(&hidlEvent->u.data[6])) = ht.discontinuityCount;
             break;
         }
+        case AidlSensorType::ACCELEROMETER_LIMITED_AXES:
+        case AidlSensorType::GYROSCOPE_LIMITED_AXES: {
+            const auto& limitedAxesImu =
+                    aidlEvent.payload.get<Event::EventPayload::limitedAxesImu>();
+            hidlEvent->u.data[0] = limitedAxesImu.x;
+            hidlEvent->u.data[1] = limitedAxesImu.y;
+            hidlEvent->u.data[2] = limitedAxesImu.z;
+            hidlEvent->u.data[3] = limitedAxesImu.xSupported;
+            hidlEvent->u.data[4] = limitedAxesImu.ySupported;
+            hidlEvent->u.data[5] = limitedAxesImu.zSupported;
+            break;
+        }
+        case AidlSensorType::ACCELEROMETER_LIMITED_AXES_UNCALIBRATED:
+        case AidlSensorType::GYROSCOPE_LIMITED_AXES_UNCALIBRATED: {
+            const auto& limitedAxesImuUncal =
+                    aidlEvent.payload.get<Event::EventPayload::limitedAxesImuUncal>();
+            hidlEvent->u.data[0] = limitedAxesImuUncal.x;
+            hidlEvent->u.data[1] = limitedAxesImuUncal.y;
+            hidlEvent->u.data[2] = limitedAxesImuUncal.z;
+            hidlEvent->u.data[3] = limitedAxesImuUncal.xBias;
+            hidlEvent->u.data[4] = limitedAxesImuUncal.yBias;
+            hidlEvent->u.data[5] = limitedAxesImuUncal.zBias;
+            hidlEvent->u.data[6] = limitedAxesImuUncal.xSupported;
+            hidlEvent->u.data[7] = limitedAxesImuUncal.ySupported;
+            hidlEvent->u.data[8] = limitedAxesImuUncal.zSupported;
+            break;
+        }
+        case AidlSensorType::HEADING: {
+            const auto& heading = aidlEvent.payload.get<Event::EventPayload::heading>();
+            hidlEvent->u.data[0] = heading.heading;
+            hidlEvent->u.data[1] = heading.accuracy;
+            break;
+        }
         default: {
             CHECK_GE((int32_t)aidlEvent.sensorType, (int32_t)SensorType::DEVICE_PRIVATE_BASE);
             std::copy(std::begin(aidlEvent.payload.get<AidlEvent::EventPayload::data>().values),
@@ -210,19 +240,19 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
     aidlEvent->timestamp = hidlEvent.timestamp;
     aidlEvent->sensorHandle = hidlEvent.sensorHandle;
     aidlEvent->sensorType = (AidlSensorType)hidlEvent.sensorType;
-    switch (hidlEvent.sensorType) {
-        case V2_1SensorType::META_DATA: {
+    switch (aidlEvent->sensorType) {
+        case AidlSensorType::META_DATA: {
             AidlEvent::EventPayload::MetaData meta;
             meta.what = (Event::EventPayload::MetaData::MetaDataEventType)hidlEvent.u.meta.what;
             aidlEvent->payload.set<Event::EventPayload::meta>(meta);
             break;
         }
-        case V2_1SensorType::ACCELEROMETER:
-        case V2_1SensorType::MAGNETIC_FIELD:
-        case V2_1SensorType::ORIENTATION:
-        case V2_1SensorType::GYROSCOPE:
-        case V2_1SensorType::GRAVITY:
-        case V2_1SensorType::LINEAR_ACCELERATION: {
+        case AidlSensorType::ACCELEROMETER:
+        case AidlSensorType::MAGNETIC_FIELD:
+        case AidlSensorType::ORIENTATION:
+        case AidlSensorType::GYROSCOPE:
+        case AidlSensorType::GRAVITY:
+        case AidlSensorType::LINEAR_ACCELERATION: {
             AidlEvent::EventPayload::Vec3 vec3;
             vec3.x = hidlEvent.u.vec3.x;
             vec3.y = hidlEvent.u.vec3.y;
@@ -231,7 +261,7 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
             aidlEvent->payload.set<Event::EventPayload::vec3>(vec3);
             break;
         }
-        case V2_1SensorType::GAME_ROTATION_VECTOR: {
+        case AidlSensorType::GAME_ROTATION_VECTOR: {
             AidlEvent::EventPayload::Vec4 vec4;
             vec4.x = hidlEvent.u.vec4.x;
             vec4.y = hidlEvent.u.vec4.y;
@@ -240,17 +270,17 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
             aidlEvent->payload.set<Event::EventPayload::vec4>(vec4);
             break;
         }
-        case V2_1SensorType::ROTATION_VECTOR:
-        case V2_1SensorType::GEOMAGNETIC_ROTATION_VECTOR: {
+        case AidlSensorType::ROTATION_VECTOR:
+        case AidlSensorType::GEOMAGNETIC_ROTATION_VECTOR: {
             AidlEvent::EventPayload::Data data;
             std::copy(hidlEvent.u.data.data(), hidlEvent.u.data.data() + 5,
                       std::begin(data.values));
             aidlEvent->payload.set<Event::EventPayload::data>(data);
             break;
         }
-        case V2_1SensorType::MAGNETIC_FIELD_UNCALIBRATED:
-        case V2_1SensorType::GYROSCOPE_UNCALIBRATED:
-        case V2_1SensorType::ACCELEROMETER_UNCALIBRATED: {
+        case AidlSensorType::MAGNETIC_FIELD_UNCALIBRATED:
+        case AidlSensorType::GYROSCOPE_UNCALIBRATED:
+        case AidlSensorType::ACCELEROMETER_UNCALIBRATED: {
             AidlEvent::EventPayload::Uncal uncal;
             uncal.x = hidlEvent.u.uncal.x;
             uncal.y = hidlEvent.u.uncal.y;
@@ -261,37 +291,38 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
             aidlEvent->payload.set<Event::EventPayload::uncal>(uncal);
             break;
         }
-        case V2_1SensorType::DEVICE_ORIENTATION:
-        case V2_1SensorType::LIGHT:
-        case V2_1SensorType::PRESSURE:
-        case V2_1SensorType::PROXIMITY:
-        case V2_1SensorType::RELATIVE_HUMIDITY:
-        case V2_1SensorType::AMBIENT_TEMPERATURE:
-        case V2_1SensorType::SIGNIFICANT_MOTION:
-        case V2_1SensorType::STEP_DETECTOR:
-        case V2_1SensorType::TILT_DETECTOR:
-        case V2_1SensorType::WAKE_GESTURE:
-        case V2_1SensorType::GLANCE_GESTURE:
-        case V2_1SensorType::PICK_UP_GESTURE:
-        case V2_1SensorType::WRIST_TILT_GESTURE:
-        case V2_1SensorType::STATIONARY_DETECT:
-        case V2_1SensorType::MOTION_DETECT:
-        case V2_1SensorType::HEART_BEAT:
-        case V2_1SensorType::LOW_LATENCY_OFFBODY_DETECT:
-        case V2_1SensorType::HINGE_ANGLE:
+        case AidlSensorType::DEVICE_ORIENTATION:
+        case AidlSensorType::LIGHT:
+        case AidlSensorType::PRESSURE:
+        case AidlSensorType::PROXIMITY:
+        case AidlSensorType::RELATIVE_HUMIDITY:
+        case AidlSensorType::AMBIENT_TEMPERATURE:
+        case AidlSensorType::SIGNIFICANT_MOTION:
+        case AidlSensorType::STEP_DETECTOR:
+        case AidlSensorType::TILT_DETECTOR:
+        case AidlSensorType::WAKE_GESTURE:
+        case AidlSensorType::GLANCE_GESTURE:
+        case AidlSensorType::PICK_UP_GESTURE:
+        case AidlSensorType::WRIST_TILT_GESTURE:
+        case AidlSensorType::STATIONARY_DETECT:
+        case AidlSensorType::MOTION_DETECT:
+        case AidlSensorType::HEART_BEAT:
+        case AidlSensorType::LOW_LATENCY_OFFBODY_DETECT:
+        case AidlSensorType::HINGE_ANGLE:
+        case AidlSensorType::MOISTURE_INTRUSION:
             aidlEvent->payload.set<Event::EventPayload::scalar>(hidlEvent.u.scalar);
             break;
-        case V2_1SensorType::STEP_COUNTER:
+        case AidlSensorType::STEP_COUNTER:
             aidlEvent->payload.set<Event::EventPayload::stepCount>(hidlEvent.u.stepCount);
             break;
-        case V2_1SensorType::HEART_RATE: {
+        case AidlSensorType::HEART_RATE: {
             AidlEvent::EventPayload::HeartRate heartRate;
             heartRate.bpm = hidlEvent.u.heartRate.bpm;
             heartRate.status = (SensorStatus)hidlEvent.u.heartRate.status;
             aidlEvent->payload.set<Event::EventPayload::heartRate>(heartRate);
             break;
         }
-        case V2_1SensorType::POSE_6DOF: {
+        case AidlSensorType::POSE_6DOF: {
             AidlEvent::EventPayload::Pose6Dof pose6Dof;
             std::copy(hidlEvent.u.pose6DOF.data(),
                       hidlEvent.u.pose6DOF.data() + hidlEvent.u.pose6DOF.size(),
@@ -299,7 +330,7 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
             aidlEvent->payload.set<Event::EventPayload::pose6DOF>(pose6Dof);
             break;
         }
-        case V2_1SensorType::DYNAMIC_SENSOR_META: {
+        case AidlSensorType::DYNAMIC_SENSOR_META: {
             DynamicSensorInfo dynamicSensorInfo;
             dynamicSensorInfo.connected = hidlEvent.u.dynamic.connected;
             dynamicSensorInfo.sensorHandle = hidlEvent.u.dynamic.sensorHandle;
@@ -309,7 +340,7 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
             aidlEvent->payload.set<Event::EventPayload::dynamic>(dynamicSensorInfo);
             break;
         }
-        case V2_1SensorType::ADDITIONAL_INFO: {
+        case AidlSensorType::ADDITIONAL_INFO: {
             AdditionalInfo additionalInfo;
             additionalInfo.type = (AdditionalInfo::AdditionalInfoType)hidlEvent.u.additional.type;
             additionalInfo.serial = hidlEvent.u.additional.serial;
@@ -324,40 +355,67 @@ void convertToAidlEvent(const V2_1Event& hidlEvent, AidlEvent* aidlEvent) {
             aidlEvent->payload.set<Event::EventPayload::additional>(additionalInfo);
             break;
         }
-        default: {
-            if (static_cast<int32_t>(hidlEvent.sensorType) ==
-                static_cast<int32_t>(AidlSensorType::HEAD_TRACKER)) {
-                Event::EventPayload::HeadTracker headTracker;
-                headTracker.rx = hidlEvent.u.data[0];
-                headTracker.ry = hidlEvent.u.data[1];
-                headTracker.rz = hidlEvent.u.data[2];
-                headTracker.vx = hidlEvent.u.data[3];
-                headTracker.vy = hidlEvent.u.data[4];
-                headTracker.vz = hidlEvent.u.data[5];
+        case AidlSensorType::HEAD_TRACKER: {
+            Event::EventPayload::HeadTracker headTracker;
+            headTracker.rx = hidlEvent.u.data[0];
+            headTracker.ry = hidlEvent.u.data[1];
+            headTracker.rz = hidlEvent.u.data[2];
+            headTracker.vx = hidlEvent.u.data[3];
+            headTracker.vy = hidlEvent.u.data[4];
+            headTracker.vz = hidlEvent.u.data[5];
 
-                // IMPORTANT: Because we want to preserve the data range of discontinuityCount,
-                // we assume the data can be interpreted as an int32_t directly (e.g. the underlying
-                // HIDL HAL must be using memcpy or equivalent to store this value).
-                headTracker.discontinuityCount =
-                        *(reinterpret_cast<const int32_t*>(&hidlEvent.u.data[6]));
+            // IMPORTANT: Because we want to preserve the data range of discontinuityCount,
+            // we assume the data can be interpreted as an int32_t directly (e.g. the underlying
+            // HIDL HAL must be using memcpy or equivalent to store this value).
+            headTracker.discontinuityCount =
+                    *(reinterpret_cast<const int32_t*>(&hidlEvent.u.data[6]));
 
-                aidlEvent->payload.set<Event::EventPayload::Tag::headTracker>(headTracker);
-            } else {
-                CHECK_GE((int32_t)hidlEvent.sensorType,
-                         (int32_t)V2_1SensorType::DEVICE_PRIVATE_BASE);
-                AidlEvent::EventPayload::Data data;
-                std::copy(hidlEvent.u.data.data(),
-                          hidlEvent.u.data.data() + hidlEvent.u.data.size(),
-                          std::begin(data.values));
-                aidlEvent->payload.set<Event::EventPayload::data>(data);
-            }
+            aidlEvent->payload.set<Event::EventPayload::Tag::headTracker>(headTracker);
+            break;
+        }
+        case AidlSensorType::ACCELEROMETER_LIMITED_AXES:
+        case AidlSensorType::GYROSCOPE_LIMITED_AXES: {
+            Event::EventPayload::LimitedAxesImu limitedAxesImu;
+            limitedAxesImu.x = hidlEvent.u.data[0];
+            limitedAxesImu.y = hidlEvent.u.data[1];
+            limitedAxesImu.z = hidlEvent.u.data[2];
+            limitedAxesImu.xSupported = hidlEvent.u.data[3];
+            limitedAxesImu.ySupported = hidlEvent.u.data[4];
+            limitedAxesImu.zSupported = hidlEvent.u.data[5];
+            aidlEvent->payload.set<Event::EventPayload::limitedAxesImu>(limitedAxesImu);
+            break;
+        }
+        case AidlSensorType::ACCELEROMETER_LIMITED_AXES_UNCALIBRATED:
+        case AidlSensorType::GYROSCOPE_LIMITED_AXES_UNCALIBRATED: {
+            Event::EventPayload::LimitedAxesImuUncal limitedAxesImuUncal;
+            limitedAxesImuUncal.x = hidlEvent.u.data[0];
+            limitedAxesImuUncal.y = hidlEvent.u.data[1];
+            limitedAxesImuUncal.z = hidlEvent.u.data[2];
+            limitedAxesImuUncal.xBias = hidlEvent.u.data[3];
+            limitedAxesImuUncal.yBias = hidlEvent.u.data[4];
+            limitedAxesImuUncal.zBias = hidlEvent.u.data[5];
+            limitedAxesImuUncal.xSupported = hidlEvent.u.data[6];
+            limitedAxesImuUncal.ySupported = hidlEvent.u.data[7];
+            limitedAxesImuUncal.zSupported = hidlEvent.u.data[8];
+            aidlEvent->payload.set<Event::EventPayload::limitedAxesImuUncal>(limitedAxesImuUncal);
+            break;
+        }
+        case AidlSensorType::HEADING: {
+            Event::EventPayload::Heading heading;
+            heading.heading = hidlEvent.u.data[0];
+            heading.accuracy = hidlEvent.u.data[1];
+            aidlEvent->payload.set<Event::EventPayload::heading>(heading);
+            break;
+        }
+        default: {
+            CHECK_GE((int32_t)hidlEvent.sensorType, (int32_t)V2_1SensorType::DEVICE_PRIVATE_BASE);
+            AidlEvent::EventPayload::Data data;
+            std::copy(hidlEvent.u.data.data(), hidlEvent.u.data.data() + hidlEvent.u.data.size(),
+                      std::begin(data.values));
+            aidlEvent->payload.set<Event::EventPayload::data>(data);
             break;
         }
     }
 }
 
-}  // namespace implementation
-}  // namespace sensors
-}  // namespace hardware
-}  // namespace android
-}  // namespace aidl
+}  // namespace aidl::android::hardware::sensors::implementation
diff --git a/sensors/aidl/multihal/Android.bp b/sensors/aidl/multihal/Android.bp
index cee3db608d..ef8fa05291 100644
--- a/sensors/aidl/multihal/Android.bp
+++ b/sensors/aidl/multihal/Android.bp
@@ -24,6 +24,12 @@ package {
     default_applicable_licenses: ["hardware_interfaces_license"],
 }
 
+vintf_fragment {
+    name: "android.hardware.sensors-multihal.xml",
+    src: "android.hardware.sensors-multihal.xml",
+    vendor: true,
+}
+
 cc_binary {
     name: "android.hardware.sensors-service.multihal",
     vendor: true,
@@ -36,7 +42,7 @@ cc_binary {
         "android.hardware.sensors@2.X-shared-utils",
     ],
     init_rc: ["android.hardware.sensors-service-multihal.rc"],
-    vintf_fragments: ["android.hardware.sensors-multihal.xml"],
+    vintf_fragment_modules: ["android.hardware.sensors-multihal.xml"],
     shared_libs: [
         "android.hardware.sensors@2.0-ScopedWakelock",
         "android.hardware.sensors@2.0",
diff --git a/sensors/aidl/multihal/android.hardware.sensors-service-multihal.rc b/sensors/aidl/multihal/android.hardware.sensors-service-multihal.rc
index d1acd6fe7b..5aecc54539 100644
--- a/sensors/aidl/multihal/android.hardware.sensors-service-multihal.rc
+++ b/sensors/aidl/multihal/android.hardware.sensors-service-multihal.rc
@@ -1,6 +1,3 @@
-on boot
-    setprop vendor.sensors.dynamic_sensor_op_timeout_ms 1600
-
 service vendor.sensors-hal-multihal /vendor/bin/hw/android.hardware.sensors-service.multihal
     class hal
     user system
diff --git a/thermal/1.0/vts/functional/OWNERS b/thermal/1.0/vts/functional/OWNERS
index 0c282a0e04..1f09611328 100644
--- a/thermal/1.0/vts/functional/OWNERS
+++ b/thermal/1.0/vts/functional/OWNERS
@@ -1,2 +1,2 @@
 # Bug component: 623506
-wvw@google.com
+file:platform/frameworks/base:/ADPF_OWNERS
diff --git a/thermal/2.0/vts/functional/OWNERS b/thermal/2.0/vts/functional/OWNERS
index 0c282a0e04..1f09611328 100644
--- a/thermal/2.0/vts/functional/OWNERS
+++ b/thermal/2.0/vts/functional/OWNERS
@@ -1,2 +1,2 @@
 # Bug component: 623506
-wvw@google.com
+file:platform/frameworks/base:/ADPF_OWNERS
diff --git a/thermal/OWNERS b/thermal/OWNERS
index 13895bdb3a..9576e140af 100644
--- a/thermal/OWNERS
+++ b/thermal/OWNERS
@@ -1,3 +1,2 @@
 # Bug component: 826709
 file:platform/frameworks/base:/ADPF_OWNERS
-wvw@google.com
diff --git a/threadnetwork/aidl/vts/VtsHalThreadNetworkTargetTest.xml b/threadnetwork/aidl/vts/VtsHalThreadNetworkTargetTest.xml
index b5eb843920..453819d107 100644
--- a/threadnetwork/aidl/vts/VtsHalThreadNetworkTargetTest.xml
+++ b/threadnetwork/aidl/vts/VtsHalThreadNetworkTargetTest.xml
@@ -15,6 +15,7 @@
 -->
 
 <configuration description="Runs VtsHalThreadNetworkTargetTest.">
+    <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
     <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
         <option name="run-command" value="if pm list features |grep 'android.hardware.thread_network'; then cmd thread_network force-stop-ot-daemon enabled; fi" />
         <option name="run-command" value="cmd bluetooth_manager enable" />
diff --git a/usb/OWNERS b/usb/OWNERS
index 0c737820a4..5a827a8356 100644
--- a/usb/OWNERS
+++ b/usb/OWNERS
@@ -1,6 +1,4 @@
 # Bug component: 175220
-
-vmartensson@google.com
 nkapron@google.com
 febinthattil@google.com
 shubhankarm@google.com
diff --git a/uwb/aidl/default/src/uwb_chip.rs b/uwb/aidl/default/src/uwb_chip.rs
index 0ed05d85ca..002bde300e 100644
--- a/uwb/aidl/default/src/uwb_chip.rs
+++ b/uwb/aidl/default/src/uwb_chip.rs
@@ -16,6 +16,7 @@ enum ClientState {
     Opened {
         callbacks: Strong<dyn IUwbClientCallback>,
         _death_recipient: DeathRecipient,
+        initialized: bool,
     },
 }
 
@@ -97,11 +98,20 @@ impl UwbChip {
 
                     log::debug!(" <-- {:?}", &buffer[0..total_packet_length]);
 
-                    let service_state = service_state.lock().await;
-                    if let ClientState::Opened { ref callbacks, .. } = service_state.client_state {
-                        callbacks
+                    let mut service_state = service_state.lock().await;
+                    if let ClientState::Opened { ref callbacks, ref mut initialized, .. } = service_state.client_state {
+                        if !*initialized {
+                            if matches!(&buffer[0..total_packet_length], [0x40, 0x00, 0x00, 0x01, 0x00]
+                            ) {
+                                *initialized = true;
+                                callbacks.onHalEvent(UwbEvent::OPEN_CPLT, UwbStatus::OK)
+                                    .expect("failed to call onHalEvent");
+                            }
+                        } else {
+                            callbacks
                             .onUciMessage(&buffer[0..total_packet_length])
                             .unwrap();
+                        }
                     }
                 }
             })
@@ -142,33 +152,20 @@ impl IUwbChipAsyncServer for UwbChip {
         };
 
         callbacks.as_binder().link_to_death(&mut death_recipient)?;
-        callbacks.onHalEvent(UwbEvent::OPEN_CPLT, UwbStatus::OK)?;
 
         service_state.client_state = ClientState::Opened {
             callbacks: callbacks.clone(),
             _death_recipient: death_recipient,
+            initialized: false,
         };
 
-        Ok(())
-    }
-
-    async fn close(&self) -> Result<()> {
-        log::debug!("close");
-
-        let mut service_state = self.service_state.lock().await;
-
-        if matches!(service_state.client_state, ClientState::Closed) {
-            log::error!("the state is already closed");
-            return Err(binder::ExceptionCode::ILLEGAL_STATE.into());
-        }
-
         // Send the command Device Reset to stop all running activities
         // on the UWBS emulator. This is necessary because the emulator
         // is otherwise not notified of the power down (the serial stays
         // open).
         //
-        // The response to the command will be dropped by the polling loop,
-        // as the callbacks will have been removed then.
+        // The response to the command will be handled so it won't be sent
+        // to uci layer.
         let uci_core_device_reset_cmd = [0x20, 0x00, 0x00, 0x01, 0x00];
 
         service_state
@@ -177,6 +174,19 @@ impl IUwbChipAsyncServer for UwbChip {
             .await
             .expect("failed to write UCI Device Reset command");
 
+        Ok(())
+    }
+
+    async fn close(&self) -> Result<()> {
+        log::debug!("close");
+
+        let mut service_state = self.service_state.lock().await;
+
+        if matches!(service_state.client_state, ClientState::Closed) {
+            log::error!("the state is already closed");
+            return Err(binder::ExceptionCode::ILLEGAL_STATE.into());
+        }
+
         if let ClientState::Opened { ref callbacks, .. } = service_state.client_state {
             callbacks.onHalEvent(UwbEvent::CLOSE_CPLT, UwbStatus::OK)?;
         }
diff --git a/uwb/aidl/vts/VtsHalUwbTargetTest.cpp b/uwb/aidl/vts/VtsHalUwbTargetTest.cpp
index c75160c60b..282a5c0cd8 100644
--- a/uwb/aidl/vts/VtsHalUwbTargetTest.cpp
+++ b/uwb/aidl/vts/VtsHalUwbTargetTest.cpp
@@ -216,7 +216,7 @@ TEST_P(UwbAidl, ChipSendUciMessage_GetDeviceInfo) {
                     init_cb_promise.set_value();
                 }
             });
-    std::chrono::milliseconds timeout{1000};
+    std::chrono::milliseconds timeout{kOpenCallbackTimeoutMs};
     const auto iuwb_chip = getAnyChip();
     EXPECT_TRUE(iuwb_chip->open(callback).isOk());
     EXPECT_EQ(open_cb_future.wait_for(timeout), std::future_status::ready);
diff --git a/vibrator/1.0/Android.bp b/vibrator/1.0/Android.bp
deleted file mode 100644
index 1ae1cef04d..0000000000
--- a/vibrator/1.0/Android.bp
+++ /dev/null
@@ -1,24 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.vibrator@1.0",
-    root: "android.hardware",
-    srcs: [
-        "types.hal",
-        "IVibrator.hal",
-    ],
-    interfaces: [
-        "android.hidl.base@1.0",
-    ],
-    gen_java: true,
-    gen_java_constants: true,
-}
diff --git a/vibrator/1.0/IVibrator.hal b/vibrator/1.0/IVibrator.hal
deleted file mode 100644
index 757ad0d74f..0000000000
--- a/vibrator/1.0/IVibrator.hal
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vibrator@1.0;
-
-interface IVibrator {
-  /**
-   * Turn on vibrator
-   *
-   * This function must only be called after the previous timeout has expired or
-   * was canceled (through off()).
-   * @param timeout_ms number of milliseconds to vibrate.
-   * @return vibratorOnRet whether vibrator command was successful or not.
-   */
-  on(uint32_t timeoutMs) generates (Status vibratorOnRet);
-
-  /**
-   * Turn off vibrator
-   *
-   * Cancel a previously-started vibration, if any.
-   * @return vibratorOffRet whether vibrator command was successful or not.
-   */
-  off() generates (Status vibratorOffRet);
-
-  /**
-   * Returns whether the vibrator supports changes to its vibrational amplitude.
-   */
-  supportsAmplitudeControl() generates (bool supports);
-
-  /**
-   * Sets the motor's vibrational amplitude.
-   *
-   * Changes the force being produced by the underlying motor.
-   *
-   * @param amplitude The unitless force setting. Note that this number must
-   *                  be between 1 and 255, inclusive. If the motor does not
-   *                  have exactly 255 steps, it must do it's best to map it
-   *                  onto the number of steps it does have.
-   * @return status Whether the command was successful or not. Must return
-   *                Status::UNSUPPORTED_OPERATION if setting the amplitude is
-   *                not supported by the device.
-   */
-  setAmplitude(uint8_t amplitude) generates (Status status);
-
-  /**
-   * Fire off a predefined haptic event.
-   *
-   * @param event The type of haptic event to trigger.
-   * @return status Whether the effect was successfully performed or not. Must
-   *                return Status::UNSUPPORTED_OPERATION is the effect is not
-   *                supported.
-   * @return lengthMs The length of time the event is expected to take in
-   *                  milliseconds. This doesn't need to be perfectly accurate,
-   *                  but should be a reasonable approximation. Should be a
-   *                  positive, non-zero value if the returned status is
-   *                  Status::OK, and set to 0 otherwise.
-   */
-  perform(Effect effect, EffectStrength strength) generates (Status status, uint32_t lengthMs);
-};
diff --git a/vibrator/1.0/default/Android.bp b/vibrator/1.0/default/Android.bp
deleted file mode 100644
index ed750b453b..0000000000
--- a/vibrator/1.0/default/Android.bp
+++ /dev/null
@@ -1,55 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_library_shared {
-    name: "android.hardware.vibrator@1.0-impl",
-    defaults: ["hidl_defaults"],
-    vendor: true,
-    relative_install_path: "hw",
-    srcs: ["Vibrator.cpp"],
-    shared_libs: [
-        "libhidlbase",
-        "liblog",
-        "libutils",
-        "libhardware",
-        "android.hardware.vibrator@1.0",
-    ],
-}
-
-cc_binary {
-    name: "android.hardware.vibrator@1.0-service",
-    defaults: ["hidl_defaults"],
-    init_rc: ["android.hardware.vibrator@1.0-service.rc"],
-    vendor: true,
-    relative_install_path: "hw",
-    srcs: ["service.cpp"],
-
-    shared_libs: [
-        "libhidlbase",
-        "liblog",
-        "libutils",
-        "libhardware",
-        "android.hardware.vibrator@1.0",
-    ],
-}
diff --git a/vibrator/1.0/default/Vibrator.cpp b/vibrator/1.0/default/Vibrator.cpp
deleted file mode 100644
index 19cf3dc850..0000000000
--- a/vibrator/1.0/default/Vibrator.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "VibratorService"
-
-#include <inttypes.h>
-
-#include <log/log.h>
-
-#include <hardware/hardware.h>
-#include <hardware/vibrator.h>
-
-#include "Vibrator.h"
-
-namespace android {
-namespace hardware {
-namespace vibrator {
-namespace V1_0 {
-namespace implementation {
-
-Vibrator::Vibrator(vibrator_device_t *device) : mDevice(device) {}
-
-// Methods from ::android::hardware::vibrator::V1_0::IVibrator follow.
-Return<Status> Vibrator::on(uint32_t timeout_ms) {
-    int32_t ret = mDevice->vibrator_on(mDevice, timeout_ms);
-    if (ret != 0) {
-        ALOGE("on command failed : %s", strerror(-ret));
-        return Status::UNKNOWN_ERROR;
-    }
-    return Status::OK;
-}
-
-Return<Status> Vibrator::off()  {
-    int32_t ret = mDevice->vibrator_off(mDevice);
-    if (ret != 0) {
-        ALOGE("off command failed : %s", strerror(-ret));
-        return Status::UNKNOWN_ERROR;
-    }
-    return Status::OK;
-}
-
-Return<bool> Vibrator::supportsAmplitudeControl()  {
-    return false;
-}
-
-Return<Status> Vibrator::setAmplitude(uint8_t) {
-    return Status::UNSUPPORTED_OPERATION;
-}
-
-Return<void> Vibrator::perform(Effect, EffectStrength, perform_cb _hidl_cb) {
-    _hidl_cb(Status::UNSUPPORTED_OPERATION, 0);
-    return Void();
-}
-
-IVibrator* HIDL_FETCH_IVibrator(const char * /*hal*/) {
-    vibrator_device_t *vib_device;
-    const hw_module_t *hw_module = nullptr;
-
-    int ret = hw_get_module(VIBRATOR_HARDWARE_MODULE_ID, &hw_module);
-    if (ret == 0) {
-        ret = vibrator_open(hw_module, &vib_device);
-        if (ret != 0) {
-            ALOGE("vibrator_open failed: %d", ret);
-        }
-    } else {
-        ALOGE("hw_get_module %s failed: %d", VIBRATOR_HARDWARE_MODULE_ID, ret);
-    }
-
-    if (ret == 0) {
-        return new Vibrator(vib_device);
-    } else {
-        ALOGE("Passthrough failed to open legacy HAL.");
-        return nullptr;
-    }
-}
-
-} // namespace implementation
-}  // namespace V1_0
-}  // namespace vibrator
-}  // namespace hardware
-}  // namespace android
diff --git a/vibrator/1.0/default/Vibrator.h b/vibrator/1.0/default/Vibrator.h
deleted file mode 100644
index bea6ea8f3a..0000000000
--- a/vibrator/1.0/default/Vibrator.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_HARDWARE_VIBRATOR_V1_0_VIBRATOR_H
-#define ANDROID_HARDWARE_VIBRATOR_V1_0_VIBRATOR_H
-
-#include <android/hardware/vibrator/1.0/IVibrator.h>
-#include <hidl/Status.h>
-
-#include <hidl/MQDescriptor.h>
-namespace android {
-namespace hardware {
-namespace vibrator {
-namespace V1_0 {
-namespace implementation {
-
-struct Vibrator : public IVibrator {
-  Vibrator(vibrator_device_t *device);
-
-  // Methods from ::android::hardware::vibrator::V1_0::IVibrator follow.
-  Return<Status> on(uint32_t timeoutMs)  override;
-  Return<Status> off()  override;
-  Return<bool> supportsAmplitudeControl() override;
-  Return<Status> setAmplitude(uint8_t amplitude) override;
-  Return<void> perform(Effect effect, EffectStrength strength, perform_cb _hidl_cb) override;
-
-private:
-  vibrator_device_t    *mDevice;
-};
-
-extern "C" IVibrator* HIDL_FETCH_IVibrator(const char* name);
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace vibrator
-}  // namespace hardware
-}  // namespace android
-
-#endif  // ANDROID_HARDWARE_VIBRATOR_V1_0_VIBRATOR_H
diff --git a/vibrator/1.0/default/android.hardware.vibrator@1.0-service.rc b/vibrator/1.0/default/android.hardware.vibrator@1.0-service.rc
deleted file mode 100644
index 1bd5c1013c..0000000000
--- a/vibrator/1.0/default/android.hardware.vibrator@1.0-service.rc
+++ /dev/null
@@ -1,5 +0,0 @@
-service vendor.vibrator-1-0 /vendor/bin/hw/android.hardware.vibrator@1.0-service
-    interface android.hardware.vibrator@1.0::IVibrator default
-    class hal
-    user system
-    group system
diff --git a/vibrator/1.0/types.hal b/vibrator/1.0/types.hal
deleted file mode 100644
index a080c07911..0000000000
--- a/vibrator/1.0/types.hal
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vibrator@1.0;
-
-enum Status : uint32_t {
-    OK,
-    UNKNOWN_ERROR,
-    BAD_VALUE,
-    UNSUPPORTED_OPERATION
-};
-
-@export
-enum Effect : uint32_t {
-    /**
-     * A single click effect.
-     *
-     * This effect should produce a sharp, crisp click sensation.
-     */
-    CLICK,
-    /**
-     * A double click effect.
-     *
-     * This effect should produce two sequential sharp, crisp click sensations with a minimal
-     * amount of time between them.
-     */
-    DOUBLE_CLICK
-};
-
-@export
-enum EffectStrength : uint8_t {
-    LIGHT,
-    MEDIUM,
-    STRONG
-};
diff --git a/vibrator/1.0/vts/functional/Android.bp b/vibrator/1.0/vts/functional/Android.bp
deleted file mode 100644
index c62dc4297f..0000000000
--- a/vibrator/1.0/vts/functional/Android.bp
+++ /dev/null
@@ -1,33 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_haptics_framework",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalVibratorV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["VtsHalVibratorV1_0TargetTest.cpp"],
-    static_libs: ["android.hardware.vibrator@1.0"],
-    test_suites: ["general-tests", "vts"],
-}
diff --git a/vibrator/1.0/vts/functional/VtsHalVibratorV1_0TargetTest.cpp b/vibrator/1.0/vts/functional/VtsHalVibratorV1_0TargetTest.cpp
deleted file mode 100644
index 863bfae6de..0000000000
--- a/vibrator/1.0/vts/functional/VtsHalVibratorV1_0TargetTest.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "vibrator_hidl_hal_test"
-
-#include <android-base/logging.h>
-#include <android/hardware/vibrator/1.0/IVibrator.h>
-#include <android/hardware/vibrator/1.0/types.h>
-#include <unistd.h>
-
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-using ::android::sp;
-using ::android::hardware::hidl_enum_range;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::vibrator::V1_0::Effect;
-using ::android::hardware::vibrator::V1_0::EffectStrength;
-using ::android::hardware::vibrator::V1_0::IVibrator;
-using ::android::hardware::vibrator::V1_0::Status;
-
-#define EXPECT_OK(ret) EXPECT_TRUE((ret).isOk())
-
-// The main test class for VIBRATOR HIDL HAL.
-class VibratorHidlTest : public ::testing::TestWithParam<std::string> {
- public:
-  virtual void SetUp() override {
-    vibrator = IVibrator::getService(GetParam());
-    ASSERT_NE(vibrator, nullptr);
-  }
-
-  virtual void TearDown() override {}
-
-  sp<IVibrator> vibrator;
-};
-
-static void validatePerformEffect(Status status, uint32_t lengthMs) {
-  ASSERT_TRUE(status == Status::OK || status == Status::UNSUPPORTED_OPERATION);
-  if (status == Status::OK) {
-      ASSERT_GT(lengthMs, static_cast<uint32_t>(0));
-  } else {
-      ASSERT_EQ(lengthMs, static_cast<uint32_t>(0));
-  }
-}
-
-static void validatePerformEffectBadInput(Status status, uint32_t lengthMs) {
-    ASSERT_EQ(Status::UNSUPPORTED_OPERATION, status);
-    ASSERT_EQ(static_cast<uint32_t>(0), lengthMs)
-            << "Effects that return UNSUPPORTED_OPERATION must have a duration of zero";
-}
-
-TEST_P(VibratorHidlTest, OnThenOffBeforeTimeout) {
-  EXPECT_EQ(Status::OK, vibrator->on(2000));
-  sleep(1);
-  EXPECT_EQ(Status::OK, vibrator->off());
-}
-
-TEST_P(VibratorHidlTest, PerformEffect) {
-  vibrator->perform(Effect::CLICK, EffectStrength::MEDIUM, validatePerformEffect);
-  vibrator->perform(Effect::DOUBLE_CLICK, EffectStrength::LIGHT, validatePerformEffect);
-}
-
-/*
- * Test to make sure effect values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest, PerformEffect_BadEffects_AboveValidRange) {
-    Effect effect = *std::prev(hidl_enum_range<Effect>().end());
-    Effect badEffect = static_cast<Effect>(static_cast<int32_t>(effect) + 1);
-    EXPECT_OK(vibrator->perform(badEffect, EffectStrength::LIGHT, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure effect values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest, PerformEffect_BadEffects_BelowValidRange) {
-    Effect effect = *hidl_enum_range<Effect>().begin();
-    Effect badEffect = static_cast<Effect>(static_cast<int32_t>(effect) - 1);
-    EXPECT_OK(vibrator->perform(badEffect, EffectStrength::LIGHT, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure strength values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest, PerformEffect_BadStrength_AboveValidRange) {
-    EffectStrength strength = *std::prev(hidl_enum_range<EffectStrength>().end());
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) + 1);
-    EXPECT_OK(vibrator->perform(Effect::CLICK, badStrength, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure strength values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest, PerformEffect_BadStrength_BelowValidRange) {
-    EffectStrength strength = *hidl_enum_range<EffectStrength>().begin();
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) - 1);
-    EXPECT_OK(vibrator->perform(Effect::CLICK, badStrength, validatePerformEffectBadInput));
-}
-
-TEST_P(VibratorHidlTest, ChangeVibrationalAmplitude) {
-  if (vibrator->supportsAmplitudeControl()) {
-    EXPECT_EQ(Status::OK, vibrator->setAmplitude(1));
-    EXPECT_EQ(Status::OK, vibrator->on(2000));
-    EXPECT_EQ(Status::OK, vibrator->setAmplitude(128));
-    sleep(1);
-    EXPECT_EQ(Status::OK, vibrator->setAmplitude(255));
-    sleep(1);
-  }
-}
-
-TEST_P(VibratorHidlTest, AmplitudeOutsideRangeFails) {
-  if (vibrator->supportsAmplitudeControl()) {
-    EXPECT_EQ(Status::BAD_VALUE, vibrator->setAmplitude(0));
-  }
-}
-
-TEST_P(VibratorHidlTest, SetAmplitudeReturnUnsupportedOperationIfNotSupported) {
-  if (!vibrator->supportsAmplitudeControl()) {
-    EXPECT_EQ(Status::UNSUPPORTED_OPERATION, vibrator->setAmplitude(1));
-  }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(VibratorHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, VibratorHidlTest,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IVibrator::descriptor)),
-        android::hardware::PrintInstanceNameToString);
diff --git a/vibrator/1.1/Android.bp b/vibrator/1.1/Android.bp
deleted file mode 100644
index 357c1f0c66..0000000000
--- a/vibrator/1.1/Android.bp
+++ /dev/null
@@ -1,25 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.vibrator@1.1",
-    root: "android.hardware",
-    srcs: [
-        "types.hal",
-        "IVibrator.hal",
-    ],
-    interfaces: [
-        "android.hardware.vibrator@1.0",
-        "android.hidl.base@1.0",
-    ],
-    gen_java: true,
-    gen_java_constants: true,
-}
diff --git a/vibrator/1.1/IVibrator.hal b/vibrator/1.1/IVibrator.hal
deleted file mode 100644
index 9a2f465cda..0000000000
--- a/vibrator/1.1/IVibrator.hal
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vibrator@1.1;
-
-import @1.0::EffectStrength;
-import @1.0::IVibrator;
-import @1.0::Status;
-
-interface IVibrator extends @1.0::IVibrator {
-  /**
-   * Fire off a predefined haptic event.
-   *
-   * @param event The type of haptic event to trigger.
-   * @return status Whether the effect was successfully performed or not. Must
-   *                return Status::UNSUPPORTED_OPERATION is the effect is not
-   *                supported.
-   * @return lengthMs The length of time the event is expected to take in
-   *                  milliseconds. This doesn't need to be perfectly accurate,
-   *                  but should be a reasonable approximation. Should be a
-   *                  positive, non-zero value if the returned status is
-   *                  Status::OK, and set to 0 otherwise.
-   */
-  perform_1_1(Effect_1_1 effect, EffectStrength strength)
-          generates (Status status, uint32_t lengthMs);
-};
diff --git a/vibrator/1.1/vts/functional/Android.bp b/vibrator/1.1/vts/functional/Android.bp
deleted file mode 100644
index c7dadc5f38..0000000000
--- a/vibrator/1.1/vts/functional/Android.bp
+++ /dev/null
@@ -1,36 +0,0 @@
-//
-// Copyright (C) 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_haptics_framework",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalVibratorV1_1TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["VtsHalVibratorV1_1TargetTest.cpp"],
-    static_libs: [
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-    ],
-    test_suites: ["general-tests", "vts"],
-}
diff --git a/vibrator/1.1/vts/functional/VtsHalVibratorV1_1TargetTest.cpp b/vibrator/1.1/vts/functional/VtsHalVibratorV1_1TargetTest.cpp
deleted file mode 100644
index e7ec496d41..0000000000
--- a/vibrator/1.1/vts/functional/VtsHalVibratorV1_1TargetTest.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "vibrator_hidl_hal_test"
-
-#include <android-base/logging.h>
-#include <android/hardware/vibrator/1.1/IVibrator.h>
-#include <android/hardware/vibrator/1.1/types.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <unistd.h>
-
-using ::android::sp;
-using ::android::hardware::hidl_enum_range;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::vibrator::V1_0::EffectStrength;
-using ::android::hardware::vibrator::V1_0::Status;
-using ::android::hardware::vibrator::V1_1::Effect_1_1;
-using ::android::hardware::vibrator::V1_1::IVibrator;
-
-#define EXPECT_OK(ret) EXPECT_TRUE((ret).isOk())
-
-// The main test class for VIBRATOR HIDL HAL 1.1.
-class VibratorHidlTest_1_1 : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        vibrator = IVibrator::getService(GetParam());
-        ASSERT_NE(vibrator, nullptr);
-    }
-
-    virtual void TearDown() override {}
-
-    sp<IVibrator> vibrator;
-};
-
-static void validatePerformEffect(Status status, uint32_t lengthMs) {
-    ASSERT_TRUE(status == Status::OK || status == Status::UNSUPPORTED_OPERATION);
-    if (status == Status::OK) {
-        ASSERT_GT(lengthMs, static_cast<uint32_t>(0))
-            << "Effects that return OK must return a non-zero duration";
-    } else {
-        ASSERT_EQ(lengthMs, static_cast<uint32_t>(0))
-            << "Effects that return UNSUPPORTED_OPERATION must have a duration of zero";
-    }
-}
-
-static void validatePerformEffectBadInput(Status status, uint32_t lengthMs) {
-    ASSERT_EQ(Status::UNSUPPORTED_OPERATION, status);
-    ASSERT_EQ(static_cast<uint32_t>(0), lengthMs)
-            << "Effects that return UNSUPPORTED_OPERATION must have a duration of zero";
-}
-
-TEST_P(VibratorHidlTest_1_1, PerformEffect_1_1) {
-    vibrator->perform_1_1(Effect_1_1::CLICK, EffectStrength::MEDIUM, validatePerformEffect);
-    vibrator->perform_1_1(Effect_1_1::TICK, EffectStrength::STRONG, validatePerformEffect);
-}
-
-/*
- * Test to make sure effect values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_1, PerformEffect_1_1_BadEffects_AboveValidRange) {
-    Effect_1_1 effect = *std::prev(hidl_enum_range<Effect_1_1>().end());
-    Effect_1_1 badEffect = static_cast<Effect_1_1>(static_cast<int32_t>(effect) + 1);
-    EXPECT_OK(
-            vibrator->perform_1_1(badEffect, EffectStrength::LIGHT, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure effect values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_1, PerformEffect_1_1_BadEffects_BelowValidRange) {
-    Effect_1_1 effect = *hidl_enum_range<Effect_1_1>().begin();
-    Effect_1_1 badEffect = static_cast<Effect_1_1>(static_cast<int32_t>(effect) - 1);
-    EXPECT_OK(
-            vibrator->perform_1_1(badEffect, EffectStrength::LIGHT, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure strength values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_1, PerformEffect_1_1_BadStrength_AboveValidRange) {
-    EffectStrength strength = *std::prev(hidl_enum_range<EffectStrength>().end());
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) + 1);
-    EXPECT_OK(vibrator->perform_1_1(Effect_1_1::CLICK, badStrength, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure strength values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_1, PerformEffect_1_1_BadStrength_BelowValidRange) {
-    EffectStrength strength = *hidl_enum_range<EffectStrength>().begin();
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) - 1);
-    EXPECT_OK(vibrator->perform_1_1(Effect_1_1::CLICK, badStrength, validatePerformEffectBadInput));
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(VibratorHidlTest_1_1);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, VibratorHidlTest_1_1,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IVibrator::descriptor)),
-        android::hardware::PrintInstanceNameToString);
diff --git a/vibrator/1.2/Android.bp b/vibrator/1.2/Android.bp
deleted file mode 100644
index 42f97d4351..0000000000
--- a/vibrator/1.2/Android.bp
+++ /dev/null
@@ -1,25 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.vibrator@1.2",
-    root: "android.hardware",
-    srcs: [
-        "types.hal",
-        "IVibrator.hal",
-    ],
-    interfaces: [
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-        "android.hidl.base@1.0",
-    ],
-    gen_java: true,
-}
diff --git a/vibrator/1.2/IVibrator.hal b/vibrator/1.2/IVibrator.hal
deleted file mode 100644
index 7244da1b42..0000000000
--- a/vibrator/1.2/IVibrator.hal
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vibrator@1.2;
-
-import @1.0::EffectStrength;
-import @1.0::Status;
-import @1.1::IVibrator;
-
-interface IVibrator extends @1.1::IVibrator {
-  /**
-   * Fire off a predefined haptic event.
-   *
-   * @param event The type of haptic event to trigger.
-   * @return status Whether the effect was successfully performed or not. Must
-   *     return Status::UNSUPPORTED_OPERATION is the effect is not supported.
-   * @return lengthMs The length of time the event is expected to take in
-   *     milliseconds. This doesn't need to be perfectly accurate, but should be a reasonable
-   *     approximation. Should be a positive, non-zero value if the returned status is Status::OK,
-   *     and set to 0 otherwise.
-   */
-  perform_1_2(Effect effect, EffectStrength strength)
-          generates (Status status, uint32_t lengthMs);
-};
diff --git a/vibrator/1.2/types.hal b/vibrator/1.2/types.hal
deleted file mode 100644
index 7604f2cea0..0000000000
--- a/vibrator/1.2/types.hal
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vibrator@1.2;
-
-import @1.1::Effect_1_1;
-
-// Note that while the previous type had a version suffix, this type does not. This is because the
-// versions are already present in the namespace and thus don't need to also be embedded in the
-// name of the type.
-enum Effect : @1.1::Effect_1_1 {
-     /**
-      * A thud effect.
-      *
-      * This effect should solid feeling bump, like the depression of a heavy mechanical button.
-      */
-     THUD,
-     /**
-      * A pop effect.
-      *
-      * A short, quick burst effect.
-      */
-     POP,
-
-     /**
-      * A heavy click effect.
-      *
-      * This should produce a sharp striking sensation, like a click but stronger.
-      */
-     HEAVY_CLICK,
-
-     /**
-      * Ringtone patterns. They may correspond with the device's ringtone audio, or may just be a
-      * pattern that can be played as a ringtone with any audio, depending on the device.
-      */
-     RINGTONE_1,
-     RINGTONE_2,
-     RINGTONE_3,
-     RINGTONE_4,
-     RINGTONE_5,
-     RINGTONE_6,
-     RINGTONE_7,
-     RINGTONE_8,
-     RINGTONE_9,
-     RINGTONE_10,
-     RINGTONE_11,
-     RINGTONE_12,
-     RINGTONE_13,
-     RINGTONE_14,
-     RINGTONE_15,
-};
diff --git a/vibrator/1.2/vts/functional/Android.bp b/vibrator/1.2/vts/functional/Android.bp
deleted file mode 100644
index 4d5de1fecb..0000000000
--- a/vibrator/1.2/vts/functional/Android.bp
+++ /dev/null
@@ -1,37 +0,0 @@
-//
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_haptics_framework",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalVibratorV1_2TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["VtsHalVibratorV1_2TargetTest.cpp"],
-    static_libs: [
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-        "android.hardware.vibrator@1.2",
-    ],
-    test_suites: ["general-tests", "vts"],
-}
diff --git a/vibrator/1.2/vts/functional/VtsHalVibratorV1_2TargetTest.cpp b/vibrator/1.2/vts/functional/VtsHalVibratorV1_2TargetTest.cpp
deleted file mode 100644
index b96e2690cd..0000000000
--- a/vibrator/1.2/vts/functional/VtsHalVibratorV1_2TargetTest.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "vibrator_hidl_hal_test"
-
-#include <android-base/logging.h>
-#include <android/hardware/vibrator/1.0/types.h>
-#include <android/hardware/vibrator/1.2/IVibrator.h>
-#include <android/hardware/vibrator/1.2/types.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <unistd.h>
-
-using ::android::hardware::vibrator::V1_0::Status;
-using ::android::hardware::vibrator::V1_0::EffectStrength;
-using ::android::hardware::vibrator::V1_2::Effect;
-using ::android::hardware::vibrator::V1_2::IVibrator;
-using ::android::hardware::hidl_enum_range;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::sp;
-
-#define EXPECT_OK(ret) ASSERT_TRUE((ret).isOk())
-
-// The main test class for VIBRATOR HIDL HAL 1.2.
-class VibratorHidlTest_1_2 : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        vibrator = IVibrator::getService(GetParam());
-        ASSERT_NE(vibrator, nullptr);
-    }
-
-    virtual void TearDown() override {}
-
-    sp<IVibrator> vibrator;
-};
-
-static void validatePerformEffect(Status status, uint32_t lengthMs) {
-    ASSERT_TRUE(status == Status::OK || status == Status::UNSUPPORTED_OPERATION);
-    if (status == Status::OK) {
-        ASSERT_LT(static_cast<uint32_t>(0), lengthMs)
-            << "Effects that return OK must return a positive duration";
-    } else {
-        ASSERT_EQ(static_cast<uint32_t>(0), lengthMs)
-            << "Effects that return UNSUPPORTED_OPERATION must have a duration of zero";
-    }
-}
-
-static void validatePerformEffectBadInput(Status status, uint32_t lengthMs) {
-    ASSERT_EQ(Status::UNSUPPORTED_OPERATION, status);
-    ASSERT_EQ(static_cast<uint32_t>(0), lengthMs)
-        << "Effects that return UNSUPPORTED_OPERATION must have a duration of zero";
-}
-
-/*
- * Test to make sure effects within the valid range return are either supported and return OK with
- * a valid duration, or are unsupported and return UNSUPPORTED_OPERATION with a duration of 0.
- */
-TEST_P(VibratorHidlTest_1_2, PerformEffect_1_2) {
-    for (const auto& effect : hidl_enum_range<Effect>()) {
-        for (const auto& strength : hidl_enum_range<EffectStrength>()) {
-            EXPECT_OK(vibrator->perform_1_2(effect, strength, validatePerformEffect));
-        }
-    }
-}
-
-/*
- * Test to make sure effect values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_2, PerformEffect_1_2_BadEffects_AboveValidRange) {
-    Effect effect = *std::prev(hidl_enum_range<Effect>().end());
-    Effect badEffect = static_cast<Effect>(static_cast<int32_t>(effect) + 1);
-    EXPECT_OK(
-        vibrator->perform_1_2(badEffect, EffectStrength::LIGHT, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure effect values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_2, PerformEffect_1_2_BadEffects_BelowValidRange) {
-    Effect effect = *hidl_enum_range<Effect>().begin();
-    Effect badEffect = static_cast<Effect>(static_cast<int32_t>(effect) - 1);
-    EXPECT_OK(
-        vibrator->perform_1_2(badEffect, EffectStrength::LIGHT, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure strength values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_2, PerformEffect_1_2_BadStrength_AboveValidRange) {
-    EffectStrength strength = *std::prev(hidl_enum_range<EffectStrength>().end());
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) + 1);
-    EXPECT_OK(vibrator->perform_1_2(Effect::THUD, badStrength, validatePerformEffectBadInput));
-}
-
-/*
- * Test to make sure strength values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_2, PerformEffect_1_2_BadStrength_BelowValidRange) {
-    EffectStrength strength = *hidl_enum_range<EffectStrength>().begin();
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) - 1);
-    EXPECT_OK(vibrator->perform_1_2(Effect::THUD, badStrength, validatePerformEffectBadInput));
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(VibratorHidlTest_1_2);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, VibratorHidlTest_1_2,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IVibrator::descriptor)),
-        android::hardware::PrintInstanceNameToString);
diff --git a/vibrator/1.3/Android.bp b/vibrator/1.3/Android.bp
deleted file mode 100644
index 124f5d1834..0000000000
--- a/vibrator/1.3/Android.bp
+++ /dev/null
@@ -1,26 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.vibrator@1.3",
-    root: "android.hardware",
-    srcs: [
-        "types.hal",
-        "IVibrator.hal",
-    ],
-    interfaces: [
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-        "android.hardware.vibrator@1.2",
-        "android.hidl.base@1.0",
-    ],
-    gen_java: true,
-}
diff --git a/vibrator/1.3/IVibrator.hal b/vibrator/1.3/IVibrator.hal
deleted file mode 100644
index 1c870ee4cd..0000000000
--- a/vibrator/1.3/IVibrator.hal
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vibrator@1.3;
-
-import @1.0::EffectStrength;
-import @1.0::Status;
-import @1.2::IVibrator;
-
-interface IVibrator extends @1.2::IVibrator {
-  /**
-   * Returns whether the vibrator supports control through an alternate interface.
-   */
-  supportsExternalControl() generates (bool supports);
-
-  /**
-   * Enables/disables control override of vibrator to audio.
-   *
-   * When this API is set, the vibrator control should be ceded to audio system
-   * for haptic audio. While this is enabled, issuing of other commands to control
-   * the vibrator is unsupported and the resulting behavior is undefined. Amplitude
-   * control may or may not be supported and is reflected in the return value of
-   * supportsAmplitudeControl() while this is enabled. When this is disabled, the
-   * vibrator should resume to an off state.
-   *
-   * @param enabled Whether external control should be enabled or disabled.
-   * @return status Whether the command was successful or not. Must return
-   *                Status::UNSUPPORTED_OPERATION if external control is
-   *                not supported by the device.
-   */
-  setExternalControl(bool enabled) generates (Status status);
-
-  /**
-   * Fire off a predefined haptic event.
-   *
-   * @param event The type of haptic event to trigger.
-   * @return status Whether the effect was successfully performed or not. Must
-   *     return Status::UNSUPPORTED_OPERATION if the effect is not supported.
-   * @return lengthMs The length of time the event is expected to take in
-   *     milliseconds. This doesn't need to be perfectly accurate, but should be a reasonable
-   *     approximation. Should be a positive, non-zero value if the returned status is Status::OK,
-   *     and set to 0 otherwise.
-   */
-  perform_1_3(Effect effect, EffectStrength strength)
-          generates (Status status, uint32_t lengthMs);
-};
diff --git a/vibrator/1.3/example/Android.bp b/vibrator/1.3/example/Android.bp
deleted file mode 100644
index 7e9bf8f1f5..0000000000
--- a/vibrator/1.3/example/Android.bp
+++ /dev/null
@@ -1,42 +0,0 @@
-//
-// Copyright (C) 2019 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_binary {
-    name: "android.hardware.vibrator@1.3-service.example",
-    vendor: true,
-    relative_install_path: "hw",
-    init_rc: ["android.hardware.vibrator@1.3-service.example.rc"],
-    vintf_fragments: ["android.hardware.vibrator@1.3-service.example.xml"],
-    srcs: ["service.cpp", "Vibrator.cpp"],
-    cflags: ["-Wall", "-Werror"],
-    shared_libs: [
-        "libhidlbase",
-        "liblog",
-        "libutils",
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-        "android.hardware.vibrator@1.2",
-        "android.hardware.vibrator@1.3",
-    ],
-}
diff --git a/vibrator/1.3/example/Vibrator.cpp b/vibrator/1.3/example/Vibrator.cpp
deleted file mode 100644
index b529437108..0000000000
--- a/vibrator/1.3/example/Vibrator.cpp
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "VibratorService"
-
-#include <log/log.h>
-
-#include "Vibrator.h"
-
-namespace android {
-namespace hardware {
-namespace vibrator {
-namespace V1_3 {
-namespace implementation {
-
-static constexpr uint32_t MS_PER_S = 1000;
-static constexpr uint32_t NS_PER_MS = 1000000;
-
-Vibrator::Vibrator() {
-    sigevent se{};
-    se.sigev_notify = SIGEV_THREAD;
-    se.sigev_value.sival_ptr = this;
-    se.sigev_notify_function = timerCallback;
-    se.sigev_notify_attributes = nullptr;
-
-    if (timer_create(CLOCK_REALTIME, &se, &mTimer) < 0) {
-        ALOGE("Can not create timer!%s", strerror(errno));
-    }
-}
-
-// Methods from ::android::hardware::vibrator::V1_0::IVibrator follow.
-
-Return<Status> Vibrator::on(uint32_t timeoutMs) {
-    return activate(timeoutMs);
-}
-
-Return<Status> Vibrator::off() {
-    return activate(0);
-}
-
-Return<bool> Vibrator::supportsAmplitudeControl() {
-    return true;
-}
-
-Return<Status> Vibrator::setAmplitude(uint8_t amplitude) {
-    if (!amplitude) {
-        return Status::BAD_VALUE;
-    }
-    ALOGI("Amplitude: %u -> %u\n", mAmplitude, amplitude);
-    mAmplitude = amplitude;
-    return Status::OK;
-}
-
-Return<void> Vibrator::perform(V1_0::Effect effect, EffectStrength strength, perform_cb _hidl_cb) {
-    return perform<decltype(effect)>(effect, strength, _hidl_cb);
-}
-
-// Methods from ::android::hardware::vibrator::V1_1::IVibrator follow.
-
-Return<void> Vibrator::perform_1_1(V1_1::Effect_1_1 effect, EffectStrength strength,
-                                   perform_cb _hidl_cb) {
-    return perform<decltype(effect)>(effect, strength, _hidl_cb);
-}
-
-// Methods from ::android::hardware::vibrator::V1_2::IVibrator follow.
-
-Return<void> Vibrator::perform_1_2(V1_2::Effect effect, EffectStrength strength,
-                                   perform_cb _hidl_cb) {
-    return perform<decltype(effect)>(effect, strength, _hidl_cb);
-}
-
-// Methods from ::android::hardware::vibrator::V1_3::IVibrator follow.
-
-Return<bool> Vibrator::supportsExternalControl() {
-    return true;
-}
-
-Return<Status> Vibrator::setExternalControl(bool enabled) {
-    if (mEnabled) {
-        ALOGW("Setting external control while the vibrator is enabled is unsupported!");
-        return Status::UNSUPPORTED_OPERATION;
-    } else {
-        ALOGI("ExternalControl: %s -> %s\n", mExternalControl ? "true" : "false",
-              enabled ? "true" : "false");
-        mExternalControl = enabled;
-        return Status::OK;
-    }
-}
-
-Return<void> Vibrator::perform_1_3(Effect effect, EffectStrength strength, perform_cb _hidl_cb) {
-    return perform<decltype(effect)>(effect, strength, _hidl_cb);
-}
-
-// Private methods follow.
-
-Return<void> Vibrator::perform(Effect effect, EffectStrength strength, perform_cb _hidl_cb) {
-    uint8_t amplitude;
-    uint32_t ms;
-    Status status = Status::OK;
-
-    ALOGI("Perform: Effect %s\n", effectToName(effect).c_str());
-
-    amplitude = strengthToAmplitude(strength, &status);
-    if (status != Status::OK) {
-        _hidl_cb(status, 0);
-        return Void();
-    }
-    setAmplitude(amplitude);
-
-    ms = effectToMs(effect, &status);
-    if (status != Status::OK) {
-        _hidl_cb(status, 0);
-        return Void();
-    }
-    status = activate(ms);
-
-    _hidl_cb(status, ms);
-
-    return Void();
-}
-
-template <typename T>
-Return<void> Vibrator::perform(T effect, EffectStrength strength, perform_cb _hidl_cb) {
-    auto validRange = hidl_enum_range<T>();
-    if (effect < *validRange.begin() || effect > *std::prev(validRange.end())) {
-        _hidl_cb(Status::UNSUPPORTED_OPERATION, 0);
-        return Void();
-    }
-    return perform(static_cast<Effect>(effect), strength, _hidl_cb);
-}
-
-Status Vibrator::enable(bool enabled) {
-    if (mExternalControl) {
-        ALOGW("Enabling/disabling while the vibrator is externally controlled is unsupported!");
-        return Status::UNSUPPORTED_OPERATION;
-    } else {
-        ALOGI("Enabled: %s -> %s\n", mEnabled ? "true" : "false", enabled ? "true" : "false");
-        mEnabled = enabled;
-        return Status::OK;
-    }
-}
-
-Status Vibrator::activate(uint32_t ms) {
-    std::lock_guard<std::mutex> lock{mMutex};
-    Status status = Status::OK;
-
-    if (ms > 0) {
-        status = enable(true);
-        if (status != Status::OK) {
-            return status;
-        }
-    }
-
-    itimerspec ts{};
-    ts.it_value.tv_sec = ms / MS_PER_S;
-    ts.it_value.tv_nsec = ms % MS_PER_S * NS_PER_MS;
-
-    if (timer_settime(mTimer, 0, &ts, nullptr) < 0) {
-        ALOGE("Can not set timer!");
-        status = Status::UNKNOWN_ERROR;
-    }
-
-    if ((status != Status::OK) || !ms) {
-        Status _status;
-
-        _status = enable(false);
-
-        if (status == Status::OK) {
-            status = _status;
-        }
-    }
-
-    return status;
-}
-
-void Vibrator::timeout() {
-    std::lock_guard<std::mutex> lock{mMutex};
-    itimerspec ts{};
-
-    if (timer_gettime(mTimer, &ts) < 0) {
-        ALOGE("Can not read timer!");
-    }
-
-    if (ts.it_value.tv_sec == 0 && ts.it_value.tv_nsec == 0) {
-        enable(false);
-    }
-}
-
-void Vibrator::timerCallback(union sigval sigval) {
-    static_cast<Vibrator*>(sigval.sival_ptr)->timeout();
-}
-
-const std::string Vibrator::effectToName(Effect effect) {
-    return toString(effect);
-}
-
-uint32_t Vibrator::effectToMs(Effect effect, Status* status) {
-    switch (effect) {
-        case Effect::CLICK:
-            return 10;
-        case Effect::DOUBLE_CLICK:
-            return 15;
-        case Effect::TICK:
-        case Effect::TEXTURE_TICK:
-            return 5;
-        case Effect::THUD:
-            return 5;
-        case Effect::POP:
-            return 5;
-        case Effect::HEAVY_CLICK:
-            return 10;
-        case Effect::RINGTONE_1:
-            return 30000;
-        case Effect::RINGTONE_2:
-            return 30000;
-        case Effect::RINGTONE_3:
-            return 30000;
-        case Effect::RINGTONE_4:
-            return 30000;
-        case Effect::RINGTONE_5:
-            return 30000;
-        case Effect::RINGTONE_6:
-            return 30000;
-        case Effect::RINGTONE_7:
-            return 30000;
-        case Effect::RINGTONE_8:
-            return 30000;
-        case Effect::RINGTONE_9:
-            return 30000;
-        case Effect::RINGTONE_10:
-            return 30000;
-        case Effect::RINGTONE_11:
-            return 30000;
-        case Effect::RINGTONE_12:
-            return 30000;
-        case Effect::RINGTONE_13:
-            return 30000;
-        case Effect::RINGTONE_14:
-            return 30000;
-        case Effect::RINGTONE_15:
-            return 30000;
-    }
-    *status = Status::UNSUPPORTED_OPERATION;
-    return 0;
-}
-
-uint8_t Vibrator::strengthToAmplitude(EffectStrength strength, Status* status) {
-    switch (strength) {
-        case EffectStrength::LIGHT:
-            return 128;
-        case EffectStrength::MEDIUM:
-            return 192;
-        case EffectStrength::STRONG:
-            return 255;
-    }
-    *status = Status::UNSUPPORTED_OPERATION;
-    return 0;
-}
-
-}  // namespace implementation
-}  // namespace V1_3
-}  // namespace vibrator
-}  // namespace hardware
-}  // namespace android
diff --git a/vibrator/1.3/example/Vibrator.h b/vibrator/1.3/example/Vibrator.h
deleted file mode 100644
index 5180774552..0000000000
--- a/vibrator/1.3/example/Vibrator.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_HARDWARE_VIBRATOR_V1_3_VIBRATOR_H
-#define ANDROID_HARDWARE_VIBRATOR_V1_3_VIBRATOR_H
-
-#include <android/hardware/vibrator/1.3/IVibrator.h>
-#include <hidl/Status.h>
-
-namespace android {
-namespace hardware {
-namespace vibrator {
-namespace V1_3 {
-namespace implementation {
-
-using android::hardware::vibrator::V1_0::EffectStrength;
-using android::hardware::vibrator::V1_0::Status;
-
-class Vibrator : public IVibrator {
-  public:
-    Vibrator();
-
-    // Methods from ::android::hardware::vibrator::V1_0::IVibrator follow.
-    Return<Status> on(uint32_t timeoutMs) override;
-    Return<Status> off() override;
-    Return<bool> supportsAmplitudeControl() override;
-    Return<Status> setAmplitude(uint8_t amplitude) override;
-    Return<void> perform(V1_0::Effect effect, EffectStrength strength,
-                         perform_cb _hidl_cb) override;
-
-    // Methods from ::android::hardware::vibrator::V1_1::IVibrator follow.
-    Return<void> perform_1_1(V1_1::Effect_1_1 effect, EffectStrength strength,
-                             perform_cb _hidl_cb) override;
-
-    // Methods from ::android::hardware::vibrator::V1_2::IVibrator follow.
-    Return<void> perform_1_2(V1_2::Effect effect, EffectStrength strength,
-                             perform_cb _hidl_cb) override;
-
-    // Methods from ::android::hardware::vibrator::V1_3::IVibrator follow.
-    Return<bool> supportsExternalControl() override;
-    Return<Status> setExternalControl(bool enabled) override;
-    Return<void> perform_1_3(Effect effect, EffectStrength strength, perform_cb _hidl_cb) override;
-
-  private:
-    Return<void> perform(Effect effect, EffectStrength strength, perform_cb _hidl_cb);
-    template <typename T>
-    Return<void> perform(T effect, EffectStrength strength, perform_cb _hidl_cb);
-    Status enable(bool enabled);
-    Status activate(uint32_t ms);
-    void timeout();
-
-    static void timerCallback(union sigval sigval);
-    static const std::string effectToName(Effect effect);
-    static uint32_t effectToMs(Effect effect, Status* status);
-    static uint8_t strengthToAmplitude(EffectStrength strength, Status* status);
-
-  private:
-    bool mEnabled{false};
-    uint8_t mAmplitude{UINT8_MAX};
-    bool mExternalControl{false};
-    std::mutex mMutex;
-    timer_t mTimer{nullptr};
-};
-}  // namespace implementation
-}  // namespace V1_3
-}  // namespace vibrator
-}  // namespace hardware
-}  // namespace android
-
-#endif  // ANDROID_HARDWARE_VIBRATOR_V1_3_VIBRATOR_H
diff --git a/vibrator/1.3/example/android.hardware.vibrator@1.3-service.example.rc b/vibrator/1.3/example/android.hardware.vibrator@1.3-service.example.rc
deleted file mode 100644
index ed7a562cfc..0000000000
--- a/vibrator/1.3/example/android.hardware.vibrator@1.3-service.example.rc
+++ /dev/null
@@ -1,4 +0,0 @@
-service vendor.vibrator-1-3 /vendor/bin/hw/android.hardware.vibrator@1.3-service.example
-    class hal
-    user system
-    group system
diff --git a/vibrator/1.3/example/android.hardware.vibrator@1.3-service.example.xml b/vibrator/1.3/example/android.hardware.vibrator@1.3-service.example.xml
deleted file mode 100644
index 172aa2178c..0000000000
--- a/vibrator/1.3/example/android.hardware.vibrator@1.3-service.example.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<manifest version="1.0" type="device">
-    <hal format="hidl">
-        <name>android.hardware.vibrator</name>
-        <transport>hwbinder</transport>
-        <version>1.3</version>
-        <interface>
-            <name>IVibrator</name>
-            <instance>default</instance>
-        </interface>
-    </hal>
-</manifest>
diff --git a/vibrator/1.3/example/service.cpp b/vibrator/1.3/example/service.cpp
deleted file mode 100644
index 449996e280..0000000000
--- a/vibrator/1.3/example/service.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#define LOG_TAG "android.hardware.vibrator@1.3-service.example"
-
-#include <android/hardware/vibrator/1.3/IVibrator.h>
-#include <hidl/HidlTransportSupport.h>
-
-#include "Vibrator.h"
-
-using android::hardware::configureRpcThreadpool;
-using android::hardware::joinRpcThreadpool;
-using android::hardware::vibrator::V1_3::IVibrator;
-using android::hardware::vibrator::V1_3::implementation::Vibrator;
-using namespace android;
-
-status_t registerVibratorService() {
-    sp<IVibrator> vibrator = new Vibrator();
-
-    return vibrator->registerAsService();
-}
-
-int main() {
-    configureRpcThreadpool(1, true);
-    status_t status = registerVibratorService();
-
-    if (status != OK) {
-        return status;
-    }
-
-    joinRpcThreadpool();
-
-    return 1;
-}
diff --git a/vibrator/1.3/vts/functional/Android.bp b/vibrator/1.3/vts/functional/Android.bp
deleted file mode 100644
index 3221fa2f08..0000000000
--- a/vibrator/1.3/vts/functional/Android.bp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_haptics_framework",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalVibratorV1_3TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["VtsHalVibratorV1_3TargetTest.cpp"],
-    static_libs: [
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-        "android.hardware.vibrator@1.2",
-        "android.hardware.vibrator@1.3",
-    ],
-    test_suites: ["general-tests", "vts"],
-}
diff --git a/vibrator/1.3/vts/functional/VtsHalVibratorV1_3TargetTest.cpp b/vibrator/1.3/vts/functional/VtsHalVibratorV1_3TargetTest.cpp
deleted file mode 100644
index 84a6af03d3..0000000000
--- a/vibrator/1.3/vts/functional/VtsHalVibratorV1_3TargetTest.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "vibrator_hidl_hal_test"
-
-#include <android-base/logging.h>
-#include <android/hardware/vibrator/1.0/types.h>
-#include <android/hardware/vibrator/1.3/IVibrator.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <unistd.h>
-
-using ::android::sp;
-using ::android::hardware::hidl_enum_range;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::vibrator::V1_0::EffectStrength;
-using ::android::hardware::vibrator::V1_0::Status;
-using ::android::hardware::vibrator::V1_3::Effect;
-using ::android::hardware::vibrator::V1_3::IVibrator;
-
-#define EXPECT_OK(ret) ASSERT_TRUE((ret).isOk())
-
-// The main test class for VIBRATOR HIDL HAL 1.3.
-class VibratorHidlTest_1_3 : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        vibrator = IVibrator::getService(GetParam());
-        ASSERT_NE(vibrator, nullptr);
-    }
-
-    virtual void TearDown() override {}
-
-    sp<IVibrator> vibrator;
-};
-
-TEST_P(VibratorHidlTest_1_3, ChangeVibrationalExternalControl) {
-    if (vibrator->supportsExternalControl()) {
-        EXPECT_EQ(Status::OK, vibrator->setExternalControl(true));
-        sleep(1);
-        EXPECT_EQ(Status::OK, vibrator->setExternalControl(false));
-        sleep(1);
-    }
-}
-
-TEST_P(VibratorHidlTest_1_3, SetExternalControlReturnUnsupportedOperationIfNotSupported) {
-    if (!vibrator->supportsExternalControl()) {
-        EXPECT_EQ(Status::UNSUPPORTED_OPERATION, vibrator->setExternalControl(true));
-    }
-}
-
-static void validatePerformEffectUnsupportedOperation(Status status, uint32_t lengthMs) {
-    ASSERT_EQ(Status::UNSUPPORTED_OPERATION, status);
-    ASSERT_EQ(static_cast<uint32_t>(0), lengthMs)
-            << "Effects that return UNSUPPORTED_OPERATION must have a duration of zero";
-}
-
-static void validatePerformEffect(Status status, uint32_t lengthMs) {
-    ASSERT_TRUE(status == Status::OK || status == Status::UNSUPPORTED_OPERATION);
-    if (status == Status::OK) {
-        ASSERT_LT(static_cast<uint32_t>(0), lengthMs)
-                << "Effects that return OK must return a positive duration";
-    } else {
-        validatePerformEffectUnsupportedOperation(status, lengthMs);
-    }
-}
-
-/*
- * Test to make sure effects within the valid range return are either supported and return OK with
- * a valid duration, or are unsupported and return UNSUPPORTED_OPERATION with a duration of 0.
- */
-TEST_P(VibratorHidlTest_1_3, PerformEffect_1_3) {
-    for (const auto& effect : hidl_enum_range<Effect>()) {
-        for (const auto& strength : hidl_enum_range<EffectStrength>()) {
-            EXPECT_OK(vibrator->perform_1_3(effect, strength, validatePerformEffect));
-        }
-    }
-}
-
-/*
- * Test to make sure effect values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_3, PerformEffect_1_3_BadEffects_AboveValidRange) {
-    Effect effect = *std::prev(hidl_enum_range<Effect>().end());
-    Effect badEffect = static_cast<Effect>(static_cast<int32_t>(effect) + 1);
-    EXPECT_OK(vibrator->perform_1_3(badEffect, EffectStrength::LIGHT,
-                                    validatePerformEffectUnsupportedOperation));
-}
-
-/*
- * Test to make sure effect values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_3, PerformEffect_1_3_BadEffects_BelowValidRange) {
-    Effect effect = *hidl_enum_range<Effect>().begin();
-    Effect badEffect = static_cast<Effect>(static_cast<int32_t>(effect) - 1);
-    EXPECT_OK(vibrator->perform_1_3(badEffect, EffectStrength::LIGHT,
-                                    validatePerformEffectUnsupportedOperation));
-}
-
-/*
- * Test to make sure strength values above the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_3, PerformEffect_1_3_BadStrength_AboveValidRange) {
-    EffectStrength strength = *std::prev(hidl_enum_range<EffectStrength>().end());
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) + 1);
-    EXPECT_OK(vibrator->perform_1_3(Effect::THUD, badStrength,
-                                    validatePerformEffectUnsupportedOperation));
-}
-
-/*
- * Test to make sure strength values below the valid range are rejected.
- */
-TEST_P(VibratorHidlTest_1_3, PerformEffect_1_3_BadStrength_BelowValidRange) {
-    EffectStrength strength = *hidl_enum_range<EffectStrength>().begin();
-    EffectStrength badStrength = static_cast<EffectStrength>(static_cast<int32_t>(strength) - 1);
-    EXPECT_OK(vibrator->perform_1_3(Effect::THUD, badStrength,
-                                    validatePerformEffectUnsupportedOperation));
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(VibratorHidlTest_1_3);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, VibratorHidlTest_1_3,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IVibrator::descriptor)),
-        android::hardware::PrintInstanceNameToString);
diff --git a/vibrator/aidl/vts/VtsHalVibratorManagerTargetTest.cpp b/vibrator/aidl/vts/VtsHalVibratorManagerTargetTest.cpp
index 101d4f585f..a8bbf3a31f 100644
--- a/vibrator/aidl/vts/VtsHalVibratorManagerTargetTest.cpp
+++ b/vibrator/aidl/vts/VtsHalVibratorManagerTargetTest.cpp
@@ -24,7 +24,6 @@
 #include <android/binder_process.h>
 
 #include <algorithm>
-#include <cmath>
 #include <future>
 
 #include "test_utils.h"
@@ -50,7 +49,7 @@ const std::vector<CompositePrimitive> kPrimitives{ndk::enum_range<CompositePrimi
                                                   ndk::enum_range<CompositePrimitive>().end()};
 
 // Timeout to wait for vibration callback completion.
-static constexpr std::chrono::milliseconds VIBRATION_CALLBACK_TIMEOUT = 100ms;
+static constexpr std::chrono::milliseconds VIBRATION_CALLBACK_TIMEOUT = 200ms;
 
 static constexpr int32_t VIBRATION_SESSIONS_MIN_VERSION = 3;
 
@@ -140,13 +139,12 @@ TEST_P(VibratorAidl, PrepareOnNotSupported) {
     if (vibratorIds.empty()) return;
     if (!(capabilities & IVibratorManager::CAP_SYNC)) return;
     if (!(capabilities & IVibratorManager::CAP_PREPARE_ON)) {
-        int32_t durationMs = 250;
         EXPECT_OK(manager->prepareSynced(vibratorIds));
         std::shared_ptr<IVibrator> vibrator;
         for (int32_t id : vibratorIds) {
             EXPECT_OK(manager->getVibrator(id, &vibrator));
             ASSERT_NE(vibrator, nullptr);
-            EXPECT_UNKNOWN_OR_UNSUPPORTED(vibrator->on(durationMs, nullptr));
+            EXPECT_UNKNOWN_OR_UNSUPPORTED(vibrator->on(2000, nullptr));
         }
         EXPECT_OK(manager->cancelSynced());
     }
@@ -202,7 +200,6 @@ TEST_P(VibratorAidl, TriggerWithCallback) {
     auto callback = ndk::SharedRefBase::make<CompletionCallback>(
             [&completionPromise] { completionPromise.set_value(); });
     int32_t durationMs = 250;
-    std::chrono::milliseconds timeout{durationMs * 2};
 
     EXPECT_OK(manager->prepareSynced(vibratorIds));
     std::shared_ptr<IVibrator> vibrator;
@@ -212,6 +209,7 @@ TEST_P(VibratorAidl, TriggerWithCallback) {
         EXPECT_OK(vibrator->on(durationMs, nullptr));
     }
 
+    auto timeout = std::chrono::milliseconds(durationMs) + VIBRATION_CALLBACK_TIMEOUT;
     EXPECT_OK(manager->triggerSynced(callback));
     EXPECT_EQ(completionFuture.wait_for(timeout), std::future_status::ready);
     EXPECT_OK(manager->cancelSynced());
@@ -374,7 +372,6 @@ TEST_P(VibratorAidl, VibrationSessionCleared) {
     EXPECT_OK(manager->startSession(vibratorIds, sessionConfig, sessionCallback, &session));
     ASSERT_NE(session, nullptr);
 
-    int32_t durationMs = 250;
     std::vector<std::promise<void>> vibrationPromises;
     std::vector<std::future<void>> vibrationFutures;
     for (int32_t id : vibratorIds) {
@@ -386,7 +383,7 @@ TEST_P(VibratorAidl, VibrationSessionCleared) {
         vibrationFutures.push_back(vibrationPromise.get_future());
         auto vibrationCallback = ndk::SharedRefBase::make<CompletionCallback>(
                 [&vibrationPromise] { vibrationPromise.set_value(); });
-        EXPECT_OK(vibrator->on(durationMs, vibrationCallback));
+        EXPECT_OK(vibrator->on(2000, vibrationCallback));
     }
 
     // Session callback not triggered.
@@ -489,8 +486,7 @@ TEST_P(VibratorAidl, VibrationSessionWithMultipleIndependentVibrations) {
 
     EXPECT_OK(session->close());
 
-    int32_t maxDurationMs = 100 + 200 + 300;
-    auto timeout = std::chrono::milliseconds(maxDurationMs) + VIBRATION_CALLBACK_TIMEOUT;
+    auto timeout = std::chrono::milliseconds(100 + 200 + 300) + VIBRATION_CALLBACK_TIMEOUT;
     EXPECT_EQ(sessionFuture.wait_for(timeout), std::future_status::ready);
 }
 
@@ -516,7 +512,7 @@ TEST_P(VibratorAidl, VibrationSessionsIgnoresSecondSessionWhenFirstIsOngoing) {
     EXPECT_EQ(sessionFuture.wait_for(VIBRATION_CALLBACK_TIMEOUT), std::future_status::timeout);
 
     // First session still ongoing, we can still vibrate.
-    int32_t durationMs = 100;
+    int32_t durationMs = 250;
     for (int32_t id : vibratorIds) {
         std::shared_ptr<IVibrator> vibrator;
         EXPECT_OK(manager->getVibrator(id, &vibrator));
diff --git a/vibrator/aidl/vts/VtsHalVibratorTargetTest.cpp b/vibrator/aidl/vts/VtsHalVibratorTargetTest.cpp
index 03ecb1a04e..dfb7f967d3 100644
--- a/vibrator/aidl/vts/VtsHalVibratorTargetTest.cpp
+++ b/vibrator/aidl/vts/VtsHalVibratorTargetTest.cpp
@@ -87,7 +87,7 @@ const std::vector<CompositePrimitive> kInvalidPrimitives = {
 };
 
 // Timeout to wait for vibration callback completion.
-static constexpr std::chrono::milliseconds VIBRATION_CALLBACK_TIMEOUT = 100ms;
+static constexpr std::chrono::milliseconds VIBRATION_CALLBACK_TIMEOUT = 200ms;
 
 static constexpr int32_t VENDOR_EFFECTS_MIN_VERSION = 3;
 static constexpr int32_t PWLE_V2_MIN_VERSION = 3;
diff --git a/vr/1.0/Android.bp b/vr/1.0/Android.bp
deleted file mode 100644
index 27d2ea8287..0000000000
--- a/vr/1.0/Android.bp
+++ /dev/null
@@ -1,22 +0,0 @@
-// This file is autogenerated by hidl-gen -Landroidbp.
-
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-hidl_interface {
-    name: "android.hardware.vr@1.0",
-    root: "android.hardware",
-    srcs: [
-        "IVr.hal",
-    ],
-    interfaces: [
-        "android.hidl.base@1.0",
-    ],
-    gen_java: true,
-}
diff --git a/vr/1.0/IVr.hal b/vr/1.0/IVr.hal
deleted file mode 100644
index 1f996e9e67..0000000000
--- a/vr/1.0/IVr.hal
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.vr@1.0;
-
-interface IVr {
-  /**
-   * Convenience method to set up any state needed at runtime startup.  This is
-   * called once from the VrManagerService during its boot phase.
-   */
-  @callflow(next={"*"})
-  @entry
-  @exit
-  init();
-
-  /**
-   * Set the VR mode state.  Possible states of the enabled parameter are:
-   * false - VR mode is disabled, turn off all VR-specific settings.
-   * true - VR mode is enabled, turn on all VR-specific settings.
-   *
-   * This must be called whenever the the Android system enters or leaves VR
-   * mode. This will typically occur when the user switches to or from a VR
-   * application that is doing stereoscopic rendering.
-   */
-  @callflow(next={"*"})
-  @exit
-  setVrMode(bool enabled);
-};
diff --git a/vr/1.0/default/Android.bp b/vr/1.0/default/Android.bp
deleted file mode 100644
index 6e59bcf99a..0000000000
--- a/vr/1.0/default/Android.bp
+++ /dev/null
@@ -1,43 +0,0 @@
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_library_shared {
-    name: "android.hardware.vr@1.0-impl",
-    defaults: ["hidl_defaults"],
-    proprietary: true,
-    relative_install_path: "hw",
-    srcs: ["Vr.cpp"],
-    shared_libs: [
-        "liblog",
-        "libcutils",
-        "libhardware",
-        "libbase",
-        "libcutils",
-        "libutils",
-        "libhidlbase",
-        "android.hardware.vr@1.0",
-    ],
-}
-
-cc_binary {
-    relative_install_path: "hw",
-    defaults: ["hidl_defaults"],
-    proprietary: true,
-    name: "android.hardware.vr@1.0-service",
-    init_rc: ["android.hardware.vr@1.0-service.rc"],
-    srcs: ["service.cpp"],
-    shared_libs: [
-        "liblog",
-        "libdl",
-        "libutils",
-        "libhardware",
-        "libhidlbase",
-        "android.hardware.vr@1.0",
-    ],
-}
diff --git a/vr/1.0/default/Vr.cpp b/vr/1.0/default/Vr.cpp
deleted file mode 100644
index 4bba9eb5a1..0000000000
--- a/vr/1.0/default/Vr.cpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "VrService"
-
-#include <log/log.h>
-
-#include <hardware/hardware.h>
-#include <hardware/vr.h>
-
-#include "Vr.h"
-
-namespace android {
-namespace hardware {
-namespace vr {
-namespace V1_0 {
-namespace implementation {
-
-Vr::Vr(vr_module_t *device) : mDevice(device) {}
-
-// Methods from ::android::hardware::vr::V1_0::IVr follow.
-Return<void> Vr::init() {
-    mDevice->init(mDevice);
-    return Void();
-}
-
-Return<void> Vr::setVrMode(bool enabled)  {
-    mDevice->set_vr_mode(mDevice, enabled);
-    return Void();
-}
-
-IVr* HIDL_FETCH_IVr(const char * /*name*/) {
-    const hw_module_t *hw_module = NULL;
-
-    int ret = hw_get_module(VR_HARDWARE_MODULE_ID, &hw_module);
-    if (ret == 0) {
-        return new Vr(reinterpret_cast<vr_module_t*>(
-                const_cast<hw_module_t*>(hw_module)));
-    } else {
-        ALOGE("hw_get_module %s failed: %d", VR_HARDWARE_MODULE_ID, ret);
-        return nullptr;
-    }
-}
-
-} // namespace implementation
-}  // namespace V1_0
-}  // namespace vr
-}  // namespace hardware
-}  // namespace android
diff --git a/vr/1.0/default/Vr.h b/vr/1.0/default/Vr.h
deleted file mode 100644
index dd5e764549..0000000000
--- a/vr/1.0/default/Vr.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_HARDWARE_VR_V1_0_VR_H
-#define ANDROID_HARDWARE_VR_V1_0_VR_H
-
-#include <android/hardware/vr/1.0/IVr.h>
-#include <hardware/vr.h>
-#include <hidl/MQDescriptor.h>
-
-namespace android {
-namespace hardware {
-namespace vr {
-namespace V1_0 {
-namespace implementation {
-
-using ::android::hardware::vr::V1_0::IVr;
-using ::android::hardware::Return;
-
-struct Vr : public IVr {
-    Vr(vr_module_t *device);
-
-    // Methods from ::android::hardware::vr::V1_0::IVr follow.
-    Return<void> init()  override;
-    Return<void> setVrMode(bool enabled)  override;
-
-  private:
-    vr_module_t    *mDevice;
-};
-
-extern "C" IVr* HIDL_FETCH_IVr(const char* name);
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace vr
-}  // namespace hardware
-}  // namespace android
-
-#endif  // ANDROID_HARDWARE_VR_V1_0_VR_H
diff --git a/vr/1.0/default/android.hardware.vr@1.0-service.rc b/vr/1.0/default/android.hardware.vr@1.0-service.rc
deleted file mode 100644
index 5486674584..0000000000
--- a/vr/1.0/default/android.hardware.vr@1.0-service.rc
+++ /dev/null
@@ -1,5 +0,0 @@
-service vendor.vr-1-0 /vendor/bin/hw/android.hardware.vr@1.0-service
-    interface android.hardware.vr@1.0::IVr default
-    class hal
-    user system
-    group system
diff --git a/vr/1.0/vts/functional/Android.bp b/vr/1.0/vts/functional/Android.bp
deleted file mode 100644
index 267a1cccf5..0000000000
--- a/vr/1.0/vts/functional/Android.bp
+++ /dev/null
@@ -1,33 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_android_kernel",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalVrV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["VtsHalVrV1_0TargetTest.cpp"],
-    static_libs: ["android.hardware.vr@1.0"],
-    test_suites: ["general-tests", "vts"],
-}
diff --git a/vr/1.0/vts/functional/VtsHalVrV1_0TargetTest.cpp b/vr/1.0/vts/functional/VtsHalVrV1_0TargetTest.cpp
deleted file mode 100644
index 00943fd4d6..0000000000
--- a/vr/1.0/vts/functional/VtsHalVrV1_0TargetTest.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "vr_hidl_hal_test"
-#include <android-base/logging.h>
-#include <android/hardware/vr/1.0/IVr.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <log/log.h>
-
-using ::android::hardware::vr::V1_0::IVr;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::sp;
-
-// The main test class for VR HIDL HAL.
-class VrHidlTest : public ::testing::TestWithParam<std::string> {
- public:
-  void SetUp() override {
-    vr = IVr::getService(GetParam());
-    ASSERT_NE(vr, nullptr);
-  }
-
-  void TearDown() override {}
-
-  sp<IVr> vr;
-};
-
-// Sanity check that Vr::init does not crash.
-TEST_P(VrHidlTest, Init) {
-  EXPECT_TRUE(vr->init().isOk());
-}
-
-// Sanity check Vr::setVrMode is able to enable and disable VR mode.
-TEST_P(VrHidlTest, SetVrMode) {
-  EXPECT_TRUE(vr->init().isOk());
-  EXPECT_TRUE(vr->setVrMode(true).isOk());
-  EXPECT_TRUE(vr->setVrMode(false).isOk());
-}
-
-// Sanity check that Vr::init and Vr::setVrMode can be used in any order.
-TEST_P(VrHidlTest, ReInit) {
-  EXPECT_TRUE(vr->init().isOk());
-  EXPECT_TRUE(vr->setVrMode(true).isOk());
-  EXPECT_TRUE(vr->init().isOk());
-  EXPECT_TRUE(vr->setVrMode(false).isOk());
-  EXPECT_TRUE(vr->init().isOk());
-  EXPECT_TRUE(vr->setVrMode(false).isOk());
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(VrHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-        PerInstance, VrHidlTest,
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(IVr::descriptor)),
-        android::hardware::PrintInstanceNameToString);
-
diff --git a/vr/OWNERS b/vr/OWNERS
deleted file mode 100644
index a07824edc3..0000000000
--- a/vr/OWNERS
+++ /dev/null
@@ -1,3 +0,0 @@
-# Bug component: 298954331
-
-include platform/hardware/interfaces:/OWNERS
diff --git a/weaver/OWNERS b/weaver/OWNERS
index 7e579f63cd..9205e33f6f 100644
--- a/weaver/OWNERS
+++ b/weaver/OWNERS
@@ -1,6 +1,5 @@
 # Bug component: 1081729
 ebiggers@google.com
-paulcrowley@google.com
 swillden@google.com
 wfrichar@google.com
 chengyouho@google.com
diff --git a/wifi/1.0/vts/functional/Android.bp b/wifi/1.0/vts/functional/Android.bp
index e3c269daee..3490e1f744 100644
--- a/wifi/1.0/vts/functional/Android.bp
+++ b/wifi/1.0/vts/functional/Android.bp
@@ -45,78 +45,3 @@ cc_library_static {
         "libwifi-system-iface",
     ],
 }
-
-cc_test {
-    name: "VtsHalWifiV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    tidy_timeout_srcs: [
-        "wifi_chip_hidl_test.cpp",
-    ],
-    srcs: [
-        "wifi_chip_hidl_test.cpp",
-        "wifi_p2p_iface_hidl_test.cpp",
-        "wifi_rtt_controller_hidl_test.cpp",
-        "wifi_sta_iface_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi@1.1",
-        "android.hardware.wifi@1.2",
-        "android.hardware.wifi@1.3",
-        "android.hardware.wifi@1.4",
-        "android.hardware.wifi@1.5",
-        "libwifi-system-iface",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
-
-// These tests are split out so that they can be conditioned on presence of the
-// "android.hardware.wifi.aware" feature.
-cc_test {
-    name: "VtsHalWifiNanV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: [
-        "wifi_chip_hidl_nan_test.cpp",
-        "wifi_nan_iface_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi@1.1",
-        "android.hardware.wifi@1.2",
-        "android.hardware.wifi@1.3",
-        "android.hardware.wifi@1.4",
-        "android.hardware.wifi@1.5",
-        "libwifi-system-iface",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
-
-// These tests are split out so that they can be conditioned on presence of
-// the hostapd HAL, which indicates SoftAP support.
-cc_test {
-    name: "VtsHalWifiApV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: [
-        "wifi_ap_iface_hidl_test.cpp",
-        "wifi_chip_hidl_ap_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi.hostapd@1.0",
-        "libwifi-system-iface",
-    ],
-    disable_framework: true,
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/wifi/1.0/vts/functional/wifi_ap_iface_hidl_test.cpp b/wifi/1.0/vts/functional/wifi_ap_iface_hidl_test.cpp
deleted file mode 100644
index 28b16168f5..0000000000
--- a/wifi/1.0/vts/functional/wifi_ap_iface_hidl_test.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiApIface.h>
-#include <android/hardware/wifi/hostapd/1.0/IHostapd.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::hostapd::V1_0::IHostapd;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiApIface;
-using ::android::hardware::wifi::V1_0::WifiBand;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-
-/**
- * Fixture to use for all AP Iface HIDL interface tests.
- */
-class WifiApIfaceHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        if (android::hardware::getAllHalInstanceNames(IHostapd::descriptor)
-                .empty()) {
-            GTEST_SKIP() << "Device does not support AP";
-        }
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_ap_iface_ = getWifiApIface(GetInstanceName());
-        ASSERT_NE(nullptr, wifi_ap_iface_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    sp<IWifiApIface> wifi_ap_iface_;
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiApIface proxy object is
- * successfully created.
- */
-TEST_P(WifiApIfaceHidlTest, Create) {
-    // The creation of a proxy object is tested as part of SetUp method.
-}
-
-/*
- * GetType:
- * Ensures that the correct interface type is returned for AP interface.
- */
-TEST_P(WifiApIfaceHidlTest, GetType) {
-    const auto& status_and_type = HIDL_INVOKE(wifi_ap_iface_, getType);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_type.first.code);
-    EXPECT_EQ(IfaceType::AP, status_and_type.second);
-}
-
-/*
- * SetCountryCode:
- * Ensures that a call to set the country code will return with a success
- * status code.
- */
-TEST_P(WifiApIfaceHidlTest, SetCountryCode) {
-    const android::hardware::hidl_array<int8_t, 2> kCountryCode{
-        std::array<int8_t, 2>{{0x55, 0x53}}};
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_ap_iface_, setCountryCode, kCountryCode).code);
-}
-
-/*
- * GetValidFrequenciesForBand:
- * Ensures that we can retrieve valid frequencies for 2.4 GHz band.
- */
-TEST_P(WifiApIfaceHidlTest, GetValidFrequenciesForBand) {
-    const auto& status_and_freqs = HIDL_INVOKE(
-        wifi_ap_iface_, getValidFrequenciesForBand, WifiBand::BAND_24GHZ);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_freqs.first.code);
-    EXPECT_GT(status_and_freqs.second.size(), 0u);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiApIfaceHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiApIfaceHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_chip_hidl_ap_test.cpp b/wifi/1.0/vts/functional/wifi_chip_hidl_ap_test.cpp
deleted file mode 100644
index 66e1a807f0..0000000000
--- a/wifi/1.0/vts/functional/wifi_chip_hidl_ap_test.cpp
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiChip.h>
-#include <android/hardware/wifi/hostapd/1.0/IHostapd.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::hostapd::V1_0::IHostapd;
-using ::android::hardware::wifi::V1_0::ChipModeId;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiApIface;
-using ::android::hardware::wifi::V1_0::IWifiChip;
-using ::android::hardware::wifi::V1_0::IWifiIface;
-using ::android::hardware::wifi::V1_0::WifiStatus;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-
-/**
- * Fixture for IWifiChip tests that are conditioned on SoftAP support.
- */
-class WifiChipHidlApTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        if (android::hardware::getAllHalInstanceNames(IHostapd::descriptor)
-                .empty()) {
-            GTEST_SKIP() << "Device does not support AP";
-        }
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_chip_ = getWifiChip(GetInstanceName());
-        ASSERT_NE(nullptr, wifi_chip_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    // Helper function to configure the Chip in one of the supported modes.
-    // Most of the non-mode-configuration-related methods require chip
-    // to be first configured.
-    ChipModeId configureChipForIfaceType(IfaceType type, bool expectSuccess) {
-        ChipModeId mode_id;
-        EXPECT_EQ(expectSuccess,
-                  configureChipToSupportIfaceType(wifi_chip_, type, &mode_id));
-        return mode_id;
-    }
-
-    std::string getIfaceName(const sp<IWifiIface>& iface) {
-        const auto& status_and_name = HIDL_INVOKE(iface, getName);
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_name.first.code);
-        return status_and_name.second;
-    }
-
-    WifiStatusCode createApIface(sp<IWifiApIface>* ap_iface) {
-        const auto& status_and_iface = HIDL_INVOKE(wifi_chip_, createApIface);
-        *ap_iface = status_and_iface.second;
-        return status_and_iface.first.code;
-    }
-
-    WifiStatusCode removeApIface(const std::string& name) {
-        return HIDL_INVOKE(wifi_chip_, removeApIface, name).code;
-    }
-
-    sp<IWifiChip> wifi_chip_;
-
-   private:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * CreateApIface
- * Configures the chip in AP mode and ensures that at least 1 iface creation
- * succeeds.
- */
-TEST_P(WifiChipHidlApTest, CreateApIface) {
-    configureChipForIfaceType(IfaceType::AP, true);
-
-    sp<IWifiApIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createApIface(&iface));
-    EXPECT_NE(nullptr, iface.get());
-}
-
-/*
- * GetApIfaceNames
- * Configures the chip in AP mode and ensures that the iface list is empty
- * before creating the iface. Then, create the iface and ensure that
- * iface name is returned via the list.
- */
-TEST_P(WifiChipHidlApTest, GetApIfaceNames) {
-    configureChipForIfaceType(IfaceType::AP, true);
-
-    const auto& status_and_iface_names1 =
-        HIDL_INVOKE(wifi_chip_, getApIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names1.first.code);
-    EXPECT_EQ(0u, status_and_iface_names1.second.size());
-
-    sp<IWifiApIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createApIface(&iface));
-    EXPECT_NE(nullptr, iface.get());
-
-    std::string iface_name = getIfaceName(iface);
-    const auto& status_and_iface_names2 =
-        HIDL_INVOKE(wifi_chip_, getApIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names2.first.code);
-    EXPECT_EQ(1u, status_and_iface_names2.second.size());
-    EXPECT_EQ(iface_name, status_and_iface_names2.second[0]);
-
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeApIface(iface_name));
-    const auto& status_and_iface_names3 =
-        HIDL_INVOKE(wifi_chip_, getApIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names3.first.code);
-    EXPECT_EQ(0u, status_and_iface_names3.second.size());
-}
-
-/*
- * GetApIface
- * Configures the chip in AP mode and create an iface. Then, retrieve
- * the iface object using the correct name and ensure any other name
- * doesn't retrieve an iface object.
- */
-TEST_P(WifiChipHidlApTest, GetApIface) {
-    configureChipForIfaceType(IfaceType::AP, true);
-
-    sp<IWifiApIface> ap_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createApIface(&ap_iface));
-    EXPECT_NE(nullptr, ap_iface.get());
-
-    std::string iface_name = getIfaceName(ap_iface);
-    const auto& status_and_iface1 =
-        HIDL_INVOKE(wifi_chip_, getApIface, iface_name);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface1.first.code);
-    EXPECT_NE(nullptr, status_and_iface1.second.get());
-
-    std::string invalid_name = iface_name + "0";
-    const auto& status_and_iface2 =
-        HIDL_INVOKE(wifi_chip_, getApIface, invalid_name);
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, status_and_iface2.first.code);
-    EXPECT_EQ(nullptr, status_and_iface2.second.get());
-}
-
-/*
- * RemoveApIface
- * Configures the chip in AP mode and create an iface. Then, remove
- * the iface object using the correct name and ensure any other name
- * doesn't remove the iface.
- */
-TEST_P(WifiChipHidlApTest, RemoveApIface) {
-    configureChipForIfaceType(IfaceType::AP, true);
-
-    sp<IWifiApIface> ap_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createApIface(&ap_iface));
-    EXPECT_NE(nullptr, ap_iface.get());
-
-    std::string iface_name = getIfaceName(ap_iface);
-    std::string invalid_name = iface_name + "0";
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeApIface(invalid_name));
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeApIface(iface_name));
-
-    // No such iface exists now. So, this should return failure.
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeApIface(iface_name));
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiChipHidlApTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiChipHidlApTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_chip_hidl_nan_test.cpp b/wifi/1.0/vts/functional/wifi_chip_hidl_nan_test.cpp
deleted file mode 100644
index 49a25e5cfa..0000000000
--- a/wifi/1.0/vts/functional/wifi_chip_hidl_nan_test.cpp
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiChip.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::V1_0::ChipModeId;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiChip;
-using ::android::hardware::wifi::V1_0::IWifiIface;
-using ::android::hardware::wifi::V1_0::IWifiNanIface;
-using ::android::hardware::wifi::V1_0::WifiStatus;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-
-/**
- * Fixture for IWifiChip tests that are conditioned on NAN support.
- */
-class WifiChipHidlNanTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        if (!::testing::deviceSupportsFeature("android.hardware.wifi.aware"))
-            GTEST_SKIP() << "Skipping this test since NAN is not supported.";
-
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_chip_ = getWifiChip(GetInstanceName());
-        ASSERT_NE(nullptr, wifi_chip_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    // Helper function to configure the Chip in one of the supported modes.
-    // Most of the non-mode-configuration-related methods require chip
-    // to be first configured.
-    ChipModeId configureChipForIfaceType(IfaceType type, bool expectSuccess) {
-        ChipModeId mode_id;
-        EXPECT_EQ(expectSuccess,
-                  configureChipToSupportIfaceType(wifi_chip_, type, &mode_id));
-        return mode_id;
-    }
-
-    std::string getIfaceName(const sp<IWifiIface>& iface) {
-        const auto& status_and_name = HIDL_INVOKE(iface, getName);
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_name.first.code);
-        return status_and_name.second;
-    }
-
-    WifiStatusCode createNanIface(sp<IWifiNanIface>* nan_iface) {
-        const auto& status_and_iface = HIDL_INVOKE(wifi_chip_, createNanIface);
-        *nan_iface = status_and_iface.second;
-        return status_and_iface.first.code;
-    }
-
-    WifiStatusCode removeNanIface(const std::string& name) {
-        return HIDL_INVOKE(wifi_chip_, removeNanIface, name).code;
-    }
-
-    sp<IWifiChip> wifi_chip_;
-
-   private:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * CreateNanIface
- * Configures the chip in NAN mode and ensures that at least 1 iface creation
- * succeeds.
- */
-TEST_P(WifiChipHidlNanTest, CreateNanIface) {
-    configureChipForIfaceType(IfaceType::NAN, true);
-
-    sp<IWifiNanIface> iface;
-    ASSERT_EQ(WifiStatusCode::SUCCESS, createNanIface(&iface));
-    EXPECT_NE(nullptr, iface.get());
-}
-
-/*
- * GetNanIfaceNames
- * Configures the chip in NAN mode and ensures that the iface list is empty
- * before creating the iface. Then, create the iface and ensure that
- * iface name is returned via the list.
- */
-TEST_P(WifiChipHidlNanTest, GetNanIfaceNames) {
-    configureChipForIfaceType(IfaceType::NAN, true);
-
-    const auto& status_and_iface_names1 =
-        HIDL_INVOKE(wifi_chip_, getNanIfaceNames);
-    ASSERT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names1.first.code);
-    EXPECT_EQ(0u, status_and_iface_names1.second.size());
-
-    sp<IWifiNanIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createNanIface(&iface));
-    EXPECT_NE(nullptr, iface.get());
-
-    std::string iface_name = getIfaceName(iface);
-    const auto& status_and_iface_names2 =
-        HIDL_INVOKE(wifi_chip_, getNanIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names2.first.code);
-    EXPECT_EQ(1u, status_and_iface_names2.second.size());
-    EXPECT_EQ(iface_name, status_and_iface_names2.second[0]);
-
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeNanIface(iface_name));
-    const auto& status_and_iface_names3 =
-        HIDL_INVOKE(wifi_chip_, getNanIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names3.first.code);
-    EXPECT_EQ(0u, status_and_iface_names3.second.size());
-}
-
-/*
- * GetNanIface
- * Configures the chip in NAN mode and create an iface. Then, retrieve
- * the iface object using the correct name and ensure any other name
- * doesn't retrieve an iface object.
- */
-TEST_P(WifiChipHidlNanTest, GetNanIface) {
-    configureChipForIfaceType(IfaceType::NAN, true);
-
-    sp<IWifiNanIface> nan_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createNanIface(&nan_iface));
-    EXPECT_NE(nullptr, nan_iface.get());
-
-    std::string iface_name = getIfaceName(nan_iface);
-    const auto& status_and_iface1 =
-        HIDL_INVOKE(wifi_chip_, getNanIface, iface_name);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface1.first.code);
-    EXPECT_NE(nullptr, status_and_iface1.second.get());
-
-    std::string invalid_name = iface_name + "0";
-    const auto& status_and_iface2 =
-        HIDL_INVOKE(wifi_chip_, getNanIface, invalid_name);
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, status_and_iface2.first.code);
-    EXPECT_EQ(nullptr, status_and_iface2.second.get());
-}
-
-/*
- * RemoveNanIface
- * Configures the chip in NAN mode and create an iface. Then, remove
- * the iface object using the correct name and ensure any other name
- * doesn't remove the iface.
- */
-TEST_P(WifiChipHidlNanTest, RemoveNanIface) {
-    configureChipForIfaceType(IfaceType::NAN, true);
-
-    sp<IWifiNanIface> nan_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createNanIface(&nan_iface));
-    EXPECT_NE(nullptr, nan_iface.get());
-
-    std::string iface_name = getIfaceName(nan_iface);
-    std::string invalid_name = iface_name + "0";
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeNanIface(invalid_name));
-
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeNanIface(iface_name));
-
-    // No such iface exists now. So, this should return failure.
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeNanIface(iface_name));
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiChipHidlNanTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiChipHidlNanTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_chip_hidl_test.cpp b/wifi/1.0/vts/functional/wifi_chip_hidl_test.cpp
deleted file mode 100644
index 6c8f560769..0000000000
--- a/wifi/1.0/vts/functional/wifi_chip_hidl_test.cpp
+++ /dev/null
@@ -1,543 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiChip.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::wifi::V1_0::ChipId;
-using ::android::hardware::wifi::V1_0::ChipModeId;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiChip;
-using ::android::hardware::wifi::V1_0::IWifiIface;
-using ::android::hardware::wifi::V1_0::IWifiP2pIface;
-using ::android::hardware::wifi::V1_0::IWifiRttController;
-using ::android::hardware::wifi::V1_0::IWifiStaIface;
-using ::android::hardware::wifi::V1_0::WifiDebugHostWakeReasonStats;
-using ::android::hardware::wifi::V1_0::WifiDebugRingBufferStatus;
-using ::android::hardware::wifi::V1_0::WifiDebugRingBufferVerboseLevel;
-using ::android::hardware::wifi::V1_0::WifiStatus;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-
-namespace {
-constexpr WifiDebugRingBufferVerboseLevel kDebugRingBufferVerboseLvl =
-    WifiDebugRingBufferVerboseLevel::VERBOSE;
-constexpr uint32_t kDebugRingBufferMaxInterval = 5;
-constexpr uint32_t kDebugRingBufferMaxDataSize = 1024;
-
-/**
- * Check if any of the ring buffer capabilities are set.
- */
-bool hasAnyRingBufferCapabilities(uint32_t caps) {
-    return (caps &
-            (IWifiChip::ChipCapabilityMask::DEBUG_RING_BUFFER_CONNECT_EVENT |
-             IWifiChip::ChipCapabilityMask::DEBUG_RING_BUFFER_POWER_EVENT |
-             IWifiChip::ChipCapabilityMask::DEBUG_RING_BUFFER_WAKELOCK_EVENT |
-             IWifiChip::ChipCapabilityMask::DEBUG_RING_BUFFER_VENDOR_DATA));
-}
-}  // namespace
-
-/**
- * Fixture for IWifiChip tests.
- *
- * Tests that require SoftAP or NAN support should go into WifiChipHidlApTest or
- * WifiChipHidlNanTest respectively.
- */
-class WifiChipHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_chip_ = getWifiChip(GetInstanceName());
-        ASSERT_NE(nullptr, wifi_chip_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    // Helper function to configure the Chip in one of the supported modes.
-    // Most of the non-mode-configuration-related methods require chip
-    // to be first configured.
-    ChipModeId configureChipForIfaceType(IfaceType type, bool expectSuccess) {
-        ChipModeId mode_id;
-        EXPECT_EQ(expectSuccess,
-            configureChipToSupportIfaceType(wifi_chip_, type, &mode_id));
-        return mode_id;
-    }
-
-    uint32_t configureChipForStaIfaceAndGetCapabilities() {
-        configureChipForIfaceType(IfaceType::STA, true);
-
-        return getChipCapabilitiesLatest(wifi_chip_);
-    }
-
-    std::string getIfaceName(const sp<IWifiIface>& iface) {
-        const auto& status_and_name = HIDL_INVOKE(iface, getName);
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_name.first.code);
-        return status_and_name.second;
-    }
-
-    WifiStatusCode createP2pIface(sp<IWifiP2pIface>* p2p_iface) {
-        const auto& status_and_iface = HIDL_INVOKE(wifi_chip_, createP2pIface);
-        *p2p_iface = status_and_iface.second;
-        return status_and_iface.first.code;
-    }
-
-    WifiStatusCode removeP2pIface(const std::string& name) {
-        return HIDL_INVOKE(wifi_chip_, removeP2pIface, name).code;
-    }
-
-    WifiStatusCode createStaIface(sp<IWifiStaIface>* sta_iface) {
-        const auto& status_and_iface = HIDL_INVOKE(wifi_chip_, createStaIface);
-        *sta_iface = status_and_iface.second;
-        return status_and_iface.first.code;
-    }
-
-    WifiStatusCode removeStaIface(const std::string& name) {
-        return HIDL_INVOKE(wifi_chip_, removeStaIface, name).code;
-    }
-
-    sp<IWifiChip> wifi_chip_;
-
-   protected:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiChip proxy object is
- * successfully created.
- */
-TEST_P(WifiChipHidlTest, Create) {
-    // The creation of a proxy object is tested as part of SetUp method.
-}
-
-/*
- * GetId:
- */
-TEST_P(WifiChipHidlTest, GetId) {
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_chip_, getId).first.code);
-}
-
-/*
- * GetAvailableMode:
- */
-TEST_P(WifiChipHidlTest, GetAvailableModes) {
-    const auto& status_and_modes = HIDL_INVOKE(wifi_chip_, getAvailableModes);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_modes.first.code);
-    EXPECT_LT(0u, status_and_modes.second.size());
-}
-
-/*
- * ConfigureChip:
- */
-TEST_P(WifiChipHidlTest, ConfigureChip) {
-    const auto& status_and_modes = HIDL_INVOKE(wifi_chip_, getAvailableModes);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_modes.first.code);
-    EXPECT_LT(0u, status_and_modes.second.size());
-    for (const auto& mode : status_and_modes.second) {
-        // configureChip() requires to be called with a fresh IWifiChip object.
-        wifi_chip_ = getWifiChip(GetInstanceName());
-        ASSERT_NE(nullptr, wifi_chip_.get());
-        EXPECT_EQ(WifiStatusCode::SUCCESS,
-                  HIDL_INVOKE(wifi_chip_, configureChip, mode.id).code);
-        stopWifi(GetInstanceName());
-        // Sleep for 5 milliseconds between each wifi state toggle.
-        usleep(5000);
-    }
-}
-
-/*
- * GetCapabilities:
- */
-TEST_P(WifiChipHidlTest, GetCapabilities) {
-    configureChipForIfaceType(IfaceType::STA, true);
-    const auto& status_and_caps = HIDL_INVOKE(wifi_chip_, getCapabilities);
-    if (status_and_caps.first.code != WifiStatusCode::SUCCESS) {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status_and_caps.first.code);
-        return;
-    }
-    EXPECT_NE(0u, status_and_caps.second);
-}
-
-/*
- * GetMode:
- */
-TEST_P(WifiChipHidlTest, GetMode) {
-    ChipModeId chip_mode_id = configureChipForIfaceType(IfaceType::STA, true);
-    const auto& status_and_mode = HIDL_INVOKE(wifi_chip_, getMode);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_mode.first.code);
-    EXPECT_EQ(chip_mode_id, status_and_mode.second);
-}
-
-/*
- * RequestChipDebugInfo:
- */
-TEST_P(WifiChipHidlTest, RequestChipDebugInfo) {
-    configureChipForIfaceType(IfaceType::STA, true);
-    const auto& status_and_chip_info =
-        HIDL_INVOKE(wifi_chip_, requestChipDebugInfo);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_chip_info.first.code);
-    EXPECT_LT(0u, status_and_chip_info.second.driverDescription.size());
-    EXPECT_LT(0u, status_and_chip_info.second.firmwareDescription.size());
-}
-
-/*
- * RequestFirmwareDebugDump
- */
-TEST_P(WifiChipHidlTest, RequestFirmwareDebugDump) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    const auto& status_and_firmware_dump =
-        HIDL_INVOKE(wifi_chip_, requestFirmwareDebugDump);
-    if (caps & IWifiChip::ChipCapabilityMask::DEBUG_MEMORY_FIRMWARE_DUMP) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_firmware_dump.first.code);
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-                  status_and_firmware_dump.first.code);
-    }
-}
-
-/*
- * RequestDriverDebugDump
- */
-TEST_P(WifiChipHidlTest, RequestDriverDebugDump) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    const auto& status_and_driver_dump =
-        HIDL_INVOKE(wifi_chip_, requestDriverDebugDump);
-    if (caps & IWifiChip::ChipCapabilityMask::DEBUG_MEMORY_DRIVER_DUMP) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_driver_dump.first.code);
-    } else {
-      // API semantics (today) are such that function cannot be called if not capable!
-      //
-      //  EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-      //            status_and_driver_dump.first.code);
-    }
-}
-
-/*
- * GetDebugRingBuffersStatus
- */
-TEST_P(WifiChipHidlTest, GetDebugRingBuffersStatus) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    const auto& status_and_ring_buffer_status =
-        HIDL_INVOKE(wifi_chip_, getDebugRingBuffersStatus);
-    if (hasAnyRingBufferCapabilities(caps)) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS,
-                  status_and_ring_buffer_status.first.code);
-        for (const auto& ring_buffer : status_and_ring_buffer_status.second) {
-            EXPECT_LT(0u, ring_buffer.ringName.size());
-        }
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-                  status_and_ring_buffer_status.first.code);
-    }
-}
-
-/*
- * StartLoggingToDebugRingBuffer
- */
-TEST_P(WifiChipHidlTest, StartLoggingToDebugRingBuffer) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    std::string ring_name;
-    const auto& status_and_ring_buffer_status =
-        HIDL_INVOKE(wifi_chip_, getDebugRingBuffersStatus);
-    if (hasAnyRingBufferCapabilities(caps)) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS,
-                  status_and_ring_buffer_status.first.code);
-        ASSERT_LT(0u, status_and_ring_buffer_status.second.size());
-        ring_name = status_and_ring_buffer_status.second[0].ringName.c_str();
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-                  status_and_ring_buffer_status.first.code);
-    }
-    const auto& status =
-        HIDL_INVOKE(wifi_chip_, startLoggingToDebugRingBuffer, ring_name,
-                    kDebugRingBufferVerboseLvl, kDebugRingBufferMaxInterval,
-                    kDebugRingBufferMaxDataSize);
-    if (hasAnyRingBufferCapabilities(caps)) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status.code);
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-    }
-}
-
-/*
- * ForceDumpToDebugRingBuffer
- */
-TEST_P(WifiChipHidlTest, ForceDumpToDebugRingBuffer) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    std::string ring_name;
-    const auto& status_and_ring_buffer_status =
-        HIDL_INVOKE(wifi_chip_, getDebugRingBuffersStatus);
-    if (hasAnyRingBufferCapabilities(caps)) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS,
-                  status_and_ring_buffer_status.first.code);
-        ASSERT_LT(0u, status_and_ring_buffer_status.second.size());
-        ring_name = status_and_ring_buffer_status.second[0].ringName.c_str();
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-                  status_and_ring_buffer_status.first.code);
-    }
-    const auto& status =
-        HIDL_INVOKE(wifi_chip_, forceDumpToDebugRingBuffer, ring_name);
-    if (hasAnyRingBufferCapabilities(caps)) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status.code);
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-    }
-}
-
-/*
- * GetDebugHostWakeReasonStats
- */
-TEST_P(WifiChipHidlTest, GetDebugHostWakeReasonStats) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    const auto& status_and_debug_wake_reason =
-        HIDL_INVOKE(wifi_chip_, getDebugHostWakeReasonStats);
-    if (caps & IWifiChip::ChipCapabilityMask::DEBUG_HOST_WAKE_REASON_STATS) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS,
-                  status_and_debug_wake_reason.first.code);
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-                  status_and_debug_wake_reason.first.code);
-    }
-}
-
-/*
- * CreateP2pIface
- * Configures the chip in P2P mode and ensures that at least 1 iface creation
- * succeeds.
- */
-TEST_P(WifiChipHidlTest, CreateP2pIface) {
-    configureChipForIfaceType(IfaceType::P2P, true);
-
-    sp<IWifiP2pIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createP2pIface(&iface));
-    EXPECT_NE(nullptr, iface.get());
-}
-
-/*
- * GetP2pIfaceNames
- * Configures the chip in P2P mode and ensures that the iface list is empty
- * before creating the iface. Then, create the iface and ensure that
- * iface name is returned via the list.
- */
-TEST_P(WifiChipHidlTest, GetP2pIfaceNames) {
-    configureChipForIfaceType(IfaceType::P2P, true);
-
-    const auto& status_and_iface_names1 =
-        HIDL_INVOKE(wifi_chip_, getP2pIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names1.first.code);
-    EXPECT_EQ(0u, status_and_iface_names1.second.size());
-
-    sp<IWifiP2pIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createP2pIface(&iface));
-    ASSERT_NE(nullptr, iface.get());
-
-    std::string iface_name = getIfaceName(iface);
-    const auto& status_and_iface_names2 =
-        HIDL_INVOKE(wifi_chip_, getP2pIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names2.first.code);
-    EXPECT_EQ(1u, status_and_iface_names2.second.size());
-    EXPECT_EQ(iface_name, status_and_iface_names2.second[0]);
-
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeP2pIface(iface_name));
-    const auto& status_and_iface_names3 =
-        HIDL_INVOKE(wifi_chip_, getP2pIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names3.first.code);
-    EXPECT_EQ(0u, status_and_iface_names3.second.size());
-}
-
-/*
- * GetP2pIface
- * Configures the chip in P2P mode and create an iface. Then, retrieve
- * the iface object using the correct name and ensure any other name
- * doesn't retrieve an iface object.
- */
-TEST_P(WifiChipHidlTest, GetP2pIface) {
-    configureChipForIfaceType(IfaceType::P2P, true);
-
-    sp<IWifiP2pIface> p2p_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createP2pIface(&p2p_iface));
-    ASSERT_NE(nullptr, p2p_iface.get());
-
-    std::string iface_name = getIfaceName(p2p_iface);
-    const auto& status_and_iface1 =
-        HIDL_INVOKE(wifi_chip_, getP2pIface, iface_name);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface1.first.code);
-    EXPECT_NE(nullptr, status_and_iface1.second.get());
-
-    std::string invalid_name = iface_name + "0";
-    const auto& status_and_iface2 =
-        HIDL_INVOKE(wifi_chip_, getP2pIface, invalid_name);
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, status_and_iface2.first.code);
-    EXPECT_EQ(nullptr, status_and_iface2.second.get());
-}
-
-/*
- * RemoveP2pIface
- * Configures the chip in P2P mode and create an iface. Then, remove
- * the iface object using the correct name and ensure any other name
- * doesn't remove the iface.
- */
-TEST_P(WifiChipHidlTest, RemoveP2pIface) {
-    configureChipForIfaceType(IfaceType::P2P, true);
-
-    sp<IWifiP2pIface> p2p_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createP2pIface(&p2p_iface));
-    ASSERT_NE(nullptr, p2p_iface.get());
-
-    std::string iface_name = getIfaceName(p2p_iface);
-    std::string invalid_name = iface_name + "0";
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeP2pIface(invalid_name));
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeP2pIface(iface_name));
-
-    // No such iface exists now. So, this should return failure.
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeP2pIface(iface_name));
-}
-
-/*
- * CreateStaIface
- * Configures the chip in STA mode and ensures that at least 1 iface creation
- * succeeds.
- */
-TEST_P(WifiChipHidlTest, CreateStaIface) {
-    configureChipForIfaceType(IfaceType::STA, true);
-
-    sp<IWifiStaIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createStaIface(&iface));
-    EXPECT_NE(nullptr, iface.get());
-}
-
-/*
- * GetStaIfaceNames
- * Configures the chip in STA mode and ensures that the iface list is empty
- * before creating the iface. Then, create the iface and ensure that
- * iface name is returned via the list.
- */
-TEST_P(WifiChipHidlTest, GetStaIfaceNames) {
-    configureChipForIfaceType(IfaceType::STA, true);
-
-    const auto& status_and_iface_names1 =
-        HIDL_INVOKE(wifi_chip_, getStaIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names1.first.code);
-    EXPECT_EQ(0u, status_and_iface_names1.second.size());
-
-    sp<IWifiStaIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createStaIface(&iface));
-    ASSERT_NE(nullptr, iface.get());
-
-    std::string iface_name = getIfaceName(iface);
-    const auto& status_and_iface_names2 =
-        HIDL_INVOKE(wifi_chip_, getStaIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names2.first.code);
-    EXPECT_EQ(1u, status_and_iface_names2.second.size());
-    EXPECT_EQ(iface_name, status_and_iface_names2.second[0]);
-
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeStaIface(iface_name));
-    const auto& status_and_iface_names3 =
-        HIDL_INVOKE(wifi_chip_, getStaIfaceNames);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface_names3.first.code);
-    EXPECT_EQ(0u, status_and_iface_names3.second.size());
-}
-
-/*
- * GetStaIface
- * Configures the chip in STA mode and create an iface. Then, retrieve
- * the iface object using the correct name and ensure any other name
- * doesn't retrieve an iface object.
- */
-TEST_P(WifiChipHidlTest, GetStaIface) {
-    configureChipForIfaceType(IfaceType::STA, true);
-
-    sp<IWifiStaIface> sta_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createStaIface(&sta_iface));
-    ASSERT_NE(nullptr, sta_iface.get());
-
-    std::string iface_name = getIfaceName(sta_iface);
-    const auto& status_and_iface1 =
-        HIDL_INVOKE(wifi_chip_, getStaIface, iface_name);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_iface1.first.code);
-    EXPECT_NE(nullptr, status_and_iface1.second.get());
-
-    std::string invalid_name = iface_name + "0";
-    const auto& status_and_iface2 =
-        HIDL_INVOKE(wifi_chip_, getStaIface, invalid_name);
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, status_and_iface2.first.code);
-    EXPECT_EQ(nullptr, status_and_iface2.second.get());
-}
-
-/*
- * RemoveStaIface
- * Configures the chip in STA mode and create an iface. Then, remove
- * the iface object using the correct name and ensure any other name
- * doesn't remove the iface.
- */
-TEST_P(WifiChipHidlTest, RemoveStaIface) {
-    configureChipForIfaceType(IfaceType::STA, true);
-
-    sp<IWifiStaIface> sta_iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createStaIface(&sta_iface));
-    ASSERT_NE(nullptr, sta_iface.get());
-
-    std::string iface_name = getIfaceName(sta_iface);
-    std::string invalid_name = iface_name + "0";
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeStaIface(invalid_name));
-    EXPECT_EQ(WifiStatusCode::SUCCESS, removeStaIface(iface_name));
-
-    // No such iface exists now. So, this should return failure.
-    EXPECT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, removeStaIface(iface_name));
-}
-
-/*
- * CreateRttController
- */
-TEST_P(WifiChipHidlTest, CreateRttController) {
-    configureChipForIfaceType(IfaceType::STA, true);
-
-    sp<IWifiStaIface> iface;
-    EXPECT_EQ(WifiStatusCode::SUCCESS, createStaIface(&iface));
-    ASSERT_NE(nullptr, iface.get());
-
-    const auto& status_and_rtt_controller =
-        HIDL_INVOKE(wifi_chip_, createRttController, iface);
-    if (status_and_rtt_controller.first.code !=
-        WifiStatusCode::ERROR_NOT_SUPPORTED) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS,
-                  status_and_rtt_controller.first.code);
-        EXPECT_NE(nullptr, status_and_rtt_controller.second.get());
-    }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiChipHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiChipHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_nan_iface_hidl_test.cpp b/wifi/1.0/vts/functional/wifi_nan_iface_hidl_test.cpp
deleted file mode 100644
index a74987cf24..0000000000
--- a/wifi/1.0/vts/functional/wifi_nan_iface_hidl_test.cpp
+++ /dev/null
@@ -1,528 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Nanache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiNanIface.h>
-#include <android/hardware/wifi/1.0/IWifiNanIfaceEventCallback.h>
-#include <android/hardware/wifi/1.5/IWifiNanIface.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <chrono>
-#include <condition_variable>
-#include <mutex>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using namespace ::android::hardware::wifi::V1_0;
-
-using ::android::sp;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::wifi::V1_0::IWifi;
-
-#define TIMEOUT_PERIOD 10
-
-/**
- * Fixture to use for all NAN Iface HIDL interface tests.
- */
-class WifiNanIfaceHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        if (!::testing::deviceSupportsFeature("android.hardware.wifi.aware"))
-            GTEST_SKIP() << "Skipping this test since NAN is not supported.";
-
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-
-        iwifiNanIface = getWifiNanIface(GetInstanceName());
-        ASSERT_NE(nullptr, iwifiNanIface.get());
-        ASSERT_EQ(WifiStatusCode::SUCCESS,
-                  HIDL_INVOKE(iwifiNanIface, registerEventCallback,
-                              new WifiNanIfaceEventCallback(*this))
-                      .code);
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-    /* Used as a mechanism to inform the test about data/event callback */
-    inline void notify() {
-      std::unique_lock<std::mutex> lock(mtx_);
-      count_++;
-      cv_.notify_one();
-    }
-
-    enum CallbackType {
-        INVALID = -2,
-        ANY_CALLBACK = -1,
-
-        NOTIFY_CAPABILITIES_RESPONSE = 0,
-        NOTIFY_ENABLE_RESPONSE,
-        NOTIFY_CONFIG_RESPONSE,
-        NOTIFY_DISABLE_RESPONSE,
-        NOTIFY_START_PUBLISH_RESPONSE,
-        NOTIFY_STOP_PUBLISH_RESPONSE,
-        NOTIFY_START_SUBSCRIBE_RESPONSE,
-        NOTIFY_STOP_SUBSCRIBE_RESPONSE,
-        NOTIFY_TRANSMIT_FOLLOWUP_RESPONSE,
-        NOTIFY_CREATE_DATA_INTERFACE_RESPONSE,
-        NOTIFY_DELETE_DATA_INTERFACE_RESPONSE,
-        NOTIFY_INITIATE_DATA_PATH_RESPONSE,
-        NOTIFY_RESPOND_TO_DATA_PATH_INDICATION_RESPONSE,
-        NOTIFY_TERMINATE_DATA_PATH_RESPONSE,
-
-        EVENT_CLUSTER_EVENT,
-        EVENT_DISABLED,
-        EVENT_PUBLISH_TERMINATED,
-        EVENT_SUBSCRIBE_TERMINATED,
-        EVENT_MATCH,
-        EVENT_MATCH_EXPIRED,
-        EVENT_FOLLOWUP_RECEIVED,
-        EVENT_TRANSMIT_FOLLOWUP,
-        EVENT_DATA_PATH_REQUEST,
-        EVENT_DATA_PATH_CONFIRM,
-        EVENT_DATA_PATH_TERMINATED
-    };
-
-    /* Test code calls this function to wait for data/event callback */
-    /* Must set callbackType = INVALID before call this function */
-    inline std::cv_status wait(CallbackType waitForCallbackType) {
-      std::unique_lock<std::mutex> lock(mtx_);
-
-      EXPECT_NE(INVALID, waitForCallbackType); // can't ASSERT in a non-void-returning method
-
-      std::cv_status status = std::cv_status::no_timeout;
-      auto now = std::chrono::system_clock::now();
-      while (count_ == 0) {
-        status = cv_.wait_until(lock, now + std::chrono::seconds(TIMEOUT_PERIOD));
-        if (status == std::cv_status::timeout) return status;
-        if (waitForCallbackType != ANY_CALLBACK && callbackType != INVALID
-            && callbackType != waitForCallbackType) {
-          count_--;
-        }
-      }
-      count_--;
-      return status;
-    }
-
-    class WifiNanIfaceEventCallback: public IWifiNanIfaceEventCallback {
-      WifiNanIfaceHidlTest& parent_;
-
-     public:
-      WifiNanIfaceEventCallback(WifiNanIfaceHidlTest& parent) : parent_(parent) {};
-
-      virtual ~WifiNanIfaceEventCallback() = default;
-
-      Return<void> notifyCapabilitiesResponse(
-            uint16_t id,
-            const WifiNanStatus& status,
-            const NanCapabilities& capabilities) override {
-        parent_.callbackType = NOTIFY_CAPABILITIES_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-        parent_.capabilities = capabilities;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyEnableResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_ENABLE_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyConfigResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_CONFIG_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyDisableResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_DISABLE_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyStartPublishResponse(
-            uint16_t id,
-            const WifiNanStatus& status,
-            uint8_t sessionId) override {
-        parent_.callbackType = NOTIFY_START_PUBLISH_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-        parent_.sessionId = sessionId;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyStopPublishResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_STOP_PUBLISH_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyStartSubscribeResponse(
-            uint16_t id,
-            const WifiNanStatus& status,
-            uint8_t sessionId) override {
-        parent_.callbackType = NOTIFY_START_SUBSCRIBE_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-        parent_.sessionId = sessionId;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyStopSubscribeResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_STOP_SUBSCRIBE_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyTransmitFollowupResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_TRANSMIT_FOLLOWUP_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyCreateDataInterfaceResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_CREATE_DATA_INTERFACE_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyDeleteDataInterfaceResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_DELETE_DATA_INTERFACE_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyInitiateDataPathResponse(
-            uint16_t id,
-            const WifiNanStatus& status,
-            uint32_t ndpInstanceId) override {
-        parent_.callbackType = NOTIFY_INITIATE_DATA_PATH_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-        parent_.ndpInstanceId = ndpInstanceId;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyRespondToDataPathIndicationResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_RESPOND_TO_DATA_PATH_INDICATION_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> notifyTerminateDataPathResponse(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = NOTIFY_TERMINATE_DATA_PATH_RESPONSE;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventClusterEvent(
-            const NanClusterEventInd& event) override {
-        parent_.callbackType = EVENT_CLUSTER_EVENT;
-
-        parent_.nanClusterEventInd = event;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventDisabled(
-            const WifiNanStatus& status) override {
-        parent_.callbackType = EVENT_DISABLED;
-
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventPublishTerminated(
-            uint8_t sessionId,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = EVENT_PUBLISH_TERMINATED;
-
-        parent_.sessionId = sessionId;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventSubscribeTerminated(
-            uint8_t sessionId,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = EVENT_SUBSCRIBE_TERMINATED;
-
-        parent_.sessionId = sessionId;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventMatch(
-            const NanMatchInd& event) override {
-        parent_.callbackType = EVENT_MATCH;
-
-        parent_.nanMatchInd = event;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventMatchExpired(
-            uint8_t discoverySessionId,
-            uint32_t peerId) override {
-        parent_.callbackType = EVENT_MATCH_EXPIRED;
-
-        parent_.sessionId = discoverySessionId;
-        parent_.peerId = peerId;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventFollowupReceived(
-            const NanFollowupReceivedInd& event) override {
-        parent_.callbackType = EVENT_FOLLOWUP_RECEIVED;
-
-        parent_.nanFollowupReceivedInd = event;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventTransmitFollowup(
-            uint16_t id,
-            const WifiNanStatus& status) override {
-        parent_.callbackType = EVENT_TRANSMIT_FOLLOWUP;
-
-        parent_.id = id;
-        parent_.status = status;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventDataPathRequest(
-            const NanDataPathRequestInd& event) override {
-        parent_.callbackType = EVENT_DATA_PATH_REQUEST;
-
-        parent_.nanDataPathRequestInd = event;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventDataPathConfirm(
-            const NanDataPathConfirmInd& event) override {
-        parent_.callbackType = EVENT_DATA_PATH_CONFIRM;
-
-        parent_.nanDataPathConfirmInd = event;
-
-        parent_.notify();
-        return Void();
-      }
-
-      Return<void> eventDataPathTerminated(
-            uint32_t ndpInstanceId) override {
-        parent_.callbackType = EVENT_DATA_PATH_TERMINATED;
-
-        parent_.ndpInstanceId = ndpInstanceId;
-
-        parent_.notify();
-        return Void();
-      }
-    };
-
-    private:
-      // synchronization objects
-      std::mutex mtx_;
-      std::condition_variable cv_;
-      int count_;
-
-    protected:
-      android::sp<IWifiNanIface> iwifiNanIface;
-
-      // Data from IWifiNanIfaceEventCallback callbacks: this is the collection of all
-      // arguments to all callbacks. They are set by the callback (notifications or
-      // events) and can be retrieved by tests.
-      CallbackType callbackType;
-      uint16_t id;
-      WifiNanStatus status;
-      NanCapabilities capabilities;
-      uint8_t sessionId;
-      uint32_t ndpInstanceId;
-      NanClusterEventInd nanClusterEventInd;
-      NanMatchInd nanMatchInd;
-      uint32_t peerId;
-      NanFollowupReceivedInd nanFollowupReceivedInd;
-      NanDataPathRequestInd nanDataPathRequestInd;
-      NanDataPathConfirmInd nanDataPathConfirmInd;
-
-      std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiNanIface proxy object is
- * successfully created.
- */
-TEST_P(WifiNanIfaceHidlTest, Create) {
-    // The creation of a proxy object is tested as part of SetUp method.
-}
-
-/*
- * Fail: use past destruction
- * Ensure that API calls fail with ERROR_WIFI_IFACE_INVALID when using an interface once wifi
- * is disabled.
- */
-TEST_P(WifiNanIfaceHidlTest, FailOnIfaceInvalid) {
-    stopWifi(GetInstanceName());
-    android::sp<IWifiNanIface> iwifiNanIface =
-        getWifiNanIface(GetInstanceName());
-    ASSERT_NE(nullptr, iwifiNanIface.get());
-    stopWifi(GetInstanceName());
-    sleep(5);  // make sure that all chips/interfaces are invalidated
-    ASSERT_EQ(WifiStatusCode::ERROR_WIFI_IFACE_INVALID,
-              HIDL_INVOKE(iwifiNanIface, getCapabilitiesRequest, 0).code);
-}
-
-/*
- * getCapabilitiesRequest: validate that returns capabilities.
- */
-TEST_P(WifiNanIfaceHidlTest, getCapabilitiesRequest) {
-    uint16_t inputCmdId = 10;
-    callbackType = INVALID;
-    sp<::android::hardware::wifi::V1_5::IWifiNanIface> iface_converted =
-        ::android::hardware::wifi::V1_5::IWifiNanIface::castFrom(iwifiNanIface);
-    if (iface_converted != nullptr) {
-        ASSERT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-                  HIDL_INVOKE(iwifiNanIface, getCapabilitiesRequest, inputCmdId)
-                      .code);
-        // Skip this test since this API is deprecated in this newer HAL version
-        return;
-    }
-
-    ASSERT_EQ(
-        WifiStatusCode::SUCCESS,
-        HIDL_INVOKE(iwifiNanIface, getCapabilitiesRequest, inputCmdId).code);
-    // wait for a callback
-    ASSERT_EQ(std::cv_status::no_timeout, wait(NOTIFY_CAPABILITIES_RESPONSE));
-    ASSERT_EQ(NOTIFY_CAPABILITIES_RESPONSE, callbackType);
-    ASSERT_EQ(id, inputCmdId);
-
-    // check for reasonable capability values
-    EXPECT_GT(capabilities.maxConcurrentClusters, (unsigned int)0);
-    EXPECT_GT(capabilities.maxPublishes, (unsigned int)0);
-    EXPECT_GT(capabilities.maxSubscribes, (unsigned int)0);
-    EXPECT_EQ(capabilities.maxServiceNameLen, (unsigned int)255);
-    EXPECT_EQ(capabilities.maxMatchFilterLen, (unsigned int)255);
-    EXPECT_GT(capabilities.maxTotalMatchFilterLen, (unsigned int)255);
-    EXPECT_EQ(capabilities.maxServiceSpecificInfoLen, (unsigned int)255);
-    EXPECT_GE(capabilities.maxExtendedServiceSpecificInfoLen,
-              (unsigned int)255);
-    EXPECT_GT(capabilities.maxNdiInterfaces, (unsigned int)0);
-    EXPECT_GT(capabilities.maxNdpSessions, (unsigned int)0);
-    EXPECT_GT(capabilities.maxAppInfoLen, (unsigned int)0);
-    EXPECT_GT(capabilities.maxQueuedTransmitFollowupMsgs, (unsigned int)0);
-    EXPECT_GT(capabilities.maxSubscribeInterfaceAddresses, (unsigned int)0);
-    EXPECT_NE(capabilities.supportedCipherSuites, (unsigned int)0);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiNanIfaceHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiNanIfaceHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_p2p_iface_hidl_test.cpp b/wifi/1.0/vts/functional/wifi_p2p_iface_hidl_test.cpp
deleted file mode 100644
index ce525f00e9..0000000000
--- a/wifi/1.0/vts/functional/wifi_p2p_iface_hidl_test.cpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the P2pache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiP2pIface.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiP2pIface;
-
-/**
- * Fixture to use for all P2P Iface HIDL interface tests.
- */
-class WifiP2pIfaceHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiP2pIface proxy object is
- * successfully created.
- */
-TEST_P(WifiP2pIfaceHidlTest, Create) {
-    stopWifi(GetInstanceName());
-    EXPECT_NE(nullptr, getWifiP2pIface(GetInstanceName()).get());
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiP2pIfaceHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiP2pIfaceHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_rtt_controller_hidl_test.cpp b/wifi/1.0/vts/functional/wifi_rtt_controller_hidl_test.cpp
deleted file mode 100644
index b1a918d545..0000000000
--- a/wifi/1.0/vts/functional/wifi_rtt_controller_hidl_test.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiRttController.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiChip;
-using ::android::hardware::wifi::V1_0::IWifiRttController;
-using ::android::hardware::wifi::V1_0::IWifiStaIface;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-
-/**
- * Fixture to use for all RTT controller HIDL interface tests.
- */
-class WifiRttControllerHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        if (!::testing::deviceSupportsFeature("android.hardware.wifi.rtt"))
-            GTEST_SKIP() << "Skipping this test since RTT is not supported.";
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiRttController proxy object is
- * successfully created.
- */
-TEST_P(WifiRttControllerHidlTest, Create) {
-    stopWifi(GetInstanceName());
-
-    const std::string& instance_name = GetInstanceName();
-
-    sp<IWifiChip> wifi_chip = getWifiChip(instance_name);
-    ASSERT_NE(nullptr, wifi_chip.get());
-
-    sp<IWifiStaIface> wifi_sta_iface = getWifiStaIface(instance_name);
-    ASSERT_NE(nullptr, wifi_sta_iface.get());
-
-    const auto& status_and_controller =
-        HIDL_INVOKE(wifi_chip, createRttController, wifi_sta_iface);
-    if (status_and_controller.first.code !=
-        WifiStatusCode::ERROR_NOT_SUPPORTED) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_controller.first.code);
-        EXPECT_NE(nullptr, status_and_controller.second.get());
-    }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiRttControllerHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiRttControllerHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.0/vts/functional/wifi_sta_iface_hidl_test.cpp b/wifi/1.0/vts/functional/wifi_sta_iface_hidl_test.cpp
deleted file mode 100644
index 08d81ff3d8..0000000000
--- a/wifi/1.0/vts/functional/wifi_sta_iface_hidl_test.cpp
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Staache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.0/IWifiStaIface.h>
-#include <android/hardware/wifi/1.3/IWifiStaIface.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::V1_0::Bssid;
-using ::android::hardware::wifi::V1_0::CommandId;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::hardware::wifi::V1_0::IWifiStaIface;
-using ::android::hardware::wifi::V1_0::Rssi;
-using ::android::hardware::wifi::V1_0::Ssid;
-using ::android::hardware::wifi::V1_0::StaApfPacketFilterCapabilities;
-using ::android::hardware::wifi::V1_0::StaRoamingConfig;
-using ::android::hardware::wifi::V1_0::StaRoamingState;
-using ::android::hardware::wifi::V1_0::WifiBand;
-using ::android::hardware::wifi::V1_0::WifiStatus;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-
-/**
- * Fixture to use for all STA Iface HIDL interface tests.
- */
-class WifiStaIfaceHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        // Make sure test starts with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_sta_iface_ = getWifiStaIface(GetInstanceName());
-        ASSERT_NE(nullptr, wifi_sta_iface_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    bool isCapabilitySupported(IWifiStaIface::StaIfaceCapabilityMask cap_mask) {
-        const auto& status_and_caps =
-            HIDL_INVOKE(wifi_sta_iface_, getCapabilities);
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_caps.first.code);
-        return (status_and_caps.second & cap_mask) != 0;
-    }
-
-    sp<IWifiStaIface> wifi_sta_iface_;
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiStaIface proxy object is
- * successfully created.
- */
-TEST_P(WifiStaIfaceHidlTest, Create) {
-    // The creation of a proxy object is tested as part of SetUp method.
-}
-
-/*
- * GetCapabilities:
- */
-TEST_P(WifiStaIfaceHidlTest, GetCapabilities) {
-    const auto& status_and_caps = HIDL_INVOKE(wifi_sta_iface_, getCapabilities);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_caps.first.code);
-    EXPECT_GT(status_and_caps.second, 0u);
-}
-
-/*
- * GetType:
- * Ensures that the correct interface type is returned for station interface.
- */
-TEST_P(WifiStaIfaceHidlTest, GetType) {
-    const auto& status_and_type = HIDL_INVOKE(wifi_sta_iface_, getType);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_type.first.code);
-    EXPECT_EQ(IfaceType::STA, status_and_type.second);
-}
-
-/*
- * GetApfPacketFilterCapabilities:
- * Ensures that we can retrieve APF packet filter capabilites.
- */
-TEST_P(WifiStaIfaceHidlTest, GetApfPacketFilterCapabilities) {
-    if (!isCapabilitySupported(IWifiStaIface::StaIfaceCapabilityMask::APF)) {
-        // No-op if APF packet filer is not supported.
-        return;
-    }
-
-    const auto& status_and_caps =
-        HIDL_INVOKE(wifi_sta_iface_, getApfPacketFilterCapabilities);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_caps.first.code);
-}
-
-/*
- * GetBackgroundScanCapabilities:
- * Ensures that we can retrieve background scan capabilities.
- */
-TEST_P(WifiStaIfaceHidlTest, GetBackgroundScanCapabilities) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::BACKGROUND_SCAN)) {
-        // No-op if background scan is not supported.
-        return;
-    }
-
-    const auto& status_and_caps =
-        HIDL_INVOKE(wifi_sta_iface_, getBackgroundScanCapabilities);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_caps.first.code);
-}
-
-/*
- * GetValidFrequenciesForBand:
- * Ensures that we can retrieve valid frequencies for 2.4 GHz band.
- */
-TEST_P(WifiStaIfaceHidlTest, GetValidFrequenciesForBand) {
-    const auto& status_and_freqs = HIDL_INVOKE(
-        wifi_sta_iface_, getValidFrequenciesForBand, WifiBand::BAND_24GHZ);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_freqs.first.code);
-    EXPECT_GT(status_and_freqs.second.size(), 0u);
-}
-
-/*
- * LinkLayerStatsCollection:
- * Ensures that calls to enable, disable, and retrieve link layer stats
- * will return a success status code.
- */
-TEST_P(WifiStaIfaceHidlTest, LinkLayerStatsCollection) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::LINK_LAYER_STATS)) {
-        // No-op if link layer stats is not supported.
-        return;
-    }
-
-    sp<::android::hardware::wifi::V1_3::IWifiStaIface> iface_converted =
-        ::android::hardware::wifi::V1_3::IWifiStaIface::castFrom(
-            wifi_sta_iface_);
-    if (iface_converted != nullptr) {
-        // Skip this test since this API is deprecated in this newer HAL version
-        return;
-    }
-
-    // Enable link layer stats collection.
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, enableLinkLayerStatsCollection, true)
-                  .code);
-    // Retrieve link layer stats.
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, getLinkLayerStats).first.code);
-    // Disable link layer stats collection.
-    EXPECT_EQ(
-        WifiStatusCode::SUCCESS,
-        HIDL_INVOKE(wifi_sta_iface_, disableLinkLayerStatsCollection).code);
-}
-
-/*
- * RSSIMonitoring:
- * Ensures that calls to enable RSSI monitoring will return an error status
- * code if device is not connected to an AP.
- * Ensures that calls to disable RSSI monitoring will return an error status
- * code if RSSI monitoring is not enabled.
- */
-TEST_P(WifiStaIfaceHidlTest, RSSIMonitoring) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::RSSI_MONITOR)) {
-        // No-op if RSSI monitor is not supported.
-        return;
-    }
-
-    const CommandId kCmd = 1;
-    const Rssi kMaxRssi = -50;
-    const Rssi kMinRssi = -90;
-    // This is going to fail because device is not connected to an AP.
-    EXPECT_NE(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, startRssiMonitoring, kCmd, kMaxRssi,
-                          kMinRssi)
-                  .code);
-    // This is going to fail because RSSI monitoring is not enabled.
-    EXPECT_NE(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, stopRssiMonitoring, kCmd).code);
-}
-
-/*
- * RoamingControl:
- * Ensures that calls to configure and enable roaming will return a success
- * status code.
- */
-TEST_P(WifiStaIfaceHidlTest, RoamingControl) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::CONTROL_ROAMING)) {
-        // No-op if roaming control is not supported.
-        return;
-    }
-
-    // Retrieve roaming capabilities.
-    const auto& status_and_cap =
-        HIDL_INVOKE(wifi_sta_iface_, getRoamingCapabilities);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_cap.first.code);
-
-    // Setup roaming configuration based on roaming capabilities.
-    const auto& cap = status_and_cap.second;
-    StaRoamingConfig roaming_config;
-    if (cap.maxBlacklistSize > 0) {
-        Bssid black_list_bssid{
-            std::array<uint8_t, 6>{{0x11, 0x22, 0x33, 0x44, 0x55, 0x66}}};
-        roaming_config.bssidBlacklist =
-            android::hardware::hidl_vec<Bssid>{black_list_bssid};
-    }
-    if (cap.maxWhitelistSize > 0) {
-        Ssid white_list_ssid{
-            std::array<uint8_t, 32>{{0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC}}};
-        roaming_config.ssidWhitelist =
-            android::hardware::hidl_vec<Ssid>{white_list_ssid};
-    }
-
-    // Configure roaming.
-    EXPECT_EQ(
-        WifiStatusCode::SUCCESS,
-        HIDL_INVOKE(wifi_sta_iface_, configureRoaming, roaming_config).code);
-
-    // Enable roaming.
-    EXPECT_EQ(
-        WifiStatusCode::SUCCESS,
-        HIDL_INVOKE(wifi_sta_iface_, setRoamingState, StaRoamingState::ENABLED)
-            .code);
-}
-
-/*
- * EnableNDOffload:
- * Ensures that calls to enable neighbor discovery offload will return a success
- * status code.
- */
-TEST_P(WifiStaIfaceHidlTest, EnableNDOffload) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::ND_OFFLOAD)) {
-        // No-op if nd offload is not supported.
-        return;
-    }
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, enableNdOffload, true).code);
-}
-
-/*
- * SetScanningMacOui:
- * Ensures that calls to set scanning MAC OUI will return a NOT_SUPPORTED
- * code since it is now deprecated.
- */
-TEST_P(WifiStaIfaceHidlTest, SetScanningMacOui) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::SCAN_RAND)) {
-        // No-op if SetScanningMacOui is not supported.
-        return;
-    }
-    const android::hardware::hidl_array<uint8_t, 3> kOui{
-        std::array<uint8_t, 3>{{0x10, 0x22, 0x33}}};
-    EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED,
-              HIDL_INVOKE(wifi_sta_iface_, setScanningMacOui, kOui).code);
-}
-
-/*
- * PacketFateMonitoring:
- * Ensures that calls to start packet fate monitoring and retrieve TX/RX
- * packets will return a success status code.
- */
-TEST_P(WifiStaIfaceHidlTest, PacketFateMonitoring) {
-    if (!isCapabilitySupported(
-            IWifiStaIface::StaIfaceCapabilityMask::DEBUG_PACKET_FATE)) {
-        // No-op if packet fate monitor is not supported.
-        return;
-    }
-    // Start packet fate monitoring.
-    EXPECT_EQ(
-        WifiStatusCode::SUCCESS,
-        HIDL_INVOKE(wifi_sta_iface_, startDebugPacketFateMonitoring).code);
-
-    // Retrieve packets.
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, getDebugTxPacketFates).first.code);
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, getDebugRxPacketFates).first.code);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiStaIfaceHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiStaIfaceHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.1/vts/functional/Android.bp b/wifi/1.1/vts/functional/Android.bp
deleted file mode 100644
index 123c8a329c..0000000000
--- a/wifi/1.1/vts/functional/Android.bp
+++ /dev/null
@@ -1,48 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_fwk_wifi_hal",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalWifiV1_1TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: [
-        "wifi_chip_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi@1.1",
-        "android.hardware.wifi@1.2",
-        "android.hardware.wifi@1.3",
-        "android.hardware.wifi@1.4",
-        "android.hardware.wifi@1.5",
-        "libwifi-system-iface",
-    ],
-    disable_framework: true,
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/wifi/1.1/vts/functional/wifi_chip_hidl_test.cpp b/wifi/1.1/vts/functional/wifi_chip_hidl_test.cpp
deleted file mode 100644
index 874aa83584..0000000000
--- a/wifi/1.1/vts/functional/wifi_chip_hidl_test.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <android/hardware/wifi/1.1/IWifi.h>
-#include <android/hardware/wifi/1.1/IWifiChip.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::ChipId;
-using ::android::hardware::wifi::V1_0::ChipModeId;
-using ::android::hardware::wifi::V1_0::WifiStatus;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-using ::android::hardware::wifi::V1_1::IWifi;
-using ::android::hardware::wifi::V1_1::IWifiChip;
-using ::android::hardware::wifi::V1_0::IWifiStaIface;
-
-namespace {
-constexpr IWifiChip::TxPowerScenario kFakePowerScenario =
-    IWifiChip::TxPowerScenario::VOICE_CALL;
-}; //namespace
-
-/**
- * Fixture to use for all Wifi chip HIDL interface tests.
- */
-class WifiChipHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        // Make sure to start with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_chip_ = IWifiChip::castFrom(getWifiChip(GetInstanceName()));
-        ASSERT_NE(nullptr, wifi_chip_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    uint32_t configureChipForStaIfaceAndGetCapabilities() {
-        ChipModeId mode_id;
-        EXPECT_TRUE(configureChipToSupportIfaceType(
-            wifi_chip_, IfaceType::STA, &mode_id));
-
-        return getChipCapabilitiesLatest(wifi_chip_);
-    }
-
-    sp<IWifiChip> wifi_chip_;
-
-   private:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * SelectTxPowerScenario
- */
-TEST_P(WifiChipHidlTest, SelectTxPowerScenario) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    const auto& status =
-        HIDL_INVOKE(wifi_chip_, selectTxPowerScenario, kFakePowerScenario);
-    if (caps & IWifiChip::ChipCapabilityMask::SET_TX_POWER_LIMIT) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status.code);
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-    }
-}
-
-/*
- * ResetTxPowerScenario
- */
-TEST_P(WifiChipHidlTest, ResetTxPowerScenario) {
-    uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-    const auto& status =
-        HIDL_INVOKE(wifi_chip_, resetTxPowerScenario);
-    if (caps & IWifiChip::ChipCapabilityMask::SET_TX_POWER_LIMIT) {
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status.code);
-    } else {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-    }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiChipHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiChipHidlTest,
-    testing::ValuesIn(
-        android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.2/vts/functional/Android.bp b/wifi/1.2/vts/functional/Android.bp
deleted file mode 100644
index 2b85d0c603..0000000000
--- a/wifi/1.2/vts/functional/Android.bp
+++ /dev/null
@@ -1,71 +0,0 @@
-//
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_fwk_wifi_hal",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_test {
-    name: "VtsHalWifiV1_2TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: [
-        "wifi_chip_hidl_test.cpp",
-        "wifi_sta_iface_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi@1.1",
-        "android.hardware.wifi@1.2",
-        "android.hardware.wifi@1.3",
-        "android.hardware.wifi@1.4",
-        "android.hardware.wifi@1.5",
-        "libwifi-system-iface",
-    ],
-    disable_framework: true,
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
-
-cc_test {
-    name: "VtsHalWifiNanV1_2TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: [
-        "wifi_nan_iface_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi@1.1",
-        "android.hardware.wifi@1.2",
-        "android.hardware.wifi@1.3",
-        "android.hardware.wifi@1.4",
-        "android.hardware.wifi@1.5",
-        "libwifi-system-iface",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/wifi/1.2/vts/functional/wifi_chip_hidl_test.cpp b/wifi/1.2/vts/functional/wifi_chip_hidl_test.cpp
deleted file mode 100644
index 6113fbf1f9..0000000000
--- a/wifi/1.2/vts/functional/wifi_chip_hidl_test.cpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <android/hardware/wifi/1.2/IWifi.h>
-#include <android/hardware/wifi/1.2/IWifiChip.h>
-#include <android/hardware/wifi/1.2/IWifiChipEventCallback.h>
-#include <android/hardware/wifi/1.3/IWifiChip.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <VtsHalHidlTargetCallbackBase.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::wifi::V1_0::ChipModeId;
-using ::android::hardware::wifi::V1_0::IfaceType;
-using ::android::hardware::wifi::V1_0::WifiStatus;
-using ::android::hardware::wifi::V1_0::WifiDebugRingBufferStatus;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-using ::android::hardware::wifi::V1_2::IWifiChip;
-using ::android::hardware::wifi::V1_2::IWifiChipEventCallback;
-using ::android::hardware::Void;
-using ::android::sp;
-
-namespace {
-constexpr IWifiChip::TxPowerScenario kPowerScenarioBody =
-    IWifiChip::TxPowerScenario::ON_BODY_CELL_OFF;
-
-constexpr IWifiChip::TxPowerScenario kPowerScenarioVoiceCall =
-    IWifiChip::TxPowerScenario::VOICE_CALL;
-};  // namespace
-
-/**
- * Fixture to use for all Wifi chip HIDL interface tests.
- */
-class WifiChipHidlTest : public ::testing::TestWithParam<std::string> {
- public:
-  virtual void SetUp() override {
-      // Make sure test starts with a clean state
-      stopWifi(GetInstanceName());
-
-      wifi_chip_ = IWifiChip::castFrom(getWifiChip(GetInstanceName()));
-      ASSERT_NE(nullptr, wifi_chip_.get());
-  }
-
-  virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-  // A simple test implementation of WifiChipEventCallback.
-  class WifiChipEventCallback
-      : public ::testing::VtsHalHidlTargetCallbackBase<WifiChipHidlTest>,
-        public IWifiChipEventCallback {
-
-   public:
-    WifiChipEventCallback() {};
-
-    virtual ~WifiChipEventCallback() = default;
-
-    Return<void> onChipReconfigured(uint32_t modeId __unused) {
-      return Void();
-    };
-
-    Return<void> onChipReconfigureFailure(const WifiStatus& status __unused) {
-      return Void();
-    };
-
-    Return<void> onIfaceAdded(IfaceType type __unused, const hidl_string& name __unused) {
-      return Void();
-    };
-
-    Return<void> onIfaceRemoved(IfaceType type __unused, const hidl_string& name __unused) {
-      return Void();
-    };
-
-    Return<void> onDebugRingBufferDataAvailable(const WifiDebugRingBufferStatus& status __unused,
-        const hidl_vec<uint8_t>& data __unused) {
-      return Void();
-    };
-
-    Return<void> onDebugErrorAlert(int32_t errorCode __unused,
-        const hidl_vec<uint8_t>& debugData __unused) {
-      return Void();
-    };
-
-    Return<void> onRadioModeChange(const hidl_vec<RadioModeInfo>& radioModeInfos __unused) {
-      return Void();
-    };
-  };
-
- protected:
-  uint32_t configureChipForStaIfaceAndGetCapabilities() {
-    ChipModeId mode_id;
-    EXPECT_TRUE(
-        configureChipToSupportIfaceType(wifi_chip_, IfaceType::STA, &mode_id));
-
-    return getChipCapabilitiesLatest(wifi_chip_);
-  }
-
-  sp<IWifiChip> wifi_chip_;
-
- private:
-  std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * SelectTxPowerScenario_1_2_body
- * This test case tests the selectTxPowerScenario_1_2() API with SAR scenarios
- * newly defined in 1.2
- */
-TEST_P(WifiChipHidlTest, SelectTxPowerScenario_1_2_body) {
-  uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-  const auto& status =
-      HIDL_INVOKE(wifi_chip_, selectTxPowerScenario_1_2, kPowerScenarioBody);
-  if (caps & (IWifiChip::ChipCapabilityMask::SET_TX_POWER_LIMIT |
-              IWifiChip::ChipCapabilityMask::USE_BODY_HEAD_SAR)) {
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status.code);
-  } else {
-    EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-  }
-}
-
-/*
- * SelectTxPowerScenario_1_2_voiceCall
- * This test case tests the selectTxPowerScenario_1_2() API with previously
- * defined SAR scenarios
- */
-TEST_P(WifiChipHidlTest, SelectTxPowerScenario_1_2_voiceCall) {
-  uint32_t caps = configureChipForStaIfaceAndGetCapabilities();
-  const auto& status =
-      HIDL_INVOKE(wifi_chip_, selectTxPowerScenario_1_2, kPowerScenarioVoiceCall);
-  if (caps & (IWifiChip::ChipCapabilityMask::SET_TX_POWER_LIMIT)) {
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status.code);
-  } else {
-    EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-  }
-}
-
-/*
- * registerEventCallback_1_2
- * This test case tests the registerEventCallback_1_2() API which registers
- * a call back function with the hal implementation
- *
- * Note: it is not feasible to test the invocation of the call back function
- * since event is triggered internally in the HAL implementation, and can not be
- * triggered from the test case
- */
-TEST_P(WifiChipHidlTest, registerEventCallback_1_2) {
-    sp<WifiChipEventCallback> wifiChipEventCallback = new WifiChipEventCallback();
-    const auto& status =
-        HIDL_INVOKE(wifi_chip_, registerEventCallback_1_2, wifiChipEventCallback);
-
-    if (status.code != WifiStatusCode::SUCCESS) {
-        EXPECT_EQ(WifiStatusCode::ERROR_NOT_SUPPORTED, status.code);
-        return;
-    }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiChipHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiChipHidlTest,
-    testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-        ::android::hardware::wifi::V1_2::IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.2/vts/functional/wifi_nan_iface_hidl_test.cpp b/wifi/1.2/vts/functional/wifi_nan_iface_hidl_test.cpp
deleted file mode 100644
index f1c751eea1..0000000000
--- a/wifi/1.2/vts/functional/wifi_nan_iface_hidl_test.cpp
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Nanache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.2/IWifi.h>
-#include <android/hardware/wifi/1.2/IWifiNanIface.h>
-#include <android/hardware/wifi/1.2/IWifiNanIfaceEventCallback.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-#include <chrono>
-#include <condition_variable>
-#include <mutex>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using namespace ::android::hardware::wifi::V1_0;
-using namespace ::android::hardware::wifi::V1_2;
-
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::sp;
-
-#define TIMEOUT_PERIOD 10
-
-android::sp<android::hardware::wifi::V1_2::IWifiNanIface> getWifiNanIface_1_2(
-    const std::string& instance_name) {
-    return android::hardware::wifi::V1_2::IWifiNanIface::castFrom(
-        getWifiNanIface(instance_name));
-}
-
-/**
- * Fixture to use for all NAN Iface HIDL interface tests.
- */
-class WifiNanIfaceHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        if (!::testing::deviceSupportsFeature("android.hardware.wifi.aware"))
-            GTEST_SKIP() << "Skipping this test since NAN is not supported.";
-        // Make sure to start with a clean state
-        stopWifi(GetInstanceName());
-
-        iwifiNanIface = getWifiNanIface_1_2(GetInstanceName());
-        ASSERT_NE(nullptr, iwifiNanIface.get());
-        ASSERT_EQ(WifiStatusCode::SUCCESS,
-                  HIDL_INVOKE(iwifiNanIface, registerEventCallback_1_2,
-                              new WifiNanIfaceEventCallback(*this))
-                      .code);
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-    /* Used as a mechanism to inform the test about data/event callback */
-    inline void notify() {
-        std::unique_lock<std::mutex> lock(mtx_);
-        count_++;
-        cv_.notify_one();
-    }
-
-    enum CallbackType {
-        INVALID = -2,
-        ANY_CALLBACK = -1,
-
-        NOTIFY_CAPABILITIES_RESPONSE = 0,
-        NOTIFY_ENABLE_RESPONSE,
-        NOTIFY_CONFIG_RESPONSE,
-        NOTIFY_DISABLE_RESPONSE,
-        NOTIFY_START_PUBLISH_RESPONSE,
-        NOTIFY_STOP_PUBLISH_RESPONSE,
-        NOTIFY_START_SUBSCRIBE_RESPONSE,
-        NOTIFY_STOP_SUBSCRIBE_RESPONSE,
-        NOTIFY_TRANSMIT_FOLLOWUP_RESPONSE,
-        NOTIFY_CREATE_DATA_INTERFACE_RESPONSE,
-        NOTIFY_DELETE_DATA_INTERFACE_RESPONSE,
-        NOTIFY_INITIATE_DATA_PATH_RESPONSE,
-        NOTIFY_RESPOND_TO_DATA_PATH_INDICATION_RESPONSE,
-        NOTIFY_TERMINATE_DATA_PATH_RESPONSE,
-
-        EVENT_CLUSTER_EVENT,
-        EVENT_DISABLED,
-        EVENT_PUBLISH_TERMINATED,
-        EVENT_SUBSCRIBE_TERMINATED,
-        EVENT_MATCH,
-        EVENT_MATCH_EXPIRED,
-        EVENT_FOLLOWUP_RECEIVED,
-        EVENT_TRANSMIT_FOLLOWUP,
-        EVENT_DATA_PATH_REQUEST,
-        EVENT_DATA_PATH_CONFIRM,
-        EVENT_DATA_PATH_TERMINATED,
-        EVENT_DATA_PATH_CONFIRM_1_2,
-        EVENT_DATA_PATH_SCHEDULE_UPDATE
-    };
-
-    /* Test code calls this function to wait for data/event callback */
-    /* Must set callbackType = INVALID before call this function */
-    inline std::cv_status wait(CallbackType waitForCallbackType) {
-        std::unique_lock<std::mutex> lock(mtx_);
-
-        EXPECT_NE(INVALID, waitForCallbackType);  // can't ASSERT in a
-                                                  // non-void-returning method
-
-        std::cv_status status = std::cv_status::no_timeout;
-        auto now = std::chrono::system_clock::now();
-        while (count_ == 0) {
-            status = cv_.wait_until(lock,
-                                    now + std::chrono::seconds(TIMEOUT_PERIOD));
-            if (status == std::cv_status::timeout) return status;
-            if (waitForCallbackType != ANY_CALLBACK &&
-                callbackType != INVALID &&
-                callbackType != waitForCallbackType) {
-                count_--;
-            }
-        }
-        count_--;
-        return status;
-    }
-
-    class WifiNanIfaceEventCallback
-        : public ::android::hardware::wifi::V1_2::IWifiNanIfaceEventCallback {
-        WifiNanIfaceHidlTest& parent_;
-
-       public:
-        WifiNanIfaceEventCallback(WifiNanIfaceHidlTest& parent)
-            : parent_(parent){};
-
-        virtual ~WifiNanIfaceEventCallback() = default;
-
-        Return<void> notifyCapabilitiesResponse(
-            uint16_t id, const WifiNanStatus& status,
-            const NanCapabilities& capabilities) override {
-            parent_.callbackType = NOTIFY_CAPABILITIES_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-            parent_.capabilities = capabilities;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyEnableResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_ENABLE_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyConfigResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_CONFIG_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyDisableResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_DISABLE_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyStartPublishResponse(uint16_t id,
-                                                const WifiNanStatus& status,
-                                                uint8_t sessionId) override {
-            parent_.callbackType = NOTIFY_START_PUBLISH_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-            parent_.sessionId = sessionId;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyStopPublishResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_STOP_PUBLISH_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyStartSubscribeResponse(uint16_t id,
-                                                  const WifiNanStatus& status,
-                                                  uint8_t sessionId) override {
-            parent_.callbackType = NOTIFY_START_SUBSCRIBE_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-            parent_.sessionId = sessionId;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyStopSubscribeResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_STOP_SUBSCRIBE_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyTransmitFollowupResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_TRANSMIT_FOLLOWUP_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyCreateDataInterfaceResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_CREATE_DATA_INTERFACE_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyDeleteDataInterfaceResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_DELETE_DATA_INTERFACE_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyInitiateDataPathResponse(
-            uint16_t id, const WifiNanStatus& status,
-            uint32_t ndpInstanceId) override {
-            parent_.callbackType = NOTIFY_INITIATE_DATA_PATH_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-            parent_.ndpInstanceId = ndpInstanceId;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyRespondToDataPathIndicationResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType =
-                NOTIFY_RESPOND_TO_DATA_PATH_INDICATION_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> notifyTerminateDataPathResponse(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = NOTIFY_TERMINATE_DATA_PATH_RESPONSE;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventClusterEvent(
-            const NanClusterEventInd& event) override {
-            parent_.callbackType = EVENT_CLUSTER_EVENT;
-
-            parent_.nanClusterEventInd = event;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventDisabled(const WifiNanStatus& status) override {
-            parent_.callbackType = EVENT_DISABLED;
-
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventPublishTerminated(
-            uint8_t sessionId, const WifiNanStatus& status) override {
-            parent_.callbackType = EVENT_PUBLISH_TERMINATED;
-
-            parent_.sessionId = sessionId;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventSubscribeTerminated(
-            uint8_t sessionId, const WifiNanStatus& status) override {
-            parent_.callbackType = EVENT_SUBSCRIBE_TERMINATED;
-
-            parent_.sessionId = sessionId;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventMatch(const NanMatchInd& event) override {
-            parent_.callbackType = EVENT_MATCH;
-
-            parent_.nanMatchInd = event;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventMatchExpired(uint8_t discoverySessionId,
-                                       uint32_t peerId) override {
-            parent_.callbackType = EVENT_MATCH_EXPIRED;
-
-            parent_.sessionId = discoverySessionId;
-            parent_.peerId = peerId;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventFollowupReceived(
-            const NanFollowupReceivedInd& event) override {
-            parent_.callbackType = EVENT_FOLLOWUP_RECEIVED;
-
-            parent_.nanFollowupReceivedInd = event;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventTransmitFollowup(
-            uint16_t id, const WifiNanStatus& status) override {
-            parent_.callbackType = EVENT_TRANSMIT_FOLLOWUP;
-
-            parent_.id = id;
-            parent_.status = status;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventDataPathRequest(
-            const NanDataPathRequestInd& event) override {
-            parent_.callbackType = EVENT_DATA_PATH_REQUEST;
-
-            parent_.nanDataPathRequestInd = event;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventDataPathConfirm(
-            const ::android::hardware::wifi::V1_0::NanDataPathConfirmInd& event)
-            override {
-            parent_.callbackType = EVENT_DATA_PATH_CONFIRM;
-
-            parent_.nanDataPathConfirmInd = event;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventDataPathTerminated(uint32_t ndpInstanceId) override {
-            parent_.callbackType = EVENT_DATA_PATH_TERMINATED;
-
-            parent_.ndpInstanceId = ndpInstanceId;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventDataPathConfirm_1_2(
-            const ::android::hardware::wifi::V1_2::NanDataPathConfirmInd& event)
-            override {
-            parent_.callbackType = EVENT_DATA_PATH_CONFIRM_1_2;
-
-            parent_.nanDataPathConfirmInd_1_2 = event;
-
-            parent_.notify();
-            return Void();
-        }
-
-        Return<void> eventDataPathScheduleUpdate(
-            const NanDataPathScheduleUpdateInd& event) override {
-            parent_.callbackType = EVENT_DATA_PATH_SCHEDULE_UPDATE;
-
-            parent_.nanDataPathScheduleUpdateInd = event;
-
-            parent_.notify();
-            return Void();
-        }
-    };
-
-   private:
-    // synchronization objects
-    std::mutex mtx_;
-    std::condition_variable cv_;
-    int count_ = 0;
-
-   protected:
-    android::sp<::android::hardware::wifi::V1_2::IWifiNanIface> iwifiNanIface;
-
-    // Data from IWifiNanIfaceEventCallback callbacks: this is the collection of
-    // all arguments to all callbacks. They are set by the callback
-    // (notifications or events) and can be retrieved by tests.
-    CallbackType callbackType;
-    uint16_t id;
-    WifiNanStatus status;
-    NanCapabilities capabilities;
-    uint8_t sessionId;
-    uint32_t ndpInstanceId;
-    NanClusterEventInd nanClusterEventInd;
-    NanMatchInd nanMatchInd;
-    uint32_t peerId;
-    NanFollowupReceivedInd nanFollowupReceivedInd;
-    NanDataPathRequestInd nanDataPathRequestInd;
-    ::android::hardware::wifi::V1_0::NanDataPathConfirmInd
-        nanDataPathConfirmInd;
-    ::android::hardware::wifi::V1_2::NanDataPathConfirmInd
-        nanDataPathConfirmInd_1_2;
-    NanDataPathScheduleUpdateInd nanDataPathScheduleUpdateInd;
-
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the IWifiNanIface proxy object is
- * successfully created.
- */
-TEST_P(WifiNanIfaceHidlTest, Create) {
-    // The creation of a proxy object is tested as part of SetUp method.
-}
-
-/*
- * enableRequest_1_2InvalidArgs: validate that fails with invalid arguments
- */
-TEST_P(WifiNanIfaceHidlTest, enableRequest_1_2InvalidArgs) {
-    uint16_t inputCmdId = 10;
-    callbackType = INVALID;
-    NanEnableRequest nanEnableRequest = {};
-    NanConfigRequestSupplemental nanConfigRequestSupp = {};
-    const auto& halStatus =
-        HIDL_INVOKE(iwifiNanIface, enableRequest_1_2, inputCmdId,
-                    nanEnableRequest, nanConfigRequestSupp);
-    if (halStatus.code != WifiStatusCode::ERROR_NOT_SUPPORTED) {
-        ASSERT_EQ(WifiStatusCode::SUCCESS, halStatus.code);
-
-        // wait for a callback
-        ASSERT_EQ(std::cv_status::no_timeout, wait(NOTIFY_ENABLE_RESPONSE));
-        ASSERT_EQ(NOTIFY_ENABLE_RESPONSE, callbackType);
-        ASSERT_EQ(id, inputCmdId);
-        ASSERT_EQ(status.status, NanStatusType::INVALID_ARGS);
-    }
-}
-
-/*
- * enableRequest_1_2ShimInvalidArgs: validate that fails with invalid arguments
- * to the shim
- */
-TEST_P(WifiNanIfaceHidlTest, enableRequest_1_2ShimInvalidArgs) {
-    uint16_t inputCmdId = 10;
-    NanEnableRequest nanEnableRequest = {};
-    nanEnableRequest.configParams.numberOfPublishServiceIdsInBeacon =
-        128;  // must be <= 127
-    NanConfigRequestSupplemental nanConfigRequestSupp = {};
-    const auto& halStatus =
-        HIDL_INVOKE(iwifiNanIface, enableRequest_1_2, inputCmdId,
-                    nanEnableRequest, nanConfigRequestSupp);
-    if (halStatus.code != WifiStatusCode::ERROR_NOT_SUPPORTED) {
-        ASSERT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, halStatus.code);
-    }
-}
-
-/*
- * configRequest_1_2InvalidArgs: validate that fails with invalid arguments
- */
-TEST_P(WifiNanIfaceHidlTest, configRequest_1_2InvalidArgs) {
-    uint16_t inputCmdId = 10;
-    callbackType = INVALID;
-    NanConfigRequest nanConfigRequest = {};
-    NanConfigRequestSupplemental nanConfigRequestSupp = {};
-    const auto& halStatus =
-        HIDL_INVOKE(iwifiNanIface, configRequest_1_2, inputCmdId,
-                    nanConfigRequest, nanConfigRequestSupp);
-
-    if (halStatus.code != WifiStatusCode::ERROR_NOT_SUPPORTED) {
-        ASSERT_EQ(WifiStatusCode::SUCCESS, halStatus.code);
-
-        // wait for a callback
-        ASSERT_EQ(std::cv_status::no_timeout, wait(NOTIFY_CONFIG_RESPONSE));
-        ASSERT_EQ(NOTIFY_CONFIG_RESPONSE, callbackType);
-        ASSERT_EQ(id, inputCmdId);
-        ASSERT_EQ(status.status, NanStatusType::INVALID_ARGS);
-    }
-}
-
-/*
- * configRequest_1_2ShimInvalidArgs: validate that fails with invalid arguments
- * to the shim
- */
-TEST_P(WifiNanIfaceHidlTest, configRequest_1_2ShimInvalidArgs) {
-    uint16_t inputCmdId = 10;
-    NanConfigRequest nanConfigRequest = {};
-    nanConfigRequest.numberOfPublishServiceIdsInBeacon = 128;  // must be <= 127
-    NanConfigRequestSupplemental nanConfigRequestSupp = {};
-    const auto& halStatus =
-        HIDL_INVOKE(iwifiNanIface, configRequest_1_2, inputCmdId,
-                    nanConfigRequest, nanConfigRequestSupp);
-    if (halStatus.code != WifiStatusCode::ERROR_NOT_SUPPORTED) {
-        ASSERT_EQ(WifiStatusCode::ERROR_INVALID_ARGS, halStatus.code);
-    }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiNanIfaceHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiNanIfaceHidlTest,
-    testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-        ::android::hardware::wifi::V1_2::IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/1.2/vts/functional/wifi_sta_iface_hidl_test.cpp b/wifi/1.2/vts/functional/wifi_sta_iface_hidl_test.cpp
deleted file mode 100644
index cfa67d43bb..0000000000
--- a/wifi/1.2/vts/functional/wifi_sta_iface_hidl_test.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Staache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <numeric>
-#include <vector>
-
-#include <android-base/logging.h>
-
-#include <android/hardware/wifi/1.2/IWifi.h>
-#include <android/hardware/wifi/1.2/IWifiStaIface.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "wifi_hidl_call_util.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::wifi::V1_0::CommandId;
-using ::android::hardware::wifi::V1_0::WifiStatusCode;
-using ::android::hardware::wifi::V1_2::IWifiStaIface;
-
-/**
- * Fixture to use for all STA Iface HIDL interface tests.
- */
-class WifiStaIfaceHidlTest : public ::testing::TestWithParam<std::string> {
-   public:
-    virtual void SetUp() override {
-        // Make sure to start with a clean state
-        stopWifi(GetInstanceName());
-
-        wifi_sta_iface_ =
-            IWifiStaIface::castFrom(getWifiStaIface(GetInstanceName()));
-        ASSERT_NE(nullptr, wifi_sta_iface_.get());
-    }
-
-    virtual void TearDown() override { stopWifi(GetInstanceName()); }
-
-   protected:
-    bool isCapabilitySupported(IWifiStaIface::StaIfaceCapabilityMask cap_mask) {
-        const auto& status_and_caps =
-            HIDL_INVOKE(wifi_sta_iface_, getCapabilities);
-        EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_caps.first.code);
-        return (status_and_caps.second & cap_mask) != 0;
-    }
-
-    sp<IWifiStaIface> wifi_sta_iface_;
-
-   private:
-    std::string GetInstanceName() { return GetParam(); }
-};
-
-/*
- * SetMacAddress:
- * Ensures that calls to set MAC address will return a success status
- * code.
- */
-TEST_P(WifiStaIfaceHidlTest, SetMacAddress) {
-    const android::hardware::hidl_array<uint8_t, 6> kMac{
-        std::array<uint8_t, 6>{{0x12, 0x22, 0x33, 0x52, 0x10, 0x41}}};
-    EXPECT_EQ(WifiStatusCode::SUCCESS,
-              HIDL_INVOKE(wifi_sta_iface_, setMacAddress, kMac).code);
-}
-
-/*
- * ReadApfPacketFilterData:
- * Ensures that we can read the APF working memory when supported.
- *
- * TODO: Test disabled because we can't even test reading and writing the APF
- * memory while the interface is in disconnected state (b/73804303#comment25).
- * There's a pending bug on VTS infra to add such support (b/32974062).
- * TODO: We can't execute APF opcodes from this test because there's no way
- * to loop test packets through the wifi firmware (b/73804303#comment29).
- */
-TEST_P(WifiStaIfaceHidlTest, DISABLED_ReadApfPacketFilterData) {
-    if (!isCapabilitySupported(IWifiStaIface::StaIfaceCapabilityMask::APF)) {
-        // Disable test if APF packet filer is not supported.
-        LOG(WARNING) << "TEST SKIPPED: APF packet filtering not supported";
-        return;
-    }
-
-    const auto& status_and_caps =
-        HIDL_INVOKE(wifi_sta_iface_, getApfPacketFilterCapabilities);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_caps.first.code);
-    LOG(WARNING) << "StaApfPacketFilterCapabilities: version="
-                 << status_and_caps.second.version
-                 << " maxLength=" << status_and_caps.second.maxLength;
-
-    const CommandId kCmd = 0;  // Matches what WifiVendorHal.java uses.
-    const uint32_t kDataSize =
-        std::min(status_and_caps.second.maxLength, static_cast<uint32_t>(500));
-
-    // Create a buffer and fill it with some values.
-    std::vector<uint8_t> data(kDataSize);
-    std::iota(data.begin(), data.end(), 0);
-
-    EXPECT_EQ(
-        HIDL_INVOKE(wifi_sta_iface_, installApfPacketFilter, kCmd, data).code,
-        WifiStatusCode::SUCCESS);
-    const auto& status_and_data =
-        HIDL_INVOKE(wifi_sta_iface_, readApfPacketFilterData);
-    EXPECT_EQ(WifiStatusCode::SUCCESS, status_and_data.first.code);
-
-    EXPECT_EQ(status_and_data.second, data);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(WifiStaIfaceHidlTest);
-INSTANTIATE_TEST_SUITE_P(
-    PerInstance, WifiStaIfaceHidlTest,
-    testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-        ::android::hardware::wifi::V1_2::IWifi::descriptor)),
-    android::hardware::PrintInstanceNameToString);
diff --git a/wifi/aidl/default/aidl_callback_util.h b/wifi/aidl/default/aidl_callback_util.h
index d077683c49..4cd0129f10 100644
--- a/wifi/aidl/default/aidl_callback_util.h
+++ b/wifi/aidl/default/aidl_callback_util.h
@@ -43,7 +43,10 @@ class AidlCallbackHandler {
     AidlCallbackHandler() {
         death_handler_ = AIBinder_DeathRecipient_new(AidlCallbackHandler::onCallbackDeath);
     }
-    ~AidlCallbackHandler() { invalidate(); }
+
+    // Instances of this class are not dynamically allocated, so the destructor
+    // will only be called on program exit.
+    ~AidlCallbackHandler() = default;
 
     bool addCallback(const std::shared_ptr<CallbackType>& cb) {
         if (cb == nullptr) {
@@ -103,6 +106,7 @@ class AidlCallbackHandler {
     // can only call a static function, so use the cookie to find the
     // proper handler and route the request there.
     static void onCallbackDeath(void* cookie) {
+        LOG(INFO) << "Callback died. cookie=" << cookie;
         std::unique_lock<std::mutex> lk(callback_handler_lock_);
         auto cbQuery = callback_handler_map_.find(cookie);
         if (cbQuery == callback_handler_map_.end()) {
diff --git a/wifi/aidl/default/wifi_chip.cpp b/wifi/aidl/default/wifi_chip.cpp
index 045e07d43e..7df168e365 100644
--- a/wifi/aidl/default/wifi_chip.cpp
+++ b/wifi/aidl/default/wifi_chip.cpp
@@ -1917,17 +1917,17 @@ void WifiChip::invalidateAndClearBridgedApAll() {
 void WifiChip::deleteApIface(const std::string& if_name) {
     if (if_name.empty()) return;
     // delete bridged interfaces if any
-    const auto iface = findUsingName(ap_ifaces_, if_name);
-    if (!iface->usesMlo()) {
-        for (auto const& it : br_ifaces_ap_instances_) {
-            if (it.first == if_name) {
+    for (auto const& it : br_ifaces_ap_instances_) {
+        if (it.first == if_name) {
+            const auto iface = findUsingName(ap_ifaces_, if_name);
+            if (iface.get() && !iface->usesMlo()) {
                 for (auto const& instance : it.second) {
                     iface_util_->removeIfaceFromBridge(if_name, instance);
                     legacy_hal_.lock()->deleteVirtualInterface(instance);
                 }
                 iface_util_->deleteBridge(if_name);
                 br_ifaces_ap_instances_.erase(if_name);
-                // ifname is bridged AP, return here.
+                // ifname is non mlo bridged AP, return here.
                 return;
             }
         }
diff --git a/wifi/aidl/vts/functional/wifi_ap_iface_aidl_test.cpp b/wifi/aidl/vts/functional/wifi_ap_iface_aidl_test.cpp
index a58fd5bcdd..4b2a2ff350 100644
--- a/wifi/aidl/vts/functional/wifi_ap_iface_aidl_test.cpp
+++ b/wifi/aidl/vts/functional/wifi_ap_iface_aidl_test.cpp
@@ -37,7 +37,7 @@ class WifiApIfaceAidlTest : public testing::TestWithParam<std::string> {
                 "/system/bin/cmd wifi get-softap-supported-features",
                 "wifi_softap_bridged_ap_supported");
         stopWifiService(getInstanceName());
-
+        sleep(1);  // Ensure that all chips/interfaces are invalidated.
         wifi_chip_ = getWifiChip(getInstanceName());
         ASSERT_NE(nullptr, wifi_chip_.get());
 
diff --git a/wifi/aidl/vts/functional/wifi_sta_iface_aidl_test.cpp b/wifi/aidl/vts/functional/wifi_sta_iface_aidl_test.cpp
index b2a1304105..3593abaf57 100644
--- a/wifi/aidl/vts/functional/wifi_sta_iface_aidl_test.cpp
+++ b/wifi/aidl/vts/functional/wifi_sta_iface_aidl_test.cpp
@@ -506,7 +506,9 @@ TEST_P(WifiStaIfaceAidlTest, TwtSessionSetup) {
     twtRequest.maxWakeDurationUs = twt_capabilities.maxWakeDurationUs;
     twtRequest.minWakeIntervalUs = twt_capabilities.minWakeIntervalUs;
     twtRequest.maxWakeIntervalUs = twt_capabilities.maxWakeIntervalUs;
-    EXPECT_TRUE(wifi_sta_iface_->twtSessionSetup(1, twtRequest).isOk());
+
+    status = wifi_sta_iface_->twtSessionSetup(1, twtRequest);
+    EXPECT_TRUE(status.isOk() || checkStatusCode(&status, WifiStatusCode::ERROR_NOT_SUPPORTED));
 }
 
 /**
@@ -520,9 +522,10 @@ TEST_P(WifiStaIfaceAidlTest, TwtSessionGetStats) {
         GTEST_SKIP() << "TWT is not supported";
     }
 
+    auto status = wifi_sta_iface_->twtSessionGetStats(1, 10);
     // Expecting a IWifiStaIfaceEventCallback.onTwtFailure() with INVALID_PARAMS
-    // as the error code.
-    EXPECT_TRUE(wifi_sta_iface_->twtSessionGetStats(1, 10).isOk());
+    // as the error code, or that the call returns WifiStatusCode::ERROR_INVALID_ARGS.
+    EXPECT_TRUE(status.isOk() || checkStatusCode(&status, WifiStatusCode::ERROR_INVALID_ARGS));
 }
 
 /**
@@ -536,9 +539,10 @@ TEST_P(WifiStaIfaceAidlTest, TwtSessionTeardown) {
         GTEST_SKIP() << "TWT is not supported";
     }
 
+    auto status = wifi_sta_iface_->twtSessionTeardown(1, 10);
     // Expecting a IWifiStaIfaceEventCallback.onTwtFailure() with INVALID_PARAMS
-    // as the error code.
-    EXPECT_TRUE(wifi_sta_iface_->twtSessionTeardown(1, 10).isOk());
+    // as the error code, or that the call returns WifiStatusCode::ERROR_INVALID_ARGS.
+    EXPECT_TRUE(status.isOk() || checkStatusCode(&status, WifiStatusCode::ERROR_INVALID_ARGS));
 }
 
 /**
@@ -564,8 +568,8 @@ TEST_P(WifiStaIfaceAidlTest, TwtSessionUpdate) {
         GTEST_SKIP() << "TwtSessionUpdate is not supported";
     }
     // Expecting a IWifiStaIfaceEventCallback.onTwtFailure() with INVALID_PARAMS
-    // as the error code.
-    EXPECT_TRUE(status.isOk());
+    // as the error code, or that the call returns WifiStatusCode::ERROR_INVALID_ARGS.
+    EXPECT_TRUE(status.isOk() || checkStatusCode(&status, WifiStatusCode::ERROR_INVALID_ARGS));
 }
 
 /**
@@ -584,8 +588,8 @@ TEST_P(WifiStaIfaceAidlTest, TwtSessionSuspend) {
         GTEST_SKIP() << "TwtSessionSuspend is not supported";
     }
     // Expecting a IWifiStaIfaceEventCallback.onTwtFailure() with INVALID_PARAMS
-    // as the error code.
-    EXPECT_TRUE(status.isOk());
+    // as the error code, or that the call returns WifiStatusCode::ERROR_INVALID_ARGS.
+    EXPECT_TRUE(status.isOk() || checkStatusCode(&status, WifiStatusCode::ERROR_INVALID_ARGS));
 }
 
 /**
@@ -604,8 +608,8 @@ TEST_P(WifiStaIfaceAidlTest, TwtSessionResume) {
         GTEST_SKIP() << "TwtSessionResume is not supported";
     }
     // Expecting a IWifiStaIfaceEventCallback.onTwtFailure() with INVALID_PARAMS
-    // as the error code.
-    EXPECT_TRUE(status.isOk());
+    // as the error code, or that the call returns WifiStatusCode::ERROR_INVALID_ARGS.
+    EXPECT_TRUE(status.isOk() || checkStatusCode(&status, WifiStatusCode::ERROR_INVALID_ARGS));
 }
 
 /*
diff --git a/wifi/legacy_headers/include/hardware_legacy/wifi_hal.h b/wifi/legacy_headers/include/hardware_legacy/wifi_hal.h
index 4cabbe49a4..c78fb7d373 100644
--- a/wifi/legacy_headers/include/hardware_legacy/wifi_hal.h
+++ b/wifi/legacy_headers/include/hardware_legacy/wifi_hal.h
@@ -75,15 +75,15 @@ typedef enum {
 
 /* Pre selected Power scenarios to be applied from BDF file */
 typedef enum {
-    WIFI_POWER_SCENARIO_INVALID = -2,
-    WIFI_POWER_SCENARIO_DEFAULT = -1,
-    WIFI_POWER_SCENARIO_VOICE_CALL = 0,
+    WIFI_POWER_SCENARIO_INVALID          = -2,
+    WIFI_POWER_SCENARIO_DEFAULT          = -1,
+    WIFI_POWER_SCENARIO_VOICE_CALL       = 0,
     WIFI_POWER_SCENARIO_ON_HEAD_CELL_OFF = 1,
-    WIFI_POWER_SCENARIO_ON_HEAD_CELL_ON = 2,
+    WIFI_POWER_SCENARIO_ON_HEAD_CELL_ON  = 2,
     WIFI_POWER_SCENARIO_ON_BODY_CELL_OFF = 3,
-    WIFI_POWER_SCENARIO_ON_BODY_CELL_ON = 4,
-    WIFI_POWER_SCENARIO_ON_BODY_BT = 5,
-    WIFI_POWER_SCENARIO_ON_HEAD_HOTSPOT = 6,
+    WIFI_POWER_SCENARIO_ON_BODY_CELL_ON  = 4,
+    WIFI_POWER_SCENARIO_ON_BODY_BT       = 5,
+    WIFI_POWER_SCENARIO_ON_HEAD_HOTSPOT  = 6,
     WIFI_POWER_SCENARIO_ON_HEAD_HOTSPOT_MMW = 7,
     WIFI_POWER_SCENARIO_ON_BODY_CELL_ON_BT = 8,
     WIFI_POWER_SCENARIO_ON_BODY_HOTSPOT = 9,
@@ -107,10 +107,7 @@ typedef enum {
     WIFI_POWER_SCENARIO_ON_BODY_BT_UNFOLDED_CAP = 27,
     WIFI_POWER_SCENARIO_ON_BODY_CELL_ON_UNFOLDED_CAP = 28,
     WIFI_POWER_SCENARIO_ON_BODY_CELL_ON_BT_UNFOLDED_CAP = 29,
-    WIFI_POWER_SCENARIO_ON_BODY_CELL_OFF_CAP = 30,
-    WIFI_POWER_SCENARIO_ON_BODY_BT_CAP = 31,
-    WIFI_POWER_SCENARIO_ON_BODY_CELL_ON_CAP = 32,
-    WIFI_POWER_SCENARIO_ON_BODY_CELL_ON_BT_CAP = 33,
+    WIFI_POWER_SCENARIO_ON_BODY_VIDEO_RECORDING = 30,
 } wifi_power_scenario;
 
 typedef enum {
diff --git a/wifi/supplicant/1.0/vts/functional/Android.bp b/wifi/supplicant/1.0/vts/functional/Android.bp
index 353e57bc4d..4cc56ed284 100644
--- a/wifi/supplicant/1.0/vts/functional/Android.bp
+++ b/wifi/supplicant/1.0/vts/functional/Android.bp
@@ -41,59 +41,3 @@ cc_library_static {
         "libwifi-system-iface",
     ],
 }
-
-cc_test {
-    name: "VtsHalWifiSupplicantV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    tidy_timeout_srcs: [
-        "supplicant_sta_network_hidl_test.cpp",
-    ],
-    srcs: [
-        "supplicant_hidl_test.cpp",
-        "supplicant_sta_iface_hidl_test.cpp",
-        "supplicant_sta_network_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "android.hardware.wifi.supplicant@1.0",
-        "android.hardware.wifi.supplicant@1.1",
-        "android.hardware.wifi.supplicant@1.2",
-        "android.hardware.wifi.supplicant@1.3",
-        "android.hardware.wifi.supplicant@1.4",
-        "android.hardware.wifi@1.0",
-        "libgmock",
-        "libwifi-system",
-        "libwifi-system-iface",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
-
-cc_test {
-    name: "VtsHalWifiSupplicantP2pV1_0TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    tidy_timeout_srcs: [
-        "supplicant_p2p_iface_hidl_test.cpp",
-    ],
-    srcs: [
-        "VtsHalWifiSupplicantP2pV1_0TargetTest.cpp",
-        "supplicant_p2p_iface_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "android.hardware.wifi.supplicant@1.0",
-        "android.hardware.wifi.supplicant@1.1",
-        "android.hardware.wifi@1.0",
-        "libgmock",
-        "libwifi-system",
-        "libwifi-system-iface",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/wifi/supplicant/1.0/vts/functional/supplicant_hidl_call_util.h b/wifi/supplicant/1.0/vts/functional/supplicant_hidl_call_util.h
deleted file mode 100644
index 3fa6f9d0b9..0000000000
--- a/wifi/supplicant/1.0/vts/functional/supplicant_hidl_call_util.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// This file is copied from
-// hardware/interfaces/wifi/1.0/vts/functional/wifi_hidl_call_util.h
-// Please make sure these two file are consistent.
-
-#pragma once
-
-#include <functional>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-namespace {
-namespace detail {
-template <typename>
-struct functionArgSaver;
-
-// Provides a std::function that takes one argument, and a buffer
-// wherein the function will store its argument. The buffer has
-// the same type as the argument, but with const and reference
-// modifiers removed.
-template <typename ArgT>
-struct functionArgSaver<std::function<void(ArgT)>> final {
-    using StorageT = typename std::remove_const<
-        typename std::remove_reference<ArgT>::type>::type;
-
-    std::function<void(ArgT)> saveArgs = [this](ArgT arg) {
-        this->saved_values = arg;
-    };
-
-    StorageT saved_values;
-};
-
-// Provides a std::function that takes two arguments, and a buffer
-// wherein the function will store its arguments. The buffer is a
-// std::pair, whose elements have the same types as the arguments
-// (but with const and reference modifiers removed).
-template <typename Arg1T, typename Arg2T>
-struct functionArgSaver<std::function<void(Arg1T, Arg2T)>> final {
-    using StorageT =
-        std::pair<typename std::remove_const<
-                      typename std::remove_reference<Arg1T>::type>::type,
-                  typename std::remove_const<
-                      typename std::remove_reference<Arg2T>::type>::type>;
-
-    std::function<void(Arg1T, Arg2T)> saveArgs = [this](Arg1T arg1,
-                                                        Arg2T arg2) {
-        this->saved_values = {arg1, arg2};
-    };
-
-    StorageT saved_values;
-};
-
-// Provides a std::function that takes three or more arguments, and a
-// buffer wherein the function will store its arguments. The buffer is a
-// std::tuple whose elements have the same types as the arguments (but
-// with const and reference modifiers removed).
-template <typename... ArgT>
-struct functionArgSaver<std::function<void(ArgT...)>> final {
-    using StorageT = std::tuple<typename std::remove_const<
-        typename std::remove_reference<ArgT>::type>::type...>;
-
-    std::function<void(ArgT...)> saveArgs = [this](ArgT... arg) {
-        this->saved_values = {arg...};
-    };
-
-    StorageT saved_values;
-};
-
-// Invokes |method| on |object|, providing |method| a CallbackT as the
-// final argument. Returns a copy of the parameters that |method| provided
-// to CallbackT. (The parameters are returned by value.)
-template <typename CallbackT, typename MethodT, typename ObjectT,
-          typename... ArgT>
-typename functionArgSaver<CallbackT>::StorageT invokeMethod(
-    MethodT method, ObjectT object, ArgT&&... methodArg) {
-    functionArgSaver<CallbackT> result_buffer;
-    const auto& res = ((*object).*method)(std::forward<ArgT>(methodArg)...,
-                                          result_buffer.saveArgs);
-    EXPECT_TRUE(res.isOk());
-    return result_buffer.saved_values;
-}
-}  // namespace detail
-}  // namespace
-
-// Invokes |method| on |strong_pointer|, passing provided arguments through to
-// |method|.
-//
-// Returns either:
-// - A copy of the result callback parameter (for callbacks with a single
-//   parameter), OR
-// - A pair containing a copy of the result callback parameters (for callbacks
-//   with two parameters), OR
-// - A tuple containing a copy of the result callback paramters (for callbacks
-//   with three or more parameters).
-//
-// Example usage:
-//   EXPECT_EQ(WifiStatusCode::SUCCESS,
-//       HIDL_INVOKE(strong_pointer, methodReturningWifiStatus).code);
-//   EXPECT_EQ(WifiStatusCode::SUCCESS,
-//       HIDL_INVOKE(strong_pointer, methodReturningWifiStatusAndOneMore)
-//         .first.code);
-//   EXPECT_EQ(WifiStatusCode::SUCCESS, std::get<0>(
-//       HIDL_INVOKE(strong_pointer, methodReturningWifiStatusAndTwoMore))
-//         .code);
-#define HIDL_INVOKE(strong_pointer, method, ...)                              \
-    (detail::invokeMethod<                                                    \
-        std::remove_reference<decltype(*strong_pointer)>::type::method##_cb>( \
-        &std::remove_reference<decltype(*strong_pointer)>::type::method,      \
-        strong_pointer, ##__VA_ARGS__))
diff --git a/wifi/supplicant/1.0/vts/functional/supplicant_hidl_test.cpp b/wifi/supplicant/1.0/vts/functional/supplicant_hidl_test.cpp
deleted file mode 100644
index da3ff3a29b..0000000000
--- a/wifi/supplicant/1.0/vts/functional/supplicant_hidl_test.cpp
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.0/ISupplicant.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "supplicant_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::wifi::supplicant::V1_0::IfaceType;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantIface;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::V1_0::IWifi;
-
-class SupplicantHidlTest
-    : public ::testing::TestWithParam<std::tuple<std::string, std::string>> {
-   public:
-    virtual void SetUp() override {
-        wifi_instance_name_ = std::get<0>(GetParam());
-        supplicant_instance_name_ = std::get<1>(GetParam());
-
-        // Stop & wait for wifi to shutdown.
-        ASSERT_TRUE(stopWifiFramework(wifi_instance_name_));
-
-        std::system("/system/bin/start");
-        ASSERT_TRUE(waitForFrameworkReady());
-        isP2pOn_ =
-            testing::deviceSupportsFeature("android.hardware.wifi.direct");
-        stopSupplicant(wifi_instance_name_);
-        startSupplicantAndWaitForHidlService(wifi_instance_name_,
-                                             supplicant_instance_name_);
-        supplicant_ = getSupplicant(supplicant_instance_name_, isP2pOn_);
-        ASSERT_NE(supplicant_.get(), nullptr);
-    }
-
-    virtual void TearDown() override {
-        stopSupplicant(wifi_instance_name_);
-        // Start Wi-Fi
-        startWifiFramework();
-    }
-
-   protected:
-    // ISupplicant object used for all tests in this fixture.
-    sp<ISupplicant> supplicant_;
-    bool isP2pOn_ = false;
-    std::string wifi_instance_name_;
-    std::string supplicant_instance_name_;
-};
-
-/*
- * Create:
- * Ensures that an instance of the ISupplicant proxy object is
- * successfully created.
- */
-TEST_P(SupplicantHidlTest, Create) {
-    // Stop the proxy object created in setup.
-    stopSupplicant(wifi_instance_name_);
-    startSupplicantAndWaitForHidlService(wifi_instance_name_,
-                                         supplicant_instance_name_);
-    EXPECT_NE(nullptr,
-              getSupplicant(supplicant_instance_name_, isP2pOn_).get());
-}
-
-/*
- * ListInterfaces
- */
-TEST_P(SupplicantHidlTest, ListInterfaces) {
-    std::vector<ISupplicant::IfaceInfo> ifaces;
-    supplicant_->listInterfaces(
-        [&](const SupplicantStatus& status,
-            const hidl_vec<ISupplicant::IfaceInfo>& hidl_ifaces) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            ifaces = hidl_ifaces;
-        });
-
-    EXPECT_NE(ifaces.end(),
-              std::find_if(ifaces.begin(), ifaces.end(), [](const auto& iface) {
-                  return iface.type == IfaceType::STA;
-              }));
-    if (isP2pOn_) {
-        EXPECT_NE(
-            ifaces.end(),
-            std::find_if(ifaces.begin(), ifaces.end(), [](const auto& iface) {
-                return iface.type == IfaceType::P2P;
-            }));
-    }
-}
-
-/*
- * GetInterface
- */
-TEST_P(SupplicantHidlTest, GetInterface) {
-    std::vector<ISupplicant::IfaceInfo> ifaces;
-    supplicant_->listInterfaces(
-        [&](const SupplicantStatus& status,
-            const hidl_vec<ISupplicant::IfaceInfo>& hidl_ifaces) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            ifaces = hidl_ifaces;
-        });
-
-    ASSERT_NE(0u, ifaces.size());
-    supplicant_->getInterface(
-        ifaces[0],
-        [&](const SupplicantStatus& status, const sp<ISupplicantIface>& iface) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_NE(nullptr, iface.get());
-        });
-}
-
-/*
- * SetDebugParams
- */
-TEST_P(SupplicantHidlTest, SetDebugParams) {
-    bool show_timestamp = true;
-    bool show_keys = true;
-    ISupplicant::DebugLevel level = ISupplicant::DebugLevel::EXCESSIVE;
-
-    supplicant_->setDebugParams(level,
-                                show_timestamp,  // show timestamps
-                                show_keys,       // show keys
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-}
-
-/*
- * GetDebugLevel
- */
-TEST_P(SupplicantHidlTest, GetDebugLevel) {
-    bool show_timestamp = true;
-    bool show_keys = true;
-    ISupplicant::DebugLevel level = ISupplicant::DebugLevel::EXCESSIVE;
-
-    supplicant_->setDebugParams(level,
-                                show_timestamp,  // show timestamps
-                                show_keys,       // show keys
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-    EXPECT_EQ(level, supplicant_->getDebugLevel());
-}
-
-/*
- * IsDebugShowTimestampEnabled
- */
-TEST_P(SupplicantHidlTest, IsDebugShowTimestampEnabled) {
-    bool show_timestamp = true;
-    bool show_keys = true;
-    ISupplicant::DebugLevel level = ISupplicant::DebugLevel::EXCESSIVE;
-
-    supplicant_->setDebugParams(level,
-                                show_timestamp,  // show timestamps
-                                show_keys,       // show keys
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-    EXPECT_EQ(show_timestamp, supplicant_->isDebugShowTimestampEnabled());
-}
-
-/*
- * IsDebugShowKeysEnabled
- */
-TEST_P(SupplicantHidlTest, IsDebugShowKeysEnabled) {
-    bool show_timestamp = true;
-    bool show_keys = true;
-    ISupplicant::DebugLevel level = ISupplicant::DebugLevel::EXCESSIVE;
-
-    supplicant_->setDebugParams(level,
-                                show_timestamp,  // show timestamps
-                                show_keys,       // show keys
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-    EXPECT_EQ(show_keys, supplicant_->isDebugShowKeysEnabled());
-}
-
-/*
- * SetConcurrenyPriority
- */
-TEST_P(SupplicantHidlTest, SetConcurrencyPriority) {
-    supplicant_->setConcurrencyPriority(
-        IfaceType::STA, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    if (isP2pOn_) {
-        supplicant_->setConcurrencyPriority(
-            IfaceType::P2P, [](const SupplicantStatus& status) {
-                EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            });
-    }
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantHidlTest,
-    testing::Combine(
-        testing::ValuesIn(
-            android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            ISupplicant::descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.0/vts/functional/supplicant_p2p_iface_hidl_test.cpp b/wifi/supplicant/1.0/vts/functional/supplicant_p2p_iface_hidl_test.cpp
deleted file mode 100644
index 325f355f4a..0000000000
--- a/wifi/supplicant/1.0/vts/functional/supplicant_p2p_iface_hidl_test.cpp
+++ /dev/null
@@ -1,662 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.0/ISupplicantP2pIface.h>
-
-#include "supplicant_hidl_call_util.h"
-#include "supplicant_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_array;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::wifi::supplicant::V1_0::IfaceType;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantP2pIface;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantP2pIfaceCallback;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantNetworkId;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::V1_0::IWifi;
-
-namespace {
-constexpr uint8_t kTestSsidPostfix[] = {'t', 'e', 's', 't'};
-constexpr uint8_t kTestMacAddr[] = {0x56, 0x67, 0x67, 0xf4, 0x56, 0x92};
-constexpr uint8_t kTestPeerMacAddr[] = {0x56, 0x67, 0x55, 0xf4, 0x56, 0x92};
-constexpr uint8_t kTestBonjourServiceQuery[] = {'t', 'e', 's', 't', 'q',
-                                                'u', 'e', 'r', 'y'};
-constexpr uint8_t kTestBonjourServiceResponse[] = {
-    't', 'e', 's', 't', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e'};
-constexpr uint8_t kTestWfdDeviceInfo[] = {[0 ... 5] = 0x01};
-constexpr char kTestConnectPin[] = "34556665";
-constexpr char kTestGroupIfName[] = "TestGroup";
-constexpr char kTestWpsDeviceName[] = "TestWpsDeviceName";
-constexpr char kTestWpsManufacturer[] = "TestManufacturer";
-constexpr char kTestWpsModelName[] = "TestModelName";
-constexpr char kTestWpsModelNumber[] = "TestModelNumber";
-constexpr char kTestWpsSerialNumber[] = "TestSerialNumber";
-constexpr char kTestUpnpServiceName[] = "TestServiceName";
-constexpr uint8_t kTestWpsDeviceType[] = {[0 ... 7] = 0x01};
-constexpr uint16_t kTestWpsConfigMethods = 0xffff;
-constexpr uint32_t kTestConnectGoIntent = 6;
-constexpr uint32_t kTestFindTimeout = 5;
-constexpr uint32_t kTestSetGroupIdleTimeout = 6;
-constexpr uint32_t kTestChannel = 1;
-constexpr uint32_t kTestOperatingClass = 81;
-constexpr uint32_t kTestFreqRange[] = {2412, 2432};
-constexpr uint32_t kTestExtListenPeriod = 400;
-constexpr uint32_t kTestExtListenInterval = 400;
-constexpr SupplicantNetworkId kTestNetworkId = 5;
-}  // namespace
-
-class SupplicantP2pIfaceHidlTest : public SupplicantHidlTestBaseV1_0 {
-   public:
-    virtual void SetUp() override {
-        SupplicantHidlTestBaseV1_0::SetUp();
-        if (!isP2pOn_) {
-            GTEST_SKIP() << "Wi-Fi Direct is not supported, skip this test.";
-        }
-        p2p_iface_ = getSupplicantP2pIface(supplicant_);
-        ASSERT_NE(p2p_iface_.get(), nullptr);
-
-        memcpy(mac_addr_.data(), kTestMacAddr, mac_addr_.size());
-        memcpy(peer_mac_addr_.data(), kTestPeerMacAddr, peer_mac_addr_.size());
-    }
-
-   protected:
-    sp<ISupplicantP2pIface> p2p_iface_;
-    // MAC address to use for various tests.
-    std::array<uint8_t, 6> mac_addr_;
-    std::array<uint8_t, 6> peer_mac_addr_;
-};
-
-class IfaceCallback : public ISupplicantP2pIfaceCallback {
-    Return<void> onNetworkAdded(uint32_t /* id */) override { return Void(); }
-    Return<void> onNetworkRemoved(uint32_t /* id */) override { return Void(); }
-    Return<void> onDeviceFound(
-        const hidl_array<uint8_t, 6>& /* srcAddress */,
-        const hidl_array<uint8_t, 6>& /* p2pDeviceAddress */,
-        const hidl_array<uint8_t, 8>& /* primaryDeviceType */,
-        const hidl_string& /* deviceName */, uint16_t /* configMethods */,
-        uint8_t /* deviceCapabilities */, uint32_t /* groupCapabilities */,
-        const hidl_array<uint8_t, 6>& /* wfdDeviceInfo */) override {
-        return Void();
-    }
-    Return<void> onDeviceLost(
-        const hidl_array<uint8_t, 6>& /* p2pDeviceAddress */) override {
-        return Void();
-    }
-    Return<void> onFindStopped() override { return Void(); }
-    Return<void> onGoNegotiationRequest(
-        const hidl_array<uint8_t, 6>& /* srcAddress */,
-        ISupplicantP2pIfaceCallback::WpsDevPasswordId /* passwordId */)
-        override {
-        return Void();
-    }
-    Return<void> onGoNegotiationCompleted(
-        ISupplicantP2pIfaceCallback::P2pStatusCode /* status */) override {
-        return Void();
-    }
-    Return<void> onGroupFormationSuccess() override { return Void(); }
-    Return<void> onGroupFormationFailure(
-        const hidl_string& /* failureReason */) override {
-        return Void();
-    }
-    Return<void> onGroupStarted(
-        const hidl_string& /* groupIfname */, bool /* isGo */,
-        const hidl_vec<uint8_t>& /* ssid */, uint32_t /* frequency */,
-        const hidl_array<uint8_t, 32>& /* psk */,
-        const hidl_string& /* passphrase */,
-        const hidl_array<uint8_t, 6>& /* goDeviceAddress */,
-        bool /* isPersistent */) override {
-        return Void();
-    }
-    Return<void> onGroupRemoved(const hidl_string& /* groupIfname */,
-                                bool /* isGo */) override {
-        return Void();
-    }
-    Return<void> onInvitationReceived(
-        const hidl_array<uint8_t, 6>& /* srcAddress */,
-        const hidl_array<uint8_t, 6>& /* goDeviceAddress */,
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        uint32_t /* persistentNetworkId */,
-        uint32_t /* operatingFrequency */) override {
-        return Void();
-    }
-    Return<void> onInvitationResult(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantP2pIfaceCallback::P2pStatusCode /* status */) override {
-        return Void();
-    }
-    Return<void> onProvisionDiscoveryCompleted(
-        const hidl_array<uint8_t, 6>& /* p2pDeviceAddress */,
-        bool /* isRequest */,
-        ISupplicantP2pIfaceCallback::P2pProvDiscStatusCode /* status */,
-        uint16_t /* configMethods */,
-        const hidl_string& /* generatedPin */) override {
-        return Void();
-    }
-    Return<void> onServiceDiscoveryResponse(
-        const hidl_array<uint8_t, 6>& /* srcAddress */,
-        uint16_t /* updateIndicator */,
-        const hidl_vec<uint8_t>& /* tlvs */) override {
-        return Void();
-    }
-    Return<void> onStaAuthorized(
-        const hidl_array<uint8_t, 6>& /* srcAddress */,
-        const hidl_array<uint8_t, 6>& /* p2pDeviceAddress */) override {
-        return Void();
-    }
-    Return<void> onStaDeauthorized(
-        const hidl_array<uint8_t, 6>& /* srcAddress */,
-        const hidl_array<uint8_t, 6>& /* p2pDeviceAddress */) override {
-        return Void();
-    }
-};
-
-/*
- * Create:
- * Ensures that an instance of the ISupplicantP2pIface proxy object is
- * successfully created.
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Create) {
-    stopSupplicant(wifi_v1_0_instance_name_);
-    startSupplicantAndWaitForHidlService(wifi_v1_0_instance_name_,
-                                         supplicant_instance_name_);
-    sp<ISupplicantP2pIface> p2p_iface = getSupplicantP2pIface(
-        getSupplicant(supplicant_instance_name_, isP2pOn_));
-
-    EXPECT_NE(nullptr, p2p_iface.get());
-}
-
-/*
- * RegisterCallback
- */
-TEST_P(SupplicantP2pIfaceHidlTest, RegisterCallback) {
-    p2p_iface_->registerCallback(
-        new IfaceCallback(), [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * GetName
- */
-TEST_P(SupplicantP2pIfaceHidlTest, GetName) {
-    const auto& status_and_interface_name = HIDL_INVOKE(p2p_iface_, getName);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_interface_name.first.code);
-    EXPECT_FALSE(std::string(status_and_interface_name.second).empty());
-}
-
-/*
- * GetType
- */
-TEST_P(SupplicantP2pIfaceHidlTest, GetType) {
-    const auto& status_and_interface_type = HIDL_INVOKE(p2p_iface_, getType);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_interface_type.first.code);
-    EXPECT_EQ(status_and_interface_type.second, IfaceType::P2P);
-}
-
-/*
- * GetDeviceAddress
- */
-TEST_P(SupplicantP2pIfaceHidlTest, GetDeviceAddress) {
-    p2p_iface_->getDeviceAddress(
-        [](const SupplicantStatus& status,
-           const hidl_array<uint8_t, 6>& /* mac_addr */) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetSsidPostfix
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetSsidPostfix) {
-    std::vector<uint8_t> ssid(kTestSsidPostfix,
-                              kTestSsidPostfix + sizeof(kTestSsidPostfix));
-    p2p_iface_->setSsidPostfix(ssid, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * Find
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Find) {
-    p2p_iface_->find(kTestFindTimeout, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * StopFind
- */
-TEST_P(SupplicantP2pIfaceHidlTest, StopFind) {
-    p2p_iface_->find(kTestFindTimeout, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-
-    p2p_iface_->stopFind([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * Flush
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Flush) {
-    p2p_iface_->flush([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * Connect
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Connect) {
-    p2p_iface_->connect(
-        mac_addr_, ISupplicantP2pIface::WpsProvisionMethod::PBC,
-        kTestConnectPin, false, false, kTestConnectGoIntent,
-        [](const SupplicantStatus& status, const hidl_string& /* pin */) {
-            /*
-             * Before R, auto-join is not enabled and it is not going to work
-             * with fake values. After enabling auto-join, it will succeed
-             * always.
-             */
-            LOG(INFO) << "ISupplicantP2pIface::connect() ret: "
-                      << toString(status);
-            if (SupplicantStatusCode::FAILURE_UNKNOWN != status.code &&
-                SupplicantStatusCode::SUCCESS != status.code) {
-                FAIL();
-            }
-        });
-}
-
-/*
- * CancelConnect
- */
-TEST_P(SupplicantP2pIfaceHidlTest, CancelConnect) {
-    p2p_iface_->connect(
-        mac_addr_, ISupplicantP2pIface::WpsProvisionMethod::PBC,
-        kTestConnectPin, false, false, kTestConnectGoIntent,
-        [](const SupplicantStatus& status, const hidl_string& /* pin */) {
-            /*
-             * Before R, auto-join is not enabled and it is not going to work
-             * with fake values. After enabling auto-join, it will succeed
-             * always.
-             */
-            LOG(INFO) << "ISupplicantP2pIface::connect() ret: "
-                      << toString(status);
-            if (SupplicantStatusCode::FAILURE_UNKNOWN != status.code &&
-                SupplicantStatusCode::SUCCESS != status.code) {
-                FAIL();
-            }
-        });
-
-    p2p_iface_->cancelConnect([](const SupplicantStatus& status) {
-        LOG(INFO) << "ISupplicantP2pIface::cancelConnect() ret: "
-                  << toString(status);
-        if (SupplicantStatusCode::FAILURE_UNKNOWN != status.code &&
-            SupplicantStatusCode::SUCCESS != status.code) {
-            FAIL();
-        }
-    });
-}
-
-/*
- * ProvisionDiscovery
- */
-TEST_P(SupplicantP2pIfaceHidlTest, ProvisionDiscovery) {
-    p2p_iface_->provisionDiscovery(
-        mac_addr_, ISupplicantP2pIface::WpsProvisionMethod::PBC,
-        [](const SupplicantStatus& status) {
-            // This is not going to work with fake values.
-            EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-        });
-}
-
-/*
- * AddGroup
- */
-TEST_P(SupplicantP2pIfaceHidlTest, AddGroup) {
-    p2p_iface_->addGroup(false, kTestNetworkId,
-                         [](const SupplicantStatus& /* status */) {
-                             // TODO: Figure out the initialization sequence for
-                             // this to work.
-                             // EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                             // status.code);
-                         });
-}
-
-/*
- * RemoveGroup
- */
-TEST_P(SupplicantP2pIfaceHidlTest, RemoveGroup) {
-    // This is not going to work with fake values.
-    EXPECT_NE(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, removeGroup, kTestGroupIfName).code);
-}
-
-/*
- * Reject
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Reject) {
-    p2p_iface_->reject(mac_addr_, [](const SupplicantStatus& status) {
-        // This is not going to work with fake values.
-        EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-    });
-}
-
-/*
- * Invite
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Invite) {
-    p2p_iface_->invite(kTestGroupIfName, mac_addr_, peer_mac_addr_,
-                       [](const SupplicantStatus& status) {
-                           // This is not going to work with fake values.
-                           EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN,
-                                     status.code);
-                       });
-}
-
-/*
- * Reinvoke
- */
-TEST_P(SupplicantP2pIfaceHidlTest, Reinvoke) {
-    p2p_iface_->reinvoke(
-        kTestNetworkId, mac_addr_, [](const SupplicantStatus& status) {
-            // This is not going to work with fake values.
-            EXPECT_EQ(SupplicantStatusCode::FAILURE_NETWORK_UNKNOWN,
-                      status.code);
-        });
-}
-
-/*
- * ConfigureExtListen
- */
-TEST_P(SupplicantP2pIfaceHidlTest, ConfigureExtListen) {
-    p2p_iface_->configureExtListen(kTestExtListenPeriod, kTestExtListenInterval,
-                                   [](const SupplicantStatus& status) {
-                                       EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                                 status.code);
-                                   });
-}
-
-/*
- * SetListenChannel
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetListenChannel) {
-    p2p_iface_->setListenChannel(
-        kTestChannel, kTestOperatingClass, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetDisallowedFrequencies
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetDisallowedFrequencies) {
-    std::vector<ISupplicantP2pIface::FreqRange> ranges = {
-        {kTestFreqRange[0], kTestFreqRange[1]}};
-    p2p_iface_->setDisallowedFrequencies(
-        ranges, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * GetSsid
- */
-TEST_P(SupplicantP2pIfaceHidlTest, GetSsid) {
-    std::array<uint8_t, 6> mac_addr;
-    memcpy(mac_addr.data(), kTestMacAddr, mac_addr.size());
-    p2p_iface_->getSsid(mac_addr, [](const SupplicantStatus& status,
-                                     const hidl_vec<uint8_t>& /* ssid */) {
-        // This is not going to work with fake values.
-        EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-    });
-}
-
-/*
- * GetGroupCapability
- */
-TEST_P(SupplicantP2pIfaceHidlTest, GetGroupCapability) {
-    std::array<uint8_t, 6> mac_addr;
-    memcpy(mac_addr.data(), kTestMacAddr, mac_addr.size());
-    p2p_iface_->getGroupCapability(
-        mac_addr, [](const SupplicantStatus& status, uint32_t /* caps */) {
-            // This is not going to work with fake values.
-            EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-        });
-}
-
-/*
- * FlushServices
- */
-TEST_P(SupplicantP2pIfaceHidlTest, FlushServices) {
-    p2p_iface_->flushServices([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * SetMiracastMode
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetMiracastMode) {
-    p2p_iface_->setMiracastMode(ISupplicantP2pIface::MiracastMode::DISABLED,
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-    p2p_iface_->setMiracastMode(ISupplicantP2pIface::MiracastMode::SOURCE,
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-    p2p_iface_->setMiracastMode(ISupplicantP2pIface::MiracastMode::SINK,
-                                [](const SupplicantStatus& status) {
-                                    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                              status.code);
-                                });
-}
-
-/*
- * SetGroupIdle
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetGroupIdle) {
-    // This is not going to work with fake values.
-    EXPECT_NE(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, setGroupIdle, kTestGroupIfName,
-                          kTestSetGroupIdleTimeout)
-                  .code);
-}
-
-/*
- * SetPowerSave
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetPowerSave) {
-    // This is not going to work with fake values.
-    EXPECT_NE(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setPowerSave, kTestGroupIfName, true).code);
-    // This is not going to work with fake values.
-    EXPECT_NE(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setPowerSave, kTestGroupIfName, false).code);
-}
-
-/*
- * SetWpsDeviceName
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsDeviceName) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWpsDeviceName, kTestWpsDeviceName).code);
-}
-
-/*
- * SetWpsDeviceType
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsDeviceType) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWpsDeviceType, kTestWpsDeviceType).code);
-}
-
-/*
- * SetWpsManufacturer
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsManufacturer) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWpsManufacturer, kTestWpsManufacturer).code);
-}
-
-/*
- * SetWpsModelName
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsModelName) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, setWpsModelName, kTestWpsModelName).code);
-}
-
-/*
- * SetWpsModelNumber
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsModelNumber) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWpsModelNumber, kTestWpsModelNumber).code);
-}
-
-/*
- * SetWpsSerialNumber
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsSerialNumber) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWpsSerialNumber, kTestWpsSerialNumber).code);
-}
-
-/*
- * SetWpsConfigMethods
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWpsConfigMethods) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWpsConfigMethods, kTestWpsConfigMethods)
-            .code);
-}
-
-/*
- * AddAndRemoveBonjourService
- * This tests that we are able to add a bonjour service, and we can remove it
- * by using the same query data.
- * This also tests that removeBonjourSerive() returns error when there is no
- * existing bonjour service with the same query data.
- */
-TEST_P(SupplicantP2pIfaceHidlTest, AddAndRemoveBonjourService) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(
-                  p2p_iface_, addBonjourService,
-                  std::vector<uint8_t>(kTestBonjourServiceQuery,
-                                       kTestBonjourServiceQuery +
-                                           sizeof(kTestBonjourServiceQuery)),
-                  std::vector<uint8_t>(kTestBonjourServiceResponse,
-                                       kTestBonjourServiceResponse +
-                                           sizeof(kTestBonjourServiceResponse)))
-                  .code);
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, removeBonjourService,
-                    std::vector<uint8_t>(kTestBonjourServiceQuery,
-                                         kTestBonjourServiceQuery +
-                                             sizeof(kTestBonjourServiceQuery)))
-            .code);
-    // This will fail because boujour service with kTestBonjourServiceQuery was
-    // already removed.
-    EXPECT_NE(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, removeBonjourService,
-                    std::vector<uint8_t>(kTestBonjourServiceQuery,
-                                         kTestBonjourServiceQuery +
-                                             sizeof(kTestBonjourServiceQuery)))
-            .code);
-}
-
-/*
- * AddAndRemoveUpnpService
- * This tests that we are able to add a upnp service, and we can remove it
- * by using the same service name.
- * This also tests that removeUpnpService() returns error when there is no
- * exsiting upnp service with the same service name.
- */
-TEST_P(SupplicantP2pIfaceHidlTest, AddAndRemoveUpnpService) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, addUpnpService, 0 /* version */,
-                          kTestUpnpServiceName)
-                  .code);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, removeUpnpService, 0 /* version */,
-                          kTestUpnpServiceName)
-                  .code);
-    // This will fail because Upnp service with kTestUpnpServiceName was
-    // already removed.
-    EXPECT_NE(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, removeUpnpService, 0 /* version */,
-                          kTestUpnpServiceName)
-                  .code);
-}
-
-/*
- * EnableWfd
- */
-TEST_P(SupplicantP2pIfaceHidlTest, EnableWfd) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, enableWfd, true).code);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(p2p_iface_, enableWfd, false).code);
-}
-
-/*
- * SetWfdDeviceInfo
- */
-TEST_P(SupplicantP2pIfaceHidlTest, SetWfdDeviceInfo) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(p2p_iface_, setWfdDeviceInfo, kTestWfdDeviceInfo).code);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantP2pIfaceHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantP2pIfaceHidlTest,
-    testing::Combine(
-        testing::ValuesIn(
-            android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            ISupplicant::descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.0/vts/functional/supplicant_sta_iface_hidl_test.cpp b/wifi/supplicant/1.0/vts/functional/supplicant_sta_iface_hidl_test.cpp
deleted file mode 100644
index bd0e8cfe50..0000000000
--- a/wifi/supplicant/1.0/vts/functional/supplicant_sta_iface_hidl_test.cpp
+++ /dev/null
@@ -1,564 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.0/ISupplicantStaIface.h>
-#include <android/hardware/wifi/supplicant/1.4/ISupplicantStaIface.h>
-
-#include "supplicant_hidl_call_util.h"
-#include "supplicant_hidl_test_utils.h"
-#include <cutils/properties.h>
-
-using ::android::sp;
-using ::android::hardware::hidl_array;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::wifi::supplicant::V1_0::IfaceType;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantStaIface;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantStaIfaceCallback;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantStaNetwork;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantNetworkId;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::V1_0::IWifi;
-
-namespace {
-constexpr uint8_t kTestMacAddr[] = {0x56, 0x67, 0x67, 0xf4, 0x56, 0x92};
-constexpr ISupplicantStaIface::AnqpInfoId kTestAnqpInfoIds[] = {
-    ISupplicantStaIface::AnqpInfoId::VENUE_NAME,
-    ISupplicantStaIface::AnqpInfoId::NAI_REALM,
-    ISupplicantStaIface::AnqpInfoId::DOMAIN_NAME};
-constexpr ISupplicantStaIface::Hs20AnqpSubtypes kTestHs20Types[] = {
-    ISupplicantStaIface::Hs20AnqpSubtypes::WAN_METRICS,
-    ISupplicantStaIface::Hs20AnqpSubtypes::OPERATOR_FRIENDLY_NAME};
-constexpr char kTestHs20IconFile[] = "TestFile";
-constexpr char kTestWpsDeviceName[] = "TestWpsDeviceName";
-constexpr char kTestWpsManufacturer[] = "TestManufacturer";
-constexpr char kTestWpsModelName[] = "TestModelName";
-constexpr char kTestWpsModelNumber[] = "TestModelNumber";
-constexpr char kTestWpsSerialNumber[] = "TestSerialNumber";
-constexpr char kTestRadioWorkName[] = "TestRadioWork";
-constexpr uint32_t kTestRadioWorkFrequency = 2412;
-constexpr uint32_t kTestRadioWorkTimeout = 8;
-constexpr uint32_t kTestRadioWorkId = 16;
-int8_t kTestCountryCode[] = {'U', 'S'};
-constexpr uint8_t kTestWpsDeviceType[] = {[0 ... 7] = 0x01};
-constexpr uint16_t kTestWpsConfigMethods = 0xffff;
-}  // namespace
-
-class SupplicantStaIfaceHidlTest : public SupplicantHidlTestBaseV1_0 {
-   public:
-    virtual void SetUp() override {
-        SupplicantHidlTestBaseV1_0::SetUp();
-        sta_iface_ = getSupplicantStaIface(supplicant_);
-        ASSERT_NE(sta_iface_.get(), nullptr);
-
-        v1_4 = ::android::hardware::wifi::supplicant::V1_4::
-            ISupplicantStaIface::castFrom(sta_iface_);
-
-        memcpy(mac_addr_.data(), kTestMacAddr, mac_addr_.size());
-    }
-
-   protected:
-    bool isP2pOn_ = false;
-    sp<::android::hardware::wifi::supplicant::V1_4::ISupplicantStaIface> v1_4 =
-        nullptr;
-    // ISupplicantStaIface object used for all tests in this fixture.
-    sp<ISupplicantStaIface> sta_iface_;
-    // MAC address to use for various tests.
-    std::array<uint8_t, 6> mac_addr_;
-};
-
-class IfaceCallback : public ISupplicantStaIfaceCallback {
-    Return<void> onNetworkAdded(uint32_t /* id */) override { return Void(); }
-    Return<void> onNetworkRemoved(uint32_t /* id */) override { return Void(); }
-    Return<void> onStateChanged(
-        ISupplicantStaIfaceCallback::State /* newState */,
-        const hidl_array<uint8_t, 6>& /*bssid */, uint32_t /* id */,
-        const hidl_vec<uint8_t>& /* ssid */) override {
-        return Void();
-    }
-    Return<void> onAnqpQueryDone(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        const ISupplicantStaIfaceCallback::AnqpData& /* data */,
-        const ISupplicantStaIfaceCallback::Hs20AnqpData& /* hs20Data */)
-        override {
-        return Void();
-    }
-    virtual Return<void> onHs20IconQueryDone(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        const hidl_string& /* fileName */,
-        const hidl_vec<uint8_t>& /* data */) override {
-        return Void();
-    }
-    virtual Return<void> onHs20SubscriptionRemediation(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantStaIfaceCallback::OsuMethod /* osuMethod */,
-        const hidl_string& /* url*/) override {
-        return Void();
-    }
-    Return<void> onHs20DeauthImminentNotice(
-        const hidl_array<uint8_t, 6>& /* bssid */, uint32_t /* reasonCode */,
-        uint32_t /* reAuthDelayInSec */,
-        const hidl_string& /* url */) override {
-        return Void();
-    }
-    Return<void> onDisconnected(const hidl_array<uint8_t, 6>& /* bssid */,
-                                bool /* locallyGenerated */,
-                                ISupplicantStaIfaceCallback::ReasonCode
-                                /* reasonCode */) override {
-        return Void();
-    }
-    Return<void> onAssociationRejected(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantStaIfaceCallback::StatusCode /* statusCode */,
-        bool /*timedOut */) override {
-        return Void();
-    }
-    Return<void> onAuthenticationTimeout(
-        const hidl_array<uint8_t, 6>& /* bssid */) override {
-        return Void();
-    }
-    Return<void> onBssidChanged(
-        ISupplicantStaIfaceCallback::BssidChangeReason /* reason */,
-        const hidl_array<uint8_t, 6>& /* bssid */) override {
-        return Void();
-    }
-    Return<void> onEapFailure() override { return Void(); }
-    Return<void> onWpsEventSuccess() override { return Void(); }
-    Return<void> onWpsEventFail(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantStaIfaceCallback::WpsConfigError /* configError */,
-        ISupplicantStaIfaceCallback::WpsErrorIndication /* errorInd */)
-        override {
-        return Void();
-    }
-    Return<void> onWpsEventPbcOverlap() override { return Void(); }
-    Return<void> onExtRadioWorkStart(uint32_t /* id */) override {
-        return Void();
-    }
-    Return<void> onExtRadioWorkTimeout(uint32_t /* id*/) override {
-        return Void();
-    }
-};
-
-/*
- * Create:
- * Ensures that an instance of the ISupplicantStaIface proxy object is
- * successfully created.
- */
-TEST_P(SupplicantStaIfaceHidlTest, Create) {
-    stopSupplicant(wifi_v1_0_instance_name_);
-    startSupplicantAndWaitForHidlService(wifi_v1_0_instance_name_,
-                                         supplicant_instance_name_);
-    EXPECT_NE(nullptr, getSupplicantStaIface(
-                           getSupplicant(supplicant_instance_name_, isP2pOn_))
-                           .get());
-}
-
-/*
- * RegisterCallback
- */
-TEST_P(SupplicantStaIfaceHidlTest, RegisterCallback) {
-    // This API is deprecated from v1.4 HAL.
-    SupplicantStatusCode expectedCode =
-        (nullptr != v1_4) ? SupplicantStatusCode::FAILURE_UNKNOWN
-                          : SupplicantStatusCode::SUCCESS;
-    sta_iface_->registerCallback(new IfaceCallback(),
-                                 [&](const SupplicantStatus& status) {
-                                     EXPECT_EQ(expectedCode, status.code);
-                                 });
-}
-
-/*
- * GetName
- */
-TEST_P(SupplicantStaIfaceHidlTest, GetName) {
-    const auto& status_and_interface_name = HIDL_INVOKE(sta_iface_, getName);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_interface_name.first.code);
-    EXPECT_FALSE(std::string(status_and_interface_name.second).empty());
-}
-
-/*
- * GetType
- */
-TEST_P(SupplicantStaIfaceHidlTest, GetType) {
-    const auto& status_and_interface_type = HIDL_INVOKE(sta_iface_, getType);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_interface_type.first.code);
-    EXPECT_EQ(status_and_interface_type.second, IfaceType::STA);
-}
-
-/*
- * listNetworks.
- */
-TEST_P(SupplicantStaIfaceHidlTest, listNetworks) {
-    sta_iface_->listNetworks([](const SupplicantStatus& status,
-                                const hidl_vec<SupplicantNetworkId>& ids) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(0u, ids.size());
-    });
-
-    sp<ISupplicantStaNetwork> sta_network =
-        createSupplicantStaNetwork(supplicant_);
-    EXPECT_NE(nullptr, sta_network.get());
-
-    sta_iface_->listNetworks([](const SupplicantStatus& status,
-                                const hidl_vec<SupplicantNetworkId>& ids) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_LT(0u, ids.size());
-    });
-}
-
-/*
- * Reassociate.
- */
-TEST_P(SupplicantStaIfaceHidlTest, Reassociate) {
-    sta_iface_->reassociate([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * Reconnect.
- */
-TEST_P(SupplicantStaIfaceHidlTest, Reconnect) {
-    sta_iface_->reconnect([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::FAILURE_IFACE_NOT_DISCONNECTED,
-                  status.code);
-    });
-}
-
-/*
- * Disconnect.
- */
-TEST_P(SupplicantStaIfaceHidlTest, Disconnect) {
-    sta_iface_->disconnect([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * SetPowerSave.
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetPowerSave) {
-    sta_iface_->setPowerSave(true, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_iface_->setPowerSave(false, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * InitiateTdlsDiscover.
- */
-TEST_P(SupplicantStaIfaceHidlTest, InitiateTdlsDiscover) {
-    sta_iface_->initiateTdlsDiscover(
-        mac_addr_, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * InitiateTdlsSetup.
- */
-TEST_P(SupplicantStaIfaceHidlTest, InitiateTdlsSetup) {
-    sta_iface_->initiateTdlsSetup(
-        mac_addr_, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * InitiateTdlsTeardown.
- */
-TEST_P(SupplicantStaIfaceHidlTest, InitiateTdlsTeardown) {
-    sta_iface_->initiateTdlsTeardown(
-        mac_addr_, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * InitiateAnqpQuery.
- */
-TEST_P(SupplicantStaIfaceHidlTest, InitiateAnqpQuery) {
-    std::vector<ISupplicantStaIface::AnqpInfoId> anqp_ids(
-        kTestAnqpInfoIds, kTestAnqpInfoIds + sizeof(kTestAnqpInfoIds));
-    std::vector<ISupplicantStaIface::Hs20AnqpSubtypes> hs_types(
-        kTestHs20Types, kTestHs20Types + sizeof(kTestHs20Types));
-    sta_iface_->initiateAnqpQuery(
-        mac_addr_, anqp_ids, hs_types, [](const SupplicantStatus& status) {
-            // These requests will fail unless the BSSID mentioned is actually
-            // present in scan results.
-            EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-        });
-}
-
-/*
- * InitiateHs20IconQuery.
- */
-TEST_P(SupplicantStaIfaceHidlTest, InitiateHs20IconQuery) {
-    sta_iface_->initiateHs20IconQuery(
-        mac_addr_, kTestHs20IconFile, [](const SupplicantStatus& status) {
-            // These requests will fail unless the BSSID mentioned is actually
-            // present in scan results.
-            EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-        });
-}
-
-/*
- * GetMacAddress.
- */
-TEST_P(SupplicantStaIfaceHidlTest, GetMacAddress) {
-    sta_iface_->getMacAddress([](const SupplicantStatus& status,
-                                 const hidl_array<uint8_t, 6>& mac_addr) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        std::array<uint8_t, 6> std_mac_addr(mac_addr);
-        EXPECT_GT(6, std::count(std_mac_addr.begin(), std_mac_addr.end(), 0));
-    });
-}
-
-/*
- * StartRxFilter.
- */
-TEST_P(SupplicantStaIfaceHidlTest, StartRxFilter) {
-    sta_iface_->startRxFilter([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * StopRxFilter.
- */
-TEST_P(SupplicantStaIfaceHidlTest, StopRxFilter) {
-    sta_iface_->stopRxFilter([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-}
-
-/*
- * AddRxFilter.
- */
-TEST_P(SupplicantStaIfaceHidlTest, AddRxFilter) {
-    sta_iface_->addRxFilter(ISupplicantStaIface::RxFilterType::V4_MULTICAST,
-                            [](const SupplicantStatus& status) {
-                                EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                          status.code);
-                            });
-    sta_iface_->addRxFilter(ISupplicantStaIface::RxFilterType::V6_MULTICAST,
-                            [](const SupplicantStatus& status) {
-                                EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                          status.code);
-                            });
-}
-
-/*
- * RemoveRxFilter.
- */
-TEST_P(SupplicantStaIfaceHidlTest, RemoveRxFilter) {
-    sta_iface_->removeRxFilter(ISupplicantStaIface::RxFilterType::V4_MULTICAST,
-                               [](const SupplicantStatus& status) {
-                                   EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                             status.code);
-                               });
-    sta_iface_->removeRxFilter(ISupplicantStaIface::RxFilterType::V6_MULTICAST,
-                               [](const SupplicantStatus& status) {
-                                   EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-                                             status.code);
-                               });
-}
-
-/*
- * SetBtCoexistenceMode.
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetBtCoexistenceMode) {
-    sta_iface_->setBtCoexistenceMode(
-        ISupplicantStaIface::BtCoexistenceMode::ENABLED,
-        [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_iface_->setBtCoexistenceMode(
-        ISupplicantStaIface::BtCoexistenceMode::DISABLED,
-        [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_iface_->setBtCoexistenceMode(
-        ISupplicantStaIface::BtCoexistenceMode::SENSE,
-        [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetBtCoexistenceScanModeEnabled.
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetBtCoexistenceScanModeEnabled) {
-    sta_iface_->setBtCoexistenceScanModeEnabled(
-        true, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_iface_->setBtCoexistenceScanModeEnabled(
-        false, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetSuspendModeEnabled.
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetSuspendModeEnabled) {
-    sta_iface_->setSuspendModeEnabled(true, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_iface_->setSuspendModeEnabled(
-        false, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetCountryCode.
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetCountryCode) {
-    std::array<char, PROPERTY_VALUE_MAX> buffer;
-    property_get("ro.boot.wificountrycode", buffer.data(), "US");
-    kTestCountryCode[0] = buffer.data()[0];
-    kTestCountryCode[1] = buffer.data()[1];
-    sta_iface_->setCountryCode(
-        kTestCountryCode, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetWpsDeviceName
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsDeviceName) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, setWpsDeviceName, kTestWpsDeviceName).code);
-}
-
-/*
- * SetWpsDeviceType
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsDeviceType) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, setWpsDeviceType, kTestWpsDeviceType).code);
-}
-
-/*
- * SetWpsManufacturer
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsManufacturer) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, setWpsManufacturer, kTestWpsManufacturer).code);
-}
-
-/*
- * SetWpsModelName
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsModelName) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_iface_, setWpsModelName, kTestWpsModelName).code);
-}
-
-/*
- * SetWpsModelNumber
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsModelNumber) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, setWpsModelNumber, kTestWpsModelNumber).code);
-}
-
-/*
- * SetWpsSerialNumber
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsSerialNumber) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, setWpsSerialNumber, kTestWpsSerialNumber).code);
-}
-
-/*
- * SetWpsConfigMethods
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetWpsConfigMethods) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, setWpsConfigMethods, kTestWpsConfigMethods)
-            .code);
-}
-
-/*
- * SetExternalSim
- */
-TEST_P(SupplicantStaIfaceHidlTest, SetExternalSim) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_iface_, setExternalSim, true).code);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_iface_, setExternalSim, false).code);
-}
-
-/*
- * AddExtRadioWork
- */
-TEST_P(SupplicantStaIfaceHidlTest, AddExtRadioWork) {
-    const auto& status_and_radio_work_id =
-        HIDL_INVOKE(sta_iface_, addExtRadioWork, kTestRadioWorkName,
-                    kTestRadioWorkFrequency, kTestRadioWorkTimeout);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_radio_work_id.first.code);
-    // removeExtRadio only succeeds if the added radio work hasn't started yet.
-    // So there this no guaranteed result from calling removeExtRadioWork here.
-    // That being said, currently we are not able to test addExtRadioWork and
-    // removeExtRadioWork in a row.
-}
-
-/*
- * RemoveExtRadioWork
- */
-TEST_P(SupplicantStaIfaceHidlTest, RemoveExtRadioWork) {
-    // This fails because there is no on going radio work with kTestRadioWorkId.
-    EXPECT_NE(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_iface_, removeExtRadioWork, kTestRadioWorkId).code);
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantStaIfaceHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantStaIfaceHidlTest,
-    testing::Combine(
-        testing::ValuesIn(
-            android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            ISupplicant::descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.0/vts/functional/supplicant_sta_network_hidl_test.cpp b/wifi/supplicant/1.0/vts/functional/supplicant_sta_network_hidl_test.cpp
deleted file mode 100644
index 5aaba22afc..0000000000
--- a/wifi/supplicant/1.0/vts/functional/supplicant_sta_network_hidl_test.cpp
+++ /dev/null
@@ -1,838 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.0/ISupplicantStaNetwork.h>
-#include <android/hardware/wifi/supplicant/1.3/ISupplicantStaNetwork.h>
-#include <android/hardware/wifi/supplicant/1.4/ISupplicantStaNetwork.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "supplicant_hidl_call_util.h"
-#include "supplicant_hidl_test_utils.h"
-#include "wifi_hidl_test_utils.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_array;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::wifi::supplicant::V1_0::IfaceType;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantStaIface;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantStaNetwork;
-using ::android::hardware::wifi::supplicant::V1_0::
-    ISupplicantStaNetworkCallback;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::V1_0::IWifi;
-
-namespace {
-constexpr char kTestSsidStr[] = "TestSsid1234";
-constexpr char kTestPskPassphrase[] = "TestPsk123";
-constexpr char kTestIdStr[] = "TestIdstr";
-constexpr char kTestEapPasswdStr[] = "TestEapPasswd1234";
-constexpr char kTestEapCert[] = "keystore://CERT";
-constexpr char kTestEapPrivateKeyId[] = "key_id";
-constexpr char kTestEapMatch[] = "match";
-constexpr char kTestEapEngineID[] = "engine_id";
-constexpr uint8_t kTestBssid[] = {0x56, 0x67, 0x67, 0xf4, 0x56, 0x92};
-constexpr uint8_t kTestWepKey[] = {0x56, 0x67, 0x67, 0xf4, 0x56};
-constexpr uint8_t kTestKc[] = {0x56, 0x67, 0x67, 0xf4, 0x76, 0x87, 0x98, 0x12};
-constexpr uint8_t kTestSres[] = {0x56, 0x67, 0x67, 0xf4};
-constexpr uint8_t kTestRes[] = {0x56, 0x67, 0x67, 0xf4, 0x67};
-constexpr uint8_t kTestIk[] = {[0 ... 15] = 0x65};
-constexpr uint8_t kTestCk[] = {[0 ... 15] = 0x45};
-constexpr uint8_t kTestIdentity[] = {0x45, 0x67, 0x98, 0x67, 0x56};
-constexpr uint8_t kTestPsk[] = {[0 ... 31] = 0x12};
-constexpr uint8_t kTestAutParam[] = {[0 ... 13] = 0xe1};
-constexpr uint32_t kTestWepTxKeyIdx = 2;
-constexpr uint32_t kTestUpdateIdentifier = 21;
-constexpr uint32_t kTestKeyMgmt = (ISupplicantStaNetwork::KeyMgmtMask::WPA_PSK |
-                                   ISupplicantStaNetwork::KeyMgmtMask::WPA_EAP);
-constexpr uint32_t kTestProto = (ISupplicantStaNetwork::ProtoMask::OSEN |
-                                 ISupplicantStaNetwork::ProtoMask::RSN);
-constexpr uint32_t kTestAuthAlg = (ISupplicantStaNetwork::AuthAlgMask::OPEN |
-                                   ISupplicantStaNetwork::AuthAlgMask::SHARED);
-constexpr uint32_t kTestGroupCipher =
-    (ISupplicantStaNetwork::GroupCipherMask::CCMP |
-     ISupplicantStaNetwork::GroupCipherMask::WEP104);
-constexpr uint32_t kTestPairwiseCipher =
-    (ISupplicantStaNetwork::PairwiseCipherMask::CCMP |
-     ISupplicantStaNetwork::PairwiseCipherMask::TKIP);
-}  // namespace
-
-class SupplicantStaNetworkHidlTest : public SupplicantHidlTestBaseV1_0 {
-   public:
-    virtual void SetUp() override {
-        SupplicantHidlTestBaseV1_0::SetUp();
-        sta_network_ = createSupplicantStaNetwork(supplicant_);
-        ASSERT_NE(sta_network_.get(), nullptr);
-        /* variable used to check if the underlying HAL version is 1.3 or
-         * higher. This is to skip tests which are using deprecated methods.
-         */
-        v1_3 = ::android::hardware::wifi::supplicant::V1_3::
-            ISupplicantStaNetwork::castFrom(sta_network_);
-        v1_4 = ::android::hardware::wifi::supplicant::V1_4::
-            ISupplicantStaNetwork::castFrom(sta_network_);
-
-        ssid_.assign(kTestSsidStr, kTestSsidStr + strlen(kTestSsidStr));
-    }
-
-   protected:
-    void removeNetwork() {
-        sp<ISupplicantStaIface> sta_iface = getSupplicantStaIface(supplicant_);
-        ASSERT_NE(nullptr, sta_iface.get());
-        uint32_t net_id;
-        sta_network_->getId(
-            [&](const SupplicantStatus& status, int network_id) {
-                ASSERT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-                net_id = network_id;
-            });
-        sta_iface->removeNetwork(net_id, [](const SupplicantStatus& status) {
-            ASSERT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    }
-
-    sp<::android::hardware::wifi::supplicant::V1_3::ISupplicantStaNetwork>
-        v1_3 = nullptr;
-    sp<::android::hardware::wifi::supplicant::V1_4::ISupplicantStaNetwork>
-        v1_4 = nullptr;
-    // ISupplicantStaNetwork object used for all tests in this fixture.
-    sp<ISupplicantStaNetwork> sta_network_;
-    // SSID to use for various tests.
-    std::vector<uint8_t> ssid_;
-};
-
-class NetworkCallback : public ISupplicantStaNetworkCallback {
-    Return<void> onNetworkEapSimGsmAuthRequest(
-        const ISupplicantStaNetworkCallback::NetworkRequestEapSimGsmAuthParams&
-        /* params */) override {
-        return Void();
-    }
-    Return<void> onNetworkEapSimUmtsAuthRequest(
-        const ISupplicantStaNetworkCallback::NetworkRequestEapSimUmtsAuthParams&
-        /* params */) override {
-        return Void();
-    }
-    Return<void> onNetworkEapIdentityRequest() override { return Void(); }
-};
-
-/*
- * Create:
- * Ensures that an instance of the ISupplicantStaNetwork proxy object is
- * successfully created.
- */
-TEST_P(SupplicantStaNetworkHidlTest, Create) {
-    stopSupplicant(wifi_v1_0_instance_name_);
-    startSupplicantAndWaitForHidlService(wifi_v1_0_instance_name_,
-                                         supplicant_instance_name_);
-    sp<ISupplicant> supplicant =
-        getSupplicant(supplicant_instance_name_, isP2pOn_);
-    EXPECT_TRUE(turnOnExcessiveLogging(supplicant));
-    EXPECT_NE(nullptr, createSupplicantStaNetwork(supplicant).get());
-}
-
-/*
- * RegisterCallback
- */
-TEST_P(SupplicantStaNetworkHidlTest, RegisterCallback) {
-    sta_network_->registerCallback(
-        new NetworkCallback(), [&](const SupplicantStatus& status) {
-            if (nullptr != v1_4) {
-                EXPECT_EQ(SupplicantStatusCode::FAILURE_UNKNOWN, status.code);
-            } else {
-                EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            }
-        });
-}
-
-/*
- * GetInterfaceName
- */
-TEST_P(SupplicantStaNetworkHidlTest, GetInterfaceName) {
-    const auto& status_and_interface_name =
-        HIDL_INVOKE(sta_network_, getInterfaceName);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_interface_name.first.code);
-    EXPECT_FALSE(std::string(status_and_interface_name.second).empty());
-}
-
-/*
- * GetType
- */
-TEST_P(SupplicantStaNetworkHidlTest, GetType) {
-    const auto& status_and_interface_type = HIDL_INVOKE(sta_network_, getType);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_interface_type.first.code);
-    EXPECT_EQ(status_and_interface_type.second, IfaceType::STA);
-}
-
-/* Tests out the various setter/getter methods. */
-/*
- * SetGetSsid
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetSsid) {
-    sta_network_->setSsid(ssid_, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->getSsid(
-        [&](const SupplicantStatus& status, const hidl_vec<uint8_t>& get_ssid) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(ssid_, std::vector<uint8_t>(get_ssid));
-        });
-}
-
-/*
- * SetGetBssid
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetBssid) {
-    std::array<uint8_t, 6> set_bssid;
-    memcpy(set_bssid.data(), kTestBssid, set_bssid.size());
-    sta_network_->setBssid(set_bssid, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->getBssid([&](const SupplicantStatus& status,
-                               const hidl_array<uint8_t, 6>& get_bssid_hidl) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        std::array<uint8_t, 6> get_bssid;
-        memcpy(get_bssid.data(), get_bssid_hidl.data(), get_bssid.size());
-        EXPECT_EQ(set_bssid, get_bssid);
-    });
-}
-
-/*
- * SetGetKeyMgmt
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetKeyMgmt) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    sta_network_->setKeyMgmt(kTestKeyMgmt, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->getKeyMgmt(
-        [&](const SupplicantStatus& status, uint32_t key_mgmt) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(key_mgmt, kTestKeyMgmt);
-        });
-}
-
-/*
- * SetGetProto
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetProto) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    sta_network_->setProto(kTestProto, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->getProto([&](const SupplicantStatus& status, uint32_t proto) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(proto, kTestProto);
-    });
-}
-
-/*
- * SetGetKeyAuthAlg
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetAuthAlg) {
-    sta_network_->setAuthAlg(kTestAuthAlg, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->getAuthAlg(
-        [&](const SupplicantStatus& status, uint32_t auth_alg) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(auth_alg, kTestAuthAlg);
-        });
-}
-
-/*
- * SetGetGroupCipher
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetGroupCipher) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    sta_network_->setGroupCipher(
-        kTestGroupCipher, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getGroupCipher(
-        [&](const SupplicantStatus& status, uint32_t group_cipher) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(group_cipher, kTestGroupCipher);
-        });
-}
-
-/*
- * SetGetPairwiseCipher
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetPairwiseCipher) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    sta_network_->setPairwiseCipher(
-        kTestPairwiseCipher, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getPairwiseCipher(
-        [&](const SupplicantStatus& status, uint32_t pairwise_cipher) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(pairwise_cipher, kTestPairwiseCipher);
-        });
-}
-
-/*
- * SetGetPskPassphrase
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetPskPassphrase) {
-    sta_network_->setPskPassphrase(
-        kTestPskPassphrase, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getPskPassphrase(
-        [&](const SupplicantStatus& status, const hidl_string& psk) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(kTestPskPassphrase, std::string(psk.c_str()));
-        });
-}
-
-/*
- * SetGetPsk
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetPsk) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, setPsk, kTestPsk).code);
-    const auto& status_and_psk = HIDL_INVOKE(sta_network_, getPsk);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS, status_and_psk.first.code);
-    hidl_array<uint8_t, 32> expected_psk(kTestPsk);
-    EXPECT_EQ(expected_psk, status_and_psk.second);
-}
-
-/*
- * SetGetWepKeys
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetWepTxKeyIdx) {
-    sta_network_->setWepTxKeyIdx(
-        kTestWepTxKeyIdx, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getWepTxKeyIdx(
-        [&](const SupplicantStatus& status, uint32_t key_idx) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(kTestWepTxKeyIdx, key_idx);
-        });
-}
-
-/*
- * SetGetWepKeys
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetWepKeys) {
-    for (uint32_t i = 0;
-         i < static_cast<uint32_t>(
-                 ISupplicantStaNetwork::ParamSizeLimits::WEP_KEYS_MAX_NUM);
-         i++) {
-        std::vector<uint8_t> set_wep_key(std::begin(kTestWepKey),
-                                         std::end(kTestWepKey));
-        sta_network_->setWepKey(
-            i, set_wep_key, [](const SupplicantStatus& status) {
-                EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            });
-        sta_network_->getWepKey(i, [&](const SupplicantStatus& status,
-                                       const hidl_vec<uint8_t>& get_wep_key) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(set_wep_key, std::vector<uint8_t>(get_wep_key));
-        });
-    }
-}
-
-/*
- * SetGetScanSsid
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetScanSsid) {
-    sta_network_->setScanSsid(
-        true, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getScanSsid(
-        [&](const SupplicantStatus& status, bool scan_ssid) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(true, scan_ssid);
-        });
-}
-
-/*
- * SetGetRequirePmf
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetRequirePmf) {
-    sta_network_->setRequirePmf(
-        true, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getRequirePmf(
-        [&](const SupplicantStatus& status, bool require_pmf) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(true, require_pmf);
-        });
-}
-
-/*
- * SetGetIdStr
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetIdStr) {
-    sta_network_->setIdStr(
-        kTestIdStr, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getIdStr(
-        [&](const SupplicantStatus& status, const hidl_string& id_str) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(kTestIdStr, std::string(id_str.c_str()));
-        });
-}
-
-/*
- * SetGetEapMethod
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapMethod) {
-    ISupplicantStaNetwork::EapMethod set_eap_method =
-        ISupplicantStaNetwork::EapMethod::PEAP;
-    sta_network_->setEapMethod(
-        set_eap_method, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapMethod(
-        [&](const SupplicantStatus& status,
-            ISupplicantStaNetwork::EapMethod eap_method) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(set_eap_method, eap_method);
-        });
-}
-
-/*
- * SetGetEapPhase2Method
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapPhase2Method) {
-    ISupplicantStaNetwork::EapMethod set_eap_method =
-        ISupplicantStaNetwork::EapMethod::PEAP;
-    sta_network_->setEapMethod(
-        set_eap_method, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    ISupplicantStaNetwork::EapPhase2Method set_eap_phase2_method =
-        ISupplicantStaNetwork::EapPhase2Method::NONE;
-    sta_network_->setEapPhase2Method(
-        set_eap_phase2_method, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapPhase2Method(
-        [&](const SupplicantStatus& status,
-            ISupplicantStaNetwork::EapPhase2Method eap_phase2_method) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(set_eap_phase2_method, eap_phase2_method);
-        });
-}
-
-/*
- * SetGetEapIdentity
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapIdentity) {
-    std::vector<uint8_t> set_identity(kTestIdentity, kTestIdentity + sizeof(kTestIdentity));
-    sta_network_->setEapIdentity(
-        set_identity, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapIdentity(
-        [&](const SupplicantStatus& status, const std::vector<uint8_t>& identity) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(set_identity, identity);
-        });
-}
-
-/*
- * SetGetEapAnonymousIdentity
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapAnonymousIdentity) {
-    std::vector<uint8_t> set_identity(kTestIdentity, kTestIdentity + sizeof(kTestIdentity));
-    sta_network_->setEapAnonymousIdentity(
-        set_identity, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapAnonymousIdentity(
-        [&](const SupplicantStatus& status, const std::vector<uint8_t>& identity) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-            EXPECT_EQ(set_identity, identity);
-        });
-}
-
-/*
- * SetGetEapPassword
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapPassword) {
-    std::vector<uint8_t> set_eap_passwd(
-        kTestEapPasswdStr, kTestEapPasswdStr + strlen(kTestEapPasswdStr));
-    sta_network_->setEapPassword(
-        set_eap_passwd, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapPassword([&](const SupplicantStatus& status,
-                                     const hidl_vec<uint8_t>& eap_passwd) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(set_eap_passwd, std::vector<uint8_t>(eap_passwd));
-    });
-}
-
-/*
- * SetGetEapCACert
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapCACert) {
-    sta_network_->setEapCACert(
-        kTestEapCert, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapCACert([&](const SupplicantStatus& status,
-                                   const hidl_string& eap_cert) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapCert, std::string(eap_cert.c_str()));
-    });
-}
-
-/*
- * SetGetEapCAPath
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapCAPath) {
-    sta_network_->setEapCAPath(
-        kTestEapCert, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapCAPath([&](const SupplicantStatus& status,
-                                   const hidl_string& eap_cert) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapCert, std::string(eap_cert.c_str()));
-    });
-}
-
-/*
- * SetGetEapClientCert
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapClientCert) {
-    sta_network_->setEapClientCert(
-        kTestEapCert, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapClientCert([&](const SupplicantStatus& status,
-                                       const hidl_string& eap_cert) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapCert, std::string(eap_cert.c_str()));
-    });
-}
-
-/*
- * SetGetEapPrivateKeyId
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapPrivateKeyId) {
-    sta_network_->setEapPrivateKeyId(
-        kTestEapPrivateKeyId, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapPrivateKeyId([&](const SupplicantStatus& status,
-                                         const hidl_string& key_id) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapPrivateKeyId, std::string(key_id.c_str()));
-    });
-}
-
-/*
- * SetGetEapAltSubjectMatch
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapAltSubjectMatch) {
-    sta_network_->setEapAltSubjectMatch(
-        kTestEapMatch, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapAltSubjectMatch([&](const SupplicantStatus& status,
-                                            const hidl_string& match) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapMatch, std::string(match.c_str()));
-    });
-}
-
-/*
- * SetGetEapSubjectMatch
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapSubjectMatch) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_network_, setEapSubjectMatch, kTestEapMatch).code);
-    const auto& status_and_subject_match =
-        HIDL_INVOKE(sta_network_, getEapSubjectMatch);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              status_and_subject_match.first.code);
-    EXPECT_EQ(kTestEapMatch,
-              std::string(status_and_subject_match.second.c_str()));
-}
-
-/*
- * SetGetEapDomainSuffixMatch
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapDomainSuffixMatch) {
-    sta_network_->setEapDomainSuffixMatch(
-        kTestEapMatch, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapDomainSuffixMatch([&](const SupplicantStatus& status,
-                                              const hidl_string& match) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapMatch, std::string(match.c_str()));
-    });
-}
-
-/*
- * SetGetEapEngine
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapEngine) {
-    sta_network_->setEapEngine(
-        true, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapEngine([&](const SupplicantStatus& status,
-                                   bool enable) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(true, enable);
-    });
-}
-
-/*
- * SetGetEapEngineID
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetGetEapEngineID) {
-    sta_network_->setEapEngineID(
-        kTestEapEngineID, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-    sta_network_->getEapEngineID([&](const SupplicantStatus& status,
-                                     const hidl_string& id) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        EXPECT_EQ(kTestEapEngineID, std::string(id.c_str()));
-    });
-}
-
-/*
- * Enable
- */
-TEST_P(SupplicantStaNetworkHidlTest, Enable) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    // wpa_supplicant doesn't perform any connection initiation
-    // unless atleast the Ssid and Ket mgmt params are set.
-    sta_network_->setSsid(ssid_, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->setKeyMgmt(kTestKeyMgmt, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-
-    sta_network_->enable(false, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->enable(true, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-
-    // Now remove the network and ensure that the calls fail.
-    removeNetwork();
-    sta_network_->enable(true, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::FAILURE_NETWORK_INVALID, status.code);
-    });
-}
-
-/*
- * Disable
- */
-TEST_P(SupplicantStaNetworkHidlTest, Disable) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    // wpa_supplicant doesn't perform any connection initiation
-    // unless atleast the Ssid and Ket mgmt params are set.
-    sta_network_->setSsid(ssid_, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->setKeyMgmt(kTestKeyMgmt, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-
-    sta_network_->disable([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    // Now remove the network and ensure that the calls fail.
-    removeNetwork();
-    sta_network_->disable([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::FAILURE_NETWORK_INVALID, status.code);
-    });
-}
-
-/*
- * Select.
- */
-TEST_P(SupplicantStaNetworkHidlTest, Select) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    // wpa_supplicant doesn't perform any connection initiation
-    // unless atleast the Ssid and Ket mgmt params are set.
-    sta_network_->setSsid(ssid_, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    sta_network_->setKeyMgmt(kTestKeyMgmt, [](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-
-    sta_network_->select([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-    });
-    // Now remove the network and ensure that the calls fail.
-    removeNetwork();
-    sta_network_->select([](const SupplicantStatus& status) {
-        EXPECT_EQ(SupplicantStatusCode::FAILURE_NETWORK_INVALID, status.code);
-    });
-}
-
-/*
- * SendNetworkEapSimGsmAuthResponse
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapSimGsmAuthResponse) {
-    std::vector<ISupplicantStaNetwork::NetworkResponseEapSimGsmAuthParams>
-        params;
-    ISupplicantStaNetwork::NetworkResponseEapSimGsmAuthParams param;
-    memcpy(param.kc.data(), kTestKc, param.kc.size());
-    memcpy(param.sres.data(), kTestSres, param.sres.size());
-    params.push_back(param);
-    sta_network_->sendNetworkEapSimGsmAuthResponse(
-        params, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SendNetworkEapSimGsmAuthFailure
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapSimGsmAuthFailure) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, sendNetworkEapSimGsmAuthFailure).code);
-}
-
-/*
- * SendNetworkEapSimUmtsAuthResponse
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapSimUmtsAuthResponse) {
-    ISupplicantStaNetwork::NetworkResponseEapSimUmtsAuthParams params;
-    params.res = std::vector<uint8_t>(kTestRes, kTestRes + sizeof(kTestRes));
-    memcpy(params.ik.data(), kTestIk, params.ik.size());
-    memcpy(params.ck.data(), kTestCk, params.ck.size());
-    sta_network_->sendNetworkEapSimUmtsAuthResponse(
-        params, [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SendNetworkEapSimUmtsAuthFailure
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapSimUmtsAuthFailure) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, sendNetworkEapSimUmtsAuthFailure).code);
-}
-
-/*
- * SendNetworkEapSimUmtsAutsResponse
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapSimUmtsAutsResponse) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, sendNetworkEapSimUmtsAutsResponse,
-                          kTestAutParam)
-                  .code);
-}
-
-/*
- * SendNetworkEapIdentityResponse
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapIdentityResponse) {
-    sta_network_->sendNetworkEapIdentityResponse(
-        std::vector<uint8_t>(kTestIdentity,
-                             kTestIdentity + sizeof(kTestIdentity)),
-        [](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * SetUpdateIdentifier
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetUpdateIdentifier) {
-    EXPECT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_network_, setUpdateIdentifier, kTestUpdateIdentifier)
-            .code);
-}
-
-/*
- * SetProactiveKeyCaching
- */
-TEST_P(SupplicantStaNetworkHidlTest, SetProactiveKeyCaching) {
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, setProactiveKeyCaching, true).code);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, setProactiveKeyCaching, false).code);
-}
-
-/*
- * GetWpsNfcConfigurationToken
- */
-TEST_P(SupplicantStaNetworkHidlTest, GetWpsNfcConfigurationToken) {
-    if (v1_3 != nullptr) {
-        GTEST_SKIP() << "Skipping test since HAL is 1.3 or higher";
-    }
-    ASSERT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, setSsid, ssid_).code);
-    ASSERT_EQ(SupplicantStatusCode::SUCCESS,
-              HIDL_INVOKE(sta_network_, setKeyMgmt, kTestKeyMgmt).code);
-    ASSERT_EQ(
-        SupplicantStatusCode::SUCCESS,
-        HIDL_INVOKE(sta_network_, setPskPassphrase, kTestPskPassphrase).code);
-    const auto& status_and_token =
-        HIDL_INVOKE(sta_network_, getWpsNfcConfigurationToken);
-    EXPECT_EQ(SupplicantStatusCode::SUCCESS, status_and_token.first.code);
-    EXPECT_FALSE(0 == status_and_token.second.size());
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantStaNetworkHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantStaNetworkHidlTest,
-    testing::Combine(
-        testing::ValuesIn(
-            android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            ISupplicant::descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.1/vts/functional/Android.bp b/wifi/supplicant/1.1/vts/functional/Android.bp
deleted file mode 100644
index 215c1cafb1..0000000000
--- a/wifi/supplicant/1.1/vts/functional/Android.bp
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// Copyright (C) 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package {
-    default_team: "trendy_team_fwk_wifi_hal",
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "hardware_interfaces_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["hardware_interfaces_license"],
-}
-
-cc_library_static {
-    name: "VtsHalWifiSupplicantV1_1TargetTestUtil",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: ["supplicant_hidl_test_utils_1_1.cpp"],
-    export_include_dirs: [
-        ".",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "android.hardware.wifi.supplicant@1.0",
-        "android.hardware.wifi.supplicant@1.1",
-        "android.hardware.wifi@1.0",
-        "libgmock",
-        "libwifi-system",
-        "libwifi-system-iface",
-    ],
-}
-
-cc_test {
-    name: "VtsHalWifiSupplicantV1_1TargetTest",
-    defaults: ["VtsHalTargetTestDefaults"],
-    srcs: [
-        "supplicant_hidl_test.cpp",
-        "supplicant_sta_iface_hidl_test.cpp",
-        "supplicant_sta_network_hidl_test.cpp",
-    ],
-    static_libs: [
-        "VtsHalWifiV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
-        "android.hardware.wifi.supplicant@1.0",
-        "android.hardware.wifi.supplicant@1.1",
-        "android.hardware.wifi.supplicant@1.2",
-        "android.hardware.wifi.supplicant@1.3",
-        "android.hardware.wifi.supplicant@1.4",
-        "android.hardware.wifi@1.0",
-        "android.hardware.wifi@1.1",
-        "libgmock",
-        "libwifi-system",
-        "libwifi-system-iface",
-    ],
-    test_suites: [
-        "general-tests",
-        "vts",
-    ],
-}
diff --git a/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test.cpp b/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test.cpp
deleted file mode 100644
index a8e72b854c..0000000000
--- a/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test.cpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-#include <cutils/properties.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.0/types.h>
-#include <android/hardware/wifi/supplicant/1.1/ISupplicant.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "supplicant_hidl_test_utils.h"
-#include "supplicant_hidl_test_utils_1_1.h"
-
-using ::android::hardware::hidl_vec;
-using ::android::hardware::wifi::supplicant::V1_0::ISupplicantIface;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::supplicant::V1_0::IfaceType;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicant;
-using ::android::hardware::wifi::V1_0::IWifi;
-using ::android::sp;
-
-class SupplicantHidlTest : public SupplicantHidlTestBaseV1_1 {
-   public:
-    virtual void SetUp() override { SupplicantHidlTestBaseV1_1::SetUp(); }
-
-   protected:
-    std::string getWlan0IfaceName() {
-        std::array<char, PROPERTY_VALUE_MAX> buffer;
-        property_get("wifi.interface", buffer.data(), "wlan0");
-        return buffer.data();
-    }
-
-    std::string getP2pIfaceName() {
-        std::array<char, PROPERTY_VALUE_MAX> buffer;
-        property_get("wifi.direct.interface", buffer.data(), "p2p0");
-        return buffer.data();
-    }
-};
-
-/*
- * AddStaInterface
- */
-TEST_P(SupplicantHidlTest, AddStaInterface) {
-    ISupplicant::IfaceInfo iface_info;
-    iface_info.name = getWlan0IfaceName();
-    iface_info.type = IfaceType::STA;
-    supplicant_->addInterface(
-        iface_info,
-        [&](const SupplicantStatus& status, const sp<ISupplicantIface>& iface) {
-            EXPECT_TRUE(
-                (status.code == SupplicantStatusCode::SUCCESS) ||
-                (status.code == SupplicantStatusCode::FAILURE_IFACE_EXISTS));
-            EXPECT_NE(nullptr, iface.get());
-        });
-}
-
-/*
- * AddP2pInterface
- */
-TEST_P(SupplicantHidlTest, AddP2pInterface) {
-    if (!isP2pOn_) return;
-    ISupplicant::IfaceInfo iface_info;
-    iface_info.name = getP2pIfaceName();
-    iface_info.type = IfaceType::P2P;
-    supplicant_->addInterface(
-        iface_info,
-        [&](const SupplicantStatus& status, const sp<ISupplicantIface>& iface) {
-            EXPECT_TRUE(
-                (status.code == SupplicantStatusCode::SUCCESS) ||
-                (status.code == SupplicantStatusCode::FAILURE_IFACE_EXISTS));
-            EXPECT_NE(nullptr, iface.get());
-        });
-}
-
-/*
- * RemoveStaInterface
- */
-TEST_P(SupplicantHidlTest, RemoveStaInterface) {
-    ISupplicant::IfaceInfo iface_info;
-    iface_info.name = getWlan0IfaceName();
-    iface_info.type = IfaceType::STA;
-
-    supplicant_->addInterface(
-        iface_info,
-        [&](const SupplicantStatus& status, const sp<ISupplicantIface>& iface) {
-            EXPECT_TRUE(
-                (status.code == SupplicantStatusCode::SUCCESS) ||
-                (status.code == SupplicantStatusCode::FAILURE_IFACE_EXISTS));
-            EXPECT_NE(nullptr, iface.get());
-        });
-    supplicant_->removeInterface(
-        iface_info, [&](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * RemoveP2pInterface
- */
-TEST_P(SupplicantHidlTest, RemoveP2pInterface) {
-    if (!isP2pOn_) return;
-    ISupplicant::IfaceInfo iface_info;
-    iface_info.name = getP2pIfaceName();
-    iface_info.type = IfaceType::P2P;
-
-    supplicant_->addInterface(
-        iface_info,
-        [&](const SupplicantStatus& status, const sp<ISupplicantIface>& iface) {
-            EXPECT_TRUE(
-                (status.code == SupplicantStatusCode::SUCCESS) ||
-                (status.code == SupplicantStatusCode::FAILURE_IFACE_EXISTS));
-            EXPECT_NE(nullptr, iface.get());
-        });
-    supplicant_->removeInterface(
-        iface_info, [&](const SupplicantStatus& status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * Terminate
- * This terminates the service.
- */
-TEST_P(SupplicantHidlTest, Terminate) { supplicant_->terminate(); }
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantHidlTest,
-    testing::Combine(
-        testing::ValuesIn(
-            android::hardware::getAllHalInstanceNames(IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            android::hardware::wifi::supplicant::V1_1::ISupplicant::
-                descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test_utils_1_1.cpp b/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test_utils_1_1.cpp
deleted file mode 100644
index b75a2fbccc..0000000000
--- a/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test_utils_1_1.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include "supplicant_hidl_test_utils.h"
-#include "supplicant_hidl_test_utils_1_1.h"
-
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicantStaIface;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicantStaNetwork;
-using ::android::sp;
-
-sp<ISupplicant> getSupplicant_1_1(const std::string& supplicant_instance_name,
-                                  bool isP2pOn) {
-    return ISupplicant::castFrom(
-        getSupplicant(supplicant_instance_name, isP2pOn));
-}
-
-sp<ISupplicantStaIface> getSupplicantStaIface_1_1(
-    const sp<ISupplicant>& supplicant) {
-    return ISupplicantStaIface::castFrom(getSupplicantStaIface(supplicant));
-}
-
-sp<ISupplicantStaNetwork> createSupplicantStaNetwork_1_1(
-    const sp<ISupplicant>& supplicant) {
-    return ISupplicantStaNetwork::castFrom(
-        createSupplicantStaNetwork(supplicant));
-}
diff --git a/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test_utils_1_1.h b/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test_utils_1_1.h
deleted file mode 100644
index b6feb41abe..0000000000
--- a/wifi/supplicant/1.1/vts/functional/supplicant_hidl_test_utils_1_1.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-#pragma clang diagnostic ignored "-Wweak-vtables"
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/supplicant/1.1/ISupplicant.h>
-#include <android/hardware/wifi/supplicant/1.1/ISupplicantStaIface.h>
-#include <android/hardware/wifi/supplicant/1.1/ISupplicantStaNetwork.h>
-#include <gtest/gtest.h>
-
-android::sp<android::hardware::wifi::supplicant::V1_1::ISupplicant>
-getSupplicant_1_1(const std::string& supplicant_instance_name, bool isP2pOn);
-
-android::sp<android::hardware::wifi::supplicant::V1_1::ISupplicantStaIface>
-getSupplicantStaIface_1_1(
-    const android::sp<android::hardware::wifi::supplicant::V1_1::ISupplicant>&
-        supplicant);
-
-android::sp<android::hardware::wifi::supplicant::V1_1::ISupplicantStaNetwork>
-createSupplicantStaNetwork_1_1(
-    const android::sp<android::hardware::wifi::supplicant::V1_1::ISupplicant>&
-        supplicant);
-
-class SupplicantHidlTestBaseV1_1 : public SupplicantHidlTestBase {
-   public:
-    virtual void SetUp() override {
-        SupplicantHidlTestBase::SetUp();
-        supplicant_ = getSupplicant_1_1(supplicant_instance_name_, isP2pOn_);
-        ASSERT_NE(supplicant_.get(), nullptr);
-    }
-
-   protected:
-    android::sp<android::hardware::wifi::supplicant::V1_1::ISupplicant>
-        supplicant_;
-};
diff --git a/wifi/supplicant/1.1/vts/functional/supplicant_sta_iface_hidl_test.cpp b/wifi/supplicant/1.1/vts/functional/supplicant_sta_iface_hidl_test.cpp
deleted file mode 100644
index 7e6e3e47b9..0000000000
--- a/wifi/supplicant/1.1/vts/functional/supplicant_sta_iface_hidl_test.cpp
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/1.1/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.1/ISupplicantStaIface.h>
-#include <android/hardware/wifi/supplicant/1.4/ISupplicantStaIface.h>
-#include <gtest/gtest.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "supplicant_hidl_test_utils.h"
-#include "supplicant_hidl_test_utils_1_1.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_array;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicantStaIface;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicantStaIfaceCallback;
-
-class SupplicantStaIfaceHidlTest : public SupplicantHidlTestBaseV1_1 {
-   public:
-    virtual void SetUp() override {
-        SupplicantHidlTestBaseV1_1::SetUp();
-        sta_iface_ = getSupplicantStaIface_1_1(supplicant_);
-        ASSERT_NE(sta_iface_.get(), nullptr);
-
-        v1_4 = ::android::hardware::wifi::supplicant::V1_4::
-            ISupplicantStaIface::castFrom(sta_iface_);
-    }
-
-   protected:
-    // ISupplicantStaIface object used for all tests in this fixture.
-    sp<ISupplicantStaIface> sta_iface_;
-    sp<::android::hardware::wifi::supplicant::V1_4::ISupplicantStaIface> v1_4 =
-        nullptr;
-};
-
-class IfaceCallback : public ISupplicantStaIfaceCallback {
-    Return<void> onNetworkAdded(uint32_t /* id */) override { return Void(); }
-    Return<void> onNetworkRemoved(uint32_t /* id */) override { return Void(); }
-    Return<void> onStateChanged(
-        ISupplicantStaIfaceCallback::State /* newState */,
-        const hidl_array<uint8_t, 6>& /*bssid */, uint32_t /* id */,
-        const hidl_vec<uint8_t>& /* ssid */) override {
-        return Void();
-    }
-    Return<void> onAnqpQueryDone(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        const ISupplicantStaIfaceCallback::AnqpData& /* data */,
-        const ISupplicantStaIfaceCallback::Hs20AnqpData& /* hs20Data */)
-        override {
-        return Void();
-    }
-    virtual Return<void> onHs20IconQueryDone(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        const hidl_string& /* fileName */,
-        const hidl_vec<uint8_t>& /* data */) override {
-        return Void();
-    }
-    virtual Return<void> onHs20SubscriptionRemediation(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantStaIfaceCallback::OsuMethod /* osuMethod */,
-        const hidl_string& /* url*/) override {
-        return Void();
-    }
-    Return<void> onHs20DeauthImminentNotice(
-        const hidl_array<uint8_t, 6>& /* bssid */, uint32_t /* reasonCode */,
-        uint32_t /* reAuthDelayInSec */,
-        const hidl_string& /* url */) override {
-        return Void();
-    }
-    Return<void> onDisconnected(const hidl_array<uint8_t, 6>& /* bssid */,
-                                bool /* locallyGenerated */,
-                                ISupplicantStaIfaceCallback::ReasonCode
-                                /* reasonCode */) override {
-        return Void();
-    }
-    Return<void> onAssociationRejected(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantStaIfaceCallback::StatusCode /* statusCode */,
-        bool /*timedOut */) override {
-        return Void();
-    }
-    Return<void> onAuthenticationTimeout(
-        const hidl_array<uint8_t, 6>& /* bssid */) override {
-        return Void();
-    }
-    Return<void> onBssidChanged(
-        ISupplicantStaIfaceCallback::BssidChangeReason /* reason */,
-        const hidl_array<uint8_t, 6>& /* bssid */) override {
-        return Void();
-    }
-    Return<void> onEapFailure() override { return Void(); }
-    Return<void> onEapFailure_1_1(
-        ISupplicantStaIfaceCallback::EapErrorCode /* eapErrorCode */) override {
-        return Void();
-    }
-    Return<void> onWpsEventSuccess() override { return Void(); }
-    Return<void> onWpsEventFail(
-        const hidl_array<uint8_t, 6>& /* bssid */,
-        ISupplicantStaIfaceCallback::WpsConfigError /* configError */,
-        ISupplicantStaIfaceCallback::WpsErrorIndication /* errorInd */)
-        override {
-        return Void();
-    }
-    Return<void> onWpsEventPbcOverlap() override { return Void(); }
-    Return<void> onExtRadioWorkStart(uint32_t /* id */) override {
-        return Void();
-    }
-    Return<void> onExtRadioWorkTimeout(uint32_t /* id*/) override {
-        return Void();
-    }
-};
-
-/*
- * RegisterCallback_1_1
- */
-TEST_P(SupplicantStaIfaceHidlTest, RegisterCallback_1_1) {
-    // This API is deprecated from v1.4 HAL.
-    SupplicantStatusCode expectedCode =
-        (nullptr != v1_4) ? SupplicantStatusCode::FAILURE_UNKNOWN
-                          : SupplicantStatusCode::SUCCESS;
-    sta_iface_->registerCallback_1_1(new IfaceCallback(),
-                                     [&](const SupplicantStatus& status) {
-                                         EXPECT_EQ(expectedCode, status.code);
-                                     });
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantStaIfaceHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantStaIfaceHidlTest,
-    testing::Combine(
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            android::hardware::wifi::V1_0::IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            android::hardware::wifi::supplicant::V1_1::ISupplicant::
-                descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.1/vts/functional/supplicant_sta_network_hidl_test.cpp b/wifi/supplicant/1.1/vts/functional/supplicant_sta_network_hidl_test.cpp
deleted file mode 100644
index 37641a4a04..0000000000
--- a/wifi/supplicant/1.1/vts/functional/supplicant_sta_network_hidl_test.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android-base/logging.h>
-
-#include <VtsCoreUtil.h>
-#include <android/hardware/wifi/1.0/IWifi.h>
-#include <android/hardware/wifi/supplicant/1.1/ISupplicantStaNetwork.h>
-#include <hidl/GtestPrinter.h>
-#include <hidl/ServiceManagement.h>
-
-#include "supplicant_hidl_test_utils.h"
-#include "supplicant_hidl_test_utils_1_1.h"
-
-using ::android::sp;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatus;
-using ::android::hardware::wifi::supplicant::V1_0::SupplicantStatusCode;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicant;
-using ::android::hardware::wifi::supplicant::V1_1::ISupplicantStaNetwork;
-
-namespace {
-constexpr uint8_t kTestIdentity[] = {0x45, 0x67, 0x98, 0x67, 0x56};
-constexpr uint8_t kTestEncryptedIdentity[] = {0x35, 0x37, 0x58, 0x57, 0x26};
-}  // namespace
-
-class SupplicantStaNetworkHidlTest : public SupplicantHidlTestBaseV1_1 {
-   public:
-    virtual void SetUp() override {
-        SupplicantHidlTestBaseV1_1::SetUp();
-        sta_network_ = createSupplicantStaNetwork_1_1(supplicant_);
-        ASSERT_NE(sta_network_.get(), nullptr);
-    }
-
-   protected:
-    // ISupplicantStaNetwork object used for all tests in this fixture.
-    sp<ISupplicantStaNetwork> sta_network_;
-};
-
-/*
- * Create:
- * Ensures that an instance of the ISupplicantStaNetwork proxy object is
- * successfully created.
- */
-TEST_P(SupplicantStaNetworkHidlTest, Create) {
-    stopSupplicant(wifi_v1_0_instance_name_);
-    startSupplicantAndWaitForHidlService(wifi_v1_0_instance_name_,
-                                         supplicant_instance_name_);
-    sp<ISupplicant> supplicant =
-        getSupplicant_1_1(supplicant_instance_name_, isP2pOn_);
-    EXPECT_NE(nullptr, createSupplicantStaNetwork_1_1(supplicant).get());
-}
-
-/*
- * Ensure that the encrypted imsi identity is set successfully.
- */
-TEST_P(SupplicantStaNetworkHidlTest, setEapEncryptedImsiIdentity) {
-    std::vector<uint8_t> encrypted_identity(
-        kTestEncryptedIdentity,
-        kTestEncryptedIdentity + sizeof(kTestEncryptedIdentity));
-    sta_network_->setEapEncryptedImsiIdentity(
-        encrypted_identity, [](const SupplicantStatus &status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-/*
- * Ensure that the identity and the encrypted imsi identity are sent
- * successfully.
- */
-TEST_P(SupplicantStaNetworkHidlTest, SendNetworkEapIdentityResponse_1_1) {
-    sta_network_->sendNetworkEapIdentityResponse_1_1(
-        std::vector<uint8_t>(kTestIdentity,
-                             kTestIdentity + sizeof(kTestIdentity)),
-        std::vector<uint8_t>(kTestEncryptedIdentity,
-                             kTestIdentity + sizeof(kTestEncryptedIdentity)),
-        [](const SupplicantStatus &status) {
-            EXPECT_EQ(SupplicantStatusCode::SUCCESS, status.code);
-        });
-}
-
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SupplicantStaNetworkHidlTest);
-INSTANTIATE_TEST_CASE_P(
-    PerInstance, SupplicantStaNetworkHidlTest,
-    testing::Combine(
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            android::hardware::wifi::V1_0::IWifi::descriptor)),
-        testing::ValuesIn(android::hardware::getAllHalInstanceNames(
-            android::hardware::wifi::supplicant::V1_1::ISupplicant::
-                descriptor))),
-    android::hardware::PrintInstanceTupleNameToString<>);
diff --git a/wifi/supplicant/1.2/vts/functional/Android.bp b/wifi/supplicant/1.2/vts/functional/Android.bp
index 65a17a8df2..5ed7b17a26 100644
--- a/wifi/supplicant/1.2/vts/functional/Android.bp
+++ b/wifi/supplicant/1.2/vts/functional/Android.bp
@@ -34,7 +34,6 @@ cc_library_static {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "android.hardware.wifi.supplicant@1.0",
         "android.hardware.wifi.supplicant@1.1",
         "android.hardware.wifi.supplicant@1.2",
@@ -55,7 +54,6 @@ cc_test {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "android.hardware.wifi.supplicant@1.0",
         "android.hardware.wifi.supplicant@1.1",
@@ -83,7 +81,6 @@ cc_test {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "android.hardware.wifi.supplicant@1.0",
         "android.hardware.wifi.supplicant@1.1",
diff --git a/wifi/supplicant/1.3/vts/functional/Android.bp b/wifi/supplicant/1.3/vts/functional/Android.bp
index 609de11cee..838107cc53 100644
--- a/wifi/supplicant/1.3/vts/functional/Android.bp
+++ b/wifi/supplicant/1.3/vts/functional/Android.bp
@@ -34,7 +34,6 @@ cc_library_static {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "android.hardware.wifi.supplicant@1.0",
         "android.hardware.wifi.supplicant@1.1",
@@ -57,7 +56,6 @@ cc_test {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "VtsHalWifiSupplicantV1_3TargetTestUtil",
         "android.hardware.wifi.supplicant@1.0",
diff --git a/wifi/supplicant/1.4/vts/functional/Android.bp b/wifi/supplicant/1.4/vts/functional/Android.bp
index def3b863f6..8fe68d4056 100644
--- a/wifi/supplicant/1.4/vts/functional/Android.bp
+++ b/wifi/supplicant/1.4/vts/functional/Android.bp
@@ -34,7 +34,6 @@ cc_library_static {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "VtsHalWifiSupplicantV1_3TargetTestUtil",
         "android.hardware.wifi.supplicant@1.0",
@@ -59,7 +58,6 @@ cc_test {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "VtsHalWifiSupplicantV1_3TargetTestUtil",
         "VtsHalWifiSupplicantV1_4TargetTestUtil",
@@ -89,7 +87,6 @@ cc_test {
     static_libs: [
         "VtsHalWifiV1_0TargetTestUtil",
         "VtsHalWifiSupplicantV1_0TargetTestUtil",
-        "VtsHalWifiSupplicantV1_1TargetTestUtil",
         "VtsHalWifiSupplicantV1_2TargetTestUtil",
         "VtsHalWifiSupplicantV1_3TargetTestUtil",
         "VtsHalWifiSupplicantV1_4TargetTestUtil",
diff --git a/wifi/supplicant/aidl/vts/functional/supplicant_aidl_test_utils.h b/wifi/supplicant/aidl/vts/functional/supplicant_aidl_test_utils.h
index a850e507f0..9e92cf9dcb 100644
--- a/wifi/supplicant/aidl/vts/functional/supplicant_aidl_test_utils.h
+++ b/wifi/supplicant/aidl/vts/functional/supplicant_aidl_test_utils.h
@@ -31,18 +31,19 @@ const std::string kWifiInstanceNameStr = std::string() + IWifi::descriptor + "/d
 const char* kWifiInstanceName = kWifiInstanceNameStr.c_str();
 
 // Initialize the driver and firmware to STA mode using the vendor HAL.
-void initializeDriverAndFirmware(const std::string& wifi_instance_name) {
+bool initializeDriverAndFirmware(const std::string& wifi_instance_name) {
     // Skip if wifi instance is not set.
     if (wifi_instance_name == "") {
-        return;
+        return false;
     }
     if (getWifi(wifi_instance_name.c_str()) != nullptr) {
         std::shared_ptr<IWifiChip> wifi_chip = getWifiChip(wifi_instance_name.c_str());
         int mode_id;
-        EXPECT_TRUE(configureChipToSupportConcurrencyType(wifi_chip, IfaceConcurrencyType::STA,
-                                                          &mode_id));
+        return configureChipToSupportConcurrencyType(wifi_chip, IfaceConcurrencyType::STA,
+                                                     &mode_id);
     } else {
         LOG(WARNING) << __func__ << ": Vendor HAL not supported";
+        return false;
     }
 }
 
@@ -117,7 +118,11 @@ bool useAidlService() {
 }
 
 void startSupplicant() {
-    initializeDriverAndFirmware(kWifiInstanceName);
+    // Retry the driver and firmware initialization if it fails the first time.
+    if (!initializeDriverAndFirmware(kWifiInstanceName)) {
+        sleep(1);
+        ASSERT_TRUE(initializeDriverAndFirmware(kWifiInstanceName));
+    }
     SupplicantManager supplicant_manager;
     ASSERT_TRUE(supplicant_manager.StartSupplicant());
     ASSERT_TRUE(supplicant_manager.IsSupplicantRunning());
diff --git a/wifi/supplicant/aidl/vts/functional/supplicant_test_utils.h b/wifi/supplicant/aidl/vts/functional/supplicant_test_utils.h
index e39e2f44c2..628841fb73 100644
--- a/wifi/supplicant/aidl/vts/functional/supplicant_test_utils.h
+++ b/wifi/supplicant/aidl/vts/functional/supplicant_test_utils.h
@@ -83,8 +83,21 @@ void addP2pIface(const std::shared_ptr<ISupplicant> supplicant) {
 }
 
 std::shared_ptr<ISupplicant> getSupplicant(const char* supplicant_name) {
-    std::shared_ptr<ISupplicant> supplicant = ISupplicant::fromBinder(
-        ndk::SpAIBinder(AServiceManager_waitForService(supplicant_name)));
+    // Retry supplicant retrieval if needed
+    std::shared_ptr<ISupplicant> supplicant;
+    for (int i = 0; i < 3; i++) {
+        supplicant = ISupplicant::fromBinder(
+                ndk::SpAIBinder(AServiceManager_waitForService(supplicant_name)));
+        if (supplicant != nullptr) {
+            break;
+        }
+        sleep(1);  // sleep for 1 second
+    }
+
+    if (supplicant == nullptr) {
+        return nullptr;
+    }
+
     addStaIface(supplicant);
     if (testing::deviceSupportsFeature("android.hardware.wifi.direct")) {
         addP2pIface(supplicant);
```

