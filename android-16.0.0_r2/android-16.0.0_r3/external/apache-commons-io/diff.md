```diff
diff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml
index 120d34f3..a61b7d0f 100644
--- a/.github/workflows/codeql-analysis.yml
+++ b/.github/workflows/codeql-analysis.yml
@@ -16,13 +16,18 @@
 name: "CodeQL"
 
 on:
+  workflow_dispatch:
   push:
     branches: [ master ]
+    paths-ignore:
+      - '**/workflows/*.yml'
+      - '!**/workflows/codeql-analysis.yml'
   pull_request:
+    paths-ignore:
+      - '**/workflows/*.yml'
+      - '!**/workflows/codeql-analysis.yml'
     # The branches below must be a subset of the branches above
     branches: [ master ]
-  schedule:
-    - cron: '33 9 * * 4'
 
 permissions:
   contents: read
@@ -45,10 +50,10 @@ jobs:
 
     steps:
     - name: Checkout repository
-      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         persist-credentials: false
-    - uses: actions/cache@704facf57e6136b1bc63b828d79edcd491f0ee84 # v3.3.2
+    - uses: actions/cache@6849a6489940f00c2f30c0fb92c6274307ccb58a # v4.1.2
       with:
         path: ~/.m2/repository
         key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
@@ -57,7 +62,7 @@ jobs:
 
     # Initializes the CodeQL tools for scanning.
     - name: Initialize CodeQL
-      uses: github/codeql-action/init@0116bc2df50751f9724a2e35ef1f24d22f90e4e1 # v2.22.3
+      uses: github/codeql-action/init@ea9e4e37992a54ee68a9622e985e60c8e8f12d9f    # 3.27.4
       with:
         languages: ${{ matrix.language }}
         # If you wish to specify custom queries, you can do so here or in a config file.
@@ -68,7 +73,7 @@ jobs:
     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
     # If this step fails, then you should remove it and run the build manually (see below)
     - name: Autobuild
-      uses: github/codeql-action/autobuild@0116bc2df50751f9724a2e35ef1f24d22f90e4e1 # v2.22.3
+      uses: github/codeql-action/autobuild@ea9e4e37992a54ee68a9622e985e60c8e8f12d9f    # 3.27.4
 
     # â„¹ï¸ Command-line programs to run using the OS shell.
     # ðŸ“š https://git.io/JvXDl
@@ -82,4 +87,4 @@ jobs:
     #   make release
 
     - name: Perform CodeQL Analysis
-      uses: github/codeql-action/analyze@0116bc2df50751f9724a2e35ef1f24d22f90e4e1 # v2.22.3
+      uses: github/codeql-action/analyze@ea9e4e37992a54ee68a9622e985e60c8e8f12d9f    # 3.27.4
diff --git a/.github/workflows/coverage.yml b/.github/workflows/coverage.yml
deleted file mode 100644
index 5c778d55..00000000
--- a/.github/workflows/coverage.yml
+++ /dev/null
@@ -1,52 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-name: Coverage
-
-on: [push, pull_request]
-
-permissions:
-  contents: read
-
-jobs:
-  build:
-
-    runs-on: ubuntu-latest
-    strategy:
-      matrix:
-        java: [ 8 ]
-
-    steps:
-    - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
-      with:
-        persist-credentials: false
-    - uses: actions/cache@704facf57e6136b1bc63b828d79edcd491f0ee84 # v3.3.2
-      with:
-        path: ~/.m2/repository
-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
-        restore-keys: |
-          ${{ runner.os }}-maven-
-    - name: Set up JDK ${{ matrix.java }}
-      uses: actions/setup-java@0ab4596768b603586c0de567f2430c30f5b0d2b0 # v3.13.0
-      with:
-        distribution: 'temurin'
-        java-version: ${{ matrix.java }}
-    - name: Build with Maven
-      run: mvn --show-version --batch-mode --no-transfer-progress test jacoco:report
-
-    - name: Upload coverage to Codecov
-      uses: codecov/codecov-action@eaaf4bedf32dbdc6b720b63067d99c4d77d6047d # v3.1.4
-      with:
-        files: ./target/site/jacoco/jacoco.xml
diff --git a/.github/workflows/dependency-review.yml b/.github/workflows/dependency-review.yml
new file mode 100644
index 00000000..6da427d5
--- /dev/null
+++ b/.github/workflows/dependency-review.yml
@@ -0,0 +1,31 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+name: 'Dependency Review'
+on: [pull_request]
+
+permissions:
+  contents: read
+
+jobs:
+  dependency-review:
+    runs-on: ubuntu-latest
+    steps:
+      - name: 'Checkout Repository'
+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
+      - name: 'Dependency Review PR'
+        uses: actions/dependency-review-action@4081bf99e2866ebe428fc0477b69eb4fcda7220a # v4.4.0
diff --git a/.github/workflows/maven.yml b/.github/workflows/maven.yml
index 3ed497d6..8f1bfc4c 100644
--- a/.github/workflows/maven.yml
+++ b/.github/workflows/maven.yml
@@ -15,7 +15,16 @@
 
 name: Java CI
 
-on: [push, pull_request]
+on:
+  workflow_dispatch:
+  push:
+    paths-ignore:
+      - '**/workflows/*.yml'
+      - '!**/workflows/maven.yml'
+  pull_request:
+    paths-ignore:
+      - '**/workflows/*.yml'
+      - '!**/workflows/maven.yml'
 
 permissions:
   contents: read
@@ -27,35 +36,70 @@ jobs:
     continue-on-error: ${{ matrix.experimental }}
     strategy:
       matrix:
-        os: [ubuntu-latest, windows-latest, macos-latest]
+        os: [ubuntu-latest, windows-latest, macos-13]
         java: [ 8, 11, 17, 21 ]
         experimental: [false]
-#        include:
-#          - java: 22-ea
-#            os: ubuntu-latest
-#            experimental: true        
-#          - java: 22-ea
-#            os: windows-latest
-#            experimental: true        
-#          - java: 22-ea
-#            os: macos-latest
-#            experimental: true        
+        # Keep the same parameter order as the matrix above
+        include:
+          # Use Java 21 and Ubuntu to add deploy step
+          - os: ubuntu-latest
+            java: 21
+            experimental: false
+            deploy: true
+          # Experimental builds: Java 23
+          - os: ubuntu-latest
+            java: 23
+            experimental: false
+          - os: windows-latest
+            java: 23
+            experimental: false
+          - os: macos-latest
+            java: 23
+            experimental: false
+          # Experimental builds: Java 24-ea
+          - os: ubuntu-latest
+            java: 24-ea
+            experimental: true
+          - os: windows-latest
+            java: 24-ea
+            experimental: true
+          - os: macos-latest
+            java: 24-ea
+            experimental: true
       fail-fast: false
         
     steps:
-    - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         persist-credentials: false
-    - uses: actions/cache@704facf57e6136b1bc63b828d79edcd491f0ee84 # v3.3.2
+    - uses: actions/cache@6849a6489940f00c2f30c0fb92c6274307ccb58a # v4.1.2
       with:
         path: ~/.m2/repository
         key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
         restore-keys: |
           ${{ runner.os }}-maven-
     - name: Set up JDK ${{ matrix.java }}
-      uses: actions/setup-java@0ab4596768b603586c0de567f2430c30f5b0d2b0 # v3.13.0
+      uses: actions/setup-java@8df1039502a15bceb9433410b1a100fbe190c53b # v4.5.0
       with:
         distribution: 'temurin'
         java-version: ${{ matrix.java }}
+        # these values cause the plugin to set up the Maven settings.xml file
+        server-id: apache.snapshots.https # Value of the distributionManagement/repository/id field of the pom.xml
+        server-username: NEXUS_USER # env variable for username in deploy
+        server-password: NEXUS_PW # env variable for token in deploy
     - name: Build with Maven
-      run: mvn --show-version --batch-mode --no-transfer-progress -DtrimStackTrace=false
+      if: ${{ !matrix.experimental }}
+      run: mvn --errors --show-version --batch-mode --no-transfer-progress -DtrimStackTrace=false
+    - name: Test only with Maven
+      if: ${{ matrix.experimental }}
+      # Skip PMD etc when using experimental Java
+      run: mvn --errors --show-version --batch-mode --no-transfer-progress -DtrimStackTrace=false clean test
+    - name: Deploy SNAPSHOT using minimal build
+      if: matrix.deploy && github.repository == 'apache/commons-io' && github.ref_name == 'master' 
+      env:
+        NEXUS_USER: ${{ secrets.NEXUS_USER }}
+        NEXUS_PW: ${{ secrets.NEXUS_PW }}
+      run: >
+        echo "Deploy SNAPSHOT" >> $GITHUB_STEP_SUMMARY;
+        mvn --show-version --batch-mode --no-transfer-progress deploy -Dgpg.skip 
+        -DskipTests -Drat.skip -Djacoco.skip -Dcyclonedx.skip -Dspotbugs.skip -Dspdx.skip -Dpmd.skip
diff --git a/.github/workflows/scorecards-analysis.yml b/.github/workflows/scorecards-analysis.yml
index 890f0498..9119ca56 100644
--- a/.github/workflows/scorecards-analysis.yml
+++ b/.github/workflows/scorecards-analysis.yml
@@ -16,11 +16,13 @@
 name: "Scorecards supply-chain security"
 
 on:
+  workflow_dispatch:
   branch_protection_rule:
-  schedule:
-    - cron: "30 1 * * 6"    # Weekly on Saturdays
   push:
     branches: [ "master" ]
+    paths-ignore:
+      - '**/workflows/*.yml'
+      - '!**/workflows/scorecards-analysis.yml'
 
 permissions: read-all
 
@@ -40,12 +42,12 @@ jobs:
     steps:
 
       - name: "Checkout code"
-        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
         with:
           persist-credentials: false
 
       - name: "Run analysis"
-        uses: ossf/scorecard-action@483ef80eb98fb506c348f7d62e28055e49fe2398    # 2.3.0
+        uses: ossf/scorecard-action@62b2cac7ed8198b15735ed49ab1e5cf35480ba46    # 2.4.0
         with:
           results_file: results.sarif
           results_format: sarif
@@ -57,13 +59,13 @@ jobs:
           publish_results: true
 
       - name: "Upload artifact"
-        uses: actions/upload-artifact@a8a3f3ad30e3422c9c7b888a15615d19a852ae32    # 3.1.3
+        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882    # 4.4.3
         with:
           name: SARIF file
           path: results.sarif
           retention-days: 5
 
       - name: "Upload to code-scanning"
-        uses: github/codeql-action/upload-sarif@0116bc2df50751f9724a2e35ef1f24d22f90e4e1    # 2.22.3
+        uses: github/codeql-action/upload-sarif@ea9e4e37992a54ee68a9622e985e60c8e8f12d9f    # 3.27.4
         with:
           sarif_file: results.sarif
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index e2748c9f..5202076f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -41,28 +41,27 @@
 Contributing to Apache Commons IO
 ======================
 
-You have found a bug or you have an idea for a cool new feature? Contributing code is a great way to give something back to
-the open source community. Before you dig right into the code there are a few guidelines that we need contributors to
-follow so that we can have a chance of keeping on top of things.
+Have you found a bug or have an idea for a cool new feature? Contributing code is a great way to give something back to the open-source community.
+Before you dig right into the code, we need contributors to follow a few guidelines to have a chance of keeping on top of things.
 
 Getting Started
 ---------------
 
 + Make sure you have a [JIRA account](https://issues.apache.org/jira/).
-+ Make sure you have a [GitHub account](https://github.com/signup/free).
++ Make sure you have a [GitHub account](https://github.com/signup/free). This is not essential, but makes providing patches much easier.
 + If you're planning to implement a new feature it makes sense to discuss your changes on the [dev list](https://commons.apache.org/mail-lists.html) first. This way you can make sure you're not wasting your time on something that isn't considered to be in Apache Commons IO's scope.
 + Submit a [Jira Ticket][jira] for your issue, assuming one does not already exist.
   + Clearly describe the issue including steps to reproduce when it is a bug.
   + Make sure you fill in the earliest version that you know has the issue.
 + Find the corresponding [repository on GitHub](https://github.com/apache/?query=commons-),
-[fork](https://help.github.com/articles/fork-a-repo/) and check out your forked repository.
+[fork](https://help.github.com/articles/fork-a-repo/) and check out your forked repository. If you don't have a GitHub account, you can still clone the Commons repository.
 
 Making Changes
 --------------
 
 + Create a _topic branch_ for your isolated work.
   * Usually you should base your branch on the `master` branch.
-  * A good topic branch name can be the JIRA bug id plus a keyword, e.g. `IO-123-InputStream`.
+  * A good topic branch name can be the JIRA bug ID plus a keyword, e.g. `IO-123-InputStream`.
   * If you have submitted multiple JIRA issues, try to maintain separate branches and pull requests.
 + Make commits of logical units.
   * Make sure your commit messages are meaningful and in the proper format. Your commit message should contain the key of the JIRA issue.
@@ -72,7 +71,7 @@ Making Changes
   + Create minimal diffs - disable _On Save_ actions like _Reformat Source Code_ or _Organize Imports_. If you feel the source code should be reformatted create a separate PR for this change first.
   + Check for unnecessary whitespace with `git diff` -- check before committing.
 + Make sure you have added the necessary tests for your changes, typically in `src/test/java`.
-+ Run all the tests with `mvn clean verify` to assure nothing else was accidentally broken.
++ Run all the tests with `mvn clean verify` to ensure nothing else was accidentally broken.
 
 Making Trivial Changes
 ----------------------
@@ -109,7 +108,6 @@ Additional Resources
 + [General GitHub documentation](https://help.github.com/)
 + [GitHub pull request documentation](https://help.github.com/articles/creating-a-pull-request/)
 + [Apache Commons Twitter Account](https://twitter.com/ApacheCommons)
-+ `#apache-commons` IRC channel on `irc.freenode.net`
 
 [cla]:https://www.apache.org/licenses/#clas
 [jira]:https://issues.apache.org/jira/browse/IO
diff --git a/METADATA b/METADATA
index 3833c5d0..de8f48bd 100644
--- a/METADATA
+++ b/METADATA
@@ -1,23 +1,20 @@
 # This project was upgraded with external_updater.
-# Usage: tools/external_updater/updater.sh update apache-commons-io
-# For more info, check https://cs.android.com/android/platform/superproject/+/main:tools/external_updater/README.md
+# Usage: tools/external_updater/updater.sh update external/apache-commons-io
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
 
 name: "apache-commons-io"
 description: "The Apache Commons IO library contains utility classes, stream implementations, file filters, file comparators, endian transformation classes, and much more."
 third_party {
-  url {
-    type: HOMEPAGE
-    value: "https://commons.apache.org/proper/commons-io/"
-  }
-  url {
-    type: GIT
-    value: "https://github.com/apache/commons-io.git"
-  }
-  version: "rel/commons-io-2.15.0"
   license_type: NOTICE
   last_upgrade_date {
-    year: 2023
-    month: 11
-    day: 1
+    year: 2025
+    month: 4
+    day: 8
+  }
+  homepage: "https://commons.apache.org/proper/commons-io/"
+  identifier {
+    type: "Git"
+    value: "https://github.com/apache/commons-io.git"
+    version: "rel/commons-io-2.18.0"
   }
 }
diff --git a/NOTICE.txt b/NOTICE.txt
index 20d8ffa2..e7dbcdc2 100644
--- a/NOTICE.txt
+++ b/NOTICE.txt
@@ -1,5 +1,5 @@
 Apache Commons IO
-Copyright 2002-2023 The Apache Software Foundation
+Copyright 2002-2024 The Apache Software Foundation
 
 This product includes software developed at
 The Apache Software Foundation (https://www.apache.org/).
diff --git a/README.md b/README.md
index 48bf0123..3f4e96dd 100644
--- a/README.md
+++ b/README.md
@@ -43,11 +43,10 @@
 Apache Commons IO
 ===================
 
-[![GitHub Actions Status](https://github.com/apache/commons-io/workflows/Java%20CI/badge.svg)](https://github.com/apache/commons-io/actions)
-[![Coverage Status](https://codecov.io/gh/apache/commons-io/branch/master/graph/badge.svg)](https://app.codecov.io/gh/apache/commons-io)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/commons-io/commons-io/badge.svg?gav=true)](https://maven-badges.herokuapp.com/maven-central/commons-io/commons-io/?gav=true)
-[![Javadocs](https://javadoc.io/badge/commons-io/commons-io/2.15.0.svg)](https://javadoc.io/doc/commons-io/commons-io/2.15.0)
-[![CodeQL](https://github.com/apache/commons-io/workflows/CodeQL/badge.svg)](https://github.com/apache/commons-io/actions/workflows/codeql-analysis.yml?query=workflow%3ACodeQL)
+[![Java CI](https://github.com/apache/commons-io/actions/workflows/maven.yml/badge.svg)](https://github.com/apache/commons-io/actions/workflows/maven.yml)
+[![Maven Central](https://img.shields.io/maven-central/v/commons-io/commons-io?label=Maven%20Central)](https://search.maven.org/artifact/commons-io/commons-io)
+[![Javadocs](https://javadoc.io/badge/commons-io/commons-io/2.18.0.svg)](https://javadoc.io/doc/commons-io/commons-io/2.18.0)
+[![CodeQL](https://github.com/apache/commons-io/actions/workflows/codeql-analysis.yml/badge.svg)](https://github.com/apache/commons-io/actions/workflows/codeql-analysis.yml)
 [![OpenSSF Scorecard](https://api.securityscorecards.dev/projects/github.com/apache/commons-io/badge)](https://api.securityscorecards.dev/projects/github.com/apache/commons-io)
 
 The Apache Commons IO library contains utility classes, stream implementations, file filters,
@@ -58,26 +57,26 @@ Documentation
 
 More information can be found on the [Apache Commons IO homepage](https://commons.apache.org/proper/commons-io).
 The [Javadoc](https://commons.apache.org/proper/commons-io/apidocs) can be browsed.
-Questions related to the usage of Apache Commons IO should be posted to the [user mailing list][ml].
+Questions related to the usage of Apache Commons IO should be posted to the [user mailing list](https://commons.apache.org/mail-lists.html).
 
 Getting the latest release
 --------------------------
 You can download source and binaries from our [download page](https://commons.apache.org/proper/commons-io/download_io.cgi).
 
-Alternatively, you can pull it from  the central Maven repositories:
+Alternatively, you can pull it from the central Maven repositories:
 
 ```xml
 <dependency>
   <groupId>commons-io</groupId>
   <artifactId>commons-io</artifactId>
-  <version>2.15.0</version>
+  <version>2.18.0</version>
 </dependency>
 ```
 
 Building
 --------
 
-Building requires a Java JDK and [Apache Maven](https://maven.apache.org/). 
+Building requires a Java JDK and [Apache Maven](https://maven.apache.org/).
 The required Java version is found in the `pom.xml` as the `maven.compiler.source` property.
 
 From a command shell, run `mvn` without arguments to invoke the default Maven goal to run all tests and checks.
@@ -90,7 +89,9 @@ There are some guidelines which will make applying PRs easier for us:
 + No tabs! Please use spaces for indentation.
 + Respect the existing code style for each file.
 + Create minimal diffs - disable on save actions like reformat source code or organize imports. If you feel the source code should be reformatted create a separate PR for this change.
-+ Provide JUnit tests for your changes and make sure your changes don't break any existing tests by running ```mvn```.
++ Provide JUnit tests for your changes and make sure your changes don't break any existing tests by running `mvn`.
++ Before you pushing a PR, run `mvn` (by itself), this runs the default goal, which contains all build checks.
++ To see the code coverage report, regardless of coverage failures, run `mvn clean site -Dcommons.jacoco.haltOnFailure=false`
 
 If you plan to contribute on a regular basis, please consider filing a [contributor license agreement](https://www.apache.org/licenses/#clas).
 You can learn more about contributing via GitHub in our [contribution guidelines](CONTRIBUTING.md).
@@ -112,7 +113,6 @@ Additional Resources
 + [Apache Issue Tracker (JIRA)](https://issues.apache.org/jira/browse/IO)
 + [Apache Commons Slack Channel](https://the-asf.slack.com/archives/C60NVB8AD)
 + [Apache Commons Twitter Account](https://twitter.com/ApacheCommons)
-+ `#apache-commons` IRC channel on `irc.freenode.org`
 
 Apache Commons Components
 -------------------------
diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 7eb52960..b3b62dfa 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -1,8 +1,496 @@
+
+Apache Commons IO 2.18.0 Release Notes
+
+Introduction
+------------
+
+The Apache Commons IO library contains utility classes, stream implementations, file filters,
+file comparators, endian transformation classes, and much more.
+
+Version 2.18.0: Java 8 is required.
+
+New features
+------------
+
+o          Add @FunctionalInterface to ClassNameMatcher. Thanks to Gary Gregory. 
+o          Add ValidatingObjectInputStream.Builder and ValidatingObjectInputStream.builder(). Thanks to Gary Gregory. 
+o          Add a "Safe Deserialization" section to the User Guide for the site. Thanks to Gary Gregory. 
+o          Add IORandomAccessFile. Thanks to Gary Gregory. 
+o          Add RandomAccessFileMode.io(String). Thanks to Gary Gregory. 
+o          Add FileAlterationObserver.Builder() and deprecate most constructors. Thanks to Gary Gregory. 
+o          Add IOUtils.readLines(CharSequence). Thanks to Gary Gregory. 
+o          Add ValidatingObjectInputStream.ObjectStreamClassPredicate to allow configuration reuse. Thanks to Gary Gregory. 
+o          Add RandomAccessFileMode.accept(Path, IOConsumer<RandomAccessFile>). Thanks to Gary Gregory. 
+o          Add RandomAccessFileMode.apply(Path, IOFunction<RandomAccessFile>, T). Thanks to Gary Gregory. 
+o          Add IOIntConsumer. Thanks to Gary Gregory. 
+o IO-861:  Add ProxyInputStream.AbstractBuilder. Supports setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o          Add support to AutoCloseInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o          Add support to BOMInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o IO-861:  Add support to BoundedInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o IO-861:  Add support to BoundedInputStream for setting a consumer for BoundedInputStream.onMaxLength(long, long). Thanks to Gary Gregory. 
+o          Add support to ChecksumInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o          Add support to ThrottledInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o          Add support to ObservableInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o          Add support to MessageDigestCalculatingInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+o          Add support to MessageDigestInputStream for setting a consumer for ProxyInputStream.afterRead(int). Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+o          Clean ups in unit tests. Thanks to Gary Gregory. 
+o          Fix some Javadoc issues. Thanks to Gary Gregory. 
+o          RandomAccessFileMode.toString() is more helpful for debugging when it inherits from Enum. Thanks to Gary Gregory. 
+o          Fix implicit narrowing conversion in compound assignment in UnsynchronizedBufferedReader.skip(long). Thanks to Gary Gregory. 
+o IO-860:  Missing reserved file names in FileSystem.WINDOWS (superscript digits for COM and LPT). Thanks to Stefan Feenstra, Gary Gregory. 
+o IO-856:  FileUtils.listFiles(final File, String[], boolean) can throw NoSuchFileException #697, #699. Thanks to Thomas Hartwig, Gary Gregory. 
+o IO-859:  FileUtils.forceDelete on non-existent file on Windows throws IOException rather than FileNotFoundException. Thanks to JD Dean, Gary Gregory. 
+o          Use Unicode escapes for superscript characters. #701. Thanks to Éamonn McManus. 
+o IO-863:  Recent incompatible change to FileUtils.listFiles re extensions, see also IO-856. Thanks to Éamonn McManus, Gary Gregory. 
+o IO-857:  Javadoc: Update details for PathUtils "clean" behavior. Thanks to Dmitry, Gary Gregory. 
+
+Changes
+-------
+
+o          Bump org.apache.commons:commons-parent from 74 to 78 #670, #676, #679, #688. Thanks to Gary Gregory. 
+o          Bump commons.bytebuddy.version from 1.15.1 to 1.15.10 #672, #673, #685, #686, #694, #696, #698. Thanks to Gary Gregory. 
+o          Update AbstractStreamBuilder getters from protected to public. Thanks to Gary Gregory. 
+
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
+
+Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
+
+For complete information on Apache Commons IO, including instructions on how to submit bug reports,
+patches, or suggestions for improvement, see the Apache Commons IO website:
+
+https://commons.apache.org/proper/commons-io/
+
+Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
+
+Have fun!
+-Apache Commons Team
+
+------------------------------------------------------------------------------
+
+
+Apache Commons IO 2.17.0 Release Notes
+
+Introduction
+------------
+
+The Apache Commons IO library contains utility classes, stream implementations, file filters,
+file comparators, endian transformation classes, and much more.
+
+Java 8 is required.
+
+New features
+------------
+
+o          Add IOIterator.adapt(Iterable). Thanks to Gary Gregory. 
+o IO-831:  Add getInputStream() for 'https' and 'http' in URIOrigin #630. Thanks to Elliotte Rusty Harold, Thach Le, Gary Gregory. 
+o          Add IOSupplier.getUnchecked(). Thanks to Gary Gregory. 
+o          Add CloseShieldInputStream.systemIn(InputStream). Thanks to Gary Gregory. 
+o          Add NullInputStream.init(). Thanks to Gary Gregory. 
+o          Add AbstractInputStream and refactor duplicate code. Thanks to Gary Gregory. 
+o          Add UnsynchronizedReader. Thanks to Gary Gregory. 
+o          Add UnsynchronizedBufferedReader. Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+o IO-858:  FileUtilsWaitForTest does not test anything useful. 
+o          Add missing unit tests. Thanks to Gary Gregory. 
+o          FileUtils.lastModifiedFileTime(File) calls Objects.requireNonNull() on the wrong object. Thanks to Gary Gregory. 
+o          PathUtils.deleteOnExit(Path) calls Objects.requireNonNull() on the wrong object. Thanks to Gary Gregory. 
+o          Deprecate LineIterator.nextLine() in favor of next(). Thanks to Gary Gregory. 
+o          Fix PMD UnnecessaryFullyQualifiedName. Thanks to Gary Gregory. 
+o          Add test for CircularByteBuffer clear() #620. Thanks to sullis. 
+o          PathUtils.isPosix(Path, LinkOption...) should return false on null input. Thanks to Gary Gregory. 
+o          AutoCloseInputStream(InputStream) uses ClosedInputStream.INSTANCE when its input is null. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in ProxyInputStream.available() when the underlying input stream is null. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in ProxyInputStream.markSupported() when the underlying input stream is null. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in ProxyInputStream.mark(int) when the underlying input stream is null. Thanks to Gary Gregory. 
+o          BufferedFileChannelInputStream.available() returns 0 before any reads. Thanks to Gary Gregory. 
+o          BufferedFileChannelInputStream.available() should return 0 instead of -1 at the end of the stream. Thanks to Gary Gregory. 
+o          BufferedFileChannelInputStream.available() should return 0 when the stream is closed instead of throwing an exception. Thanks to Gary Gregory. 
+o          CharSequenceInputStream.available() should return 0 after the stream is closed. Thanks to Gary Gregory. 
+o          BoundedInputStream.available() should return 0 when the stream is closed. Thanks to Gary Gregory. 
+o          CircularInputStream.available() should return 0 when the stream is closed. Thanks to Gary Gregory. 
+o          InfiniteCircularInputStream.available() should return 0 when the stream is closed. Thanks to Gary Gregory. 
+o          ChecksumInputStream(InputStream, Checksum, long, long) should fail-fast on null Checksum input. Thanks to Gary Gregory. 
+o          Deprecate NullInputStream.INSTANCE in favor of constructors. Thanks to Gary Gregory. 
+o          NullInputStream.available() should return 0 after the stream is closed. Thanks to Gary Gregory. 
+o          MemoryMappedFileInputStream.available() should return 0 after the stream is closed. Thanks to Gary Gregory. 
+o          RandomAccessFileInputStream.available() should return 0 after the stream is closed. Thanks to Gary Gregory. 
+o          ReaderInputStream.available() should return 0 after the stream is closed. Thanks to Gary Gregory. 
+o          AutoCloseInputStream does not call handleIOException() on close() when the proxied stream throws an IOException. Thanks to Gary Gregory. 
+o          BoundedInputStream does not call handleIOException() on close() when the proxied stream throws an IOException. Thanks to Gary Gregory. 
+o          NullInputStream.read(*) should throw IOException when it is closed. Thanks to Gary Gregory. 
+o          NullInputStream.read(byte[]) should return 0 when the input byte array in length 0. Thanks to Gary Gregory. 
+o          NullInputStream.read(byte[], int, int) should return 0 when the input byte array in length 0 or requested length is 0. Thanks to Gary Gregory. 
+o          MarkShieldInputStream.read(*) should throw IOException when it is closed. Thanks to Gary Gregory. 
+o          Replace deprecated constant FileFileFilter.FILE in Javadoc #657. Thanks to aelaort. 
+o          Pick up exec-maven-plugin version from parent POM. Thanks to Gary Gregory. 
+
+Changes
+-------
+
+o          Bump tests commons.bytebuddy.version from 1.14.13 to 1.15.1 #615, #621, #631, #635, #642, #658, #663, #665. Thanks to Dependabot. 
+o          Bump tests commons-codec:commons-codec from 1.16.1 to 1.17.1 #644. Thanks to Dependabot. 
+o          Bump org.codehaus.mojo:exec-maven-plugin from 3.2.0 to 3.4.1 #632, #652, #659. Thanks to Dependabot. 
+o          Bump org.apache.commons:commons-parent from 69 to 74 #628, #637, #649, #661, #664. Thanks to Dependabot. 
+o          Bump org.apache.commons:commons-lang3 from 3.14.0 to 3.17.0 #645, #653, #666. Thanks to Dependabot. 
+
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
+
+Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
+
+For complete information on Apache Commons IO, including instructions on how to submit bug reports,
+patches, or suggestions for improvement, see the Apache Commons IO website:
+
+https://commons.apache.org/proper/commons-io/
+
+Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
+
+Have fun!
+-Apache Commons Team
+
+------------------------------------------------------------------------------
+
+
+Apache Commons IO 2.16.1 Release Notes
+
+Introduction
+------------
+
+Commons IO is a package of Java utility classes like java.io.  
+Classes in this package are considered to be so standard and of such high 
+reuse as to justify existence in java.io.
+
+The Apache Commons IO library contains utility classes, stream implementations, file filters,
+file comparators, endian transformation classes, and much more.
+
+Java 8 is required.
+
+
+Fixed Bugs
+----------
+
+o          Reimplement FileSystemUtils using NIO. Thanks to Gary Gregory. 
+o IO-851:  FileSystemUtils no longer throws IllegalStateException. Thanks to Sebb, Gary Gregory. 
+o          Avoid possible NullPointerException in FileUtils.listAccumulate(File, IOFileFilter, IOFileFilter, FileVisitOption...). Thanks to Gary Gregory. 
+o IO-853:  BoundedInputStream.reset() not updating count. Thanks to Mike Drob, Gary Gregory. 
+o          ThresholdingOutputStream: a negative threshold should behave like a zero threshold and trigger the event on the first write #609. Thanks to rproserpio, Gary Gregory. 
+
+Changes
+-------
+
+o          Bump commons.bytebuddy.version from 1.14.12 to 1.14.13 #605. Thanks to Gary Gregory. 
+o          Bump org.apache.commons:commons-parent from 67 to 69 #608. Thanks to Gary Gregory, Dependabot. 
+
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
+
+Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
+
+For complete information on Apache Commons IO, including instructions on how to submit bug reports,
+patches, or suggestions for improvement, see the Apache Commons IO website:
+
+https://commons.apache.org/proper/commons-io/
+
+Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
+
+Have fun!
+-Apache Commons Team
+
+------------------------------------------------------------------------------
+
+
+Apache Commons IO 2.16.1 Release Notes
+
+Introduction
+------------
+
+Commons IO is a package of Java utility classes like java.io.  
+Classes in this package are considered to be so standard and of such high 
+reuse as to justify existence in java.io.
+
+The Apache Commons IO library contains utility classes, stream implementations, file filters,
+file comparators, endian transformation classes, and much more.
+
+Java 8 is required.
+
+
+Fixed Bugs
+----------
+
+o          Reimplement FileSystemUtils using NIO. Thanks to Gary Gregory. 
+o IO-851:  FileSystemUtils no longer throws IllegalStateException. Thanks to Sebb, Gary Gregory. 
+o          Avoid possible NullPointerException in FileUtils.listAccumulate(File, IOFileFilter, IOFileFilter, FileVisitOption...). Thanks to Gary Gregory. 
+o IO-853:  BoundedInputStream.reset() not updating count. Thanks to Mike Drob, Gary Gregory. 
+
+Changes
+-------
+
+o          Bump commons.bytebuddy.version from 1.14.12 to 1.14.13 #605. Thanks to Gary Gregory. 
+o          Bump org.apache.commons:commons-parent from 67 to 69 #608. Thanks to Gary Gregory, Dependabot. 
+
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
+
+Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
+
+For complete information on Apache Commons IO, including instructions on how to submit bug reports,
+patches, or suggestions for improvement, see the Apache Commons IO website:
+
+https://commons.apache.org/proper/commons-io/
+
+Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
+
+Have fun!
+-Apache Commons Team
+
+------------------------------------------------------------------------------
+
+
+Apache Commons IO 2.16.0 Release Notes
+
+Introduction
+------------
+
+Commons IO is a package of Java utility classes like java.io.  
+Classes in this package are considered to be so standard and of such high 
+reuse as to justify existence in java.io.
+
+The Apache Commons IO library contains utility classes, stream implementations, file filters,
+file comparators, endian transformation classes, and much more.
+
+Java 8 is required.
+
+New features
+------------
+
+o          Add and use PathUtils.getFileName(Path, Function<Path, R>). Thanks to Gary Gregory. 
+o          Add and use PathUtils.getFileNameString(). Thanks to Gary Gregory. 
+o          Make public Erase.rethrow(Throwable). Thanks to Gary Gregory. 
+o IO-826:  Add BrokenInputStream.BrokenInputStream(Throwable). Thanks to markslater, Gary Gregory. 
+o IO-826:  Add BrokenReader.BrokenReader(Throwable). Thanks to markslater, Gary Gregory. 
+o IO-826:  Add BrokenOutputStream.BrokenOutputStream(Throwable). Thanks to markslater, Gary Gregory. 
+o IO-826:  Add BrokenWriter.BrokenWriter(Throwable). Thanks to markslater, Gary Gregory. 
+o          Add BoundedInputStream.getRemaining(). Thanks to Gary Gregory. 
+o          Add FileTimes.toNtfsTime(long). Thanks to Gary Gregory. 
+o          Add FileTimes.fromUnixTime(long). Thanks to Gary Gregory. 
+o          Add FileTimes.isUnixTime(FileTime). Thanks to Gary Gregory. 
+o          Add FileTimes.isUnixTime(long). Thanks to Gary Gregory. 
+o          Add FileTimes.toUnixTime(FileTime). Thanks to Gary Gregory. 
+o          Add BrokenInputStream.Builder. Thanks to Gary Gregory. 
+o          Add PathUtils.getExtension(Path). Thanks to Gary Gregory. 
+o          Add PathUtils.getBaseName(Path). Thanks to Gary Gregory. 
+o          Add ThrottledInputStream. Thanks to Gary Gregory. 
+o          Add IORunnable.noop(). Thanks to Gary Gregory. 
+o          Add ChecksumInputStream and test #548. Thanks to Gary Gregory. 
+o          Add AbstractStreamBuilder.getReader(). Thanks to Gary Gregory. 
+o          Add Maven property project.build.outputTimestamp for build reproducibility. Thanks to Gary Gregory. 
+o          Add ProxyInputStream.unwrap(). Thanks to Gary Gregory. 
+o          Add a running count and builder to BoundedInputStream. Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+o          Fix and re-enable testSkip_RequiredCharsets #518. Thanks to Elliotte Rusty Harold. 
+o IO-824:  SymbolicLineFileFilter documentation fixes. Thanks to Miguel Munoz, Gary Gregory. 
+o IO-795:  CharSequenceInputStream.reset() only works once #520. Thanks to Miguel Munoz, Gary Gregory. 
+o IO-795:  Finish TODO on CharSequenceInputStream #540. Thanks to Elliotte Rusty Harold. 
+o IO-825:  Add byte array size validation for methods in EndianUtils #521. Thanks to Arthur Chan, Gary Gregory. 
+o IO-825:  Add missing test case CircularByteBufferTest. Thanks to dkdal, Gary Gregory. 
+o IO-781:  Make CharSequenceInputStream.available() more correct in the face of multibyte encodings #525. Thanks to Elliotte Rusty Harold. 
+o IO-781:  Remove unreachable code in AbstractIOFileFilterTest #526. Thanks to Elliotte Rusty Harold. 
+o IO-808:  Rationalize and unify checking for existence of files and directories #529. Thanks to Elliotte Rusty Harold. 
+o          Avoid NullPointerException in IOCase.checkEquals(String, String) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in CanExecuteFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in CanExecuteFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in CanReadFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in CanReadFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in CanWriteFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in CanWriteFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in DirectoryFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in DirectoryFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in EmptyFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in EmptyFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in FileFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in FileFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in HiddenFileFilter.accept(File) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in HiddenFileFilter.accept(Path, BasicFileAttributes) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in IOCase.checkIndexOf(String, int, String) on null input. Thanks to Gary Gregory. 
+o          Avoid NullPointerException in IOCase.checkRegionMatches(String, int, String) on null input. Thanks to Gary Gregory. 
+o          BoundedInputStream.getCount() should not count EOF. Thanks to Gary Gregory. 
+o          Modernize temporary file creation and deletion in DeferredFileOutputStreamTest #535. Thanks to Elliotte Rusty Harold, Gary Gregory. 
+o          Add PathMatcher to IOFileFilter class Javadoc #536. Thanks to Elliotte Rusty Harold. 
+o IO-781:  Fix CharSequenceInputStream coding exception handling #537. Thanks to Marcono1234. 
+o IO-781:  Deprecate int CountingInputStream#getCount() in favor of long CountingInputStream#getByteCount(). Thanks to Marcono1234. 
+o IO-828:  Deprecate CountingInputStream.resetCount() in favor of resetByteCount(). Thanks to Elliotte Rusty Harold, Gary Gregory. 
+o IO-828:  Deprecate CountingInputStream.getMaxLength() in favor of getMaxCount()). Thanks to Gary Gregory. 
+o IO-818:  NullInputStream breaks InputStream's read method contract. Thanks to Gary Gregory. 
+o          Javadoc shouldn't reference 1.x behavior #539. Thanks to Elliotte Rusty Harold. 
+o IO-829:  Don't decode and reencode characters in a potentially different charset in AbstractOrigin.CharSequenceOrigin.getReader(Charset). Thanks to Elliotte Rusty Harold, Gary Gregory. 
+o          Let subclasses of CountingInputStream.afterRead(int) throw IOException. Thanks to Gary Gregory. 
+o IO-807:  Characterization test for broken symlinks when copying directories #547. Thanks to Elliotte Rusty Harold, Gary Gregory. 
+o          ClosedInputStream.read(byte[], int, int) does not always return -1. Thanks to Gary Gregory. 
+o          ClosedOutputStream.write(byte[], int, int) does not always throw IOException. Thanks to Gary Gregory. 
+o          XmlStreamReader can't parse an XML document with a multi-line prolog #550. Thanks to Sylwester Lachiewicz, Gary Gregory. 
+o          XmlStreamReader can't parse XML an document with an external parsed entity prolog. Thanks to Andreas Hubold, Gary Gregory. 
+o IO-836:  Update FileNameUtils Javadoc #554. Thanks to Elliotte Rusty Harold. 
+o IO-807:  Copy symlinks, not the files the symlinks point to #558. Thanks to Jordi Sola, Elliotte Rusty Harold. 
+o          Pickup apache-rat-plugin version from parent POM. Thanks to Gary Gregory. 
+o          Add test for copying a symlink FileUtilsTest#testCopyFile_symLink() #564. Thanks to Elliotte Rusty Harold. 
+o          Make copyFile copy symbolic links by value rather than reference #565. Thanks to Elliotte Rusty Harold. 
+o          Deprecate CopyUtils 0-argument constructor. Thanks to Gary Gregory. 
+o IO-843:  Deprecate EndianUtils 0-argument constructor. Thanks to Gary Gregory, Elliotte Rusty Harold. 
+o          Deprecate FileSystemUtils 0-argument constructor. Thanks to Gary Gregory. 
+o          Deprecate FilenameUtils 0-argument constructor. Thanks to Gary Gregory. 
+o          Deprecate RandomAccessFiles 0-argument constructor. Thanks to Gary Gregory. 
+o          Clarify and correct EndianUtils and SwappedDataInputStream API doc #566. Thanks to Elliotte Rusty Harold, Gary Gregory. 
+o          Add characterization test for copying a symlinked directory #570. Thanks to Elliotte Rusty Harold. 
+o          RandomAccessFileInputStream.builder().get() now throws ISE instead of NPE. Thanks to Gary Gregory. 
+o IO-845:  Test links to targets outside the source directory #571. Thanks to Elliotte Rusty Harold. 
+o          Focus Javadoc on current version rather than past versions #573, #574. Thanks to Elliotte Rusty Harold. 
+o IO-469:  "Self-suppression not permitted" while using BrokenOutput and BrokenInput streams with try-with-resources. Thanks to Grigory Fadeev, Kristian Rosenvold, Elliotte Rusty Harold. 
+o IO-405:  Handle zero and negative thresholds #587. Thanks to Elliotte Rusty Harold. 
+o          Deprecate CountingInputStream in favor of BoundedInputStream. Thanks to Gary Gregory. 
+o          PathUtils.setPosixPermissions(...) only sets permissions if needed. Thanks to Gary Gregory. 
+o          PathUtils.setReadOnly(...) only sets permissions if needed. Thanks to Gary Gregory. 
+o          PathUtils.deleteFile(..., DeleteOption...) only sets permissions if needed. Thanks to Gary Gregory. 
+o          CleaningPathVisitor only sets permissions if needed. Thanks to Gary Gregory. 
+o          DeletingPathVisitor only sets permissions if needed. Thanks to Gary Gregory. 
+
+Changes
+-------
+
+o          Bump commons.bytebuddy.version from 1.14.10 to 1.14.12 #534, #592. Thanks to Gary Gregory. 
+o          Bump org.apache.commons:commons-parent from 65 to 67. Thanks to Gary Gregory. 
+o          Bump commons-codec:commons-codec from 1.16.0 to 1.16.1 #583. Thanks to Dependabot. 
+o          Bump org.codehaus.mojo:exec-maven-plugin from 3.1.1 to 3.2.0 #593. Thanks to Dependabot. 
+
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
+
+Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
+
+For complete information on Apache Commons IO, including instructions on how to submit bug reports,
+patches, or suggestions for improvement, see the Apache Commons IO website:
+
+https://commons.apache.org/proper/commons-io/
+
+Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
+
+Have fun!
+-Apache Commons Team
+
+------------------------------------------------------------------------------
+
+
+Apache Commons IO 
+Version 2.15.1
+Release Notes
+
+Introduction
+------------
+
+Commons IO is a package of Java utility classes like java.io.  
+Classes in this package are considered to be so standard and of such high 
+reuse as to justify existence in java.io.
+
+The Apache Commons IO library contains utility classes, stream implementations, file filters,
+file comparators, endian transformation classes, and much more.
+
+Java 8 is required.
+
+Fixed Bugs
+----------
+
+*           Fix wrong issue id in change log #503. Thanks to Gregor Dschung. 
+*           Add test for FileChannels.contentEquals() #509. Thanks to Stephan Markwalder, Gary Gregory. 
+*           Fix FileChannels.contentEquals(). Thanks to Gary Gregory. 
+*           Fix some Javadoc issues in LineIterator and IOUtils. Thanks to Gary Gregory. 
+*           Simplify FileAlterationObserver internal processing. Thanks to Gary Gregory. 
+*           Avoid NullPointerException in RegexFileFilter.RegexFileFilter(Pattern). Thanks to Gary Gregory. 
+*           Avoid NullPointerException in RegexFileFilter.accept(Path, BasicFileAttributes). Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Class org.apache.commons.io.filefilter.RegexFileFilter defines non-transient non-serializable instance field pathToString [org.apache.commons.io.filefilter.RegexFileFilter] In RegexFileFilter.java SE_BAD_FIELD. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Class org.apache.commons.io.filefilter.DelegateFileFilter defines non-transient non-serializable instance field fileFilter [org.apache.commons.io.filefilter.DelegateFileFilter] In DelegateFileFilter.java SE_BAD_FIELD. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Class org.apache.commons.io.filefilter.DelegateFileFilter defines non-transient non-serializable instance field fileNameFilter [org.apache.commons.io.filefilter.DelegateFileFilter] In DelegateFileFilter.java SE_BAD_FIELD. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.function.IOStream$1.next() cannot throw NoSuchElementException [org.apache.commons.io.function.IOStream$1] At IOStream.java:[line 98] IT_NO_SUCH_ELEMENT. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.monitor.FileAlterationMonitor.getObservers() may expose internal representation by returning FileAlterationMonitor.observers [org.apache.commons.io.monitor.FileAlterationMonitor] At FileAlterationMonitor.java:[line 124] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Class org.apache.commons.io.monitor.FileAlterationObserver defines non-transient non-serializable instance field fileFilter [org.apache.commons.io.monitor.FileAlterationObserver] In FileAlterationObserver.java SE_BAD_FIELD. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Class org.apache.commons.io.monitor.FileAlterationObserver defines non-transient non-serializable instance field listeners [org.apache.commons.io.monitor.FileAlterationObserver] In FileAlterationObserver.java SE_BAD_FIELD. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.FileCleaningTracker.getDeleteFailures() may expose internal representation by returning FileCleaningTracker.deleteFailures [org.apache.commons.io.FileCleaningTracker] At FileCleaningTracker.java:[line 218] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.IOExceptionList.getCauseList() may expose internal representation by returning IOExceptionList.causeList [org.apache.commons.io.IOExceptionList] At IOExceptionList.java:[line 118] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.IOExceptionList.getCauseList(Class) may expose internal representation by returning IOExceptionList.causeList [org.apache.commons.io.IOExceptionList] At IOExceptionList.java:[line 129] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.file.AccumulatorPathVisitor.getDirList() may expose internal representation by returning AccumulatorPathVisitor.dirList [org.apache.commons.io.file.AccumulatorPathVisitor] At AccumulatorPathVisitor.java:[line 179] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.file.AccumulatorPathVisitor.getFileList() may expose internal representation by returning AccumulatorPathVisitor.fileList [org.apache.commons.io.file.AccumulatorPathVisitor] At AccumulatorPathVisitor.java:[line 188] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: org.apache.commons.io.input.ObservableInputStream.getObservers() may expose internal representation by returning ObservableInputStream.observers [org.apache.commons.io.input.ObservableInputStream] At ObservableInputStream.java:[line 187] EI_EXPOSE_REP. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Exception thrown in class org.apache.commons.io.input.UnsynchronizedByteArrayInputStream at new org.apache.commons.io.input.UnsynchronizedByteArrayInputStream(byte[], int) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks. [org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream] At UnsynchronizedByteArrayInputStream.java:[line 202]At UnsynchronizedByteArrayInputStream.java:[line 202] CT_CONSTRUCTOR_THROW. Thanks to Gary Gregory. 
+*           Fix SpotBugs error: Exception thrown in class org.apache.commons.io.input.UnsynchronizedByteArrayInputStream at new org.apache.commons.io.input.UnsynchronizedByteArrayInputStream(byte[], int, int) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks. [org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream] At UnsynchronizedByteArrayInputStream.java:[line 223]At UnsynchronizedByteArrayInputStream.java:[line 223] CT_CONSTRUCTOR_THROW. Thanks to Gary Gregory. 
+
+Changes
+-------
+
+*           Bump org.codehaus.mojo:exec-maven-plugin from 3.1.0 to 3.1.1 #512. Thanks to Gary Gregory. 
+*           Bump commons-lang3 from 3.13.0 to 3.14.0. Thanks to Gary Gregory. 
+*           Bump commons.bytebuddy.version from 1.14.9 to 1.14.10 #516. Thanks to Dependabot. 
+*           Bump commons-parent from 64 to 65. Thanks to Dependabot. 
+
+Compatibility with 2.6:
+Binary compatible: Yes.
+Source compatible: Yes.
+Semantic compatible: Yes.
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
+
+Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
+
+For complete information on Apache Commons IO, including instructions on how to submit bug reports,
+patches, or suggestions for improvement, see the Apache Commons IO website:
+
+https://commons.apache.org/proper/commons-io/
+
+Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
+
+Have fun!
+-Apache Commons Team
+
+------------------------------------------------------------------------------
+
 Apache Commons IO 
 Version 2.15.0
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -13,56 +501,56 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 is required.
 
-Changes in this version include:
-
-New features:
-o           Add org.apache.commons.io.channels.FileChannels. Thanks to Gary Gregory. 
-o           Add RandomAccessFiles#contentEquals(RandomAccessFile, RandomAccessFile). Thanks to Gary Gregory. 
-o           Add RandomAccessFiles#reset(RandomAccessFile). Thanks to Gary Gregory. 
-o           Add PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
-o           Add org.apache.commons.io.StreamIterator. Thanks to Gary Gregory. 
-o           Add MessageDigestInputStream and deprecate MessageDigestCalculatingInputStream. Thanks to Gary Gregory. 
-
-Fixed Bugs:
-o IO-810:  XmlStreamReader encoding match RE is too strict. Thanks to Laurence Gonsalves. 
-o IO-810:  Javadoc in FileUtils does not reflect code for thrown exceptions. Thanks to Gregor Dschung, Gary Gregory. 
-o IO-812:  Javadoc should mention closing Streams based on file resources. Thanks to Adam Rauch, Gary Gregory. 
-o IO-811:  In tests, Files.walk() direct and indirect callers fail to close the returned Stream. Thanks to Adam Rauch, Gary Gregory. 
-o IO-811:  FileUtils.listFiles(File, String[], boolean) fails to close its internal Stream. Thanks to Adam Rauch, Gary Gregory. 
-o IO-811:  FileUtils.iterateFiles(File, String[], boolean) fails to close its internal Stream. Thanks to Adam Rauch, Gary Gregory. 
-o IO-811:  StreamIterator fails to close its internal Stream. Thanks to Adam Rauch, Gary Gregory. 
-o IO-814:  Don't throw UncheckedIOException #491. Thanks to Elliotte Rusty Harold, Gary Gregory. 
-o IO-414:  Don't write a BOM on every (or any) line #492. Thanks to Elliotte Rusty Harold, Gary Gregory. 
-o IO-814:  RandomAccessFileMode.create(Path) provides a better NullPointerException message. Thanks to Gary Gregory. 
-o           Improve performance of PathUtils.fileContentEquals(Path, Path, LinkOption[], OpenOption[]) by about 60%, see PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
-o           Improve performance of PathUtils.fileContentEquals(Path, Path) by about 60%, see PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
-o           Improve performance of FileUtils.contentEquals(File, File) by about 60%, see PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
-o           Remove unused test code #494. Thanks to Elliotte Rusty Harold. 
-o           [Javadoc] IOUtils#contentEquals does not throw NullPointerException #496. Thanks to sebbASF. 
-o           Fix CodeQL warnings in UnsynchronizedBufferedInputStream: Implicit narrowing conversion in compound assignment. Thanks to Gary Gregory. 
-o           MessageDigestCalculatingInputStream.MessageDigestMaintainingObserver.MessageDigestMaintainingObserver(MessageDigest) now throws a NullPointerException
+New features
+------------
+
+*           Add org.apache.commons.io.channels.FileChannels. Thanks to Gary Gregory. 
+*           Add RandomAccessFiles#contentEquals(RandomAccessFile, RandomAccessFile). Thanks to Gary Gregory. 
+*           Add RandomAccessFiles#reset(RandomAccessFile). Thanks to Gary Gregory. 
+*           Add PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
+*           Add org.apache.commons.io.StreamIterator. Thanks to Gary Gregory. 
+*           Add MessageDigestInputStream and deprecate MessageDigestCalculatingInputStream. Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+* IO-815:  XmlStreamReader encoding match RE is too strict. Thanks to Laurence Gonsalves. 
+* IO-810:  Javadoc in FileUtils does not reflect code for thrown exceptions. Thanks to Gregor Dschung, Gary Gregory. 
+* IO-812:  Javadoc should mention closing Streams based on file resources. Thanks to Adam Rauch, Gary Gregory. 
+* IO-811:  In tests, Files.walk() direct and indirect callers fail to close the returned Stream. Thanks to Adam Rauch, Gary Gregory. 
+* IO-811:  FileUtils.listFiles(File, String[], boolean) fails to close its internal Stream. Thanks to Adam Rauch, Gary Gregory. 
+* IO-811:  FileUtils.iterateFiles(File, String[], boolean) fails to close its internal Stream. Thanks to Adam Rauch, Gary Gregory. 
+* IO-811:  StreamIterator fails to close its internal Stream. Thanks to Adam Rauch, Gary Gregory. 
+* IO-814:  Don't throw UncheckedIOException #491. Thanks to Elliotte Rusty Harold, Gary Gregory. 
+* IO-414:  Don't write a BOM on every (or any) line #492. Thanks to Elliotte Rusty Harold, Gary Gregory. 
+* IO-814:  RandomAccessFileMode.create(Path) provides a better NullPointerException message. Thanks to Gary Gregory. 
+*           Improve performance of PathUtils.fileContentEquals(Path, Path, LinkOption[], OpenOption[]) by about 60%, see PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
+*           Improve performance of PathUtils.fileContentEquals(Path, Path) by about 60%, see PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
+*           Improve performance of FileUtils.contentEquals(File, File) by about 60%, see PathUtilsContentEqualsBenchmark. Thanks to Gary Gregory. 
+*           Remove unused test code #494. Thanks to Elliotte Rusty Harold. 
+*           [Javadoc] IOUtils#contentEquals does not throw NullPointerException #496. Thanks to sebbASF. 
+*           Fix CodeQL warnings in UnsynchronizedBufferedInputStream: Implicit narrowing conversion in compound assignment. Thanks to Gary Gregory. 
+*           MessageDigestCalculatingInputStream.MessageDigestMaintainingObserver.MessageDigestMaintainingObserver(MessageDigest) now throws a NullPointerException
         if the MessageDigest is null. Thanks to Gary Gregory. 
-o           MessageDigestCalculatingInputStream.MessageDigestCalculatingInputStream(InputStream, MessageDigest) now throws a NullPointerException
+*           MessageDigestCalculatingInputStream.MessageDigestCalculatingInputStream(InputStream, MessageDigest) now throws a NullPointerException
         if the MessageDigest is null. Thanks to Gary Gregory. 
-o IO-816:  UnsynchronizedBufferedInputStream.read(byte[], int, int) does not use buffer. Thanks to Andreas Loth, Gary Gregory. 
+* IO-816:  UnsynchronizedBufferedInputStream.read(byte[], int, int) does not use buffer. Thanks to Andreas Loth, Gary Gregory. 
+
+Changes
+-------
 
-Changes:
-o           Bump org.apache.commons:commons-parent from 62 to 64. Thanks to Gary Gregory. 
+*           Bump org.apache.commons:commons-parent from 62 to 64. Thanks to Gary Gregory. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -76,13 +564,14 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO 
 Version 2.14.0
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -93,55 +582,55 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
-
-New features:
-o           Add DeferredFileOutputStream.getPath(). Thanks to Gary Gregory. 
-o           Add FileCleaningTracker.track(Path, Object[, FileDeleteStrategy]). Thanks to Gary Gregory. 
-o           Add IOUtils.skip[Fully](InputStream, long, Supplier<byte[]>). Thanks to Gary Gregory. 
-o           Add FilesUncheck.find(Path, int, BiPredicate%lt;Path, BasicFileAttributes>, FileVisitOption...) Thanks to Gary Gregory. 
-o           Add IOIntSupplier. Thanks to Gary Gregory. 
-o           Add IOLongSupplier. Thanks to Gary Gregory. 
-o           Add Uncheck.getAsInt(IOIntSupplier [, Supplier<String>]). Thanks to Gary Gregory. 
-o           Add Uncheck.getAsLong(IOLongSupplier [, Supplier<String>]). Thanks to Gary Gregory. 
-o           Add Uncheck.run(IORunnable, Supplier<String>) Thanks to Gary Gregory. 
-o           Add Uncheck.get(IOSupplier, Supplier<String>) Thanks to Gary Gregory. 
-o           IOFileFilter now also extends java.nio.file.PathMatcher. Thanks to Gary Gregory. 
-o           Add PathMatcherFileFilter to adapt java.nio.file.PathMatcher. Thanks to Gary Gregory. 
-o           Add ThresholdingOutputStream.getOutputStream() and deprecate getStream(). Thanks to Gary Gregory. 
-o           Add DeferredFileOutputStream.Builder.setOutputFile(Path). Thanks to Gary Gregory. 
-o           Add DeferredFileOutputStream.Builder.setDirectory(Path). Thanks to Gary Gregory. 
-o           Add AbstractStreamBuilder.setBufferSizeChecker(IntToIntFunction). Thanks to Gary Gregory. 
-o           Add AbstractStreamBuilder.setBufferSizeMax(int). Thanks to Gary Gregory. 
-
-Fixed Bugs:
-o IO-799:  ReaderInputStream.read() throws an exception instead of returning -1 when called again after returning -1. Thanks to Jeroen van der Vegt, Gary Gregory. 
-o IO-804:  FileUtils.forceMkdirParent() Javadoc is incorrect. Thanks to Elliotte Rusty Harold, Gary Gregory. 
-o           [StepSecurity] ci: Harden GitHub Actions #461. Thanks to step-security-bot, Gary Gregory. 
-o           MagicNumberFileFilter.accept(Path, BasicFileAttributes) doesn't its byteOffset before reading. Thanks to Gary Gregory. 
-o           Javadoc improvements. Thanks to Gary Gregory. 
-o           Spelling #468. Thanks to Josh Soref, Gary Gregory. 
-o           Use assertThrows #475. Thanks to Jakub Kupczyk. 
-
-Changes:
-o           Bump jimfs from 1.2 to 1.3.0 #465 (tests). Thanks to Dependabot. 
-o           Bump commons-parent from 58 to 62. Thanks to Gary Gregory. 
-o           Bump commons-lang3 from 3.12 to 3.13.0. Thanks to Gary Gregory. 
+New features
+------------
+
+*           Add DeferredFileOutputStream.getPath(). Thanks to Gary Gregory. 
+*           Add FileCleaningTracker.track(Path, Object[, FileDeleteStrategy]). Thanks to Gary Gregory. 
+*           Add IOUtils.skip[Fully](InputStream, long, Supplier<byte[]>). Thanks to Gary Gregory. 
+*           Add FilesUncheck.find(Path, int, BiPredicate%lt;Path, BasicFileAttributes>, FileVisitOption...) Thanks to Gary Gregory. 
+*           Add IOIntSupplier. Thanks to Gary Gregory. 
+*           Add IOLongSupplier. Thanks to Gary Gregory. 
+*           Add Uncheck.getAsInt(IOIntSupplier [, Supplier<String>]). Thanks to Gary Gregory. 
+*           Add Uncheck.getAsLong(IOLongSupplier [, Supplier<String>]). Thanks to Gary Gregory. 
+*           Add Uncheck.run(IORunnable, Supplier<String>) Thanks to Gary Gregory. 
+*           Add Uncheck.get(IOSupplier, Supplier<String>) Thanks to Gary Gregory. 
+*           IOFileFilter now also extends java.nio.file.PathMatcher. Thanks to Gary Gregory. 
+*           Add PathMatcherFileFilter to adapt java.nio.file.PathMatcher. Thanks to Gary Gregory. 
+*           Add ThresholdingOutputStream.getOutputStream() and deprecate getStream(). Thanks to Gary Gregory. 
+*           Add DeferredFileOutputStream.Builder.setOutputFile(Path). Thanks to Gary Gregory. 
+*           Add DeferredFileOutputStream.Builder.setDirectory(Path). Thanks to Gary Gregory. 
+*           Add AbstractStreamBuilder.setBufferSizeChecker(IntToIntFunction). Thanks to Gary Gregory. 
+*           Add AbstractStreamBuilder.setBufferSizeMax(int). Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+* IO-799:  ReaderInputStream.read() throws an exception instead of returning -1 when called again after returning -1. Thanks to Jeroen van der Vegt, Gary Gregory. 
+* IO-804:  FileUtils.forceMkdirParent() Javadoc is incorrect. Thanks to Elliotte Rusty Harold, Gary Gregory. 
+*           [StepSecurity] ci: Harden GitHub Actions #461. Thanks to step-security-bot, Gary Gregory. 
+*           MagicNumberFileFilter.accept(Path, BasicFileAttributes) doesn't its byteOffset before reading. Thanks to Gary Gregory. 
+*           Javadoc improvements. Thanks to Gary Gregory. 
+*           Spelling #468. Thanks to Josh Soref, Gary Gregory. 
+*           Use assertThrows #475. Thanks to Jakub Kupczyk. 
+
+Changes
+-------
+
+*           Bump jimfs from 1.2 to 1.3.0 #465 (tests). Thanks to Dependabot. 
+*           Bump commons-parent from 58 to 62. Thanks to Gary Gregory. 
+*           Bump commons-lang3 from 3.12 to 3.13.0. Thanks to Gary Gregory. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -155,13 +644,14 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO 
 Version 2.13.0
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -172,48 +662,48 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
-
-New features:
-o           Add CharSequenceInputStream.Builder. Thanks to Gary Gregory. 
-o           Add ChunkedOutputStream.Builder. Thanks to Gary Gregory. 
-o           Add AbstractStreamBuilder.setOpenOptions(OpenOption...). Thanks to Gary Gregory. 
-o           Add some missing conversions to AbstractOrigin subclasses. Thanks to Gary Gregory. 
-o           Add AbstractOrigin.getByteArray(long, int). Thanks to Gary Gregory. 
-o           Add and use RandomAccessFiles. Thanks to Gary Gregory. 
-o           Add AbstractOrigin.size(). Thanks to Gary Gregory. 
-o           Add PathUtils.EMPTY_FILE_ATTRIBUTE_ARRAY. Thanks to Gary Gregory. 
-o           Add CharSequenceInputStream.Builder.setCharsetEncoder(CharsetEncoder). Thanks to Gary Gregory. 
-o           Add CharsetEncoders.toCharsetEncoder(CharsetEncoder, Supplier<CharsetEncoder>). Thanks to Gary Gregory. 
-
-Fixed Bugs:
-o IO-791:  Regression in FileUtils.touch() - no longer creates parent directories. Thanks to Chad Wilson, Gary Gregory. 
-o           ByteArrayOrigin should be able convert a byte[] to a ByteArrayInputStream. Thanks to Gary Gregory. 
-o           AbstractOriginSupplier.checkOrigin() now throws IllegalStateException instead of NullPointerException. Thanks to Gary Gregory. 
-o IO-796:  FileAlreadyExistsException in PathUtils.createParentDirectories(Path, LinkOption, FileAttribute...). Thanks to Giacomo Boccardo, Gary Gregory. 
-o           Only read the relevant portion of a file in AbstractOrigin.FileOrigin.getByteArray(long, int) Thanks to Gary Gregory. 
-o           Only read the relevant portion of a file in AbstractOrigin.PathOrigin.getByteArray(long, int) Thanks to Gary Gregory. 
-o IO-798:  DeferredFileOutputStream throws exception when system temp dir is a symlink. Thanks to Shai Shapira, Gary Gregory. 
-o           ReaderInputStream.Builder.setCharsetEncoder(null) should reset to a default object, not throw an NPE. Thanks to Gary Gregory. 
-o           ReaderInputStream.Builder.setCharset(null) should reset to a default object, not throw an NPE. Thanks to Gary Gregory. 
-
-Changes:
-o           Bump commons-parent from 57 to 58. Thanks to Gary Gregory, Dependabot. 
+New features
+------------
+
+*           Add CharSequenceInputStream.Builder. Thanks to Gary Gregory. 
+*           Add ChunkedOutputStream.Builder. Thanks to Gary Gregory. 
+*           Add AbstractStreamBuilder.setOpenOptions(OpenOption...). Thanks to Gary Gregory. 
+*           Add some missing conversions to AbstractOrigin subclasses. Thanks to Gary Gregory. 
+*           Add AbstractOrigin.getByteArray(long, int). Thanks to Gary Gregory. 
+*           Add and use RandomAccessFiles. Thanks to Gary Gregory. 
+*           Add AbstractOrigin.size(). Thanks to Gary Gregory. 
+*           Add PathUtils.EMPTY_FILE_ATTRIBUTE_ARRAY. Thanks to Gary Gregory. 
+*           Add CharSequenceInputStream.Builder.setCharsetEncoder(CharsetEncoder). Thanks to Gary Gregory. 
+*           Add CharsetEncoders.toCharsetEncoder(CharsetEncoder, Supplier<CharsetEncoder>). Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+* IO-791:  Regression in FileUtils.touch() - no longer creates parent directories. Thanks to Chad Wilson, Gary Gregory. 
+*           ByteArrayOrigin should be able convert a byte[] to a ByteArrayInputStream. Thanks to Gary Gregory. 
+*           AbstractOriginSupplier.checkOrigin() now throws IllegalStateException instead of NullPointerException. Thanks to Gary Gregory. 
+* IO-796:  FileAlreadyExistsException in PathUtils.createParentDirectories(Path, LinkOption, FileAttribute...). Thanks to Giacomo Boccardo, Gary Gregory. 
+*           Only read the relevant portion of a file in AbstractOrigin.FileOrigin.getByteArray(long, int) Thanks to Gary Gregory. 
+*           Only read the relevant portion of a file in AbstractOrigin.PathOrigin.getByteArray(long, int) Thanks to Gary Gregory. 
+* IO-798:  DeferredFileOutputStream throws exception when system temp dir is a symlink. Thanks to Shai Shapira, Gary Gregory. 
+*           ReaderInputStream.Builder.setCharsetEncoder(null) should reset to a default object, not throw an NPE. Thanks to Gary Gregory. 
+*           ReaderInputStream.Builder.setCharset(null) should reset to a default object, not throw an NPE. Thanks to Gary Gregory. 
+
+Changes
+-------
+
+*           Bump commons-parent from 57 to 58. Thanks to Gary Gregory, Dependabot. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -231,9 +721,10 @@ Apache Commons IO
 Version 2.12.0
 Release Notes
 
-==============================================================================
+------------------------------------------------------------------------------
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -244,219 +735,219 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
-
-New features:
-o IO-746:  Drop unnecessary casts and conversions #267. Thanks to Davide Angelocola. 
-o           Add GitHub coverage.yml. Thanks to Gary Gregory. 
-o           Add BrokenReader.INSTANCE. Thanks to Gary Gregory. 
-o           Add UncheckedBufferedReader. Thanks to Gary Gregory. 
-o           Add UncheckedFilterReader. Thanks to Gary Gregory. 
-o           Add UncheckedFilterWriter. Thanks to Gary Gregory. 
-o           Add StringInputStream. Thanks to Gary Gregory. 
-o           Add UncheckedFilterInputStream. Thanks to Gary Gregory. 
-o           Add UncheckedFilterOutputStream. Thanks to Gary Gregory. 
-o           Add BrokenInputStream.INSTANCE. Thanks to Gary Gregory. 
-o           Add ClosedInputStream.INSTANCE and deprecate CLOSED_INPUT_STREAM. Thanks to Gary Gregory. 
-o           Add ClosedReader.INSTANCE and deprecate CLOSED_READER. Thanks to Gary Gregory. 
-o           Add BrokenWriter.INSTANCE. Thanks to Gary Gregory. 
-o           Add ClosedOutputStream.INSTANCE and deprecate CLOSED_OUTPUT_STREAM. Thanks to Gary Gregory. 
-o           Add ClosedWriter.INSTANCE and deprecate CLOSED_WRITER. Thanks to Gary Gregory. 
-o           Add NullOutputStream.INSTANCE and deprecate NULL_OUTPUT_STREAM. Thanks to Gary Gregory. 
-o           Add NullPrintStream.INSTANCE and deprecate NULL_PRINT_STREAM. Thanks to Gary Gregory. 
-o           Add NullWriter.INSTANCE and deprecate NULL_WRITER. Thanks to Gary Gregory. 
-o           Add NullInputStream.INSTANCE. Thanks to Gary Gregory. 
-o           Add NullReader.INSTANCE. Thanks to Gary Gregory. 
-o           Add PathUtils.readString(Path, Charset). Thanks to Gary Gregory. 
-o           Add FileUtils.newOutputStream(File, boolean). Thanks to Gary Gregory. 
-o           Add PathUtils.newOutputStream(Path, boolean). Thanks to Gary Gregory. 
-o           Add UncheckedAppendable. Thanks to Gary Gregory. 
-o           Add and reuse UncheckedIOExceptions. Thanks to Gary Gregory. 
-o           Add PathUtils.getTempDirectory(). Thanks to Gary Gregory. 
-o           Add FileSystem.getNameSeparator(). Thanks to Gary Gregory. 
-o           Add FileSystem.normalizeSeparators(). Thanks to Gary Gregory. 
-o           Add PathUtils.isNewer(Path, FileTime, LinkOption...). Thanks to Gary Gregory. 
-o           Add PathUtils.isNewer(Path, Instant, LinkOption...). Thanks to Gary Gregory. 
-o           Add AgeFileFilter.AgeFileFilter(Instant).
+New features
+------------
+
+* IO-746:  Drop unnecessary casts and conversions #267. Thanks to Davide Angelocola. 
+*           Add GitHub coverage.yml. Thanks to Gary Gregory. 
+*           Add BrokenReader.INSTANCE. Thanks to Gary Gregory. 
+*           Add UncheckedBufferedReader. Thanks to Gary Gregory. 
+*           Add UncheckedFilterReader. Thanks to Gary Gregory. 
+*           Add UncheckedFilterWriter. Thanks to Gary Gregory. 
+*           Add StringInputStream. Thanks to Gary Gregory. 
+*           Add UncheckedFilterInputStream. Thanks to Gary Gregory. 
+*           Add UncheckedFilterOutputStream. Thanks to Gary Gregory. 
+*           Add BrokenInputStream.INSTANCE. Thanks to Gary Gregory. 
+*           Add ClosedInputStream.INSTANCE and deprecate CLOSED_INPUT_STREAM. Thanks to Gary Gregory. 
+*           Add ClosedReader.INSTANCE and deprecate CLOSED_READER. Thanks to Gary Gregory. 
+*           Add BrokenWriter.INSTANCE. Thanks to Gary Gregory. 
+*           Add ClosedOutputStream.INSTANCE and deprecate CLOSED_OUTPUT_STREAM. Thanks to Gary Gregory. 
+*           Add ClosedWriter.INSTANCE and deprecate CLOSED_WRITER. Thanks to Gary Gregory. 
+*           Add NullOutputStream.INSTANCE and deprecate NULL_OUTPUT_STREAM. Thanks to Gary Gregory. 
+*           Add NullPrintStream.INSTANCE and deprecate NULL_PRINT_STREAM. Thanks to Gary Gregory. 
+*           Add NullWriter.INSTANCE and deprecate NULL_WRITER. Thanks to Gary Gregory. 
+*           Add NullInputStream.INSTANCE. Thanks to Gary Gregory. 
+*           Add NullReader.INSTANCE. Thanks to Gary Gregory. 
+*           Add PathUtils.readString(Path, Charset). Thanks to Gary Gregory. 
+*           Add FileUtils.newOutputStream(File, boolean). Thanks to Gary Gregory. 
+*           Add PathUtils.newOutputStream(Path, boolean). Thanks to Gary Gregory. 
+*           Add UncheckedAppendable. Thanks to Gary Gregory. 
+*           Add and reuse UncheckedIOExceptions. Thanks to Gary Gregory. 
+*           Add PathUtils.getTempDirectory(). Thanks to Gary Gregory. 
+*           Add FileSystem.getNameSeparator(). Thanks to Gary Gregory. 
+*           Add FileSystem.normalizeSeparators(). Thanks to Gary Gregory. 
+*           Add PathUtils.isNewer(Path, FileTime, LinkOption...). Thanks to Gary Gregory. 
+*           Add PathUtils.isNewer(Path, Instant, LinkOption...). Thanks to Gary Gregory. 
+*           Add AgeFileFilter.AgeFileFilter(Instant).
         Add AgeFileFilter.AgeFileFilter(Instant, boolean). Thanks to Gary Gregory. 
-o           Add FileUtils.lastModifiedFileTime(File). Thanks to Gary Gregory. 
-o           Add FileTimes. Thanks to Gary Gregory. 
-o           Add PathUtils.waitFor(Path, Duration, LinkOption...). Thanks to Gary Gregory. 
-o           Add org.apache.commons.io.input.Tailer.getDelayDuration(). Thanks to Gary Gregory. 
-o           Add FileUtils.current(). Thanks to Gary Gregory. 
-o           Add and use PathUtils.setLastModifiedTime(Path) for more precision.
+*           Add FileUtils.lastModifiedFileTime(File). Thanks to Gary Gregory. 
+*           Add FileTimes. Thanks to Gary Gregory. 
+*           Add PathUtils.waitFor(Path, Duration, LinkOption...). Thanks to Gary Gregory. 
+*           Add org.apache.commons.io.input.Tailer.getDelayDuration(). Thanks to Gary Gregory. 
+*           Add FileUtils.current(). Thanks to Gary Gregory. 
+*           Add and use PathUtils.setLastModifiedTime(Path) for more precision.
         Add and use PathUtils.setLastModifiedTime(Path, Path) for more precision. Thanks to Gary Gregory. 
-o           Add and use PathUtils.isNewer(Path, ChronoZonedDateTime, LinkOption...) for more precision.
+*           Add and use PathUtils.isNewer(Path, ChronoZonedDateTime, LinkOption...) for more precision.
         Add and use PathUtils.isNewer(Path, Path) for more precision.
         Add and use FileUtils.isNewer(File, FileTime) for more precision. Thanks to Gary Gregory. 
-o           Add and use PathUtils.isOlder(Path, FileTime, LinkOption...).
+*           Add and use PathUtils.isOlder(Path, FileTime, LinkOption...).
         Add and use PathUtils.isOlder(Path, Instant, LinkOption...).
         Add and use PathUtils.isOlder(Path, long, LinkOption...).
         Add and use PathUtils.isOlder(Path, Path). Thanks to Gary Gregory. 
-o           Add and use PathUtils.sizeOf(Path).
+*           Add and use PathUtils.sizeOf(Path).
         Add and use PathUtils.sizeOfAsBigInteger(Path).
         Add and use PathUtils.sizeOfDirectory(Path).
         Add and use PathUtils.sizeOfDirectoryAsBigInteger(Path). Thanks to Gary Gregory. 
-o           Add and use IOCase.value(IOCase, IOCase). Thanks to Gary Gregory. 
-o           Add Tailer.Tailable interface to allow tailing of remote files for example using jCIFS. Thanks to Jon Freedman, Gary Gregory. 
-o           Add and use RandomAccessFileMode. Thanks to Gary Gregory. 
-o           Add PathUtils.writeString(Path, CharSequence, Charset, OpenOption...). Thanks to Gary Gregory. 
-o           Add PathUtiFiles.getFileAttributeView() shorthands:
+*           Add and use IOCase.value(IOCase, IOCase). Thanks to Gary Gregory. 
+*           Add Tailer.Tailable interface to allow tailing of remote files for example using jCIFS. Thanks to Jon Freedman, Gary Gregory. 
+*           Add and use RandomAccessFileMode. Thanks to Gary Gregory. 
+*           Add PathUtils.writeString(Path, CharSequence, Charset, OpenOption...). Thanks to Gary Gregory. 
+*           Add PathUtiFiles.getFileAttributeView() shorthands:
           - PathUtils.getAclFileAttributeView(Path, LinkOption...)
           - PathUtils.getDosFileAttributeView(Path, LinkOption...)
           - PathUtils.getPosixFileAttributeView(Path, LinkOption...) Thanks to Gary Gregory. 
-o IO-747:  Make commons-io a JPMS module by adding module-info.class. 
-o IO-753:  Add IOUtils method to copy output stream to input stream #281. Thanks to SebastianDietrich, Gary Gregory. 
-o           Add PathUtils.isPosix(Path, LinkOption...). #290 Thanks to Gary Gregory. 
-o           Add PathUtils.readAttributes(Path, Class, LinkOption...). #290 Thanks to Gary Gregory. 
-o           Add IOExceptionList.checkEmpty(List, Object). Thanks to Gary Gregory. 
-o           Add IOBiConsumer, IOTriConsumer, IOComparator, IOUnaryOperator, IOBinaryOperator. Thanks to Gary Gregory. 
-o           Add and reuse IOConsumer forAll(*), forEach(*), and forEachIndexed(*). Thanks to Gary Gregory. 
-o           Add CharsetEncoders. Thanks to Gary Gregory. 
-o           Add CharsetDecoders. Thanks to Gary Gregory. 
-o           Add PathUtils.createParentDirectories(Path, LinkOption, FileAttribute...). Thanks to Gary Gregory. 
-o           Update FileEntry to use FileTime instead of long for file time stamps. Thanks to Gary Gregory. 
-o IO-680:  Add more tests for IOUtils.contentEqualsIgnoreEOL #137. Thanks to XenoAmess, sebbASF, Gary Gregory. 
-o           Reduce boilerplate through new UncheckedIO class and friends in org.apache.commons.io.function. Thanks to Gary Gregory. 
-o           Add PathUtils.touch(Path). Thanks to Gary Gregory. 
-o           Add FileSystem.getIllegalFileNameCodePoints(). Thanks to Gary Gregory. 
-o           Add FileUtils.isFileNewer(File, ChronoLocalDate, OffsetTime).
+* IO-747:  Make commons-io a JPMS module by adding module-info.class. 
+* IO-753:  Add IOUtils method to copy output stream to input stream #281. Thanks to SebastianDietrich, Gary Gregory. 
+*           Add PathUtils.isPosix(Path, LinkOption...). #290 Thanks to Gary Gregory. 
+*           Add PathUtils.readAttributes(Path, Class, LinkOption...). #290 Thanks to Gary Gregory. 
+*           Add IOExceptionList.checkEmpty(List, Object). Thanks to Gary Gregory. 
+*           Add IOBiConsumer, IOTriConsumer, IOComparator, IOUnaryOperator, IOBinaryOperator. Thanks to Gary Gregory. 
+*           Add and reuse IOConsumer forAll(*), forEach(*), and forEachIndexed(*). Thanks to Gary Gregory. 
+*           Add CharsetEncoders. Thanks to Gary Gregory. 
+*           Add CharsetDecoders. Thanks to Gary Gregory. 
+*           Add PathUtils.createParentDirectories(Path, LinkOption, FileAttribute...). Thanks to Gary Gregory. 
+*           Update FileEntry to use FileTime instead of long for file time stamps. Thanks to Gary Gregory. 
+* IO-680:  Add more tests for IOUtils.contentEqualsIgnoreEOL #137. Thanks to XenoAmess, sebbASF, Gary Gregory. 
+*           Reduce boilerplate through new UncheckedIO class and friends in org.apache.commons.io.function. Thanks to Gary Gregory. 
+*           Add PathUtils.touch(Path). Thanks to Gary Gregory. 
+*           Add FileSystem.getIllegalFileNameCodePoints(). Thanks to Gary Gregory. 
+*           Add FileUtils.isFileNewer(File, ChronoLocalDate, OffsetTime).
         Add FileUtils.isFileNewer(File, OffsetDateTime).
         Add FileUtils.isFileOlder(File, ChronoLocalDate, OffsetTime).
         Add FileUtils.isFileOlder(File, OffsetDateTime). Thanks to Isira Seneviratne, Gary Gregory. 
-o           Add IOBiConsumer.noop(). Thanks to Gary Gregory. 
-o           Add IOUtils.closeQuietly(Iterable<Closeable>).
+*           Add IOBiConsumer.noop(). Thanks to Gary Gregory. 
+*           Add IOUtils.closeQuietly(Iterable<Closeable>).
         Add IOUtils.closeQuietly(Stream<Closeable>). Thanks to Gary Gregory. 
-o           Add Charsets.toCharset(Charset, Charset).
+*           Add Charsets.toCharset(Charset, Charset).
         Add Charsets.toCharset(String, Charset). Thanks to Gary Gregory. 
-o           Add XmlStreamWriter(OutputStream, Charset). Thanks to Gary Gregory. 
-o           Add PathUtils.getLastModifiedFileTime(*). Thanks to Gary Gregory. 
-o           Add IOBiFunction, IOTriFunction, IOQuadFunction, IOPredicate, IOIterator, IOSpliterator, IOBaseStream, IOStream, FilesUncheck. Thanks to Gary Gregory. 
-o           Add IOUtils.consume(Reader). Thanks to Gary Gregory. 
-o           Add IOSupplier.asSupplier(). Thanks to Gary Gregory. 
-o           Add IOFunction.asFunction(). Thanks to Gary Gregory. 
-o           Add IOConsumer.asConsumer(). Thanks to Gary Gregory. 
-o           Add TimestampedObserver.isClosed(). Thanks to Gary Gregory. 
-o           IOExceptionList implements Iterable. Thanks to Gary Gregory. 
-o IO-784:  Add support for Appendable to HexDump #418. Thanks to Fredrik Kjellberg, Gary Gregory. 
-o           Add and use ThreadUtils. Thanks to DaGeRe, Gary Gregory. 
-o IO-786:  Add UnsynchronizedFilterInputStream. Thanks to Gary Gregory. 
-o IO-786:  Add UnsynchronizedBufferedInputStream. Thanks to Gary Gregory, Benoit Tellier. 
-o           Add FileSystem.getBlockSize(). Thanks to Gary Gregory. 
-o           Add builders and avoid creating more constructors for all permutations of current options. Thanks to Gary Gregory. 
-o           Refactor using new Supplier API IOUtils.toString(IOSupplier<InputStream>, Charset[, IOSupplier<String>]). Thanks to Gary Gregory, maxxedev. 
-o           Refactor using new Supplier API org.apache.commons.io.file.PathUtils.copy(IOSupplier<InputStream>, Path, CopyOption...). Thanks to Gary Gregory, maxxedev. 
-
-Fixed Bugs:
-o IO-697:  IOUtils.toByteArray size validation does not match documentation. Thanks to otter606. 
-o           Fix Javadoc links to the JRE Javadoc 8. Thanks to Gary Gregory. 
-o IO-744:  FileWriterWithEncoding for an existing file no longer truncates the file. #251. Thanks to RBRi, Gary Gregory. 
-o           A null Charset or Charset name in FileWriterWithEncoding constructors uses the default Charset. Thanks to Gary Gregory. 
-o           Fix usage of assertNotNull #269. Thanks to Davide Angelocola. 
-o IO-727:  FilenameUtils directoryContains() should handle files with the same prefix #217. Thanks to trungPa, Gary Gregory. 
-o IO-748:  FileUtils.moveToDirectory() exception documentation and exception message error. Thanks to Dirk Heinrichs, Gary Gregory, Elango Ravi. 
-o           ThreadMonitor.sleep(Duration) ignores nanoseconds. Thanks to Gary Gregory. 
-o           Fix Javadoc in ThreadMonitor#run() method. #273. Thanks to Arturo Bernal. 
-o IO-749:  FileUtils.listFiles() does not list matching files if File parameter is a symbolic link. Thanks to haihuiyang, Gary Gregory. 
-o           Fix typo in Javadocs for FileUtils#convertFileCollectionToFileArray() #276. Thanks to niranjanghule, Gary Gregory. 
-o           Avoid Code Duplication: Reuse Sleep from ThreadMonitor #66. Thanks to DaGeRe, Gary Gregory. 
-o IO-750:  FileUtils.iterateFiles also lists directories. Thanks to Sita Geßner, Sebastian Peters, Gary Gregory. 
-o IO-721:  Wrong exception message in FileUtils.setLastModified(File, File). Thanks to Dirk Heinrichs, Gary Gregory. 
-o IO-717:  Infinite loop in ReaderInputStream instead of throwing exception for CodingErrorAction.REPORT. Thanks to Marcono1234, Gary Gregory. 
-o IO-716:  ReaderInputStream enter infinite loop for too small buffer sizes. Thanks to Marcono1234, Gary Gregory. 
-o IO-638:  Infinite loop in CharSequenceInputStream.read for 4-byte characters with UTF-8 and 3-byte buffer. Thanks to Thayne McCombs, Gary Gregory. 
-o IO-638:  PathUtils.setReadOnly(Path, boolean, LinkOption...) should add READ_* file attributes when using POSIX. Thanks to Gary Gregory. 
-o IO-638:  PathUtils.setReadOnly(Path, boolean, LinkOption...) readOnly argument is always assumed true on POSIX. Thanks to Gary Gregory. 
-o IO-729:  Prevent IllegalArgumentExceptions in BrokenInputStream/Reader/OutputStream/Writer #278. Thanks to Rob Spoor, Gary Gregory. 
-o           FileUtils.copyURLToFile(URL, File, int, int) leaks its URLConnection.
+*           Add XmlStreamWriter(OutputStream, Charset). Thanks to Gary Gregory. 
+*           Add PathUtils.getLastModifiedFileTime(*). Thanks to Gary Gregory. 
+*           Add IOBiFunction, IOTriFunction, IOQuadFunction, IOPredicate, IOIterator, IOSpliterator, IOBaseStream, IOStream, FilesUncheck. Thanks to Gary Gregory. 
+*           Add IOUtils.consume(Reader). Thanks to Gary Gregory. 
+*           Add IOSupplier.asSupplier(). Thanks to Gary Gregory. 
+*           Add IOFunction.asFunction(). Thanks to Gary Gregory. 
+*           Add IOConsumer.asConsumer(). Thanks to Gary Gregory. 
+*           Add TimestampedObserver.isClosed(). Thanks to Gary Gregory. 
+*           IOExceptionList implements Iterable. Thanks to Gary Gregory. 
+* IO-784:  Add support for Appendable to HexDump #418. Thanks to Fredrik Kjellberg, Gary Gregory. 
+*           Add and use ThreadUtils. Thanks to DaGeRe, Gary Gregory. 
+* IO-786:  Add UnsynchronizedFilterInputStream. Thanks to Gary Gregory. 
+* IO-786:  Add UnsynchronizedBufferedInputStream. Thanks to Gary Gregory, Benoit Tellier. 
+*           Add FileSystem.getBlockSize(). Thanks to Gary Gregory. 
+*           Add builders and avoid creating more constructors for all permutations of current options. Thanks to Gary Gregory. 
+*           Refactor using new Supplier API IOUtils.toString(IOSupplier<InputStream>, Charset[, IOSupplier<String>]). Thanks to Gary Gregory, maxxedev. 
+*           Refactor using new Supplier API org.apache.commons.io.file.PathUtils.copy(IOSupplier<InputStream>, Path, CopyOption...). Thanks to Gary Gregory, maxxedev. 
+
+Fixed Bugs
+----------
+
+* IO-697:  IOUtils.toByteArray size validation does not match documentation. Thanks to otter606. 
+*           Fix Javadoc links to the JRE Javadoc 8. Thanks to Gary Gregory. 
+* IO-744:  FileWriterWithEncoding for an existing file no longer truncates the file. #251. Thanks to RBRi, Gary Gregory. 
+*           A null Charset or Charset name in FileWriterWithEncoding constructors uses the default Charset. Thanks to Gary Gregory. 
+*           Fix usage of assertNotNull #269. Thanks to Davide Angelocola. 
+* IO-727:  FilenameUtils directoryContains() should handle files with the same prefix #217. Thanks to trungPa, Gary Gregory. 
+* IO-748:  FileUtils.moveToDirectory() exception documentation and exception message error. Thanks to Dirk Heinrichs, Gary Gregory, Elango Ravi. 
+*           ThreadMonitor.sleep(Duration) ignores nanoseconds. Thanks to Gary Gregory. 
+*           Fix Javadoc in ThreadMonitor#run() method. #273. Thanks to Arturo Bernal. 
+* IO-749:  FileUtils.listFiles() does not list matching files if File parameter is a symbolic link. Thanks to haihuiyang, Gary Gregory. 
+*           Fix typo in Javadocs for FileUtils#convertFileCollectionToFileArray() #276. Thanks to niranjanghule, Gary Gregory. 
+*           Avoid Code Duplication: Reuse Sleep from ThreadMonitor #66. Thanks to DaGeRe, Gary Gregory. 
+* IO-750:  FileUtils.iterateFiles also lists directories. Thanks to Sita Geßner, Sebastian Peters, Gary Gregory. 
+* IO-721:  Wrong exception message in FileUtils.setLastModified(File, File). Thanks to Dirk Heinrichs, Gary Gregory. 
+* IO-717:  Infinite loop in ReaderInputStream instead of throwing exception for CodingErrorAction.REPORT. Thanks to Marcono1234, Gary Gregory. 
+* IO-716:  ReaderInputStream enter infinite loop for too small buffer sizes. Thanks to Marcono1234, Gary Gregory. 
+* IO-638:  Infinite loop in CharSequenceInputStream.read for 4-byte characters with UTF-8 and 3-byte buffer. Thanks to Thayne McCombs, Gary Gregory. 
+* IO-638:  PathUtils.setReadOnly(Path, boolean, LinkOption...) should add READ_* file attributes when using POSIX. Thanks to Gary Gregory. 
+* IO-638:  PathUtils.setReadOnly(Path, boolean, LinkOption...) readOnly argument is always assumed true on POSIX. Thanks to Gary Gregory. 
+* IO-729:  Prevent IllegalArgumentExceptions in BrokenInputStream/Reader/OutputStream/Writer #278. Thanks to Rob Spoor, Gary Gregory. 
+*           FileUtils.copyURLToFile(URL, File, int, int) leaks its URLConnection.
         Called by FileUtils.copyURLToFile(URL, File). Thanks to Gary Gregory. 
-o IO-714:  Fixed ReaderInputStream not calling CharsetEncoder.flush issue #283. Thanks to kevinwang1975, Gary Gregory. 
-o           Minor changes #287. Thanks to Arturo Bernal. 
-o IO-756:  Update FileWriterWithEncoding to extend ProxyWriter #296. Thanks to wodencafe, Gary Gregory, Bruno P. Kinoshita. 
-o           Initialize the message of an IOExceptionList to a default if null. Thanks to Gary Gregory. 
-o IO-751:  When deleting symlinks, File/PathUtils.deleteDirectory() changes file permissions of the target. Thanks to Gary Gregory, Richard Cyganiak. 
-o           ReaderInputStream maps null Charset, Charset name, and CharsetEncoder to the platform default instead of throwing a NullPointerException. Thanks to Gary Gregory. 
-o           CharSequenceInputStream maps null Charset and Charset name to the platform default instead of throwing a NullPointerException. Thanks to Gary Gregory. 
-o           WriterOutputStream maps null Charset, Charset name, and CharsetEncoder name to the platform default instead of throwing a NullPointerException. Thanks to Gary Gregory. 
-o           FileUtils.copyURLToFile should create target parent directories and overwrite target file #319. Thanks to Chad Wilson, Gary Gregory. 
-o IO-484:  Fix incorrect FilenameUtils Javadoc for null bytes #310. Thanks to Marcono1234, Gary Gregory. 
-o IO-484:  Change to uppercase variable constant. #323. Thanks to Arturo Bernal. 
-o IO-484:  IOCase.isCaseSensitive(IOCase) result is backward #325. Thanks to David Huang, Gary Gregory. 
-o IO-758:  Deprecate PathUtils.NOFOLLOW_LINK_OPTION_ARRAY in favor of noFollowLinkOptionArray(). Thanks to Marcono1234, Gary Gregory. 
-o           Improve ReaderInputStream documentation #291. Thanks to Marcono1234, Gary Gregory. 
-o           Fix misleading comments in FileFilterTest #334. Thanks to richarda23. 
-o           Add missing Javadoc for exceptions thrown for invalid arguments #339. Thanks to Diego Marcilio. 
-o           FileFilterTest minor fixes #340. Thanks to richarda23. 
-o IO-764:  IOUtils.write() throws OutOfMemoryError/NegativeArraySizeException while writing big strings #343. Thanks to DaGeRe, Gary Gregory. 
-o IO-768:  Add reserved Windows file names CONIN$ and CONOUT$ to FileSystem #355. Thanks to Marcono1234, Michael Osipov. 
-o IO-773:  RegexFileFilter is no longer Serializable. Thanks to Dominik Reinarz, Gary Gregory. 
-o IO-763:  [Javadoc] FileFilterUtils doc does not match impl: missing some file filters. Thanks to Richard Adams, Gary Gregory. 
-o IO-762:  FileSystem.WINDOWS.isReservedFileName doesn't check for file extension. Thanks to Leonidas Chiron, Gary Gregory. 
-o IO-772:  Confusing Javadoc on IOUtils#resourceToURL() and other resource* methods. Thanks to Dan Ziemba, Gary Gregory. 
-o IO-443:  FileUtils.copyFile methods throw an unnecessary "Failed to copy full contents from" exception. Thanks to Dan Ziemba, Gary Gregory. 
-o IO-564:  Pick up Javadoc from super for override write() methods in AbstractByteArrayOutputStream and ByteArrayOutputStream. Thanks to Hao Zhong, Bernd Eckenfels, Pascal Schumacher, Gary Gregory. 
-o           Fix minor typos #367. Thanks to Marc Wrobel. 
-o IO-776:  Fix parameters to requireNonNull call in DeferredOutputSteam #368. Thanks to Chris Povirk. 
-o           Fix PathUtils.copyFileToDirectory(URL,Path,CopyOption[]). Thanks to Gary Gregory. 
-o IO-386:  FileUtils.doCopyFile uses different methods to check the file sizes. Thanks to Sebb, Bernd Eckenfels, zhipengxu, Gary Gregory. 
-o           Fix typos #375. Thanks to Michael Ernst. 
-o IO-611:  FilenameUtils.normalize javadoc and tests #383. Thanks to Fedor Urvanov. 
-o IO-611:  Better docs in IOUtils and IOUtils.byteArray(int size) #374. Thanks to ArdenL-Liu, Bruno P. Kinoshita, Gary Gregory. 
-o IO-782:  SequenceReader should close readers when its close method is called #391. Thanks to Matteo Di Giovinazzo, Gary Gregory. 
-o IO-790:  Fix symbolic link file filter #450. Thanks to Miguel Muñoz, Gary Gregory. 
-o IO-790:  Apply nanoseconds precision for QueueInputStream timeout duration. #453. Thanks to maxxedev, Gary Gregory, Bruno P. Kinoshita. 
-o           Fix overflow for FileUtilsTest constants #456. Thanks to Marcono1234. 
-o           Serialization is deprecated and will be removed in 3.0. Thanks to Gary Gregory. 
-o           FileSystemUtils.performCommand(String[], int, Duration): Use Locale.getDefault() instead of ENGLISH. Thanks to Gary Gregory. 
-o IO-726:  Add MemoryMappedFileInputStream #215. Thanks to shollander, Gary Gregory. 
-
-Changes:
-o           Bump actions/cache from 2.1.6 to 3.0.10 #307, #337, #393. Thanks to Dependabot, Gary Gregory. 
-o           Bump actions/checkout from 2.3.4 to 3.1.0 #286, #298, #330, #392. Thanks to Dependabot, Gary Gregory. 
-o           Bump actions/setup-java from 2 to 3.6.0 #346, #397. Thanks to Dependabot. 
-o           Bump github/codeql-action from 1 to 2 #353. Thanks to Dependabot. 
-o           Bump Maven Javadoc plugin from 3.2.0 to 3.4.1. Thanks to Dependabot, Gary Gregory. 
-o           Bump spotbugs-maven-plugin from 4.2.3 to 4.7.3.0 #250, #259, #272, #274, #285, #288, #289, #305, #315, #326, #338, #360, #366, #370, #380, #395, #403. Thanks to Dependabot. 
-o           Bump spotbugs from 4.5.2 to 4.7.3 #313, #317, #357, #382, #398. Thanks to Gary Gregory, Dependabot. 
-o           Bump JUnit from 5.7.2 to 5.8.2. Thanks to Gary Gregory. 
-o           Bump maven-enforcer-plugin from 3.0.0-M3 to 3.3.0 #255, #363, #431, #446. Thanks to Dependabot. 
-o           Bump checkstyle from 8.44 to 9.3 #256, #257, #266, #279, #292. #308. Thanks to Dependabot, Gary Gregory. 
-o           Bump junit-bom from 5.8.0-M1 to 5.9.1 #260, #271, #275, #309, #386. Thanks to Dependabot. 
-o           Bump mockito-inline from 3.11.2 to 4.11.0 #262, #264, #282, #306, #314, #331, #348, #359, #381, #399, #405, #414, #420. Thanks to Dependabot, Gary Gregory. 
-o           Bump jmh.version from 1.32 to 1.36 #258, #316, #342, #404. Thanks to Dependabot. 
-o           Bump moditect-maven-plugin from 1.0.0.RC1 to 1.0.0.Final #280, #439, #445. Thanks to Dependabot. 
-o           Bump junit-pioneer from 1.4.2 to 1.9.1 #304. #335, #362, #402, #406, #409. Thanks to Dependabot, Gary Gregory. 
-o           Bump japicmp-maven-plugin from 0.15.3 to 0.16.0. Thanks to Gary Gregory. 
-o           Bump commons-parent from 52 to 57 #388, #415, #421, #184. Thanks to Gary Gregory, Dependabot. 
-o           Bump jacoco-maven-plugin from 0.8.7 to 0.8.8. Thanks to Gary Gregory. 
-o           Bump maven-antrun-plugin from 3.0.0 to 3.1.0 #354. Thanks to Dependabot. 
-o           Bump commons.surefire.version 3.0.0-M5 to 3.0.0-M7. Thanks to Gary Gregory. 
-o           Bump PMD from 6.44.0 to 6.52.0. Thanks to Gary Gregory. 
-o           Bump maven-pmd-plugin from 3.16.0 to 3.19.0. Thanks to Gary Gregory. 
-o           Bump apache-rat from 0.13 to 0.14. Thanks to Gary Gregory. 
-o           Bump exec-maven-plugin from 3.0.0 to 3.1.0 #369. Thanks to Dependabot. 
-o           Bump maven-checkstyle-plugin from 3.1.2 to 3.2.0 #376. Thanks to Dependabot. 
-o           Bump apache-rat-plugin from 0.14 to 0.15 #387. Thanks to Dependabot. 
-o           Bump default buffer size for CharSequenceInputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
-o           Bump default buffer size for ChunkedOutputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
-o           Bump default buffer size for ChunkedWriter to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
-o           Bump default buffer size for ReaderInputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
-o           Bump default buffer size for WriterOutputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
+* IO-714:  Fixed ReaderInputStream not calling CharsetEncoder.flush issue #283. Thanks to kevinwang1975, Gary Gregory. 
+*           Minor changes #287. Thanks to Arturo Bernal. 
+* IO-756:  Update FileWriterWithEncoding to extend ProxyWriter #296. Thanks to wodencafe, Gary Gregory, Bruno P. Kinoshita. 
+*           Initialize the message of an IOExceptionList to a default if null. Thanks to Gary Gregory. 
+* IO-751:  When deleting symlinks, File/PathUtils.deleteDirectory() changes file permissions of the target. Thanks to Gary Gregory, Richard Cyganiak. 
+*           ReaderInputStream maps null Charset, Charset name, and CharsetEncoder to the platform default instead of throwing a NullPointerException. Thanks to Gary Gregory. 
+*           CharSequenceInputStream maps null Charset and Charset name to the platform default instead of throwing a NullPointerException. Thanks to Gary Gregory. 
+*           WriterOutputStream maps null Charset, Charset name, and CharsetEncoder name to the platform default instead of throwing a NullPointerException. Thanks to Gary Gregory. 
+*           FileUtils.copyURLToFile should create target parent directories and overwrite target file #319. Thanks to Chad Wilson, Gary Gregory. 
+* IO-484:  Fix incorrect FilenameUtils Javadoc for null bytes #310. Thanks to Marcono1234, Gary Gregory. 
+* IO-484:  Change to uppercase variable constant. #323. Thanks to Arturo Bernal. 
+* IO-484:  IOCase.isCaseSensitive(IOCase) result is backward #325. Thanks to David Huang, Gary Gregory. 
+* IO-758:  Deprecate PathUtils.NOFOLLOW_LINK_OPTION_ARRAY in favor of noFollowLinkOptionArray(). Thanks to Marcono1234, Gary Gregory. 
+*           Improve ReaderInputStream documentation #291. Thanks to Marcono1234, Gary Gregory. 
+*           Fix misleading comments in FileFilterTest #334. Thanks to richarda23. 
+*           Add missing Javadoc for exceptions thrown for invalid arguments #339. Thanks to Diego Marcilio. 
+*           FileFilterTest minor fixes #340. Thanks to richarda23. 
+* IO-764:  IOUtils.write() throws OutOfMemoryError/NegativeArraySizeException while writing big strings #343. Thanks to DaGeRe, Gary Gregory. 
+* IO-768:  Add reserved Windows file names CONIN$ and CONOUT$ to FileSystem #355. Thanks to Marcono1234, Michael Osipov. 
+* IO-773:  RegexFileFilter is no longer Serializable. Thanks to Dominik Reinarz, Gary Gregory. 
+* IO-763:  [Javadoc] FileFilterUtils doc does not match impl: missing some file filters. Thanks to Richard Adams, Gary Gregory. 
+* IO-762:  FileSystem.WINDOWS.isReservedFileName doesn't check for file extension. Thanks to Leonidas Chiron, Gary Gregory. 
+* IO-772:  Confusing Javadoc on IOUtils#resourceToURL() and other resource* methods. Thanks to Dan Ziemba, Gary Gregory. 
+* IO-443:  FileUtils.copyFile methods throw an unnecessary "Failed to copy full contents from" exception. Thanks to Dan Ziemba, Gary Gregory. 
+* IO-564:  Pick up Javadoc from super for override write() methods in AbstractByteArrayOutputStream and ByteArrayOutputStream. Thanks to Hao Zhong, Bernd Eckenfels, Pascal Schumacher, Gary Gregory. 
+*           Fix minor typos #367. Thanks to Marc Wrobel. 
+* IO-776:  Fix parameters to requireNonNull call in DeferredOutputSteam #368. Thanks to Chris Povirk. 
+*           Fix PathUtils.copyFileToDirectory(URL,Path,CopyOption[]). Thanks to Gary Gregory. 
+* IO-386:  FileUtils.doCopyFile uses different methods to check the file sizes. Thanks to Sebb, Bernd Eckenfels, zhipengxu, Gary Gregory. 
+*           Fix typos #375. Thanks to Michael Ernst. 
+* IO-611:  FilenameUtils.normalize javadoc and tests #383. Thanks to Fedor Urvanov. 
+* IO-611:  Better docs in IOUtils and IOUtils.byteArray(int size) #374. Thanks to ArdenL-Liu, Bruno P. Kinoshita, Gary Gregory. 
+* IO-782:  SequenceReader should close readers when its close method is called #391. Thanks to Matteo Di Giovinazzo, Gary Gregory. 
+* IO-790:  Fix symbolic link file filter #450. Thanks to Miguel Muñoz, Gary Gregory. 
+* IO-790:  Apply nanoseconds precision for QueueInputStream timeout duration. #453. Thanks to maxxedev, Gary Gregory, Bruno P. Kinoshita. 
+*           Fix overflow for FileUtilsTest constants #456. Thanks to Marcono1234. 
+*           Serialization is deprecated and will be removed in 3.0. Thanks to Gary Gregory. 
+*           FileSystemUtils.performCommand(String[], int, Duration): Use Locale.getDefault() instead of ENGLISH. Thanks to Gary Gregory. 
+* IO-726:  Add MemoryMappedFileInputStream #215. Thanks to shollander, Gary Gregory. 
+
+Changes
+-------
+
+*           Bump actions/cache from 2.1.6 to 3.0.10 #307, #337, #393. Thanks to Dependabot, Gary Gregory. 
+*           Bump actions/checkout from 2.3.4 to 3.1.0 #286, #298, #330, #392. Thanks to Dependabot, Gary Gregory. 
+*           Bump actions/setup-java from 2 to 3.6.0 #346, #397. Thanks to Dependabot. 
+*           Bump github/codeql-action from 1 to 2 #353. Thanks to Dependabot. 
+*           Bump Maven Javadoc plugin from 3.2.0 to 3.4.1. Thanks to Dependabot, Gary Gregory. 
+*           Bump spotbugs-maven-plugin from 4.2.3 to 4.7.3.0 #250, #259, #272, #274, #285, #288, #289, #305, #315, #326, #338, #360, #366, #370, #380, #395, #403. Thanks to Dependabot. 
+*           Bump spotbugs from 4.5.2 to 4.7.3 #313, #317, #357, #382, #398. Thanks to Gary Gregory, Dependabot. 
+*           Bump JUnit from 5.7.2 to 5.8.2. Thanks to Gary Gregory. 
+*           Bump maven-enforcer-plugin from 3.0.0-M3 to 3.3.0 #255, #363, #431, #446. Thanks to Dependabot. 
+*           Bump checkstyle from 8.44 to 9.3 #256, #257, #266, #279, #292. #308. Thanks to Dependabot, Gary Gregory. 
+*           Bump junit-bom from 5.8.0-M1 to 5.9.1 #260, #271, #275, #309, #386. Thanks to Dependabot. 
+*           Bump mockito-inline from 3.11.2 to 4.11.0 #262, #264, #282, #306, #314, #331, #348, #359, #381, #399, #405, #414, #420. Thanks to Dependabot, Gary Gregory. 
+*           Bump jmh.version from 1.32 to 1.36 #258, #316, #342, #404. Thanks to Dependabot. 
+*           Bump moditect-maven-plugin from 1.0.0.RC1 to 1.0.0.Final #280, #439, #445. Thanks to Dependabot. 
+*           Bump junit-pioneer from 1.4.2 to 1.9.1 #304. #335, #362, #402, #406, #409. Thanks to Dependabot, Gary Gregory. 
+*           Bump japicmp-maven-plugin from 0.15.3 to 0.16.0. Thanks to Gary Gregory. 
+*           Bump commons-parent from 52 to 57 #388, #415, #421, #184. Thanks to Gary Gregory, Dependabot. 
+*           Bump jacoco-maven-plugin from 0.8.7 to 0.8.8. Thanks to Gary Gregory. 
+*           Bump maven-antrun-plugin from 3.0.0 to 3.1.0 #354. Thanks to Dependabot. 
+*           Bump commons.surefire.version 3.0.0-M5 to 3.0.0-M7. Thanks to Gary Gregory. 
+*           Bump PMD from 6.44.0 to 6.52.0. Thanks to Gary Gregory. 
+*           Bump maven-pmd-plugin from 3.16.0 to 3.19.0. Thanks to Gary Gregory. 
+*           Bump apache-rat from 0.13 to 0.14. Thanks to Gary Gregory. 
+*           Bump exec-maven-plugin from 3.0.0 to 3.1.0 #369. Thanks to Dependabot. 
+*           Bump maven-checkstyle-plugin from 3.1.2 to 3.2.0 #376. Thanks to Dependabot. 
+*           Bump apache-rat-plugin from 0.14 to 0.15 #387. Thanks to Dependabot. 
+*           Bump default buffer size for CharSequenceInputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
+*           Bump default buffer size for ChunkedOutputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
+*           Bump default buffer size for ChunkedWriter to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
+*           Bump default buffer size for ReaderInputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
+*           Bump default buffer size for WriterOutputStream to IOUtils#DEFAULT_BUFFER_SIZE. Thanks to Gary Gregory. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -470,13 +961,14 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO 
 Version 2.11.0
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -487,16 +979,15 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
+Fixed Bugs
+----------
 
-
-Fixed Bugs:
-o IO-741:  FileUtils.listFiles does not list matching files if File parameter is a symbolic link. Thanks to Zach Sherman. 
-o IO-724:  FileUtils#deleteDirectory(File) exception Javadoc inaccurate update #245. Thanks to liran2000. 
-o          Minor changes #243. Thanks to Arturo Bernal. 
-o          Replace construction of FileInputStream and FileOutputStream objects with Files NIO APIs. #221. Thanks to Arturo Bernal. 
-o          Fix IndexOutOfBoundsException in IOExceptionList constructors. Thanks to Gary Gregory. 
-o          Remove IOException from the method signatures that no longer throw IOException.
+* IO-741:  FileUtils.listFiles does not list matching files if File parameter is a symbolic link. Thanks to Zach Sherman. 
+* IO-724:  FileUtils#deleteDirectory(File) exception Javadoc inaccurate update #245. Thanks to liran2000. 
+*          Minor changes #243. Thanks to Arturo Bernal. 
+*          Replace construction of FileInputStream and FileOutputStream objects with Files NIO APIs. #221. Thanks to Arturo Bernal. 
+*          Fix IndexOutOfBoundsException in IOExceptionList constructors. Thanks to Gary Gregory. 
+*          Remove IOException from the method signatures that no longer throw IOException.
            This maintains binary compatibility but not source compatibility.
            - FilenameUtils
                directoryContains(String, String)
@@ -511,28 +1002,26 @@ o          Remove IOException from the method signatures that no longer throw IO
                toString(byte[])
                toString(byte[], String) Thanks to Gary Gregory. 
 
-Changes:
-o          Add SymbolicLinkFileFilter. Thanks to Gary Gregory. 
-o          Add test to make sure the setter of AndFileFilter works correctly #244. Thanks to trncate.
-o          Add XmlStreamReader(Path). Thanks to Gary Gregory. 
-o          Bump mockito-inline from 3.11.0 to 3.11.2 #247. Thanks to Dependabot. 
-o          Bump jmh.version from 1.27 to 1.32 #237. Thanks to Dependabot. 
-o          Bump spotbugs from 4.2.3 to 4.3.0 #249. Thanks to Dependabot. 
+Changes
+-------
+
+*          Add SymbolicLinkFileFilter. Thanks to Gary Gregory. 
+*          Add test to make sure the setter of AndFileFilter works correctly #244. Thanks to trncate.
+*          Add XmlStreamReader(Path). Thanks to Gary Gregory. 
+*          Bump mockito-inline from 3.11.0 to 3.11.2 #247. Thanks to Dependabot. 
+*          Bump jmh.version from 1.27 to 1.32 #237. Thanks to Dependabot. 
+*          Bump spotbugs from 4.2.3 to 4.3.0 #249. Thanks to Dependabot. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -546,13 +1035,14 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO 
 Version 2.10.0
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -563,38 +1053,38 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
+New features
+------------
+
+*           Add and use RegexFileFilter.toString(). Thanks to Gary Gregory. 
+*           Add and use RegexFileFilter.RegexFileFilter(Pattern, Function<Path>, String>) Thanks to Gary Gregory. 
+*           Add and use IOCase.isCaseSensitive(IOCase). Thanks to Gary Gregory. 
 
-New features:
-o           Add and use RegexFileFilter.toString(). Thanks to Gary Gregory. 
-o           Add and use RegexFileFilter.RegexFileFilter(Pattern, Function<Path>, String>) Thanks to Gary Gregory. 
-o           Add and use IOCase.isCaseSensitive(IOCase). Thanks to Gary Gregory. 
+Fixed Bugs
+----------
 
-Fixed Bugs:
-o IO-733:  RegexFileFilter uses the path and file name instead of just the file name. Thanks to Jim Sellers, Gary Gregory. 
-o IO-734:  The OSGi manifest now contains sun.* import packages #239. Thanks to Eric Norman. 
-o IO-585:  Sanitize double slash after prefix #79. Thanks to Adam McClenaghan. 
+* IO-733:  RegexFileFilter uses the path and file name instead of just the file name. Thanks to Jim Sellers, Gary Gregory. 
+* IO-734:  The OSGi manifest now contains sun.* import packages #239. Thanks to Eric Norman. 
+* IO-585:  Sanitize double slash after prefix #79. Thanks to Adam McClenaghan. 
 
-Changes:
-o           Bump actions/cache from 2.1.5 to 2.1.6 #238. Thanks to Dependabot. 
-o           Bump junit-pioneer from 1.4.1 to 1.4.2 #240. Thanks to Dependabot. 
-o           Bump checkstyle from 8.42 to 8.43 #241. Thanks to Dependabot. 
-o           Bump mockito-inline from 3.10.0 to 3.11.0 #242. Thanks to Dependabot. 
+Changes
+-------
+
+*           Bump actions/cache from 2.1.5 to 2.1.6 #238. Thanks to Dependabot. 
+*           Bump junit-pioneer from 1.4.1 to 1.4.2 #240. Thanks to Dependabot. 
+*           Bump checkstyle from 8.42 to 8.43 #241. Thanks to Dependabot. 
+*           Bump mockito-inline from 3.10.0 to 3.11.0 #242. Thanks to Dependabot. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -608,13 +1098,14 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO 
 Version 2.8.0
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -625,70 +1116,72 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
-
-New features:
-o Add org.apache.commons.io.input.CircularInputStream. Thanks to Gary Gregory. 
-o Add org.apache.commons.io.file.PathUtils.cleanDirectory(Path, FileVisitOption...). Thanks to Gary Gregory. 
-o Add org.apache.commons.io.file.PathUtils.deleteDirectory(Path, FileVisitOption...). Thanks to Gary Gregory. 
-o Add NullAppendable. Thanks to Gary Gregory. 
-o Add PathUtils.getAclEntryList(Path). Thanks to Gary Gregory. 
-o Null-guard IOUtils.close(Closeable, IOConsumer). Thanks to Gary Gregory. 
-o Add ReversedLinesFileReader.readLines(int). Thanks to Gary Gregory. 
-o Add ReversedLinesFileReader.toString(int). Thanks to Gary Gregory. 
-o IO-684:  Add PathUtils.delete(Path, DeleteOption...).
+New features
+------------
+
+* Add org.apache.commons.io.input.CircularInputStream. Thanks to Gary Gregory. 
+* Add org.apache.commons.io.file.PathUtils.cleanDirectory(Path, FileVisitOption...). Thanks to Gary Gregory. 
+* Add org.apache.commons.io.file.PathUtils.deleteDirectory(Path, FileVisitOption...). Thanks to Gary Gregory. 
+* Add NullAppendable. Thanks to Gary Gregory. 
+* Add PathUtils.getAclEntryList(Path). Thanks to Gary Gregory. 
+* Null-guard IOUtils.close(Closeable, IOConsumer). Thanks to Gary Gregory. 
+* Add ReversedLinesFileReader.readLines(int). Thanks to Gary Gregory. 
+* Add ReversedLinesFileReader.toString(int). Thanks to Gary Gregory. 
+* IO-684:  Add PathUtils.delete(Path, DeleteOption...).
         Add PathUtils.deleteDirectory(Path, DeleteOption...).
         Add PathUtils.deleteFile(Path, DeleteOption...).
         Add PathUtils.setReadOnly(Path, boolean, LinkOption...).
         Add CleaningPathVisitor.CleaningPathVisitor(PathCounters, DeleteOption[], String...).
         Add DeletingPathVisitor.DeletingPathVisitor(PathCounters, DeleteOption[], String...). Thanks to Gary Gregory, Robin Jansohn. 
-o Add RandomAccessFileInputStream. Thanks to Gary Gregory. 
-o IO-681:  IOUtils.close(Closeable) should allow a list of closeables. 
-o Add IOUtils.consume(InputStream). Thanks to Gary Gregory. 
-o IO-676:  Add isFileNewer() and isFileOlder() methods that support the Java 8 Date/Time API. #124. Thanks to Isira Seneviratne, Gary Gregory. 
-o Add a MarkShieldInputStream #119. Thanks to Adam Retter, Gary Gregory. 
-o Deprecate IOUtils.LINE_SEPARATOR in favor of Java 7's System.lineSeparator(). Thanks to Gary Gregory. 
-
-Fixed Bugs:
-o CharSequenceReader.skip should return 0 instead of EOF on stream end #123. Thanks to Rob Spoor, Jochen Wiedmann. 
-o Implement CharSequenceReader.ready() #122. Thanks to Rob Spoor. 
-o IO-669:  Fix code smells; fix typos #115. Thanks to XenoAmess, Gary Gregory. 
-o Add caching for required charsets #120. Thanks to Jerome Wolff, Gary Gregory. 
-o IO-673:  Make some simplifications #121. Thanks to Jerome Wolff. 
-o IO-674:  InfiniteCircularInputStream is not infinite if its input buffer contains -1. Thanks to Gary Gregory. 
-o IO-675:  InfiniteCircularInputStream throws a divide-by-zero exception when reading if its input buffer is size 0. Thanks to Gary Gregory. 
-o IO-677:  FileSystem.getCurrent() does not return the correct enum. Thanks to Gary Gregory. 
-o IO-679:  input.AbstractCharacterFilterReader passes count of chars read #132. Thanks to proneel. 
-o IO-683:  CircularBufferInputStream.read() fails to convert byte to unsigned int 
-o Fix SpotBugs issues in org.apache.commons.io.FileUtils. Thanks to Gary Gregory. 
-o IO-672:  Copying a File sets last modified date to 01 January 1970. 
-o IO-676:  Prevent NullPointerException in ReversedLinesFileReader constructors #117. Thanks to Michael Ernst, Gary Gregory. 
-
-Changes:
-o Replace FindBugs with SpotBugs. Thanks to Gary Gregory. 
-o maven-checkstyle-plugin 3.1.0 -> 3.1.1. Thanks to Gary Gregory. 
-o Update tests from org.apache.commons:commons-lang3 3.10 to 3.11. Thanks to Gary Gregory. 
-o Update commons-parent from 50 to 51 #129. Thanks to Gary Gregory. 
-o Update actions/checkout from v1 to v2.3.1 #126. Thanks to Gary Gregory. 
-o Update junit-pioneer from 0.6.0 to 0.8.0, #127, #135. Thanks to Gary Gregory. 
-o Update mockito-core from 3.3.3 to 3.5.9 #128, #133, #145, #149, #151. Thanks to Gary Gregory. 
-o Update spotbugs from 4.0.6 to 4.1.1 #134. Thanks to Dependabot. 
-o Update junit-pioneer from 0.8.0 to 0.9.0 #138. Thanks to Dependabot. 
-o Update actions/checkout from v2.3.1 to v2.3.2 #140. Thanks to Dependabot. 
-o Update actions/setup-java from v1.4.0 to v1.4.2 #141, #148. Thanks to Dependabot. 
+* Add RandomAccessFileInputStream. Thanks to Gary Gregory. 
+* IO-681:  IOUtils.close(Closeable) should allow a list of closeables. 
+* Add IOUtils.consume(InputStream). Thanks to Gary Gregory. 
+* IO-676:  Add isFileNewer() and isFileOlder() methods that support the Java 8 Date/Time API. #124. Thanks to Isira Seneviratne, Gary Gregory. 
+* Add a MarkShieldInputStream #119. Thanks to Adam Retter, Gary Gregory. 
+* Deprecate IOUtils.LINE_SEPARATOR in favor of Java 7's System.lineSeparator(). Thanks to Gary Gregory. 
+
+Fixed Bugs
+----------
+
+* CharSequenceReader.skip should return 0 instead of EOF on stream end #123. Thanks to Rob Spoor, Jochen Wiedmann. 
+* Implement CharSequenceReader.ready() #122. Thanks to Rob Spoor. 
+* IO-669:  Fix code smells; fix typos #115. Thanks to XenoAmess, Gary Gregory. 
+* Add caching for required charsets #120. Thanks to Jerome Wolff, Gary Gregory. 
+* IO-673:  Make some simplifications #121. Thanks to Jerome Wolff. 
+* IO-674:  InfiniteCircularInputStream is not infinite if its input buffer contains -1. Thanks to Gary Gregory. 
+* IO-675:  InfiniteCircularInputStream throws a divide-by-zero exception when reading if its input buffer is size 0. Thanks to Gary Gregory. 
+* IO-677:  FileSystem.getCurrent() does not return the correct enum. Thanks to Gary Gregory. 
+* IO-679:  input.AbstractCharacterFilterReader passes count of chars read #132. Thanks to proneel. 
+* IO-683:  CircularBufferInputStream.read() fails to convert byte to unsigned int 
+* Fix SpotBugs issues in org.apache.commons.io.FileUtils. Thanks to Gary Gregory. 
+* IO-672:  Copying a File sets last modified date to 01 January 1970. 
+* IO-676:  Prevent NullPointerException in ReversedLinesFileReader constructors #117. Thanks to Michael Ernst, Gary Gregory. 
+
+Changes
+-------
+
+* Replace FindBugs with SpotBugs. Thanks to Gary Gregory. 
+* maven-checkstyle-plugin 3.1.0 -> 3.1.1. Thanks to Gary Gregory. 
+* Update tests from org.apache.commons:commons-lang3 3.10 to 3.11. Thanks to Gary Gregory. 
+* Update commons-parent from 50 to 51 #129. Thanks to Gary Gregory. 
+* Update actions/checkout from v1 to v2.3.1 #126. Thanks to Gary Gregory. 
+* Update junit-pioneer from 0.6.0 to 0.8.0, #127, #135. Thanks to Gary Gregory. 
+* Update mockito-core from 3.3.3 to 3.5.9 #128, #133, #145, #149, #151. Thanks to Gary Gregory. 
+* Update spotbugs from 4.0.6 to 4.1.1 #134. Thanks to Dependabot. 
+* Update junit-pioneer from 0.8.0 to 0.9.0 #138. Thanks to Dependabot. 
+* Update actions/checkout from v2.3.1 to v2.3.2 #140. Thanks to Dependabot. 
+* Update actions/setup-java from v1.4.0 to v1.4.2 #141, #148. Thanks to Dependabot. 
 
 Compatibility with 2.7:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -702,13 +1195,14 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO 
 Version 2.7
 Release Notes
 
-INTRODUCTION:
+Introduction
+------------
 
 Commons IO is a package of Java utility classes like java.io.  
 Classes in this package are considered to be so standard and of such high 
@@ -719,88 +1213,90 @@ file comparators, endian transformation classes, and much more.
 
 Java 8 required.
 
-Changes in this version include:
-
-New features:
-o           Adding the CircularBufferInputStream, and the PeekableInputStream. 
-o IO-553:  Add org.apache.commons.io.FilenameUtils.isIllegalWindowsFileName(char). 
-o IO-577:  Add readers to filter out given characters: CharacterSetFilterReader and CharacterFilterReader. Thanks to Gary Gregory. 
-o IO-594:  Add IOUtils copy methods with java.lang.Appendable as the target. Thanks to Gary Gregory. 
-o IO-605:  Add class CanExecuteFileFilter. Thanks to Gary Gregory. 
-o IO-578:  Support java.nio.Path and non-default file systems for ReversedLinesFileReader (#62). Thanks to Mark Chesney. 
-o IO-608:  Add a convenience NullPrintStream. Thanks to Gary Gregory. 
-o IO-612:  Add class TeeReader. Thanks to Rob Spoor, Gary Gregory. 
-o IO-613:  Add classes ClosedReader and CloseShieldReader. #84. Thanks to Rob Spoor, Gary Gregory. 
-o IO-614:  Add classes TaggedWriter, ClosedWriter and BrokenWriter. #86. Thanks to Rob Spoor. 
-o IO-615:  Add classes TeeWriter, FilterCollectionWriter, ProxyCollectionWriter, IOExceptionList, IOIndexedException. Thanks to Gary Gregory, Rob Spoor. 
-o IO-616:  Add class AppendableWriter. #87. Thanks to Rob Spoor. 
-o IO-617:  Add class CloseShieldWriter. #83. Thanks to Rob Spoor, Gary Gregory. 
-o IO-618:  Add classes Added TaggedReader, ClosedReader and BrokenReader. #85. Thanks to Rob Spoor. 
-o IO-619:  Support sub sequences in CharSequenceReader. #91. Thanks to Rob Spoor. 
-o IO-631:  Add a CountingFileVisitor (as the basis for a forthcoming DeletingFileVisitor). Thanks to Gary Gregory. 
-o IO-632:  Add PathUtils for operations on NIO Path. Thanks to Gary Gregory. 
-o IO-633:  Add DeletingFileVisitor. Thanks to Gary Gregory. 
-o IO-635:  Add org.apache.commons.io.IOUtils.close(Closeable). Thanks to Gary Gregory. 
-o IO-636:  Add and reuse org.apache.commons.io.IOUtils.closeQuitely(Closeable, Consumer<IOException>).
+New features
+------------
+
+*           Adding the CircularBufferInputStream, and the PeekableInputStream. 
+* IO-553:  Add org.apache.commons.io.FilenameUtils.isIllegalWindowsFileName(char). 
+* IO-577:  Add readers to filter out given characters: CharacterSetFilterReader and CharacterFilterReader. Thanks to Gary Gregory. 
+* IO-594:  Add IOUtils copy methods with java.lang.Appendable as the target. Thanks to Gary Gregory. 
+* IO-605:  Add class CanExecuteFileFilter. Thanks to Gary Gregory. 
+* IO-578:  Support java.nio.Path and non-default file systems for ReversedLinesFileReader (#62). Thanks to Mark Chesney. 
+* IO-608:  Add a convenience NullPrintStream. Thanks to Gary Gregory. 
+* IO-612:  Add class TeeReader. Thanks to Rob Spoor, Gary Gregory. 
+* IO-613:  Add classes ClosedReader and CloseShieldReader. #84. Thanks to Rob Spoor, Gary Gregory. 
+* IO-614:  Add classes TaggedWriter, ClosedWriter and BrokenWriter. #86. Thanks to Rob Spoor. 
+* IO-615:  Add classes TeeWriter, FilterCollectionWriter, ProxyCollectionWriter, IOExceptionList, IOIndexedException. Thanks to Gary Gregory, Rob Spoor. 
+* IO-616:  Add class AppendableWriter. #87. Thanks to Rob Spoor. 
+* IO-617:  Add class CloseShieldWriter. #83. Thanks to Rob Spoor, Gary Gregory. 
+* IO-618:  Add classes Added TaggedReader, ClosedReader and BrokenReader. #85. Thanks to Rob Spoor. 
+* IO-619:  Support sub sequences in CharSequenceReader. #91. Thanks to Rob Spoor. 
+* IO-631:  Add a CountingFileVisitor (as the basis for a forthcoming DeletingFileVisitor). Thanks to Gary Gregory. 
+* IO-632:  Add PathUtils for operations on NIO Path. Thanks to Gary Gregory. 
+* IO-633:  Add DeletingFileVisitor. Thanks to Gary Gregory. 
+* IO-635:  Add org.apache.commons.io.IOUtils.close(Closeable). Thanks to Gary Gregory. 
+* IO-636:  Add and reuse org.apache.commons.io.IOUtils.closeQuitely(Closeable, Consumer<IOException>).
            Add and reuse org.apache.commons.io.IOUtils.close(Closeable, IOConsumer<IOException>). Thanks to Gary Gregory. 
-o IO-645:  Add org.apache.commons.io.file.PathUtils.fileContentEquals(Path, Path, OpenOption...). Thanks to Gary Gregory. 
-o IO-458:  Add a SequenceReader similar to java.io.SequenceInputStream. Thanks to Gary Gregory, Joshua Gitlin. 
-o IO-648:  Implement directory content equality. 100#. Thanks to Gary Gregory. 
-o IO-648:  Refactor ByteArrayOutputStream into synchronized and unsynchronized versions #108. Thanks to Adam Retter, Alex Herbert, Gary Gregory. 
-o IO-662:  Refactor ByteArrayOutputStream into synchronized and unsynchronized versions #108. Thanks to Adam Retter, Gary Gregory. 
-
-Fixed Bugs:
-o IO-589:  Some tests fail if the base path contains a space. 
-o IO-582:  Make methods in ObservableInputStream.Observer public. Thanks to Bruno Palos.
-o IO-535:  Thread bug in FileAlterationMonitor.stop(int). Thanks to Svetlin Zarev, Anthony Raymond. 
-o IO-557:  Perform locale independent upper case conversions. Thanks to luccioman. 
-o IO-570:  Missing Javadoc in FilenameUtils causing Travis-CI build to fail. Thanks to Pranet Verma. 
-o IO-571:  Remove redundant isDirectory() check in org.apache.commons.io.FileUtils.listFilesAndDirs(File, IOFileFilter, IOFileFilter). Thanks to pranet. 
-o IO-559:  FilenameUtils.normalize now verifies hostname syntax in UNC path. 
-o IO-554:  FileUtils.copyToFile(InputStream source, File destination) should not close input stream. Thanks to Michele Mariotti. 
-o IO-604:  FileUtils.doCopyFile(File, File, boolean) can throw ClosedByInterruptException. Thanks to Gary Gregory. 
-o IO-625:  Corrected misleading exception message for FileUtils.copyDirectoryToDirectory. Thanks to Mikko Maunu. 
-o IO-626:  A mistake in the FilenameUtils.concat()'s Javadoc about an absolute path. Thanks to Yuji Konishi. 
-o IO-640:  NPE in org.apache.commons.io.IOUtils.contentEquals(InputStream, InputStream) when only one input is null. Thanks to Gary Gregory. 
-o IO-641:  NPE in org.apache.commons.io.IOUtils.contentEquals(Reader, Reader) when only one input is null. Thanks to Gary Gregory. 
-o IO-643:  NPE in org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(Reader, Reader) when only one input is null. Thanks to Gary Gregory. 
-o IO-644:  NPE in org.apache.commons.io.FileUtils.contentEqualsIgnoreEOL(File, File) when only one input is null. Thanks to Gary Gregory. 
-o IO-664:  org.apache.commons.io.FileUtils.copyURLToFile(*) open but do not close streams. Thanks to Gary Gregory. 
-
-Changes:
-o IO-572:  Refactor duplicate code in org.apache.commons.io.FileUtils. Thanks to Pranet Verma. 
-o IO-580:  Update org.apache.commons.io.FilenameUtils.isExtension(String, String[]) to use var args. 
-o IO-701:  Make array declaration in ThresholdingOutputStream consistent with other array declarations in the library #77. Thanks to Raymond Tan. 
-o IO-607:  Update from Java 7 to Java 8. Thanks to Gary Gregory. 
-o IO-610:  Remove throws IOException in method isSymlink() #80. Thanks to Sebastian. 
-o IO-628:  Migration to JUnit Jupiter #97. Thanks to Allon Mureinik. 
-o IO-630:  Deprecate org.apache.commons.io.output.NullOutputStream.NullOutputStream() in favor of org.apache.commons.io.output.NullOutputStream.NULL_OUTPUT_STREAM. Thanks to Gary Gregory. 
-o IO-629:  FileUtils#forceDelete should use Files#delete rather than File#delete so exception messages includes reason for failure. Thanks to Ian Springer, Ian Springer, Gary Gregory. 
-o IO-634:  Make getCause synchronized and use a Deque instead of a Stack #64. Thanks to Václav Haisman, Bruno P. Kinoshita, Gary Gregory. 
-o            Update tests from Apache Commons Lang 3.9 to 3.10. Thanks to Gary Gregory. 
-o            Update tests org.junit-pioneer:junit-pioneer 0.3.0 -> 0.6.0. Thanks to Gary Gregory. 
-o            Update tests org.junit.jupiter:junit-jupiter 5.5.2 -> 5.6.2. Thanks to Gary Gregory. 
-o            Update tests org.mockito:mockito-core 3.0.0 -> 3.3.3. Thanks to Gary Gregory. 
-o IO-666:  Normalize internal buffers to 8192 bytes. Thanks to Gary Gregory. 
-o IO-665:  Ensure that passing a null InputStream results in NPE with tests #112. Thanks to Otto Fowler, Gary Gregory. 
-o            commons.jacoco.version 0.8.4 -> 0.8.5. Thanks to Gary Gregory. 
-o            com.github.siom79.japicmp:japicmp-maven-plugin 0.14.1 -> 0.14.3. Thanks to Gary Gregory. 
-o IO-667:  Add functional interfaces IOFunction and IOSupplier #110. Thanks to Adam Retter, Gary Gregory. 
-o            Support sub sequences in CharSequenceReader #91. Thanks to Rob Spoor, Gary Gregory. 
-o            Remove deprecated sudo setting. #113. Thanks to dengliming. 
+* IO-645:  Add org.apache.commons.io.file.PathUtils.fileContentEquals(Path, Path, OpenOption...). Thanks to Gary Gregory. 
+* IO-458:  Add a SequenceReader similar to java.io.SequenceInputStream. Thanks to Gary Gregory, Joshua Gitlin. 
+* IO-648:  Implement directory content equality. 100#. Thanks to Gary Gregory. 
+* IO-648:  Refactor ByteArrayOutputStream into synchronized and unsynchronized versions #108. Thanks to Adam Retter, Alex Herbert, Gary Gregory. 
+* IO-662:  Refactor ByteArrayOutputStream into synchronized and unsynchronized versions #108. Thanks to Adam Retter, Gary Gregory. 
+
+Fixed Bugs
+----------
+
+* IO-589:  Some tests fail if the base path contains a space. 
+* IO-582:  Make methods in ObservableInputStream.Observer public. Thanks to Bruno Palos.
+* IO-535:  Thread bug in FileAlterationMonitor.stop(int). Thanks to Svetlin Zarev, Anthony Raymond. 
+* IO-557:  Perform locale independent upper case conversions. Thanks to luccioman. 
+* IO-570:  Missing Javadoc in FilenameUtils causing Travis-CI build to fail. Thanks to Pranet Verma. 
+* IO-571:  Remove redundant isDirectory() check in org.apache.commons.io.FileUtils.listFilesAndDirs(File, IOFileFilter, IOFileFilter). Thanks to pranet. 
+* IO-559:  FilenameUtils.normalize now verifies hostname syntax in UNC path. 
+* IO-554:  FileUtils.copyToFile(InputStream source, File destination) should not close input stream. Thanks to Michele Mariotti. 
+* IO-604:  FileUtils.doCopyFile(File, File, boolean) can throw ClosedByInterruptException. Thanks to Gary Gregory. 
+* IO-625:  Corrected misleading exception message for FileUtils.copyDirectoryToDirectory. Thanks to Mikko Maunu. 
+* IO-626:  A mistake in the FilenameUtils.concat()'s Javadoc about an absolute path. Thanks to Yuji Konishi. 
+* IO-640:  NPE in org.apache.commons.io.IOUtils.contentEquals(InputStream, InputStream) when only one input is null. Thanks to Gary Gregory. 
+* IO-641:  NPE in org.apache.commons.io.IOUtils.contentEquals(Reader, Reader) when only one input is null. Thanks to Gary Gregory. 
+* IO-643:  NPE in org.apache.commons.io.IOUtils.contentEqualsIgnoreEOL(Reader, Reader) when only one input is null. Thanks to Gary Gregory. 
+* IO-644:  NPE in org.apache.commons.io.FileUtils.contentEqualsIgnoreEOL(File, File) when only one input is null. Thanks to Gary Gregory. 
+* IO-664:  org.apache.commons.io.FileUtils.copyURLToFile(*) open but do not close streams. Thanks to Gary Gregory. 
+
+Changes
+-------
+
+* IO-572:  Refactor duplicate code in org.apache.commons.io.FileUtils. Thanks to Pranet Verma. 
+* IO-580:  Update org.apache.commons.io.FilenameUtils.isExtension(String, String[]) to use var args. 
+* IO-701:  Make array declaration in ThresholdingOutputStream consistent with other array declarations in the library #77. Thanks to Raymond Tan. 
+* IO-607:  Update from Java 7 to Java 8. Thanks to Gary Gregory. 
+* IO-610:  Remove throws IOException in method isSymlink() #80. Thanks to Sebastian. 
+* IO-628:  Migration to JUnit Jupiter #97. Thanks to Allon Mureinik. 
+* IO-630:  Deprecate org.apache.commons.io.output.NullOutputStream.NullOutputStream() in favor of org.apache.commons.io.output.NullOutputStream.NULL_OUTPUT_STREAM. Thanks to Gary Gregory. 
+* IO-629:  FileUtils#forceDelete should use Files#delete rather than File#delete so exception messages includes reason for failure. Thanks to Ian Springer, Ian Springer, Gary Gregory. 
+* IO-634:  Make getCause synchronized and use a Deque instead of a Stack #64. Thanks to Václav Haisman, Bruno P. Kinoshita, Gary Gregory. 
+*            Update tests from Apache Commons Lang 3.9 to 3.10. Thanks to Gary Gregory. 
+*            Update tests org.junit-pioneer:junit-pioneer 0.3.0 -> 0.6.0. Thanks to Gary Gregory. 
+*            Update tests org.junit.jupiter:junit-jupiter 5.5.2 -> 5.6.2. Thanks to Gary Gregory. 
+*            Update tests org.mockito:mockito-core 3.0.0 -> 3.3.3. Thanks to Gary Gregory. 
+* IO-666:  Normalize internal buffers to 8192 bytes. Thanks to Gary Gregory. 
+* IO-665:  Ensure that passing a null InputStream results in NPE with tests #112. Thanks to Otto Fowler, Gary Gregory. 
+*            commons.jacoco.version 0.8.4 -> 0.8.5. Thanks to Gary Gregory. 
+*            com.github.siom79.japicmp:japicmp-maven-plugin 0.14.1 -> 0.14.3. Thanks to Gary Gregory. 
+* IO-667:  Add functional interfaces IOFunction and IOSupplier #110. Thanks to Adam Retter, Gary Gregory. 
+*            Support sub sequences in CharSequenceReader #91. Thanks to Rob Spoor, Gary Gregory. 
+*            Remove deprecated sudo setting. #113. Thanks to dengliming. 
 
 Compatibility with 2.6:
 Binary compatible: Yes.
 Source compatible: Yes.
 Semantic compatible: Yes.
 
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: https://commons.apache.org/proper/commons-io/changes-report.html
 
@@ -814,11 +1310,12 @@ Download page: https://commons.apache.org/proper/commons-io/download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 2.6
 
-INTRODUCTION:
+Introduction
+------------
 
 Apache Commons IO is a package of Java utility classes like java.io.
 Classes in this package are considered to be so standard and of such high
@@ -829,7 +1326,6 @@ file filters, file comparators, endian transformation classes, and much more.
 
 Apache Commons IO 2.6 requires at least Java 7 to build and run.
 
-
 DEPRECATIONS
 ============
 
@@ -842,7 +1338,6 @@ Use equivalent methods in java.nio.file.FileStore instead, e.g.
 Files.getFileStore(Paths.get("/home")).getUsableSpace() or iterate over
 FileSystems.getDefault().getFileStores().
 
-
 COMPATIBILITY WITH JAVA 9
 ==================
 
@@ -860,68 +1355,67 @@ release. Please report any Java 9 related issues at:
 
     https://issues.apache.org/jira/browse/IO
 
-
 NEW FEATURES
 ============
 
-o IO-551: Add Automatic-Module-Name MANIFEST entry for Java 9 compatibility.
-o IO-367: Add convenience methods for copyToDirectory. Thanks to James Sawle.
-o IO-493: Add infinite circular input stream. Thanks to Piotr Turski.
-o IO-507: Add a ByteOrderUtils class.
-o IO-518: Add ObservableInputStream.
-o IO-519: Add MessageDigestCalculatingInputStream.
-o IO-513: Add convenience methods for reading class path resources.
+* IO-551: Add Automatic-Module-Name MANIFEST entry for Java 9 compatibility.
+* IO-367: Add convenience methods for copyToDirectory. Thanks to James Sawle.
+* IO-493: Add infinite circular input stream. Thanks to Piotr Turski.
+* IO-507: Add a ByteOrderUtils class.
+* IO-518: Add ObservableInputStream.
+* IO-519: Add MessageDigestCalculatingInputStream.
+* IO-513: Add convenience methods for reading class path resources.
           Thanks to Behrang Saeedzadeh.
 
 FIXED BUGS
 ==========
 
-o IO-546: ClosedOutputStream#flush should throw. Thanks to Tomas Celaya.
-o IO-550: Documentation issue, fix 404 Javadoc issues in the description page.
+* IO-546: ClosedOutputStream#flush should throw. Thanks to Tomas Celaya.
+* IO-550: Documentation issue, fix 404 Javadoc issues in the description page.
           Thanks to Jimi Adrian.
-o IO-442: Javadoc contradictory for FileFilterUtils.ageFileFilter(cutoff) and
+* IO-442: Javadoc contradictory for FileFilterUtils.ageFileFilter(cutoff) and
           the filter it constructs: AgeFileFilter(cutoff).
           Thanks to Simon Robinson.
-o IO-534: FileUtilTestCase.testForceDeleteDir() should not delete testDirectory
+* IO-534: FileUtilTestCase.testForceDeleteDir() should not delete testDirectory
           parent.
-o IO-528: Fix Tailer.run race condition runaway logging. Thanks to Dave Moten.
-o IO-483: getPrefixLength return -1 if Unix file contains colon.
+* IO-528: Fix Tailer.run race condition runaway logging. Thanks to Dave Moten.
+* IO-483: getPrefixLength return -1 if Unix file contains colon.
           Thanks to Marko Vasic.
-o IO-520: FileUtilsTestCase#testContentEqualsIgnoreEOL fails on Windows.
-o IO-516: .gitattributes not correctly applied. Thanks to Jason Pyeron.
-o IO-515: Allow Specifying Initial Buffer Size of DeferredFileOutputStream.
+* IO-520: FileUtilsTestCase#testContentEqualsIgnoreEOL fails on Windows.
+* IO-516: .gitattributes not correctly applied. Thanks to Jason Pyeron.
+* IO-515: Allow Specifying Initial Buffer Size of DeferredFileOutputStream.
           Thanks to Brett Lounsbury, Gary Gregory.
-o IO-512: ThresholdingOutputStream.thresholdReached() results in
+* IO-512: ThresholdingOutputStream.thresholdReached() results in
           FileNotFoundException. Thanks to Ralf Hauser.
-o IO-511: After a few unit tests, a few newly created directories not cleaned
+* IO-511: After a few unit tests, a few newly created directories not cleaned
           completely. Thanks to Ahmet Celik.
-o IO-502: Exceptions are suppressed incorrectly when copying files.
+* IO-502: Exceptions are suppressed incorrectly when copying files.
           Thanks to Christian Schulte.
-o IO-503: Update platform requirement to Java 7.
-o IO-537: BOMInputStream shouldn't sort array of BOMs in-place.
+* IO-503: Update platform requirement to Java 7.
+* IO-537: BOMInputStream shouldn't sort array of BOMs in-place.
           Thanks to Borys Zibrov.
 
 CHANGES
 =======
 
-o IO-553: Make code style of hasBOM() consistent with getBOMCharsetName().
+* IO-553: Make code style of hasBOM() consistent with getBOMCharsetName().
           Thanks to Michael Ernst.
-o IO-542: FileUtils#readFileToByteArray: optimize reading of files with known
+* IO-542: FileUtils#readFileToByteArray: optimize reading of files with known
           size. Thanks to Ilmars Poikans.
-o IO-547: Throw a IllegalArgumentException instead of NullPointerException in
+* IO-547: Throw a IllegalArgumentException instead of NullPointerException in
           FileSystemUtils.freeSpaceWindows(). Thanks to Nikhil Shinde,
           Michael Ernst, Gary Greory.
-o IO-506: Deprecate methods FileSystemUtils.freeSpaceKb().
+* IO-506: Deprecate methods FileSystemUtils.freeSpaceKb().
           Thanks to Christian Schulte.
-o IO-505: Make LineIterator implement Closeable to support try-with-resources
+* IO-505: Make LineIterator implement Closeable to support try-with-resources
           statements. Thanks to Christian Schulte.
-o IO-504: Deprecated of all IOUtils.closeQuietly() methods and use
+* IO-504: Deprecated of all IOUtils.closeQuietly() methods and use
           try-with-resources internally. Thanks to Christian Schulte.
 
 REMOVED
 =======
 
-o IO-514: Remove org.apache.commons.io.Java7Support.
+* IO-514: Remove org.apache.commons.io.Java7Support.
 
 COMPATIBILITY WITH OLDER VERSIONS
 =================================
@@ -938,108 +1432,111 @@ Source compatible: No, see the rare case in
 Semantic compatible: No, see the rare case in
   https://issues.apache.org/jira/browse/IO-318.
 
-Commons IO 2.6 requires Java 7 or later.
-Commons IO 2.5 requires Java 6 or later.
-Commons IO 2.4 requires Java 6 or later.
-Commons IO 2.3 requires Java 6 or later.
-Commons IO 2.2 requires Java 5 or later.
-Commons IO 1.4 requires Java 1.3 or later.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 2.5
 
 New features and bug fixes.
 
-Changes in this version include:
+New features
+------------
 
-New features:
-o IO-487:  Add ValidatingObjectInputStream for controlled deserialization 
-o IO-471:  Support for additional encodings in ReversedLinesFileReader Thanks to Leandro Reis. 
-o IO-425:  Setter method for threshold on ThresholdingOutputStream Thanks to Craig Swank. 
-o IO-406:  Introduce new class AppendableOutputStream Thanks to Niall Pemberton. 
-o IO-459:  Add WindowsLineEndingInputStream and UnixLineEndingInputStream. Thanks to Kristian Rosenvold. 
-o IO-457:  Add a BoundedReader, a wrapper that can be used to constrain access
+* IO-487:  Add ValidatingObjectInputStream for controlled deserialization 
+* IO-471:  Support for additional encodings in ReversedLinesFileReader Thanks to Leandro Reis. 
+* IO-425:  Setter method for threshold on ThresholdingOutputStream Thanks to Craig Swank. 
+* IO-406:  Introduce new class AppendableOutputStream Thanks to Niall Pemberton. 
+* IO-459:  Add WindowsLineEndingInputStream and UnixLineEndingInputStream. Thanks to Kristian Rosenvold. 
+* IO-457:  Add a BoundedReader, a wrapper that can be used to constrain access
         to an underlying stream when used with mark/reset -
         to avoid overflowing the mark limit of the underlying buffer. Thanks to Kristian Rosenvold. 
-o IO-426:  Add API IOUtils.closeQuietly(Closeable...) 
-o IO-410:  Readfully() That Returns A Byte Array Thanks to Beluga Behr. 
-o IO-395:  Overload IOUtils buffer methods to accept buffer size Thanks to Beluga Behr. 
-o IO-382:  Chunked IO for large arrays.
+* IO-426:  Add API IOUtils.closeQuietly(Closeable...) 
+* IO-410:  Readfully() That Returns A Byte Array Thanks to Beluga Behr. 
+* IO-395:  Overload IOUtils buffer methods to accept buffer size Thanks to Beluga Behr. 
+* IO-382:  Chunked IO for large arrays.
          Added writeChunked(byte[], OutputStream) and writeChunked(char[] Writer)
          Added ChunkedOutputStream, ChunkedWriter 
-o IO-233:  Add Methods for Buffering Streams/Writers To IOUtils
+* IO-233:  Add Methods for Buffering Streams/Writers To IOUtils
          Added overloaded buffer() methods - see also IO-330 
-o IO-330:  IOUtils#toBufferedOutputStream/toBufferedWriter to conditionally wrap the output
+* IO-330:  IOUtils#toBufferedOutputStream/toBufferedWriter to conditionally wrap the output
          Added overloaded buffer() methods - see also IO-233 
-o IO-381:  Add FileUtils.copyInputStreamToFile API with option to leave the source open.
+* IO-381:  Add FileUtils.copyInputStreamToFile API with option to leave the source open.
         See copyInputStreamToFile(final InputStream source, final File destination, boolean closeSource) 
-o IO-379:  CharSequenceInputStream - add tests for available()
+* IO-379:  CharSequenceInputStream - add tests for available()
          Fix code so it really does reflect a minimum available. 
-o IO-346:  Add ByteArrayOutputStream.toInputStream() 
-o IO-341:  A constant for holding the BOM character (U+FEFF) 
-o IO-361:  Add API FileUtils.forceMkdirsParent(). 
-o IO-360:  Add API Charsets.requiredCharsets(). 
-o IO-359:  Add IOUtils.skip and skipFully(ReadableByteChannel, long). Thanks to yukoba. 
-o IO-358:  Add IOUtils.read and readFully(ReadableByteChannel, ByteBuffer buffer). Thanks to yukoba. 
-o IO-353:  Add API IOUtils.copy(InputStream, OutputStream, int) Thanks to ggregory. 
-o IO-349:  Add API with array offset and length argument to FileUtils.writeByteArrayToFile. Thanks to scop. 
-o IO-348:  Missing information in IllegalArgumentException thrown by org.apache.commons.io.FileUtils#validateListFilesParameters. Thanks to plcstpierre. 
-o IO-345:  Supply a hook method allowing Tailer actively determining stop condition. Thanks to mkresse. 
-o IO-437:  Make IOUtils.EOF public and reuse it in various classes. 
-
-Fixed Bugs:
-o IO-446:  adds an endOfFileReached method to the TailerListener Thanks to Jeffrey Barrus. 
-o IO-484:  FilenameUtils should handle embedded null bytes Thanks to Philippe Arteau. 
-o IO-481:  Changed/Corrected algorithm for waitFor 
-o IO-428:  BOMInputStream.skip returns wrong count if stream contains no BOM Thanks to Stefan Gmeiner. 
-o IO-488:  FileUtils.waitFor(...) swallows thread interrupted status Thanks to Björn Buchner. 
-o IO-452:  Support for symlinks with missing target. Added support for JDK7 symlink features when present Thanks to David Standish. 
-o IO-453:  Regression in FileUtils.readFileToString from 2.0.1 Thanks to Steven Christou. 
-o IO-451:  ant test fails - resources missing from test classpath Thanks to David Standish. 
-o IO-435:  Document that FileUtils.deleteDirectory, directoryContains and cleanDirectory
+* IO-346:  Add ByteArrayOutputStream.toInputStream() 
+* IO-341:  A constant for holding the BOM character (U+FEFF) 
+* IO-361:  Add API FileUtils.forceMkdirsParent(). 
+* IO-360:  Add API Charsets.requiredCharsets(). 
+* IO-359:  Add IOUtils.skip and skipFully(ReadableByteChannel, long). Thanks to yukoba. 
+* IO-358:  Add IOUtils.read and readFully(ReadableByteChannel, ByteBuffer buffer). Thanks to yukoba. 
+* IO-353:  Add API IOUtils.copy(InputStream, OutputStream, int) Thanks to ggregory. 
+* IO-349:  Add API with array offset and length argument to FileUtils.writeByteArrayToFile. Thanks to scop. 
+* IO-348:  Missing information in IllegalArgumentException thrown by org.apache.commons.io.FileUtils#validateListFilesParameters. Thanks to plcstpierre. 
+* IO-345:  Supply a hook method allowing Tailer actively determining stop condition. Thanks to mkresse. 
+* IO-437:  Make IOUtils.EOF public and reuse it in various classes. 
+
+Fixed Bugs
+----------
+
+* IO-446:  adds an endOfFileReached method to the TailerListener Thanks to Jeffrey Barrus. 
+* IO-484:  FilenameUtils should handle embedded null bytes Thanks to Philippe Arteau. 
+* IO-481:  Changed/Corrected algorithm for waitFor 
+* IO-428:  BOMInputStream.skip returns wrong count if stream contains no BOM Thanks to Stefan Gmeiner. 
+* IO-488:  FileUtils.waitFor(...) swallows thread interrupted status Thanks to Björn Buchner. 
+* IO-452:  Support for symlinks with missing target. Added support for JDK7 symlink features when present Thanks to David Standish. 
+* IO-453:  Regression in FileUtils.readFileToString from 2.0.1 Thanks to Steven Christou. 
+* IO-451:  ant test fails - resources missing from test classpath Thanks to David Standish. 
+* IO-435:  Document that FileUtils.deleteDirectory, directoryContains and cleanDirectory
          may throw an IllegalArgumentException in case the passed directory does not
          exist or is not a directory. Thanks to Dominik Stadler. 
-o IO-424:  Javadoc fixes, mostly to appease 1.8.0 Thanks to Ville Skyttä. 
-o IO-389:  FileUtils.sizeOfDirectory can throw IllegalArgumentException Thanks to Austin Doupnik. 
-o IO-390:  FileUtils.sizeOfDirectoryAsBigInteger can overflow.
+* IO-424:  Javadoc fixes, mostly to appease 1.8.0 Thanks to Ville Skyttä. 
+* IO-389:  FileUtils.sizeOfDirectory can throw IllegalArgumentException Thanks to Austin Doupnik. 
+* IO-390:  FileUtils.sizeOfDirectoryAsBigInteger can overflow.
          Ensure that recursive calls all use BigInteger 
-o IO-385:  FileUtils.doCopyFile can potentially loop for ever
+* IO-385:  FileUtils.doCopyFile can potentially loop for ever
          Exit loop if no data to copy 
-o IO-383:  FileUtils.doCopyFile caches the file size; needs to be documented
+* IO-383:  FileUtils.doCopyFile caches the file size; needs to be documented
          Added Javadoc; show file lengths in exception message 
-o IO-380:  FileUtils.copyInputStreamToFile should document it closes the input source Thanks to claudio_ch. 
-o IO-279:  Tailer erroneously considers file as new.
+* IO-380:  FileUtils.copyInputStreamToFile should document it closes the input source Thanks to claudio_ch. 
+* IO-279:  Tailer erroneously considers file as new.
         Fix to use file.lastModified() rather than System.currentTimeMillis() 
-o IO-356:  CharSequenceInputStream#reset() behaves incorrectly in case when buffer size is not dividable by data size.
+* IO-356:  CharSequenceInputStream#reset() behaves incorrectly in case when buffer size is not dividable by data size.
          Fix code so skip relates to the encoded bytes; reset now re-encodes the data up to the point of the mark 
-o IO-368:  ClassLoaderObjectInputStream does not handle primitive typed members 
-o IO-314:  Deprecate all methods that use the default encoding 
-o IO-338:  When a file is rotated, finish reading previous file prior to starting new one 
-o IO-354:  Commons IO Tailer does not respect UTF-8 Charset. 
-o IO-323:  What should happen in FileUtils.sizeOf[Directory] when an overflow takes place?
+* IO-368:  ClassLoaderObjectInputStream does not handle primitive typed members 
+* IO-314:  Deprecate all methods that use the default encoding 
+* IO-338:  When a file is rotated, finish reading previous file prior to starting new one 
+* IO-354:  Commons IO Tailer does not respect UTF-8 Charset. 
+* IO-323:  What should happen in FileUtils.sizeOf[Directory] when an overflow takes place?
         Added Javadoc. 
-o IO-372:  FileUtils.moveDirectory can produce misleading error message on failure
-o IO-362:  IOUtils.contentEquals* methods returns false if input1 == input2, should return true. Thanks to mmadson, ggregory. 
-o IO-357:  [Tailer] InterruptedException while the thread is sleeping is silently ignored Thanks to mortenh. 
-o IO-352:  Spelling fixes. Thanks to scop. 
-o IO-436:  Improper Javadoc comment for FilenameUtils.indexOfExtension. Thanks to christoph.schneegans. 
-
-Changes:
-o IO-433:  Converted all testcases to JUnit 4 
-o IO-466:  Added testcase to show this was fixed with IO-423 
-o IO-479:  Correct exception message in FileUtils.getFile(File, String...) Thanks to Zhouce Chen. 
-o IO-465:  Update to JUnit 4.12 Thanks to based2. 
-o IO-462:  IOExceptionWithCause no longer needed 
-o IO-422:  Deprecate Charsets Charset constants in favor of Java 7's java.nio.charset.StandardCharsets 
-o IO-239:  Convert IOCase to a Java 1.5+ Enumeration
+* IO-372:  FileUtils.moveDirectory can produce misleading error message on failure
+* IO-362:  IOUtils.contentEquals* methods returns false if input1 == input2, should return true. Thanks to mmadson, ggregory. 
+* IO-357:  [Tailer] InterruptedException while the thread is sleeping is silently ignored Thanks to mortenh. 
+* IO-352:  Spelling fixes. Thanks to scop. 
+* IO-436:  Improper Javadoc comment for FilenameUtils.indexOfExtension. Thanks to christoph.schneegans. 
+
+Changes
+-------
+
+* IO-433:  Converted all testcases to JUnit 4 
+* IO-466:  Added testcase to show this was fixed with IO-423 
+* IO-479:  Correct exception message in FileUtils.getFile(File, String...) Thanks to Zhouce Chen. 
+* IO-465:  Update to JUnit 4.12 Thanks to based2. 
+* IO-462:  IOExceptionWithCause no longer needed 
+* IO-422:  Deprecate Charsets Charset constants in favor of Java 7's java.nio.charset.StandardCharsets 
+* IO-239:  Convert IOCase to a Java 1.5+ Enumeration
          [N.B. this is binary compatible] 
-o IO-328:  getPrefixLength returns null if filename has leading slashes
+* IO-328:  getPrefixLength returns null if filename has leading slashes
         Javadoc: add examples to show correct behavior; add unit tests 
-o IO-299:  FileUtils.listFilesAndDirs includes original dir in results even when it doesn't match filter
+* IO-299:  FileUtils.listFilesAndDirs includes original dir in results even when it doesn't match filter
         Javadoc: clarify that original dir is included in the results 
-o IO-375:  FilenameUtils.splitOnTokens(String text) check for '**' could be simplified 
-o IO-374:  WildcardFileFilter ctors should not use null to mean IOCase.SENSITIVE when delegating to other ctors 
+* IO-375:  FilenameUtils.splitOnTokens(String text) check for '**' could be simplified 
+* IO-374:  WildcardFileFilter ctors should not use null to mean IOCase.SENSITIVE when delegating to other ctors 
 
 Compatibility with 2.4:
 Binary compatible: Yes.
@@ -1051,49 +1548,50 @@ Binary compatible: Yes.
 Source compatible: No, see the rare case in https://issues.apache.org/jira/browse/IO-318.
 Semantic compatible: No, see the rare case in https://issues.apache.org/jira/browse/IO-318.
 
-Commons IO 2.5 requires Java 6 or later.
-Commons IO 2.4 requires Java 6 or later.
-Commons IO 2.3 requires Java 6 or later.
-Commons IO 2.2 requires Java 5 or later.
-Commons IO 1.4 requires Java 1.3 or later.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 2.4
 
-Changes in this version include:
+New features
+------------
 
-New features:
-o IO-269:  Tailer locks file from deletion/rename on Windows. Thanks to
+* IO-269:  Tailer locks file from deletion/rename on Windows. Thanks to
 sebb.
-o IO-333:  Export OSGi packages at version 1.x in addition to 2.x. Thanks
+* IO-333:  Export OSGi packages at version 1.x in addition to 2.x. Thanks
 to fmeschbe.
-o IO-320:  Add XmlStreamReader support for UTF-32. Thanks to ggregory.
-o IO-331:  BOMInputStream wrongly detects UTF-32LE_BOM files as
+* IO-320:  Add XmlStreamReader support for UTF-32. Thanks to ggregory.
+* IO-331:  BOMInputStream wrongly detects UTF-32LE_BOM files as
 UTF-16LE_BOM files in method getBOM(). Thanks to ggregory.
-o IO-327:  Add byteCountToDisplaySize(BigInteger). Thanks to ggregory.
-o IO-326:  Add new FileUtils.sizeOf[Directory] APIs to return BigInteger.
+* IO-327:  Add byteCountToDisplaySize(BigInteger). Thanks to ggregory.
+* IO-326:  Add new FileUtils.sizeOf[Directory] APIs to return BigInteger.
 Thanks to ggregory.
-o IO-325:  Add IOUtils.toByteArray methods to work with URL and URI. Thanks
+* IO-325:  Add IOUtils.toByteArray methods to work with URL and URI. Thanks
 to raviprak.
-o IO-324:  Add missing Charset sister APIs to method that take a String
+* IO-324:  Add missing Charset sister APIs to method that take a String
 charset name. Thanks to raviprak.
 
-Fixed Bugs:
-o IO-336:  Yottabyte (YB) incorrectly defined in FileUtils. Thanks to
+Fixed Bugs
+----------
+
+* IO-336:  Yottabyte (YB) incorrectly defined in FileUtils. Thanks to
 rleavelle.
-o IO-279:  Tailer erroneously considers file as new. Thanks to Sergio
+* IO-279:  Tailer erroneously considers file as new. Thanks to Sergio
 Bossa, Chris Baron.
-o IO-335:  Tailer#readLines - incorrect CR handling.
-o IO-334:  FileUtils.toURLs throws NPE for null parameter; document the
+* IO-335:  Tailer#readLines - incorrect CR handling.
+* IO-334:  FileUtils.toURLs throws NPE for null parameter; document the
 behavior.
-o IO-332:  Improve tailer's reading performance. Thanks to liangly.
-o IO-279:  Improve Tailer performance with buffered reads (see IO-332).
-o IO-329:  FileUtils.writeLines uses unbuffered IO. Thanks to tivv.
-o IO-319:  FileUtils.sizeOfDirectory follows symbolic links. Thanks to
+* IO-332:  Improve tailer's reading performance. Thanks to liangly.
+* IO-279:  Improve Tailer performance with buffered reads (see IO-332).
+* IO-329:  FileUtils.writeLines uses unbuffered IO. Thanks to tivv.
+* IO-319:  FileUtils.sizeOfDirectory follows symbolic links. Thanks to
 raviprak.
 
-
 Compatibility with 2.3:
 Binary compatible: Yes.
 Source compatible: Yes.
@@ -1104,104 +1602,120 @@ Binary compatible: Yes.
 Source compatible: No, see the rare case in https://issues.apache.org/jira/browse/IO-318.
 Semantic compatible: No, see the rare case in https://issues.apache.org/jira/browse/IO-318.
 
-Commons IO 2.4 requires Java 6 or later.
-Commons IO 2.3 requires Java 6 or later.
-Commons IO 2.2 requires Java 5 or later.
-Commons IO 1.4 requires Java 1.3 or later.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 2.3
 
-Changes in this version include:
+New features
+------------
 
-New features:
-o IO-322:  Add and use class Charsets. Thanks to ggregory. 
-o IO-321:  ByteOrderMark UTF_32LE is incorrect. Thanks to ggregory. 
-o IO-318:  Add Charset sister APIs to method that take a String charset name. Thanks to ggregory. 
+* IO-322:  Add and use class Charsets. Thanks to ggregory. 
+* IO-321:  ByteOrderMark UTF_32LE is incorrect. Thanks to ggregory. 
+* IO-318:  Add Charset sister APIs to method that take a String charset name. Thanks to ggregory. 
 
 Compatibility with 2.2 and 1.4:
 Binary compatible: Yes.
 Source compatible: No, see the rare case in https://issues.apache.org/jira/browse/IO-318.
 Semantic compatible: No, see the rare case in https://issues.apache.org/jira/browse/IO-318.
 
-Commons IO 2.3 requires Java 6 or later.
-Commons IO 2.2 requires Java 5 or later.
-Commons IO 1.4 requires Java 1.3 or later.
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 2.2
 
-Changes in this version include:
-
-New features:
-o Add IOUtils.toBufferedReader(Reader)  Issue: IO-313. Thanks to ggregory.
-o Allow applications to provide buffer (or size) for copyLarge methods.  Issue: IO-308. Thanks to Manoj Mokashi. 
-o New copyLarge() method in IOUtils that takes additional offset, length arguments  Issue: IO-305. Thanks to Manoj Mokashi. 
-o Use terabyte (TB), petabyte (PB) and exabyte (EB) in FileUtils.byteCountToDisplaySize(long size)  Issue: IO-287. Thanks to Ron Kuris, Gary Gregory. 
-o FileUtils.listFiles() doesn't return directories  Issue: IO-173. Thanks to Marcos Vinícius da Silva. 
-o CharSequenceInputStream to efficiently stream content of a CharSequence  Issue: IO-297. Thanks to Oleg Kalnichevski. 
-o The second constructor of Tailer class does not pass 'delay' to the third one  Issue: IO-304. Thanks to liangly. 
-o TeeOutputStream does not call branch.close() when main.close() throws an exception  Issue: IO-303. Thanks to fabian.barney. 
-o ArrayIndexOutOfBoundsException in BOMInputStream when reading a file without BOM multiple times  Issue: IO-302. Thanks to jsteuerwald, detinho. 
-o Add IOUtils.closeQuietly(Selector) necessary  Issue: IO-301. Thanks to kaykay.unique. 
-o IOUtils.closeQuietly() should take a ServerSocket as a parameter  Issue: IO-292. Thanks to sebb. 
-o Add read/readFully methods to IOUtils  Issue: IO-290. Thanks to sebb. 
-o Supply a ReversedLinesFileReader  Issue: IO-288. Thanks to Georg Henzler. 
-o Add new function FileUtils.directoryContains.  Issue: IO-291. Thanks to ggregory. 
-o FileUtils.contentEquals and IOUtils.contentEquals - Add option to ignore "line endings"
+New features
+------------
+
+* Add IOUtils.toBufferedReader(Reader)  Issue: IO-313. Thanks to ggregory.
+* Allow applications to provide buffer (or size) for copyLarge methods.  Issue: IO-308. Thanks to Manoj Mokashi. 
+* New copyLarge() method in IOUtils that takes additional offset, length arguments  Issue: IO-305. Thanks to Manoj Mokashi. 
+* Use terabyte (TB), petabyte (PB) and exabyte (EB) in FileUtils.byteCountToDisplaySize(long size)  Issue: IO-287. Thanks to Ron Kuris, Gary Gregory. 
+* FileUtils.listFiles() doesn't return directories  Issue: IO-173. Thanks to Marcos Vinícius da Silva. 
+* CharSequenceInputStream to efficiently stream content of a CharSequence  Issue: IO-297. Thanks to Oleg Kalnichevski. 
+* The second constructor of Tailer class does not pass 'delay' to the third one  Issue: IO-304. Thanks to liangly. 
+* TeeOutputStream does not call branch.close() when main.close() throws an exception  Issue: IO-303. Thanks to fabian.barney. 
+* ArrayIndexOutOfBoundsException in BOMInputStream when reading a file without BOM multiple times  Issue: IO-302. Thanks to jsteuerwald, detinho. 
+* Add IOUtils.closeQuietly(Selector) necessary  Issue: IO-301. Thanks to kaykay.unique. 
+* IOUtils.closeQuietly() should take a ServerSocket as a parameter  Issue: IO-292. Thanks to sebb. 
+* Add read/readFully methods to IOUtils  Issue: IO-290. Thanks to sebb. 
+* Supply a ReversedLinesFileReader  Issue: IO-288. Thanks to Georg Henzler. 
+* Add new function FileUtils.directoryContains.  Issue: IO-291. Thanks to ggregory. 
+* FileUtils.contentEquals and IOUtils.contentEquals - Add option to ignore "line endings"
         Added contentEqualsIgnoreEOL methods to both classes  Issue: IO-275. Thanks to CJ Aspromgos. 
 
-Fixed Bugs:
-o IOUtils.read(InputStream/Reader) ignores the offset parameter  Issue: IO-311. Thanks to Robert Muir. 
-o CharSequenceInputStream(CharSequence s, Charset charset, int bufferSize) ignores bufferSize  Issue: IO-312. 
-o FileUtils.moveDirectoryToDirectory removes source directory if destination is a subdirectory  Issue: IO-300. 
-o ReaderInputStream#read(byte[] b, int off, int len) should check for valid parameters  Issue: IO-307. 
-o ReaderInputStream#read(byte[] b, int off, int len) should always return 0 for length == 0  Issue: IO-306. 
-o "FileUtils#deleteDirectoryOnExit(File)" does not work  Issue: IO-276. Thanks to nkami. 
-o BoundedInputStream.read() treats max differently from BoundedInputStream.read(byte[]...)  Issue: IO-273. Thanks to sebb. 
-o Various methods of class 'org.apache.commons.io.FileUtils' incorrectly suppress 'java.io.IOException'  Issue: IO-298. Thanks to Christian Schulte. 
+Fixed Bugs
+----------
 
-Changes:
-o ReaderInputStream optimization: more efficient reading of small chunks of data  Issue: IO-296. Thanks to Oleg Kalnichevski. 
+* IOUtils.read(InputStream/Reader) ignores the offset parameter  Issue: IO-311. Thanks to Robert Muir. 
+* CharSequenceInputStream(CharSequence s, Charset charset, int bufferSize) ignores bufferSize  Issue: IO-312. 
+* FileUtils.moveDirectoryToDirectory removes source directory if destination is a subdirectory  Issue: IO-300. 
+* ReaderInputStream#read(byte[] b, int off, int len) should check for valid parameters  Issue: IO-307. 
+* ReaderInputStream#read(byte[] b, int off, int len) should always return 0 for length == 0  Issue: IO-306. 
+* "FileUtils#deleteDirectoryOnExit(File)" does not work  Issue: IO-276. Thanks to nkami. 
+* BoundedInputStream.read() treats max differently from BoundedInputStream.read(byte[]...)  Issue: IO-273. Thanks to sebb. 
+* Various methods of class 'org.apache.commons.io.FileUtils' incorrectly suppress 'java.io.IOException'  Issue: IO-298. Thanks to Christian Schulte. 
 
+Changes
+-------
+
+* ReaderInputStream optimization: more efficient reading of small chunks of data  Issue: IO-296. Thanks to Oleg Kalnichevski. 
 
 Compatibility with 2.1 and 1.4:
 Binary compatible: Yes
 Source compatible: Yes
 Semantic compatible: Yes. Check the bug fixes section for semantic bug fixes
 
-Commons IO 2.2 requires a minimum of Java 5. 
-Commons IO 1.4 requires a minimum of Java 1.3. 
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 2.1
 
-New features:
-o Use standard Maven directory layout  Issue: IO-285. Thanks to ggregory. 
-o Add IOUtils API toString for URL and URI to get contents  Issue: IO-284. Thanks to ggregory. 
-o Add API FileUtils.copyFile(File input, OutputStream output)  Issue: IO-282. Thanks to ggregory. 
-o FileAlterationObserver has no getter for FileFilter  Issue: IO-262. 
-o Add FileUtils.getFile API with varargs parameter  Issue: IO-261. 
-o Add new APPEND parameter for writing string into files  Issue: IO-182. 
-o Add new read method "toByteArray" to handle InputStream with known size.  Issue: IO-251. Thanks to Marco Albini. 
-
-Fixed Bugs:
-o Dubious use of mkdirs() return code  Issue: IO-280. Thanks to sebb. 
-o ReaderInputStream enters infinite loop when it encounters an unmappable character  Issue: IO-277. 
-o FileUtils.moveFile() Javadoc should specify FileExistsException thrown  Issue: IO-264. 
-o ClassLoaderObjectInputStream does not handle Proxy classes  Issue: IO-260. 
-o Tailer returning partial lines when reaching EOF before EOL  Issue: IO-274. Thanks to Frank Grimes. 
-o FileUtils.copyFile() throws IOException when copying large files to a shared directory (on Windows)  Issue: IO-266. Thanks to Igor Smereka. 
-o FileSystemUtils.freeSpaceKb throws exception for Windows volumes with no visible files.
+New features
+------------
+
+* Use standard Maven directory layout  Issue: IO-285. Thanks to ggregory. 
+* Add IOUtils API toString for URL and URI to get contents  Issue: IO-284. Thanks to ggregory. 
+* Add API FileUtils.copyFile(File input, OutputStream output)  Issue: IO-282. Thanks to ggregory. 
+* FileAlterationObserver has no getter for FileFilter  Issue: IO-262. 
+* Add FileUtils.getFile API with varargs parameter  Issue: IO-261. 
+* Add new APPEND parameter for writing string into files  Issue: IO-182. 
+* Add new read method "toByteArray" to handle InputStream with known size.  Issue: IO-251. Thanks to Marco Albini. 
+
+Fixed Bugs
+----------
+
+* Dubious use of mkdirs() return code  Issue: IO-280. Thanks to sebb. 
+* ReaderInputStream enters infinite loop when it encounters an unmappable character  Issue: IO-277. 
+* FileUtils.moveFile() Javadoc should specify FileExistsException thrown  Issue: IO-264. 
+* ClassLoaderObjectInputStream does not handle Proxy classes  Issue: IO-260. 
+* Tailer returning partial lines when reaching EOF before EOL  Issue: IO-274. Thanks to Frank Grimes. 
+* FileUtils.copyFile() throws IOException when copying large files to a shared directory (on Windows)  Issue: IO-266. Thanks to Igor Smereka. 
+* FileSystemUtils.freeSpaceKb throws exception for Windows volumes with no visible files.
         Improve coverage by also looking for hidden files.  Issue: IO-263. Thanks to Gil Adam. 
 
-Changes:
-o FileAlterationMonitor.stop(boolean allowIntervalToFinish)  Issue: IO-259. 
+Changes
+-------
+
+* FileAlterationMonitor.stop(boolean allowIntervalToFinish)  Issue: IO-259. 
 
-==============================================================================
+------------------------------------------------------------------------------
+------------------------------------------------------------------------------
 
 Apache Commons IO Package 2.0.1
 
@@ -1214,8 +1728,8 @@ Source compatible - Yes
 Semantic compatible - Yes
   Check the bug fixes section for semantic bug fixes
 
-Commons IO 2.0.1 requires a minimum of Java 5
- (Commons IO 1.4 had a minimum of Java 1.3) 
+Commons IO 2.0.1 requires Java 5 or above
+ (Commons IO 1.4 requires Java 1.3 or above) 
 
 Enhancements from 2.0
 ---------------------
@@ -1228,7 +1742,7 @@ Bug fixes from 2.0
    * [IO-257] - BOMInputStream.read(byte[]) can return 0 which it should not
    * [IO-258] - XmlStreamReader consumes the stream during encoding detection
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Package 2.0
 
@@ -1241,8 +1755,8 @@ Source compatible - Yes
 Semantic compatible - Yes
   Check the bug fixes section for semantic bug fixes
 
-Commons IO 2.0 requires a minimum of Java 5
- (Commons IO 1.4 had a minimum of Java 1.3) 
+Commons IO 2.0 requires Java 5 or abobe
+ (Commons IO 1.4 requires Java 1.3 or above) 
 
 Deprecations from 1.4
 ---------------------
@@ -1343,7 +1857,7 @@ Documentation changes from 1.4
   * [IO-206 ProxyInputStream - fix misleading parameter names
   * [IO-212 ProxyInputStream.skip() documentation corrections
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 1.4
 
@@ -1444,7 +1958,7 @@ Enhancements from 1.3.2
   - PathFileComparator - compares files using file paths.
   - SizeFileComparator - compares files using file sizes.
   
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 1.3.2
 
@@ -1489,7 +2003,7 @@ Bug fixes from 1.3
   - NPE in openOutputStream(File) when file has no parent in path [IO-112]
   - readFileToString(File) is not static [IO-113]
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 1.3.1
 
@@ -1510,7 +2024,7 @@ Bug fixes from 1.3
   - NPE in openOutputStream(File) when file has no parent in path [IO-112]
   - readFileToString(File) is not static [IO-113]
   
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 1.3
 
@@ -1697,7 +2211,7 @@ Enhancements from 1.2
 - ByteArrayOutputStream  [IO-97]
   - Performance enhancements
 
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 1.2
 
@@ -1745,7 +2259,7 @@ Enhancements from 1.1
 - FileUtils.copyDirectoryToDirectory
   New method to copy a directory to within another directory [36315]
   
-==============================================================================
+------------------------------------------------------------------------------
 
 Apache Commons IO Version 1.1
 
@@ -1911,9 +2425,9 @@ Enhancements from 1.0
 - IOUtils and EndianUtils are no longer final  [28978]
     Allows developers to have subclasses if desired   
 
-==============================================================================
+------------------------------------------------------------------------------
 Feedback
-==============================================================================
+------------------------------------------------------------------------------
 
 Open source works best when you give feedback:
 https://commons.apache.org/io/
diff --git a/pom.xml b/pom.xml
index bad8c9ba..10a79772 100644
--- a/pom.xml
+++ b/pom.xml
@@ -19,12 +19,12 @@
   <parent>
     <groupId>org.apache.commons</groupId>
     <artifactId>commons-parent</artifactId>
-    <version>64</version>
+    <version>78</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <groupId>commons-io</groupId>
   <artifactId>commons-io</artifactId>
-  <version>2.15.0</version>
+  <version>2.18.0</version>
   <name>Apache Commons IO</name>
 
   <inceptionYear>2002</inceptionYear>
@@ -52,198 +52,9 @@ file comparators, endian transformation classes, and much more.
     <connection>scm:git:https://gitbox.apache.org/repos/asf/commons-io.git</connection>
     <developerConnection>scm:git:https://gitbox.apache.org/repos/asf/commons-io.git</developerConnection>
     <url>https://gitbox.apache.org/repos/asf?p=commons-io.git</url>
-    <tag>rel/commons-io-2.15.0</tag>
+    <tag>rel/commons-io-2.17.0</tag>
   </scm>
 
-  <developers>
-    <developer>
-      <name>Scott Sanders</name>
-      <id>sanders</id>
-      <email>sanders@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>dIon Gillard</name>
-      <!-- Note: first name is correctly capitalised above -->
-      <id>dion</id>
-      <email>dion@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Nicola Ken Barozzi</name>
-      <id>nicolaken</id>
-      <email>nicolaken@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Henri Yandell</name>
-      <id>bayard</id>
-      <email>bayard@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Stephen Colebourne</name>
-      <id>scolebourne</id>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-      <timezone>0</timezone>
-    </developer>
-    <developer>
-      <name>Jeremias Maerki</name>
-      <id>jeremias</id>
-      <email>jeremias@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-      <timezone>+1</timezone>
-    </developer>
-    <developer>
-      <name>Matthew Hawthorne</name>
-      <id>matth</id>
-      <email>matth@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Martin Cooper</name>
-      <id>martinc</id>
-      <email>martinc@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Rob Oxspring</name>
-      <id>roxspring</id>
-      <email>roxspring@apache.org</email>
-      <organization />
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Jochen Wiedmann</name>
-      <id>jochen</id>
-      <email>jochen.wiedmann@gmail.com</email>
-    </developer>
-    <developer>
-      <name>Niall Pemberton</name>
-      <id>niallp</id>
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <name>Jukka Zitting</name>
-      <id>jukka</id>
-      <roles>
-        <role>Java Developer</role>
-      </roles>
-    </developer>
-    <developer>
-      <id>ggregory</id>
-      <name>Gary Gregory</name>
-      <email>ggregory at apache.org</email>
-      <url>https://www.garygregory.com</url>
-      <organization>The Apache Software Foundation</organization>
-      <organizationUrl>https://www.apache.org/</organizationUrl>      
-      <roles>
-        <role>PMC Member</role>
-      </roles>
-      <timezone>America/New_York</timezone>
-      <properties>
-        <picUrl>https://people.apache.org/~ggregory/img/garydgregory80.png</picUrl>
-      </properties>
-    </developer>
-    <developer>
-      <name>Kristian Rosenvold</name>
-      <id>krosenvold</id>
-      <email>krosenvold@apache.org</email>
-      <timezone>+1</timezone>
-    </developer>
-  </developers>
-
-  <contributors>
-    <contributor>
-      <name>Rahul Akolkar</name>
-    </contributor>
-    <contributor>
-      <name>Jason Anderson</name>
-    </contributor>
-    <contributor>
-      <name>Nathan Beyer</name>
-    </contributor>
-    <contributor>
-      <name>Emmanuel Bourg</name>
-    </contributor>
-    <contributor>
-      <name>Chris Eldredge</name>
-    </contributor>
-    <contributor>
-      <name>Magnus Grimsell</name>
-    </contributor>
-    <contributor>
-      <name>Jim Harrington</name>
-    </contributor>
-    <contributor>
-      <name>Thomas Ledoux</name>
-    </contributor>
-    <contributor>
-      <name>Andy Lehane</name>
-    </contributor>
-    <contributor>
-      <name>Marcelo Liberato</name>
-    </contributor>
-    <contributor>
-      <name>Alban Peignier</name>
-      <email>alban.peignier at free.fr</email>
-    </contributor>
-    <contributor>
-      <name>Adam Retter</name>
-      <organization>Evolved Binary</organization>
-    </contributor>
-    <contributor>
-      <name>Ian Springer</name>
-    </contributor>
-    <contributor>
-      <name>Dominik Stadler</name>
-    </contributor>
-    <contributor>
-      <name>Masato Tezuka</name>
-    </contributor>
-    <contributor>
-      <name>James Urie</name>
-    </contributor>
-    <contributor>
-      <name>Frank W. Zammetti</name>
-    </contributor>
-    <contributor>
-      <name>Martin Grigorov</name>
-      <email>mgrigorov@apache.org</email>
-    </contributor>
-    <contributor>
-      <name>Arturo Bernal</name>
-    </contributor>
-  </contributors>
-
   <dependencies>
     <dependency>
       <groupId>org.junit.jupiter</groupId>
@@ -285,13 +96,13 @@ file comparators, endian transformation classes, and much more.
     <dependency>
       <groupId>org.apache.commons</groupId>
       <artifactId>commons-lang3</artifactId>
-      <version>3.13.0</version>
+      <version>3.17.0</version>
       <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>commons-codec</groupId>
       <artifactId>commons-codec</artifactId>
-      <version>1.16.0</version>
+      <version>1.17.1</version>
       <scope>test</scope>
     </dependency>
     <dependency>
@@ -314,9 +125,10 @@ file comparators, endian transformation classes, and much more.
     <commons.componentid>io</commons.componentid>
     <commons.module.name>org.apache.commons.io</commons.module.name>
     <commons.rc.version>RC1</commons.rc.version>
-    <commons.bc.version>2.14.0</commons.bc.version>
-    <commons.release.version>2.15.0</commons.release.version>
-    <commons.release.next>2.15.1</commons.release.next>
+    <commons.bc.version>2.17.0</commons.bc.version>
+    <commons.release.version>2.18.0</commons.release.version>
+    <commons.release.next>2.18.1</commons.release.next>
+    <project.build.outputTimestamp>2024-11-16T14:47:38Z</project.build.outputTimestamp>
     <commons.release.desc>(requires Java 8)</commons.release.desc>
     <commons.jira.id>IO</commons.jira.id>
     <commons.jira.pid>12310477</commons.jira.pid>
@@ -343,24 +155,28 @@ file comparators, endian transformation classes, and much more.
     </commons.osgi.import>
     <commons.scmPubUrl>https://svn.apache.org/repos/infra/websites/production/commons/content/proper/commons-io/</commons.scmPubUrl>
     <commons.scmPubCheckoutDirectory>site-content</commons.scmPubCheckoutDirectory>
-    <commons.javadoc.java.link>${commons.javadoc8.java.link}</commons.javadoc.java.link>
-    <commons.moditect.version>1.0.0.Final</commons.moditect.version>
     <jmh.version>1.37</jmh.version>
-    <commons.bytebuddy.version>1.14.9</commons.bytebuddy.version>
+    <commons.bytebuddy.version>1.15.10</commons.bytebuddy.version>
     <japicmp.skip>false</japicmp.skip>
-    <jacoco.skip>${env.JACOCO_SKIP}</jacoco.skip>
     <commons.release.isDistModule>true</commons.release.isDistModule>
+    <!-- JaCoCo: Don't make code coverage worse than: -->
+    <jacoco.skip>${env.JACOCO_SKIP}</jacoco.skip>
+    <commons.jacoco.haltOnFailure>true</commons.jacoco.haltOnFailure>
+    <commons.jacoco.classRatio>0.98</commons.jacoco.classRatio>
+    <commons.jacoco.instructionRatio>0.90</commons.jacoco.instructionRatio>
+    <commons.jacoco.methodRatio>0.90</commons.jacoco.methodRatio>
+    <commons.jacoco.branchRatio>0.85</commons.jacoco.branchRatio>
+    <commons.jacoco.lineRatio>0.90</commons.jacoco.lineRatio>
+    <commons.jacoco.complexityRatio>0.85</commons.jacoco.complexityRatio>
   </properties>
-
   <build>
     <!-- japicmp:cmp needs package to work from a jar -->
-    <defaultGoal>clean verify apache-rat:check japicmp:cmp checkstyle:check pmd:check javadoc:javadoc</defaultGoal>
+    <defaultGoal>clean verify apache-rat:check japicmp:cmp checkstyle:check spotbugs:check pmd:check javadoc:javadoc</defaultGoal>
     <pluginManagement>
       <plugins>
         <plugin>
           <groupId>org.apache.rat</groupId>
           <artifactId>apache-rat-plugin</artifactId>
-          <version>0.15</version>
           <configuration>
             <excludes>
               <exclude>src/test/resources/**/*.bin</exclude>
@@ -457,14 +273,6 @@ file comparators, endian transformation classes, and much more.
       <plugin>
         <groupId>com.github.siom79.japicmp</groupId>
         <artifactId>japicmp-maven-plugin</artifactId>
-        <configuration>
-          <parameter>
-			 <excludes>
-               <!-- False positive: https://github.com/siom79/japicmp/issues/365 -->
-               <exclude>org.apache.commons.io.StreamIterator</exclude>
-             </excludes>
-          </parameter>
-        </configuration>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
@@ -531,11 +339,9 @@ file comparators, endian transformation classes, and much more.
                     <exec executable="svn">
                       <arg line="checkout --depth immediates ${commons.scmPubUrl} ${commons.scmPubCheckoutDirectory}" />
                     </exec>
-
                     <exec executable="svn">
                       <arg line="update --set-depth exclude ${commons.scmPubCheckoutDirectory}/javadocs" />
                     </exec>
-
                     <pathconvert pathsep=" " property="dirs">
                       <dirset dir="${commons.scmPubCheckoutDirectory}" includes="*" />
                     </pathconvert>
@@ -556,49 +362,9 @@ file comparators, endian transformation classes, and much more.
         <jdk>[9,)</jdk>
       </activation>
       <properties>
-        <!-- coverall version 4.3.0 does not work with java 9, see https://github.com/trautonen/coveralls-maven-plugin/issues/112 -->
-        <coveralls.skip>true</coveralls.skip>
         <maven.compiler.release>8</maven.compiler.release>
       </properties>
     </profile>
-    <profile>
-      <id>java9-moditect</id>
-      <activation>
-        <!-- 
-        Fails on Java 11 and Windows:
-        Error:  Failed to execute goal org.moditect:moditect-maven-plugin:1.0.0.RC2:add-module-info (add-module-infos) on project commons-io: Execution add-module-infos of goal org.moditect:moditect-maven-plugin:1.0.0.RC2:add-module-info failed: Couldn't add module-info.class to JAR: D:\a\commons-io\commons-io\target\commons-io-2.12.0-SNAPSHOT.jar: The process cannot access the file because it is being used by another process. -> [Help 1]
-        -->
-        <jdk>[9,11)</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.moditect</groupId>
-            <artifactId>moditect-maven-plugin</artifactId>
-            <version>${commons.moditect.version}</version>
-            <executions>
-              <execution>
-                <id>add-module-infos</id>
-                <phase>package</phase>
-                <goals>
-                  <goal>add-module-info</goal>
-                </goals>
-                <configuration>
-                  <jvmVersion>9</jvmVersion>
-                  <outputDirectory>${project.build.directory}</outputDirectory>
-                  <overwriteExistingFiles>true</overwriteExistingFiles>
-                  <module>
-                    <moduleInfo>
-                      <name>org.apache.commons.io</name>
-                    </moduleInfo>
-                  </module>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
     <profile>
       <id>benchmark</id>
       <properties>
@@ -610,7 +376,6 @@ file comparators, endian transformation classes, and much more.
           <plugin>
             <groupId>org.codehaus.mojo</groupId>
             <artifactId>exec-maven-plugin</artifactId>
-            <version>3.1.0</version>
             <executions>
               <execution>
                 <id>benchmark</id>
@@ -639,4 +404,197 @@ file comparators, endian transformation classes, and much more.
       </build>
     </profile>
   </profiles>
+
+  <developers>
+    <developer>
+      <name>Scott Sanders</name>
+      <id>sanders</id>
+      <email>sanders@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>dIon Gillard</name>
+      <!-- Note: first name is correctly capitalised above -->
+      <id>dion</id>
+      <email>dion@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Nicola Ken Barozzi</name>
+      <id>nicolaken</id>
+      <email>nicolaken@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Henri Yandell</name>
+      <id>bayard</id>
+      <email>bayard@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Stephen Colebourne</name>
+      <id>scolebourne</id>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+      <timezone>0</timezone>
+    </developer>
+    <developer>
+      <name>Jeremias Maerki</name>
+      <id>jeremias</id>
+      <email>jeremias@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+      <timezone>+1</timezone>
+    </developer>
+    <developer>
+      <name>Matthew Hawthorne</name>
+      <id>matth</id>
+      <email>matth@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Martin Cooper</name>
+      <id>martinc</id>
+      <email>martinc@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Rob Oxspring</name>
+      <id>roxspring</id>
+      <email>roxspring@apache.org</email>
+      <organization />
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Jochen Wiedmann</name>
+      <id>jochen</id>
+      <email>jochen.wiedmann@gmail.com</email>
+    </developer>
+    <developer>
+      <name>Niall Pemberton</name>
+      <id>niallp</id>
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <name>Jukka Zitting</name>
+      <id>jukka</id>
+      <roles>
+        <role>Java Developer</role>
+      </roles>
+    </developer>
+    <developer>
+      <id>ggregory</id>
+      <name>Gary Gregory</name>
+      <email>ggregory at apache.org</email>
+      <url>https://www.garygregory.com</url>
+      <organization>The Apache Software Foundation</organization>
+      <organizationUrl>https://www.apache.org/</organizationUrl>      
+      <roles>
+        <role>PMC Member</role>
+      </roles>
+      <timezone>America/New_York</timezone>
+      <properties>
+        <picUrl>https://people.apache.org/~ggregory/img/garydgregory80.png</picUrl>
+      </properties>
+    </developer>
+    <developer>
+      <name>Kristian Rosenvold</name>
+      <id>krosenvold</id>
+      <email>krosenvold@apache.org</email>
+      <timezone>+1</timezone>
+    </developer>
+  </developers>
+
+  <contributors>
+    <contributor>
+      <name>Rahul Akolkar</name>
+    </contributor>
+    <contributor>
+      <name>Jason Anderson</name>
+    </contributor>
+    <contributor>
+      <name>Nathan Beyer</name>
+    </contributor>
+    <contributor>
+      <name>Emmanuel Bourg</name>
+    </contributor>
+    <contributor>
+      <name>Chris Eldredge</name>
+    </contributor>
+    <contributor>
+      <name>Magnus Grimsell</name>
+    </contributor>
+    <contributor>
+      <name>Jim Harrington</name>
+    </contributor>
+    <contributor>
+      <name>Thomas Ledoux</name>
+    </contributor>
+    <contributor>
+      <name>Andy Lehane</name>
+    </contributor>
+    <contributor>
+      <name>Marcelo Liberato</name>
+    </contributor>
+    <contributor>
+      <name>Alban Peignier</name>
+      <email>alban.peignier at free.fr</email>
+    </contributor>
+    <contributor>
+      <name>Adam Retter</name>
+      <organization>Evolved Binary</organization>
+    </contributor>
+    <contributor>
+      <name>Ian Springer</name>
+    </contributor>
+    <contributor>
+      <name>Dominik Stadler</name>
+    </contributor>
+    <contributor>
+      <name>Masato Tezuka</name>
+    </contributor>
+    <contributor>
+      <name>James Urie</name>
+    </contributor>
+    <contributor>
+      <name>Frank W. Zammetti</name>
+    </contributor>
+    <contributor>
+      <name>Martin Grigorov</name>
+      <email>mgrigorov@apache.org</email>
+    </contributor>
+    <contributor>
+      <name>Arturo Bernal</name>
+    </contributor>
+    <contributor>
+      <name>Miguel MuÃ±oz</name>
+    </contributor>
+  </contributors>
+
 </project>
diff --git a/src/assembly/bin.xml b/src/assembly/bin.xml
index cf3f0086..e8dcfad7 100644
--- a/src/assembly/bin.xml
+++ b/src/assembly/bin.xml
@@ -14,7 +14,9 @@
  See the License for the specific language governing permissions and
  limitations under the License.
 -->
-<assembly>
+<assembly xmlns="http://maven.apache.org/ASSEMBLY/2.2.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.2.0 http://maven.apache.org/xsd/assembly-2.2.0.xsd">
     <id>bin</id>
     <formats>
         <format>tar.gz</format>
diff --git a/src/assembly/src.xml b/src/assembly/src.xml
index f5373b0e..891f8e24 100644
--- a/src/assembly/src.xml
+++ b/src/assembly/src.xml
@@ -14,7 +14,9 @@
  See the License for the specific language governing permissions and
  limitations under the License.
 -->
-<assembly>
+<assembly xmlns="http://maven.apache.org/ASSEMBLY/2.2.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.2.0 http://maven.apache.org/xsd/assembly-2.2.0.xsd">
     <id>src</id>
     <formats>
         <format>tar.gz</format>
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index d8665e8f..273e2388 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -45,11 +45,239 @@ The <action> type attribute can be add,update,fix,remove.
   <properties>
     <title>Apache Commons IO Release Notes</title>
   </properties>
-
   <body>
+    <release version="2.18.0" date="2024-11-16" description="Version 2.18.0: Java 8 is required.">
+      <!-- FIX -->
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Clean ups in unit tests.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Fix some Javadoc issues.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">RandomAccessFileMode.toString() is more helpful for debugging when it inherits from Enum.</action>      
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Fix implicit narrowing conversion in compound assignment in UnsynchronizedBufferedReader.skip(long).</action>
+      <action dev="ggregory" type="fix" issue="IO-860" due-to="Stefan Feenstra, Gary Gregory">Missing reserved file names in FileSystem.WINDOWS (superscript digits for COM and LPT).</action>
+      <action dev="ggregory" type="fix" issue="IO-856" due-to="Thomas Hartwig, Gary Gregory">FileUtils.listFiles(final File, String[], boolean) can throw NoSuchFileException #697, #699.</action>
+      <action dev="ggregory" type="fix" issue="IO-859" due-to="JD Dean, Gary Gregory">FileUtils.forceDelete on non-existent file on Windows throws IOException rather than FileNotFoundException.</action>
+      <action dev="ggregory" type="fix"                due-to="Ã‰amonn McManus">Use Unicode escapes for superscript characters. #701.</action>
+      <action dev="ggregory" type="fix" issue="IO-863" due-to="Ã‰amonn McManus, Gary Gregory">Recent incompatible change to FileUtils.listFiles re extensions, see also IO-856.</action>
+      <action dev="ggregory" type="fix" issue="IO-857" due-to="Dmitry, Gary Gregory">Javadoc: Update details for PathUtils "clean" behavior.</action>
+      
+      <!-- ADD -->
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add @FunctionalInterface to ClassNameMatcher.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add ValidatingObjectInputStream.Builder and ValidatingObjectInputStream.builder().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add a "Safe Deserialization" section to the User Guide for the site.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IORandomAccessFile.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add RandomAccessFileMode.io(String).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add FileAlterationObserver.Builder() and deprecate most constructors.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IOUtils.readLines(CharSequence).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add ValidatingObjectInputStream.ObjectStreamClassPredicate to allow configuration reuse.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add RandomAccessFileMode.accept(Path, IOConsumer&lt;RandomAccessFile&gt;).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add RandomAccessFileMode.apply(Path, IOFunction&lt;RandomAccessFile&gt;, T).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IOIntConsumer.</action>
+      <action dev="ggregory" type="add" issue="IO-861" due-to="Gary Gregory">Add ProxyInputStream.AbstractBuilder. Supports setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to AutoCloseInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to BOMInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add" issue="IO-861" due-to="Gary Gregory">Add support to BoundedInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add" issue="IO-861" due-to="Gary Gregory">Add support to BoundedInputStream for setting a consumer for BoundedInputStream.onMaxLength(long, long).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to ChecksumInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to ThrottledInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to ObservableInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to MessageDigestCalculatingInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add support to MessageDigestInputStream for setting a consumer for ProxyInputStream.afterRead(int).</action>
+      <!-- UPDATE -->
+      <action dev="ggregory" type="update"             due-to="Gary Gregory">Bump org.apache.commons:commons-parent from 74 to 78 #670, #676, #679, #688.</action>
+      <action dev="ggregory" type="update"             due-to="Gary Gregory">Bump commons.bytebuddy.version from 1.15.1 to 1.15.10 #672, #673, #685, #686, #694, #696, #698.</action>
+      <action dev="ggregory" type="update"             due-to="Gary Gregory">Update AbstractStreamBuilder getters from protected to public.</action>
+    </release>
+    <release version="2.17.0" date="2024-09-15" description="Version 2.17.0: Java 8 is required.">
+      <!-- ADD --> 
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IOIterator.adapt(Iterable).</action>
+      <action dev="ggregory" type="add" issue="IO-831" due-to="Elliotte Rusty Harold, Thach Le, Gary Gregory">Add getInputStream() for 'https' and 'http' in URIOrigin #630.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IOSupplier.getUnchecked().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add CloseShieldInputStream.systemIn(InputStream).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add NullInputStream.init().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add AbstractInputStream and refactor duplicate code.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add UnsynchronizedReader.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add UnsynchronizedBufferedReader.</action>
+      <!-- FIX -->
+      <action dev="sebb" type="fix" issue="IO-858">FileUtilsWaitForTest does not test anything useful.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Add missing unit tests.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">FileUtils.lastModifiedFileTime(File) calls Objects.requireNonNull() on the wrong object.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">PathUtils.deleteOnExit(Path) calls Objects.requireNonNull() on the wrong object.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate LineIterator.nextLine() in favor of next().</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Fix PMD UnnecessaryFullyQualifiedName.</action>
+      <action dev="ggregory" type="fix"                due-to="sullis">Add test for CircularByteBuffer clear() #620.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">PathUtils.isPosix(Path, LinkOption...) should return false on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">AutoCloseInputStream(InputStream) uses ClosedInputStream.INSTANCE when its input is null.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in ProxyInputStream.available() when the underlying input stream is null.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in ProxyInputStream.markSupported() when the underlying input stream is null.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in ProxyInputStream.mark(int) when the underlying input stream is null.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">BufferedFileChannelInputStream.available() returns 0 before any reads.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">BufferedFileChannelInputStream.available() should return 0 instead of -1 at the end of the stream.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">BufferedFileChannelInputStream.available() should return 0 when the stream is closed instead of throwing an exception.</action>      
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">CharSequenceInputStream.available() should return 0 after the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">BoundedInputStream.available() should return 0 when the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">CircularInputStream.available() should return 0 when the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">InfiniteCircularInputStream.available() should return 0 when the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">ChecksumInputStream(InputStream, Checksum, long, long) should fail-fast on null Checksum input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate NullInputStream.INSTANCE in favor of constructors.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">NullInputStream.available() should return 0 after the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">MemoryMappedFileInputStream.available() should return 0 after the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">RandomAccessFileInputStream.available() should return 0 after the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">ReaderInputStream.available() should return 0 after the stream is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">AutoCloseInputStream does not call handleIOException() on close() when the proxied stream throws an IOException.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">BoundedInputStream does not call handleIOException() on close() when the proxied stream throws an IOException.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">NullInputStream.read(*) should throw IOException when it is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">NullInputStream.read(byte[]) should return 0 when the input byte array in length 0.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">NullInputStream.read(byte[], int, int) should return 0 when the input byte array in length 0 or requested length is 0.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">MarkShieldInputStream.read(*) should throw IOException when it is closed.</action>
+      <action dev="ggregory" type="fix"                due-to="aelaort">Replace deprecated constant FileFileFilter.FILE in Javadoc #657.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Pick up exec-maven-plugin version from parent POM.</action>
+      <!-- UPDATE -->
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump tests commons.bytebuddy.version from 1.14.13 to 1.15.1 #615, #621, #631, #635, #642, #658, #663, #665.</action>
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump tests commons-codec:commons-codec from 1.16.1 to 1.17.1 #644.</action>
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump org.codehaus.mojo:exec-maven-plugin from 3.2.0 to 3.4.1 #632, #652, #659.</action>
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump org.apache.commons:commons-parent from 69 to 74 #628, #637, #649, #661, #664.</action>
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump org.apache.commons:commons-lang3 from 3.14.0 to 3.17.0 #645, #653, #666.</action>     
+    </release>
+    <release version="2.16.1" date="2024-04-04" description="Java 8 is required.">
+      <!-- FIX -->
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Reimplement FileSystemUtils using NIO.</action>
+      <action dev="ggregory" type="fix" issue="IO-851" due-to="Sebb, Gary Gregory">FileSystemUtils no longer throws IllegalStateException.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid possible NullPointerException in FileUtils.listAccumulate(File, IOFileFilter, IOFileFilter, FileVisitOption...).</action>
+      <action dev="ggregory" type="fix" issue="IO-853" due-to="Mike Drob, Gary Gregory">BoundedInputStream.reset() not updating count.</action>
+      <action dev="ggregory" type="fix" issue="IO-854" due-to="rproserpio, Bill Orpet, Gary Gregory">ThresholdingOutputStream: a negative threshold should behave like a zero threshold and trigger the event on the first write #609.</action>
+      <!-- UPDATE -->
+      <action dev="ggregory" type="update"             due-to="Gary Gregory">Bump commons.bytebuddy.version from 1.14.12 to 1.14.13 #605.</action>
+      <action dev="ggregory" type="update"             due-to="Gary Gregory, Dependabot">Bump org.apache.commons:commons-parent from 67 to 69 #608.</action>
+    </release>
+    <release version="2.16.0" date="2024-03-25" description="Java 8 is required.">
+      <!-- FIX -->
+      <action dev="ggregory" type="fix" due-to="Elliotte Rusty Harold">Fix and re-enable testSkip_RequiredCharsets #518.</action>
+      <action dev="ggregory" type="fix" issue="IO-824" due-to="Miguel Munoz, Gary Gregory">SymbolicLineFileFilter documentation fixes.</action>
+      <action dev="ggregory" type="fix" issue="IO-795" due-to="Miguel Munoz, Gary Gregory">CharSequenceInputStream.reset() only works once #520.</action>
+      <action dev="ggregory" type="fix" issue="IO-795" due-to="Elliotte Rusty Harold">Finish TODO on CharSequenceInputStream #540.</action>
+      <action dev="ggregory" type="fix" issue="IO-825" due-to="Arthur Chan, Gary Gregory">Add byte array size validation for methods in EndianUtils #521.</action>
+      <action dev="ggregory" type="fix" issue="IO-825" due-to="dkdal, Gary Gregory">Add missing test case CircularByteBufferTest.</action>
+      <action dev="ggregory" type="fix" issue="IO-781" due-to="Elliotte Rusty Harold">Make CharSequenceInputStream.available() more correct in the face of multibyte encodings #525.</action>
+      <action dev="ggregory" type="fix" issue="IO-781" due-to="Elliotte Rusty Harold">Remove unreachable code in AbstractIOFileFilterTest #526.</action>
+      <action dev="ggregory" type="fix" issue="IO-808" due-to="Elliotte Rusty Harold">Rationalize and unify checking for existence of files and directories #529.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in IOCase.checkEquals(String, String) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in CanExecuteFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in CanExecuteFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in CanReadFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in CanReadFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in CanWriteFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in CanWriteFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in DirectoryFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in DirectoryFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in EmptyFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in EmptyFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in FileFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in FileFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in HiddenFileFilter.accept(File) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in HiddenFileFilter.accept(Path, BasicFileAttributes) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in IOCase.checkIndexOf(String, int, String) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Avoid NullPointerException in IOCase.checkRegionMatches(String, int, String) on null input.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">BoundedInputStream.getCount() should not count EOF.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold, Gary Gregory">Modernize temporary file creation and deletion in DeferredFileOutputStreamTest #535.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold">Add PathMatcher to IOFileFilter class Javadoc #536.</action>
+      <action dev="ggregory" type="fix" issue="IO-781" due-to="Marcono1234">Fix CharSequenceInputStream coding exception handling #537.</action>
+      <action dev="ggregory" type="fix" issue="IO-781" due-to="Marcono1234">Deprecate int CountingInputStream#getCount() in favor of long CountingInputStream#getByteCount().</action>
+      <action dev="ggregory" type="fix" issue="IO-828" due-to="Elliotte Rusty Harold, Gary Gregory">Deprecate CountingInputStream.resetCount() in favor of resetByteCount().</action>
+      <action dev="ggregory" type="fix" issue="IO-828" due-to="Gary Gregory">Deprecate CountingInputStream.getMaxLength() in favor of getMaxCount()).</action>
+      <action dev="ggregory" type="fix" issue="IO-818" due-to="Gary Gregory">NullInputStream breaks InputStream's read method contract.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold">Javadoc shouldn't reference 1.x behavior #539.</action>
+      <action dev="ggregory" type="fix" issue="IO-829" due-to="Elliotte Rusty Harold, Gary Gregory">Don't decode and reencode characters in a potentially different charset in AbstractOrigin.CharSequenceOrigin.getReader(Charset).</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Let subclasses of CountingInputStream.afterRead(int) throw IOException.</action>
+      <action dev="ggregory" type="fix" issue="IO-807" due-to="Elliotte Rusty Harold, Gary Gregory">Characterization test for broken symlinks when copying directories #547.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">ClosedInputStream.read(byte[], int, int) does not always return -1.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">ClosedOutputStream.write(byte[], int, int) does not always throw IOException.</action>
+      <action dev="ggregory" type="fix"                due-to="Sylwester Lachiewicz, Gary Gregory">XmlStreamReader can't parse an XML document with a multi-line prolog #550.</action>
+      <action dev="ggregory" type="fix"                due-to="Andreas Hubold, Gary Gregory">XmlStreamReader can't parse XML an document with an external parsed entity prolog.</action>
+      <action dev="ggregory" type="fix" issue="IO-836" due-to="Elliotte Rusty Harold">Update FileNameUtils Javadoc #554.</action>
+      <action dev="ggregory" type="fix" issue="IO-807" due-to="Jordi Sola, Elliotte Rusty Harold">Copy symlinks, not the files the symlinks point to #558.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Pickup apache-rat-plugin version from parent POM.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold">Add test for copying a symlink FileUtilsTest#testCopyFile_symLink() #564.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold">Make copyFile copy symbolic links by value rather than reference #565.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate CopyUtils 0-argument constructor.</action>
+      <action dev="ggregory" type="fix" issue="IO-843" due-to="Gary Gregory, Elliotte Rusty Harold">Deprecate EndianUtils 0-argument constructor.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate FileSystemUtils 0-argument constructor.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate FilenameUtils 0-argument constructor.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate RandomAccessFiles 0-argument constructor.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold, Gary Gregory">Clarify and correct EndianUtils and SwappedDataInputStream API doc #566.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold">Add characterization test for copying a symlinked directory #570.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">RandomAccessFileInputStream.builder().get() now throws ISE instead of NPE.</action>
+      <action dev="ggregory" type="fix" issue="IO-845" due-to="Elliotte Rusty Harold">Test links to targets outside the source directory #571.</action>
+      <action dev="ggregory" type="fix"                due-to="Elliotte Rusty Harold">Focus Javadoc on current version rather than past versions #573, #574.</action>
+      <action dev="ggregory" type="fix" issue="IO-469" due-to="Grigory Fadeev, Kristian Rosenvold, Elliotte Rusty Harold">"Self-suppression not permitted" while using BrokenOutput and BrokenInput streams with try-with-resources.</action>
+      <action dev="ggregory" type="fix" issue="IO-405" due-to="Elliotte Rusty Harold">Handle zero and negative thresholds #587.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">Deprecate CountingInputStream in favor of BoundedInputStream.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">PathUtils.setPosixPermissions(...) only sets permissions if needed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">PathUtils.setReadOnly(...) only sets permissions if needed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">PathUtils.deleteFile(..., DeleteOption...) only sets permissions if needed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">CleaningPathVisitor only sets permissions if needed.</action>
+      <action dev="ggregory" type="fix"                due-to="Gary Gregory">DeletingPathVisitor only sets permissions if needed.</action>
+      <!-- Add -->
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add and use PathUtils.getFileName(Path, Function&lt;Path, R&gt;).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add and use PathUtils.getFileNameString().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Make public Erase.rethrow(Throwable).</action>
+      <action dev="ggregory" type="add" issue="IO-826" due-to="markslater, Gary Gregory">Add BrokenInputStream.BrokenInputStream(Throwable).</action>
+      <action dev="ggregory" type="add" issue="IO-826" due-to="markslater, Gary Gregory">Add BrokenReader.BrokenReader(Throwable).</action>
+      <action dev="ggregory" type="add" issue="IO-826" due-to="markslater, Gary Gregory">Add BrokenOutputStream.BrokenOutputStream(Throwable).</action>
+      <action dev="ggregory" type="add" issue="IO-826" due-to="markslater, Gary Gregory">Add BrokenWriter.BrokenWriter(Throwable).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add BoundedInputStream.getRemaining().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add FileTimes.toNtfsTime(long).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add FileTimes.fromUnixTime(long).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add FileTimes.isUnixTime(FileTime).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add FileTimes.isUnixTime(long).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add FileTimes.toUnixTime(FileTime).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add BrokenInputStream.Builder.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add PathUtils.getExtension(Path).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add PathUtils.getBaseName(Path).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add ThrottledInputStream.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IORunnable.noop().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add ChecksumInputStream and test #548.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add AbstractStreamBuilder.getReader().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add Maven property project.build.outputTimestamp for build reproducibility.</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add ProxyInputStream.unwrap().</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add a running count and builder to BoundedInputStream.</action>
+      <!--  UPDATE -->
+      <action dev="ggregory" type="update"             due-to="Gary Gregory">Bump commons.bytebuddy.version from 1.14.10 to 1.14.12 #534, #592.</action>
+      <action dev="ggregory" type="update"             due-to="Gary Gregory">Bump org.apache.commons:commons-parent from 65 to 67.</action>
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump commons-codec:commons-codec from 1.16.0 to 1.16.1 #583.</action>
+      <action dev="ggregory" type="update"             due-to="Dependabot">Bump org.codehaus.mojo:exec-maven-plugin from 3.1.1 to 3.2.0 #593.</action>
+    </release>
+    <release version="2.15.1" date="2023-11-24" description="Java 8 is required.">
+      <!-- FIX -->
+      <action dev="sebb" type="fix" due-to="Gregor Dschung">Fix wrong issue id in change log #503.</action>
+      <action dev="ggregory" type="fix" due-to="Stephan Markwalder, Gary Gregory">Add test for FileChannels.contentEquals() #509.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix FileChannels.contentEquals().</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix some Javadoc issues in LineIterator and IOUtils.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Simplify FileAlterationObserver internal processing.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Avoid NullPointerException in RegexFileFilter.RegexFileFilter(Pattern).</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Avoid NullPointerException in RegexFileFilter.accept(Path, BasicFileAttributes).</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Class org.apache.commons.io.filefilter.RegexFileFilter defines non-transient non-serializable instance field pathToString [org.apache.commons.io.filefilter.RegexFileFilter] In RegexFileFilter.java SE_BAD_FIELD.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Class org.apache.commons.io.filefilter.DelegateFileFilter defines non-transient non-serializable instance field fileFilter [org.apache.commons.io.filefilter.DelegateFileFilter] In DelegateFileFilter.java SE_BAD_FIELD.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Class org.apache.commons.io.filefilter.DelegateFileFilter defines non-transient non-serializable instance field fileNameFilter [org.apache.commons.io.filefilter.DelegateFileFilter] In DelegateFileFilter.java SE_BAD_FIELD.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.function.IOStream$1.next() cannot throw NoSuchElementException [org.apache.commons.io.function.IOStream$1] At IOStream.java:[line 98] IT_NO_SUCH_ELEMENT.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.monitor.FileAlterationMonitor.getObservers() may expose internal representation by returning FileAlterationMonitor.observers [org.apache.commons.io.monitor.FileAlterationMonitor] At FileAlterationMonitor.java:[line 124] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Class org.apache.commons.io.monitor.FileAlterationObserver defines non-transient non-serializable instance field fileFilter [org.apache.commons.io.monitor.FileAlterationObserver] In FileAlterationObserver.java SE_BAD_FIELD.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Class org.apache.commons.io.monitor.FileAlterationObserver defines non-transient non-serializable instance field listeners [org.apache.commons.io.monitor.FileAlterationObserver] In FileAlterationObserver.java SE_BAD_FIELD.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.FileCleaningTracker.getDeleteFailures() may expose internal representation by returning FileCleaningTracker.deleteFailures [org.apache.commons.io.FileCleaningTracker] At FileCleaningTracker.java:[line 218] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.IOExceptionList.getCauseList() may expose internal representation by returning IOExceptionList.causeList [org.apache.commons.io.IOExceptionList] At IOExceptionList.java:[line 118] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.IOExceptionList.getCauseList(Class) may expose internal representation by returning IOExceptionList.causeList [org.apache.commons.io.IOExceptionList] At IOExceptionList.java:[line 129] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.file.AccumulatorPathVisitor.getDirList() may expose internal representation by returning AccumulatorPathVisitor.dirList [org.apache.commons.io.file.AccumulatorPathVisitor] At AccumulatorPathVisitor.java:[line 179] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.file.AccumulatorPathVisitor.getFileList() may expose internal representation by returning AccumulatorPathVisitor.fileList [org.apache.commons.io.file.AccumulatorPathVisitor] At AccumulatorPathVisitor.java:[line 188] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: org.apache.commons.io.input.ObservableInputStream.getObservers() may expose internal representation by returning ObservableInputStream.observers [org.apache.commons.io.input.ObservableInputStream] At ObservableInputStream.java:[line 187] EI_EXPOSE_REP.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Exception thrown in class org.apache.commons.io.input.UnsynchronizedByteArrayInputStream at new org.apache.commons.io.input.UnsynchronizedByteArrayInputStream(byte[], int) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks. [org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream] At UnsynchronizedByteArrayInputStream.java:[line 202]At UnsynchronizedByteArrayInputStream.java:[line 202] CT_CONSTRUCTOR_THROW.</action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">Fix SpotBugs error: Exception thrown in class org.apache.commons.io.input.UnsynchronizedByteArrayInputStream at new org.apache.commons.io.input.UnsynchronizedByteArrayInputStream(byte[], int, int) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks. [org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream] At UnsynchronizedByteArrayInputStream.java:[line 223]At UnsynchronizedByteArrayInputStream.java:[line 223] CT_CONSTRUCTOR_THROW.</action>
+      <!-- UPDATE -->
+      <action dev="ggregory" type="update" due-to="Gary Gregory">Bump org.codehaus.mojo:exec-maven-plugin from 3.1.0 to 3.1.1 #512.</action>
+      <action dev="ggregory" type="update" due-to="Gary Gregory">Bump commons-lang3 from 3.13.0 to 3.14.0.</action>
+      <action dev="ggregory" type="update" due-to="Dependabot">Bump commons.bytebuddy.version from 1.14.9 to 1.14.10 #516.</action>
+      <action dev="ggregory" type="update" due-to="Dependabot">Bump commons-parent from 64 to 65.</action>
+    </release>
     <release version="2.15.0" date="2023-10-21" description="Java 8 is required.">
       <!-- FIX -->
-      <action dev="sebb" type="fix" issue="IO-810" due-to="Laurence Gonsalves">
+      <action dev="sebb" type="fix" issue="IO-815" due-to="Laurence Gonsalves">
         XmlStreamReader encoding match RE is too strict.
       </action>
       <action dev="ggregory" type="fix" issue="IO-810" due-to="Gregor Dschung, Gary Gregory">
@@ -108,6 +336,12 @@ The <action> type attribute can be add,update,fix,remove.
       <action issue="IO-816" dev="ggregory" type="fix" due-to="Andreas Loth, Gary Gregory">
         UnsynchronizedBufferedInputStream.read(byte[], int, int) does not use buffer.
       </action>
+      <action dev="ggregory" type="fix" due-to="Gary Gregory">
+        Pick up Maven Moditect plugin version from parent POM.
+      </action>
+      <action issue="IO-821" dev="ggregory" type="fix" due-to="FrÃ©dÃ©ric Hannes, Gary Gregory">
+        2.15.0 breaks backwards compatibility in PathUtils.fileContentEquals for the Zip file system.
+      </action>
       <!-- ADD -->
       <action dev="ggregory" type="add" due-to="Gary Gregory">
         Add org.apache.commons.io.channels.FileChannels.
diff --git a/src/changes/release-notes.vm b/src/changes/release-notes.vm
index 86973814..61f90469 100644
--- a/src/changes/release-notes.vm
+++ b/src/changes/release-notes.vm
@@ -15,15 +15,10 @@
 ## specific language governing permissions and limitations
 ## under the License.
 
-Apache Commons IO 
-Version ${version}
-Release Notes
+Apache Commons IO ${version} Release Notes
 
-INTRODUCTION:
-
-Commons IO is a package of Java utility classes like java.io.  
-Classes in this package are considered to be so standard and of such high 
-reuse as to justify existence in java.io.
+Introduction
+------------
 
 $introduction.replaceAll("(?<!\015)\012", "
 ")
@@ -40,14 +35,14 @@ $release.description.replaceAll("  ", "
 #if ($release.getActions().size() == 0)
 No changes defined in this version.
 #else
-Changes in this version include:
-
 ## indent to be used if there is no issue attribute.
 ## should be the same as the indent in the changes.xml file
-## less 2 spaces for the 'o' and trailing space
-#set($indent='          ')
+## less 2 spaces for the '*' and trailing space
+#set($indent='         ')
 #if ($release.getActions('add').size() !=0)
-New features:
+New features
+------------
+
 #foreach($actionItem in $release.getActions('add'))
 ## Use replaceAll to fix up LF-only line ends on Windows.
 #set($action=$actionItem.getAction().replaceAll("\n","
@@ -70,7 +65,9 @@ o#if($!issue != "") $issue: #else$indent#end ${action} #if($!dueto != "")Thanks
 #end
 
 #if ($release.getActions('fix').size() !=0)
-Fixed Bugs:
+Fixed Bugs
+----------
+
 #foreach($actionItem in $release.getActions('fix'))
 ## Use replaceAll to fix up LF-only line ends on Windows.
 #set($action=$actionItem.getAction().replaceAll("\n","
@@ -93,7 +90,9 @@ o#if($!issue != "") $issue: #else$indent#end ${action} #if($!dueto != "")Thanks
 #end
 
 #if ($release.getActions('update').size() !=0)
-Changes:
+Changes
+-------
+
 #foreach($actionItem in $release.getActions('update'))
 ## Use replaceAll to fix up LF-only line ends on Windows.
 #set($action=$actionItem.getAction().replaceAll("\n","
@@ -116,7 +115,9 @@ o#if($!issue != "") $issue: #else$indent#end ${action} #if($!dueto != "")Thanks
 #end
 
 #if ($release.getActions('remove').size() !=0)
-Removed:
+Removed
+-------
+
 #foreach($actionItem in $release.getActions('remove'))
 ## Use replaceAll to fix up LF-only line ends on Windows.
 #set($action=$actionItem.getAction().replaceAll("\n","
@@ -140,20 +141,12 @@ o#if($!issue != "") $issue: #else$indent#end ${action} #if($!dueto != "")Thanks
 ## End of main loop
 #end
 ##
-Compatibility with 2.6:
-Binary compatible: Yes.
-Source compatible: Yes.
-Semantic compatible: Yes.
-
-Commons IO 2.9.0 requires Java 8.
-Commons IO 2.8.0 requires Java 8.
-Commons IO 2.7 requires Java 8.
-Commons IO 2.6 requires Java 7.
-Commons IO 2.5 requires Java 6.
-Commons IO 2.4 requires Java 6.
-Commons IO 2.3 requires Java 6.
-Commons IO 2.2 requires Java 5.
-Commons IO 1.4 requires Java 1.3.
+
+Commons IO 2.7 and up requires Java 8 or above.
+Commons IO 2.6 requires Java 7 or above.
+Commons IO 2.3 through 2.5 requires Java 6 or above.
+Commons IO 2.2 requires Java 5 or above.
+Commons IO 1.4 requires Java 1.3 or above.
 
 Historical list of changes: ${project.url}changes-report.html
 
@@ -167,4 +160,5 @@ Download page: ${project.url}download_io.cgi
 Have fun!
 -Apache Commons Team
 
-==============================================================================
+------------------------------------------------------------------------------
+
diff --git a/src/conf/checkstyle.xml b/src/conf/checkstyle.xml
index 4ff52333..24fc4b73 100644
--- a/src/conf/checkstyle.xml
+++ b/src/conf/checkstyle.xml
@@ -31,6 +31,7 @@ limitations under the License.
     <property name="max" value="160" />
   </module>
   <module name="TreeWalker">
+    <module name="WhitespaceAfter" />
     <module name="AvoidStarImport" />
     <module name="RedundantImport" />
     <module name="UnusedImports" />
@@ -51,4 +52,11 @@ limitations under the License.
       <property name="message" value="Trailing whitespace" />
     </module>
   </module>
+  <!-- @author tags are deprecated -->
+  <module name="RegexpSingleline">
+    <property name="format" value="^\s+\*\s+@author\s" />
+    <property name="message" value="Deprecated @author tag" />
+    <property name="fileExtensions" value="java" />
+    <property name="severity" value="warning" />
+  </module>
 </module>
diff --git a/src/conf/maven-pmd-plugin.xml b/src/conf/maven-pmd-plugin.xml
index a89254da..cdb42c7e 100644
--- a/src/conf/maven-pmd-plugin.xml
+++ b/src/conf/maven-pmd-plugin.xml
@@ -65,7 +65,12 @@ under the License.
     <rule ref="category/java/errorprone.xml/CheckSkipResult" />
     <rule ref="category/java/errorprone.xml/ClassCastExceptionWithToArray" />
     <rule ref="category/java/errorprone.xml/DontUseFloatTypeForLoopIndices" />
-    <rule ref="category/java/errorprone.xml/EmptyCatchBlock" />
+    <rule ref="category/java/errorprone.xml/EmptyCatchBlock">
+      <properties>
+        <property name="allowCommentedBlocks" value="true" />
+        <property name="allowExceptionNameRegex" value="^(ignored|expected)$" />
+      </properties>
+    </rule>
     <rule ref="category/java/errorprone.xml/JumbledIncrementer" />
     <rule ref="category/java/errorprone.xml/MisplacedNullCheck" />
     <rule ref="category/java/errorprone.xml/OverrideBothEqualsAndHashcode" />
diff --git a/src/conf/spotbugs-exclude-filter.xml b/src/conf/spotbugs-exclude-filter.xml
index 000c565d..ecb4fee9 100644
--- a/src/conf/spotbugs-exclude-filter.xml
+++ b/src/conf/spotbugs-exclude-filter.xml
@@ -20,6 +20,22 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="https://github.com/spotbugs/filter/3.0.0 https://raw.githubusercontent.com/spotbugs/spotbugs/3.1.0/spotbugs/etc/findbugsfilter.xsd">
 
+  <!-- TODO Can any of these be done without breaking binary compatibility? -->
+  <Match>
+    <Class name="~.*" />
+    <Or>
+      <Bug pattern="EI_EXPOSE_REP" />
+      <Bug pattern="EI_EXPOSE_REP2" />
+      <Bug pattern="MS_EXPOSE_REP" />
+    </Or>
+  </Match>
+
+  <!-- https://github.com/spotbugs/spotbugs/issues/2710 -->
+  <Match>
+    <Class name="~.*" />
+    <Bug pattern="CT_CONSTRUCTOR_THROW" />
+  </Match>
+
   <!--  See discussion on https://issues.apache.org/jira/browse/IO-216 -->
   <Match>
     <Class name="org.apache.commons.io.output.LockableFileWriter" />
@@ -47,4 +63,25 @@
     <Bug pattern="MS_PKGPROTECT" />
   </Match>
 
+  <!-- Deprecated -->
+  <Match>
+    <Class name="org.apache.commons.io.monitor.FileAlterationObserver" />
+    <Field name="fileFilter" />
+    <Bug pattern="SE_TRANSIENT_FIELD_NOT_RESTORED" />
+  </Match>
+
+  <!-- Deprecated -->
+  <Match>
+    <Class name="org.apache.commons.io.monitor.FileAlterationObserver" />
+    <Field name="listeners" />
+    <Bug pattern="SE_TRANSIENT_FIELD_NOT_RESTORED" />
+  </Match>
+
+  <!-- This class only throws unchecked exceptions. -->
+  <Match>
+    <Class name="org.apache.commons.io.function.UncheckedIOIterator" />
+    <Method name="next" />
+    <Bug pattern="IT_NO_SUCH_ELEMENT" />
+  </Match>
+
 </FindBugsFilter>
diff --git a/src/main/java/org/apache/commons/io/ByteOrderMark.java b/src/main/java/org/apache/commons/io/ByteOrderMark.java
index c5ab57b1..6e87d6b3 100644
--- a/src/main/java/org/apache/commons/io/ByteOrderMark.java
+++ b/src/main/java/org/apache/commons/io/ByteOrderMark.java
@@ -39,7 +39,7 @@
  * </p>
  *
  * @see org.apache.commons.io.input.BOMInputStream
- * @see <a href="http://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia: Byte Order Mark</a>
+ * @see <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia: Byte Order Mark</a>
  * @see <a href="http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing">W3C: Autodetection of Character Encodings
  *      (Non-Normative)</a>
  * @since 2.0
@@ -110,7 +110,7 @@ public class ByteOrderMark implements Serializable {
     /**
      * Unicode BOM character; external form depends on the encoding.
      *
-     * @see <a href="http://unicode.org/faq/utf_bom.html#BOM">Byte Order Mark (BOM) FAQ</a>
+     * @see <a href="https://unicode.org/faq/utf_bom.html#BOM">Byte Order Mark (BOM) FAQ</a>
      * @since 2.5
      */
     public static final char UTF_BOM = '\uFEFF';
diff --git a/src/main/java/org/apache/commons/io/Charsets.java b/src/main/java/org/apache/commons/io/Charsets.java
index 37275b8c..11433cfe 100644
--- a/src/main/java/org/apache/commons/io/Charsets.java
+++ b/src/main/java/org/apache/commons/io/Charsets.java
@@ -26,7 +26,7 @@
 /**
  * Charsets required of every implementation of the Java platform.
  *
- * From the Java documentation <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">
+ * From the Java documentation <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">
  * Standard charsets</a>:
  * <p>
  * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult
@@ -50,7 +50,7 @@
  * accepted on input, big-endian used on output.)</li>
  * </ul>
  *
- * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+ * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
  * @since 2.3
  */
 public class Charsets {
@@ -79,7 +79,7 @@ public class Charsets {
      * Every implementation of the Java platform is required to support this character encoding.
      * </p>
      *
-     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
      * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
      */
     @Deprecated
@@ -93,7 +93,7 @@ public class Charsets {
      * Every implementation of the Java platform is required to support this character encoding.
      * </p>
      *
-     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
      * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
      */
     @Deprecated
@@ -108,7 +108,7 @@ public class Charsets {
      * Every implementation of the Java platform is required to support this character encoding.
      * </p>
      *
-     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
      * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
      */
     @Deprecated
@@ -122,7 +122,7 @@ public class Charsets {
      * Every implementation of the Java platform is required to support this character encoding.
      * </p>
      *
-     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
      * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
      */
     @Deprecated
@@ -136,7 +136,7 @@ public class Charsets {
      * Every implementation of the Java platform is required to support this character encoding.
      * </p>
      *
-     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
      * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
      */
     @Deprecated
@@ -150,7 +150,7 @@ public class Charsets {
      * Every implementation of the Java platform is required to support this character encoding.
      * </p>
      *
-     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
      * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}
      */
     @Deprecated
@@ -160,7 +160,7 @@ public class Charsets {
      * Constructs a sorted map from canonical charset names to charset objects required of every implementation of the
      * Java platform.
      * <p>
-     * From the Java documentation <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">
+     * From the Java documentation <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">
      * Standard charsets</a>:
      * </p>
      *
diff --git a/src/main/java/org/apache/commons/io/CloseableURLConnection.java b/src/main/java/org/apache/commons/io/CloseableURLConnection.java
index 14e061b3..4796d376 100644
--- a/src/main/java/org/apache/commons/io/CloseableURLConnection.java
+++ b/src/main/java/org/apache/commons/io/CloseableURLConnection.java
@@ -30,7 +30,7 @@
 /**
  * Delegates to a URLConnection while implementing AutoCloseable.
  */
-class CloseableURLConnection extends URLConnection implements AutoCloseable {
+final class CloseableURLConnection extends URLConnection implements AutoCloseable {
 
     static CloseableURLConnection open(final URI uri) throws IOException {
         return open(Objects.requireNonNull(uri, "uri").toURL());
diff --git a/src/main/java/org/apache/commons/io/CopyUtils.java b/src/main/java/org/apache/commons/io/CopyUtils.java
index da01a987..72da100a 100644
--- a/src/main/java/org/apache/commons/io/CopyUtils.java
+++ b/src/main/java/org/apache/commons/io/CopyUtils.java
@@ -68,7 +68,7 @@
  * Imagine that an InputStream's read() is a very expensive operation, which
  * would usually suggest wrapping in a BufferedInputStream. The
  * BufferedInputStream works by issuing infrequent
- * {@link java.io.InputStream#read(byte[] b, int off, int len)} requests on the
+ * {@link InputStream#read(byte[] b, int off, int len)} requests on the
  * underlying InputStream, to fill an internal buffer, from which further
  * {@code read} requests can inexpensively get their data (until the buffer
  * runs out).
@@ -131,7 +131,7 @@ public static void copy(final byte[] input, final OutputStream output) throws IO
      * @param input the byte array to read from
      * @param output the {@link Writer} to write to
      * @throws IOException In case of an I/O problem
-     * @deprecated 2.5 use {@link #copy(byte[], Writer, String)} instead
+     * @deprecated Use {@link #copy(byte[], Writer, String)} instead
      */
     @Deprecated
     public static void copy(final byte[] input, final Writer output) throws IOException {
@@ -183,7 +183,7 @@ public static int copy(final InputStream input, final OutputStream output) throw
      * @param input the {@link InputStream} to read from
      * @param output the {@link Writer} to write to
      * @throws IOException In case of an I/O problem
-     * @deprecated 2.5 use {@link #copy(InputStream, Writer, String)} instead
+     * @deprecated Use {@link #copy(InputStream, Writer, String)} instead
      */
     @Deprecated
     public static void copy(
@@ -223,7 +223,7 @@ public static void copy(
      * @param input the {@link Reader} to read from
      * @param output the {@link OutputStream} to write to
      * @throws IOException In case of an I/O problem
-     * @deprecated 2.5 use {@link #copy(Reader, OutputStream, String)} instead
+     * @deprecated Use {@link #copy(Reader, OutputStream, String)} instead
      */
     @Deprecated
     public static void copy(
@@ -293,7 +293,7 @@ public static int copy(
      * @param input the {@link String} to read from
      * @param output the {@link OutputStream} to write to
      * @throws IOException In case of an I/O problem
-     * @deprecated 2.5 use {@link #copy(String, OutputStream, String)} instead
+     * @deprecated Use {@link #copy(String, OutputStream, String)} instead
      */
     @Deprecated
     public static void copy(
@@ -349,7 +349,12 @@ public static void copy(final String input, final Writer output)
 
     /**
      * Instances should NOT be constructed in standard programming.
+     *
+     * @deprecated TODO Make private in 3.0.
      */
-    public CopyUtils() { }
+    @Deprecated
+    public CopyUtils() {
+        // empty
+    }
 
 }
diff --git a/src/main/java/org/apache/commons/io/DirectoryWalker.java b/src/main/java/org/apache/commons/io/DirectoryWalker.java
index 2269c2af..1a0fdc2b 100644
--- a/src/main/java/org/apache/commons/io/DirectoryWalker.java
+++ b/src/main/java/org/apache/commons/io/DirectoryWalker.java
@@ -157,7 +157,7 @@
  * What {@link DirectoryWalker} does provide for cancellation is:
  * </p>
  * <ul>
- * <li>{@link CancelException} which can be thrown in any of the <i>lifecycle</i> methods to stop processing.</li>
+ * <li>{@link CancelException} which can be thrown in any of the <em>lifecycle</em> methods to stop processing.</li>
  * <li>The {@code walk()} method traps thrown {@link CancelException} and calls the {@code handleCancelled()}
  * method, providing a place for custom cancel processing.</li>
  * </ul>
@@ -186,11 +186,11 @@
  *
  * <p>
  * This example provides a public {@code cancel()} method that can be called by another thread to stop the
- * processing. A typical example use-case would be a cancel button on a GUI. Calling this method sets a
- * <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#36930"> volatile</a> flag to ensure
- * it will work properly in a multi-threaded environment. The flag is returned by the {@code handleIsCancelled()}
- * method, which will cause the walk to stop immediately. The {@code handleCancelled()} method will be the next,
- * and last, callback method received once cancellation has occurred.
+ * processing. A typical example use-case is a cancel button on a GUI. Calling this method sets a
+ * <a href='https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#d5e12277'>(@code volatile}</a>
+ * flag to ensure it works properly in a multi-threaded environment.
+ * The flag is returned by the {@code handleIsCancelled()} method, which causes the walk to stop
+ * immediately. The {@code handleCancelled()} method will be the next, and last, callback method received once cancellation has occurred.
  * </p>
  *
  * <pre>
@@ -215,8 +215,8 @@
  * <h3 id="internal">3.2 Internal</h3>
  *
  * <p>
- * This shows an example of how internal cancellation processing could be implemented. <b>Note</b> the decision logic
- * and throwing a {@link CancelException} could be implemented in any of the <i>lifecycle</i> methods.
+ * This shows an example of how internal cancellation processing could be implemented. <strong>Note</strong> the decision logic
+ * and throwing a {@link CancelException} could be implemented in any of the <em>lifecycle</em> methods.
  * </p>
  *
  * <pre>
@@ -323,14 +323,14 @@ public File getFile() {
     private final int depthLimit;
 
     /**
-     * Constructs an instance with no filtering and unlimited <i>depth</i>.
+     * Constructs an instance with no filtering and unlimited <em>depth</em>.
      */
     protected DirectoryWalker() {
         this(null, -1);
     }
 
     /**
-     * Constructs an instance with a filter and limit the <i>depth</i> navigated to.
+     * Constructs an instance with a filter and limit the <em>depth</em> navigated to.
      * <p>
      * The filter controls which files and directories will be navigated to as
      * part of the walk. The {@link FileFilterUtils} class is useful for combining
@@ -339,7 +339,7 @@ protected DirectoryWalker() {
      * </p>
      *
      * @param filter  the filter to apply, null means visit all files
-     * @param depthLimit  controls how <i>deep</i> the hierarchy is
+     * @param depthLimit  controls how <em>deep</em> the hierarchy is
      *  navigated to (less than 0 means unlimited)
      */
     protected DirectoryWalker(final FileFilter filter, final int depthLimit) {
@@ -349,7 +349,7 @@ protected DirectoryWalker(final FileFilter filter, final int depthLimit) {
 
     /**
      * Constructs an instance with a directory and a file filter and an optional
-     * limit on the <i>depth</i> navigated to.
+     * limit on the <em>depth</em> navigated to.
      * <p>
      * The filters control which files and directories will be navigated to as part
      * of the walk. This constructor uses {@link FileFilterUtils#makeDirectoryOnly(IOFileFilter)}
@@ -359,7 +359,7 @@ protected DirectoryWalker(final FileFilter filter, final int depthLimit) {
      *
      * @param directoryFilter  the filter to apply to directories, null means visit all directories
      * @param fileFilter  the filter to apply to files, null means visit all files
-     * @param depthLimit  controls how <i>deep</i> the hierarchy is
+     * @param depthLimit  controls how <em>deep</em> the hierarchy is
      *  navigated to (less than 0 means unlimited)
      */
     protected DirectoryWalker(IOFileFilter directoryFilter, IOFileFilter fileFilter, final int depthLimit) {
@@ -624,7 +624,7 @@ protected final void walk(final File startDirectory, final Collection<T> results
             handleStart(startDirectory, results);
             walk(startDirectory, 0, results);
             handleEnd(results);
-        } catch(final CancelException cancel) {
+        } catch (final CancelException cancel) {
             handleCancelled(startDirectory, results, cancel);
         }
     }
@@ -644,7 +644,7 @@ private void walk(final File directory, final int depth, final Collection<T> res
             final int childDepth = depth + 1;
             if (depthLimit < 0 || childDepth <= depthLimit) {
                 checkIfCancelled(directory, depth, results);
-                File[] childFiles = filter == null ? directory.listFiles() : directory.listFiles(filter);
+                File[] childFiles = directory.listFiles(filter);
                 childFiles = filterDirectoryContents(directory, depth, childFiles);
                 if (childFiles == null) {
                     handleRestricted(directory, childDepth, results);
diff --git a/src/main/java/org/apache/commons/io/EndianUtils.java b/src/main/java/org/apache/commons/io/EndianUtils.java
index 83c2ce25..7eaa9a19 100644
--- a/src/main/java/org/apache/commons/io/EndianUtils.java
+++ b/src/main/java/org/apache/commons/io/EndianUtils.java
@@ -24,14 +24,21 @@
 import java.io.OutputStream;
 
 /**
- * Helps with different endian systems.
+ * Helps with reading and writing primitive numeric types ({@code short},
+ * {@code int}, {@code long}, {@code float}, and {@code double}) that are
+ * encoded in little endian using two's complement or unsigned representations.
  * <p>
- * Different computer architectures adopt different conventions for
- * byte ordering. In so-called "Little Endian" architectures (eg Intel),
+ * Different computer architectures have different conventions for
+ * byte ordering. In "Little Endian" architectures (e.g. X86),
  * the low-order byte is stored in memory at the lowest address, and
- * subsequent bytes at higher addresses. For "Big Endian" architectures
- * (eg Motorola), the situation is reversed.
- * This class helps you solve this incompatibility.
+ * subsequent bytes at higher addresses. In "Big Endian" architectures
+ * (e.g. Motorola 680X0), the situation is reversed.
+ * Most methods and classes throughout Java &mdash; e.g. {@code DataInputStream} and
+ * {@code Double.longBitsToDouble()} &mdash; assume data is laid out
+ * in big endian order with the most significant byte first.
+ * The methods in this class read and write data in little endian order,
+ * generally by reversing the bytes and then using the
+ * regular Java methods to convert the swapped bytes to a primitive type.
  * </p>
  * <p>
  * Provenance: Excalibur
@@ -56,19 +63,20 @@ private static int read(final InputStream input) throws IOException {
     }
 
     /**
-     * Reads a "double" value from a byte array at a given offset. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code double} value from a byte array at a given offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 8 bytes
      */
     public static double readSwappedDouble(final byte[] data, final int offset) {
         return Double.longBitsToDouble(readSwappedLong(data, offset));
     }
 
     /**
-     * Reads a "double" value from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code double} value from an InputStream.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -78,19 +86,20 @@ public static double readSwappedDouble(final InputStream input) throws IOExcepti
     }
 
     /**
-     * Reads a "float" value from a byte array at a given offset. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code float} value from a byte array at a given offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 4 bytes
      */
     public static float readSwappedFloat(final byte[] data, final int offset) {
         return Float.intBitsToFloat(readSwappedInteger(data, offset));
     }
 
     /**
-     * Reads a "float" value from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code float} value from an InputStream.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -100,13 +109,15 @@ public static float readSwappedFloat(final InputStream input) throws IOException
     }
 
     /**
-     * Reads an "int" value from a byte array at a given offset. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code int} value from a byte array at a given offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 4 bytes
      */
     public static int readSwappedInteger(final byte[] data, final int offset) {
+        validateByteArrayOffset(data, offset, Integer.SIZE / Byte.SIZE);
         return ((data[offset + 0] & 0xff) << 0) +
             ((data[offset + 1] & 0xff) << 8) +
             ((data[offset + 2] & 0xff) << 16) +
@@ -114,8 +125,8 @@ public static int readSwappedInteger(final byte[] data, final int offset) {
     }
 
     /**
-     * Reads an "int" value from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code int} value from an InputStream.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -129,21 +140,23 @@ public static int readSwappedInteger(final InputStream input) throws IOException
     }
 
     /**
-     * Reads a "long" value from a byte array at a given offset. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code long} value from a byte array at a given offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 8 bytes
      */
     public static long readSwappedLong(final byte[] data, final int offset) {
+        validateByteArrayOffset(data, offset, Long.SIZE / Byte.SIZE);
         final long low = readSwappedInteger(data, offset);
         final long high = readSwappedInteger(data, offset + 4);
         return (high << 32) + (0xffffffffL & low);
     }
 
     /**
-     * Reads a "long" value from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code long} value from an InputStream.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -157,20 +170,21 @@ public static long readSwappedLong(final InputStream input) throws IOException {
     }
 
     /**
-     * Reads a "short" value from a byte array at a given offset. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code short} value from a byte array at a given offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 2 bytes
      */
     public static short readSwappedShort(final byte[] data, final int offset) {
-        return (short)(((data[offset + 0] & 0xff) << 0) +
-            ((data[offset + 1] & 0xff) << 8));
+        validateByteArrayOffset(data, offset, Short.SIZE / Byte.SIZE);
+        return (short) (((data[offset + 0] & 0xff) << 0) + ((data[offset + 1] & 0xff) << 8));
     }
 
     /**
-     * Reads a "short" value from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian {@code short} value from an InputStream.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -180,14 +194,16 @@ public static short readSwappedShort(final InputStream input) throws IOException
     }
 
     /**
-     * Reads an unsigned integer (32-bit) value from a byte array at a given
-     * offset. The value is converted to the opposed endian system while
-     * reading.
+     * Reads a little endian unsigned integer (32-bit) value from a byte array at a given
+     * offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
-     */
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 4 bytes
+    */
     public static long readSwappedUnsignedInteger(final byte[] data, final int offset) {
+        validateByteArrayOffset(data, offset, Integer.SIZE / Byte.SIZE);
         final long low = ((data[offset + 0] & 0xff) << 0) +
                      ((data[offset + 1] & 0xff) << 8) +
                      ((data[offset + 2] & 0xff) << 16);
@@ -196,8 +212,8 @@ public static long readSwappedUnsignedInteger(final byte[] data, final int offse
     }
 
     /**
-     * Reads an unsigned integer (32-bit) from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads a little endian unsigned integer (32-bit) from an InputStream.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -213,21 +229,22 @@ public static long readSwappedUnsignedInteger(final InputStream input) throws IO
     }
 
     /**
-     * Reads an unsigned short (16-bit) value from a byte array at a given
-     * offset. The value is converted to the opposed endian system while
-     * reading.
+     * Reads an unsigned short (16-bit) value from a byte array in little endian order at a given
+     * offset.
+     *
      * @param data source byte array
      * @param offset starting offset in the byte array
      * @return the value read
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 2 bytes
      */
     public static int readSwappedUnsignedShort(final byte[] data, final int offset) {
-        return ((data[offset + 0] & 0xff) << 0) +
-            ((data[offset + 1] & 0xff) << 8);
+        validateByteArrayOffset(data, offset, Short.SIZE / Byte.SIZE);
+        return ((data[offset + 0] & 0xff) << 0) + ((data[offset + 1] & 0xff) << 8);
     }
 
     /**
-     * Reads an unsigned short (16-bit) from an InputStream. The value is
-     * converted to the opposed endian system while reading.
+     * Reads an unsigned short (16-bit) from an InputStream in little endian order.
+     *
      * @param input source InputStream
      * @return the value just read
      * @throws IOException in case of an I/O problem
@@ -240,7 +257,12 @@ public static int readSwappedUnsignedShort(final InputStream input) throws IOExc
     }
 
     /**
-     * Converts a "double" value between endian systems.
+     * Converts a {@code double} value from big endian to little endian
+     * and vice versa. That is, it converts the {@code double} to bytes,
+     * reverses the bytes, and then reinterprets those bytes as a new {@code double}.
+     * This can be useful if you have a number that was read from the
+     * underlying source in the wrong endianness.
+     *
      * @param value value to convert
      * @return the converted value
      */
@@ -249,7 +271,8 @@ public static double swapDouble(final double value) {
     }
 
     /**
-     * Converts a "float" value between endian systems.
+     * Converts a {@code float} value from big endian to little endian and vice versa.
+     *
      * @param value value to convert
      * @return the converted value
      */
@@ -258,7 +281,8 @@ public static float swapFloat(final float value) {
     }
 
     /**
-     * Converts an "int" value between endian systems.
+     * Converts an {@code int} value from big endian to little endian and vice versa.
+     *
      * @param value value to convert
      * @return the converted value
      */
@@ -271,7 +295,8 @@ public static int swapInteger(final int value) {
     }
 
     /**
-     * Converts a "long" value between endian systems.
+     * Converts a {@code long} value from big endian to little endian and vice versa.
+     *
      * @param value value to convert
      * @return the converted value
      */
@@ -288,7 +313,8 @@ public static long swapLong(final long value) {
     }
 
     /**
-     * Converts a "short" value between endian systems.
+     * Converts a {@code short} value from big endian to little endian and vice versa.
+     *
      * @param value value to convert
      * @return the converted value
      */
@@ -298,19 +324,34 @@ public static short swapShort(final short value) {
     }
 
     /**
-     * Writes a "double" value to a byte array at a given offset. The value is
-     * converted to the opposed endian system while writing.
+     * Validates if the provided byte array has enough data.
+     *
+     * @param data the input byte array
+     * @param offset the input offset
+     * @param byteNeeded the needed number of bytes
+     * @throws IllegalArgumentException if the byte array does not have enough data
+     */
+    private static void validateByteArrayOffset(final byte[] data, final int offset, final int byteNeeded) {
+        if (data.length < offset + byteNeeded) {
+            throw new IllegalArgumentException("Data only has " + data.length + "bytes, needed " + (offset + byteNeeded) + "bytes.");
+        }
+    }
+
+    /**
+     * Writes the 8 bytes of a {@code double} to a byte array at a given offset in little endian order.
+     *
      * @param data target byte array
      * @param offset starting offset in the byte array
      * @param value value to write
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 8 bytes
      */
     public static void writeSwappedDouble(final byte[] data, final int offset, final double value) {
         writeSwappedLong(data, offset, Double.doubleToLongBits(value));
     }
 
     /**
-     * Writes a "double" value to an OutputStream. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 8 bytes of a {@code double} to an output stream in little endian order.
+     *
      * @param output target OutputStream
      * @param value value to write
      * @throws IOException in case of an I/O problem
@@ -320,35 +361,38 @@ public static void writeSwappedDouble(final OutputStream output, final double va
     }
 
     /**
-     * Writes a "float" value to a byte array at a given offset. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 4 bytes of a {@code float} to a byte array at a given offset in little endian order.
+     *
      * @param data target byte array
      * @param offset starting offset in the byte array
      * @param value value to write
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 4 bytes
      */
     public static void writeSwappedFloat(final byte[] data, final int offset, final float value) {
         writeSwappedInteger(data, offset, Float.floatToIntBits(value));
     }
 
     /**
-     * Writes a "float" value to an OutputStream. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 4 bytes of a {@code float} to an output stream in little endian order.
+     *
      * @param output target OutputStream
      * @param value value to write
      * @throws IOException in case of an I/O problem
-     */
+    */
     public static void writeSwappedFloat(final OutputStream output, final float value) throws IOException {
         writeSwappedInteger(output, Float.floatToIntBits(value));
     }
 
     /**
-     * Writes an "int" value to a byte array at a given offset. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 4 bytes of an {@code int} to a byte array at a given offset in little endian order.
+     *
      * @param data target byte array
      * @param offset starting offset in the byte array
      * @param value value to write
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 4 bytes
      */
     public static void writeSwappedInteger(final byte[] data, final int offset, final int value) {
+        validateByteArrayOffset(data, offset, Integer.SIZE / Byte.SIZE);
         data[offset + 0] = (byte) (value >> 0 & 0xff);
         data[offset + 1] = (byte) (value >> 8 & 0xff);
         data[offset + 2] = (byte) (value >> 16 & 0xff);
@@ -356,7 +400,7 @@ public static void writeSwappedInteger(final byte[] data, final int offset, fina
     }
 
     /**
-     * Writes an "int" value to an OutputStream. The value is converted to the opposed endian system while writing.
+     * Writes the 4 bytes of an {@code int} to an output stream in little endian order.
      *
      * @param output target OutputStream
      * @param value value to write
@@ -370,13 +414,15 @@ public static void writeSwappedInteger(final OutputStream output, final int valu
     }
 
     /**
-     * Writes a "long" value to a byte array at a given offset. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 8 bytes of a {@code long} to a byte array at a given offset in little endian order.
+     *
      * @param data target byte array
      * @param offset starting offset in the byte array
      * @param value value to write
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 8 bytes
      */
     public static void writeSwappedLong(final byte[] data, final int offset, final long value) {
+        validateByteArrayOffset(data, offset, Long.SIZE / Byte.SIZE);
         data[offset + 0] = (byte) (value >> 0 & 0xff);
         data[offset + 1] = (byte) (value >> 8 & 0xff);
         data[offset + 2] = (byte) (value >> 16 & 0xff);
@@ -388,8 +434,8 @@ public static void writeSwappedLong(final byte[] data, final int offset, final l
     }
 
     /**
-     * Writes a "long" value to an OutputStream. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 8 bytes of a {@code long} to an output stream in little endian order.
+     *
      * @param output target OutputStream
      * @param value value to write
      * @throws IOException in case of an I/O problem
@@ -406,20 +452,22 @@ public static void writeSwappedLong(final OutputStream output, final long value)
     }
 
     /**
-     * Writes a "short" value to a byte array at a given offset. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 2 bytes of a {@code short} to a byte array at a given offset in little endian order.
+     *
      * @param data target byte array
      * @param offset starting offset in the byte array
      * @param value value to write
+     * @throws IllegalArgumentException if the part of the byte array starting at offset does not have at least 2 bytes
      */
     public static void writeSwappedShort(final byte[] data, final int offset, final short value) {
-        data[offset + 0] = (byte)(value >> 0 & 0xff);
-        data[offset + 1] = (byte)(value >> 8 & 0xff);
+        validateByteArrayOffset(data, offset, Short.SIZE / Byte.SIZE);
+        data[offset + 0] = (byte) (value >> 0 & 0xff);
+        data[offset + 1] = (byte) (value >> 8 & 0xff);
     }
 
     /**
-     * Writes a "short" value to an OutputStream. The value is
-     * converted to the opposed endian system while writing.
+     * Writes the 2 bytes of a {@code short} to an output stream using little endian encoding.
+     *
      * @param output target OutputStream
      * @param value value to write
      * @throws IOException in case of an I/O problem
@@ -431,7 +479,11 @@ public static void writeSwappedShort(final OutputStream output, final short valu
 
     /**
      * Instances should NOT be constructed in standard programming.
+     *
+     * @deprecated TODO Make private in 3.0.
      */
+    @Deprecated
     public EndianUtils() {
+        // empty
     }
 }
diff --git a/src/main/java/org/apache/commons/io/FileCleaner.java b/src/main/java/org/apache/commons/io/FileCleaner.java
index 609d34be..d748e257 100644
--- a/src/main/java/org/apache/commons/io/FileCleaner.java
+++ b/src/main/java/org/apache/commons/io/FileCleaner.java
@@ -71,7 +71,7 @@ public static synchronized void exitWhenFinished() {
     }
 
     /**
-     * Returns the singleton instance, which is used by the deprecated, static methods.
+     * Gets the singleton instance, which is used by the deprecated, static methods.
      * This is mainly useful for code, which wants to support the new
      * {@link FileCleaningTracker} class while maintain compatibility with the
      * deprecated {@link FileCleaner}.
@@ -83,7 +83,7 @@ public static FileCleaningTracker getInstance() {
     }
 
     /**
-     * Retrieve the number of files currently being tracked, and therefore
+     * Gets the number of files currently being tracked, and therefore
      * awaiting deletion.
      *
      * @return the number of files being tracked
diff --git a/src/main/java/org/apache/commons/io/FileCleaningTracker.java b/src/main/java/org/apache/commons/io/FileCleaningTracker.java
index 98c33b0d..02de332b 100644
--- a/src/main/java/org/apache/commons/io/FileCleaningTracker.java
+++ b/src/main/java/org/apache/commons/io/FileCleaningTracker.java
@@ -54,7 +54,7 @@ private final class Reaper extends Thread {
         /** Constructs a new Reaper */
         Reaper() {
             super("File Reaper");
-            setPriority(Thread.MAX_PRIORITY);
+            setPriority(MAX_PRIORITY);
             setDaemon(true);
         }
 
@@ -122,7 +122,7 @@ public boolean delete() {
         }
 
         /**
-         * Return the path.
+         * Gets the path.
          *
          * @return the path
          */
@@ -209,13 +209,13 @@ public synchronized void exitWhenFinished() {
     }
 
     /**
-     * Gets the file paths that failed to delete.
+     * Gets a copy of the file paths that failed to delete.
      *
-     * @return the file paths that failed to delete
+     * @return a copy of the file paths that failed to delete
      * @since 2.0
      */
     public List<String> getDeleteFailures() {
-        return deleteFailures;
+        return new ArrayList<>(deleteFailures);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/FileExistsException.java b/src/main/java/org/apache/commons/io/FileExistsException.java
index 22642566..c44aee84 100644
--- a/src/main/java/org/apache/commons/io/FileExistsException.java
+++ b/src/main/java/org/apache/commons/io/FileExistsException.java
@@ -32,7 +32,7 @@ public class FileExistsException extends IOException {
     private static final long serialVersionUID = 1L;
 
     /**
-     * Default Constructor.
+     * Constructs a new instance.
      */
     public FileExistsException() {
     }
diff --git a/src/main/java/org/apache/commons/io/FileSystem.java b/src/main/java/org/apache/commons/io/FileSystem.java
index c7dbdfa8..566389f9 100644
--- a/src/main/java/org/apache/commons/io/FileSystem.java
+++ b/src/main/java/org/apache/commons/io/FileSystem.java
@@ -76,20 +76,27 @@ public enum FileSystem {
      * @see <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea#consoles">
      *      CreateFileA function - Consoles (microsoft.com)</a>
      */
+    // @formatter:off
     WINDOWS(4096, false, true,
             255, 32000, // KEEP THIS ARRAY SORTED!
             new int[] {
                     // KEEP THIS ARRAY SORTED!
-                    // @formatter:off
                     // ASCII NUL
                     0,
                     // 1-31 may be allowed in file streams
                     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
                     29, 30, 31,
                     '"', '*', '/', ':', '<', '>', '?', '\\', '|'
-                    // @formatter:on
-            }, new String[] { "AUX", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "CON", "CONIN$", "CONOUT$",
-                            "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9", "NUL", "PRN" }, true, true, '\\');
+            }, new String[] {
+                    "AUX",
+                    "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
+                    "COM\u00b2", "COM\u00b3", "COM\u00b9", // Superscript 2 3 1 in that order
+                    "CON", "CONIN$", "CONOUT$",
+                    "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9",
+                    "LPT\u00b2", "LPT\u00b3", "LPT\u00b9", // Superscript 2 3 1 in that order
+                    "NUL", "PRN"
+            }, true, true, '\\');
+    // @formatter:on
 
     /**
      * <p>
@@ -204,15 +211,15 @@ private static String getSystemProperty(final String property) {
      * object at an index no smaller than {@code start}, then
      * the index of the first such occurrence is returned. For values
      * of {@code searchChar} in the range from 0 to 0xFFFF (inclusive),
-     * this is the smallest value <i>k</i> such that:
+     * this is the smallest value <em>k</em> such that:
      * </p>
      * <blockquote><pre>
-     * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &gt;= start)
+     * (this.charAt(<em>k</em>) == searchChar) &amp;&amp; (<em>k</em> &gt;= start)
      * </pre></blockquote>
      * is true. For other values of {@code searchChar}, it is the
-     * smallest value <i>k</i> such that:
+     * smallest value <em>k</em> such that:
      * <blockquote><pre>
-     * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &gt;= start)
+     * (this.codePointAt(<em>k</em>) == searchChar) &amp;&amp; (<em>k</em> &gt;= start)
      * </pre></blockquote>
      * <p>
      * is true. In either case, if no such character occurs in {@code cs}
@@ -331,6 +338,7 @@ private static String replace(final String path, final char oldChar, final char
         this.maxPathLength = maxPathLength;
         this.illegalFileNameChars = Objects.requireNonNull(illegalFileNameChars, "illegalFileNameChars");
         this.reservedFileNames = Objects.requireNonNull(reservedFileNames, "reservedFileNames");
+        //Arrays.sort(this.reservedFileNames);
         this.reservedFileNamesExtensions = reservedFileNamesExtensions;
         this.caseSensitive = caseSensitive;
         this.casePreserving = casePreserving;
diff --git a/src/main/java/org/apache/commons/io/FileSystemUtils.java b/src/main/java/org/apache/commons/io/FileSystemUtils.java
index 0476f4d8..cfa10205 100644
--- a/src/main/java/org/apache/commons/io/FileSystemUtils.java
+++ b/src/main/java/org/apache/commons/io/FileSystemUtils.java
@@ -16,140 +16,68 @@
  */
 package org.apache.commons.io;
 
-import java.io.BufferedReader;
+import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.nio.charset.Charset;
-import java.time.Duration;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Locale;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.Objects;
-import java.util.StringTokenizer;
-import java.util.stream.Collectors;
 
 /**
  * General File System utilities.
  * <p>
- * This class provides static utility methods for general file system
- * functions not provided via the JDK {@link java.io.File File} class.
+ * This class provides static utility methods for general file system functions not provided before Java 6's {@link File File} class.
+ * </p>
  * <p>
  * The current functions provided are:
+ * </p>
  * <ul>
- * <li>Get the free space on a drive
+ * <li>Get the free space on a drive</li>
  * </ul>
  *
  * @since 1.1
- * @deprecated As of 2.6 deprecated without replacement. Use equivalent
- *  methods in {@link java.nio.file.FileStore} instead, e.g.
- *  {@code Files.getFileStore(Paths.get("/home")).getUsableSpace()}
- *  or iterate over {@code FileSystems.getDefault().getFileStores()}
+ * @deprecated As of 2.6 deprecated without replacement. Use equivalent methods in {@link java.nio.file.FileStore} instead,
+ *             {@code Files.getFileStore(Paths.get("/home")).getUsableSpace()} or iterate over {@code FileSystems.getDefault().getFileStores()}
  */
 @Deprecated
 public class FileSystemUtils {
 
-    /** Singleton instance, used mainly for testing. */
-    private static final FileSystemUtils INSTANCE = new FileSystemUtils();
-
-    /** Operating system state flag for error. */
-    private static final int INIT_PROBLEM = -1;
-    /** Operating system state flag for neither Unix nor Windows. */
-    private static final int OTHER = 0;
-    /** Operating system state flag for Windows. */
-    private static final int WINDOWS = 1;
-    /** Operating system state flag for Unix. */
-    private static final int UNIX = 2;
-    /** Operating system state flag for Posix flavour Unix. */
-    private static final int POSIX_UNIX = 3;
-
-    /** The operating system flag. */
-    private static final int OS;
-
-    /** The path to df */
-    private static final String DF;
-
-    static {
-        int os = OTHER;
-        String dfPath = "df";
-        try {
-            String osName = System.getProperty("os.name");
-            if (osName == null) {
-                throw new IOException("os.name not found");
-            }
-            osName = osName.toLowerCase(Locale.ENGLISH);
-            // match
-            if (osName.contains("windows")) {
-                os = WINDOWS;
-            } else if (osName.contains("linux") ||
-                    osName.contains("mpe/ix") ||
-                    osName.contains("freebsd") ||
-                    osName.contains("openbsd") ||
-                    osName.contains("irix") ||
-                    osName.contains("digital unix") ||
-                    osName.contains("unix") ||
-                    osName.contains("mac os x")) {
-                os = UNIX;
-            } else if (osName.contains("sun os") ||
-                    osName.contains("sunos") ||
-                    osName.contains("solaris")) {
-                os = POSIX_UNIX;
-                dfPath = "/usr/xpg4/bin/df";
-            } else if (osName.contains("hp-ux") ||
-                    osName.contains("aix")) {
-                os = POSIX_UNIX;
-            }
-
-        } catch (final Exception ex) {
-            os = INIT_PROBLEM;
-        }
-        OS = os;
-        DF = dfPath;
-    }
-
     /**
-     * Returns the free space on a drive or volume by invoking
-     * the command line.
-     * This method does not normalize the result, and typically returns
-     * bytes on Windows, 512 byte units on OS X and kilobytes on Unix.
-     * As this is not very useful, this method is deprecated in favor
-     * of {@link #freeSpaceKb(String)} which returns a result in kilobytes.
+     * Gets the number of kibibytes (1024 bytes) available to this Java virtual machine on the given file store.
      * <p>
-     * Note that some OS's are NOT currently supported, including OS/390,
-     * OpenVMS.
+     * Note that some OS's are NOT currently supported, including OS/390, OpenVMS.
+     * </p>
+     *
      * <pre>
-     * FileSystemUtils.freeSpace("C:");       // Windows
-     * FileSystemUtils.freeSpace("/volume");  // *nix
+     * FileSystemUtils.freeSpace("C:"); // Windows
+     * FileSystemUtils.freeSpace("/volume"); // *nix
      * </pre>
-     * The free space is calculated via the command line.
-     * It uses 'dir /-c' on Windows and 'df' on *nix.
      *
-     * @param path  the path to get free space for, not null, not empty on Unix
+     * @param path the path to get free space for, not null, not empty on UNIX
      * @return the amount of free drive space on the drive or volume
-     * @throws IllegalArgumentException if the path is invalid
-     * @throws IllegalStateException if an error occurred in initialization
-     * @throws IOException if an error occurs when finding the free space
+     * @throws IOException              if an I/O error occurs.
+     * @throws IllegalArgumentException if the path is invalid.
      * @since 1.1, enhanced OS support in 1.2 and 1.3
-     * @deprecated Use freeSpaceKb(String)
-     *  Deprecated from 1.3, may be removed in 2.0
+     * @deprecated Use freeSpaceKb(String) Deprecated from 1.3, may be removed in 2.0
      */
     @Deprecated
     public static long freeSpace(final String path) throws IOException {
-        return INSTANCE.freeSpaceOS(path, OS, false, Duration.ofMillis(-1));
+        return getFreeSpace(path);
     }
 
     /**
-     * Returns the free space for the working directory
-     * in kibibytes (1024 bytes) by invoking the command line.
+     * Gets the number of kibibytes (1024 bytes) available to this Java virtual machine on the current file store.
      * <p>
      * Identical to:
+     * </p>
+     *
      * <pre>
      * freeSpaceKb(FileUtils.current().getAbsolutePath())
      * </pre>
+     *
      * @return the amount of free drive space on the drive or volume in kilobytes
-     * @throws IllegalStateException if an error occurred in initialization
-     * @throws IOException if an error occurs when finding the free space
+     * @throws IOException              if an I/O error occurs.
+     * @throws IllegalArgumentException if the path is invalid.
      * @since 2.0
      * @deprecated As of 2.6 deprecated without replacement. Please use {@link java.nio.file.FileStore#getUsableSpace()}.
      */
@@ -159,18 +87,19 @@ public static long freeSpaceKb() throws IOException {
     }
 
     /**
-     * Returns the free space for the working directory
-     * in kibibytes (1024 bytes) by invoking the command line.
+     * Gets the number of kibibytes (1024 bytes) available to this Java virtual machine on the current file store.
      * <p>
      * Identical to:
+     * </p>
+     *
      * <pre>
      * freeSpaceKb(FileUtils.current().getAbsolutePath())
      * </pre>
-     * @param timeout The timeout amount in milliseconds or no timeout if the value
-     *  is zero or less
+     *
+     * @param timeout ignored.
      * @return the amount of free drive space on the drive or volume in kilobytes
-     * @throws IllegalStateException if an error occurred in initialization
-     * @throws IOException if an error occurs when finding the free space
+     * @throws IOException              if an I/O error occurs.
+     * @throws IllegalArgumentException if the path is invalid.
      * @since 2.0
      * @deprecated As of 2.6 deprecated without replacement. Please use {@link java.nio.file.FileStore#getUsableSpace()}.
      */
@@ -178,28 +107,19 @@ public static long freeSpaceKb() throws IOException {
     public static long freeSpaceKb(final long timeout) throws IOException {
         return freeSpaceKb(FileUtils.current().getAbsolutePath(), timeout);
     }
+
     /**
-     * Returns the free space on a drive or volume in kibibytes (1024 bytes)
-     * by invoking the command line.
+     * Gets the number of kibibytes (1024 bytes) available to this Java virtual machine on the given file store.
+     *
      * <pre>
-     * FileSystemUtils.freeSpaceKb("C:");       // Windows
-     * FileSystemUtils.freeSpaceKb("/volume");  // *nix
+     * FileSystemUtils.freeSpaceKb("C:"); // Windows
+     * FileSystemUtils.freeSpaceKb("/volume"); // *nix
      * </pre>
-     * The free space is calculated via the command line.
-     * It uses 'dir /-c' on Windows, 'df -kP' on AIX/HP-UX and 'df -k' on other Unix.
-     * <p>
-     * In order to work, you must be running Windows, or have an implementation of
-     * Unix df that supports GNU format when passed -k (or -kP). If you are going
-     * to rely on this code, please check that it works on your OS by running
-     * some simple tests to compare the command line with the output from this class.
-     * If your operating system isn't supported, please raise a JIRA call detailing
-     * the exact result from df -k and as much other detail as possible, thanks.
      *
-     * @param path  the path to get free space for, not null, not empty on Unix
+     * @param path the path to get free space for, not null, not empty on UNIX
      * @return the amount of free drive space on the drive or volume in kilobytes
-     * @throws IllegalArgumentException if the path is invalid
-     * @throws IllegalStateException if an error occurred in initialization
-     * @throws IOException if an error occurs when finding the free space
+     * @throws IOException              if an I/O error occurs.
+     * @throws IllegalArgumentException if the path is invalid.
      * @since 1.2, enhanced OS support in 1.3
      * @deprecated As of 2.6 deprecated without replacement. Please use {@link java.nio.file.FileStore#getUsableSpace()}.
      */
@@ -209,303 +129,57 @@ public static long freeSpaceKb(final String path) throws IOException {
     }
 
     /**
-     * Returns the free space on a drive or volume in kibibytes (1024 bytes)
-     * by invoking the command line.
+     * Gets the number of kibibytes (1024 bytes) available to this Java virtual machine on the given file store.
+     *
      * <pre>
-     * FileSystemUtils.freeSpaceKb("C:");       // Windows
-     * FileSystemUtils.freeSpaceKb("/volume");  // *nix
+     * FileSystemUtils.freeSpaceKb("C:"); // Windows
+     * FileSystemUtils.freeSpaceKb("/volume"); // *nix
      * </pre>
-     * The free space is calculated via the command line.
-     * It uses 'dir /-c' on Windows, 'df -kP' on AIX/HP-UX and 'df -k' on other Unix.
-     * <p>
-     * In order to work, you must be running Windows, or have an implementation of
-     * Unix df that supports GNU format when passed -k (or -kP). If you are going
-     * to rely on this code, please check that it works on your OS by running
-     * some simple tests to compare the command line with the output from this class.
-     * If your operating system isn't supported, please raise a JIRA call detailing
-     * the exact result from df -k and as much other detail as possible, thanks.
      *
-     * @param path  the path to get free space for, not null, not empty on Unix
-     * @param timeout The timeout amount in milliseconds or no timeout if the value
-     *  is zero or less
+     * @param path    the path to get free space for, not null, not empty on UNIX
+     * @param timeout ignored.
      * @return the amount of free drive space on the drive or volume in kilobytes
-     * @throws IllegalArgumentException if the path is invalid
-     * @throws IllegalStateException if an error occurred in initialization
-     * @throws IOException if an error occurs when finding the free space
+     * @throws IOException              if an I/O error occurs.
+     * @throws IllegalArgumentException if the path is invalid.
      * @since 2.0
      * @deprecated As of 2.6 deprecated without replacement. Please use {@link java.nio.file.FileStore#getUsableSpace()}.
      */
     @Deprecated
     public static long freeSpaceKb(final String path, final long timeout) throws IOException {
-        return INSTANCE.freeSpaceOS(path, OS, true, Duration.ofMillis(timeout));
-    }
-
-    /**
-     * Instances should NOT be constructed in standard programming.
-     */
-    public FileSystemUtils() {
+        return getFreeSpace(path) / FileUtils.ONE_KB;
     }
 
     /**
-     * Returns the free space on a drive or volume in a cross-platform manner.
-     * Note that some OS's are NOT currently supported, including OS/390.
+     * Gets the number of bytes available to this Java virtual machine on the given file store.
+     *
      * <pre>
-     * FileSystemUtils.freeSpace("C:");  // Windows
-     * FileSystemUtils.freeSpace("/volume");  // *nix
+     * FileSystemUtils.freeSpace("C:"); // Windows
+     * FileSystemUtils.freeSpace("/volume"); // *nix
      * </pre>
-     * The free space is calculated via the command line.
-     * It uses 'dir /-c' on Windows and 'df' on *nix.
      *
-     * @param path  the path to get free space for, not null, not empty on Unix
-     * @param os  the operating system code
-     * @param kb  whether to normalize to kilobytes
-     * @param timeout The timeout amount in milliseconds or no timeout if the value
-     *  is zero or less
+     * @param pathStr the path to get free space for, not null, not empty on UNIX
      * @return the amount of free drive space on the drive or volume
-     * @throws IllegalArgumentException if the path is invalid
-     * @throws IllegalStateException if an error occurred in initialization
-     * @throws IOException if an error occurs when finding the free space
-     */
-    long freeSpaceOS(final String path, final int os, final boolean kb, final Duration timeout) throws IOException {
-        Objects.requireNonNull(path, "path");
-        switch (os) {
-        case WINDOWS:
-            return kb ? freeSpaceWindows(path, timeout) / FileUtils.ONE_KB : freeSpaceWindows(path, timeout);
-        case UNIX:
-            return freeSpaceUnix(path, kb, false, timeout);
-        case POSIX_UNIX:
-            return freeSpaceUnix(path, kb, true, timeout);
-        case OTHER:
-            throw new IllegalStateException("Unsupported operating system");
-        default:
-            throw new IllegalStateException("Exception caught when determining operating system");
-        }
-    }
-
-    /**
-     * Find free space on the *nix platform using the 'df' command.
-     *
-     * @param path  the path to get free space for
-     * @param kb  whether to normalize to kilobytes
-     * @param posix  whether to use the POSIX standard format flag
-     * @param timeout The timeout amount in milliseconds or no timeout if the value
-     *  is zero or less
-     * @return the amount of free drive space on the volume
-     * @throws IOException If an I/O error occurs
-     */
-    long freeSpaceUnix(final String path, final boolean kb, final boolean posix, final Duration timeout)
-            throws IOException {
-        if (path.isEmpty()) {
-            throw new IllegalArgumentException("Path must not be empty");
-        }
-
-        // build and run the 'dir' command
-        String flags = "-";
-        if (kb) {
-            flags += "k";
-        }
-        if (posix) {
-            flags += "P";
-        }
-        final String[] cmdAttribs = flags.length() > 1 ? new String[] { DF, flags, path } : new String[] { DF, path };
-
-        // perform the command, asking for up to 3 lines (header, interesting, overflow)
-        final List<String> lines = performCommand(cmdAttribs, 3, timeout);
-        if (lines.size() < 2) {
-            // unknown problem, throw exception
-            throw new IOException("Command line '" + DF + "' did not return info as expected for path '" + path + "'- response was " + lines);
-        }
-        final String line2 = lines.get(1); // the line we're interested in
-
-        // Now, we tokenize the string. The fourth element is what we want.
-        StringTokenizer tok = new StringTokenizer(line2, " ");
-        if (tok.countTokens() < 4) {
-            // could be long Filesystem, thus data on third line
-            if (tok.countTokens() != 1 || lines.size() < 3) {
-                throw new IOException("Command line '" + DF + "' did not return data as expected for path '" + path + "'- check path is valid");
-            }
-            final String line3 = lines.get(2); // the line may be interested in
-            tok = new StringTokenizer(line3, " ");
-        } else {
-            tok.nextToken(); // Ignore Filesystem
-        }
-        tok.nextToken(); // Ignore 1K-blocks
-        tok.nextToken(); // Ignore Used
-        final String freeSpace = tok.nextToken();
-        return parseBytes(freeSpace, path);
-    }
-
-    /**
-     * Find free space on the Windows platform using the 'dir' command.
-     *
-     * @param path  the path to get free space for, including the colon
-     * @param timeout The timeout amount in milliseconds or no timeout if the value
-     *  is zero or less
-     * @return the amount of free drive space on the drive
-     * @throws IOException If an I/O error occurs
-     */
-    long freeSpaceWindows(final String path, final Duration timeout) throws IOException {
-        String normPath = FilenameUtils.normalize(path, false);
-        if (normPath == null) {
-            throw new IllegalArgumentException(path);
-        }
-        if (!normPath.isEmpty() && normPath.charAt(0) != '"') {
-            normPath = "\"" + normPath + "\"";
-        }
-
-        // build and run the 'dir' command
-        final String[] cmdAttribs = { "cmd.exe", "/C", "dir /a /-c " + normPath };
-
-        // read in the output of the command to an ArrayList
-        final List<String> lines = performCommand(cmdAttribs, Integer.MAX_VALUE, timeout);
-
-        // now iterate over the lines we just read and find the LAST
-        // non-empty line (the free space bytes should be in the last element
-        // of the ArrayList anyway, but this will ensure it works even if it's
-        // not, still assuming it is on the last non-blank line)
-        for (int i = lines.size() - 1; i >= 0; i--) {
-            final String line = lines.get(i);
-            if (!line.isEmpty()) {
-                return parseDir(line, normPath);
-            }
-        }
-        // all lines are blank
-        throw new IOException("Command line 'dir /-c' did not return any info for path '" + normPath + "'");
-    }
-
-    /**
-     * Opens the process to the operating system.
-     *
-     * @param cmdAttribs  the command line parameters
-     * @return the process
-     * @throws IOException If an I/O error occurs
-     */
-    Process openProcess(final String[] cmdAttribs) throws IOException {
-        return Runtime.getRuntime().exec(cmdAttribs);
-    }
-
-    /**
-     * Parses the bytes from a string.
-     *
-     * @param freeSpace  the free space string
-     * @param path  the path
-     * @return the number of bytes
-     * @throws IOException If an I/O error occurs
+     * @throws IOException              if an I/O error occurs.
+     * @throws IllegalArgumentException if the path is invalid.
      */
-    long parseBytes(final String freeSpace, final String path) throws IOException {
-        try {
-            final long bytes = Long.parseLong(freeSpace);
-            if (bytes < 0) {
-                throw new IOException("Command line '" + DF + "' did not find free space in response for path '" + path + "'- check path is valid");
-            }
-            return bytes;
-
-        } catch (final NumberFormatException ex) {
-            throw new IOException("Command line '" + DF + "' did not return numeric data as expected for path '" + path + "'- check path is valid", ex);
-        }
-    }
-
-    /**
-     * Parses the Windows dir response last line
-     *
-     * @param line  the line to parse
-     * @param path  the path that was sent
-     * @return the number of bytes
-     * @throws IOException If an I/O error occurs
-     */
-    long parseDir(final String line, final String path) throws IOException {
-        // read from the end of the line to find the last numeric
-        // character on the line, then continue until we find the first
-        // non-numeric character, and everything between that and the last
-        // numeric character inclusive is our free space bytes count
-        int bytesStart = 0;
-        int bytesEnd = 0;
-        int j = line.length() - 1;
-        innerLoop1: while (j >= 0) {
-            final char c = line.charAt(j);
-            if (Character.isDigit(c)) {
-                // found the last numeric character, this is the end of
-                // the free space bytes count
-                bytesEnd = j + 1;
-                break innerLoop1;
-            }
-            j--;
-        }
-        innerLoop2: while (j >= 0) {
-            final char c = line.charAt(j);
-            if (!Character.isDigit(c) && c != ',' && c != '.') {
-                // found the next non-numeric character, this is the
-                // beginning of the free space bytes count
-                bytesStart = j + 1;
-                break innerLoop2;
-            }
-            j--;
-        }
-        if (j < 0) {
-            throw new IOException("Command line 'dir /-c' did not return valid info for path '" + path + "'");
-        }
-
-        // remove commas and dots in the bytes count
-        final StringBuilder buf = new StringBuilder(line.substring(bytesStart, bytesEnd));
-        for (int k = 0; k < buf.length(); k++) {
-            if (buf.charAt(k) == ',' || buf.charAt(k) == '.') {
-                buf.deleteCharAt(k--);
-            }
-        }
-        return parseBytes(buf.toString(), path);
+    static long getFreeSpace(final String pathStr) throws IOException {
+        final Path path = Paths.get(Objects.requireNonNull(pathStr, "pathStr"));
+        if (Files.exists(path)) {
+            // Need an absolute path for input like "" to work
+            return Files.getFileStore(path.toAbsolutePath()).getUsableSpace();
+            // return path.toAbsolutePath().toFile().getUsableSpace();
+        }
+        throw new IllegalArgumentException(path.toString());
     }
 
     /**
-     * Performs an OS command.
+     * Instances should NOT be constructed in standard programming.
      *
-     * @param cmdAttribs  the command line parameters
-     * @param max The maximum limit for the lines returned
-     * @param timeout The timeout amount in milliseconds or no timeout if the value
-     *  is zero or less
-     * @return the lines returned by the command, converted to lower-case
-     * @throws IOException if an error occurs
+     * @deprecated TODO Make private in 3.0.
      */
-    List<String> performCommand(final String[] cmdAttribs, final int max, final Duration timeout) throws IOException {
-        //
-        // This method does what it can to avoid the 'Too many open files' error
-        // based on trial and error and these links:
-        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4784692
-        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4801027
-        // http://forum.java.sun.com/thread.jspa?threadID=533029&messageID=2572018
-        // however, it's still not perfect as the JDK support is so poor
-        // (see commons-exec or Ant for a better multithreaded multi-OS solution)
-        //
-        final Process proc = openProcess(cmdAttribs);
-        final Thread monitor = ThreadMonitor.start(timeout);
-        try (InputStream in = proc.getInputStream();
-                OutputStream out = proc.getOutputStream();
-                // default Charset is most likely appropriate here
-                InputStream err = proc.getErrorStream();
-                // If in is null here, InputStreamReader throws NullPointerException
-                BufferedReader inr = new BufferedReader(new InputStreamReader(in, Charset.defaultCharset()))) {
-
-            final List<String> lines = inr.lines().limit(max).map(line -> line.toLowerCase(Locale.getDefault()).trim()).collect(Collectors.toList());
-            proc.waitFor();
-            ThreadMonitor.stop(monitor);
-
-            if (proc.exitValue() != 0) {
-                // Command problem, throw exception
-                throw new IOException("Command line returned OS error code '" + proc.exitValue() + "' for command " + Arrays.asList(cmdAttribs));
-            }
-            if (lines.isEmpty()) {
-                // Unknown problem, throw exception
-                throw new IOException("Command line did not return any info for command " + Arrays.asList(cmdAttribs));
-            }
-
-            return lines;
-
-        } catch (final InterruptedException ex) {
-            throw new IOException("Command line threw an InterruptedException for command " + Arrays.asList(cmdAttribs) + " timeout=" + timeout, ex);
-        } finally {
-            if (proc != null) {
-                proc.destroy();
-            }
-        }
+    @Deprecated
+    public FileSystemUtils() {
+        // empty
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java
index 80d100f1..4e61ed7a 100644
--- a/src/main/java/org/apache/commons/io/FileUtils.java
+++ b/src/main/java/org/apache/commons/io/FileUtils.java
@@ -23,6 +23,7 @@
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
+import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -41,6 +42,7 @@
 import java.nio.file.FileVisitResult;
 import java.nio.file.Files;
 import java.nio.file.LinkOption;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.NotDirectoryException;
 import java.nio.file.Path;
 import java.nio.file.StandardCopyOption;
@@ -57,6 +59,7 @@
 import java.time.chrono.ChronoLocalDateTime;
 import java.time.chrono.ChronoZonedDateTime;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
@@ -114,6 +117,8 @@
  */
 public class FileUtils {
 
+    private static final String PROTOCOL_FILE = "file";
+
     /**
      * The number of bytes in a kilobyte.
      */
@@ -204,7 +209,7 @@ public class FileUtils {
     /**
      * Returns a human-readable version of the file size, where the input represents a specific number of bytes.
      * <p>
-     * If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the
+     * If the size is over 1GB, the size is returned as the number of whole GB, the size is rounded down to the
      * nearest GB boundary.
      * </p>
      * <p>
@@ -243,7 +248,7 @@ public static String byteCountToDisplaySize(final BigInteger size) {
     /**
      * Returns a human-readable version of the file size, where the input represents a specific number of bytes.
      * <p>
-     * If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the
+     * If the size is over 1GB, the size is returned as the number of whole GB, the size is rounded down to the
      * nearest GB boundary.
      * </p>
      * <p>
@@ -262,7 +267,7 @@ public static String byteCountToDisplaySize(final long size) {
     /**
      * Returns a human-readable version of the file size, where the input represents a specific number of bytes.
      * <p>
-     * If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the
+     * If the size is over 1GB, the size is returned as the number of whole GB, the size is rounded down to the
      * nearest GB boundary.
      * </p>
      * <p>
@@ -279,6 +284,48 @@ public static String byteCountToDisplaySize(final Number size) {
         return byteCountToDisplaySize(size.longValue());
     }
 
+    /**
+     * Requires that the given {@link File} is non-null and exists (if strict is true).
+     *
+     * @param file The {@link File} to check.
+     * @param strict whether to check that the {@code file} exists.
+     * @throws FileNotFoundException if the file does not exist.
+     * @throws NullPointerException  if the given {@link File} is {@code null}.
+     */
+    private static void checkExists(final File file, final boolean strict) throws FileNotFoundException {
+        Objects.requireNonNull(file, PROTOCOL_FILE);
+        if (strict && !file.exists()) {
+            throw new FileNotFoundException(file.toString());
+        }
+    }
+
+    /**
+     * Requires that the given {@link File} exists, and throws a {@link FileNotFoundException} if it doesn't.
+     *
+     * @param file The {@link File} to check.
+     * @param name The NullPointerException message.
+     * @throws FileNotFoundException if the file does not exist.
+     * @throws NullPointerException  if the given {@link File} is {@code null}.
+     */
+    private static void checkFileExists(final File file, final String name) throws FileNotFoundException {
+        Objects.requireNonNull(file, name);
+        if (!file.isFile()) {
+            if (file.exists()) {
+                throw new IllegalArgumentException("Parameter '" + name + "' is not a file: " + file);
+            }
+            if (!Files.isSymbolicLink(file.toPath())) {
+                throw new FileNotFoundException("Source '" + file + "' does not exist");
+            }
+        }
+    }
+
+    private static File checkIsFile(final File file, final String name) {
+        if (file.isFile()) {
+            return file;
+        }
+        throw new IllegalArgumentException(String.format("Parameter '%s' is not a file: %s", name, file));
+    }
+
     /**
      * Computes the checksum of a file using the specified checksum object. Multiple files may be checked using one
      * {@link Checksum} instance if desired simply by reusing the same checksum object. For example:
@@ -292,13 +339,13 @@ public static String byteCountToDisplaySize(final Number size) {
      * @return the checksum specified, updated with the content of the file
      * @throws NullPointerException if the given {@link File} is {@code null}.
      * @throws NullPointerException if the given {@link Checksum} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist or is not a file.
+     * @throws IllegalArgumentException if the given {@link File} is not a file.
+     * @throws FileNotFoundException if the file does not exist
      * @throws IOException if an IO error occurs reading the file.
      * @since 1.3
      */
     public static Checksum checksum(final File file, final Checksum checksum) throws IOException {
-        requireExistsChecked(file, "file");
-        requireFile(file, "file");
+        checkFileExists(file, PROTOCOL_FILE);
         Objects.requireNonNull(checksum, "checksum");
         try (InputStream inputStream = new CheckedInputStream(Files.newInputStream(file.toPath()), checksum)) {
             IOUtils.consume(inputStream);
@@ -312,8 +359,8 @@ public static Checksum checksum(final File file, final Checksum checksum) throws
      *
      * @param file the file to checksum, must not be {@code null}
      * @return the checksum value
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist or is not a file.
+     * @throws NullPointerException if the {@code file} is {@code null}.
+     * @throws IllegalArgumentException if the {@code file} does not exist or is not a file.
      * @throws IOException              if an IO error occurs reading the file.
      * @since 1.3
      */
@@ -326,12 +373,12 @@ public static long checksumCRC32(final File file) throws IOException {
      *
      * @param directory directory to clean
      * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if directory does not exist or is not a directory.
+     * @throws IllegalArgumentException if the {@code directory} does not exist or is not a directory.
      * @throws IOException if an I/O error occurs.
      * @see #forceDelete(File)
      */
     public static void cleanDirectory(final File directory) throws IOException {
-        IOConsumer.forAll(FileUtils::forceDelete, listFiles(directory, null));
+        IOConsumer.forAll(f -> forceDelete(f, false), listFiles(directory, null));
     }
 
     /**
@@ -339,7 +386,7 @@ public static void cleanDirectory(final File directory) throws IOException {
      *
      * @param directory directory to clean, must not be {@code null}
      * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if directory does not exist or is not a directory.
+     * @throws IllegalArgumentException if the {@code directory} does not exist or is not a directory.
      * @throws IOException if an I/O error occurs.
      * @see #forceDeleteOnExit(File)
      */
@@ -378,8 +425,8 @@ public static boolean contentEquals(final File file1, final File file2) throws I
             return true;
         }
 
-        requireFile(file1, "file1");
-        requireFile(file2, "file2");
+        checkIsFile(file1, "file1");
+        checkIsFile(file2, "file2");
 
         if (file1.length() != file2.length()) {
             // lengths differ, cannot be equal
@@ -431,8 +478,8 @@ public static boolean contentEqualsIgnoreEOL(final File file1, final File file2,
             return true;
         }
 
-        requireFile(file1, "file1");
-        requireFile(file2, "file2");
+        checkFileExists(file1, "file1");
+        checkFileExists(file2, "file2");
 
         if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {
             // same file
@@ -459,28 +506,37 @@ public static File[] convertFileCollectionToFileArray(final Collection<File> fil
     }
 
     /**
-     * Copies a whole directory to a new location preserving the file dates.
+     * Copies a whole directory to a new location, preserving the file dates.
      * <p>
      * This method copies the specified directory and all its child directories and files to the specified destination.
-     * The destination is the new location and name of the directory.
+     * The destination is the new location and name of the directory. That is, copying /home/bar to /tmp/bang
+     * copies the contents of /home/bar into /tmp/bang. It does not create /tmp/bang/bar.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this
      * method merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
-     * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * <strong>Note:</strong> This method tries to preserve the file's last
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However it is
+     * not guaranteed that the operation will succeed. If the modification operation fails, it falls back to
+     * {@link File#setLastModified(long)}. If that fails, the method throws IOException.
+     * </p>
+     * <p>
+     * Symbolic links in the source directory are copied to new symbolic links in the destination
+     * directory that point to the original target. The target of the link is not copied unless
+     * it is also under the source directory. Even if it is under the source directory, the new symbolic
+     * link in the destination points to the original target in the source directory, not to the
+     * newly created copy of the target.
      * </p>
      *
      * @param srcDir an existing directory to copy, must not be {@code null}.
      * @param destDir the new directory, must not be {@code null}.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws IllegalArgumentException if the source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcDir} exists but is not a directory,
+     *     the source and the destination directory are the same
      * @throws FileNotFoundException if the source does not exist.
-     * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
+     * @throws IOException if an error occurs, the destination is not writable, or setting the last-modified time didn't succeed
      * @since 1.1
      */
     public static void copyDirectory(final File srcDir, final File destDir) throws IOException {
@@ -493,22 +549,22 @@ public static void copyDirectory(final File srcDir, final File destDir) throws I
      * This method copies the contents of the specified source directory to within the specified destination directory.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this
      * method merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the files' last
-     * modified date/times using {@link File#setLastModified(long)}, however it is not guaranteed that those operations
-     * will succeed. If the modification operation fails, the methods throws IOException.
+     * modified date/times using {@link File#setLastModified(long)}. However it is not guaranteed that those operations
+     * will succeed. If the modification operation fails, the method throws IOException.
      * </p>
      *
      * @param srcDir an existing directory to copy, must not be {@code null}.
      * @param destDir the new directory, must not be {@code null}.
      * @param preserveFileDate true if the file date of the copy should be the same as the original.
-     * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws IllegalArgumentException if the source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcDir} exists but is not a directory, or
+     *     the source and the destination directory are the same
      * @throws FileNotFoundException if the source does not exist.
-     * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
+     * @throws IOException if an error occurs, the destination is not writable, or setting the last-modified time didn't succeed
      * @since 1.1
      */
     public static void copyDirectory(final File srcDir, final File destDir, final boolean preserveFileDate)
@@ -522,27 +578,27 @@ public static void copyDirectory(final File srcDir, final File destDir, final bo
      * This method copies the contents of the specified source directory to within the specified destination directory.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this
      * method merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
      * <strong>Note:</strong> This method tries to preserve the files' last modified date/times using
-     * {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the
-     * modification operation fails, the methods throws IOException.
+     * {@link File#setLastModified(long)}. However it is not guaranteed that those operations will succeed. If the
+     * modification operation fails, the method throws IOException.
      * </p>
-     * <b>Example: Copy directories only</b>
+     * <strong>Example: Copy directories only</strong>
      *
      * <pre>
      * // only copy the directory structure
      * FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY);
      * </pre>
      *
-     * <b>Example: Copy directories and txt files</b>
+     * <strong>Example: Copy directories and txt files</strong>
      *
      * <pre>
      * // Create a filter for ".txt" files
      * IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
-     * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
+     * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.INSTANCE, txtSuffixFilter);
      *
      * // Create a filter for either directories or ".txt" files
      * FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
@@ -555,9 +611,10 @@ public static void copyDirectory(final File srcDir, final File destDir, final bo
      * @param destDir the new directory, must not be {@code null}.
      * @param filter the filter to apply, null means copy all directories and files should be the same as the original.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws IllegalArgumentException if the source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcDir} exists but is not a directory, or
+     *     the source and the destination directory are the same
      * @throws FileNotFoundException if the source does not exist.
-     * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
+     * @throws IOException if an error occurs, the destination is not writable, or setting the last-modified time didn't succeed
      * @since 1.4
      */
     public static void copyDirectory(final File srcDir, final File destDir, final FileFilter filter)
@@ -571,28 +628,28 @@ public static void copyDirectory(final File srcDir, final File destDir, final Fi
      * This method copies the contents of the specified source directory to within the specified destination directory.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this
      * method merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)}. If that fails, the method throws IOException.
      * </p>
-     * <b>Example: Copy directories only</b>
+     * <strong>Example: Copy directories only</strong>
      *
      * <pre>
      * // only copy the directory structure
      * FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY, false);
      * </pre>
      *
-     * <b>Example: Copy directories and txt files</b>
+     * <strong>Example: Copy directories and txt files</strong>
      *
      * <pre>
      * // Create a filter for ".txt" files
      * IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
-     * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
+     * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.INSTANCE, txtSuffixFilter);
      *
      * // Create a filter for either directories or ".txt" files
      * FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
@@ -606,13 +663,14 @@ public static void copyDirectory(final File srcDir, final File destDir, final Fi
      * @param filter the filter to apply, null means copy all directories and files.
      * @param preserveFileDate true if the file date of the copy should be the same as the original.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws IllegalArgumentException if the source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcDir} exists but is not a directory,
+     *     the source and the destination directory are the same, or the destination is not writable
      * @throws FileNotFoundException if the source does not exist.
      * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
      * @since 1.4
      */
     public static void copyDirectory(final File srcDir, final File destDir, final FileFilter filter, final boolean preserveFileDate) throws IOException {
-        copyDirectory(srcDir, destDir, filter, preserveFileDate, StandardCopyOption.REPLACE_EXISTING);
+        copyDirectory(srcDir, destDir, filter, preserveFileDate, StandardCopyOption.REPLACE_EXISTING, LinkOption.NOFOLLOW_LINKS);
     }
 
     /**
@@ -621,28 +679,28 @@ public static void copyDirectory(final File srcDir, final File destDir, final Fi
      * This method copies the contents of the specified source directory to within the specified destination directory.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this
      * method merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)}. If that fails, the method throws IOException.
      * </p>
-     * <b>Example: Copy directories only</b>
+     * <strong>Example: Copy directories only</strong>
      *
      * <pre>
      * // only copy the directory structure
      * FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY, false);
      * </pre>
      *
-     * <b>Example: Copy directories and txt files</b>
+     * <strong>Example: Copy directories and txt files</strong>
      *
      * <pre>
      * // Create a filter for ".txt" files
      * IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
-     * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
+     * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.INSTANCE, txtSuffixFilter);
      *
      * // Create a filter for either directories or ".txt" files
      * FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
@@ -657,15 +715,16 @@ public static void copyDirectory(final File srcDir, final File destDir, final Fi
      * @param preserveFileDate true if the file date of the copy should be the same as the original
      * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws IllegalArgumentException if the source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcDir} exists but is not a directory, or
+     *     the source and the destination directory are the same
      * @throws FileNotFoundException if the source does not exist.
-     * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
+     * @throws IOException if an error occurs, the destination is not writable, or setting the last-modified time didn't succeed
      * @since 2.8.0
      */
     public static void copyDirectory(final File srcDir, final File destDir, final FileFilter fileFilter, final boolean preserveFileDate,
         final CopyOption... copyOptions) throws IOException {
-        requireFileCopy(srcDir, destDir);
-        requireDirectory(srcDir, "srcDir");
+        Objects.requireNonNull(destDir, "destination");
+        requireDirectoryExists(srcDir, "srcDir");
         requireCanonicalPathsNotEquals(srcDir, destDir);
 
         // Cater for destination being directory within the source directory (see IO-141)
@@ -691,14 +750,14 @@ public static void copyDirectory(final File srcDir, final File destDir, final Fi
      * destination directory.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this
      * method merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)} and if that fails, the method throws IOException.
      * </p>
      *
      * @param sourceDir an existing directory to copy, must not be {@code null}.
@@ -706,11 +765,11 @@ public static void copyDirectory(final File srcDir, final File destDir, final Fi
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
      * @throws IllegalArgumentException if the source or destination is invalid.
      * @throws FileNotFoundException if the source does not exist.
-     * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
+     * @throws IOException if an error occurs, the destination is not writable, or setting the last-modified time didn't succeed
      * @since 1.2
      */
     public static void copyDirectoryToDirectory(final File sourceDir, final File destinationDir) throws IOException {
-        requireDirectoryIfExists(sourceDir, "sourceDir");
+        Objects.requireNonNull(sourceDir, "sourceDir");
         requireDirectoryIfExists(destinationDir, "destinationDir");
         copyDirectory(sourceDir, new File(destinationDir, sourceDir.getName()), true);
     }
@@ -720,13 +779,13 @@ public static void copyDirectoryToDirectory(final File sourceDir, final File des
      * <p>
      * This method copies the contents of the specified source file to the specified destination file. The directory
      * holding the destination file is created if it does not exist. If the destination file exists, then this method
-     * will overwrite it.
+     * overwrites it. A symbolic link is resolved before copying so the new file is not a link.
      * </p>
      * <p>
      * <strong>Note:</strong> This method tries to preserve the file's last modified date/times using
-     * {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is not guaranteed that the
-     * operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is not guaranteed that the
+     * operation will succeed. If the modification operation fails, it falls back to
+     * {@link File#setLastModified(long)}, and if that fails, the method throws IOException.
      * </p>
      *
      * @param srcFile an existing file to copy, must not be {@code null}.
@@ -747,13 +806,13 @@ public static void copyFile(final File srcFile, final File destFile) throws IOEx
      * <p>
      * This method copies the contents of the specified source file to the specified destination file. The directory
      * holding the destination file is created if it does not exist. If the destination file exists, then this method
-     * will overwrite it.
+     * overwrites it. A symbolic link is resolved before copying so the new file is not a link.
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails, it falls back to
+     * {@link File#setLastModified(long)}, and if that fails, the method throws IOException.
      * </p>
      *
      * @param srcFile an existing file to copy, must not be {@code null}.
@@ -770,44 +829,53 @@ public static void copyFile(final File srcFile, final File destFile, final boole
     }
 
     /**
-     * Copies a file to a new location.
+     * Copies the contents of a file to a new location.
      * <p>
      * This method copies the contents of the specified source file to the specified destination file. The directory
      * holding the destination file is created if it does not exist. If the destination file exists, you can overwrite
      * it with {@link StandardCopyOption#REPLACE_EXISTING}.
      * </p>
+     *
+     * <p>
+     * By default, a symbolic link is resolved before copying so the new file is not a link.
+     * To copy symbolic links as links, you can pass {@code LinkOption.NO_FOLLOW_LINKS} as the last argument.
+     * </p>
+     *
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails, it falls back to
+     * {@link File#setLastModified(long)}, and if that fails, the method throws IOException.
      * </p>
      *
      * @param srcFile an existing file to copy, must not be {@code null}.
      * @param destFile the new file, must not be {@code null}.
      * @param preserveFileDate true if the file date of the copy should be the same as the original.
-     * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}..
+     * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
      * @throws FileNotFoundException if the source does not exist.
-     * @throws IllegalArgumentException if source is not a file.
+     * @throws IllegalArgumentException if {@code srcFile} or {@code destFile} is not a file
      * @throws IOException if the output file length is not the same as the input file length after the copy completes.
-     * @throws IOException if an I/O error occurs, or setting the last-modified time didn't succeed.
+     * @throws IOException if an I/O error occurs, setting the last-modified time didn't succeed,
+     *     or the destination is not writable
      * @see #copyFileToDirectory(File, File, boolean)
      * @since 2.8.0
      */
     public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate, final CopyOption... copyOptions) throws IOException {
-        requireFileCopy(srcFile, destFile);
-        requireFile(srcFile, "srcFile");
+        Objects.requireNonNull(destFile, "destination");
+        checkFileExists(srcFile, "srcFile");
         requireCanonicalPathsNotEquals(srcFile, destFile);
         createParentDirectories(destFile);
-        requireFileIfExists(destFile, "destFile");
         if (destFile.exists()) {
-            requireCanWrite(destFile, "destFile");
+            checkFileExists(destFile, "destFile");
         }
-        Files.copy(srcFile.toPath(), destFile.toPath(), copyOptions);
+
+        final Path srcPath = srcFile.toPath();
+
+        Files.copy(srcPath, destFile.toPath(), copyOptions);
 
         // On Windows, the last modified time is copied by default.
-        if (preserveFileDate && !setTimes(srcFile, destFile)) {
+        if (preserveFileDate && !Files.isSymbolicLink(srcPath) && !setTimes(srcFile, destFile)) {
             throw new IOException("Cannot set the file time.");
         }
     }
@@ -822,7 +890,7 @@ public static void copyFile(final File srcFile, final File destFile, final boole
      *
      * @param srcFile an existing file to copy, must not be {@code null}.
      * @param destFile the new file, must not be {@code null}.
-     * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}..
+     * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
      * @throws FileNotFoundException if the source does not exist.
      * @throws IllegalArgumentException if source is not a file.
@@ -863,9 +931,9 @@ public static long copyFile(final File input, final OutputStream output) throws
      * </p>
      * <p>
      * <strong>Note:</strong> This method tries to preserve the file's last modified date/times using
-     * {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is not guaranteed that the
-     * operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is not guaranteed that the
+     * operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)} and if that fails, the method throws IOException.
      * </p>
      *
      * @param srcFile an existing file to copy, must not be {@code null}.
@@ -888,9 +956,9 @@ public static void copyFileToDirectory(final File srcFile, final File destDir) t
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)} and if that fails, the method throws IOException.
      * </p>
      *
      * @param sourceFile an existing file to copy, must not be {@code null}.
@@ -938,18 +1006,18 @@ public static void copyInputStreamToFile(final InputStream source, final File de
     /**
      * Copies a file or directory to within another directory preserving the file dates.
      * <p>
-     * This method copies the source file or directory, along all its contents, to a directory of the same name in the
+     * This method copies the source file or directory, along with all its contents, to a directory of the same name in the
      * specified destination directory.
      * </p>
      * <p>
-     * The destination directory is created if it does not exist. If the destination directory did exist, then this method
+     * The destination directory is created if it does not exist. If the destination directory does exist, then this method
      * merges the source with the destination, with the source taking precedence.
      * </p>
      * <p>
      * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)} and if that fails, the method throws IOException.
      * </p>
      *
      * @param sourceFile an existing file or directory to copy, must not be {@code null}.
@@ -982,10 +1050,10 @@ public static void copyToDirectory(final File sourceFile, final File destination
      * If the destination file exists, then this method will overwrite it.
      * </p>
      * <p>
-     * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
-     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}, however it is
-     * not guaranteed that the operation will succeed. If the modification operation fails it will fallback to
-     * {@link File#setLastModified(long)} and if that fails, the methods throws IOException.
+     * <strong>Note:</strong> This method tries to preserve the file's last
+     * modified date/times using {@link BasicFileAttributeView#setTimes(FileTime, FileTime, FileTime)}. However, it is
+     * not guaranteed that the operation will succeed. If the modification operation fails it falls back to
+     * {@link File#setLastModified(long)} and if that fails, the method throws IOException.
      * </p>
      *
      * @param sourceIterable  existing files to copy, must not be {@code null}.
@@ -1108,7 +1176,7 @@ public static File current() {
     }
 
     /**
-     * Decodes the specified URL as per RFC 3986, i.e. transforms
+     * Decodes the specified URL as per RFC 3986, transforming
      * percent-encoded octets to characters by decoding with the UTF-8 character
      * set. This function is primarily intended for usage with
      * {@link java.net.URL} which unfortunately does not enforce proper URLs. As
@@ -1136,7 +1204,7 @@ static String decodeUrl(final String url) {
                             i += 3;
                         } while (i < n && url.charAt(i) == '%');
                         continue;
-                    } catch (final RuntimeException ignored) {
+                    } catch (final IndexOutOfBoundsException | NumberFormatException ignored) {
                         // malformed percent-encoded octet, fall through and
                         // append characters literally
                     } finally {
@@ -1166,7 +1234,7 @@ static String decodeUrl(final String url) {
      * @since 2.9.0
      */
     public static File delete(final File file) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         Files.delete(file.toPath());
         return file;
     }
@@ -1249,7 +1317,7 @@ public static boolean deleteQuietly(final File file) {
      *
      * Edge cases:
      * <ul>
-     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>
+     * <li>A {@code directory} must not be null: if null, throw NullPointerException</li>
      * <li>A {@code directory} must be a directory: if not a directory, throw IllegalArgumentException</li>
      * <li>A directory does not contain itself: return false</li>
      * <li>A null child file is not contained in any parent: return false</li>
@@ -1259,15 +1327,15 @@ public static boolean deleteQuietly(final File file) {
      * @param child     the file to consider as the child.
      * @return true is the candidate leaf is under by the specified composite. False otherwise.
      * @throws IOException              if an IO error occurs while checking the files.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist or is not a directory.
+     * @throws NullPointerException if the parent is {@code null}.
+     * @throws IllegalArgumentException if the parent is not a directory.
      * @see FilenameUtils#directoryContains(String, String)
      * @since 2.2
      */
     public static boolean directoryContains(final File directory, final File child) throws IOException {
         requireDirectoryExists(directory, "directory");
 
-        if (child == null || !directory.exists() || !child.exists()) {
+        if (child == null || !child.exists()) {
             return false;
         }
 
@@ -1286,6 +1354,7 @@ public static boolean directoryContains(final File directory, final File child)
      * @param preserveDirDate preserve the directories last modified dates.
      * @param copyOptions options specifying how the copy should be done, see {@link StandardCopyOption}.
      * @throws IOException if the directory was not created along with all its parent directories.
+     * @throws IllegalArgumentException if {@code destDir} is not writable
      * @throws SecurityException See {@link File#mkdirs()}.
      */
     private static void doCopyDirectory(final File srcDir, final File destDir, final FileFilter fileFilter, final List<String> exclusionList,
@@ -1294,7 +1363,6 @@ private static void doCopyDirectory(final File srcDir, final File destDir, final
         final File[] srcFiles = listFiles(srcDir, fileFilter);
         requireDirectoryIfExists(destDir, "destDir");
         mkdirs(destDir);
-        requireCanWrite(destDir, "destDir");
         for (final File srcFile : srcFiles) {
             final File dstFile = new File(destDir, srcFile.getName());
             if (exclusionList == null || !exclusionList.contains(srcFile.getCanonicalPath())) {
@@ -1327,15 +1395,38 @@ private static void doCopyDirectory(final File srcDir, final File destDir, final
      * @throws IOException           in case deletion is unsuccessful.
      */
     public static void forceDelete(final File file) throws IOException {
-        Objects.requireNonNull(file, "file");
+        forceDelete(file, true);
+    }
+
+    /**
+     * Deletes a file or directory. For a directory, delete it and all subdirectories.
+     * <p>
+     * The difference between File.delete() and this method are:
+     * </p>
+     * <ul>
+     * <li>The directory does not have to be empty.</li>
+     * <li>You get an exception when a file or directory cannot be deleted.</li>
+     * </ul>
+     *
+     * @param file file or directory to delete, must not be {@code null}.
+     * @param strict whether to throw a FileNotFoundException.
+     * @throws NullPointerException  if the file is {@code null}.
+     * @throws FileNotFoundException if the file was not found.
+     * @throws IOException           in case deletion is unsuccessful.
+     */
+    private static void forceDelete(final File file, final boolean strict) throws IOException {
+        checkExists(file, strict); // fail-fast
         final Counters.PathCounters deleteCounters;
         try {
-            deleteCounters = PathUtils.delete(file.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY,
-                StandardDeleteOption.OVERRIDE_READ_ONLY);
+            deleteCounters = PathUtils.delete(file.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY, StandardDeleteOption.OVERRIDE_READ_ONLY);
+        } catch (final NoSuchFileException e) {
+            // Map NIO to IO exception
+            final FileNotFoundException nioEx = new FileNotFoundException("Cannot delete file: " + file);
+            nioEx.initCause(e);
+            throw nioEx;
         } catch (final IOException e) {
             throw new IOException("Cannot delete file: " + file, e);
         }
-
         if (deleteCounters.getFileCounter().get() < 1 && deleteCounters.getDirectoryCounter().get() < 1) {
             // didn't find a file to delete.
             throw new FileNotFoundException("File does not exist: " + file);
@@ -1351,7 +1442,7 @@ public static void forceDelete(final File file) throws IOException {
      * @throws IOException          in case deletion is unsuccessful.
      */
     public static void forceDeleteOnExit(final File file) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         if (file.isDirectory()) {
             deleteDirectoryOnExit(file);
         } else {
@@ -1380,7 +1471,7 @@ public static void forceMkdir(final File directory) throws IOException {
      * Creates all directories for a File object, including any necessary but non-existent parent directories. If the parent directory already exists or is
      * null, nothing happens.
      * <p>
-     * Calls {@link File#mkdirs()} for the parent of @{code file}.
+     * Calls {@link File#mkdirs()} for the parent of {@code file}.
      * </p>
      *
      * @param file file with parents to create, must not be {@code null}.
@@ -1391,7 +1482,7 @@ public static void forceMkdir(final File directory) throws IOException {
      * @since 2.5
      */
     public static void forceMkdirParent(final File file) throws IOException {
-        forceMkdir(getParentFile(Objects.requireNonNull(file, "file")));
+        forceMkdir(getParentFile(Objects.requireNonNull(file, PROTOCOL_FILE)));
     }
 
     /**
@@ -1458,7 +1549,7 @@ public static File getTempDirectory() {
      * WARNING: this method relies on the Java system property 'java.io.tmpdir'
      * which may or may not have a trailing file separator.
      * This can affect code that uses String processing to manipulate pathnames rather
-     * than the standard libary methods in classes such as {@link java.io.File}
+     * than the standard libary methods in classes such as {@link File}
      *
      * @return the path to the system temporary directory as a String
      * @since 2.0
@@ -1512,7 +1603,7 @@ public static boolean isDirectory(final File file, final LinkOption... options)
      * @return whether the directory is empty.
      * @throws IOException if an I/O error occurs.
      * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory
-     *                               <i>(optional specific exception)</i>.
+     *                               <em>(optional specific exception)</em>.
      * @since 2.9.0
      */
     public static boolean isEmptyDirectory(final File directory) throws IOException {
@@ -1533,6 +1624,7 @@ public static boolean isEmptyDirectory(final File directory) throws IOException
      * @param chronoLocalDate the date reference.
      * @return true if the {@link File} exists and has been modified after the given
      * {@link ChronoLocalDate} at the current time.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file or local date is {@code null}.
      * @since 2.8.0
      */
@@ -1554,6 +1646,7 @@ public static boolean isFileNewer(final File file, final ChronoLocalDate chronoL
      * @param localTime       the time reference.
      * @return true if the {@link File} exists and has been modified after the given
      * {@link ChronoLocalDate} at the given time.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file, local date or zone ID is {@code null}.
      * @since 2.8.0
      */
@@ -1572,6 +1665,7 @@ public static boolean isFileNewer(final File file, final ChronoLocalDate chronoL
      * @param offsetTime the time reference
      * @return true if the {@link File} exists and has been modified after the given {@link ChronoLocalDate} at the given
      *         {@link OffsetTime}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file, local date or zone ID is {@code null}
      * @since 2.12.0
      */
@@ -1594,6 +1688,7 @@ public static boolean isFileNewer(final File file, final ChronoLocalDate chronoL
      * @param chronoLocalDateTime the date reference.
      * @return true if the {@link File} exists and has been modified after the given
      * {@link ChronoLocalDateTime} at the system-default time zone.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file or local date time is {@code null}.
      * @since 2.8.0
      */
@@ -1610,6 +1705,7 @@ public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?>
      * @param zoneId              the time zone.
      * @return true if the {@link File} exists and has been modified after the given
      * {@link ChronoLocalDateTime} at the given {@link ZoneId}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file, local date time or zone ID is {@code null}.
      * @since 2.8.0
      */
@@ -1627,10 +1723,11 @@ public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?>
      * @return true if the {@link File} exists and has been modified after the given
      * {@link ChronoZonedDateTime}.
      * @throws NullPointerException if the file or zoned date time is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @since 2.8.0
      */
     public static boolean isFileNewer(final File file, final ChronoZonedDateTime<?> chronoZonedDateTime) {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         Objects.requireNonNull(chronoZonedDateTime, "chronoZonedDateTime");
         return Uncheck.get(() -> PathUtils.isNewer(file.toPath(), chronoZonedDateTime));
     }
@@ -1642,6 +1739,7 @@ public static boolean isFileNewer(final File file, final ChronoZonedDateTime<?>
      * @param date the date reference.
      * @return true if the {@link File} exists and has been modified
      * after the given {@link Date}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file or date is {@code null}.
      */
     public static boolean isFileNewer(final File file, final Date date) {
@@ -1657,10 +1755,9 @@ public static boolean isFileNewer(final File file, final Date date) {
      * @return true if the {@link File} exists and has been modified more
      * recently than the reference {@link File}.
      * @throws NullPointerException if the file or reference file is {@code null}.
-     * @throws IllegalArgumentException if the reference file doesn't exist.
+     * @throws UncheckedIOException if the reference file doesn't exist.
      */
     public static boolean isFileNewer(final File file, final File reference) {
-        requireExists(reference, "reference");
         return Uncheck.get(() -> PathUtils.isNewer(file.toPath(), reference.toPath()));
     }
 
@@ -1675,7 +1772,7 @@ public static boolean isFileNewer(final File file, final File reference) {
      * @since 2.12.0
      */
     public static boolean isFileNewer(final File file, final FileTime fileTime) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return PathUtils.isNewer(file.toPath(), fileTime);
     }
 
@@ -1686,6 +1783,7 @@ public static boolean isFileNewer(final File file, final FileTime fileTime) thro
      * @param instant the date reference.
      * @return true if the {@link File} exists and has been modified after the given {@link Instant}.
      * @throws NullPointerException if the file or instant is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @since 2.8.0
      */
     public static boolean isFileNewer(final File file, final Instant instant) {
@@ -1700,10 +1798,11 @@ public static boolean isFileNewer(final File file, final Instant instant) {
      * @param timeMillis the time reference measured in milliseconds since the
      *                   epoch (00:00:00 GMT, January 1, 1970).
      * @return true if the {@link File} exists and has been modified after the given time reference.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file is {@code null}.
      */
     public static boolean isFileNewer(final File file, final long timeMillis) {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return Uncheck.get(() -> PathUtils.isNewer(file.toPath(), timeMillis));
     }
 
@@ -1713,6 +1812,7 @@ public static boolean isFileNewer(final File file, final long timeMillis) {
      * @param file the {@link File} of which the modification date must be compared
      * @param offsetDateTime the date reference
      * @return true if the {@link File} exists and has been modified before the given {@link OffsetDateTime}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file or zoned date time is {@code null}
      * @since 2.12.0
      */
@@ -1736,6 +1836,7 @@ public static boolean isFileNewer(final File file, final OffsetDateTime offsetDa
      * @return true if the {@link File} exists and has been modified before the given
      * {@link ChronoLocalDate} at the current time.
      * @throws NullPointerException if the file or local date is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @see ZoneId#systemDefault()
      * @see LocalTime#now()
      * @since 2.8.0
@@ -1758,6 +1859,7 @@ public static boolean isFileOlder(final File file, final ChronoLocalDate chronoL
      * @param localTime       the time reference.
      * @return true if the {@link File} exists and has been modified before the
      * given {@link ChronoLocalDate} at the specified time.
+     * @throws UncheckedIOException if an I/O error occurs
      * @throws NullPointerException if the file, local date or local time is {@code null}.
      * @see ZoneId#systemDefault()
      * @since 2.8.0
@@ -1778,6 +1880,7 @@ public static boolean isFileOlder(final File file, final ChronoLocalDate chronoL
      * @return true if the {@link File} exists and has been modified after the given {@link ChronoLocalDate} at the given
      *         {@link OffsetTime}.
      * @throws NullPointerException if the file, local date or zone ID is {@code null}
+     * @throws UncheckedIOException if an I/O error occurs
      * @since 2.12.0
      */
     public static boolean isFileOlder(final File file, final ChronoLocalDate chronoLocalDate, final OffsetTime offsetTime) {
@@ -1800,6 +1903,7 @@ public static boolean isFileOlder(final File file, final ChronoLocalDate chronoL
      * @return true if the {@link File} exists and has been modified before the given
      * {@link ChronoLocalDateTime} at the system-default time zone.
      * @throws NullPointerException if the file or local date time is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @see ZoneId#systemDefault()
      * @since 2.8.0
      */
@@ -1817,6 +1921,7 @@ public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?>
      * @return true if the {@link File} exists and has been modified before the given
      * {@link ChronoLocalDateTime} at the given {@link ZoneId}.
      * @throws NullPointerException if the file, local date time or zone ID is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @since 2.8.0
      */
     public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime, final ZoneId zoneId) {
@@ -1833,6 +1938,7 @@ public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?>
      * @return true if the {@link File} exists and has been modified before the given
      * {@link ChronoZonedDateTime}.
      * @throws NullPointerException if the file or zoned date time is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      * @since 2.8.0
      */
     public static boolean isFileOlder(final File file, final ChronoZonedDateTime<?> chronoZonedDateTime) {
@@ -1847,6 +1953,7 @@ public static boolean isFileOlder(final File file, final ChronoZonedDateTime<?>
      * @param date the date reference.
      * @return true if the {@link File} exists and has been modified before the given {@link Date}.
      * @throws NullPointerException if the file or date is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      */
     public static boolean isFileOlder(final File file, final Date date) {
         Objects.requireNonNull(date, "date");
@@ -1860,10 +1967,10 @@ public static boolean isFileOlder(final File file, final Date date) {
      * @param reference the {@link File} of which the modification date is used.
      * @return true if the {@link File} exists and has been modified before the reference {@link File}.
      * @throws NullPointerException if the file or reference file is {@code null}.
-     * @throws IllegalArgumentException if the reference file doesn't exist.
+     * @throws FileNotFoundException if the reference file doesn't exist.
+     * @throws UncheckedIOException if an I/O error occurs
      */
-    public static boolean isFileOlder(final File file, final File reference) {
-        requireExists(reference, "reference");
+    public static boolean isFileOlder(final File file, final File reference) throws FileNotFoundException {
         return Uncheck.get(() -> PathUtils.isOlder(file.toPath(), reference.toPath()));
     }
 
@@ -1878,7 +1985,7 @@ public static boolean isFileOlder(final File file, final File reference) {
      * @since 2.12.0
      */
     public static boolean isFileOlder(final File file, final FileTime fileTime) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return PathUtils.isOlder(file.toPath(), fileTime);
     }
 
@@ -1904,9 +2011,10 @@ public static boolean isFileOlder(final File file, final Instant instant) {
      *                   epoch (00:00:00 GMT, January 1, 1970).
      * @return true if the {@link File} exists and has been modified before the given time reference.
      * @throws NullPointerException if the file is {@code null}.
+     * @throws UncheckedIOException if an I/O error occurs
      */
     public static boolean isFileOlder(final File file, final long timeMillis) {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return Uncheck.get(() -> PathUtils.isOlder(file.toPath(), timeMillis));
     }
 
@@ -1924,6 +2032,16 @@ public static boolean isFileOlder(final File file, final OffsetDateTime offsetDa
         return isFileOlder(file, offsetDateTime.toInstant());
     }
 
+    /**
+     * Tests whether the given URL is a file URL.
+     *
+     * @param url The URL to test.
+     * @return Whether the given URL is a file URL.
+     */
+    private static boolean isFileProtocol(final URL url) {
+        return PROTOCOL_FILE.equalsIgnoreCase(url.getProtocol());
+    }
+
     /**
      * Tests whether the specified {@link File} is a regular file or not. Implemented as a
      * null-safe delegate to {@link Files#isRegularFile(Path path, LinkOption... options)}.
@@ -2068,7 +2186,7 @@ public static FileTime lastModifiedFileTime(final File file) throws IOException
         // https://bugs.openjdk.java.net/browse/JDK-8177809
         // File.lastModified() is losing milliseconds (always ends in 000)
         // This bug is in OpenJDK 8 and 9, and fixed in 10.
-        return Files.getLastModifiedTime(Objects.requireNonNull(file.toPath(), "file"));
+        return Files.getLastModifiedTime(Objects.requireNonNull(file, PROTOCOL_FILE).toPath());
     }
 
     /**
@@ -2160,14 +2278,16 @@ public static LineIterator lineIterator(final File file, final String charsetNam
     }
 
     private static AccumulatorPathVisitor listAccumulate(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter,
-        final FileVisitOption... options) throws IOException {
+            final FileVisitOption... options) throws IOException {
         final boolean isDirFilterSet = dirFilter != null;
         final FileEqualsFileFilter rootDirFilter = new FileEqualsFileFilter(directory);
         final PathFilter dirPathFilter = isDirFilterSet ? rootDirFilter.or(dirFilter) : rootDirFilter;
         final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(), fileFilter, dirPathFilter,
-            (p, e) -> FileVisitResult.CONTINUE);
+                (p, e) -> FileVisitResult.CONTINUE);
         final Set<FileVisitOption> optionSet = new HashSet<>();
-        Collections.addAll(optionSet, options);
+        if (options != null) {
+            Collections.addAll(optionSet, options);
+        }
         Files.walkFileTree(directory.toPath(), optionSet, toMaxDepth(isDirFilterSet), visitor);
         return visitor;
     }
@@ -2175,16 +2295,18 @@ private static AccumulatorPathVisitor listAccumulate(final File directory, final
     /**
      * Lists files in a directory, asserting that the supplied directory exists and is a directory.
      *
-     * @param directory The directory to list
+     * @param directory  The directory to list.
      * @param fileFilter Optional file filter, may be null.
      * @return The files in the directory, never {@code null}.
-     * @throws NullPointerException if directory is {@code null}.
-     * @throws IllegalArgumentException if directory does not exist or is not a directory.
-     * @throws IOException if an I/O error occurs.
+     * @throws NullPointerException     if the {@code directory} is {@code null}.
+     * @throws IllegalArgumentException if the {@code directory} exists but is not a directory.
+     * @throws IOException              if an I/O error occurs per {@link File#listFiles()} and {@link File#listFiles(FileFilter)}.
+     * @throws SecurityException        If a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to the
+     *                                  directory.
      */
     private static File[] listFiles(final File directory, final FileFilter fileFilter) throws IOException {
         requireDirectoryExists(directory, "directory");
-        final File[] files = fileFilter == null ? directory.listFiles() : directory.listFiles(fileFilter);
+        final File[] files = directory.listFiles(fileFilter);
         if (files == null) {
             // null if the directory does not denote a directory, or if an I/O error occurs.
             throw new IOException("Unknown I/O error listing contents of directory: " + directory);
@@ -2227,6 +2349,25 @@ public static Collection<File> listFiles(final File directory, final IOFileFilte
         return toList(visitor.getFileList().stream().map(Path::toFile));
     }
 
+    @SuppressWarnings("null")
+    private static void listFiles(final File directory, final List<File> files, final boolean recursive, final FilenameFilter filter) {
+        final File[] listFiles = directory.listFiles();
+        if (listFiles != null) {
+            // Only allocate if you must.
+            final List<File> dirs = recursive ? new ArrayList<>() : null;
+            Arrays.stream(listFiles).forEach(f -> {
+                if (recursive && f.isDirectory()) {
+                    dirs.add(f);
+                } else if (f.isFile() && filter.accept(directory, f.getName())) {
+                    files.add(f);
+                }
+            });
+            if (recursive) {
+                dirs.forEach(d -> listFiles(d, files, true, filter));
+            }
+        }
+    }
+
     /**
      * Lists files within a given directory (and optionally its subdirectories)
      * which match an array of extensions.
@@ -2238,9 +2379,11 @@ public static Collection<File> listFiles(final File directory, final IOFileFilte
      * @return a collection of {@link File} with the matching files
      */
     public static Collection<File> listFiles(final File directory, final String[] extensions, final boolean recursive) {
-        try (Stream<File> fileStream = Uncheck.get(() -> streamFiles(directory, recursive, extensions))) {
-            return toList(fileStream);
-        }
+        // IO-856: Don't use NIO to path walk, allocate as little as possible while traversing.
+        final List<File> files = new ArrayList<>();
+        final FilenameFilter filter = extensions != null ? toSuffixFileFilter(extensions) : TrueFileFilter.INSTANCE;
+        listFiles(directory, files, recursive, filter);
+        return files;
     }
 
     /**
@@ -2300,14 +2443,14 @@ private static File mkdirs(final File directory) throws IOException {
      * @param srcDir the directory to be moved.
      * @param destDir the destination directory.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws IllegalArgumentException if the source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcDir} exists but is not a directory
      * @throws FileNotFoundException if the source does not exist.
      * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
      * @since 1.4
      */
     public static void moveDirectory(final File srcDir, final File destDir) throws IOException {
-        validateMoveParameters(srcDir, destDir);
-        requireDirectory(srcDir, "srcDir");
+        Objects.requireNonNull(destDir, "destination");
+        requireDirectoryExists(srcDir, "srcDir");
         requireAbsent(destDir, "destDir");
         if (!srcDir.renameTo(destDir)) {
             if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator)) {
@@ -2328,7 +2471,7 @@ public static void moveDirectory(final File srcDir, final File destDir) throws I
      * If {@code createDestDir} is true, creates all destination parent directories, including any necessary but non-existent parent directories.
      * </p>
      *
-     * @param source the file to be moved.
+     * @param source the directory to be moved.
      * @param destDir the destination file.
      * @param createDestDir If {@code true} create the destination directory, otherwise if {@code false} throw an
      *        IOException.
@@ -2368,7 +2511,7 @@ public static void moveDirectoryToDirectory(final File source, final File destDi
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
      * @throws FileExistsException if the destination file exists.
      * @throws FileNotFoundException if the source file does not exist.
-     * @throws IOException if source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcFile} is a directory
      * @throws IOException if an error occurs.
      * @since 1.4
      */
@@ -2388,35 +2531,35 @@ public static void moveFile(final File srcFile, final File destFile) throws IOEx
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
      * @throws FileExistsException if the destination file exists.
      * @throws FileNotFoundException if the source file does not exist.
-     * @throws IOException if source or destination is invalid.
+     * @throws IllegalArgumentException if {@code srcFile} is a directory
      * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
      * @since 2.9.0
      */
     public static void moveFile(final File srcFile, final File destFile, final CopyOption... copyOptions) throws IOException {
-        validateMoveParameters(srcFile, destFile);
-        requireFile(srcFile, "srcFile");
+        Objects.requireNonNull(destFile, "destination");
+        checkFileExists(srcFile, "srcFile");
         requireAbsent(destFile, "destFile");
         final boolean rename = srcFile.renameTo(destFile);
         if (!rename) {
             // Don't interfere with file date on move, handled by StandardCopyOption.COPY_ATTRIBUTES
             copyFile(srcFile, destFile, false, copyOptions);
             if (!srcFile.delete()) {
-                FileUtils.deleteQuietly(destFile);
+                deleteQuietly(destFile);
                 throw new IOException("Failed to delete original file '" + srcFile + "' after copy to '" + destFile + "'");
             }
         }
     }
 
     /**
-     * Moves a file to a directory.
+     * Moves a file into a directory.
      * <p>
      * If {@code createDestDir} is true, creates all destination parent directories, including any necessary but non-existent parent directories.
      * </p>
      *
      * @param srcFile the file to be moved.
-     * @param destDir the destination file.
-     * @param createDestDir If {@code true} create the destination directory, otherwise if {@code false} throw an
-     *        IOException.
+     * @param destDir the directory to move the file into
+     * @param createDestDir if {@code true} create the destination directory. If {@code false} throw an
+     *        IOException if the destination directory does not already exist.
      * @throws NullPointerException if any of the given {@link File}s are {@code null}.
      * @throws FileExistsException if the destination file exists.
      * @throws FileNotFoundException if the source file does not exist.
@@ -2424,6 +2567,7 @@ public static void moveFile(final File srcFile, final File destFile, final CopyO
      * @throws IOException if the directory was not created along with all its parent directories, if enabled.
      * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
      * @throws SecurityException See {@link File#mkdirs()}.
+     * @throws IllegalArgumentException if {@code destDir} exists but is not a directory
      * @since 1.4
      */
     public static void moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir) throws IOException {
@@ -2431,13 +2575,12 @@ public static void moveFileToDirectory(final File srcFile, final File destDir, f
         if (!destDir.exists() && createDestDir) {
             mkdirs(destDir);
         }
-        requireExistsChecked(destDir, "destDir");
-        requireDirectory(destDir, "destDir");
+        requireDirectoryExists(destDir, "destDir");
         moveFile(srcFile, new File(destDir, srcFile.getName()));
     }
 
     /**
-     * Moves a file or directory to a destination directory.
+     * Moves a file or directory into a destination directory.
      * <p>
      * If {@code createDestDir} is true, creates all destination parent directories, including any necessary but non-existent parent directories.
      * </p>
@@ -2447,7 +2590,8 @@ public static void moveFileToDirectory(final File srcFile, final File destDir, f
      *
      * @param src           the file or directory to be moved.
      * @param destDir       the destination directory.
-     * @param createDestDir If {@code true} create the destination directory, otherwise if {@code false} throw an IOException.
+     * @param createDestDir if {@code true} create the destination directory. If {@code false} throw an
+     *        IOException if the destination directory does not already exist.
      * @throws NullPointerException  if any of the given {@link File}s are {@code null}.
      * @throws FileExistsException   if the directory or file exists in the destination directory.
      * @throws FileNotFoundException if the source file does not exist.
@@ -2476,7 +2620,7 @@ public static void moveToDirectory(final File src, final File destDir, final boo
      * @since 2.12.0
      */
     public static OutputStream newOutputStream(final File file, final boolean append) throws IOException {
-        return PathUtils.newOutputStream(Objects.requireNonNull(file, "file").toPath(), append);
+        return PathUtils.newOutputStream(Objects.requireNonNull(file, PROTOCOL_FILE).toPath(), append);
     }
 
     /**
@@ -2499,7 +2643,7 @@ public static OutputStream newOutputStream(final File file, final boolean append
      * @since 1.3
      */
     public static FileInputStream openInputStream(final File file) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return new FileInputStream(file);
     }
 
@@ -2551,15 +2695,13 @@ public static FileOutputStream openOutputStream(final File file) throws IOExcept
      * @return a new {@link FileOutputStream} for the specified file
      * @throws NullPointerException if the file object is {@code null}.
      * @throws IllegalArgumentException if the file object is a directory
-     * @throws IllegalArgumentException if the file is not writable.
-     * @throws IOException if the directories could not be created.
+     * @throws IOException if the directories could not be created, or the file is not writable
      * @since 2.1
      */
     public static FileOutputStream openOutputStream(final File file, final boolean append) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         if (file.exists()) {
-            requireFile(file, "file");
-            requireCanWrite(file, "file");
+            checkIsFile(file, PROTOCOL_FILE);
         } else {
             createParentDirectories(file);
         }
@@ -2578,7 +2720,7 @@ public static FileOutputStream openOutputStream(final File file, final boolean a
      * @since 1.1
      */
     public static byte[] readFileToByteArray(final File file) throws IOException {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return Files.readAllBytes(file.toPath());
     }
 
@@ -2592,7 +2734,7 @@ public static byte[] readFileToByteArray(final File file) throws IOException {
      * @throws IOException if an I/O error occurs, including when the file does not exist, is a directory rather than a
      *         regular file, or for some other reason why the file cannot be opened for reading.
      * @since 1.3.1
-     * @deprecated 2.5 use {@link #readFileToString(File, Charset)} instead (and specify the appropriate encoding)
+     * @deprecated Use {@link #readFileToString(File, Charset)} instead (and specify the appropriate encoding)
      */
     @Deprecated
     public static String readFileToString(final File file) throws IOException {
@@ -2624,8 +2766,7 @@ public static String readFileToString(final File file, final Charset charsetName
      * @throws NullPointerException if file is {@code null}.
      * @throws IOException if an I/O error occurs, including when the file does not exist, is a directory rather than a
      *         regular file, or for some other reason why the file cannot be opened for reading.
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the named charset is unavailable.
+     * @throws java.nio.charset.UnsupportedCharsetException if the named charset is unavailable.
      * @since 2.3
      */
     public static String readFileToString(final File file, final String charsetName) throws IOException {
@@ -2642,7 +2783,7 @@ public static String readFileToString(final File file, final String charsetName)
      * @throws IOException if an I/O error occurs, including when the file does not exist, is a directory rather than a
      *         regular file, or for some other reason why the file cannot be opened for reading.
      * @since 1.3
-     * @deprecated 2.5 use {@link #readLines(File, Charset)} instead (and specify the appropriate encoding)
+     * @deprecated Use {@link #readLines(File, Charset)} instead (and specify the appropriate encoding)
      */
     @Deprecated
     public static List<String> readLines(final File file) throws IOException {
@@ -2674,15 +2815,13 @@ public static List<String> readLines(final File file, final Charset charset) thr
      * @throws NullPointerException if file is {@code null}.
      * @throws IOException if an I/O error occurs, including when the file does not exist, is a directory rather than a
      *         regular file, or for some other reason why the file cannot be opened for reading.
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the named charset is unavailable.
+     * @throws java.nio.charset.UnsupportedCharsetException if the named charset is unavailable.
      * @since 1.1
      */
     public static List<String> readLines(final File file, final String charsetName) throws IOException {
         return readLines(file, Charsets.toCharset(charsetName));
     }
 
-
     private static void requireAbsent(final File file, final String name) throws FileExistsException {
         if (file.exists()) {
             throw new FileExistsException(String.format("File element in parameter '%s' already exists: '%s'", name, file));
@@ -2706,51 +2845,22 @@ private static void requireCanonicalPathsNotEquals(final File file1, final File
     }
 
     /**
-     * Throws an {@link IllegalArgumentException} if the file is not writable. This provides a more precise exception
-     * message than a plain access denied.
-     *
-     * @param file The file to test.
-     * @param name The parameter name to use in the exception message.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the file is not writable.
-     */
-    private static void requireCanWrite(final File file, final String name) {
-        Objects.requireNonNull(file, "file");
-        if (!file.canWrite()) {
-            throw new IllegalArgumentException("File parameter '" + name + " is not writable: '" + file + "'");
-        }
-    }
-
-    /**
-     * Requires that the given {@link File} is a directory.
+     * Requires that the given {@link File} exists and is a directory.
      *
      * @param directory The {@link File} to check.
      * @param name The parameter name to use in the exception message in case of null input or if the file is not a directory.
-     * @return the given directory.
      * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist or is not a directory.
+     * @throws FileNotFoundException if the given {@link File} does not exist
+     * @throws IllegalArgumentException if the given {@link File} exists but is not a directory.
      */
-    private static File requireDirectory(final File directory, final String name) {
+    private static void requireDirectoryExists(final File directory, final String name) throws FileNotFoundException {
         Objects.requireNonNull(directory, name);
         if (!directory.isDirectory()) {
-            throw new IllegalArgumentException("Parameter '" + name + "' is not a directory: '" + directory + "'");
+            if (directory.exists()) {
+                throw new IllegalArgumentException("Parameter '" + name + "' is not a directory: '" + directory + "'");
+            }
+            throw new FileNotFoundException("Directory '" + directory + "' does not exist.");
         }
-        return directory;
-    }
-
-    /**
-     * Requires that the given {@link File} exists and is a directory.
-     *
-     * @param directory The {@link File} to check.
-     * @param name The parameter name to use in the exception message in case of null input.
-     * @return the given directory.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist or is not a directory.
-     */
-    private static File requireDirectoryExists(final File directory, final String name) {
-        requireExists(directory, name);
-        requireDirectory(directory, name);
-        return directory;
     }
 
     /**
@@ -2758,98 +2868,18 @@ private static File requireDirectoryExists(final File directory, final String na
      *
      * @param directory The {@link File} to check.
      * @param name The parameter name to use in the exception message in case of null input.
-     * @return the given directory.
      * @throws NullPointerException if the given {@link File} is {@code null}.
      * @throws IllegalArgumentException if the given {@link File} exists but is not a directory.
      */
-    private static File requireDirectoryIfExists(final File directory, final String name) {
+    private static void requireDirectoryIfExists(final File directory, final String name) {
         Objects.requireNonNull(directory, name);
-        if (directory.exists()) {
-            requireDirectory(directory, name);
-        }
-        return directory;
-    }
-
-    /**
-     * Requires that the given {@link File} exists and throws an {@link IllegalArgumentException} if it doesn't.
-     *
-     * @param file The {@link File} to check.
-     * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.
-     * @return the given file.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist.
-     */
-    private static File requireExists(final File file, final String fileParamName) {
-        Objects.requireNonNull(file, fileParamName);
-        if (!file.exists()) {
-            throw new IllegalArgumentException("File system element for parameter '" + fileParamName + "' does not exist: '" + file + "'");
-        }
-        return file;
-    }
-
-    /**
-     * Requires that the given {@link File} exists and throws an {@link FileNotFoundException} if it doesn't.
-     *
-     * @param file The {@link File} to check.
-     * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.
-     * @return the given file.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws FileNotFoundException if the given {@link File} does not exist.
-     */
-    private static File requireExistsChecked(final File file, final String fileParamName) throws FileNotFoundException {
-        Objects.requireNonNull(file, fileParamName);
-        if (!file.exists()) {
-            throw new FileNotFoundException("File system element for parameter '" + fileParamName + "' does not exist: '" + file + "'");
-        }
-        return file;
-    }
-
-    /**
-     * Requires that the given {@link File} is a file.
-     *
-     * @param file The {@link File} to check.
-     * @param name The parameter name to use in the exception message.
-     * @return the given file.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} does not exist or is not a file.
-     */
-    private static File requireFile(final File file, final String name) {
-        Objects.requireNonNull(file, name);
-        if (!file.isFile()) {
-            throw new IllegalArgumentException("Parameter '" + name + "' is not a file: " + file);
+        if (directory.exists() && !directory.isDirectory()) {
+            throw new IllegalArgumentException("Parameter '" + name + "' is not a directory: '" + directory + "'");
         }
-        return file;
     }
 
     /**
-     * Requires parameter attributes for a file copy operation.
-     *
-     * @param source the source file
-     * @param destination the destination
-     * @throws NullPointerException if any of the given {@link File}s are {@code null}.
-     * @throws FileNotFoundException if the source does not exist.
-     */
-    private static void requireFileCopy(final File source, final File destination) throws FileNotFoundException {
-        requireExistsChecked(source, "source");
-        Objects.requireNonNull(destination, "destination");
-    }
-
-    /**
-     * Requires that the given {@link File} is a file if it exists.
-     *
-     * @param file The {@link File} to check.
-     * @param name The parameter name to use in the exception message in case of null input.
-     * @return the given directory.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
-     * @throws IllegalArgumentException if the given {@link File} exists but is not a directory.
-     */
-    private static File requireFileIfExists(final File file, final String name) {
-        Objects.requireNonNull(file, name);
-        return file.exists() ? requireFile(file, name) : file;
-    }
-
-    /**
-     * Set file lastModifiedTime, lastAccessTime and creationTime to match source file
+     * Sets file lastModifiedTime, lastAccessTime and creationTime to match source file
      *
      * @param sourceFile The source file to query.
      * @param targetFile The target file or directory to set.
@@ -2868,7 +2898,7 @@ private static boolean setTimes(final File sourceFile, final File targetFile) {
             // null guards are not needed; BasicFileAttributes.setTimes(...) is null safe
             destAttrView.setTimes(srcAttr.lastModifiedTime(), srcAttr.lastAccessTime(), srcAttr.creationTime());
             return true;
-        } catch (IOException ignored) {
+        } catch (final IOException ignored) {
             // Fallback: Only set modified time to match source file
             return targetFile.setLastModified(sourceFile.lastModified());
         }
@@ -2901,7 +2931,6 @@ private static boolean setTimes(final File sourceFile, final File targetFile) {
      * @since 2.0
      */
     public static long sizeOf(final File file) {
-        requireExists(file, "file");
         return Uncheck.get(() -> PathUtils.sizeOf(file.toPath()));
     }
 
@@ -2924,7 +2953,6 @@ public static long sizeOf(final File file) {
      * @since 2.4
      */
     public static BigInteger sizeOfAsBigInteger(final File file) {
-        requireExists(file, "file");
         return Uncheck.get(() -> PathUtils.sizeOfAsBigInteger(file.toPath()));
     }
 
@@ -2939,11 +2967,16 @@ public static BigInteger sizeOfAsBigInteger(final File file) {
      * @param directory directory to inspect, must not be {@code null}.
      * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total
      * is greater than {@link Long#MAX_VALUE}.
+     * @throws IllegalArgumentException if the given {@link File} exists but is not a directory
      * @throws NullPointerException if the directory is {@code null}.
      * @throws UncheckedIOException if an IO error occurs.
      */
     public static long sizeOfDirectory(final File directory) {
-        requireDirectoryExists(directory, "directory");
+        try {
+            requireDirectoryExists(directory, "directory");
+        } catch (final FileNotFoundException e) {
+            throw new UncheckedIOException(e);
+        }
         return Uncheck.get(() -> PathUtils.sizeOfDirectory(directory.toPath()));
     }
 
@@ -2952,12 +2985,17 @@ public static long sizeOfDirectory(final File directory) {
      *
      * @param directory directory to inspect, must not be {@code null}.
      * @return size of directory in bytes, 0 if directory is security restricted.
+     * @throws IllegalArgumentException if the given {@link File} exists but is not a directory
      * @throws NullPointerException if the directory is {@code null}.
      * @throws UncheckedIOException if an IO error occurs.
      * @since 2.4
      */
     public static BigInteger sizeOfDirectoryAsBigInteger(final File directory) {
-        requireDirectoryExists(directory, "directory");
+        try {
+            requireDirectoryExists(directory, "directory");
+        } catch (final FileNotFoundException e) {
+            throw new UncheckedIOException(e);
+        }
         return Uncheck.get(() -> PathUtils.sizeOfDirectoryAsBigInteger(directory.toPath()));
     }
 
@@ -2980,7 +3018,7 @@ public static Stream<File> streamFiles(final File directory, final boolean recur
         // @formatter:off
         final IOFileFilter filter = extensions == null
             ? FileFileFilter.INSTANCE
-            : FileFileFilter.INSTANCE.and(new SuffixFileFilter(toSuffixes(extensions)));
+            : FileFileFilter.INSTANCE.and(toSuffixFileFilter(extensions));
         // @formatter:on
         return PathUtils.walk(directory.toPath(), filter, toMaxDepth(recursive), false, FileVisitOption.FOLLOW_LINKS).map(Path::toFile);
     }
@@ -2988,10 +3026,9 @@ public static Stream<File> streamFiles(final File directory, final boolean recur
     /**
      * Converts from a {@link URL} to a {@link File}.
      * <p>
-     * From version 1.1 this method will decode the URL.
      * Syntax such as {@code file:///my%20docs/file.txt} will be
-     * correctly decoded to {@code /my docs/file.txt}. Starting with version
-     * 1.5, this method uses UTF-8 to decode percent-encoded octets to characters.
+     * correctly decoded to {@code /my docs/file.txt}.
+     * UTF-8 is used to decode percent-encoded octets to characters.
      * Additionally, malformed percent-encoded octets are handled leniently by
      * passing them through literally.
      * </p>
@@ -3001,7 +3038,7 @@ public static Stream<File> streamFiles(final File directory, final boolean recur
      * if the URL's protocol is not {@code file}
      */
     public static File toFile(final URL url) {
-        if (url == null || !"file".equalsIgnoreCase(url.getProtocol())) {
+        if (url == null || !isFileProtocol(url)) {
             return null;
         }
         final String fileName = url.getFile().replace('/', File.separatorChar);
@@ -3037,7 +3074,7 @@ public static File[] toFiles(final URL... urls) {
         for (int i = 0; i < urls.length; i++) {
             final URL url = urls[i];
             if (url != null) {
-                if (!"file".equalsIgnoreCase(url.getProtocol())) {
+                if (!isFileProtocol(url)) {
                     throw new IllegalArgumentException("Can only convert file URL to a File: " + url);
                 }
                 files[i] = toFile(url);
@@ -3077,27 +3114,28 @@ private static int toMaxDepth(final boolean recursive) {
      * @throws NullPointerException if the parameter is null
      */
     private static String[] toSuffixes(final String... extensions) {
-        return Stream.of(Objects.requireNonNull(extensions, "extensions")).map(e -> "." + e).toArray(String[]::new);
+        return Stream.of(Objects.requireNonNull(extensions, "extensions")).map(s -> s.charAt(0) == '.' ? s : "." + s).toArray(String[]::new);
+    }
+
+    private static SuffixFileFilter toSuffixFileFilter(final String... extensions) {
+        return new SuffixFileFilter(toSuffixes(extensions));
     }
 
     /**
-     * Implements behavior similar to the Unix "touch" utility. Creates a new file with size 0, or, if the file exists, just
-     * updates the file's modified time.
-     * <p>
-     * NOTE: As from v1.3, this method throws an IOException if the last modified date of the file cannot be set. Also, as
-     * from v1.3 this method creates parent directories if they do not exist.
-     * </p>
+     * Implements behavior similar to the UNIX "touch" utility. Creates a new file with size 0, or, if the file exists, just
+     * updates the file's modified time. This method throws an IOException if the last modified date
+     * of the file cannot be set. It creates parent directories if they do not exist.
      *
      * @param file the File to touch.
      * @throws NullPointerException if the parameter is {@code null}.
      * @throws IOException if setting the last-modified time failed or an I/O problem occurs.
      */
     public static void touch(final File file) throws IOException {
-        PathUtils.touch(Objects.requireNonNull(file, "file").toPath());
+        PathUtils.touch(Objects.requireNonNull(file, PROTOCOL_FILE).toPath());
     }
 
     /**
-     * Converts each of an array of {@link File} to a {@link URL}.
+     * Converts each element of an array of {@link File} to a {@link URL}.
      * <p>
      * Returns an array of the same size as the input.
      * </p>
@@ -3105,7 +3143,7 @@ public static void touch(final File file) throws IOException {
      * @param files the files to convert, must not be {@code null}
      * @return an array of URLs matching the input
      * @throws IOException          if a file cannot be converted
-     * @throws NullPointerException if the parameter is null
+     * @throws NullPointerException if any argument is null
      */
     public static URL[] toURLs(final File... files) throws IOException {
         Objects.requireNonNull(files, "files");
@@ -3138,7 +3176,7 @@ private static void validateMoveParameters(final File source, final File destina
     }
 
     /**
-     * Waits for the file system to propagate a file creation, with a timeout.
+     * Waits for the file system to detect a file's presence, with a timeout.
      * <p>
      * This method repeatedly tests {@link Files#exists(Path, LinkOption...)} until it returns
      * true up to the maximum time specified in seconds.
@@ -3150,7 +3188,7 @@ private static void validateMoveParameters(final File source, final File destina
      * @throws NullPointerException if the file is {@code null}
      */
     public static boolean waitFor(final File file, final int seconds) {
-        Objects.requireNonNull(file, "file");
+        Objects.requireNonNull(file, PROTOCOL_FILE);
         return PathUtils.waitFor(file.toPath(), Duration.ofSeconds(seconds), PathUtils.EMPTY_LINK_OPTION_ARRAY);
     }
 
@@ -3161,7 +3199,7 @@ public static boolean waitFor(final File file, final int seconds) {
      * @param data the content to write to the file
      * @throws IOException in case of an I/O error
      * @since 2.0
-     * @deprecated 2.5 use {@link #write(File, CharSequence, Charset)} instead (and specify the appropriate encoding)
+     * @deprecated Use {@link #write(File, CharSequence, Charset)} instead (and specify the appropriate encoding)
      */
     @Deprecated
     public static void write(final File file, final CharSequence data) throws IOException {
@@ -3177,7 +3215,7 @@ public static void write(final File file, final CharSequence data) throws IOExce
      *               end of the file rather than overwriting
      * @throws IOException in case of an I/O error
      * @since 2.1
-     * @deprecated 2.5 use {@link #write(File, CharSequence, Charset, boolean)} instead (and specify the appropriate encoding)
+     * @deprecated Use {@link #write(File, CharSequence, Charset, boolean)} instead (and specify the appropriate encoding)
      */
     @Deprecated
     public static void write(final File file, final CharSequence data, final boolean append) throws IOException {
@@ -3235,8 +3273,7 @@ public static void write(final File file, final CharSequence data, final String
      * @param append   if {@code true}, then the data will be added to the
      *                 end of the file rather than overwriting
      * @throws IOException                 in case of an I/O error
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported by the VM
      * @since 2.1
      */
     public static void write(final File file, final CharSequence data, final String charsetName, final boolean append) throws IOException {
@@ -3247,10 +3284,7 @@ public static void write(final File file, final CharSequence data, final String
 
     /**
      * Writes a byte array to a file creating the file if it does not exist.
-     * <p>
-     * NOTE: As from v1.3, the parent directories of the file will be created
-     * if they do not exist.
-     * </p>
+     * The parent directories of the file will be created if they do not exist.
      *
      * @param file the file to write to
      * @param data the content to write to the file
@@ -3377,10 +3411,7 @@ public static void writeLines(final File file, final Collection<?> lines, final
      * Writes the {@code toString()} value of each item in a collection to
      * the specified {@link File} line by line.
      * The specified character encoding and the default line ending will be used.
-     * <p>
-     * NOTE: As from v1.3, the parent directories of the file will be created
-     * if they do not exist.
-     * </p>
+     * The parent directories of the file will be created if they do not exist.
      *
      * @param file     the file to write to
      * @param charsetName the name of the requested charset, {@code null} means platform default
@@ -3415,10 +3446,7 @@ public static void writeLines(final File file, final String charsetName, final C
      * Writes the {@code toString()} value of each item in a collection to
      * the specified {@link File} line by line.
      * The specified character encoding and the line ending will be used.
-     * <p>
-     * NOTE: As from v1.3, the parent directories of the file will be created
-     * if they do not exist.
-     * </p>
+     * The parent directories of the file will be created if they do not exist.
      *
      * @param file       the file to write to
      * @param charsetName   the name of the requested charset, {@code null} means platform default
@@ -3460,7 +3488,7 @@ public static void writeLines(final File file, final String charsetName, final C
      * @param file the file to write
      * @param data the content to write to the file
      * @throws IOException in case of an I/O error
-     * @deprecated 2.5 use {@link #writeStringToFile(File, String, Charset)} instead (and specify the appropriate encoding)
+     * @deprecated Use {@link #writeStringToFile(File, String, Charset)} instead (and specify the appropriate encoding)
      */
     @Deprecated
     public static void writeStringToFile(final File file, final String data) throws IOException {
@@ -3476,7 +3504,7 @@ public static void writeStringToFile(final File file, final String data) throws
      *               end of the file rather than overwriting
      * @throws IOException in case of an I/O error
      * @since 2.1
-     * @deprecated 2.5 use {@link #writeStringToFile(File, String, Charset, boolean)} instead (and specify the appropriate encoding)
+     * @deprecated Use {@link #writeStringToFile(File, String, Charset, boolean)} instead (and specify the appropriate encoding)
      */
     @Deprecated
     public static void writeStringToFile(final File file, final String data, final boolean append) throws IOException {
@@ -3485,10 +3513,7 @@ public static void writeStringToFile(final File file, final String data, final b
 
     /**
      * Writes a String to a file creating the file if it does not exist.
-     * <p>
-     * NOTE: As from v1.3, the parent directories of the file will be created
-     * if they do not exist.
-     * </p>
+     * The parent directories of the file will be created if they do not exist.
      *
      * @param file     the file to write
      * @param data     the content to write to the file
@@ -3502,7 +3527,8 @@ public static void writeStringToFile(final File file, final String data, final C
     }
 
     /**
-     * Writes a String to a file creating the file if it does not exist.
+     * Writes a String to a file, creating the file if it does not exist.
+     * The parent directories of the file are created if they do not exist.
      *
      * @param file     the file to write
      * @param data     the content to write to the file
@@ -3519,11 +3545,8 @@ public static void writeStringToFile(final File file, final String data, final C
     }
 
     /**
-     * Writes a String to a file creating the file if it does not exist.
-     * <p>
-     * NOTE: As from v1.3, the parent directories of the file will be created
-     * if they do not exist.
-     * </p>
+     * Writes a String to a file, creating the file if it does not exist.
+     * The parent directories of the file are created if they do not exist.
      *
      * @param file     the file to write
      * @param data     the content to write to the file
@@ -3536,7 +3559,8 @@ public static void writeStringToFile(final File file, final String data, final S
     }
 
     /**
-     * Writes a String to a file creating the file if it does not exist.
+     * Writes a String to a file, creating the file if it does not exist.
+     * The parent directories of the file are created if they do not exist.
      *
      * @param file     the file to write
      * @param data     the content to write to the file
@@ -3544,8 +3568,7 @@ public static void writeStringToFile(final File file, final String data, final S
      * @param append   if {@code true}, then the String will be added to the
      *                 end of the file rather than overwriting
      * @throws IOException                 in case of an I/O error
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported by the VM
      * @since 2.1
      */
     public static void writeStringToFile(final File file, final String data, final String charsetName, final boolean append) throws IOException {
@@ -3554,11 +3577,12 @@ public static void writeStringToFile(final File file, final String data, final S
 
     /**
      * Instances should NOT be constructed in standard programming.
-     * @deprecated Will be private in 3.0.
+     *
+     * @deprecated TODO Make private in 3.0.
      */
     @Deprecated
     public FileUtils() { //NOSONAR
-
+        // empty
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/FilenameUtils.java b/src/main/java/org/apache/commons/io/FilenameUtils.java
index 049c3a71..9fdbc739 100644
--- a/src/main/java/org/apache/commons/io/FilenameUtils.java
+++ b/src/main/java/org/apache/commons/io/FilenameUtils.java
@@ -28,30 +28,33 @@
 import java.util.stream.Stream;
 
 /**
- * General file name and file path manipulation utilities.
+ * General file name and file path manipulation utilities. The methods in this class
+ * operate on strings that represent relative or absolute paths. Nothing in this class
+ * ever accesses the file system, or depends on whether a path points to a file that exists.
  * <p>
- * When dealing with file names you can hit problems when moving from a Windows
- * based development machine to a Unix based production machine.
+ * When dealing with file names, you can hit problems when moving from a Windows
+ * based development machine to a UNIX based production machine.
  * This class aims to help avoid those problems.
  * </p>
  * <p>
- * <b>NOTE</b>: You may be able to avoid using this class entirely simply by
- * using JDK {@link java.io.File File} objects and the two argument constructor
- * {@link java.io.File#File(java.io.File, String) File(File,String)}.
+ * <strong>NOTE</strong>: You may be able to avoid using this class entirely simply by
+ * using JDK {@link File File} objects and the two argument constructor
+ * {@link File#File(java.io.File, String) File(File,String)}.
  * </p>
  * <p>
- * Most methods on this class are designed to work the same on both Unix and Windows.
- * Those that don't include 'System', 'Unix' or 'Windows' in their name.
+ * Most methods in this class are designed to work the same on both UNIX and Windows.
+ * Those that don't include 'System', 'Unix', or 'Windows' in their name.
  * </p>
  * <p>
- * Most methods recognize both separators (forward and back), and both
+ * Most methods recognize both separators (forward and backslashes), and both
  * sets of prefixes. See the Javadoc of each method for details.
  * </p>
  * <p>
- * This class defines six components within a file name
- * (example C:\dev\project\file.txt):
+ * This class defines six components within a path (sometimes called a file name or a full file name).
+ * Given an absolute Windows path such as C:\dev\project\file.txt they are:
  * </p>
  * <ul>
+ * <li>the full file name, or just file name - C:\dev\project\file.txt</li>
  * <li>the prefix - C:\</li>
  * <li>the path - dev\project\</li>
  * <li>the full path - C:\dev\project\</li>
@@ -60,13 +63,51 @@
  * <li>the extension - txt</li>
  * </ul>
  * <p>
- * Note that this class works best if directory file names end with a separator.
- * If you omit the last separator, it is impossible to determine if the file name
- * corresponds to a file or a directory. As a result, we have chosen to say
- * it corresponds to a file.
+ * Given an absolute UNIX path such as /dev/project/file.txt they are:
  * </p>
+ * <ul>
+ * <li>the full file name, or just file name - /dev/project/file.txt</li>
+ * <li>the prefix - /</li>
+ * <li>the path - dev/project</li>
+ * <li>the full path - /dev/project</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
+ * <p>
+ * Given a relative Windows path such as dev\project\file.txt they are:
+ * </p>
+ * <ul>
+ * <li>the full file name, or just file name - dev\project\file.txt</li>
+ * <li>the prefix - null</li>
+ * <li>the path - dev\project\</li>
+ * <li>the full path - dev\project\</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
  * <p>
- * This class only supports Unix and Windows style names.
+ * Given an absolute UNIX path such as /dev/project/file.txt they are:
+ * </p>
+ * <ul>
+ * <li>the full path, full file name, or just file name - /dev/project/file.txt</li>
+ * <li>the prefix - /</li>
+ * <li>the path - dev/project</li>
+ * <li>the full path - /dev/project</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
+ *
+ *
+ * <p>
+ * This class works best if directory names end with a separator.
+ * If you omit the last separator, it is impossible to determine if the last component
+ * corresponds to a file or a directory. This class treats final components
+ * that do not end with a separator as files, not directories.
+ * </p>
+ * <p>
+ * This class only supports UNIX and Windows style names.
  * Prefixes are matched as follows:
  * </p>
  * <pre>
@@ -86,12 +127,9 @@
  * ~user               --&gt; "~user/"    --&gt; named user (slash added)
  * </pre>
  * <p>
- * Both prefix styles are matched always, irrespective of the machine that you are
+ * Both prefix styles are matched, irrespective of the machine that you are
  * currently running on.
  * </p>
- * <p>
- * Provenance: Excalibur, Alexandria, Tomcat, Commons-Utils.
- * </p>
  *
  * @since 1.1
  */
@@ -116,7 +154,7 @@ public class FilenameUtils {
     public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);
 
     /**
-     * The Unix separator character.
+     * The UNIX separator character.
      */
     private static final char UNIX_NAME_SEPARATOR = '/';
 
@@ -167,7 +205,7 @@ public class FilenameUtils {
      * Otherwise, the paths will be joined, normalized and returned.
      * </p>
      * <p>
-     * The output will be the same on both Unix and Windows except
+     * The output will be the same on both UNIX and Windows except
      * for the separator character.
      * </p>
      * <pre>
@@ -194,7 +232,7 @@ public class FilenameUtils {
      * </p>
      *
      * @param basePath  the base path to attach to, always treated as a path
-     * @param fullFileNameToAdd  the fileName (or path) to attach to the base
+     * @param fullFileNameToAdd  the file name (or path) to attach to the base
      * @return the concatenated path, or null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -221,7 +259,9 @@ public static String concat(final String basePath, final String fullFileNameToAd
     }
 
     /**
-     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).
+     * Determines whether the {@code parent} directory contains the {@code child} (a file or directory).
+     * This does not read from the file system, and there is no guarantee or expectation that
+     * these paths actually exist.
      * <p>
      * The files names are expected to be normalized.
      * </p>
@@ -233,11 +273,9 @@ public static String concat(final String basePath, final String fullFileNameToAd
      * <li>A null child file is not contained in any parent: return false</li>
      * </ul>
      *
-     * @param canonicalParent
-     *            the file to consider as the parent.
-     * @param canonicalChild
-     *            the file to consider as the child.
-     * @return true is the candidate leaf is under by the specified composite. False otherwise.
+     * @param canonicalParent the path string to consider as the parent.
+     * @param canonicalChild the path string to consider as the child.
+     * @return true if the candidate leaf is under the specified composite. False otherwise.
      * @since 2.2
      * @see FileUtils#directoryContains(File, File)
      */
@@ -259,7 +297,7 @@ public static boolean directoryContains(final String canonicalParent, final Stri
     /**
      * Does the work of getting the path.
      *
-     * @param fileName  the fileName
+     * @param fileName  the file name
      * @param includeSeparator  true to include the end separator
      * @return the path
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
@@ -292,7 +330,7 @@ private static String doGetFullPath(final String fileName, final boolean include
     /**
      * Does the work of getting the path.
      *
-     * @param fileName  the fileName
+     * @param fileName  the file name
      * @param separatorAdd  0 to omit the end separator, 1 to return it
      * @return the path
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
@@ -316,11 +354,11 @@ private static String doGetPath(final String fileName, final int separatorAdd) {
     /**
      * Internal method to perform the normalization.
      *
-     * @param fileName  the fileName
+     * @param fileName  the file name
      * @param separator The separator character to use
      * @param keepSeparator  true to keep the final separator
      * @return the normalized fileName
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {
         if (fileName == null) {
@@ -421,15 +459,15 @@ private static String doNormalize(final String fileName, final char separator, f
     }
 
     /**
-     * Checks whether two fileNames are equal exactly.
+     * Checks whether two file names are exactly equal.
      * <p>
-     * No processing is performed on the fileNames other than comparison,
-     * thus this is merely a null-safe case-sensitive equals.
+     * No processing is performed on the file names other than comparison.
+     * This is merely a null-safe case-sensitive string equality.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SENSITIVE
      */
     public static boolean equals(final String fileName1, final String fileName2) {
@@ -437,14 +475,14 @@ public static boolean equals(final String fileName1, final String fileName2) {
     }
 
     /**
-     * Checks whether two fileNames are equal, optionally normalizing and providing
+     * Checks whether two file names are equal, optionally normalizing and providing
      * control over the case-sensitivity.
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @param normalize  whether to normalize the fileNames
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @param normalize  whether to normalize the file names
      * @param ioCase  what case sensitivity rule to use, null means case-sensitive
-     * @return true if the fileNames are equal, null equals null
+     * @return true if the file names are equal, null equals null
      * @since 1.3
      */
     public static boolean equals(String fileName1, String fileName2, final boolean normalize, final IOCase ioCase) {
@@ -466,15 +504,15 @@ public static boolean equals(String fileName1, String fileName2, final boolean n
     }
 
     /**
-     * Checks whether two fileNames are equal after both have been normalized.
+     * Checks whether two file names are equal after both have been normalized.
      * <p>
-     * Both fileNames are first passed to {@link #normalize(String)}.
+     * Both file names are first passed to {@link #normalize(String)}.
      * The check is then performed in a case-sensitive manner.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SENSITIVE
      */
     public static boolean equalsNormalized(final String fileName1, final String fileName2) {
@@ -482,17 +520,17 @@ public static boolean equalsNormalized(final String fileName1, final String file
     }
 
     /**
-     * Checks whether two fileNames are equal after both have been normalized
-     * and using the case rules of the system.
+     * Checks whether two file names are equal using the case rules of the system
+     * after both have been normalized.
      * <p>
-     * Both fileNames are first passed to {@link #normalize(String)}.
-     * The check is then performed case-sensitive on Unix and
-     * case-insensitive on Windows.
+     * Both file names are first passed to {@link #normalize(String)}.
+     * The check is then performed case-sensitively on UNIX and
+     * case-insensitively on Windows.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SYSTEM
      */
     public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {
@@ -500,15 +538,15 @@ public static boolean equalsNormalizedOnSystem(final String fileName1, final Str
     }
 
     /**
-     * Checks whether two fileNames are equal using the case rules of the system.
+     * Checks whether two file names are equal using the case rules of the system.
      * <p>
-     * No processing is performed on the fileNames other than comparison.
-     * The check is case-sensitive on Unix and case-insensitive on Windows.
+     * No processing is performed on the file names other than comparison.
+     * The check is case-sensitive on UNIX and case-insensitive on Windows.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SYSTEM
      */
     public static boolean equalsOnSystem(final String fileName1, final String fileName2) {
@@ -532,7 +570,7 @@ static char flipSeparator(final char ch) {
     }
 
     /**
-     * Special handling for NTFS ADS: Don't accept colon in the fileName.
+     * Special handling for NTFS ADS: Don't accept colon in the file name.
      *
      * @param fileName a file name
      * @return ADS offsets.
@@ -554,13 +592,15 @@ private static int getAdsCriticalOffset(final String fileName) {
     }
 
     /**
-     * Gets the base name, minus the full path and extension, from a full fileName.
+     * Gets the base name, minus the full path and extension, from a full file name.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a path in either UNIX or Windows format.
      * The text after the last forward or backslash and before the last dot is returned.
      * </p>
      * <pre>
      * a/b/c.txt --&gt; c
+     * a\b\c.txt --&gt; c
+     * a/b/c.foo.txt --&gt; c.foo
      * a.txt     --&gt; a
      * a/b/c     --&gt; c
      * a/b/c/    --&gt; ""
@@ -569,9 +609,9 @@ private static int getAdsCriticalOffset(final String fileName) {
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the name of the file without the path, or an empty string if none exists
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String getBaseName(final String fileName) {
         return removeExtension(getName(fileName));
@@ -580,7 +620,7 @@ public static String getBaseName(final String fileName) {
     /**
      * Gets the extension of a fileName.
      * <p>
-     * This method returns the textual part of the fileName after the last dot.
+     * This method returns the textual part of the file name after the last dot.
      * There must be no directory separator after the dot.
      * </p>
      * <pre>
@@ -594,17 +634,17 @@ public static String getBaseName(final String fileName) {
      * exception of a possible {@link IllegalArgumentException} on Windows (see below).
      * </p>
      * <p>
-     * <b>Note:</b> This method used to have a hidden problem for names like "foo.exe:bar.txt".
+     * <strong>Note:</strong> This method used to have a hidden problem for names like "foo.exe:bar.txt".
      * In this case, the name wouldn't be the name of a file, but the identifier of an
      * alternate data stream (bar.txt) on the file foo.exe. The method used to return
-     * ".txt" here, which would be misleading. Commons IO 2.7, and later versions, are throwing
+     * ".txt" here, which would be misleading. Commons IO 2.7 and later throw
      * an {@link IllegalArgumentException} for names like this.
      * </p>
      *
-     * @param fileName the fileName to retrieve the extension of.
+     * @param fileName the file name to retrieve the extension of.
      * @return the extension of the file or an empty string if none exists or {@code null}
-     * if the fileName is {@code null}.
-     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,
+     * if the file name is {@code null}.
+     * @throws IllegalArgumentException <strong>Windows only:</strong> the file name parameter is, in fact,
      * the identifier of an Alternate Data Stream, for example "foo.exe:bar.txt".
      */
     public static String getExtension(final String fileName) throws IllegalArgumentException {
@@ -619,9 +659,9 @@ public static String getExtension(final String fileName) throws IllegalArgumentE
     }
 
     /**
-     * Gets the full path from a full fileName, which is the prefix + path.
+     * Gets the full path (prefix + path) from a full file name.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * The method is entirely text based, and returns the text before and
      * including the last forward or backslash.
      * </p>
@@ -642,7 +682,7 @@ public static String getExtension(final String fileName) throws IllegalArgumentE
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -651,10 +691,10 @@ public static String getFullPath(final String fileName) {
     }
 
     /**
-     * Gets the full path from a full fileName, which is the prefix + path,
-     * and also excluding the final directory separator.
+     * Gets the full path (prefix + path) from a full file name,
+     * excluding the final directory separator.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * The method is entirely text based, and returns the text before the
      * last forward or backslash.
      * </p>
@@ -675,7 +715,7 @@ public static String getFullPath(final String fileName) {
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -684,13 +724,14 @@ public static String getFullPathNoEndSeparator(final String fileName) {
     }
 
     /**
-     * Gets the name minus the path from a full fileName.
+     * Gets the name minus the path from a full file name.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * The text after the last forward or backslash is returned.
      * </p>
      * <pre>
      * a/b/c.txt --&gt; c.txt
+     * a\b\c.txt --&gt; c.txt
      * a.txt     --&gt; a.txt
      * a/b/c     --&gt; c
      * a/b/c/    --&gt; ""
@@ -699,9 +740,9 @@ public static String getFullPathNoEndSeparator(final String fileName) {
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the name of the file without the path, or an empty string if none exists
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String getName(final String fileName) {
         if (fileName == null) {
@@ -711,9 +752,9 @@ public static String getName(final String fileName) {
     }
 
     /**
-     * Gets the path from a full fileName, which excludes the prefix.
+     * Gets the path from a full file name, which excludes the prefix and the name.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * The method is entirely text based, and returns the text before and
      * including the last forward or backslash.
      * </p>
@@ -732,7 +773,7 @@ public static String getName(final String fileName) {
      * See {@link #getFullPath(String)} for the method that retains the prefix.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -741,10 +782,10 @@ public static String getPath(final String fileName) {
     }
 
     /**
-     * Gets the path from a full fileName, which excludes the prefix, and
+     * Gets the path (which excludes the prefix) from a full file name, and
      * also excluding the final directory separator.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * The method is entirely text based, and returns the text before the
      * last forward or backslash.
      * </p>
@@ -763,7 +804,7 @@ public static String getPath(final String fileName) {
      * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -772,11 +813,10 @@ public static String getPathNoEndSeparator(final String fileName) {
     }
 
     /**
-     * Gets the prefix from a full fileName, such as {@code C:/}
-     * or {@code ~/}.
+     * Gets the prefix such as {@code C:/} or {@code ~/} from a full file name,
      * <p>
-     * This method will handle a file in either Unix or Windows format.
-     * The prefix includes the first slash in the full fileName where applicable.
+     * This method will handle a file in either UNIX or Windows format.
+     * The prefix includes the first slash in the full file name where applicable.
      * </p>
      * <pre>
      * Windows:
@@ -796,10 +836,10 @@ public static String getPathNoEndSeparator(final String fileName) {
      * </pre>
      * <p>
      * The output will be the same irrespective of the machine that the code is running on.
-     * ie. both Unix and Windows prefixes are matched regardless.
+     * ie. both UNIX and Windows prefixes are matched regardless.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the prefix of the file, null if invalid
      * @throws IllegalArgumentException if the result contains the null character ({@code U+0000})
      */
@@ -819,12 +859,12 @@ public static String getPrefix(final String fileName) {
     }
 
     /**
-     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.
+     * Returns the length of the file name prefix, such as {@code C:/} or {@code ~/}.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * </p>
      * <p>
-     * The prefix length includes the first slash in the full fileName
+     * The prefix length includes the first slash in the full file name
      * if applicable. Thus, it is possible that the length returned is greater
      * than the length of the input string.
      * </p>
@@ -850,15 +890,15 @@ public static String getPrefix(final String fileName) {
      * </pre>
      * <p>
      * The output will be the same irrespective of the machine that the code is running on.
-     * ie. both Unix and Windows prefixes are matched regardless.
+     * ie. both UNIX and Windows prefixes are matched regardless.
      * </p>
      * <p>
      * Note that a leading // (or \\) is used to indicate a UNC name on Windows.
      * These must be followed by a server name, so double-slashes are not collapsed
-     * to a single slash at the start of the fileName.
+     * to a single slash at the start of the file name.
      * </p>
      *
-     * @param fileName  the fileName to find the prefix in, null returns -1
+     * @param fileName  the file name to find the prefix in, null returns -1
      * @return the length of the prefix, -1 if invalid or null
      */
     public static int getPrefixLength(final String fileName) {
@@ -926,22 +966,22 @@ public static int getPrefixLength(final String fileName) {
      * Returns the index of the last extension separator character, which is a dot.
      * <p>
      * This method also checks that there is no directory separator after the last dot. To do this it uses
-     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.
+     * {@link #indexOfLastSeparator(String)} which will handle a file in either UNIX or Windows format.
      * </p>
      * <p>
      * The output will be the same irrespective of the machine that the code is running on, with the
      * exception of a possible {@link IllegalArgumentException} on Windows (see below).
      * </p>
-     * <b>Note:</b> This method used to have a hidden problem for names like "foo.exe:bar.txt".
+     * <strong>Note:</strong> This method used to have a hidden problem for names like "foo.exe:bar.txt".
      * In this case, the name wouldn't be the name of a file, but the identifier of an
      * alternate data stream (bar.txt) on the file foo.exe. The method used to return
      * ".txt" here, which would be misleading. Commons IO 2.7, and later versions, are throwing
      * an {@link IllegalArgumentException} for names like this.
      *
      * @param fileName
-     *            the fileName to find the last extension separator in, null returns -1
+     *            the file name to find the last extension separator in, null returns -1
      * @return the index of the last extension separator character, or -1 if there is no such character
-     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,
+     * @throws IllegalArgumentException <strong>Windows only:</strong> the file name parameter is, in fact,
      * the identifier of an Alternate Data Stream, for example "foo.exe:bar.txt".
      */
     public static int indexOfExtension(final String fileName) throws IllegalArgumentException {
@@ -949,7 +989,7 @@ public static int indexOfExtension(final String fileName) throws IllegalArgument
             return NOT_FOUND;
         }
         if (isSystemWindows()) {
-            // Special handling for NTFS ADS: Don't accept colon in the fileName.
+            // Special handling for NTFS ADS: Don't accept colon in the file name.
             final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));
             if (offset != -1) {
                 throw new IllegalArgumentException("NTFS ADS separator (':') in file name is forbidden.");
@@ -963,12 +1003,12 @@ public static int indexOfExtension(final String fileName) throws IllegalArgument
     /**
      * Returns the index of the last directory separator character.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a file in either UNIX or Windows format.
      * The position of the last forward or backslash is returned.
      * <p>
      * The output will be the same irrespective of the machine that the code is running on.
      *
-     * @param fileName  the fileName to find the last path separator in, null returns -1
+     * @param fileName  the file name to find the last path separator in, null returns -1
      * @return the index of the last separator character, or -1 if there
      * is no such character
      */
@@ -986,16 +1026,16 @@ private static boolean isEmpty(final String string) {
     }
 
     /**
-     * Checks whether the extension of the fileName is one of those specified.
+     * Checks whether the extension of the file name is one of those specified.
      * <p>
-     * This method obtains the extension as the textual part of the fileName
+     * This method obtains the extension as the textual part of the file name
      * after the last dot. There must be no directory separator after the dot.
      * The extension check is case-sensitive on all platforms.
      *
-     * @param fileName  the fileName to query, null returns false
+     * @param fileName  the file name, null returns false
      * @param extensions  the extensions to check for, null checks for no extension
-     * @return true if the fileName is one of the extensions
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @return true if the file name is one of the extensions
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static boolean isExtension(final String fileName, final Collection<String> extensions) {
         if (fileName == null) {
@@ -1010,16 +1050,16 @@ public static boolean isExtension(final String fileName, final Collection<String
     }
 
     /**
-     * Checks whether the extension of the fileName is that specified.
+     * Checks whether the extension of the file name is that specified.
      * <p>
-     * This method obtains the extension as the textual part of the fileName
+     * This method obtains the extension as the textual part of the file name
      * after the last dot. There must be no directory separator after the dot.
      * The extension check is case-sensitive on all platforms.
      *
-     * @param fileName  the fileName to query, null returns false
+     * @param fileName  the file name, null returns false
      * @param extension  the extension to check for, null or empty checks for no extension
-     * @return true if the fileName has the specified extension
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @return true if the file name has the specified extension
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static boolean isExtension(final String fileName, final String extension) {
         if (fileName == null) {
@@ -1034,16 +1074,16 @@ public static boolean isExtension(final String fileName, final String extension)
     }
 
     /**
-     * Checks whether the extension of the fileName is one of those specified.
+     * Checks whether the extension of the file name is one of those specified.
      * <p>
-     * This method obtains the extension as the textual part of the fileName
+     * This method obtains the extension as the textual part of the file name
      * after the last dot. There must be no directory separator after the dot.
      * The extension check is case-sensitive on all platforms.
      *
-     * @param fileName  the fileName to query, null returns false
+     * @param fileName  the file name, null returns false
      * @param extensions  the extensions to check for, null checks for no extension
-     * @return true if the fileName is one of the extensions
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @return true if the file name is one of the extensions
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static boolean isExtension(final String fileName, final String... extensions) {
         if (fileName == null) {
@@ -1216,17 +1256,16 @@ private static boolean isValidHostName(final String name) {
      * Normalizes a path, removing double and single dot path steps.
      * <p>
      * This method normalizes a path to a standard format.
-     * The input may contain separators in either Unix or Windows format.
+     * The input may contain separators in either UNIX or Windows format.
      * The output will contain separators in the format of the system.
      * <p>
      * A trailing slash will be retained.
      * A double slash will be merged to a single slash (but UNC names are handled).
      * A single dot path segment will be removed.
      * A double dot will cause that path segment and the one before to be removed.
-     * If the double dot has no parent path segment to work with, {@code null}
-     * is returned.
+     * If the double dot has no parent path segment, {@code null} is returned.
      * <p>
-     * The output will be the same on both Unix and Windows except
+     * The output will be the same on both UNIX and Windows except
      * for the separator character.
      * <pre>
      * /foo//               --&gt;   /foo/
@@ -1247,11 +1286,11 @@ private static boolean isValidHostName(final String name) {
      * ~/foo/../bar/        --&gt;   ~/bar/
      * ~/../bar             --&gt;   null
      * </pre>
-     * (Note the file separator returned will be correct for Windows/Unix)
+     * (Note the file separator will be correct for Windows/Unix.)
      *
-     * @param fileName  the fileName to normalize, null returns null
+     * @param fileName  the file name to normalize, null returns null
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String normalize(final String fileName) {
         return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, true);
@@ -1261,7 +1300,7 @@ public static String normalize(final String fileName) {
      * Normalizes a path, removing double and single dot path steps.
      * <p>
      * This method normalizes a path to a standard format.
-     * The input may contain separators in either Unix or Windows format.
+     * The input may contain separators in either UNIX or Windows format.
      * The output will contain separators in the format specified.
      * <p>
      * A trailing slash will be retained.
@@ -1271,7 +1310,7 @@ public static String normalize(final String fileName) {
      * If the double dot has no parent path segment to work with, {@code null}
      * is returned.
      * <p>
-     * The output will be the same on both Unix and Windows except
+     * The output will be the same on both UNIX and Windows except
      * for the separator character.
      * <pre>
      * /foo//               --&gt;   /foo/
@@ -1292,14 +1331,14 @@ public static String normalize(final String fileName) {
      * ~/foo/../bar/        --&gt;   ~/bar/
      * ~/../bar             --&gt;   null
      * </pre>
-     * The output will be the same on both Unix and Windows including
+     * The output will be the same on both UNIX and Windows including
      * the separator character.
      *
-     * @param fileName  the fileName to normalize, null returns null
-     * @param unixSeparator {@code true} if a Unix separator should
+     * @param fileName  the file name to normalize, null returns null
+     * @param unixSeparator {@code true} if a UNIX separator should
      * be used or {@code false} if a Windows separator should be used.
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      * @since 2.0
      */
     public static String normalize(final String fileName, final boolean unixSeparator) {
@@ -1311,7 +1350,7 @@ public static String normalize(final String fileName, final boolean unixSeparato
      * and removing any final directory separator.
      * <p>
      * This method normalizes a path to a standard format.
-     * The input may contain separators in either Unix or Windows format.
+     * The input may contain separators in either UNIX or Windows format.
      * The output will contain separators in the format of the system.
      * <p>
      * A trailing slash will be removed.
@@ -1321,7 +1360,7 @@ public static String normalize(final String fileName, final boolean unixSeparato
      * If the double dot has no parent path segment to work with, {@code null}
      * is returned.
      * <p>
-     * The output will be the same on both Unix and Windows except
+     * The output will be the same on both UNIX and Windows except
      * for the separator character.
      * <pre>
      * /foo//               --&gt;   /foo
@@ -1344,9 +1383,9 @@ public static String normalize(final String fileName, final boolean unixSeparato
      * </pre>
      * (Note the file separator returned will be correct for Windows/Unix)
      *
-     * @param fileName  the fileName to normalize, null returns null
+     * @param fileName  the file name to normalize, null returns null
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String normalizeNoEndSeparator(final String fileName) {
         return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, false);
@@ -1357,7 +1396,7 @@ public static String normalizeNoEndSeparator(final String fileName) {
      * and removing any final directory separator.
      * <p>
      * This method normalizes a path to a standard format.
-     * The input may contain separators in either Unix or Windows format.
+     * The input may contain separators in either UNIX or Windows format.
      * The output will contain separators in the format specified.
      * <p>
      * A trailing slash will be removed.
@@ -1367,7 +1406,7 @@ public static String normalizeNoEndSeparator(final String fileName) {
      * If the double dot has no parent path segment to work with, {@code null}
      * is returned.
      * <p>
-     * The output will be the same on both Unix and Windows including
+     * The output will be the same on both UNIX and Windows including
      * the separator character.
      * <pre>
      * /foo//               --&gt;   /foo
@@ -1389,11 +1428,11 @@ public static String normalizeNoEndSeparator(final String fileName) {
      * ~/../bar             --&gt;   null
      * </pre>
      *
-     * @param fileName  the fileName to normalize, null returns null
-     * @param unixSeparator {@code true} if a Unix separator should
+     * @param fileName  the file name to normalize, null returns null
+     * @param unixSeparator {@code true} if a UNIX separator should
      * be used or {@code false} if a Windows separator should be used.
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      * @since 2.0
      */
     public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {
@@ -1403,20 +1442,22 @@ public static String normalizeNoEndSeparator(final String fileName, final boolea
     /**
      * Removes the extension from a fileName.
      * <p>
-     * This method returns the textual part of the fileName before the last dot.
+     * This method returns the textual part of the file name before the last dot.
      * There must be no directory separator after the dot.
      * <pre>
      * foo.txt    --&gt; foo
+     * .txt       --&gt; "" (empty string)
      * a\b\c.jpg  --&gt; a\b\c
+     * /a/b/c.jpg --&gt; /a/b/c
      * a\b\c      --&gt; a\b\c
      * a.b\c      --&gt; a.b\c
      * </pre>
      * <p>
      * The output will be the same irrespective of the machine that the code is running on.
      *
-     * @param fileName  the fileName to query, null returns null
-     * @return the fileName minus the extension
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @param fileName  the file name, null returns null
+     * @return the file name minus the extension
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String removeExtension(final String fileName) {
         if (fileName == null) {
@@ -1434,7 +1475,7 @@ public static String removeExtension(final String fileName) {
     /**
      * Checks the input for null characters ({@code U+0000}), a sign of unsanitized data being passed to file level functions.
      *
-     * This may be used for poison byte attacks.
+     * This may be used to defend against poison byte attacks.
      *
      * @param path the path to check
      * @return The input
@@ -1459,7 +1500,7 @@ public static String separatorsToSystem(final String path) {
     }
 
     /**
-     * Converts all separators to the Unix separator of forward slash.
+     * Converts all separators to the UNIX separator of forward slash.
      *
      * @param path the path to be changed, null ignored.
      * @return the new path.
@@ -1548,9 +1589,9 @@ private static char toSeparator(final boolean unixSeparator) {
      * </pre>
      * N.B. the sequence "*?" does not work properly at present in match strings.
      *
-     * @param fileName  the fileName to match on
+     * @param fileName  the file name to match on
      * @param wildcardMatcher  the wildcard string to match against
-     * @return true if the fileName matches the wildcard string
+     * @return true if the file name matches the wildcard string
      * @see IOCase#SENSITIVE
      */
     public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {
@@ -1565,10 +1606,10 @@ public static boolean wildcardMatch(final String fileName, final String wildcard
      * single or multiple (zero or more) wildcard characters.
      * N.B. the sequence "*?" does not work properly at present in match strings.
      *
-     * @param fileName  the fileName to match on
+     * @param fileName  the file name to match on
      * @param wildcardMatcher  the wildcard string to match against
      * @param ioCase  what case sensitivity rule to use, null means case-sensitive
-     * @return true if the fileName matches the wildcard string
+     * @return true if the file name matches the wildcard string
      * @since 1.3
      */
     public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase ioCase) {
@@ -1656,7 +1697,7 @@ public static boolean wildcardMatch(final String fileName, final String wildcard
      * The wildcard matcher uses the characters '?' and '*' to represent a
      * single or multiple (zero or more) wildcard characters.
      * This is the same as often found on DOS/Unix command lines.
-     * The check is case-sensitive on Unix and case-insensitive on Windows.
+     * The check is case-sensitive on UNIX and case-insensitive on Windows.
      * <pre>
      * wildcardMatch("c.txt", "*.txt")      --&gt; true
      * wildcardMatch("c.txt", "*.jpg")      --&gt; false
@@ -1666,9 +1707,9 @@ public static boolean wildcardMatch(final String fileName, final String wildcard
      * </pre>
      * N.B. the sequence "*?" does not work properly at present in match strings.
      *
-     * @param fileName  the fileName to match on
+     * @param fileName  the file name to match on
      * @param wildcardMatcher  the wildcard string to match against
-     * @return true if the fileName matches the wildcard string
+     * @return true if the file name matches the wildcard string
      * @see IOCase#SYSTEM
      */
     public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {
@@ -1677,7 +1718,11 @@ public static boolean wildcardMatchOnSystem(final String fileName, final String
 
     /**
      * Instances should NOT be constructed in standard programming.
+     *
+     * @deprecated TODO Make private in 3.0.
      */
+    @Deprecated
     public FilenameUtils() {
+        // empty
     }
 }
diff --git a/src/main/java/org/apache/commons/io/HexDump.java b/src/main/java/org/apache/commons/io/HexDump.java
index 0a53e3d6..e747be6d 100644
--- a/src/main/java/org/apache/commons/io/HexDump.java
+++ b/src/main/java/org/apache/commons/io/HexDump.java
@@ -199,30 +199,29 @@ public static void dump(final byte[] data, final long offset,
     /**
      * Dumps a byte value into a StringBuilder.
      *
-     * @param _cbuffer the StringBuilder to dump the value in
+     * @param builder the StringBuilder to dump the value in
      * @param value  the byte value to be dumped
      * @return StringBuilder containing the dumped value.
      */
-    private static StringBuilder dump(final StringBuilder _cbuffer, final byte value) {
+    private static StringBuilder dump(final StringBuilder builder, final byte value) {
         for (int j = 0; j < 2; j++) {
-            _cbuffer.append(HEX_CODES[value >> SHIFTS[j + 6] & 15]);
+            builder.append(HEX_CODES[value >> SHIFTS[j + 6] & 15]);
         }
-        return _cbuffer;
+        return builder;
     }
 
     /**
      * Dumps a long value into a StringBuilder.
      *
-     * @param _lbuffer the StringBuilder to dump the value in
+     * @param builder the StringBuilder to dump the value in
      * @param value  the long value to be dumped
      * @return StringBuilder containing the dumped value.
      */
-    private static StringBuilder dump(final StringBuilder _lbuffer, final long value) {
+    private static StringBuilder dump(final StringBuilder builder, final long value) {
         for (int j = 0; j < 8; j++) {
-            _lbuffer
-                    .append(HEX_CODES[(int) (value >> SHIFTS[j]) & 15]);
+            builder.append(HEX_CODES[(int) (value >> SHIFTS[j]) & 15]);
         }
-        return _lbuffer;
+        return builder;
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/IO.java b/src/main/java/org/apache/commons/io/IO.java
index d9db4246..11d6421c 100644
--- a/src/main/java/org/apache/commons/io/IO.java
+++ b/src/main/java/org/apache/commons/io/IO.java
@@ -19,7 +19,7 @@
 /**
  * Component-wide operations on Apache Commons IO.
  */
-class IO {
+final class IO {
 
     /**
      * Clears any state, throughout Apache Commons IO. Handy for tests.
diff --git a/src/main/java/org/apache/commons/io/IOCase.java b/src/main/java/org/apache/commons/io/IOCase.java
index cc425609..c803b2fe 100644
--- a/src/main/java/org/apache/commons/io/IOCase.java
+++ b/src/main/java/org/apache/commons/io/IOCase.java
@@ -16,6 +16,7 @@
  */
 package org.apache.commons.io;
 
+import java.io.File;
 import java.util.Objects;
 import java.util.stream.Stream;
 
@@ -23,7 +24,7 @@
  * Enumeration of IO case sensitivity.
  * <p>
  * Different filing systems have different rules for case-sensitivity.
- * Windows is case-insensitive, Unix is case-sensitive.
+ * Windows is case-insensitive, UNIX is case-sensitive.
  * </p>
  * <p>
  * This class captures that difference, providing an enumeration to
@@ -51,12 +52,12 @@ public enum IOCase {
 
     /**
      * The constant for case sensitivity determined by the current operating system.
-     * Windows is case-insensitive when comparing file names, Unix is case-sensitive.
+     * Windows is case-insensitive when comparing file names, UNIX is case-sensitive.
      * <p>
      * <strong>Note:</strong> This only caters for Windows and Unix. Other operating
      * systems (e.g. OSX and OpenVMS) are treated as case-sensitive if they use the
-     * Unix file separator and case-insensitive if they use the Windows file separator
-     * (see {@link java.io.File#separatorChar}).
+     * UNIX file separator and case-insensitive if they use the Windows file separator
+     * (see {@link File#separatorChar}).
      * </p>
      * <p>
      * If you serialize this constant on Windows, and deserialize on Unix, or vice
@@ -69,14 +70,14 @@ public enum IOCase {
     private static final long serialVersionUID = -6343169151696340687L;
 
     /**
-     * Factory method to create an IOCase from a name.
+     * Looks up an IOCase by name.
      *
      * @param name  the name to find
      * @return the IOCase object
      * @throws IllegalArgumentException if the name is invalid
      */
     public static IOCase forName(final String name) {
-        return Stream.of(IOCase.values()).filter(ioCase -> ioCase.getName().equals(name)).findFirst()
+        return Stream.of(values()).filter(ioCase -> ioCase.getName().equals(name)).findFirst()
                 .orElseThrow(() -> new IllegalArgumentException("Illegal IOCase name: " + name));
     }
 
@@ -112,8 +113,8 @@ public static IOCase value(final IOCase value, final IOCase defaultValue) {
     /**
      * Constructs a new instance.
      *
-     * @param name  the name
-     * @param sensitive  the sensitivity
+     * @param name  the name.
+     * @param sensitive  the sensitivity.
      */
     IOCase(final String name, final boolean sensitive) {
         this.name = name;
@@ -127,10 +128,10 @@ public static IOCase value(final IOCase value, final IOCase defaultValue) {
      * into account.
      * </p>
      *
-     * @param str1  the first string to compare, not null
-     * @param str2  the second string to compare, not null
-     * @return true if equal using the case rules
-     * @throws NullPointerException if either string is null
+     * @param str1  the first string to compare, not null.
+     * @param str2  the second string to compare, not null.
+     * @return true if equal using the case rules.
+     * @throws NullPointerException if either string is null.
      */
     public int checkCompareTo(final String str1, final String str2) {
         Objects.requireNonNull(str1, "str1");
@@ -145,9 +146,9 @@ public int checkCompareTo(final String str1, final String str2) {
      * into account.
      * </p>
      *
-     * @param str  the string to check
-     * @param end  the end to compare against
-     * @return true if equal using the case rules, false if either input is null
+     * @param str  the string to check.
+     * @param end  the end to compare against.
+     * @return true if equal using the case rules, false if either input is null.
      */
     public boolean checkEndsWith(final String str, final String end) {
         if (str == null || end == null) {
@@ -164,15 +165,12 @@ public boolean checkEndsWith(final String str, final String end) {
      * into account.
      * </p>
      *
-     * @param str1  the first string to compare, not null
-     * @param str2  the second string to compare, not null
-     * @return true if equal using the case rules
-     * @throws NullPointerException if either string is null
+     * @param str1  the first string to compare.
+     * @param str2  the second string to compare.
+     * @return true if equal using the case rules.
      */
     public boolean checkEquals(final String str1, final String str2) {
-        Objects.requireNonNull(str1, "str1");
-        Objects.requireNonNull(str2, "str2");
-        return sensitive ? str1.equals(str2) : str1.equalsIgnoreCase(str2);
+        return str1 == str2 || str1 != null && (sensitive ? str1.equals(str2) : str1.equalsIgnoreCase(str2));
     }
 
     /**
@@ -183,20 +181,21 @@ public boolean checkEquals(final String str1, final String str2) {
      * but takes case-sensitivity into account.
      * </p>
      *
-     * @param str  the string to check, not null
-     * @param strStartIndex  the index to start at in str
-     * @param search  the start to search for, not null
+     * @param str  the string to check.
+     * @param strStartIndex  the index to start at in str.
+     * @param search  the start to search for.
      * @return the first index of the search String,
-     *  -1 if no match or {@code null} string input
-     * @throws NullPointerException if either string is null
+     *  -1 if no match or {@code null} string input.
      * @since 2.0
      */
     public int checkIndexOf(final String str, final int strStartIndex, final String search) {
-        final int endIndex = str.length() - search.length();
-        if (endIndex >= strStartIndex) {
-            for (int i = strStartIndex; i <= endIndex; i++) {
-                if (checkRegionMatches(str, i, search)) {
-                    return i;
+        if (str != null && search != null) {
+            final int endIndex = str.length() - search.length();
+            if (endIndex >= strStartIndex) {
+                for (int i = strStartIndex; i <= endIndex; i++) {
+                    if (checkRegionMatches(str, i, search)) {
+                        return i;
+                    }
                 }
             }
         }
@@ -210,14 +209,13 @@ public int checkIndexOf(final String str, final int strStartIndex, final String
      * but takes case-sensitivity into account.
      * </p>
      *
-     * @param str  the string to check, not null
-     * @param strStartIndex  the index to start at in str
-     * @param search  the start to search for, not null
-     * @return true if equal using the case rules
-     * @throws NullPointerException if either string is null
+     * @param str  the string to check.
+     * @param strStartIndex  the index to start at in str.
+     * @param search  the start to search for,.
+     * @return true if equal using the case rules.
      */
     public boolean checkRegionMatches(final String str, final int strStartIndex, final String search) {
-        return str.regionMatches(!sensitive, strStartIndex, search, 0, search.length());
+        return str != null && search != null && str.regionMatches(!sensitive, strStartIndex, search, 0, search.length());
     }
 
     /**
@@ -227,9 +225,9 @@ public boolean checkRegionMatches(final String str, final int strStartIndex, fin
      * into account.
      * </p>
      *
-     * @param str  the string to check
-     * @param start  the start to compare against
-     * @return true if equal using the case rules, false if either input is null
+     * @param str  the string to check.
+     * @param start  the start to compare against.
+     * @return true if equal using the case rules, false if either input is null.
      */
     public boolean checkStartsWith(final String str, final String start) {
         return str != null && start != null && str.regionMatches(!sensitive, 0, start, 0, start.length());
@@ -247,7 +245,7 @@ public String getName() {
     /**
      * Does the object represent case-sensitive comparison.
      *
-     * @return true if case-sensitive
+     * @return true if case-sensitive.
      */
     public boolean isCaseSensitive() {
         return sensitive;
@@ -257,7 +255,7 @@ public boolean isCaseSensitive() {
      * Replaces the enumeration from the stream with a real one.
      * This ensures that the correct flag is set for SYSTEM.
      *
-     * @return the resolved object
+     * @return the resolved object.
      */
     private Object readResolve() {
         return forName(name);
@@ -266,7 +264,7 @@ private Object readResolve() {
     /**
      * Gets a string describing the sensitivity.
      *
-     * @return a string describing the sensitivity
+     * @return a string describing the sensitivity.
      */
     @Override
     public String toString() {
diff --git a/src/main/java/org/apache/commons/io/IOExceptionList.java b/src/main/java/org/apache/commons/io/IOExceptionList.java
index 8ee519b5..7db7fb8d 100644
--- a/src/main/java/org/apache/commons/io/IOExceptionList.java
+++ b/src/main/java/org/apache/commons/io/IOExceptionList.java
@@ -18,6 +18,7 @@
 package org.apache.commons.io;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -62,6 +63,9 @@ private static String toMessage(final List<? extends Throwable> causeList) {
         return String.format("%,d exception(s): %s", size(causeList), causeList);
     }
 
+    /**
+     * List of causes.
+     */
     private final List<? extends Throwable> causeList;
 
     /**
@@ -115,7 +119,7 @@ public <T extends Throwable> T getCause(final int index, final Class<T> clazz) {
      * @return The list of causes.
      */
     public <T extends Throwable> List<T> getCauseList() {
-        return (List<T>) causeList;
+        return (List<T>) new ArrayList<>(causeList);
     }
 
     /**
@@ -126,7 +130,7 @@ public <T extends Throwable> List<T> getCauseList() {
      * @return The list of causes.
      */
     public <T extends Throwable> List<T> getCauseList(final Class<T> clazz) {
-        return (List<T>) causeList;
+        return (List<T>) new ArrayList<>(causeList);
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/io/IORandomAccessFile.java b/src/main/java/org/apache/commons/io/IORandomAccessFile.java
new file mode 100644
index 00000000..c5bfd5cc
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/IORandomAccessFile.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.RandomAccessFile;
+import java.util.Objects;
+
+/**
+ * Extends {@link RandomAccessFile} to provide access to the {@link File} and {@code mode} passed on construction.
+ *
+ * @since 2.18.0
+ * @see RandomAccessFile
+ * @see RandomAccessFileMode
+ */
+public final class IORandomAccessFile extends RandomAccessFile {
+
+    private final File file;
+    private final String mode;
+
+    /**
+     * Constructs a new instance by calling {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     *
+     * @param file the file object
+     * @param mode the access mode, as described in {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     * @throws FileNotFoundException Thrown by {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     * @see RandomAccessFile#RandomAccessFile(File, String)
+     */
+    public IORandomAccessFile(final File file, final String mode) throws FileNotFoundException {
+        super(file, mode);
+        this.file = file;
+        this.mode = mode;
+    }
+
+    /**
+     * Constructs a new instance by calling {@link RandomAccessFile#RandomAccessFile(String, String)}.
+     *
+     * @param name the file object
+     * @param mode the access mode, as described in {@link RandomAccessFile#RandomAccessFile(String, String)}.
+     * @throws FileNotFoundException Thrown by {@link RandomAccessFile#RandomAccessFile(String, String)}.
+     * @see RandomAccessFile#RandomAccessFile(String, String)
+     */
+    public IORandomAccessFile(final String name, final String mode) throws FileNotFoundException {
+        super(name, mode);
+        this.file = name != null ? new File(name) : null;
+        this.mode = mode;
+    }
+
+    /**
+     * Gets the file passed to {@link #IORandomAccessFile(File, String)}.
+     *
+     * @return the file passed to {@link #IORandomAccessFile(File, String)}.
+     */
+    public File getFile() {
+        return file;
+    }
+
+    /**
+     * Gets the mode passed to {@link #IORandomAccessFile(File, String)}.
+     *
+     * @return the mode passed to {@link #IORandomAccessFile(File, String)}.
+     */
+    public String getMode() {
+        return mode;
+    }
+
+    /**
+     * Returns the pathname string of this abstract pathname. This is just the string returned by the {@link File#toString()} method.
+     *
+     * @return The string form of the File's abstract pathname.
+     * @see File#toString()
+     */
+    @Override
+    public String toString() {
+        return Objects.toString(file);
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java
index dfb4c19e..2c420d07 100644
--- a/src/main/java/org/apache/commons/io/IOUtils.java
+++ b/src/main/java/org/apache/commons/io/IOUtils.java
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.commons.io;
 
 import java.io.BufferedInputStream;
@@ -30,6 +31,8 @@
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
 import java.io.Reader;
 import java.io.UncheckedIOException;
 import java.io.Writer;
@@ -61,6 +64,7 @@
 import org.apache.commons.io.function.IOConsumer;
 import org.apache.commons.io.function.IOSupplier;
 import org.apache.commons.io.function.IOTriFunction;
+import org.apache.commons.io.input.CharSequenceReader;
 import org.apache.commons.io.input.QueueInputStream;
 import org.apache.commons.io.output.AppendableWriter;
 import org.apache.commons.io.output.ByteArrayOutputStream;
@@ -128,7 +132,7 @@ public class IOUtils {
     // or return one of them.
 
     /**
-     * CR char.
+     * CR char '{@value}'.
      *
      * @since 2.9.0
      */
@@ -145,12 +149,12 @@ public class IOUtils {
     public static final char DIR_SEPARATOR = File.separatorChar;
 
     /**
-     * The Unix directory separator character.
+     * The UNIX directory separator character '{@value}'.
      */
     public static final char DIR_SEPARATOR_UNIX = '/';
 
     /**
-     * The Windows directory separator character.
+     * The Windows directory separator character '{@value}'.
      */
     public static final char DIR_SEPARATOR_WINDOWS = '\\';
 
@@ -162,13 +166,13 @@ public class IOUtils {
     public static final byte[] EMPTY_BYTE_ARRAY = {};
 
     /**
-     * Represents the end-of-file (or stream).
+     * Represents the end-of-file (or stream) value {@value}.
      * @since 2.5 (made public)
      */
     public static final int EOF = -1;
 
     /**
-     * LF char.
+     * LF char '{@value}'.
      *
      * @since 2.9.0
      */
@@ -183,7 +187,7 @@ public class IOUtils {
     public static final String LINE_SEPARATOR = System.lineSeparator();
 
     /**
-     * The Unix line separator string.
+     * The UNIX line separator string.
      *
      * @see StandardLineSeparator#LF
      */
@@ -541,7 +545,7 @@ public static void closeQuietly(final Closeable closeable) {
      * } catch (Exception e) {
      *     // error handling
      * } finally {
-     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>
+     *     <strong>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</strong>
      * }
      * </pre>
      * <p>
@@ -1104,7 +1108,7 @@ public static int copy(final InputStream inputStream, final OutputStream outputS
      */
     public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize)
             throws IOException {
-        return copyLarge(inputStream, outputStream, IOUtils.byteArray(bufferSize));
+        return copyLarge(inputStream, outputStream, byteArray(bufferSize));
     }
 
     /**
@@ -1123,7 +1127,7 @@ public static long copy(final InputStream inputStream, final OutputStream output
      * @throws NullPointerException if the input or output is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #copy(InputStream, Writer, Charset)} instead
+     * @deprecated Use {@link #copy(InputStream, Writer, Charset)} instead
      */
     @Deprecated
     public static void copy(final InputStream input, final Writer writer)
@@ -1151,8 +1155,7 @@ public static void copy(final InputStream input, final Writer writer)
      */
     public static void copy(final InputStream input, final Writer writer, final Charset inputCharset)
             throws IOException {
-        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(inputCharset));
-        copy(reader, writer);
+        copy(new InputStreamReader(input, Charsets.toCharset(inputCharset)), writer);
     }
 
     /**
@@ -1164,7 +1167,7 @@ public static void copy(final InputStream input, final Writer writer, final Char
      * </p>
      * <p>
      * Character encoding names can be found at
-     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <a href="https://www.iana.org/assignments/character-sets">IANA</a>.
      * </p>
      * <p>
      * This method uses {@link InputStreamReader}.
@@ -1175,9 +1178,7 @@ public static void copy(final InputStream input, final Writer writer, final Char
      * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default
      * @throws NullPointerException                         if the input or output is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static void copy(final InputStream input, final Writer writer, final String inputCharsetName)
@@ -1186,9 +1187,9 @@ public static void copy(final InputStream input, final Writer writer, final Stri
     }
 
     /**
-     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@link QueueInputStream}.
+     * Copies bytes from a {@link ByteArrayOutputStream} to a {@link QueueInputStream}.
      * <p>
-     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this
+     * Unlike using JDK {@link PipedInputStream} and {@link PipedOutputStream} for this, this
      * solution works safely in a single thread environment.
      * </p>
      * <p>
@@ -1202,9 +1203,9 @@ public static void copy(final InputStream input, final Writer writer, final Stri
      * InputStream inputStream = IOUtils.copy(outputStream);
      * </pre>
      *
-     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.
+     * @param outputStream the {@link ByteArrayOutputStream} to read.
      * @return the {@link QueueInputStream} filled with the content of the outputStream.
-     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.
+     * @throws NullPointerException if the {@link ByteArrayOutputStream} is {@code null}.
      * @throws IOException if an I/O error occurs.
      * @since 2.12
      */
@@ -1287,7 +1288,7 @@ public static long copy(final Reader reader, final Appendable output, final Char
      * @throws NullPointerException if the input or output is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #copy(Reader, OutputStream, Charset)} instead
+     * @deprecated Use {@link #copy(Reader, OutputStream, Charset)} instead
      */
     @Deprecated
     public static void copy(final Reader reader, final OutputStream output)
@@ -1352,9 +1353,7 @@ public static void copy(final Reader reader, final OutputStream output, final Ch
      * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default
      * @throws NullPointerException                         if the input or output is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName)
@@ -1509,7 +1508,7 @@ public static long copyLarge(final InputStream inputStream, final OutputStream o
      * @param output the {@link OutputStream} to write to
      * @param inputOffset : number of bytes to skip from input before copying
      * -ve values are ignored
-     * @param length : number of bytes to copy. -ve means all
+     * @param length number of bytes to copy. -ve means all
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
      * @throws IOException          if an I/O error occurs
@@ -1535,9 +1534,9 @@ public static long copyLarge(final InputStream input, final OutputStream output,
      *
      * @param input the {@link InputStream} to read
      * @param output the {@link OutputStream} to write to
-     * @param inputOffset : number of bytes to skip from input before copying
+     * @param inputOffset number of bytes to skip from input before copying
      * -ve values are ignored
-     * @param length : number of bytes to copy. -ve means all
+     * @param length number of bytes to copy. -ve means all
      * @param buffer the buffer to use for the copy
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
@@ -1629,9 +1628,9 @@ public static long copyLarge(final Reader reader, final Writer writer, final cha
      *
      * @param reader the {@link Reader} to read
      * @param writer the {@link Writer} to write to
-     * @param inputOffset : number of chars to skip from input before copying
+     * @param inputOffset number of chars to skip from input before copying
      * -ve values are ignored
-     * @param length : number of chars to copy. -ve means all
+     * @param length number of chars to copy. -ve means all
      * @return the number of chars copied
      * @throws NullPointerException if the input or output is null
      * @throws IOException          if an I/O error occurs
@@ -1652,9 +1651,9 @@ public static long copyLarge(final Reader reader, final Writer writer, final lon
      *
      * @param reader the {@link Reader} to read
      * @param writer the {@link Writer} to write to
-     * @param inputOffset : number of chars to skip from input before copying
+     * @param inputOffset number of chars to skip from input before copying
      * -ve values are ignored
-     * @param length : number of chars to copy. -ve means all
+     * @param length number of chars to copy. -ve means all
      * @param buffer the buffer to be used for the copy
      * @return the number of chars copied
      * @throws NullPointerException if the input or output is null
@@ -1690,7 +1689,7 @@ public static long copyLarge(final Reader reader, final Writer writer, final lon
     /**
      * Fills the given array with 0s.
      *
-     * @param arr The array to fill.
+     * @param arr The non-null array to fill.
      * @return The given array.
      */
     private static byte[] fill0(final byte[] arr) {
@@ -1701,7 +1700,7 @@ private static byte[] fill0(final byte[] arr) {
     /**
      * Fills the given array with 0s.
      *
-     * @param arr The array to fill.
+     * @param arr The non-null array to fill.
      * @return The given array.
      */
     private static char[] fill0(final char[] arr) {
@@ -1749,7 +1748,7 @@ static char[] getScratchCharArrayWriteOnly() {
      * Returns the length of the given array in a null-safe manner.
      *
      * @param array an array or null
-     * @return the array length -- or 0 if the given array is null.
+     * @return the array length, or 0 if the given array is null.
      * @since 2.7
      */
     public static int length(final byte[] array) {
@@ -1760,7 +1759,7 @@ public static int length(final byte[] array) {
      * Returns the length of the given array in a null-safe manner.
      *
      * @param array an array or null
-     * @return the array length -- or 0 if the given array is null.
+     * @return the array length, or 0 if the given array is null.
      * @since 2.7
      */
     public static int length(final char[] array) {
@@ -1771,7 +1770,7 @@ public static int length(final char[] array) {
      * Returns the length of the given CharSequence in a null-safe manner.
      *
      * @param csq a CharSequence or null
-     * @return the CharSequence length -- or 0 if the given CharSequence is null.
+     * @return the CharSequence length, or 0 if the given CharSequence is null.
      * @since 2.7
      */
     public static int length(final CharSequence csq) {
@@ -1782,7 +1781,7 @@ public static int length(final CharSequence csq) {
      * Returns the length of the given array in a null-safe manner.
      *
      * @param array an array or null
-     * @return the array length -- or 0 if the given array is null.
+     * @return the array length, or 0 if the given array is null.
      * @since 2.7
      */
     public static int length(final Object[] array) {
@@ -1853,9 +1852,7 @@ public static LineIterator lineIterator(final InputStream input, final Charset c
      * @param charsetName the encoding to use, null means platform default
      * @return an Iterator of the lines in the reader, never null
      * @throws IllegalArgumentException                     if the input is null
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.2
      */
     public static LineIterator lineIterator(final InputStream input, final String charsetName) {
@@ -1888,7 +1885,7 @@ public static LineIterator lineIterator(final InputStream input, final String ch
      *
      * @param reader the {@link Reader} to read, not null
      * @return an Iterator of the lines in the reader, never null
-     * @throws IllegalArgumentException if the reader is null
+     * @throws NullPointerException if the reader is null
      * @since 1.2
      */
     public static LineIterator lineIterator(final Reader reader) {
@@ -2165,6 +2162,20 @@ public static void readFully(final Reader reader, final char[] buffer, final int
         }
     }
 
+    /**
+     * Gets the contents of a {@link CharSequence} as a list of Strings, one entry per line.
+     *
+     * @param csq the {@link CharSequence} to read, not null
+     * @return the list of Strings, never null
+     * @throws UncheckedIOException if an I/O error occurs
+     * @since 2.18.0
+     */
+    public static List<String> readLines(final CharSequence csq) throws UncheckedIOException {
+        try (CharSequenceReader reader = new CharSequenceReader(csq)) {
+            return readLines(reader);
+        }
+    }
+
     /**
      * Gets the contents of an {@link InputStream} as a list of Strings,
      * one entry per line, using the default character encoding of the platform.
@@ -2178,7 +2189,7 @@ public static void readFully(final Reader reader, final char[] buffer, final int
      * @throws NullPointerException if the input is null
      * @throws UncheckedIOException if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #readLines(InputStream, Charset)} instead
+     * @deprecated Use {@link #readLines(InputStream, Charset)} instead
      */
     @Deprecated
     public static List<String> readLines(final InputStream input) throws UncheckedIOException {
@@ -2221,9 +2232,7 @@ public static List<String> readLines(final InputStream input, final Charset char
      * @return the list of Strings, never null
      * @throws NullPointerException                         if the input is null
      * @throws UncheckedIOException                         if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static List<String> readLines(final InputStream input, final String charsetName) throws UncheckedIOException {
@@ -2368,7 +2377,7 @@ public static URL resourceToURL(final String name, final ClassLoader classLoader
      * </p>
      *
      * @param input byte stream to skip
-     * @param toSkip number of bytes to skip.
+     * @param skip number of bytes to skip.
      * @return number of bytes actually skipped.
      * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if toSkip is negative
@@ -2376,8 +2385,8 @@ public static URL resourceToURL(final String name, final ClassLoader classLoader
      * @see <a href="https://issues.apache.org/jira/browse/IO-203">IO-203 - Add skipFully() method for InputStreams</a>
      * @since 2.0
      */
-    public static long skip(final InputStream input, final long toSkip) throws IOException {
-        return skip(input, toSkip, IOUtils::getScratchByteArrayWriteOnly);
+    public static long skip(final InputStream input, final long skip) throws IOException {
+        return skip(input, skip, IOUtils::getScratchByteArrayWriteOnly);
     }
 
     /**
@@ -2397,7 +2406,7 @@ public static long skip(final InputStream input, final long toSkip) throws IOExc
      * </p>
      *
      * @param input              byte stream to skip
-     * @param toSkip             number of bytes to skip.
+     * @param skip             number of bytes to skip.
      * @param skipBufferSupplier Supplies the buffer to use for reading.
      * @return number of bytes actually skipped.
      * @throws IOException              if there is a problem reading the file
@@ -2406,16 +2415,16 @@ public static long skip(final InputStream input, final long toSkip) throws IOExc
      * @see <a href="https://issues.apache.org/jira/browse/IO-203">IO-203 - Add skipFully() method for InputStreams</a>
      * @since 2.14.0
      */
-    public static long skip(final InputStream input, final long toSkip, final Supplier<byte[]> skipBufferSupplier) throws IOException {
-        if (toSkip < 0) {
-            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);
+    public static long skip(final InputStream input, final long skip, final Supplier<byte[]> skipBufferSupplier) throws IOException {
+        if (skip < 0) {
+            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + skip);
         }
         //
         // No need to synchronize access to SCRATCH_BYTE_BUFFER_WO: We don't care if the buffer is written multiple
         // times or in parallel since the data is ignored. We reuse the same buffer, if the buffer size were variable or read-write,
         // we would need to synch or use a thread local to ensure some other thread safety.
         //
-        long remain = toSkip;
+        long remain = skip;
         while (remain > 0) {
             final byte[] skipBuffer = skipBufferSupplier.get();
             // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()
@@ -2425,7 +2434,7 @@ public static long skip(final InputStream input, final long toSkip, final Suppli
             }
             remain -= n;
         }
-        return toSkip - remain;
+        return skip - remain;
     }
 
     /**
@@ -2734,7 +2743,7 @@ public static byte[] toByteArray(final InputStream input, final int size) throws
      * Gets contents of an {@link InputStream} as a {@code byte[]}.
      * Use this method instead of {@link #toByteArray(InputStream)}
      * when {@link InputStream} size is known.
-     * <b>NOTE:</b> the method checks that the length can safely be cast to an int without truncation
+     * <strong>NOTE:</strong> the method checks that the length can safely be cast to an int without truncation
      * before using {@link IOUtils#toByteArray(InputStream, int)} to read into the byte array.
      * (Arrays can have no more than Integer.MAX_VALUE entries anyway)
      *
@@ -2799,7 +2808,7 @@ static byte[] toByteArray(final IOTriFunction<byte[], Integer, Integer, Integer>
      * @return the requested byte array
      * @throws NullPointerException if the input is null
      * @throws IOException          if an I/O error occurs
-     * @deprecated 2.5 use {@link #toByteArray(Reader, Charset)} instead
+     * @deprecated Use {@link #toByteArray(Reader, Charset)} instead
      */
     @Deprecated
     public static byte[] toByteArray(final Reader reader) throws IOException {
@@ -2845,9 +2854,7 @@ public static byte[] toByteArray(final Reader reader, final Charset charset) thr
      * @return the requested byte array
      * @throws NullPointerException                         if the input is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {
@@ -2864,7 +2871,7 @@ public static byte[] toByteArray(final Reader reader, final String charsetName)
      * @param input the {@link String} to convert
      * @return the requested byte array
      * @throws NullPointerException if the input is null
-     * @deprecated 2.5 Use {@link String#getBytes()} instead
+     * @deprecated Use {@link String#getBytes()} instead
      */
     @Deprecated
     public static byte[] toByteArray(final String input) {
@@ -2928,7 +2935,7 @@ public static byte[] toByteArray(final URLConnection urlConnection) throws IOExc
      * @throws NullPointerException if the input is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #toCharArray(InputStream, Charset)} instead
+     * @deprecated Use {@link #toCharArray(InputStream, Charset)} instead
      */
     @Deprecated
     public static char[] toCharArray(final InputStream inputStream) throws IOException {
@@ -2974,9 +2981,7 @@ public static char[] toCharArray(final InputStream inputStream, final Charset ch
      * @return the requested character array
      * @throws NullPointerException                         if the input is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {
@@ -3009,7 +3014,7 @@ public static char[] toCharArray(final Reader reader) throws IOException {
      * @param input the CharSequence to convert
      * @return an input stream
      * @since 2.0
-     * @deprecated 2.5 use {@link #toInputStream(CharSequence, Charset)} instead
+     * @deprecated Use {@link #toInputStream(CharSequence, Charset)} instead
      */
     @Deprecated
     public static InputStream toInputStream(final CharSequence input) {
@@ -3040,9 +3045,7 @@ public static InputStream toInputStream(final CharSequence input, final Charset
      * @param input the CharSequence to convert
      * @param charsetName the name of the requested charset, null means platform default
      * @return an input stream
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 2.0
      */
     public static InputStream toInputStream(final CharSequence input, final String charsetName) {
@@ -3056,7 +3059,7 @@ public static InputStream toInputStream(final CharSequence input, final String c
      * @param input the string to convert
      * @return an input stream
      * @since 1.1
-     * @deprecated 2.5 use {@link #toInputStream(String, Charset)} instead
+     * @deprecated Use {@link #toInputStream(String, Charset)} instead
      */
     @Deprecated
     public static InputStream toInputStream(final String input) {
@@ -3087,9 +3090,7 @@ public static InputStream toInputStream(final String input, final Charset charse
      * @param input the string to convert
      * @param charsetName the name of the requested charset, null means platform default
      * @return an input stream
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static InputStream toInputStream(final String input, final String charsetName) {
@@ -3103,7 +3104,7 @@ public static InputStream toInputStream(final String input, final String charset
      * @param input the byte array to read
      * @return the requested String
      * @throws NullPointerException if the input is null
-     * @deprecated 2.5 Use {@link String#String(byte[])} instead
+     * @deprecated Use {@link String#String(byte[])} instead
      */
     @Deprecated
     public static String toString(final byte[] input) {
@@ -3140,7 +3141,7 @@ public static String toString(final byte[] input, final String charsetName) {
      * @return the requested String
      * @throws NullPointerException if the input is null
      * @throws IOException          if an I/O error occurs
-     * @deprecated 2.5 use {@link #toString(InputStream, Charset)} instead
+     * @deprecated Use {@link #toString(InputStream, Charset)} instead
      */
     @Deprecated
     public static String toString(final InputStream input) throws IOException {
@@ -3186,9 +3187,7 @@ public static String toString(final InputStream input, final Charset charset) th
      * @return the requested String
      * @throws NullPointerException                         if the input is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      */
     public static String toString(final InputStream input, final String charsetName)
             throws IOException {
@@ -3267,7 +3266,7 @@ public static String toString(final Reader reader) throws IOException {
      * @return The contents of the URL as a String.
      * @throws IOException if an I/O exception occurs.
      * @since 2.1
-     * @deprecated 2.5 use {@link #toString(URI, Charset)} instead
+     * @deprecated Use {@link #toString(URI, Charset)} instead
      */
     @Deprecated
     public static String toString(final URI uri) throws IOException {
@@ -3294,9 +3293,7 @@ public static String toString(final URI uri, final Charset encoding) throws IOEx
      * @param charsetName The encoding name for the URL contents.
      * @return The contents of the URL as a String.
      * @throws IOException                                  if an I/O exception occurs.
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 2.1
      */
     public static String toString(final URI uri, final String charsetName) throws IOException {
@@ -3310,7 +3307,7 @@ public static String toString(final URI uri, final String charsetName) throws IO
      * @return The contents of the URL as a String.
      * @throws IOException if an I/O exception occurs.
      * @since 2.1
-     * @deprecated 2.5 use {@link #toString(URL, Charset)} instead
+     * @deprecated Use {@link #toString(URL, Charset)} instead
      */
     @Deprecated
     public static String toString(final URL url) throws IOException {
@@ -3337,9 +3334,7 @@ public static String toString(final URL url, final Charset encoding) throws IOEx
      * @param charsetName The encoding name for the URL contents.
      * @return The contents of the URL as a String.
      * @throws IOException                                  if an I/O exception occurs.
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 2.1
      */
     public static String toString(final URL url, final String charsetName) throws IOException {
@@ -3376,7 +3371,7 @@ public static void write(final byte[] data, final OutputStream output)
      * @throws NullPointerException if output is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #write(byte[], Writer, Charset)} instead
+     * @deprecated Use {@link #write(byte[], Writer, Charset)} instead
      */
     @Deprecated
     public static void write(final byte[] data, final Writer writer) throws IOException {
@@ -3421,9 +3416,7 @@ public static void write(final byte[] data, final Writer writer, final Charset c
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException                         if output is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {
@@ -3444,7 +3437,7 @@ public static void write(final byte[] data, final Writer writer, final String ch
      * @throws NullPointerException if output is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #write(char[], OutputStream, Charset)} instead
+     * @deprecated Use {@link #write(char[], OutputStream, Charset)} instead
      */
     @Deprecated
     public static void write(final char[] data, final OutputStream output)
@@ -3492,8 +3485,7 @@ public static void write(final char[] data, final OutputStream output, final Cha
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException                         if output is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static void write(final char[] data, final OutputStream output, final String charsetName)
@@ -3530,7 +3522,7 @@ public static void write(final char[] data, final Writer writer) throws IOExcept
      * @throws NullPointerException if output is null
      * @throws IOException          if an I/O error occurs
      * @since 2.0
-     * @deprecated 2.5 use {@link #write(CharSequence, OutputStream, Charset)} instead
+     * @deprecated Use {@link #write(CharSequence, OutputStream, Charset)} instead
      */
     @Deprecated
     public static void write(final CharSequence data, final OutputStream output)
@@ -3575,8 +3567,7 @@ public static void write(final CharSequence data, final OutputStream output, fin
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException        if output is null
      * @throws IOException                 if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 2.0
      */
     public static void write(final CharSequence data, final OutputStream output, final String charsetName)
@@ -3584,7 +3575,6 @@ public static void write(final CharSequence data, final OutputStream output, fin
         write(data, output, Charsets.toCharset(charsetName));
     }
 
-
     /**
      * Writes chars from a {@link CharSequence} to a {@link Writer}.
      *
@@ -3613,7 +3603,7 @@ public static void write(final CharSequence data, final Writer writer) throws IO
      * @throws NullPointerException if output is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #write(String, OutputStream, Charset)} instead
+     * @deprecated Use {@link #write(String, OutputStream, Charset)} instead
      */
     @Deprecated
     public static void write(final String data, final OutputStream output)
@@ -3661,8 +3651,7 @@ public static void write(final String data, final OutputStream output, final Cha
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException        if output is null
      * @throws IOException                 if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static void write(final String data, final OutputStream output, final String charsetName)
@@ -3722,8 +3711,7 @@ public static void write(final StringBuffer data, final OutputStream output) //N
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException        if output is null
      * @throws IOException                 if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      * @deprecated Use {@link #write(CharSequence, OutputStream, String)}.
      */
@@ -3815,7 +3803,7 @@ public static void writeChunked(final char[] data, final Writer writer) throws I
      * @throws NullPointerException if the output is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
-     * @deprecated 2.5 use {@link #writeLines(Collection, String, OutputStream, Charset)} instead
+     * @deprecated Use {@link #writeLines(Collection, String, OutputStream, Charset)} instead
      */
     @Deprecated
     public static void writeLines(final Collection<?> lines, final String lineEnding,
@@ -3829,7 +3817,7 @@ public static void writeLines(final Collection<?> lines, final String lineEnding
      * encoding and the specified line ending.
      * <p>
      * UTF-16 is written big-endian with no byte order mark.
-     * For little endian, use UTF-16LE. For a BOM, write it to the stream
+     * For little-endian, use UTF-16LE. For a BOM, write it to the stream
      * before calling this method.
      * </p>
      *
@@ -3877,9 +3865,7 @@ public static void writeLines(final Collection<?> lines, String lineEnding, fina
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException                         if the output is null
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     *                                                      .UnsupportedEncodingException} in version 2.2 if the
-     *                                                      encoding is not supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 1.1
      */
     public static void writeLines(final Collection<?> lines, final String lineEnding,
@@ -3936,10 +3922,12 @@ public static Writer writer(final Appendable appendable) {
 
     /**
      * Instances should NOT be constructed in standard programming.
-     * @deprecated Will be private in 3.0.
+     *
+     * @deprecated TODO Make private in 3.0.
      */
     @Deprecated
     public IOUtils() { //NOSONAR
+        // empty
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/LineIterator.java b/src/main/java/org/apache/commons/io/LineIterator.java
index d32f7540..93ed01d9 100644
--- a/src/main/java/org/apache/commons/io/LineIterator.java
+++ b/src/main/java/org/apache/commons/io/LineIterator.java
@@ -78,10 +78,10 @@ public static void closeQuietly(final LineIterator iterator) {
      * Constructs an iterator of the lines for a {@link Reader}.
      *
      * @param reader the {@link Reader} to read from, not null
-     * @throws IllegalArgumentException if the reader is null
+     * @throws NullPointerException if the reader is null
      */
     @SuppressWarnings("resource") // Caller closes Reader
-    public LineIterator(final Reader reader) throws IllegalArgumentException {
+    public LineIterator(final Reader reader) {
         Objects.requireNonNull(reader, "reader");
         if (reader instanceof BufferedReader) {
             bufferedReader = (BufferedReader) reader;
@@ -134,7 +134,7 @@ public boolean hasNext() {
                     return true;
                 }
             }
-        } catch(final IOException ioe) {
+        } catch (final IOException ioe) {
             IOUtils.closeQuietly(this, ioe::addSuppressed);
             throw new IllegalStateException(ioe);
         }
@@ -166,7 +166,9 @@ public String next() {
      *
      * @return the next line from the input
      * @throws NoSuchElementException if there is no line to return
+     * @deprecated Use {@link #next()}.
      */
+    @Deprecated
     public String nextLine() {
         if (!hasNext()) {
             throw new NoSuchElementException("No more lines");
diff --git a/src/main/java/org/apache/commons/io/RandomAccessFileMode.java b/src/main/java/org/apache/commons/io/RandomAccessFileMode.java
index 8b51e439..eeacaaa4 100644
--- a/src/main/java/org/apache/commons/io/RandomAccessFileMode.java
+++ b/src/main/java/org/apache/commons/io/RandomAccessFileMode.java
@@ -14,88 +14,281 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.commons.io;
 
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.nio.file.OpenOption;
 import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
 import java.util.Objects;
 
+import org.apache.commons.io.function.IOConsumer;
+import org.apache.commons.io.function.IOFunction;
+
 /**
- * Access modes and factory methods for {@link RandomAccessFile}.
+ * Enumerates access modes for {@link RandomAccessFile} with factory methods.
  *
+ * @see RandomAccessFile#RandomAccessFile(File, String)
+ * @see RandomAccessFile#RandomAccessFile(String, String)
+ * @see Enum
  * @since 2.12.0
  */
 public enum RandomAccessFileMode {
 
     /**
-     * Mode {@code "r"} opens for reading only.
+     * Defines mode {@value #R} to open a {@link RandomAccessFile} for reading only.
+     *
+     * @see RandomAccessFile#RandomAccessFile(File, String)
+     * @see RandomAccessFile#RandomAccessFile(String, String)
+     */
+    READ_ONLY(RandomAccessFileMode.R, 1), // NOPMD bug https://github.com/pmd/pmd/issues/5263
+
+    /**
+     * Defines mode {@value #RW} to open a {@link RandomAccessFile} for reading and writing.
+     *
+     * @see RandomAccessFile#RandomAccessFile(File, String)
+     * @see RandomAccessFile#RandomAccessFile(String, String)
+     */
+    READ_WRITE(RandomAccessFileMode.RW, 2), // NOPMD bug https://github.com/pmd/pmd/issues/5263
+
+    /**
+     * Defines mode {@value #RWS} to open a {@link RandomAccessFile} for reading and writing, as with {@value #RW}, and also require that every update to the
+     * file's content or metadata be written synchronously to the underlying storage device.
+     *
+     * @see RandomAccessFile#RandomAccessFile(File, String)
+     * @see RandomAccessFile#RandomAccessFile(String, String)
+     * @see StandardOpenOption#SYNC
      */
-    READ_ONLY("r"),
+    READ_WRITE_SYNC_ALL(RandomAccessFileMode.RWS, 4), // NOPMD bug https://github.com/pmd/pmd/issues/5263
 
     /**
-     * Mode {@code "rw"} opens for reading and writing.
+     * Defines mode {@value #RWD} to open a {@link RandomAccessFile} for reading and writing, as with {@value #RW}, and also require that every update to the
+     * file's content be written synchronously to the underlying storage device.
+     *
+     * @see RandomAccessFile#RandomAccessFile(File, String)
+     * @see RandomAccessFile#RandomAccessFile(String, String)
+     * @see StandardOpenOption#DSYNC
      */
-    READ_WRITE("rw"),
+    READ_WRITE_SYNC_CONTENT(RandomAccessFileMode.RWD, 3); // NOPMD bug https://github.com/pmd/pmd/issues/5263
+
+    private static final String R = "r";
+    private static final String RW = "rw";
+    private static final String RWD = "rwd";
+    private static final String RWS = "rws";
 
     /**
-     * Mode {@code "rws"} opens for reading and writing, as with {@code "rw"}, and also require that every update to the file's content or metadata be written
-     * synchronously to the underlying storage device.
+     * Gets the enum value that best fits the given {@link OpenOption}s.
+     * <p>
+     * The input must be a legal and working combination for NIO.
+     * </p>
+     *
+     * @param openOption options like {@link StandardOpenOption}.
+     * @return best fit, by default {@link #READ_ONLY}.
+     * @see StandardOpenOption
+     * @since 2.18.0
      */
-    READ_WRITE_SYNC_ALL("rws"),
+    public static RandomAccessFileMode valueOf(final OpenOption... openOption) {
+        RandomAccessFileMode bestFit = READ_ONLY;
+        for (final OpenOption option : openOption) {
+            if (option instanceof StandardOpenOption) {
+                switch ((StandardOpenOption) option) {
+                case WRITE:
+                    if (!bestFit.implies(READ_WRITE)) {
+                        bestFit = READ_WRITE;
+                    }
+                    break;
+                case DSYNC:
+                    if (!bestFit.implies(READ_WRITE_SYNC_CONTENT)) {
+                        bestFit = READ_WRITE_SYNC_CONTENT;
+                    }
+                    break;
+                case SYNC:
+                    if (!bestFit.implies(READ_WRITE_SYNC_ALL)) {
+                        bestFit = READ_WRITE_SYNC_ALL;
+                    }
+                    break;
+                default:
+                    // explicit case skip (spotbugs)
+                    continue;
+                }
+            }
+        }
+        return bestFit;
+    }
 
     /**
-     * Mode {@code "rwd"} open for reading and writing, as with {@code "rw"}, and also require that every update to the file's content be written synchronously
-     * to the underlying storage device.
+     * Gets the {@link RandomAccessFileMode} value for the given mode, one of {@value #R}, {@value #RW}, {@value #RWD}, or {@value #RWS}.
+     *
+     * @param mode one of {@value #R}, {@value #RW}, {@value #RWD}, or {@value #RWS}.
+     * @return A RandomAccessFileMode.
+     * @throws IllegalArgumentException Thrown when mode is not one of {@value #R}, {@value #RW}, {@value #RWD}, or {@value #RWS}.
+     * @since 2.18.0
      */
-    READ_WRITE_SYNC_CONTENT("rwd");
+    public static RandomAccessFileMode valueOfMode(final String mode) {
+        switch (mode) {
+        case R:
+            return READ_ONLY;
+        case RW:
+            return READ_WRITE;
+        case RWD:
+            return READ_WRITE_SYNC_CONTENT;
+        case RWS:
+            return READ_WRITE_SYNC_ALL;
+        }
+        throw new IllegalArgumentException(mode);
+    }
+
+    private final int level;
 
     private final String mode;
 
-    RandomAccessFileMode(final String mode) {
+    RandomAccessFileMode(final String mode, final int level) {
         this.mode = mode;
+        this.level = level;
     }
 
     /**
-     * Constructs a random access file stream to read from, and optionally to write to, the file specified by the {@link File}
-     * argument.
+     * Performs an operation on the {@link RandomAccessFile} specified at the given {@link Path}.
+     * <p>
+     * This method allocates and releases the {@link RandomAccessFile} given to the consumer.
+     * </p>
+     *
+     * @param file the file specifying the {@link RandomAccessFile} to open.
+     * @param consumer the function to apply.
+     * @throws FileNotFoundException See {@link IORandomAccessFile#IORandomAccessFile(File, String)}.
+     * @throws IOException Thrown by the given function.
+     * @since 2.18.0
+     */
+    public void accept(final Path file, final IOConsumer<RandomAccessFile> consumer) throws IOException {
+        try (RandomAccessFile raf = create(file)) {
+            consumer.accept(raf);
+        }
+    }
+
+    /**
+     * Applies the given function for a {@link RandomAccessFile} specified at the given {@link Path}.
+     * <p>
+     * This method allocates and releases the {@link RandomAccessFile} given to the function.
+     * </p>
+     *
+     * @param <T> the return type of the function.
+     * @param file the file specifying the {@link RandomAccessFile} to open.
+     * @param function the function to apply.
+     * @return the function's result value.
+     * @throws FileNotFoundException See {@link IORandomAccessFile#IORandomAccessFile(File, String)}.
+     * @throws IOException Thrown by the given function.
+     * @since 2.18.0
+     */
+    public <T> T apply(final Path file, final IOFunction<RandomAccessFile, T> function) throws IOException {
+        try (RandomAccessFile raf = create(file)) {
+            return function.apply(raf);
+        }
+    }
+
+    /**
+     * Constructs a random access file to read from, and optionally to write to, the file specified by the {@link File} argument.
+     * <p>
+     * Prefer {@link #create(Path)} over this.
+     * </p>
      *
      * @param file the file object
-     * @return a random access file stream
-     * @throws FileNotFoundException See {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     * @return a random access file
+     * @throws FileNotFoundException See {@link IORandomAccessFile#IORandomAccessFile(File, String)}.
      */
     public RandomAccessFile create(final File file) throws FileNotFoundException {
-        return new RandomAccessFile(file, mode);
+        return new IORandomAccessFile(file, mode);
     }
 
     /**
-     * Constructs a random access file stream to read from, and optionally to write to, the file specified by the {@link File}
-     * argument.
+     * Constructs a random access file to read from, and optionally to write to, the file specified by the {@link File} argument.
      *
      * @param file the file object
-     * @return a random access file stream
-     * @throws FileNotFoundException See {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     * @return a random access file
+     * @throws FileNotFoundException See {@link IORandomAccessFile#IORandomAccessFile(File, String)}.
      */
     public RandomAccessFile create(final Path file) throws FileNotFoundException {
         return create(Objects.requireNonNull(file.toFile(), "file"));
     }
 
     /**
-     * Constructs a random access file stream to read from, and optionally to write to, the file specified by the {@link File}
-     * argument.
+     * Constructs a random access file to read from, and optionally to write to, the file specified by the {@link File} argument.
+     * <p>
+     * Prefer {@link #create(Path)} over this.
+     * </p>
      *
-     * @param file the file object
-     * @return a random access file stream
-     * @throws FileNotFoundException See {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     * @param name the file object
+     * @return a random access file
+     * @throws FileNotFoundException See {@link IORandomAccessFile#IORandomAccessFile(File, String)}.
+     */
+    public RandomAccessFile create(final String name) throws FileNotFoundException {
+        return new IORandomAccessFile(name, mode);
+    }
+
+    /**
+     * A level for relative comparison of access mode rights, the larger, the more access.
+     * <p>
+     * The relative order from lowest to highest access rights is:
+     * </p>
+     * <ol>
+     * <li>{@link #READ_ONLY}</li>
+     * <li>{@link #READ_WRITE}</li>
+     * <li>{@link #READ_WRITE_SYNC_CONTENT}</li>
+     * <li>{@link #READ_WRITE_SYNC_ALL}</li>
+     * </ol>
+     * <p>
+     * This is unrelated to {@link #ordinal()}.
+     * </p>
+     *
+     * @return A level for relative comparison.
      */
-    public RandomAccessFile create(final String file) throws FileNotFoundException {
-        return new RandomAccessFile(file, mode);
+    private int getLevel() {
+        return level;
     }
 
-    @Override
-    public String toString() {
+    /**
+     * Gets the access mode, one of {@value #R}, {@value #RW}, {@value #RWD}, or {@value #RWS}.
+     *
+     * @return one of {@value #R}, {@value #RW}, {@value #RWD}, or {@value #RWS}.
+     * @since 2.18.0
+     */
+    public String getMode() {
         return mode;
     }
 
+    /**
+     * Tests whether this mode implies the given {@code other} mode.
+     * <p>
+     * For example:
+     * </p>
+     * <ol>
+     * <li>{@link RandomAccessFileMode#READ_WRITE_SYNC_ALL} implies {{@link RandomAccessFileMode#READ_WRITE_SYNC_CONTENT}}.</li>
+     * <li>{@link RandomAccessFileMode#READ_WRITE_SYNC_CONTENT} implies {{@link RandomAccessFileMode#READ_WRITE}}.</li>
+     * <li>{@link RandomAccessFileMode#READ_WRITE} implies {{@link RandomAccessFileMode#READ_ONLY}}.</li>
+     * </ol>
+     *
+     * @param other the non-null mode to test against.
+     * @return whether this mode implies the given {@code other} mode.
+     * @since 2.18.0
+     */
+    public boolean implies(final RandomAccessFileMode other) {
+        // Note: The method name "implies" is inspired by java.security.Permission.implies(Permission)
+        return getLevel() >= other.getLevel();
+    }
+
+    /**
+     * Constructs a random access file to read from, and optionally to write to, the file specified by the {@link File} argument.
+     *
+     * @param name the file object
+     * @return a random access file
+     * @throws FileNotFoundException See {@link IORandomAccessFile#IORandomAccessFile(File, String)}.
+     * @since 2.18.0
+     */
+    public IORandomAccessFile io(final String name) throws FileNotFoundException {
+        return new IORandomAccessFile(name, mode);
+    }
+
 }
diff --git a/src/main/java/org/apache/commons/io/RandomAccessFiles.java b/src/main/java/org/apache/commons/io/RandomAccessFiles.java
index 0e0140b6..7d3a223b 100644
--- a/src/main/java/org/apache/commons/io/RandomAccessFiles.java
+++ b/src/main/java/org/apache/commons/io/RandomAccessFiles.java
@@ -95,4 +95,13 @@ public static RandomAccessFile reset(final RandomAccessFile raf) throws IOExcept
         return raf;
     }
 
+    /**
+     * Make private in 3.0.
+     *
+     * @deprecated TODO Make private in 3.0.
+     */
+    @Deprecated
+    public RandomAccessFiles() {
+        // empty
+    }
 }
diff --git a/src/main/java/org/apache/commons/io/StandardLineSeparator.java b/src/main/java/org/apache/commons/io/StandardLineSeparator.java
index 4d40ada2..13a6edd3 100644
--- a/src/main/java/org/apache/commons/io/StandardLineSeparator.java
+++ b/src/main/java/org/apache/commons/io/StandardLineSeparator.java
@@ -28,7 +28,7 @@
 public enum StandardLineSeparator {
 
     /**
-     * Carriage return. This is the line ending used on Mac OS 9 and earlier.
+     * Carriage return. This is the line ending used on macOS 9 and earlier.
      */
     CR("\r"),
 
@@ -38,7 +38,7 @@ public enum StandardLineSeparator {
     CRLF("\r\n"),
 
     /**
-     * Line feed. This is the line ending used on Linux and Mac OS X and later.
+     * Line feed. This is the line ending used on Linux and macOS X and later.
      */
     LF("\n");
 
diff --git a/src/main/java/org/apache/commons/io/StreamIterator.java b/src/main/java/org/apache/commons/io/StreamIterator.java
index 23465657..1df839a7 100644
--- a/src/main/java/org/apache/commons/io/StreamIterator.java
+++ b/src/main/java/org/apache/commons/io/StreamIterator.java
@@ -37,7 +37,7 @@ public final class StreamIterator<E> implements Iterator<E>, AutoCloseable {
     /**
      * Wraps and presents a stream as a closable resource that automatically closes itself when reaching the end of stream.
      * <p>
-     * <b>Warning</b>
+     * <strong>Warning</strong>
      * </p>
      * <p>
      * In order to close the stream, the call site MUST either close the stream it allocated OR call this iterator until the end.
diff --git a/src/main/java/org/apache/commons/io/ThreadMonitor.java b/src/main/java/org/apache/commons/io/ThreadMonitor.java
index 17e44e4d..a1826f5a 100644
--- a/src/main/java/org/apache/commons/io/ThreadMonitor.java
+++ b/src/main/java/org/apache/commons/io/ThreadMonitor.java
@@ -22,7 +22,7 @@
  * Monitors a thread, interrupting it if it reaches the specified timeout.
  * <p>
  * This works by sleeping until the specified timeout amount and then interrupting the thread being monitored. If the
- * thread being monitored completes its work before being interrupted, it should {@code interrupt()} the <i>monitor</i>
+ * thread being monitored completes its work before being interrupted, it should {@code interrupt()} the <em>monitor</em>
  * thread.
  * </p>
  *
@@ -102,7 +102,7 @@ public void run() {
         try {
             ThreadUtils.sleep(timeout);
             thread.interrupt();
-        } catch (final InterruptedException e) {
+        } catch (final InterruptedException ignored) {
             // timeout not reached
         }
     }
diff --git a/src/main/java/org/apache/commons/io/ThreadUtils.java b/src/main/java/org/apache/commons/io/ThreadUtils.java
index 153bd501..f6b7713c 100644
--- a/src/main/java/org/apache/commons/io/ThreadUtils.java
+++ b/src/main/java/org/apache/commons/io/ThreadUtils.java
@@ -51,4 +51,13 @@ public static void sleep(final Duration duration) throws InterruptedException {
         } while (!remainingDuration.isNegative());
     }
 
+    /**
+     * Make private in 3.0.
+     *
+     * @deprecated TODO Make private in 3.0.
+     */
+    @Deprecated
+    public ThreadUtils() {
+        // empty
+    }
 }
diff --git a/src/main/java/org/apache/commons/io/build/AbstractOrigin.java b/src/main/java/org/apache/commons/io/build/AbstractOrigin.java
index 9268a325..6cc5c725 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractOrigin.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractOrigin.java
@@ -19,6 +19,7 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -33,13 +34,21 @@
 import java.nio.file.OpenOption;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.nio.file.StandardOpenOption;
+import java.nio.file.spi.FileSystemProvider;
 import java.util.Arrays;
 import java.util.Objects;
 
+import org.apache.commons.io.IORandomAccessFile;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.RandomAccessFileMode;
 import org.apache.commons.io.RandomAccessFiles;
+import org.apache.commons.io.file.spi.FileSystemProviders;
+import org.apache.commons.io.input.BufferedFileChannelInputStream;
+import org.apache.commons.io.input.CharSequenceInputStream;
+import org.apache.commons.io.input.CharSequenceReader;
 import org.apache.commons.io.input.ReaderInputStream;
+import org.apache.commons.io.output.RandomAccessFileOutputStream;
 import org.apache.commons.io.output.WriterOutputStream;
 
 /**
@@ -56,6 +65,83 @@
  */
 public abstract class AbstractOrigin<T, B extends AbstractOrigin<T, B>> extends AbstractSupplier<T, B> {
 
+    /**
+     * A {@link RandomAccessFile} origin.
+     * <p>
+     * This origin cannot support File and Path since you cannot query a RandomAccessFile for those attributes; Use {@link IORandomAccessFileOrigin}
+     * instead.
+     * </p>
+     *
+     * @param <T> the type of instances to build.
+     * @param <B> the type of builder subclass.
+     */
+    public static abstract class AbstractRandomAccessFileOrigin<T extends RandomAccessFile, B extends AbstractRandomAccessFileOrigin<T, B>>
+            extends AbstractOrigin<T, B> {
+
+        /**
+         * A {@link RandomAccessFile} origin.
+         * <p>
+         * Starting from this origin, you can everything except a Path and a File.
+         * </p>
+         *
+         * @param origin The origin.
+         */
+        public AbstractRandomAccessFileOrigin(final T origin) {
+            super(origin);
+        }
+
+        @Override
+        public byte[] getByteArray() throws IOException {
+            final long longLen = origin.length();
+            if (longLen > Integer.MAX_VALUE) {
+                throw new IllegalStateException("Origin too large.");
+            }
+            return RandomAccessFiles.read(origin, 0, (int) longLen);
+        }
+
+        @Override
+        public byte[] getByteArray(final long position, final int length) throws IOException {
+            return RandomAccessFiles.read(origin, position, length);
+        }
+
+        @Override
+        public CharSequence getCharSequence(final Charset charset) throws IOException {
+            return new String(getByteArray(), charset);
+        }
+
+        @SuppressWarnings("resource")
+        @Override
+        public InputStream getInputStream(final OpenOption... options) throws IOException {
+            return BufferedFileChannelInputStream.builder().setFileChannel(origin.getChannel()).get();
+        }
+
+        @Override
+        public OutputStream getOutputStream(final OpenOption... options) throws IOException {
+            return RandomAccessFileOutputStream.builder().setRandomAccessFile(origin).get();
+        }
+
+        @Override
+        public T getRandomAccessFile(final OpenOption... openOption) {
+            // No conversion
+            return get();
+        }
+
+        @Override
+        public Reader getReader(final Charset charset) throws IOException {
+            return new InputStreamReader(getInputStream(), charset);
+        }
+
+        @Override
+        public Writer getWriter(final Charset charset, final OpenOption... options) throws IOException {
+            return new OutputStreamWriter(getOutputStream(options), charset);
+        }
+
+        @Override
+        public long size() throws IOException {
+            return origin.length();
+        }
+    }
+
     /**
      * A {@code byte[]} origin.
      */
@@ -76,6 +162,12 @@ public byte[] getByteArray() {
             return get();
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@code byte[]} does not need an {@link OpenOption} to be read.
+         * </p>
+         */
         @Override
         public InputStream getInputStream(final OpenOption... options) throws IOException {
             return new ByteArrayInputStream(origin);
@@ -113,23 +205,39 @@ public byte[] getByteArray() {
             return origin.toString().getBytes(Charset.defaultCharset());
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code charset} parameter is ignored since a {@link CharSequence} does not need a {@link Charset} to be read.
+         * </p>
+         */
         @Override
         public CharSequence getCharSequence(final Charset charset) {
             // No conversion
             return get();
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@link CharSequence} does not need an {@link OpenOption} to be read.
+         * </p>
+         */
         @Override
         public InputStream getInputStream(final OpenOption... options) throws IOException {
             // TODO Pass in a Charset? Consider if call sites actually need this.
-            return new ByteArrayInputStream(origin.toString().getBytes(Charset.defaultCharset()));
-            // Needs [IO-795] CharSequenceInputStream.reset() only works once.
-            // return CharSequenceInputStream.builder().setCharSequence(getCharSequence(Charset.defaultCharset())).get();
+            return CharSequenceInputStream.builder().setCharSequence(getCharSequence(Charset.defaultCharset())).get();
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code charset} parameter is ignored since a {@link CharSequence} does not need a {@link Charset} to be read.
+         * </p>
+         */
         @Override
         public Reader getReader(final Charset charset) throws IOException {
-            return new InputStreamReader(getInputStream(), charset);
+            return new CharSequenceReader(get());
         }
 
         @Override
@@ -198,6 +306,12 @@ public byte[] getByteArray() throws IOException {
             return IOUtils.toByteArray(origin);
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@link InputStream} does not need an {@link OpenOption} to be read.
+         * </p>
+         */
         @Override
         public InputStream getInputStream(final OpenOption... options) {
             // No conversion
@@ -211,6 +325,35 @@ public Reader getReader(final Charset charset) throws IOException {
 
     }
 
+    /**
+     * A {@link IORandomAccessFile} origin.
+     *
+     * @since 2.18.0
+     */
+    public static class IORandomAccessFileOrigin extends AbstractRandomAccessFileOrigin<IORandomAccessFile, IORandomAccessFileOrigin> {
+
+        /**
+         * A {@link RandomAccessFile} origin.
+         *
+         * @param origin The origin.
+         */
+        public IORandomAccessFileOrigin(final IORandomAccessFile origin) {
+            super(origin);
+        }
+
+        @SuppressWarnings("resource")
+        @Override
+        public File getFile() {
+            return get().getFile();
+        }
+
+        @Override
+        public Path getPath() {
+            return getFile().toPath();
+        }
+
+    }
+
     /**
      * An {@link OutputStream} origin.
      * <p>
@@ -228,12 +371,24 @@ public OutputStreamOrigin(final OutputStream origin) {
             super(origin);
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@link OutputStream} does not need an {@link OpenOption} to be written.
+         * </p>
+         */
         @Override
         public OutputStream getOutputStream(final OpenOption... options) {
             // No conversion
             return get();
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@link OutputStream} does not need an {@link OpenOption} to be written.
+         * </p>
+         */
         @Override
         public Writer getWriter(final Charset charset, final OpenOption... options) throws IOException {
             return new OutputStreamWriter(origin, charset);
@@ -259,9 +414,7 @@ public PathOrigin(final Path origin) {
 
         @Override
         public byte[] getByteArray(final long position, final int length) throws IOException {
-            try (RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(origin)) {
-                return RandomAccessFiles.read(raf, position, length);
-            }
+            return RandomAccessFileMode.READ_ONLY.apply(origin, raf -> RandomAccessFiles.read(raf, position, length));
         }
 
         @Override
@@ -278,9 +431,32 @@ public Path getPath() {
     }
 
     /**
-     * An {@link Reader} origin.
+     * A {@link RandomAccessFile} origin.
      * <p>
-     * This origin cannot provide other aspects.
+     * This origin cannot support File and Path since you cannot query a RandomAccessFile for those attributes; Use {@link IORandomAccessFileOrigin}
+     * instead.
+     * </p>
+     */
+    public static class RandomAccessFileOrigin extends AbstractRandomAccessFileOrigin<RandomAccessFile, RandomAccessFileOrigin> {
+
+        /**
+         * A {@link RandomAccessFile} origin.
+         * <p>
+         * Starting from this origin, you can everything except a Path and a File.
+         * </p>
+         *
+         * @param origin The origin.
+         */
+        public RandomAccessFileOrigin(final RandomAccessFile origin) {
+            super(origin);
+        }
+
+    }
+
+    /**
+     * A {@link Reader} origin.
+     * <p>
+     * This origin cannot provide conversions to other aspects.
      * </p>
      */
     public static class ReaderOrigin extends AbstractOrigin<Reader, ReaderOrigin> {
@@ -300,17 +476,35 @@ public byte[] getByteArray() throws IOException {
             return IOUtils.toByteArray(origin, Charset.defaultCharset());
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code charset} parameter is ignored since a {@link Reader} does not need a {@link Charset} to be read.
+         * </p>
+         */
         @Override
         public CharSequence getCharSequence(final Charset charset) throws IOException {
             return IOUtils.toString(origin);
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@link Reader} does not need an {@link OpenOption} to be read.
+         * </p>
+         */
         @Override
         public InputStream getInputStream(final OpenOption... options) throws IOException {
             // TODO Pass in a Charset? Consider if call sites actually need this.
             return ReaderInputStream.builder().setReader(origin).setCharset(Charset.defaultCharset()).get();
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code charset} parameter is ignored since a {@link Reader} does not need a {@link Charset} to be read.
+         * </p>
+         */
         @Override
         public Reader getReader(final Charset charset) throws IOException {
             // No conversion
@@ -323,6 +517,9 @@ public Reader getReader(final Charset charset) throws IOException {
      */
     public static class URIOrigin extends AbstractOrigin<URI, URIOrigin> {
 
+        private static final String SCHEME_HTTPS = "https";
+        private static final String SCHEME_HTTP = "http";
+
         /**
          * Constructs a new instance for the given origin.
          *
@@ -337,17 +534,30 @@ public File getFile() {
             return getPath().toFile();
         }
 
+        @Override
+        public InputStream getInputStream(final OpenOption... options) throws IOException {
+            final URI uri = get();
+            final String scheme = uri.getScheme();
+            final FileSystemProvider fileSystemProvider = FileSystemProviders.installed().getFileSystemProvider(scheme);
+            if (fileSystemProvider != null) {
+                return Files.newInputStream(fileSystemProvider.getPath(uri), options);
+            }
+            if (SCHEME_HTTP.equalsIgnoreCase(scheme) || SCHEME_HTTPS.equalsIgnoreCase(scheme)) {
+                return uri.toURL().openStream();
+            }
+            return Files.newInputStream(getPath(), options);
+        }
+
         @Override
         public Path getPath() {
             return Paths.get(get());
         }
-
     }
 
     /**
-     * An {@link Writer} origin.
+     * A {@link Writer} origin.
      * <p>
-     * This origin cannot provide other aspects.
+     * This origin cannot provide conversions to other aspects.
      * </p>
      */
     public static class WriterOrigin extends AbstractOrigin<Writer, WriterOrigin> {
@@ -361,12 +571,27 @@ public WriterOrigin(final Writer origin) {
             super(origin);
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code options} parameter is ignored since a {@link Writer} does not need an {@link OpenOption} to be written.
+         * </p>
+         */
         @Override
         public OutputStream getOutputStream(final OpenOption... options) throws IOException {
             // TODO Pass in a Charset? Consider if call sites actually need this.
             return WriterOutputStream.builder().setWriter(origin).setCharset(Charset.defaultCharset()).get();
         }
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * The {@code charset} parameter is ignored since a {@link Writer} does not need a {@link Charset} to be written.
+         * </p>
+         * <p>
+         * The {@code options} parameter is ignored since a {@link Writer} does not need an {@link OpenOption} to be written.
+         * </p>
+         */
         @Override
         public Writer getWriter(final Charset charset, final OpenOption... options) throws IOException {
             // No conversion
@@ -410,7 +635,7 @@ public byte[] getByteArray() throws IOException {
     }
 
     /**
-     * Gets this origin as a byte array, if possible.
+     * Gets a portion of this origin as a byte array, if possible.
      *
      * @param position the initial index of the range to be copied, inclusive.
      * @param length   How many bytes to copy.
@@ -450,7 +675,7 @@ public CharSequence getCharSequence(final Charset charset) throws IOException {
      */
     public File getFile() {
         throw new UnsupportedOperationException(
-                String.format("%s#getFile() for %s origin %s", getClass().getSimpleName(), origin.getClass().getSimpleName(), origin));
+                String.format("%s#getFile() for %s origin %s", getSimpleClassName(), origin.getClass().getSimpleName(), origin));
     }
 
     /**
@@ -485,7 +710,20 @@ public OutputStream getOutputStream(final OpenOption... options) throws IOExcept
      */
     public Path getPath() {
         throw new UnsupportedOperationException(
-                String.format("%s#getPath() for %s origin %s", getClass().getSimpleName(), origin.getClass().getSimpleName(), origin));
+                String.format("%s#getPath() for %s origin %s", getSimpleClassName(), origin.getClass().getSimpleName(), origin));
+    }
+
+    /**
+     * Gets this origin as a RandomAccessFile, if possible.
+     *
+     * @param openOption options like {@link StandardOpenOption}.
+     * @return this origin as a RandomAccessFile, if possible.
+     * @throws FileNotFoundException         See {@link RandomAccessFile#RandomAccessFile(File, String)}.
+     * @throws UnsupportedOperationException if this method is not implemented in a concrete subclass.
+     * @since 2.18.0
+     */
+    public RandomAccessFile getRandomAccessFile(final OpenOption... openOption) throws FileNotFoundException {
+        return RandomAccessFileMode.valueOf(openOption).create(getFile());
     }
 
     /**
@@ -499,6 +737,10 @@ public Reader getReader(final Charset charset) throws IOException {
         return Files.newBufferedReader(getPath(), charset);
     }
 
+    private String getSimpleClassName() {
+        return getClass().getSimpleName();
+    }
+
     /**
      * Gets a new Writer on the origin, buffered by default.
      *
@@ -525,6 +767,6 @@ public long size() throws IOException {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + "[" + origin.toString() + "]";
+        return getSimpleClassName() + "[" + origin.toString() + "]";
     }
 }
diff --git a/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java b/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java
index bd823713..768514cd 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java
@@ -20,18 +20,22 @@
 import java.io.File;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.RandomAccessFile;
 import java.io.Reader;
 import java.io.Writer;
 import java.net.URI;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 
+import org.apache.commons.io.IORandomAccessFile;
 import org.apache.commons.io.build.AbstractOrigin.ByteArrayOrigin;
 import org.apache.commons.io.build.AbstractOrigin.CharSequenceOrigin;
 import org.apache.commons.io.build.AbstractOrigin.FileOrigin;
+import org.apache.commons.io.build.AbstractOrigin.IORandomAccessFileOrigin;
 import org.apache.commons.io.build.AbstractOrigin.InputStreamOrigin;
 import org.apache.commons.io.build.AbstractOrigin.OutputStreamOrigin;
 import org.apache.commons.io.build.AbstractOrigin.PathOrigin;
+import org.apache.commons.io.build.AbstractOrigin.RandomAccessFileOrigin;
 import org.apache.commons.io.build.AbstractOrigin.ReaderOrigin;
 import org.apache.commons.io.build.AbstractOrigin.URIOrigin;
 import org.apache.commons.io.build.AbstractOrigin.WriterOrigin;
@@ -126,6 +130,28 @@ protected static PathOrigin newPathOrigin(final String origin) {
         return new PathOrigin(Paths.get(origin));
     }
 
+    /**
+     * Constructs a new RandomAccessFile origin for a RandomAccessFile.
+     *
+     * @param origin the reader.
+     * @return a new reader origin.
+     * @since 2.18.0
+     */
+    protected static IORandomAccessFileOrigin newRandomAccessFileOrigin(final IORandomAccessFile origin) {
+        return new IORandomAccessFileOrigin(origin);
+    }
+
+    /**
+     * Constructs a new RandomAccessFile origin for a RandomAccessFile.
+     *
+     * @param origin the reader.
+     * @return a new reader origin.
+     * @since 2.18.0
+     */
+    protected static RandomAccessFileOrigin newRandomAccessFileOrigin(final RandomAccessFile origin) {
+        return new RandomAccessFileOrigin(origin);
+    }
+
     /**
      * Constructs a new reader origin for a reader.
      *
@@ -196,7 +222,7 @@ protected boolean hasOrigin() {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setByteArray(final byte[] origin) {
         return setOrigin(newByteArrayOrigin(origin));
@@ -206,7 +232,7 @@ public B setByteArray(final byte[] origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      * @since 2.13.0
      */
     public B setCharSequence(final CharSequence origin) {
@@ -217,7 +243,7 @@ public B setCharSequence(final CharSequence origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setFile(final File origin) {
         return setOrigin(newFileOrigin(origin));
@@ -227,7 +253,7 @@ public B setFile(final File origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setFile(final String origin) {
         return setOrigin(newFileOrigin(origin));
@@ -237,7 +263,7 @@ public B setFile(final String origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setInputStream(final InputStream origin) {
         return setOrigin(newInputStreamOrigin(origin));
@@ -247,7 +273,7 @@ public B setInputStream(final InputStream origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     protected B setOrigin(final AbstractOrigin<?, ?> origin) {
         this.origin = origin;
@@ -258,7 +284,7 @@ protected B setOrigin(final AbstractOrigin<?, ?> origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setOutputStream(final OutputStream origin) {
         return setOrigin(newOutputStreamOrigin(origin));
@@ -268,7 +294,7 @@ public B setOutputStream(final OutputStream origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setPath(final Path origin) {
         return setOrigin(newPathOrigin(origin));
@@ -278,7 +304,7 @@ public B setPath(final Path origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setPath(final String origin) {
         return setOrigin(newPathOrigin(origin));
@@ -288,7 +314,29 @@ public B setPath(final String origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
+     * @since 2.18.0
+     */
+    public B setRandomAccessFile(final IORandomAccessFile origin) {
+        return setOrigin(newRandomAccessFileOrigin(origin));
+    }
+
+    /**
+     * Sets a new origin.
+     *
+     * @param origin the new origin.
+     * @return {@code this} instance.
+     * @since 2.18.0
+     */
+    public B setRandomAccessFile(final RandomAccessFile origin) {
+        return setOrigin(newRandomAccessFileOrigin(origin));
+    }
+
+    /**
+     * Sets a new origin.
+     *
+     * @param origin the new origin.
+     * @return {@code this} instance.
      */
     public B setReader(final Reader origin) {
         return setOrigin(newReaderOrigin(origin));
@@ -298,7 +346,7 @@ public B setReader(final Reader origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setURI(final URI origin) {
         return setOrigin(newURIOrigin(origin));
@@ -308,7 +356,7 @@ public B setURI(final URI origin) {
      * Sets a new origin.
      *
      * @param origin the new origin.
-     * @return this
+     * @return {@code this} instance.
      */
     public B setWriter(final Writer origin) {
         return setOrigin(newWriterOrigin(origin));
diff --git a/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java b/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java
index e0f9ba66..a8e5bcdb 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java
@@ -17,9 +17,12 @@
 
 package org.apache.commons.io.build;
 
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.io.Reader;
 import java.io.Writer;
 import java.nio.charset.Charset;
 import java.nio.file.OpenOption;
@@ -95,7 +98,7 @@ private int checkBufferSize(final int size) {
      *
      * @return the buffer size, defaults to {@link IOUtils#DEFAULT_BUFFER_SIZE} ({@value IOUtils#DEFAULT_BUFFER_SIZE}).
      */
-    protected int getBufferSize() {
+    public int getBufferSize() {
         return bufferSize;
     }
 
@@ -104,7 +107,7 @@ protected int getBufferSize() {
      *
      * @return the buffer size default, defaults to {@link IOUtils#DEFAULT_BUFFER_SIZE} ({@value IOUtils#DEFAULT_BUFFER_SIZE}).
      */
-    protected int getBufferSizeDefault() {
+    public int getBufferSizeDefault() {
         return bufferSizeDefault;
     }
 
@@ -112,13 +115,13 @@ protected int getBufferSizeDefault() {
      * Gets a CharSequence from the origin with a Charset.
      *
      * @return An input stream
-     * @throws IOException                   if an I/O error occurs.
-     * @throws UnsupportedOperationException if the origin cannot be converted to a CharSequence.
      * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a CharSequence.
+     * @throws IOException                   if an I/O error occurs.
      * @see AbstractOrigin#getCharSequence(Charset)
      * @since 2.13.0
      */
-    protected CharSequence getCharSequence() throws IOException {
+    public CharSequence getCharSequence() throws IOException {
         return checkOrigin().getCharSequence(getCharset());
     }
 
@@ -136,44 +139,59 @@ public Charset getCharset() {
      *
      * @return the Charset default, defaults to {@link Charset#defaultCharset()}.
      */
-    protected Charset getCharsetDefault() {
+    public Charset getCharsetDefault() {
         return charsetDefault;
     }
 
     /**
-     * Gets an input stream from the origin with open options.
+     * Gets a File from the origin.
+     *
+     * @return A File
+     * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link File}.
+     * @see AbstractOrigin#getPath()
+     * @since 2.18.0
+     */
+    public File getFile() {
+        return checkOrigin().getFile();
+    }
+
+    /**
+     * Gets an InputStream from the origin with OpenOption[].
      *
      * @return An input stream
+     * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
      * @throws IOException                   if an I/O error occurs.
-     * @throws UnsupportedOperationException if the origin cannot be converted to an InputStream.
      * @see AbstractOrigin#getInputStream(OpenOption...)
-     * @throws IllegalStateException if the {@code origin} is {@code null}.
+     * @see #getOpenOptions()
      * @since 2.13.0
      */
-    protected InputStream getInputStream() throws IOException {
+    public InputStream getInputStream() throws IOException {
         return checkOrigin().getInputStream(getOpenOptions());
     }
 
     /**
-     * Gets the OpenOption.
+     * Gets the OpenOption array.
      *
-     * @return the OpenOption.
+     * @return the OpenOption array.
      */
-    protected OpenOption[] getOpenOptions() {
+    public OpenOption[] getOpenOptions() {
         return openOptions;
     }
 
     /**
-     * Gets an OutputStream from the origin with open options.
+     * Gets an OutputStream from the origin with OpenOption[].
      *
      * @return An OutputStream
-     * @throws IOException                   if an I/O error occurs.
-     * @throws UnsupportedOperationException if the origin cannot be converted to an OutputStream.
      * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to an {@link OutputStream}.
+     * @throws IOException                   if an I/O error occurs.
      * @see AbstractOrigin#getOutputStream(OpenOption...)
+     * @see #getOpenOptions()
      * @since 2.13.0
      */
-    protected OutputStream getOutputStream() throws IOException {
+    public OutputStream getOutputStream() throws IOException {
         return checkOrigin().getOutputStream(getOpenOptions());
     }
 
@@ -181,26 +199,55 @@ protected OutputStream getOutputStream() throws IOException {
      * Gets a Path from the origin.
      *
      * @return A Path
-     * @throws UnsupportedOperationException if the origin cannot be converted to a Path.
      * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link Path}.
      * @see AbstractOrigin#getPath()
      * @since 2.13.0
      */
-    protected Path getPath() {
+    public Path getPath() {
         return checkOrigin().getPath();
     }
 
     /**
-     * Gets an writer from the origin with open options.
+     * Gets a RandomAccessFile from the origin.
      *
-     * @return An writer.
+     * @return A RandomAccessFile
+     * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link RandomAccessFile}.
      * @throws IOException                   if an I/O error occurs.
-     * @throws UnsupportedOperationException if the origin cannot be converted to a Writer.
+     * @since 2.18.0
+     */
+    public RandomAccessFile getRandomAccessFile() throws IOException {
+        return checkOrigin().getRandomAccessFile(getOpenOptions());
+    }
+
+    /**
+     * Gets a Reader from the origin with a Charset.
+     *
+     * @return A Reader
      * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link Reader}.
+     * @throws IOException                   if an I/O error occurs.
+     * @see AbstractOrigin#getReader(Charset)
+     * @see #getCharset()
+     * @since 2.16.0
+     */
+    public Reader getReader() throws IOException {
+        return checkOrigin().getReader(getCharset());
+    }
+
+    /**
+     * Gets a Writer from the origin with an OpenOption[].
+     *
+     * @return An writer.
+     * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link Writer}.
+     * @throws IOException                   if an I/O error occurs.
      * @see AbstractOrigin#getOutputStream(OpenOption...)
+     * @see #getOpenOptions()
      * @since 2.13.0
      */
-    protected Writer getWriter() throws IOException {
+    public Writer getWriter() throws IOException {
         return checkOrigin().getWriter(getCharset(), getOpenOptions());
     }
 
@@ -211,7 +258,7 @@ protected Writer getWriter() throws IOException {
      * </p>
      *
      * @param bufferSize the buffer size.
-     * @return this.
+     * @return {@code this} instance.
      */
     public B setBufferSize(final int bufferSize) {
         this.bufferSize = checkBufferSize(bufferSize > 0 ? bufferSize : bufferSizeDefault);
@@ -225,7 +272,7 @@ public B setBufferSize(final int bufferSize) {
      * </p>
      *
      * @param bufferSize the buffer size, null resets to the default.
-     * @return this.
+     * @return {@code this} instance.
      */
     public B setBufferSize(final Integer bufferSize) {
         setBufferSize(bufferSize != null ? bufferSize : bufferSizeDefault);
@@ -236,7 +283,7 @@ public B setBufferSize(final Integer bufferSize) {
      * Sets the buffer size checker function. Throws a {@link IllegalArgumentException} by default.
      *
      * @param bufferSizeChecker the buffer size checker function. null resets to the default behavior.
-     * @return this
+     * @return {@code this} instance.
      * @since 2.14.0
      */
     public B setBufferSizeChecker(final IntUnaryOperator bufferSizeChecker) {
@@ -251,7 +298,7 @@ public B setBufferSizeChecker(final IntUnaryOperator bufferSizeChecker) {
      * </p>
      *
      * @param bufferSizeDefault the buffer size, null resets to the default.
-     * @return this.
+     * @return {@code this} instance.
      */
     protected B setBufferSizeDefault(final int bufferSizeDefault) {
         this.bufferSizeDefault = bufferSizeDefault;
@@ -263,7 +310,7 @@ protected B setBufferSizeDefault(final int bufferSizeDefault) {
      * exceeded, this methods throws an {@link IllegalArgumentException}.
      *
      * @param bufferSizeMax maximum buffer size checked by the buffer size checker.
-     * @return this.
+     * @return {@code this} instance.
      * @since 2.14.0
      */
     public B setBufferSizeMax(final int bufferSizeMax) {
@@ -278,7 +325,7 @@ public B setBufferSizeMax(final int bufferSizeMax) {
      * </p>
      *
      * @param charset the Charset, null resets to the default.
-     * @return this.
+     * @return {@code this} instance.
      */
     public B setCharset(final Charset charset) {
         this.charset = Charsets.toCharset(charset, charsetDefault);
@@ -292,7 +339,7 @@ public B setCharset(final Charset charset) {
      * </p>
      *
      * @param charset the Charset name, null resets to the default.
-     * @return this.
+     * @return {@code this} instance.
      */
     public B setCharset(final String charset) {
         return setCharset(Charsets.toCharset(charset, charsetDefault));
@@ -305,7 +352,7 @@ public B setCharset(final String charset) {
      * </p>
      *
      * @param defaultCharset the Charset name, null resets to the default.
-     * @return this.
+     * @return {@code this} instance.
      */
     protected B setCharsetDefault(final Charset defaultCharset) {
         this.charsetDefault = defaultCharset;
@@ -322,7 +369,7 @@ protected B setCharsetDefault(final Charset defaultCharset) {
      * </p>
      *
      * @param openOptions the OpenOption[] name, null resets to the default.
-     * @return this.
+     * @return {@code this} instance.
      * @since 2.13.0
      * @see #setInputStream(InputStream)
      * @see #setOutputStream(OutputStream)
diff --git a/src/main/java/org/apache/commons/io/build/AbstractSupplier.java b/src/main/java/org/apache/commons/io/build/AbstractSupplier.java
index bfbeabad..84daedce 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractSupplier.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractSupplier.java
@@ -20,7 +20,103 @@
 import org.apache.commons.io.function.IOSupplier;
 
 /**
- * Abstracts supplying an instance of {@code T}. Use to implement the builder pattern.
+ * Abstracts supplying an instance of {@code T}.
+ * <p>
+ * Extend this class to implement the builder pattern.
+ * </p>
+ * <p>
+ * For example, here is a builder, a domain class, and a test.
+ * </p>
+ * <p>
+ * The builder:
+ * </p>
+ * <pre>
+    &#47;**
+     &#42; Builds Foo instances.
+     &#42;&#47;
+    public static class Builder extends AbstractSupplier&#60;Foo, Builder&#62; {
+
+        private String bar1;
+        private String bar2;
+        private String bar3;
+
+        &#47;**
+         &#42; Builds a new Foo.
+         &#42;&#47;
+        &#64;Override
+        public Foo get() {
+            return new Foo(bar1, bar2, bar3);
+        }
+
+        public Builder setBar1(final String bar1) {
+            this.bar1 = bar1;
+            return this;
+        }
+
+        public Builder setBar2(final String bar2) {
+            this.bar2 = bar2;
+            return this;
+        }
+
+        public Builder setBar3(final String bar3) {
+            this.bar3 = bar3;
+            return this;
+        }
+    }
+ * </pre>
+ * <p>
+ * The domain class:
+ * </p>
+ * <pre>
+    &#47;**
+     &#42; Domain class.
+     &#42;&#47;
+    public class Foo {
+
+        public static Builder builder() {
+            return new Builder();
+        }
+
+        private final String bar1;
+        private final String bar2;
+        private final String bar3;
+
+        private Foo(final String bar1, final String bar2, final String bar3) {
+            this.bar1 = bar1;
+            this.bar2 = bar2;
+            this.bar3 = bar3;
+        }
+
+        public String getBar1() {
+            return bar1;
+        }
+
+        public String getBar2() {
+            return bar2;
+        }
+
+        public String getBar3() {
+            return bar3;
+        }
+
+    }
+ * </pre>
+ * <p>
+ * The test:
+ * </p>
+ * <pre>
+    &#64;Test
+    public void test() {
+        final Foo foo = Foo.builder()
+            .setBar1("value1")
+            .setBar2("value2")
+            .setBar3("value3")
+            .get();
+        assertEquals("value1", foo.getBar1());
+        assertEquals("value2", foo.getBar2());
+        assertEquals("value3", foo.getBar3());
+    }
+ * </pre>
  *
  * @param <T> the type of instances to build.
  * @param <B> the type of builder subclass.
@@ -29,9 +125,15 @@
 public abstract class AbstractSupplier<T, B extends AbstractSupplier<T, B>> implements IOSupplier<T> {
 
     /**
-     * Returns this instance typed as the proper subclass type.
+     * Returns this instance typed as the subclass type {@code B}.
+     * <p>
+     * This is the same as the expression:
+     * </p>
+     * <pre>
+     * (B) this
+     * </pre>
      *
-     * @return this instance typed as the proper subclass type.
+     * @return this instance typed as the subclass type {@code B}.
      */
     @SuppressWarnings("unchecked")
     protected B asThis() {
diff --git a/src/main/java/org/apache/commons/io/channels/FileChannels.java b/src/main/java/org/apache/commons/io/channels/FileChannels.java
index 468c85b4..94116b14 100644
--- a/src/main/java/org/apache/commons/io/channels/FileChannels.java
+++ b/src/main/java/org/apache/commons/io/channels/FileChannels.java
@@ -60,6 +60,8 @@ public static boolean contentEquals(final FileChannel channel1, final FileChanne
         while (true) {
             final int read1 = channel1.read(byteBuffer1);
             final int read2 = channel2.read(byteBuffer2);
+            byteBuffer1.clear();
+            byteBuffer2.clear();
             if (read1 == IOUtils.EOF && read2 == IOUtils.EOF) {
                 return byteBuffer1.equals(byteBuffer2);
             }
@@ -69,8 +71,6 @@ public static boolean contentEquals(final FileChannel channel1, final FileChanne
             if (!byteBuffer1.equals(byteBuffer2)) {
                 return false;
             }
-            byteBuffer1.clear();
-            byteBuffer2.clear();
         }
     }
 
diff --git a/src/main/java/org/apache/commons/io/comparator/CompositeFileComparator.java b/src/main/java/org/apache/commons/io/comparator/CompositeFileComparator.java
index d50f3252..ca7c7888 100644
--- a/src/main/java/org/apache/commons/io/comparator/CompositeFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/CompositeFileComparator.java
@@ -28,7 +28,7 @@
  * <p>
  * This comparator can be used to sort lists or arrays of files by combining a number of other comparators.
  * <p>
- * Example of sorting a list of files by type (i.e. directory or file) and then by name:
+ * Example of sorting a list of files by type (directory or file) and then by name:
  *
  * <pre>
  *       CompositeFileComparator comparator = new CompositeFileComparator(
diff --git a/src/main/java/org/apache/commons/io/comparator/DefaultFileComparator.java b/src/main/java/org/apache/commons/io/comparator/DefaultFileComparator.java
index bf5a1c9a..ca0fcb39 100644
--- a/src/main/java/org/apache/commons/io/comparator/DefaultFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/DefaultFileComparator.java
@@ -21,7 +21,7 @@
 import java.util.Comparator;
 
 /**
- * Compares two files using the <b>default</b> {@link File#compareTo(File)} method.
+ * Compares two files using the <strong>default</strong> {@link File#compareTo(File)} method.
  * <p>
  * This comparator can be used to sort lists or arrays of files
  * by using the default file comparison.
@@ -35,7 +35,7 @@
  *       ((AbstractFileComparator) DefaultFileComparator.DEFAULT_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of doing a <i>reverse</i> sort of an array of files using the
+ * Example of doing a <em>reverse</em> sort of an array of files using the
  * {@link #DEFAULT_REVERSE} singleton instance:
  * </p>
  * <pre>
@@ -59,6 +59,13 @@ public class DefaultFileComparator extends AbstractFileComparator implements Ser
     /** Singleton reverse default comparator instance */
     public static final Comparator<File> DEFAULT_REVERSE = new ReverseFileComparator(DEFAULT_COMPARATOR);
 
+    /**
+     * Constructs a new instance.
+     */
+    public DefaultFileComparator() {
+        // empty
+    }
+
     /**
      * Compares the two files using the {@link File#compareTo(File)} method.
      *
diff --git a/src/main/java/org/apache/commons/io/comparator/DirectoryFileComparator.java b/src/main/java/org/apache/commons/io/comparator/DirectoryFileComparator.java
index 35f98bfa..cedf0b1e 100644
--- a/src/main/java/org/apache/commons/io/comparator/DirectoryFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/DirectoryFileComparator.java
@@ -34,7 +34,7 @@
  *       ((AbstractFileComparator) DirectoryFileComparator.DIRECTORY_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of doing a <i>reverse</i> sort of an array of files/directories using the {@link #DIRECTORY_REVERSE}
+ * Example of doing a <em>reverse</em> sort of an array of files/directories using the {@link #DIRECTORY_REVERSE}
  * singleton instance:
  * </p>
  *
diff --git a/src/main/java/org/apache/commons/io/comparator/ExtensionFileComparator.java b/src/main/java/org/apache/commons/io/comparator/ExtensionFileComparator.java
index 6960a904..a0b11a69 100644
--- a/src/main/java/org/apache/commons/io/comparator/ExtensionFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/ExtensionFileComparator.java
@@ -24,7 +24,7 @@
 import org.apache.commons.io.IOCase;
 
 /**
- * Compare the file name <b>extensions</b> for order
+ * Compare the file name <strong>extensions</strong> for order
  * (see {@link FilenameUtils#getExtension(String)}).
  * <p>
  * This comparator can be used to sort lists or arrays of files
@@ -34,7 +34,7 @@
  * and the reverse of those options.
  * </p>
  * <p>
- * Example of a <i>case-sensitive</i> file extension sort using the
+ * Example of a <em>case-sensitive</em> file extension sort using the
  * {@link #EXTENSION_COMPARATOR} singleton instance:
  * </p>
  * <pre>
@@ -42,7 +42,7 @@
  *       ((AbstractFileComparator) ExtensionFileComparator.EXTENSION_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of a <i>reverse case-insensitive</i> file extension sort using the
+ * Example of a <em>reverse case-insensitive</em> file extension sort using the
  * {@link #EXTENSION_INSENSITIVE_REVERSE} singleton instance:
  * </p>
  * <pre>
@@ -108,7 +108,6 @@ public ExtensionFileComparator(final IOCase ioCase) {
      * is less than the second, zero if the extensions are the
      * same and a positive value if the first files extension
      * is greater than the second file.
-     *
      */
     @Override
     public int compare(final File file1, final File file2) {
diff --git a/src/main/java/org/apache/commons/io/comparator/LastModifiedFileComparator.java b/src/main/java/org/apache/commons/io/comparator/LastModifiedFileComparator.java
index 7849f80b..26f1bc6e 100644
--- a/src/main/java/org/apache/commons/io/comparator/LastModifiedFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/LastModifiedFileComparator.java
@@ -23,7 +23,7 @@
 import org.apache.commons.io.FileUtils;
 
 /**
- * Compare the <b>last modified date/time</b> of two files for order
+ * Compare the <strong>last modified date/time</strong> of two files for order
  * (see {@link FileUtils#lastModifiedUnchecked(File)}).
  * <p>
  * This comparator can be used to sort lists or arrays of files
@@ -38,7 +38,7 @@
  *       ((AbstractFileComparator) LastModifiedFileComparator.LASTMODIFIED_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of doing a <i>reverse</i> sort of an array of files using the
+ * Example of doing a <em>reverse</em> sort of an array of files using the
  * {@link #LASTMODIFIED_REVERSE} singleton instance:
  * </p>
  * <pre>
diff --git a/src/main/java/org/apache/commons/io/comparator/NameFileComparator.java b/src/main/java/org/apache/commons/io/comparator/NameFileComparator.java
index 76f4dbd0..0001c7a3 100644
--- a/src/main/java/org/apache/commons/io/comparator/NameFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/NameFileComparator.java
@@ -23,7 +23,7 @@
 import org.apache.commons.io.IOCase;
 
 /**
- * Compare the <b>names</b> of two files for order (see {@link File#getName()}).
+ * Compare the <strong>names</strong> of two files for order (see {@link File#getName()}).
  * <p>
  * This comparator can be used to sort lists or arrays of files
  * by their name either in a case-sensitive, case-insensitive or
@@ -32,7 +32,7 @@
  * and the reverse of those options.
  * </p>
  * <p>
- * Example of a <i>case-sensitive</i> file name sort using the
+ * Example of a <em>case-sensitive</em> file name sort using the
  * {@link #NAME_COMPARATOR} singleton instance:
  * </p>
  * <pre>
@@ -40,7 +40,7 @@
  *       ((AbstractFileComparator) NameFileComparator.NAME_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of a <i>reverse case-insensitive</i> file name sort using the
+ * Example of a <em>reverse case-insensitive</em> file name sort using the
  * {@link #NAME_INSENSITIVE_REVERSE} singleton instance:
  * </p>
  * <pre>
diff --git a/src/main/java/org/apache/commons/io/comparator/PathFileComparator.java b/src/main/java/org/apache/commons/io/comparator/PathFileComparator.java
index 80579d13..3254cc32 100644
--- a/src/main/java/org/apache/commons/io/comparator/PathFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/PathFileComparator.java
@@ -23,7 +23,7 @@
 import org.apache.commons.io.IOCase;
 
 /**
- * Compare the <b>path</b> of two files for order (see {@link File#getPath()}).
+ * Compare the <strong>path</strong> of two files for order (see {@link File#getPath()}).
  * <p>
  * This comparator can be used to sort lists or arrays of files
  * by their path either in a case-sensitive, case-insensitive or
@@ -32,7 +32,7 @@
  * and the reverse of those options.
  * </p>
  * <p>
- * Example of a <i>case-sensitive</i> file path sort using the
+ * Example of a <em>case-sensitive</em> file path sort using the
  * {@link #PATH_COMPARATOR} singleton instance:
  * </p>
  * <pre>
@@ -40,7 +40,7 @@
  *       ((AbstractFileComparator) PathFileComparator.PATH_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of a <i>reverse case-insensitive</i> file path sort using the
+ * Example of a <em>reverse case-insensitive</em> file path sort using the
  * {@link #PATH_INSENSITIVE_REVERSE} singleton instance:
  * </p>
  * <pre>
@@ -103,7 +103,6 @@ public PathFileComparator(final IOCase ioCase) {
      * is less than the second, zero if the paths are the
      * same and a positive value if the first files path
      * is greater than the second file.
-     *
      */
     @Override
     public int compare(final File file1, final File file2) {
diff --git a/src/main/java/org/apache/commons/io/comparator/ReverseFileComparator.java b/src/main/java/org/apache/commons/io/comparator/ReverseFileComparator.java
index 8f33ec4d..d2239c51 100644
--- a/src/main/java/org/apache/commons/io/comparator/ReverseFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/ReverseFileComparator.java
@@ -30,7 +30,7 @@
  *
  * @since 1.4
  */
-class ReverseFileComparator extends AbstractFileComparator implements Serializable {
+final class ReverseFileComparator extends AbstractFileComparator implements Serializable {
 
     private static final long serialVersionUID = -4808255005272229056L;
     private final Comparator<File> delegate;
@@ -49,8 +49,8 @@ public ReverseFileComparator(final Comparator<File> delegate) {
      *
      * @param file1 The first file to compare.
      * @param file2 The second file to compare.
-     * @return the result from the delegate {@link Comparator#compare(Object, Object)} reversing the value (i.e.
-     *         positive becomes negative and vice versa).
+     * @return the result from the delegate {@link Comparator#compare(Object, Object)} reversing the value,
+     *         positive becomes negative and vice versa.
      */
     @Override
     public int compare(final File file1, final File file2) {
diff --git a/src/main/java/org/apache/commons/io/comparator/SizeFileComparator.java b/src/main/java/org/apache/commons/io/comparator/SizeFileComparator.java
index 21463bd0..f7eac085 100644
--- a/src/main/java/org/apache/commons/io/comparator/SizeFileComparator.java
+++ b/src/main/java/org/apache/commons/io/comparator/SizeFileComparator.java
@@ -23,7 +23,7 @@
 import org.apache.commons.io.FileUtils;
 
 /**
- * Compare the <b>length/size</b> of two files for order (see
+ * Compare the <strong>length/size</strong> of two files for order (see
  * {@link File#length()} and {@link FileUtils#sizeOfDirectory(File)}).
  * <p>
  * This comparator can be used to sort lists or arrays of files
@@ -38,7 +38,7 @@
  *       ((AbstractFileComparator) SizeFileComparator.SIZE_COMPARATOR).sort(list);
  * </pre>
  * <p>
- * Example of doing a <i>reverse</i> sort of an array of files using the
+ * Example of doing a <em>reverse</em> sort of an array of files using the
  * {@link #SIZE_REVERSE} singleton instance:
  * </p>
  * <pre>
@@ -46,7 +46,7 @@
  *       ((AbstractFileComparator) SizeFileComparator.SIZE_REVERSE).sort(array);
  * </pre>
  * <p>
- * <strong>N.B.</strong> Directories are treated as <b>zero size</b> unless
+ * <strong>N.B.</strong> Directories are treated as <strong>zero size</strong> unless
  * {@code sumDirectoryContents} is {@code true}.
  * </p>
  * <h2>Deprecating Serialization</h2>
@@ -113,7 +113,6 @@ public SizeFileComparator(final boolean sumDirectoryContents) {
      * is less than the second, zero if the lengths are the
      * same and a positive value if the first files length
      * is greater than the second file.
-     *
      */
     @Override
     public int compare(final File file1, final File file2) {
diff --git a/src/main/java/org/apache/commons/io/comparator/package-info.java b/src/main/java/org/apache/commons/io/comparator/package-info.java
index 17f6a962..b084bb4d 100644
--- a/src/main/java/org/apache/commons/io/comparator/package-info.java
+++ b/src/main/java/org/apache/commons/io/comparator/package-info.java
@@ -20,7 +20,7 @@
  * for {@link java.io.File}s and {@link java.nio.file.Path}.
  * <h2>Sorting</h2>
  * <p>
- * All the comparators include <i>convenience</i> utility <code>sort(File...)</code> and
+ * All the comparators include <em>convenience</em> utility <code>sort(File...)</code> and
  * <code>sort(List)</code> methods.
  * </p>
  * <p>
@@ -42,7 +42,7 @@
  * to compare (and sort lists or arrays of files) by combining a number of other comparators.
  * </p>
  * <p>
- * For example, to sort an array of files by type (i.e. directory or file)
+ * For example, to sort an array of files by type (directory or file)
  * and then by name:
  * </p>
  * <pre>
@@ -55,8 +55,8 @@
  * </pre>
  * <h2>Singleton Instances (thread-safe)</h2>
  * <p>
- * The {@link java.util.Comparator} implementations have some <i>convenience</i>
- * singleton(<i>thread-safe</i>) instances ready to use:
+ * The {@link java.util.Comparator} implementations have some <em>convenience</em>
+ * singleton(<em>thread-safe</em>) instances ready to use:
  * </p>
  * <ul>
  * <li><a href="DefaultFileComparator.html">DefaultFileComparator</a> - default file compare:
diff --git a/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java b/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java
index ecfdd2b7..0d4bf2d9 100644
--- a/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java
@@ -42,14 +42,14 @@
  * Instant cutoff = Instant.now().minus(Duration.ofDays(1));
  * AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
  * //
- * // Walk one dir
+ * // Walk one directory
  * Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
+ * // Walk directory tree
  * Files.walkFileTree(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
@@ -171,21 +171,21 @@ public boolean equals(final Object obj) {
     }
 
     /**
-     * Gets the list of visited directories.
+     * Gets a copy of the list of visited directories.
      *
-     * @return the list of visited directories.
+     * @return a copy of the list of visited directories.
      */
     public List<Path> getDirList() {
-        return dirList;
+        return new ArrayList<>(dirList);
     }
 
     /**
-     * Gets the list of visited files.
+     * Gets a copy of the list of visited files.
      *
-     * @return the list of visited files.
+     * @return a copy of the list of visited files.
      */
     public List<Path> getFileList() {
-        return fileList;
+        return new ArrayList<>(fileList);
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/io/file/CleaningPathVisitor.java b/src/main/java/org/apache/commons/io/file/CleaningPathVisitor.java
index 79162f32..81c4c29c 100644
--- a/src/main/java/org/apache/commons/io/file/CleaningPathVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/CleaningPathVisitor.java
@@ -57,7 +57,7 @@ public static CountingPathVisitor withLongCounters() {
     private final boolean overrideReadOnly;
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      * @param deleteOption How deletion is handled.
@@ -73,7 +73,7 @@ public CleaningPathVisitor(final PathCounters pathCounter, final DeleteOption[]
     }
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a new instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      * @param skip The files to skip deleting.
@@ -89,7 +89,7 @@ public CleaningPathVisitor(final PathCounters pathCounter, final String... skip)
      * @return true to process the given path, false if not.
      */
     private boolean accept(final Path path) {
-        return Arrays.binarySearch(skip, Objects.toString(path.getFileName(), null)) < 0;
+        return Arrays.binarySearch(skip, PathUtils.getFileNameString(path)) < 0;
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java b/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java
index 57896fd1..41c1d6bb 100644
--- a/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java
@@ -45,7 +45,7 @@ private static CopyOption[] toCopyOption(final CopyOption... copyOptions) {
     private final Path targetDirectory;
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      * @param sourceDirectory The source directory
@@ -60,7 +60,7 @@ public CopyDirectoryVisitor(final PathCounters pathCounter, final Path sourceDir
     }
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      * @param fileFilter How to filter file paths.
diff --git a/src/main/java/org/apache/commons/io/file/Counters.java b/src/main/java/org/apache/commons/io/file/Counters.java
index 2b6736c1..6654c830 100644
--- a/src/main/java/org/apache/commons/io/file/Counters.java
+++ b/src/main/java/org/apache/commons/io/file/Counters.java
@@ -173,7 +173,7 @@ private final static class BigIntegerPathCounters extends AbstractPathCounters {
          * Constructs a new initialized instance.
          */
         protected BigIntegerPathCounters() {
-            super(Counters.bigIntegerCounter(), Counters.bigIntegerCounter(), Counters.bigIntegerCounter());
+            super(bigIntegerCounter(), bigIntegerCounter(), bigIntegerCounter());
         }
 
     }
@@ -295,7 +295,7 @@ private final static class LongPathCounters extends AbstractPathCounters {
          * Constructs a new initialized instance.
          */
         protected LongPathCounters() {
-            super(Counters.longCounter(), Counters.longCounter(), Counters.longCounter());
+            super(longCounter(), longCounter(), longCounter());
         }
 
     }
@@ -356,7 +356,7 @@ private static final class NoopPathCounters extends AbstractPathCounters {
          * Constructs a new initialized instance.
          */
         private NoopPathCounters() {
-            super(Counters.noopCounter(), Counters.noopCounter(), Counters.noopCounter());
+            super(noopCounter(), noopCounter(), noopCounter());
         }
 
     }
diff --git a/src/main/java/org/apache/commons/io/file/DeletingPathVisitor.java b/src/main/java/org/apache/commons/io/file/DeletingPathVisitor.java
index aff9bcd3..53dc0db1 100644
--- a/src/main/java/org/apache/commons/io/file/DeletingPathVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/DeletingPathVisitor.java
@@ -59,7 +59,7 @@ public static DeletingPathVisitor withLongCounters() {
     private final LinkOption[] linkOptions;
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      * @param deleteOption How deletion is handled.
@@ -71,7 +71,7 @@ public DeletingPathVisitor(final PathCounters pathCounter, final DeleteOption[]
     }
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      * @param linkOptions How symbolic links are handled.
@@ -90,7 +90,7 @@ public DeletingPathVisitor(final PathCounters pathCounter, final LinkOption[] li
     }
 
     /**
-     * Constructs a new visitor that deletes files except for the files and directories explicitly given.
+     * Constructs a instance that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
      *
@@ -107,7 +107,7 @@ public DeletingPathVisitor(final PathCounters pathCounter, final String... skip)
      * @return true to process the given path, false if not.
      */
     private boolean accept(final Path path) {
-        return Arrays.binarySearch(skip, Objects.toString(path.getFileName(), null)) < 0;
+        return Arrays.binarySearch(skip, PathUtils.getFileNameString(path)) < 0;
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/io/file/PathFilter.java b/src/main/java/org/apache/commons/io/file/PathFilter.java
index 837ddc02..e8727760 100644
--- a/src/main/java/org/apache/commons/io/file/PathFilter.java
+++ b/src/main/java/org/apache/commons/io/file/PathFilter.java
@@ -33,7 +33,7 @@ public interface PathFilter {
      * Tests whether or not to include the specified Path in a result.
      *
      * @param path The Path to test.
-     * @param attributes the file's basic attributes (TODO may be null).
+     * @param attributes the path's basic attributes (may be null).
      * @return a FileVisitResult
      */
     FileVisitResult accept(Path path, BasicFileAttributes attributes);
diff --git a/src/main/java/org/apache/commons/io/file/PathUtils.java b/src/main/java/org/apache/commons/io/file/PathUtils.java
index d85fdb67..b93535d3 100644
--- a/src/main/java/org/apache/commons/io/file/PathUtils.java
+++ b/src/main/java/org/apache/commons/io/file/PathUtils.java
@@ -60,9 +60,11 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
+import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
@@ -70,6 +72,7 @@
 import org.apache.commons.io.Charsets;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.FilenameUtils;
+import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.RandomAccessFileMode;
 import org.apache.commons.io.RandomAccessFiles;
 import org.apache.commons.io.ThreadUtils;
@@ -87,8 +90,7 @@
 public final class PathUtils {
 
     /**
-     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative
-     * lists when comparing directories.
+     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative lists when comparing directories.
      */
     private static final class RelativeSortedPaths {
 
@@ -101,15 +103,15 @@ private static final class RelativeSortedPaths {
         /**
          * Constructs and initializes a new instance by accumulating directory and file info.
          *
-         * @param dir1 First directory to compare.
-         * @param dir2 Seconds directory to compare.
-         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
-         * @param linkOptions Options indicating how symbolic links are handled.
+         * @param dir1             First directory to compare.
+         * @param dir2             Seconds directory to compare.
+         * @param maxDepth         See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+         * @param linkOptions      Options indicating how symbolic links are handled.
          * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
          * @throws IOException if an I/O error is thrown by a visitor method.
          */
         private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,
-            final FileVisitOption[] fileVisitOptions) throws IOException {
+                final FileVisitOption[] fileVisitOptions) throws IOException {
             final List<Path> tmpRelativeDirList1;
             final List<Path> tmpRelativeDirList2;
             List<Path> tmpRelativeFileList1 = null;
@@ -148,9 +150,9 @@ private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth
         }
     }
 
-    private static final OpenOption[] OPEN_OPTIONS_TRUNCATE = {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING};
+    private static final OpenOption[] OPEN_OPTIONS_TRUNCATE = { StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING };
 
-    private static final OpenOption[] OPEN_OPTIONS_APPEND = {StandardOpenOption.CREATE, StandardOpenOption.APPEND};
+    private static final OpenOption[] OPEN_OPTIONS_APPEND = { StandardOpenOption.CREATE, StandardOpenOption.APPEND };
 
     /**
      * Empty {@link CopyOption} array.
@@ -190,7 +192,7 @@ private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth
      * @deprecated Use {@link #noFollowLinkOptionArray()}.
      */
     @Deprecated
-    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};
+    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = { LinkOption.NOFOLLOW_LINKS };
 
     /**
      * A LinkOption used to follow link in this class, the inverse of {@link LinkOption#NOFOLLOW_LINKS}.
@@ -214,8 +216,8 @@ private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth
     /**
      * Accumulates file tree information in a {@link AccumulatorPathVisitor}.
      *
-     * @param directory The directory to accumulate information.
-     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+     * @param directory        The directory to accumulate information.
+     * @param maxDepth         See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
      * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
      * @throws IOException if an I/O error is thrown by a visitor method.
      * @return file tree information.
@@ -225,7 +227,7 @@ private static AccumulatorPathVisitor accumulate(final Path directory, final int
     }
 
     /**
-     * Cleans a directory including subdirectories without deleting directories.
+     * Cleans a directory by deleting only files, including in subdirectories, but without deleting the directories.
      *
      * @param directory directory to clean.
      * @return The visitation path counters.
@@ -236,9 +238,9 @@ public static PathCounters cleanDirectory(final Path directory) throws IOExcepti
     }
 
     /**
-     * Cleans a directory including subdirectories without deleting directories.
+     * Cleans a directory by deleting only files, including in subdirectories, but without deleting the directories.
      *
-     * @param directory directory to clean.
+     * @param directory     directory to clean.
      * @param deleteOptions How to handle deletion.
      * @return The visitation path counters.
      * @throws IOException if an I/O error is thrown by a visitor method.
@@ -251,11 +253,11 @@ public static PathCounters cleanDirectory(final Path directory, final DeleteOpti
     /**
      * Compares the given {@link Path}'s last modified time to the given file time.
      *
-     * @param file the {@link Path} to test.
+     * @param file     the {@link Path} to test.
      * @param fileTime the time reference.
-     * @param options options indicating how to handle symbolic links.
+     * @param options  options indicating how to handle symbolic links.
      * @return See {@link FileTime#compareTo(FileTime)}
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      */
     private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {
@@ -265,8 +267,8 @@ private static int compareLastModifiedTimeTo(final Path file, final FileTime fil
     /**
      * Copies the InputStream from the supplier with {@link Files#copy(InputStream, Path, CopyOption...)}.
      *
-     * @param in Supplies the InputStream.
-     * @param target See {@link Files#copy(InputStream, Path, CopyOption...)}.
+     * @param in          Supplies the InputStream.
+     * @param target      See {@link Files#copy(InputStream, Path, CopyOption...)}.
      * @param copyOptions See {@link Files#copy(InputStream, Path, CopyOption...)}.
      * @return See {@link Files#copy(InputStream, Path, CopyOption...)}
      * @throws IOException See {@link Files#copy(InputStream, Path, CopyOption...)}
@@ -283,21 +285,21 @@ public static long copy(final IOSupplier<InputStream> in, final Path target, fin
      *
      * @param sourceDirectory The source directory.
      * @param targetDirectory The target directory.
-     * @param copyOptions Specifies how the copying should be done.
+     * @param copyOptions     Specifies how the copying should be done.
      * @return The visitation path counters.
      * @throws IOException if an I/O error is thrown by a visitor method.
      */
     public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {
         final Path absoluteSource = sourceDirectory.toAbsolutePath();
         return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)
-            .getPathCounters();
+                .getPathCounters();
     }
 
     /**
      * Copies a URL to a directory.
      *
-     * @param sourceFile The source URL.
-     * @param targetFile The target file.
+     * @param sourceFile  The source URL.
+     * @param targetFile  The target file.
      * @param copyOptions Specifies how the copying should be done.
      * @return The target file
      * @throws IOException if an I/O error occurs.
@@ -311,9 +313,9 @@ public static Path copyFile(final URL sourceFile, final Path targetFile, final C
     /**
      * Copies a file to a directory.
      *
-     * @param sourceFile The source file.
+     * @param sourceFile      The source file.
      * @param targetDirectory The target directory.
-     * @param copyOptions Specifies how the copying should be done.
+     * @param copyOptions     Specifies how the copying should be done.
      * @return The target file
      * @throws IOException if an I/O error occurs.
      * @see Files#copy(Path, Path, CopyOption...)
@@ -325,9 +327,9 @@ public static Path copyFileToDirectory(final Path sourceFile, final Path targetD
     /**
      * Copies a URL to a directory.
      *
-     * @param sourceFile The source URL.
+     * @param sourceFile      The source URL.
      * @param targetDirectory The target directory.
-     * @param copyOptions Specifies how the copying should be done.
+     * @param copyOptions     Specifies how the copying should be done.
      * @return The target file
      * @throws IOException if an I/O error occurs.
      * @see Files#copy(InputStream, Path, CopyOption...)
@@ -367,7 +369,7 @@ public static PathCounters countDirectoryAsBigInteger(final Path directory) thro
      * If the parent directory already exists, then return it.
      * </p>
      *
-     * @param path The path to a file (or directory).
+     * @param path  The path to a file (or directory).
      * @param attrs An optional list of file attributes to set atomically when creating the directories.
      * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.
      * @throws IOException if an I/O error occurs.
@@ -383,15 +385,14 @@ public static Path createParentDirectories(final Path path, final FileAttribute<
      * If the parent directory already exists, then return it.
      * </p>
      *
-     * @param path The path to a file (or directory).
+     * @param path       The path to a file (or directory).
      * @param linkOption A {@link LinkOption} or null.
-     * @param attrs An optional list of file attributes to set atomically when creating the directories.
+     * @param attrs      An optional list of file attributes to set atomically when creating the directories.
      * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.
      * @throws IOException if an I/O error occurs.
      * @since 2.12.0
      */
-    public static Path createParentDirectories(final Path path, final LinkOption linkOption,
-            final FileAttribute<?>... attrs) throws IOException {
+    public static Path createParentDirectories(final Path path, final LinkOption linkOption, final FileAttribute<?>... attrs) throws IOException {
         Path parent = getParent(path);
         parent = linkOption == LinkOption.NOFOLLOW_LINKS ? parent : readIfSymbolicLink(parent);
         if (parent == null) {
@@ -415,17 +416,17 @@ public static Path current() {
     /**
      * Deletes a file or directory. If the path is a directory, delete it and all subdirectories.
      * <p>
-     * The difference between File.delete() and this method are:
+     * The difference between {@link File#delete()} and this method are:
      * </p>
      * <ul>
      * <li>A directory to delete does not have to be empty.</li>
-     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.
+     * <li>You get exceptions when a file or directory cannot be deleted; {@link File#delete()} returns a boolean.
      * </ul>
      *
      * @param path file or directory to delete, must not be {@code null}
      * @return The visitor used to delete the given directory.
      * @throws NullPointerException if the directory is {@code null}
-     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.
+     * @throws IOException          if an I/O error is thrown by a visitor method or if an I/O error occurs.
      */
     public static PathCounters delete(final Path path) throws IOException {
         return delete(path, EMPTY_DELETE_OPTION_ARRAY);
@@ -438,14 +439,14 @@ public static PathCounters delete(final Path path) throws IOException {
      * </p>
      * <ul>
      * <li>A directory to delete does not have to be empty.</li>
-     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.
+     * <li>You get exceptions when a file or directory cannot be deleted; {@link File#delete()} returns a boolean.
      * </ul>
      *
-     * @param path file or directory to delete, must not be {@code null}
+     * @param path          file or directory to delete, must not be {@code null}
      * @param deleteOptions How to handle deletion.
      * @return The visitor used to delete the given directory.
      * @throws NullPointerException if the directory is {@code null}
-     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.
+     * @throws IOException          if an I/O error is thrown by a visitor method or if an I/O error occurs.
      * @since 2.8.0
      */
     public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {
@@ -460,15 +461,15 @@ public static PathCounters delete(final Path path, final DeleteOption... deleteO
      * </p>
      * <ul>
      * <li>A directory to delete does not have to be empty.</li>
-     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.
+     * <li>You get exceptions when a file or directory cannot be deleted; {@link File#delete()} returns a boolean.
      * </ul>
      *
-     * @param path file or directory to delete, must not be {@code null}
-     * @param linkOptions How to handle symbolic links.
+     * @param path          file or directory to delete, must not be {@code null}
+     * @param linkOptions   How to handle symbolic links.
      * @param deleteOptions How to handle deletion.
      * @return The visitor used to delete the given directory.
      * @throws NullPointerException if the directory is {@code null}
-     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.
+     * @throws IOException          if an I/O error is thrown by a visitor method or if an I/O error occurs.
      * @since 2.9.0
      */
     public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {
@@ -490,24 +491,24 @@ public static PathCounters deleteDirectory(final Path directory) throws IOExcept
     /**
      * Deletes a directory including subdirectories.
      *
-     * @param directory directory to delete.
+     * @param directory     directory to delete.
      * @param deleteOptions How to handle deletion.
      * @return The visitor used to delete the given directory.
      * @throws IOException if an I/O error is thrown by a visitor method.
      * @since 2.8.0
      */
     public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {
-        final LinkOption[] linkOptions = PathUtils.noFollowLinkOptionArray();
+        final LinkOption[] linkOptions = noFollowLinkOptionArray();
         // POSIX ops will noop on non-POSIX.
         return withPosixFileAttributes(getParent(directory), linkOptions, overrideReadOnly(deleteOptions),
-            pfa -> visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters());
+                pfa -> visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters());
     }
 
     /**
      * Deletes a directory including subdirectories.
      *
-     * @param directory directory to delete.
-     * @param linkOptions How to handle symbolic links.
+     * @param directory     directory to delete.
+     * @param linkOptions   How to handle symbolic links.
      * @param deleteOptions How to handle deletion.
      * @return The visitor used to delete the given directory.
      * @throws IOException if an I/O error is thrown by a visitor method.
@@ -522,8 +523,8 @@ public static PathCounters deleteDirectory(final Path directory, final LinkOptio
      *
      * @param file The file to delete.
      * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.
-     * @throws IOException if an I/O error occurs.
-     * @throws NoSuchFileException if the file is a directory.
+     * @throws IOException         if an I/O error occurs.
+     * @throws NoSuchFileException if the file is a directory
      */
     public static PathCounters deleteFile(final Path file) throws IOException {
         return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);
@@ -532,10 +533,10 @@ public static PathCounters deleteFile(final Path file) throws IOException {
     /**
      * Deletes the given file.
      *
-     * @param file The file to delete.
+     * @param file          The file to delete.
      * @param deleteOptions How to handle deletion.
      * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException         if an I/O error occurs.
      * @throws NoSuchFileException if the file is a directory.
      * @since 2.8.0
      */
@@ -547,18 +548,18 @@ public static PathCounters deleteFile(final Path file, final DeleteOption... del
     /**
      * Deletes the given file.
      *
-     * @param file The file to delete.
-     * @param linkOptions How to handle symbolic links.
+     * @param file          The file to delete.
+     * @param linkOptions   How to handle symbolic links.
      * @param deleteOptions How to handle deletion.
      * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException         if an I/O error occurs.
      * @throws NoSuchFileException if the file is a directory.
      * @since 2.9.0
      */
     public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)
-        throws NoSuchFileException, IOException {
+            throws NoSuchFileException, IOException {
         //
-        // TODO Needs clean up
+        // TODO Needs clean up?
         //
         if (Files.isDirectory(file, linkOptions)) {
             throw new NoSuchFileException(file.toString());
@@ -604,12 +605,12 @@ public static PathCounters deleteFile(final Path file, final LinkOption[] linkOp
      * @since 3.13.0
      */
     public static void deleteOnExit(final Path path) {
-        Objects.requireNonNull(path.toFile()).deleteOnExit();
+        Objects.requireNonNull(path).toFile().deleteOnExit();
     }
 
     /**
-     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The
-     * comparison includes all files in all subdirectories.
+     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The comparison includes all files in all
+     * subdirectories.
      *
      * @param path1 The first directory.
      * @param path2 The second directory.
@@ -621,19 +622,19 @@ public static boolean directoryAndFileContentEquals(final Path path1, final Path
     }
 
     /**
-     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The
-     * comparison includes all files in all subdirectories.
+     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The comparison includes all files in all
+     * subdirectories.
      *
-     * @param path1 The first directory.
-     * @param path2 The second directory.
-     * @param linkOptions options to follow links.
-     * @param openOptions options to open files.
+     * @param path1           The first directory.
+     * @param path2           The second directory.
+     * @param linkOptions     options to follow links.
+     * @param openOptions     options to open files.
      * @param fileVisitOption options to configure traversal.
      * @return Whether the two directories contain the same files while considering file contents.
      * @throws IOException if an I/O error is thrown by a visitor method.
      */
     public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,
-        final FileVisitOption[] fileVisitOption) throws IOException {
+            final FileVisitOption[] fileVisitOption) throws IOException {
         // First walk both file trees and gather normalized paths.
         if (path1 == null && path2 == null) {
             return true;
@@ -665,8 +666,8 @@ public static boolean directoryAndFileContentEquals(final Path path1, final Path
     }
 
     /**
-     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The
-     * comparison includes all files in all subdirectories.
+     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The comparison includes all files in all
+     * subdirectories.
      *
      * @param path1 The first directory.
      * @param path2 The second directory.
@@ -678,25 +679,24 @@ public static boolean directoryContentEquals(final Path path1, final Path path2)
     }
 
     /**
-     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The
-     * comparison includes all files in all subdirectories.
+     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The comparison includes all files in all
+     * subdirectories.
      *
-     * @param path1 The first directory.
-     * @param path2 The second directory.
-     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
-     * @param linkOptions options to follow links.
+     * @param path1            The first directory.
+     * @param path2            The second directory.
+     * @param maxDepth         See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+     * @param linkOptions      options to follow links.
      * @param fileVisitOptions options to configure the traversal
      * @return Whether the two directories contain the same files without considering file contents.
      * @throws IOException if an I/O error is thrown by a visitor method.
      */
     public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,
-        final FileVisitOption[] fileVisitOptions) throws IOException {
+            final FileVisitOption[] fileVisitOptions) throws IOException {
         return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;
     }
 
     private static boolean exists(final Path path, final LinkOption... options) {
-        Objects.requireNonNull(path, "path");
-        return options != null ? Files.exists(path, options) : Files.exists(path);
+        return path != null && (options != null ? Files.exists(path, options) : Files.exists(path));
     }
 
     /**
@@ -709,7 +709,7 @@ private static boolean exists(final Path path, final LinkOption... options) {
      * @param path2 the second stream.
      * @return true if the content of the streams are equal or they both don't exist, false otherwise.
      * @throws NullPointerException if either input is null.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)
      */
     public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {
@@ -722,13 +722,13 @@ public static boolean fileContentEquals(final Path path1, final Path path2) thro
      * File content is accessed through {@link RandomAccessFileMode#create(Path)}.
      * </p>
      *
-     * @param path1 the first stream.
-     * @param path2 the second stream.
+     * @param path1       the first stream.
+     * @param path2       the second stream.
      * @param linkOptions options specifying how files are followed.
      * @param openOptions ignored.
      * @return true if the content of the streams are equal or they both don't exist, false otherwise.
      * @throws NullPointerException if openOptions is null.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)
      */
     public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)
@@ -766,16 +766,26 @@ public static boolean fileContentEquals(final Path path1, final Path path2, fina
             // same file
             return true;
         }
+        // Faster:
         try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(path1.toRealPath(linkOptions));
                 RandomAccessFile raf2 = RandomAccessFileMode.READ_ONLY.create(path2.toRealPath(linkOptions))) {
             return RandomAccessFiles.contentEquals(raf1, raf2);
+        } catch (final UnsupportedOperationException e) {
+            // Slower:
+            // Handle
+            // java.lang.UnsupportedOperationException
+            // at com.sun.nio.zipfs.ZipPath.toFile(ZipPath.java:656)
+            try (InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);
+                    InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {
+                return IOUtils.contentEquals(inputStream1, inputStream2);
+            }
         }
     }
 
     /**
      * <p>
-     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original
-     * file list that matches the provided filter.
+     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original file list that matches the provided
+     * filter.
      * </p>
      *
      * <p>
@@ -789,10 +799,10 @@ public static boolean fileContentEquals(final Path path1, final Path path2, fina
      * </pre>
      *
      * @param filter the filter to apply to the set of files.
-     * @param paths the array of files to apply the filter to.
+     * @param paths  the array of files to apply the filter to.
      *
      * @return a subset of {@code files} that is accepted by the file filter.
-     * @throws NullPointerException if the filter is {@code null}
+     * @throws NullPointerException     if the filter is {@code null}
      * @throws IllegalArgumentException if {@code files} contains a {@code null} value.
      *
      * @since 2.9.0
@@ -836,7 +846,7 @@ public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOExc
     /**
      * Shorthand for {@code Files.getFileAttributeView(path, AclFileAttributeView.class)}.
      *
-     * @param path the path to the file.
+     * @param path    the path to the file.
      * @param options how to handle symbolic links.
      * @return a AclFileAttributeView, or {@code null} if the attribute view type is not available.
      * @since 2.12.0
@@ -846,9 +856,27 @@ public static AclFileAttributeView getAclFileAttributeView(final Path path, fina
     }
 
     /**
-     * Shorthand for {@code Files.getFileAttributeView(path, DosFileAttributeView.class)}.
+     * Gets the base name (the part up to and not including the last ".") of the last path segment of a file name.
+     * <p>
+     * Will return the file name itself if it doesn't contain any dots. All leading directories of the {@code file name} parameter are skipped.
+     * </p>
+     *
+     * @return the base name of file name
+     * @param path the path of the file to obtain the base name of.
+     * @since 2.16.0
+     */
+    public static String getBaseName(final Path path) {
+        if (path == null) {
+            return null;
+        }
+        final Path fileName = path.getFileName();
+        return fileName != null ? FilenameUtils.removeExtension(fileName.toString()) : null;
+    }
+
+    /**
+     * Shorthand for {@code Files.getFileAttributeView(path, DosFileAttributeView.class, options)}.
      *
-     * @param path the path to the file.
+     * @param path    the path to the file.
      * @param options how to handle symbolic links.
      * @return a DosFileAttributeView, or {@code null} if the attribute view type is not available.
      * @since 2.12.0
@@ -857,12 +885,62 @@ public static DosFileAttributeView getDosFileAttributeView(final Path path, fina
         return Files.getFileAttributeView(path, DosFileAttributeView.class, options);
     }
 
+    /**
+     * Gets the extension of a Path.
+     * <p>
+     * This method returns the textual part of the Path after the last dot.
+     * </p>
+     * <pre>
+     * foo.txt      --&gt; "txt"
+     * a/b/c.jpg    --&gt; "jpg"
+     * a/b.txt/c    --&gt; ""
+     * a/b/c        --&gt; ""
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * </p>
+     *
+     * @param path the path to query.
+     * @return the extension of the file or an empty string if none exists or {@code null} if the fileName is {@code null}.
+     * @since 2.16.0
+     */
+    public static String getExtension(final Path path) {
+        final String fileName = getFileNameString(path);
+        return fileName != null ? FilenameUtils.getExtension(fileName) : null;
+    }
+
+    /**
+     * Gets the Path's file name and apply the given function if the file name is non-null.
+     *
+     * @param <R> The function's result type.
+     * @param path the path to query.
+     * @param function function to apply to the file name.
+     * @return the Path's file name as a string or null.
+     * @see Path#getFileName()
+     * @since 2.16.0
+     */
+    public static <R> R getFileName(final Path path, final Function<Path, R> function) {
+        final Path fileName = path != null ? path.getFileName() : null;
+        return fileName != null ? function.apply(fileName) : null;
+    }
+
+    /**
+     * Gets the Path's file name as a string.
+     *
+     * @param path the path to query.
+     * @return the Path's file name as a string or null.
+     * @see Path#getFileName()
+     * @since 2.16.0
+     */
+    public static String getFileNameString(final Path path) {
+        return getFileName(path, Path::toString);
+    }
+
     /**
      * Gets the file's last modified time or null if the file does not exist.
      * <p>
-     * The method provides a workaround for bug <a href="https://bugs.openjdk.java.net/browse/JDK-8177809">JDK-8177809</a>
-     * where {@link File#lastModified()} looses milliseconds and always ends in 000. This bug is in OpenJDK 8 and 9, and
-     * fixed in 11.
+     * The method provides a workaround for bug <a href="https://bugs.openjdk.java.net/browse/JDK-8177809">JDK-8177809</a> where {@link File#lastModified()}
+     * looses milliseconds and always ends in 000. This bug is in OpenJDK 8 and 9, and fixed in 11.
      * </p>
      *
      * @param file the file to query.
@@ -877,9 +955,9 @@ public static FileTime getLastModifiedFileTime(final File file) throws IOExcepti
     /**
      * Gets the file's last modified time or null if the file does not exist.
      *
-     * @param path the file to query.
+     * @param path            the file to query.
      * @param defaultIfAbsent Returns this file time of the file does not exist, may be null.
-     * @param options options indicating how symbolic links are handled.
+     * @param options         options indicating how symbolic links are handled.
      * @return the file's last modified time.
      * @throws IOException Thrown if an I/O error occurs.
      * @since 2.12.0
@@ -891,7 +969,7 @@ public static FileTime getLastModifiedFileTime(final Path path, final FileTime d
     /**
      * Gets the file's last modified time or null if the file does not exist.
      *
-     * @param path the file to query.
+     * @param path    the file to query.
      * @param options options indicating how symbolic links are handled.
      * @return the file's last modified time.
      * @throws IOException Thrown if an I/O error occurs.
@@ -918,9 +996,8 @@ public static FileTime getLastModifiedFileTime(final URI uri) throws IOException
      *
      * @param url the file to query.
      * @return the file's last modified time.
-     * @throws IOException Thrown if an I/O error occurs.
-     * @throws URISyntaxException if the URL is not formatted strictly according to RFC2396 and cannot be converted to a
-     *         URI.
+     * @throws IOException        Thrown if an I/O error occurs.
+     * @throws URISyntaxException if the URL is not formatted strictly according to RFC2396 and cannot be converted to a URI.
      * @since 2.12.0
      */
     public static FileTime getLastModifiedFileTime(final URL url) throws IOException, URISyntaxException {
@@ -938,7 +1015,7 @@ private static Path getParent(final Path path) {
     /**
      * Shorthand for {@code Files.getFileAttributeView(path, PosixFileAttributeView.class)}.
      *
-     * @param path the path to the file.
+     * @param path    the path to the file.
      * @param options how to handle symbolic links.
      * @return a PosixFileAttributeView, or {@code null} if the attribute view type is not available.
      * @since 2.12.0
@@ -961,12 +1038,12 @@ public static Path getTempDirectory() {
      * Tests whether the given {@link Path} is a directory or not. Implemented as a null-safe delegate to
      * {@code Files.isDirectory(Path path, LinkOption... options)}.
      *
-     * @param path the path to the file.
+     * @param path    the path to the file.
      * @param options options indicating how to handle symbolic links
-     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a
-     *         directory, or it cannot be determined if the file is a directory or not.
-     * @throws SecurityException In the case of the default provider, and a security manager is installed, the
-     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.
+     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a directory, or it cannot be
+     *         determined if the file is a directory or not.
+     * @throws SecurityException In the case of the default provider, and a security manager is installed, the {@link SecurityManager#checkRead(String)
+     *                           checkRead} method is invoked to check read access to the directory.
      * @since 2.9.0
      */
     public static boolean isDirectory(final Path path, final LinkOption... options) {
@@ -989,11 +1066,10 @@ public static boolean isEmpty(final Path path) throws IOException {
      *
      * @param directory the directory to query.
      * @return whether the directory is empty.
-     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional
-     *         specific exception)</i>.
-     * @throws IOException if an I/O error occurs.
-     * @throws SecurityException In the case of the default provider, and a security manager is installed, the
-     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.
+     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <em>(optional specific exception)</em>.
+     * @throws IOException           if an I/O error occurs.
+     * @throws SecurityException     In the case of the default provider, and a security manager is installed, the {@link SecurityManager#checkRead(String)
+     *                               checkRead} method is invoked to check read access to the directory.
      */
     public static boolean isEmptyDirectory(final Path directory) throws IOException {
         try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {
@@ -1006,9 +1082,9 @@ public static boolean isEmptyDirectory(final Path directory) throws IOException
      *
      * @param file the file to query.
      * @return whether the file is empty.
-     * @throws IOException if an I/O error occurs.
-     * @throws SecurityException In the case of the default provider, and a security manager is installed, its
-     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.
+     * @throws IOException       if an I/O error occurs.
+     * @throws SecurityException In the case of the default provider, and a security manager is installed, its {@link SecurityManager#checkRead(String)
+     *                           checkRead} method denies read access to the file.
      */
     public static boolean isEmptyFile(final Path file) throws IOException {
         return Files.size(file) <= 0;
@@ -1017,11 +1093,11 @@ public static boolean isEmptyFile(final Path file) throws IOException {
     /**
      * Tests if the given {@link Path} is newer than the given time reference.
      *
-     * @param file the {@link Path} to test.
-     * @param czdt the time reference.
+     * @param file    the {@link Path} to test.
+     * @param czdt    the time reference.
      * @param options options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified after the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.12.0
      */
@@ -1033,11 +1109,11 @@ public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt
     /**
      * Tests if the given {@link Path} is newer than the given time reference.
      *
-     * @param file the {@link Path} to test.
+     * @param file     the {@link Path} to test.
      * @param fileTime the time reference.
-     * @param options options indicating how to handle symbolic links.
+     * @param options  options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified after the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.12.0
      */
@@ -1051,11 +1127,11 @@ public static boolean isNewer(final Path file, final FileTime fileTime, final Li
     /**
      * Tests if the given {@link Path} is newer than the given time reference.
      *
-     * @param file the {@link Path} to test.
+     * @param file    the {@link Path} to test.
      * @param instant the time reference.
      * @param options options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified after the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.12.0
      */
@@ -1066,11 +1142,11 @@ public static boolean isNewer(final Path file, final Instant instant, final Link
     /**
      * Tests if the given {@link Path} is newer than the given time reference.
      *
-     * @param file the {@link Path} to test.
+     * @param file       the {@link Path} to test.
      * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)
-     * @param options options indicating how to handle symbolic links.
+     * @param options    options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified after the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.9.0
      */
@@ -1081,7 +1157,7 @@ public static boolean isNewer(final Path file, final long timeMillis, final Link
     /**
      * Tests if the given {@link Path} is newer than the reference {@link Path}.
      *
-     * @param file the {@link File} to test.
+     * @param file      the {@link File} to test.
      * @param reference the {@link File} of which the modification date is used.
      * @return true if the {@link File} exists and has been modified more recently than the reference {@link File}.
      * @throws IOException if an I/O error occurs.
@@ -1094,11 +1170,11 @@ public static boolean isNewer(final Path file, final Path reference) throws IOEx
     /**
      * Tests if the given {@link Path} is older than the given time reference.
      *
-     * @param file the {@link Path} to test.
+     * @param file     the {@link Path} to test.
      * @param fileTime the time reference.
-     * @param options options indicating how to handle symbolic links.
+     * @param options  options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified before the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.12.0
      */
@@ -1112,11 +1188,11 @@ public static boolean isOlder(final Path file, final FileTime fileTime, final Li
     /**
      * Tests if the given {@link Path} is older than the given time reference.
      *
-     * @param file the {@link Path} to test.
+     * @param file    the {@link Path} to test.
      * @param instant the time reference.
      * @param options options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified before the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.12.0
      */
@@ -1127,11 +1203,11 @@ public static boolean isOlder(final Path file, final Instant instant, final Link
     /**
      * Tests if the given {@link Path} is older than the given time reference.
      *
-     * @param file the {@link Path} to test.
+     * @param file       the {@link Path} to test.
      * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)
-     * @param options options indicating how to handle symbolic links.
+     * @param options    options indicating how to handle symbolic links.
      * @return true if the {@link Path} exists and has been modified before the given time reference.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @throws NullPointerException if the file is {@code null}.
      * @since 2.12.0
      */
@@ -1142,7 +1218,7 @@ public static boolean isOlder(final Path file, final long timeMillis, final Link
     /**
      * Tests if the given {@link Path} is older than the reference {@link Path}.
      *
-     * @param file the {@link File} to test.
+     * @param file      the {@link File} to test.
      * @param reference the {@link File} of which the modification date is used.
      * @return true if the {@link File} exists and has been modified before than the reference {@link File}.
      * @throws IOException if an I/O error occurs.
@@ -1155,7 +1231,7 @@ public static boolean isOlder(final Path file, final Path reference) throws IOEx
     /**
      * Tests whether the given path is on a POSIX file system.
      *
-     * @param test The Path to test.
+     * @param test    The Path to test.
      * @param options options indicating how to handle symbolic links.
      * @return true if test is on a POSIX file system.
      * @since 2.12.0
@@ -1168,12 +1244,12 @@ public static boolean isPosix(final Path test, final LinkOption... options) {
      * Tests whether the given {@link Path} is a regular file or not. Implemented as a null-safe delegate to
      * {@code Files.isRegularFile(Path path, LinkOption... options)}.
      *
-     * @param path the path to the file.
+     * @param path    the path to the file.
      * @param options options indicating how to handle symbolic links.
-     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is
-     *         not a directory, or it cannot be determined if the file is a regular file or not.
-     * @throws SecurityException In the case of the default provider, and a security manager is installed, the
-     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.
+     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is not a directory, or it cannot be
+     *         determined if the file is a regular file or not.
+     * @throws SecurityException In the case of the default provider, and a security manager is installed, the {@link SecurityManager#checkRead(String)
+     *                           checkRead} method is invoked to check read access to the directory.
      * @since 2.9.0
      */
     public static boolean isRegularFile(final Path path, final LinkOption... options) {
@@ -1197,10 +1273,9 @@ public static DirectoryStream<Path> newDirectoryStream(final Path dir, final Pat
     }
 
     /**
-     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes
-     * to the file.
+     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes to the file.
      *
-     * @param path the Path.
+     * @param path   the Path.
      * @param append Whether or not to append.
      * @return a new OutputStream.
      * @throws IOException if an I/O error occurs.
@@ -1249,9 +1324,9 @@ private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {
     /**
      * Reads the BasicFileAttributes from the given path. Returns null if the attributes can't be read.
      *
-     * @param <A> The {@link BasicFileAttributes} type
-     * @param path The Path to test.
-     * @param type the {@link Class} of the file attributes required to read.
+     * @param <A>     The {@link BasicFileAttributes} type
+     * @param path    The Path to test.
+     * @param type    the {@link Class} of the file attributes required to read.
      * @param options options indicating how to handle symbolic links.
      * @return the file attributes or null if the attributes can't be read.
      * @see Files#readAttributes(Path, Class, LinkOption...)
@@ -1279,10 +1354,9 @@ public static BasicFileAttributes readBasicFileAttributes(final Path path) throw
     }
 
     /**
-     * Reads the BasicFileAttributes from the given path. Returns null if the attributes
-     * can't be read.
+     * Reads the BasicFileAttributes from the given path. Returns null if the attributes can't be read.
      *
-     * @param path the path to read.
+     * @param path    the path to read.
      * @param options options indicating how to handle symbolic links.
      * @return the path attributes.
      * @since 2.12.0
@@ -1292,8 +1366,7 @@ public static BasicFileAttributes readBasicFileAttributes(final Path path, final
     }
 
     /**
-     * Reads the BasicFileAttributes from the given path. Returns null if the attributes
-     * can't be read.
+     * Reads the BasicFileAttributes from the given path. Returns null if the attributes can't be read.
      *
      * @param path the path to read.
      * @return the path attributes.
@@ -1306,10 +1379,9 @@ public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path pa
     }
 
     /**
-     * Reads the DosFileAttributes from the given path. Returns null if the attributes
-     * can't be read.
+     * Reads the DosFileAttributes from the given path. Returns null if the attributes can't be read.
      *
-     * @param path the path to read.
+     * @param path    the path to read.
      * @param options options indicating how to handle symbolic links.
      * @return the path attributes.
      * @since 2.12.0
@@ -1323,10 +1395,9 @@ private static Path readIfSymbolicLink(final Path path) throws IOException {
     }
 
     /**
-     * Reads the PosixFileAttributes or DosFileAttributes from the given path. Returns null if the attributes
-     * can't be read.
+     * Reads the PosixFileAttributes or DosFileAttributes from the given path. Returns null if the attributes can't be read.
      *
-     * @param path The Path to read.
+     * @param path    The Path to read.
      * @param options options indicating how to handle symbolic links.
      * @return the file attributes.
      * @since 2.12.0
@@ -1337,10 +1408,9 @@ public static BasicFileAttributes readOsFileAttributes(final Path path, final Li
     }
 
     /**
-     * Reads the PosixFileAttributes from the given path. Returns null instead of throwing
-     * {@link UnsupportedOperationException}.
+     * Reads the PosixFileAttributes from the given path. Returns null instead of throwing {@link UnsupportedOperationException}.
      *
-     * @param path The Path to read.
+     * @param path    The Path to read.
      * @param options options indicating how to handle symbolic links.
      * @return the file attributes.
      * @since 2.12.0
@@ -1350,13 +1420,14 @@ public static PosixFileAttributes readPosixFileAttributes(final Path path, final
     }
 
     /**
-     * Reads the given path as a String.
+     * Reads the file contents at the given path as a String using the Charset.
      *
-     * @param path The source path.
+     * @param path    The source path.
      * @param charset How to convert bytes to a String, null uses the default Charset.
-     * @return a new String.
+     * @return the file contents as a new String.
      * @throws IOException if an I/O error occurs reading from the stream.
      * @see Files#readAllBytes(Path)
+     * @see Charsets#toCharset(Charset)
      * @since 2.12.0
      */
     public static String readString(final Path path, final Charset charset) throws IOException {
@@ -1367,8 +1438,8 @@ public static String readString(final Path path, final Charset charset) throws I
      * Relativizes all files in the given {@code collection} against a {@code parent}.
      *
      * @param collection The collection of paths to relativize.
-     * @param parent relativizes against this parent path.
-     * @param sort Whether to sort the result.
+     * @param parent     relativizes against this parent path.
+     * @param sort       Whether to sort the result.
      * @param comparator How to sort.
      * @return A collection of relativized paths, optionally sorted.
      */
@@ -1383,11 +1454,11 @@ static List<Path> relativize(final Collection<Path> collection, final Path paren
     /**
      * Requires that the given {@link File} exists and throws an {@link IllegalArgumentException} if it doesn't.
      *
-     * @param file The {@link File} to check.
+     * @param file          The {@link File} to check.
      * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.
-     * @param options options indicating how to handle symbolic links.
+     * @param options       options indicating how to handle symbolic links.
      * @return the given file.
-     * @throws NullPointerException if the given {@link File} is {@code null}.
+     * @throws NullPointerException     if the given {@link File} is {@code null}.
      * @throws IllegalArgumentException if the given {@link File} does not exist.
      */
     private static Path requireExists(final Path file, final String fileParamName, final LinkOption... options) {
@@ -1414,7 +1485,7 @@ private static boolean setDosReadOnly(final Path path, final boolean readOnly, f
      * @param targetFile The target path to set.
      * @throws NullPointerException if sourceFile is {@code null}.
      * @throws NullPointerException if targetFile is {@code null}.
-     * @throws IOException if setting the last-modified time failed.
+     * @throws IOException          if setting the last-modified time failed.
      * @since 2.12.0
      */
     public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {
@@ -1425,14 +1496,14 @@ public static void setLastModifiedTime(final Path sourceFile, final Path targetF
     /**
      * To delete a file in POSIX, you need Write and Execute permissions on its parent directory.
      *
-     * @param parent The parent path for a file element to delete which needs RW permissions.
+     * @param parent               The parent path for a file element to delete which needs RW permissions.
      * @param enableDeleteChildren true to set permissions to delete.
-     * @param linkOptions options indicating how handle symbolic links.
+     * @param linkOptions          options indicating how handle symbolic links.
      * @return true if the operation was attempted and succeeded, false if parent is null.
      * @throws IOException if an I/O error occurs.
      */
     private static boolean setPosixDeletePermissions(final Path parent, final boolean enableDeleteChildren, final LinkOption... linkOptions)
-        throws IOException {
+            throws IOException {
         // To delete a file in POSIX, you need write and execute permissions on its parent directory.
         // @formatter:off
         return setPosixPermissions(parent, enableDeleteChildren, Arrays.asList(
@@ -1448,24 +1519,30 @@ private static boolean setPosixDeletePermissions(final Path parent, final boolea
 
     /**
      * Low-level POSIX permission operation to set permissions.
+     * <p>
+     * If the permissions to update are already set, then make no additional calls.
+     * </p>
      *
-     * @param path Set this path's permissions.
-     * @param addPermissions true to add, false to remove.
+     * @param path              Set this path's permissions.
+     * @param addPermissions    true to add, false to remove.
      * @param updatePermissions the List of PosixFilePermission to add or remove.
-     * @param linkOptions options indicating how handle symbolic links.
+     * @param linkOptions       options indicating how handle symbolic links.
      * @return true if the operation was attempted and succeeded, false if parent is null.
      * @throws IOException if an I/O error occurs.
      */
     private static boolean setPosixPermissions(final Path path, final boolean addPermissions, final List<PosixFilePermission> updatePermissions,
-        final LinkOption... linkOptions) throws IOException {
+            final LinkOption... linkOptions) throws IOException {
         if (path != null) {
             final Set<PosixFilePermission> permissions = Files.getPosixFilePermissions(path, linkOptions);
+            final Set<PosixFilePermission> newPermissions = new HashSet<>(permissions);
             if (addPermissions) {
-                permissions.addAll(updatePermissions);
+                newPermissions.addAll(updatePermissions);
             } else {
-                permissions.removeAll(updatePermissions);
+                newPermissions.removeAll(updatePermissions);
+            }
+            if (!newPermissions.equals(permissions)) {
+                Files.setPosixFilePermissions(path, newPermissions);
             }
-            Files.setPosixFilePermissions(path, permissions);
             return true;
         }
         return false;
@@ -1504,8 +1581,8 @@ private static void setPosixReadOnlyFile(final Path path, final boolean readOnly
      * This behavior is OS dependent.
      * </p>
      *
-     * @param path The path to set.
-     * @param readOnly true for read-only, false for not read-only.
+     * @param path        The path to set.
+     * @param readOnly    true for read-only, false for not read-only.
      * @param linkOptions options indicating how to handle symbolic links.
      * @return The given path.
      * @throws IOException if an I/O error occurs.
@@ -1522,7 +1599,7 @@ public static Path setReadOnly(final Path path, final boolean readOnly, final Li
         }
         final Path parent = getParent(path);
         if (!isPosix(parent, linkOptions)) { // Test parent because we may not the permissions to test the file.
-            throw new IOException(String.format("DOS or POSIX file operations not available for '%s' %s", path, Arrays.toString(linkOptions)));
+            throw new IOException(String.format("DOS or POSIX file operations not available for '%s', linkOptions %s", path, Arrays.toString(linkOptions)));
         }
         // POSIX
         if (readOnly) {
@@ -1539,18 +1616,18 @@ public static Path setReadOnly(final Path path, final boolean readOnly, final Li
     }
 
     /**
-     * Returns the size of the given file or directory. If the provided {@link Path} is a regular file, then the file's size
-     * is returned. If the argument is a directory, then the size of the directory is calculated recursively.
+     * Returns the size of the given file or directory. If the provided {@link Path} is a regular file, then the file's size is returned. If the argument is a
+     * directory, then the size of the directory is calculated recursively.
      * <p>
-     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See
-     * {@link #sizeOfAsBigInteger(Path)} for an alternative method that does not overflow.
+     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See {@link #sizeOfAsBigInteger(Path)} for an alternative
+     * method that does not overflow.
      * </p>
      *
      * @param path the regular file or directory to return the size of, must not be {@code null}.
      * @return the length of the file, or recursive size of the directory, in bytes.
-     * @throws NullPointerException if the file is {@code null}.
+     * @throws NullPointerException     if the file is {@code null}.
      * @throws IllegalArgumentException if the file does not exist.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException              if an I/O error occurs.
      * @since 2.12.0
      */
     public static long sizeOf(final Path path) throws IOException {
@@ -1559,14 +1636,14 @@ public static long sizeOf(final Path path) throws IOException {
     }
 
     /**
-     * Returns the size of the given file or directory. If the provided {@link Path} is a regular file, then the file's size
-     * is returned. If the argument is a directory, then the size of the directory is calculated recursively.
+     * Returns the size of the given file or directory. If the provided {@link Path} is a regular file, then the file's size is returned. If the argument is a
+     * directory, then the size of the directory is calculated recursively.
      *
      * @param path the regular file or directory to return the size of (must not be {@code null}).
      * @return the length of the file, or recursive size of the directory, provided (in bytes).
-     * @throws NullPointerException if the file is {@code null}.
+     * @throws NullPointerException     if the file is {@code null}.
      * @throws IllegalArgumentException if the file does not exist.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException              if an I/O error occurs.
      * @since 2.12.0
      */
     public static BigInteger sizeOfAsBigInteger(final Path path) throws IOException {
@@ -1577,15 +1654,14 @@ public static BigInteger sizeOfAsBigInteger(final Path path) throws IOException
     /**
      * Counts the size of a directory recursively (sum of the size of all files).
      * <p>
-     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See
-     * {@link #sizeOfDirectoryAsBigInteger(Path)} for an alternative method that does not overflow.
+     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See {@link #sizeOfDirectoryAsBigInteger(Path)} for an
+     * alternative method that does not overflow.
      * </p>
      *
      * @param directory directory to inspect, must not be {@code null}.
-     * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total is
-     *         greater than {@link Long#MAX_VALUE}.
+     * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total is greater than {@link Long#MAX_VALUE}.
      * @throws NullPointerException if the directory is {@code null}.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @since 2.12.0
      */
     public static long sizeOfDirectory(final Path directory) throws IOException {
@@ -1598,7 +1674,7 @@ public static long sizeOfDirectory(final Path directory) throws IOException {
      * @param directory directory to inspect, must not be {@code null}.
      * @return size of directory in bytes, 0 if directory is security restricted.
      * @throws NullPointerException if the directory is {@code null}.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException          if an I/O error occurs.
      * @since 2.12.0
      */
     public static BigInteger sizeOfDirectoryAsBigInteger(final Path directory) throws IOException {
@@ -1616,13 +1692,13 @@ static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVi
     }
 
     /**
-     * Implements behavior similar to the Unix "touch" utility. Creates a new file with size 0, or, if the file exists, just
-     * updates the file's modified time. this method creates parent directories if they do not exist.
+     * Implements behavior similar to the UNIX "touch" utility. Creates a new file with size 0, or, if the file exists, just updates the file's modified time.
+     * this method creates parent directories if they do not exist.
      *
      * @param file the file to touch.
      * @return The given file.
      * @throws NullPointerException if the parameter is {@code null}.
-     * @throws IOException if setting the last-modified time failed or an I/O problem occurs.\
+     * @throws IOException          if setting the last-modified time failed or an I/O problem occurs.\
      * @since 2.12.0
      */
     public static Path touch(final Path file) throws IOException {
@@ -1641,13 +1717,13 @@ public static Path touch(final Path file) throws IOException {
      *
      * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.
      *
-     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.
+     * @param visitor   See {@link Files#walkFileTree(Path,FileVisitor)}.
      * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.
-     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.
+     * @param <T>       See {@link Files#walkFileTree(Path,FileVisitor)}.
      * @return the given visitor.
      *
-     * @throws NoSuchFileException if the directory does not exist.
-     * @throws IOException if an I/O error is thrown by a visitor method.
+     * @throws NoSuchFileException  if the directory does not exist.
+     * @throws IOException          if an I/O error is thrown by a visitor method.
      * @throws NullPointerException if the directory is {@code null}.
      */
     public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {
@@ -1660,17 +1736,17 @@ public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visi
      *
      * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.
      *
-     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
-     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+     * @param start    See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+     * @param options  See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
      * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
-     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
-     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+     * @param visitor  See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
+     * @param <T>      See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.
      * @return the given visitor.
      *
      * @throws IOException if an I/O error is thrown by a visitor method.
      */
     public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,
-        final int maxDepth) throws IOException {
+            final int maxDepth) throws IOException {
         Files.walkFileTree(start, options, maxDepth, visitor);
         return visitor;
     }
@@ -1681,9 +1757,9 @@ public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visi
      * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.
      *
      * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.
-     * @param first See {@link Paths#get(String,String[])}.
-     * @param more See {@link Paths#get(String,String[])}.
-     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.
+     * @param first   See {@link Paths#get(String,String[])}.
+     * @param more    See {@link Paths#get(String,String[])}.
+     * @param <T>     See {@link Files#walkFileTree(Path,FileVisitor)}.
      * @return the given visitor.
      *
      * @throws IOException if an I/O error is thrown by a visitor method.
@@ -1698,8 +1774,8 @@ public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visi
      * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.
      *
      * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.
-     * @param uri See {@link Paths#get(URI)}.
-     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.
+     * @param uri     See {@link Paths#get(URI)}.
+     * @param <T>     See {@link Files#walkFileTree(Path,FileVisitor)}.
      * @return the given visitor.
      *
      * @throws IOException if an I/O error is thrown by a visitor method.
@@ -1709,13 +1785,12 @@ public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visi
     }
 
     /**
-     * Waits for the file system to propagate a file creation, with a timeout.
+     * Waits for the file system to detect a file's presence, with a timeout.
      * <p>
-     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time
-     * given.
+     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time given.
      * </p>
      *
-     * @param file the file to check, must not be {@code null}.
+     * @param file    the file to check, must not be {@code null}.
      * @param timeout the maximum time to wait.
      * @param options options indicating how to handle symbolic links.
      * @return true if file exists.
@@ -1757,23 +1832,24 @@ public static boolean waitFor(final Path file, final Duration timeout, final Lin
      * closed stream causes a {@link IllegalStateException}.
      * </p>
      *
-     * @param start the start path
-     * @param pathFilter the path filter
-     * @param maxDepth the maximum depth of directories to walk.
+     * @param start          the start path
+     * @param pathFilter     the path filter
+     * @param maxDepth       the maximum depth of directories to walk.
      * @param readAttributes whether to call the filters with file attributes (false passes null).
-     * @param options the options to configure the walk.
+     * @param options        the options to configure the walk.
      * @return a filtered stream of paths.
      * @throws IOException if an I/O error is thrown when accessing the starting file.
      * @since 2.9.0
      */
+    @SuppressWarnings("resource") // Caller closes
     public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,
-        final FileVisitOption... options) throws IOException {
+            final FileVisitOption... options) throws IOException {
         return Files.walk(start, maxDepth, options)
-            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);
+                .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);
     }
 
     private static <R> R withPosixFileAttributes(final Path path, final LinkOption[] linkOptions, final boolean overrideReadOnly,
-        final IOFunction<PosixFileAttributes, R> function) throws IOException {
+            final IOFunction<PosixFileAttributes, R> function) throws IOException {
         final PosixFileAttributes posixFileAttributes = overrideReadOnly ? readPosixFileAttributes(path, linkOptions) : null;
         try {
             return function.apply(posixFileAttributes);
@@ -1787,17 +1863,17 @@ private static <R> R withPosixFileAttributes(final Path path, final LinkOption[]
     /**
      * Writes the given character sequence to a file at the given path.
      *
-     * @param path The target file.
+     * @param path         The target file.
      * @param charSequence The character sequence text.
-     * @param charset The Charset to encode the text.
-     * @param openOptions options How to open the file.
+     * @param charset      The Charset to encode the text.
+     * @param openOptions  options How to open the file.
      * @return The given path.
-     * @throws IOException if an I/O error occurs writing to or creating the file.
+     * @throws IOException          if an I/O error occurs writing to or creating the file.
      * @throws NullPointerException if either {@code path} or {@code charSequence} is {@code null}.
      * @since 2.12.0
      */
     public static Path writeString(final Path path, final CharSequence charSequence, final Charset charset, final OpenOption... openOptions)
-        throws IOException {
+            throws IOException {
         // Check the text is not null before opening file.
         Objects.requireNonNull(path, "path");
         Objects.requireNonNull(charSequence, "charSequence");
diff --git a/src/main/java/org/apache/commons/io/file/StandardDeleteOption.java b/src/main/java/org/apache/commons/io/file/StandardDeleteOption.java
index c5c2af96..0e1e3db9 100644
--- a/src/main/java/org/apache/commons/io/file/StandardDeleteOption.java
+++ b/src/main/java/org/apache/commons/io/file/StandardDeleteOption.java
@@ -45,7 +45,7 @@ public static boolean overrideReadOnly(final DeleteOption[] options) {
         if (IOUtils.length(options) == 0) {
             return false;
         }
-        return Stream.of(options).anyMatch(e -> StandardDeleteOption.OVERRIDE_READ_ONLY == e);
+        return Stream.of(options).anyMatch(e -> OVERRIDE_READ_ONLY == e);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/file/attribute/FileTimes.java b/src/main/java/org/apache/commons/io/file/attribute/FileTimes.java
index 2ea372f9..e899b65d 100644
--- a/src/main/java/org/apache/commons/io/file/attribute/FileTimes.java
+++ b/src/main/java/org/apache/commons/io/file/attribute/FileTimes.java
@@ -40,12 +40,12 @@ public final class FileTimes {
     public static final FileTime EPOCH = FileTime.from(Instant.EPOCH);
 
     /**
-     * The offset of Windows time 0 to Unix epoch in 100-nanosecond intervals.
+     * The offset of Windows time 0 to UNIX epoch in 100-nanosecond intervals.
      *
      * <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724290%28v=vs.85%29.aspx">Windows File Times</a>
      * <p>
      * A file time is a 64-bit value that represents the number of 100-nanosecond intervals that have elapsed since 12:00
-     * A.M. January 1, 1601 Coordinated Universal Time (UTC). This is the offset of Windows time 0 to Unix epoch in
+     * A.M. January 1, 1601 Coordinated Universal Time (UTC). This is the offset of Windows time 0 to UNIX epoch in
      * 100-nanosecond intervals.
      * </p>
      */
@@ -61,6 +61,43 @@ public final class FileTimes {
      */
     static final long HUNDRED_NANOS_PER_MILLISECOND = TimeUnit.MILLISECONDS.toNanos(1) / 100;
 
+    /**
+     * Converts standard UNIX time (in seconds, UTC/GMT) to {@link FileTime}.
+     *
+     * @param time UNIX timestamp (seconds).
+     * @return the corresponding FileTime.
+     * @since 2.16.0
+     */
+    public static FileTime fromUnixTime(final long time) {
+        return FileTime.from(time, TimeUnit.SECONDS);
+    }
+
+    /**
+     * Tests whether a FileTime can be safely represented in the standard UNIX time.
+     * <p>
+     * If the FileTime is null, this method returns true.
+     * </p>
+     *
+     * @param time the FileTime to evaluate, can be null.
+     * @return true if the time exceeds the minimum or maximum UNIX time, false otherwise.
+     * @since 2.16.0
+     */
+    public static boolean isUnixTime(final FileTime time) {
+        return isUnixTime(toUnixTime(time));
+    }
+
+    /**
+     * Tests whether a given number of seconds (since Epoch) can be safely represented in the standard UNIX time.
+     *
+     * @param seconds the number of seconds (since Epoch) to evaluate.
+     * @return true if the time can be represented in the standard UNIX time, false otherwise.
+     * @since 2.16.0
+     */
+    public static boolean isUnixTime(final long seconds) {
+        return Integer.MIN_VALUE <= seconds && seconds <= Integer.MAX_VALUE;
+    }
+
+
     /**
      * Subtracts milliseconds from a source FileTime.
      *
@@ -220,6 +257,33 @@ public static long toNtfsTime(final FileTime fileTime) {
         return Math.subtractExact(javaHundredNanos, WINDOWS_EPOCH_OFFSET);
     }
 
+    /**
+     * Converts Java time (milliseconds since Epoch) to NTFS time.
+     *
+     * @param javaTime the Java time
+     * @return the NTFS time
+     * @since 2.16.0
+     */
+    public static long toNtfsTime(final long javaTime) {
+        final long javaHundredNanos = javaTime * HUNDRED_NANOS_PER_MILLISECOND;
+        return Math.subtractExact(javaHundredNanos, WINDOWS_EPOCH_OFFSET);
+    }
+
+    /**
+     * Converts {@link FileTime} to standard UNIX time in seconds.
+     * <p>
+     * The returned seconds value may lie out of bounds of UNIX time. Check with {@link FileTimes#isUnixTime(long)}.
+     * </p>
+     *
+     * @param fileTime the original FileTime.
+     * @return the UNIX timestamp or 0 if the input is null.
+     * @see #isUnixTime(long)
+     * @since 2.16.0
+     */
+    public static long toUnixTime(final FileTime fileTime) {
+        return fileTime != null ? fileTime.to(TimeUnit.SECONDS) : 0;
+    }
+
     private FileTimes() {
         // No instances.
     }
diff --git a/src/main/java/org/apache/commons/io/file/spi/FileSystemProviders.java b/src/main/java/org/apache/commons/io/file/spi/FileSystemProviders.java
index a64b4e76..a5d3241f 100644
--- a/src/main/java/org/apache/commons/io/file/spi/FileSystemProviders.java
+++ b/src/main/java/org/apache/commons/io/file/spi/FileSystemProviders.java
@@ -33,6 +33,7 @@
  */
 public class FileSystemProviders { // NOPMD Class will be final in 3.0.
 
+    private static final String SCHEME_FILE = "file";
     private static final FileSystemProviders INSTALLED = new FileSystemProviders(FileSystemProvider.installedProviders());
 
     /**
@@ -75,7 +76,7 @@ private FileSystemProviders(final List<FileSystemProvider> providers) {
     public FileSystemProvider getFileSystemProvider(final String scheme) {
         Objects.requireNonNull(scheme, "scheme");
         // Check default provider first to avoid loading of installed providers.
-        if (scheme.equalsIgnoreCase("file")) {
+        if (scheme.equalsIgnoreCase(SCHEME_FILE)) {
             return FileSystems.getDefault().provider();
         }
         // Find provider.
diff --git a/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
index 4bc6dcf4..e1359c96 100644
--- a/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
@@ -120,7 +120,7 @@ void append(final Object[] array, final StringBuilder buffer) {
     FileVisitResult get(final IOSupplier<FileVisitResult> supplier) {
         try {
             return supplier.get();
-        } catch (IOException e) {
+        } catch (final IOException e) {
             return handle(e);
         }
     }
diff --git a/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java
index 095571c9..8601cbaa 100644
--- a/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java
@@ -50,15 +50,15 @@
  * Instant cutoff = Instant.now().minus(Duration.ofDays(1));
  * AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directoryectory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -175,8 +175,8 @@ public AgeFileFilter(final long cutoffMillis, final boolean acceptOlder) {
     /**
      * Checks to see if the last modification of the file matches cutoff favorably.
      * <p>
-     * If last modification time equals cutoff and newer files are required, file <b>IS NOT</b> selected. If last
-     * modification time equals cutoff and older files are required, file <b>IS</b> selected.
+     * If last modification time equals cutoff and newer files are required, file <strong>IS NOT</strong> selected. If last
+     * modification time equals cutoff and older files are required, file <strong>IS</strong> selected.
      * </p>
      *
      * @param file the File to check
@@ -190,11 +190,12 @@ public boolean accept(final File file) {
     /**
      * Checks to see if the last modification of the file matches cutoff favorably.
      * <p>
-     * If last modification time equals cutoff and newer files are required, file <b>IS NOT</b> selected. If last
-     * modification time equals cutoff and older files are required, file <b>IS</b> selected.
+     * If last modification time equals cutoff and newer files are required, file <strong>IS NOT</strong> selected. If last
+     * modification time equals cutoff and older files are required, file <strong>IS</strong> selected.
      * </p>
-     * @param file the File to check
      *
+     * @param file the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name matches
      * @since 2.9.0
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/AndFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/AndFileFilter.java
index 312a7dab..62a3e0f1 100644
--- a/src/main/java/org/apache/commons/io/filefilter/AndFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/AndFileFilter.java
@@ -17,6 +17,7 @@
 package org.apache.commons.io.filefilter;
 
 import java.io.File;
+import java.io.FileFilter;
 import java.io.Serializable;
 import java.nio.file.FileVisitResult;
 import java.nio.file.Path;
@@ -28,7 +29,7 @@
 import java.util.stream.Stream;
 
 /**
- * A {@link java.io.FileFilter} providing conditional AND logic across a list of
+ * A {@link FileFilter} providing conditional AND logic across a list of
  * file filters. This filter returns {@code true} if all filters in the
  * list return {@code true}. Otherwise, it returns {@code false}.
  * Checking of the file filter list stops when the first filter returns
@@ -41,9 +42,7 @@
  * @since 1.0
  * @see FileFilterUtils#and(IOFileFilter...)
  */
-public class AndFileFilter
-        extends AbstractFileFilter
-        implements ConditionalFileFilter, Serializable {
+public class AndFileFilter extends AbstractFileFilter implements ConditionalFileFilter, Serializable {
 
     private static final long serialVersionUID = 7215974688563965257L;
 
@@ -79,8 +78,8 @@ private AndFileFilter(final int initialCapacity) {
 
     /**
      * Constructs a new instance for the give filters.
-     * @param fileFilters filters to OR.
      *
+     * @param fileFilters filters to OR.
      * @since 2.9.0
      */
     public AndFileFilter(final IOFileFilter... fileFilters) {
@@ -143,7 +142,7 @@ public FileVisitResult accept(final Path file, final BasicFileAttributes attribu
      */
     @Override
     public void addFileFilter(final IOFileFilter fileFilter) {
-        this.fileFilters.add(Objects.requireNonNull(fileFilter, "fileFilter"));
+        fileFilters.add(Objects.requireNonNull(fileFilter, "fileFilter"));
     }
 
     /**
@@ -161,11 +160,11 @@ public void addFileFilter(final IOFileFilter... fileFilters) {
      */
     @Override
     public List<IOFileFilter> getFileFilters() {
-        return Collections.unmodifiableList(this.fileFilters);
+        return Collections.unmodifiableList(fileFilters);
     }
 
     private boolean isEmpty() {
-        return this.fileFilters.isEmpty();
+        return fileFilters.isEmpty();
     }
 
     /**
@@ -173,7 +172,7 @@ private boolean isEmpty() {
      */
     @Override
     public boolean removeFileFilter(final IOFileFilter ioFileFilter) {
-        return this.fileFilters.remove(ioFileFilter);
+        return fileFilters.remove(ioFileFilter);
     }
 
     /**
@@ -186,7 +185,7 @@ public void setFileFilters(final List<IOFileFilter> fileFilters) {
     }
 
     /**
-     * Provide a String representation of this file filter.
+     * Builds a String representation of this file filter.
      *
      * @return a String representation
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java
index 9bd55e4a..cd51c5dd 100644
--- a/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java
@@ -27,7 +27,7 @@
  * This filter accepts {@link File}s that can be executed.
  * <p>
  * Example, showing how to print out a list of the
- * current directory's <i>executable</i> files:
+ * current directory's <em>executable</em> files:
  * </p>
  * <h2>Using Classic IO</h2>
  * <pre>
@@ -40,7 +40,7 @@
  *
  * <p>
  * Example, showing how to print out a list of the
- * current directory's <i>non-executable</i> files:
+ * current directory's <em>non-executable</em> files:
  * </p>
  *
  * <pre>
@@ -59,10 +59,10 @@
  */
 public class CanExecuteFileFilter extends AbstractFileFilter implements Serializable {
 
-    /** Singleton instance of <i>executable</i> filter */
+    /** Singleton instance of <em>executable</em> filter */
     public static final IOFileFilter CAN_EXECUTE = new CanExecuteFileFilter();
 
-    /** Singleton instance of not <i>executable</i> filter */
+    /** Singleton instance of not <em>executable</em> filter */
     public static final IOFileFilter CANNOT_EXECUTE = CAN_EXECUTE.negate();
 
     private static final long serialVersionUID = 3179904805251622989L;
@@ -82,19 +82,20 @@ protected CanExecuteFileFilter() {
      */
     @Override
     public boolean accept(final File file) {
-        return file.canExecute();
+        return file != null && file.canExecute();
     }
 
     /**
      * Checks to see if the file can be executed.
-     * @param file  the File to check.
      *
+     * @param file  the File to check.
+     * @param attributes the path's basic attributes (may be null).
      * @return {@code true} if the file can be executed, otherwise {@code false}.
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isExecutable(file));
+        return toFileVisitResult(file != null && Files.isExecutable(file));
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java
index a1efdcc9..7a320f52 100644
--- a/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java
@@ -26,7 +26,7 @@
 /**
  * This filter accepts {@link File}s that can be read.
  * <p>
- * Example, showing how to print out a list of the current directory's <i>readable</i> files:
+ * Example, showing how to print out a list of the current directory's <em>readable</em> files:
  * </p>
  * <h2>Using Classic IO</h2>
  * <pre>
@@ -38,7 +38,7 @@
  * </pre>
  *
  * <p>
- * Example, showing how to print out a list of the current directory's <i>un-readable</i> files:
+ * Example, showing how to print out a list of the current directory's <em>un-readable</em> files:
  *
  * <pre>
  * File dir = FileUtils.current();
@@ -49,7 +49,7 @@
  * </pre>
  *
  * <p>
- * Example, showing how to print out a list of the current directory's <i>read-only</i> files:
+ * Example, showing how to print out a list of the current directory's <em>read-only</em> files:
  *
  * <pre>
  * File dir = FileUtils.current();
@@ -67,13 +67,13 @@
  */
 public class CanReadFileFilter extends AbstractFileFilter implements Serializable {
 
-    /** Singleton instance of <i>readable</i> filter */
+    /** Singleton instance of <em>readable</em> filter */
     public static final IOFileFilter CAN_READ = new CanReadFileFilter();
 
-    /** Singleton instance of not <i>readable</i> filter */
+    /** Singleton instance of not <em>readable</em> filter */
     public static final IOFileFilter CANNOT_READ = CAN_READ.negate();
 
-    /** Singleton instance of <i>read-only</i> filter */
+    /** Singleton instance of <em>read-only</em> filter */
     public static final IOFileFilter READ_ONLY = CAN_READ.and(CanWriteFileFilter.CANNOT_WRITE);
 
     private static final long serialVersionUID = 3179904805251622989L;
@@ -92,19 +92,20 @@ protected CanReadFileFilter() {
      */
     @Override
     public boolean accept(final File file) {
-        return file.canRead();
+        return file != null && file.canRead();
     }
 
     /**
      * Checks to see if the file can be read.
-     * @param file the File to check.
      *
+     * @param file the File to check.
+     * @param attributes the path's basic attributes (may be null).
      * @return {@code true} if the file can be read, otherwise {@code false}.
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isReadable(file));
+        return toFileVisitResult(file != null && Files.isReadable(file));
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java
index 842007bf..343fd99a 100644
--- a/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java
@@ -26,7 +26,7 @@
 /**
  * This filter accepts {@link File}s that can be written to.
  * <p>
- * Example, showing how to print out a list of the current directory's <i>writable</i> files:
+ * Example, showing how to print out a list of the current directory's <em>writable</em> files:
  * </p>
  * <h2>Using Classic IO</h2>
  * <pre>
@@ -37,7 +37,7 @@
  * }
  * </pre>
  * <p>
- * Example, showing how to print out a list of the current directory's <i>un-writable</i> files:
+ * Example, showing how to print out a list of the current directory's <em>un-writable</em> files:
  * </p>
  * <pre>
  * File dir = FileUtils.current();
@@ -47,7 +47,7 @@
  * }
  * </pre>
  * <p>
- * <b>N.B.</b> For read-only files, use {@code CanReadFileFilter.READ_ONLY}.
+ * <strong>N.B.</strong> For read-only files, use {@code CanReadFileFilter.READ_ONLY}.
  * </p>
  * <h2>Deprecating Serialization</h2>
  * <p>
@@ -58,10 +58,10 @@
  */
 public class CanWriteFileFilter extends AbstractFileFilter implements Serializable {
 
-    /** Singleton instance of <i>writable</i> filter */
+    /** Singleton instance of <em>writable</em> filter */
     public static final IOFileFilter CAN_WRITE = new CanWriteFileFilter();
 
-    /** Singleton instance of not <i>writable</i> filter */
+    /** Singleton instance of not <em>writable</em> filter */
     public static final IOFileFilter CANNOT_WRITE = CAN_WRITE.negate();
 
     private static final long serialVersionUID = 5132005214688990379L;
@@ -80,19 +80,20 @@ protected CanWriteFileFilter() {
      */
     @Override
     public boolean accept(final File file) {
-        return file.canWrite();
+        return file != null && file.canWrite();
     }
 
     /**
      * Checks to see if the file can be written to.
-     * @param file the File to check
      *
+     * @param file the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return {@code true} if the file can be written to, otherwise {@code false}.
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isWritable(file));
+        return toFileVisitResult(file != null && Files.isWritable(file));
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/DelegateFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/DelegateFileFilter.java
index ee2bb02b..3f9c1c1e 100644
--- a/src/main/java/org/apache/commons/io/filefilter/DelegateFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/DelegateFileFilter.java
@@ -36,10 +36,11 @@
 public class DelegateFileFilter extends AbstractFileFilter implements Serializable {
 
     private static final long serialVersionUID = -8723373124984771318L;
+
     /** The File filter */
-    private final FileFilter fileFilter;
+    private transient final FileFilter fileFilter;
     /** The Filename filter */
-    private final FilenameFilter fileNameFilter;
+    private transient final FilenameFilter fileNameFilter;
 
     /**
      * Constructs a delegate file filter around an existing FileFilter.
@@ -99,7 +100,7 @@ public boolean accept(final File dir, final String name) {
      */
     @Override
     public String toString() {
-        final String delegate = fileFilter != null ? fileFilter.toString() : fileNameFilter.toString();
+        final String delegate = Objects.toString(fileFilter, Objects.toString(fileNameFilter, null));
         return super.toString() + "(" + delegate + ")";
     }
 
diff --git a/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
index b02d8ffe..4a8fdcf3 100644
--- a/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
@@ -44,15 +44,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(DirectoryFileFilter.INSTANCE);
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -97,19 +97,20 @@ protected DirectoryFileFilter() {
      */
     @Override
     public boolean accept(final File file) {
-        return file.isDirectory();
+        return file != null && file.isDirectory();
     }
 
     /**
      * Checks to see if the file is a directory.
-     * @param file the File to check
      *
+     * @param file the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file is a directory
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isDirectory(file));
+        return toFileVisitResult(file != null && Files.isDirectory(file));
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java
index 86686e5a..33b84343 100644
--- a/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java
@@ -60,15 +60,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(EmptyFileFilter.EMPTY);
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -82,10 +82,10 @@
  */
 public class EmptyFileFilter extends AbstractFileFilter implements Serializable {
 
-    /** Singleton instance of <i>empty</i> filter */
+    /** Singleton instance of <em>empty</em> filter */
     public static final IOFileFilter EMPTY = new EmptyFileFilter();
 
-    /** Singleton instance of <i>not-empty</i> filter */
+    /** Singleton instance of <em>not-empty</em> filter */
     public static final IOFileFilter NOT_EMPTY = EMPTY.negate();
 
     private static final long serialVersionUID = 3631422087512832211L;
@@ -100,10 +100,13 @@ protected EmptyFileFilter() {
      * Checks to see if the file is empty.
      *
      * @param file the file or directory to check
-     * @return {@code true} if the file or directory is <i>empty</i>, otherwise {@code false}.
+     * @return {@code true} if the file or directory is <em>empty</em>, otherwise {@code false}.
      */
     @Override
     public boolean accept(final File file) {
+        if (file == null) {
+            return true;
+        }
         if (file.isDirectory()) {
             final File[] files = file.listFiles();
             return IOUtils.length(files) == 0;
@@ -113,13 +116,17 @@ public boolean accept(final File file) {
 
     /**
      * Checks to see if the file is empty.
-     * @param file the file or directory to check
      *
-     * @return {@code true} if the file or directory is <i>empty</i>, otherwise {@code false}.
+     * @param file the file or directory to check
+     * @param attributes the path's basic attributes (may be null).
+     * @return {@code true} if the file or directory is <em>empty</em>, otherwise {@code false}.
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
+        if (file == null) {
+            return toFileVisitResult(true);
+        }
         return get(() -> {
             if (Files.isDirectory(file)) {
                 try (Stream<Path> stream = Files.list(file)) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/FalseFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/FalseFileFilter.java
index 9ffb2ab6..5852b37c 100644
--- a/src/main/java/org/apache/commons/io/filefilter/FalseFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/FalseFileFilter.java
@@ -84,7 +84,7 @@ public boolean accept(final File dir, final String name) {
      * Returns false.
      *
      * @param file the file to check (ignored)
-     *
+     * @param attributes the path's basic attributes (may be null).
      * @return false
      * @since 2.9.0
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java
index 83c69cfa..4277dce1 100644
--- a/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java
@@ -43,15 +43,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(FileFileFilter.INSTANCE);
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -97,19 +97,20 @@ protected FileFileFilter() {
      */
     @Override
     public boolean accept(final File file) {
-        return file.isFile();
+        return file != null && file.isFile();
     }
 
     /**
      * Checks to see if the file is a file.
-     * @param file  the File to check
      *
+     * @param file  the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file is a file
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isRegularFile(file));
+        return toFileVisitResult(file != null && Files.isRegularFile(file));
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java b/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java
index c1c205ee..4eed282b 100644
--- a/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java
+++ b/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java
@@ -47,7 +47,6 @@ public class FileFilterUtils {
     private static final IOFileFilter CVS_FILTER = notFileFilter(
             and(directoryFileFilter(), nameFileFilter("CVS")));
 
-
     /* Constructed on demand and then cached */
     private static final IOFileFilter SVN_FILTER = notFileFilter(
             and(directoryFileFilter(), nameFileFilter(".svn")));
diff --git a/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java
index 86ef0d31..963b9057 100644
--- a/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java
@@ -27,7 +27,7 @@
  * This filter accepts {@link File}s that are hidden.
  * <p>
  * Example, showing how to print out a list of the
- * current directory's <i>hidden</i> files:
+ * current directory's <em>hidden</em> files:
  * </p>
  * <h2>Using Classic IO</h2>
  * <pre>
@@ -40,7 +40,7 @@
  *
  * <p>
  * Example, showing how to print out a list of the
- * current directory's <i>visible</i> (i.e. not hidden) files:
+ * current directory's <em>visible</em> (not hidden) files:
  * </p>
  *
  * <pre>
@@ -56,15 +56,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(HiddenFileFilter.HIDDEN);
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -78,12 +78,12 @@
  */
 public class HiddenFileFilter extends AbstractFileFilter implements Serializable {
 
-    /** Singleton instance of <i>hidden</i> filter */
+    /** Singleton instance of <em>hidden</em> filter */
     public static final IOFileFilter HIDDEN  = new HiddenFileFilter();
 
     private static final long serialVersionUID = 8930842316112759062L;
 
-    /** Singleton instance of <i>visible</i> filter */
+    /** Singleton instance of <em>visible</em> filter */
     public static final IOFileFilter VISIBLE = HIDDEN.negate();
 
     /**
@@ -97,24 +97,24 @@ protected HiddenFileFilter() {
      *
      * @param file  the File to check
      * @return {@code true} if the file is
-     *  <i>hidden</i>, otherwise {@code false}.
+     *  <em>hidden</em>, otherwise {@code false}.
      */
     @Override
     public boolean accept(final File file) {
-        return file.isHidden();
+        return file == null || file.isHidden();
     }
 
     /**
      * Checks to see if the file is hidden.
-     * @param file  the File to check
      *
-     * @return {@code true} if the file is
-     *  <i>hidden</i>, otherwise {@code false}.
+     * @param file       the File to check
+     * @param attributes the path's basic attributes (may be null).
+     * @return {@code true} if the file is <em>hidden</em>, otherwise {@code false}.
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return get(() -> toFileVisitResult(Files.isHidden(file)));
+        return get(() -> toFileVisitResult(file == null || Files.isHidden(file)));
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java
index 2bdeab49..528527c0 100644
--- a/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java
@@ -27,7 +27,7 @@
 import org.apache.commons.io.file.PathFilter;
 
 /**
- * An interface which brings the FileFilter, FilenameFilter, and PathFilter interfaces together.
+ * An interface which brings the {@link FileFilter}, {@link FilenameFilter}, {@link PathFilter}, and {@link PathMatcher} interfaces together.
  *
  * @since 1.0
  */
@@ -41,7 +41,7 @@ public interface IOFileFilter extends FileFilter, FilenameFilter, PathFilter, Pa
     /**
      * Tests if a File should be accepted by this filter.
      * <p>
-     * Defined in {@link java.io.FileFilter}.
+     * Defined in {@link FileFilter}.
      * </p>
      *
      * @param file the File to check.
@@ -53,10 +53,10 @@ public interface IOFileFilter extends FileFilter, FilenameFilter, PathFilter, Pa
     /**
      * Tests if a File should be accepted by this filter.
      * <p>
-     * Defined in {@link java.io.FilenameFilter}.
+     * Defined in {@link FilenameFilter}.
      * </p>
      *
-     * @param dir the directory File to check.
+     * @param dir  the directory File to check.
      * @param name the file name within the directory to check.
      * @return true if this file matches the test.
      */
@@ -67,6 +67,7 @@ public interface IOFileFilter extends FileFilter, FilenameFilter, PathFilter, Pa
      * Checks to see if a Path should be accepted by this filter.
      *
      * @param path the Path to check.
+     * @param attributes the path's basic attributes (may be null).
      * @return true if this path matches the test.
      * @since 2.9.0
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
index 1793ef2a..6956bc8d 100644
--- a/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
@@ -18,7 +18,6 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.io.RandomAccessFile;
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
@@ -72,15 +71,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(MagicNumberFileFilter("ustar", 257));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -262,8 +261,9 @@ public MagicNumberFileFilter(final String magicNumber, final long offset) {
     @Override
     public boolean accept(final File file) {
         if (file != null && file.isFile() && file.canRead()) {
-            try (RandomAccessFile randomAccessFile = RandomAccessFileMode.READ_ONLY.create(file)) {
-                return Arrays.equals(magicNumbers, RandomAccessFiles.read(randomAccessFile, byteOffset, magicNumbers.length));
+            try {
+                return RandomAccessFileMode.READ_ONLY.apply(file.toPath(),
+                        raf -> Arrays.equals(magicNumbers, RandomAccessFiles.read(raf, byteOffset, magicNumbers.length)));
             } catch (final IOException ignored) {
                 // Do nothing, fall through and do not accept file
             }
@@ -276,13 +276,13 @@ public boolean accept(final File file) {
      * Accepts the provided file if the file contains the file filter's magic
      * number at the specified offset.
      * </p>
-     *
      * <p>
      * If any {@link IOException}s occur while reading the file, the file will
      * be rejected.
+     *
      * </p>
      * @param file the file to accept or reject.
-     *
+     * @param attributes the path's basic attributes (may be null).
      * @return {@code true} if the file contains the filter's magic number
      *         at the specified offset, {@code false} otherwise.
      * @since 2.9.0
@@ -318,8 +318,8 @@ public FileVisitResult accept(final Path file, final BasicFileAttributes attribu
     public String toString() {
         final StringBuilder builder = new StringBuilder(super.toString());
         builder.append("(");
-        builder.append(new String(magicNumbers, Charset.defaultCharset()));// TODO perhaps use hex if value is not
-                                                                           // printable
+        // TODO perhaps use hex if value is not printable
+        builder.append(new String(magicNumbers, Charset.defaultCharset()));
         builder.append(",");
         builder.append(this.byteOffset);
         builder.append(")");
diff --git a/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java
index 2d986cfb..2fa2cb53 100644
--- a/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java
@@ -26,6 +26,7 @@
 import java.util.stream.Stream;
 
 import org.apache.commons.io.IOCase;
+import org.apache.commons.io.file.PathUtils;
 
 /**
  * Filters file names for a certain name.
@@ -47,15 +48,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new NameFileFilter("Test"));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -162,7 +163,7 @@ public NameFileFilter(final String[] names, final IOCase ioCase) {
      */
     @Override
     public boolean accept(final File file) {
-        return acceptBaseName(file.getName());
+        return file != null && acceptBaseName(file.getName());
     }
 
     /**
@@ -179,14 +180,15 @@ public boolean accept(final File dir, final String name) {
 
     /**
      * Checks to see if the file name matches.
-     * @param file  the File to check
      *
+     * @param path  the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name matches
      * @since 2.9.0
      */
     @Override
-    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(acceptBaseName(Objects.toString(file.getFileName(), null)));
+    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
+        return toFileVisitResult(acceptBaseName(PathUtils.getFileNameString(path)));
     }
 
     private boolean acceptBaseName(final String baseName) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/NotFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/NotFileFilter.java
index e61081bc..386bfaaa 100644
--- a/src/main/java/org/apache/commons/io/filefilter/NotFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/NotFileFilter.java
@@ -76,8 +76,9 @@ public boolean accept(final File file, final String name) {
 
     /**
      * Returns the logical NOT of the underlying filter's return value for the same File.
-     * @param file the File to check
      *
+     * @param file the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the filter returns false
      * @since 2.9.0
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/OrFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/OrFileFilter.java
index 7d9a3666..4c6e82a0 100644
--- a/src/main/java/org/apache/commons/io/filefilter/OrFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/OrFileFilter.java
@@ -17,6 +17,7 @@
 package org.apache.commons.io.filefilter;
 
 import java.io.File;
+import java.io.FileFilter;
 import java.io.Serializable;
 import java.nio.file.FileVisitResult;
 import java.nio.file.Path;
@@ -28,7 +29,7 @@
 import java.util.stream.Stream;
 
 /**
- * A {@link java.io.FileFilter} providing conditional OR logic across a list of file filters. This filter returns
+ * A {@link FileFilter} providing conditional OR logic across a list of file filters. This filter returns
  * {@code true} if any filters in the list return {@code true}. Otherwise, it returns {@code false}. Checking of the
  * file filter list stops when the first filter returns {@code true}.
  * <h2>Deprecating Serialization</h2>
diff --git a/src/main/java/org/apache/commons/io/filefilter/PathMatcherFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/PathMatcherFileFilter.java
index 76b73eb3..aa796a1c 100644
--- a/src/main/java/org/apache/commons/io/filefilter/PathMatcherFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/PathMatcherFileFilter.java
@@ -44,6 +44,7 @@ public PathMatcherFileFilter(final PathMatcher pathMatcher) {
     public boolean accept(final File file) {
         return file != null && matches(file.toPath());
     }
+
     @Override
     public boolean matches(final Path path) {
         return pathMatcher.matches(path);
diff --git a/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
index 13f03648..7c8d4c4a 100644
--- a/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
@@ -26,6 +26,7 @@
 import java.util.stream.Stream;
 
 import org.apache.commons.io.IOCase;
+import org.apache.commons.io.file.PathUtils;
 
 /**
  * Filters file names for a certain prefix.
@@ -47,15 +48,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new PrefixFileFilter("Test"));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -121,6 +122,7 @@ public PrefixFileFilter(final String prefix) {
      * <p>
      * The array is not cloned, so could be changed after constructing the
      * instance. This would be inadvisable however.
+     * </p>
      *
      * @param prefixes  the prefixes to allow, must not be null
      * @throws IllegalArgumentException if the prefix array is null
@@ -184,15 +186,15 @@ public boolean accept(final File file, final String name) {
 
     /**
      * Checks to see if the file name starts with the prefix.
-     * @param file  the File to check
      *
+     * @param file  the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name starts with one of our prefixes
      * @since 2.9.0
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        final Path fileName = file.getFileName();
-        return toFileVisitResult(accept(fileName == null ? null : fileName.toFile()));
+        return toFileVisitResult(accept(PathUtils.getFileName(file, Path::toFile)));
     }
 
     private boolean accept(final String name) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java
index 9bcdd806..e9411321 100644
--- a/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java
@@ -26,6 +26,7 @@
 import java.util.regex.Pattern;
 
 import org.apache.commons.io.IOCase;
+import org.apache.commons.io.file.PathUtils;
 
 /**
  * Filters files using supplied regular expression(s).
@@ -51,15 +52,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new RegexFileFilter("^.*[tT]est(-\\d+)?\\.java$"));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -101,7 +102,7 @@ private static int toFlags(final IOCase ioCase) {
     private final Pattern pattern;
 
     /** How convert a path to a string. */
-    private final Function<Path, String> pathToString;
+    private transient final Function<Path, String> pathToString;
 
     /**
      * Constructs a new regular expression filter for a compiled regular expression
@@ -111,7 +112,7 @@ private static int toFlags(final IOCase ioCase) {
      */
     @SuppressWarnings("unchecked")
     public RegexFileFilter(final Pattern pattern) {
-        this(pattern, (Function<Path, String> & Serializable) p -> p.getFileName().toString());
+        this(pattern, (Function<Path, String> & Serializable) PathUtils::getFileNameString);
     }
 
     /**
@@ -125,7 +126,7 @@ public RegexFileFilter(final Pattern pattern) {
     public RegexFileFilter(final Pattern pattern, final Function<Path, String> pathToString) {
         Objects.requireNonNull(pattern, "pattern");
         this.pattern = pattern;
-        this.pathToString = pathToString;
+        this.pathToString = pathToString != null ? pathToString : Objects::toString;
     }
 
     /**
@@ -176,12 +177,13 @@ public boolean accept(final File dir, final String name) {
      * Checks to see if the file name matches one of the regular expressions.
      *
      * @param path the path
-     * @param attributes the path attributes
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name matches one of the regular expressions
      */
     @Override
     public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
-        return toFileVisitResult(pattern.matcher(pathToString.apply(path)).matches());
+        final String result = pathToString.apply(path);
+        return toFileVisitResult(result != null && pattern.matcher(result).matches());
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java
index cdb8d9b7..f9b68974 100644
--- a/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java
@@ -45,15 +45,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SizeFileFilter(1024 * 1024));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -110,9 +110,9 @@ public SizeFileFilter(final long size, final boolean acceptLarger) {
      * Checks to see if the size of the file is favorable.
      * <p>
      * If size equals threshold and smaller files are required,
-     * file <b>IS NOT</b> selected.
+     * file <strong>IS NOT</strong> selected.
      * If size equals threshold and larger files are required,
-     * file <b>IS</b> selected.
+     * file <strong>IS</strong> selected.
      * </p>
      *
      * @param file  the File to check
@@ -120,7 +120,7 @@ public SizeFileFilter(final long size, final boolean acceptLarger) {
      */
     @Override
     public boolean accept(final File file) {
-        return accept(file.length());
+        return accept(file != null ? file.length() : 0);
     }
 
     private boolean accept(final long length) {
@@ -130,13 +130,12 @@ private boolean accept(final long length) {
     /**
      * Checks to see if the size of the file is favorable.
      * <p>
-     * If size equals threshold and smaller files are required,
-     * file <b>IS NOT</b> selected.
-     * If size equals threshold and larger files are required,
-     * file <b>IS</b> selected.
+     * If size equals threshold and smaller files are required, file <strong>IS NOT</strong> selected. If size equals threshold and larger files are required,
+     * file <strong>IS</strong> selected.
      * </p>
-     * @param file  the File to check
      *
+     * @param file       the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name matches
      */
     @Override
diff --git a/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
index e06f5448..8823c24a 100644
--- a/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
@@ -26,6 +26,7 @@
 import java.util.stream.Stream;
 
 import org.apache.commons.io.IOCase;
+import org.apache.commons.io.file.PathUtils;
 
 /**
  * Filters files based on the suffix (what the file name ends with).
@@ -48,15 +49,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SuffixFileFilter(".java"));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -122,6 +123,7 @@ public SuffixFileFilter(final String suffix) {
      * <p>
      * The array is not cloned, so could be changed after constructing the
      * instance. This would be inadvisable however.
+     * </p>
      *
      * @param suffixes  the suffixes to allow, must not be null
      * @throws NullPointerException if the suffix array is null
@@ -185,14 +187,15 @@ public boolean accept(final File file, final String name) {
 
     /**
      * Checks to see if the file name ends with the suffix.
-     * @param file  the File to check
      *
+     * @param path       the File to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name ends with one of our suffixes
      * @since 2.9.0
      */
     @Override
-    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(accept(Objects.toString(file.getFileName(), null)));
+    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
+        return toFileVisitResult(accept(PathUtils.getFileNameString(path)));
     }
 
     private boolean accept(final String name) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilter.java
index 20a0dc8c..a0867f0f 100644
--- a/src/main/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilter.java
@@ -43,15 +43,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(SymbolicLinkFileFilter.INSTANCE);
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -71,7 +71,7 @@ public class SymbolicLinkFileFilter extends AbstractFileFilter implements Serial
      * unit test to works around this by doing two things: 1) This separates the class logic from
      * the call to identify a symbolic link, and 2) It allows the unit test to override that
      * symbolic link call on Windows only.
-     * This means we can write unit tests will run on all machines. On Windows, the unit test
+     * This means we can write unit tests that will run on all machines. On Windows, the unit test
      * can't create a symbolic link without admin privileges, so the unit tests won't
      * completely test all the necessary behavior on Windows, but they will still test the class
      * logic. Be careful not to break this, but be aware of it when writing unit tests. You can
@@ -117,10 +117,12 @@ public boolean accept(final File file) {
     }
 
     /**
-     * Checks to see if the file is a file.
+     * Checks to see if the file is a symbolic link.
      *
      * @param path the File Path to check
-     * @return true if the file exists and is a symbolic link to either another file or a directory.
+     * @param attributes the path's basic attributes (may be null).
+     * @return {@code onAccept} from {@link #SymbolicLinkFileFilter(FileVisitResult, FileVisitResult)} if the file exists and is a symbolic link to either
+     *         another file or a directory; returns {@code onReject} otherwise.
      */
     @Override
     public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/TrueFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/TrueFileFilter.java
index e48d80a1..4ce98844 100644
--- a/src/main/java/org/apache/commons/io/filefilter/TrueFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/TrueFileFilter.java
@@ -82,8 +82,9 @@ public boolean accept(final File dir, final String name) {
 
     /**
      * Returns true.
-     * @param file the file to check (ignored)
      *
+     * @param file the file to check (ignored)
+     * @param attributes the path's basic attributes (may be null).
      * @return true
      * @since 2.9.0
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java
index 0b21e7a0..6ee4db92 100644
--- a/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java
@@ -28,6 +28,7 @@
 import org.apache.commons.io.FilenameUtils;
 import org.apache.commons.io.IOCase;
 import org.apache.commons.io.build.AbstractSupplier;
+import org.apache.commons.io.file.PathUtils;
 
 /**
  * Filters files using the supplied wildcards.
@@ -39,7 +40,7 @@
  * command lines. The check is case-sensitive by default. See {@link FilenameUtils#wildcardMatchOnSystem(String,String)} for more information.
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * For example:
@@ -62,15 +63,15 @@
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(
  *     WildcardFileFilter.builder().setWildcards("*test*.java~*~").get());
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -106,7 +107,7 @@ public WildcardFileFilter get() {
          * Sets how to handle case sensitivity, null means case-sensitive.
          *
          * @param ioCase how to handle case sensitivity, null means case-sensitive.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setIoCase(final IOCase ioCase) {
             this.ioCase = IOCase.value(ioCase, IOCase.SENSITIVE);
@@ -117,7 +118,7 @@ public Builder setIoCase(final IOCase ioCase) {
          * Sets the list of wildcards to match, not null.
          *
          * @param wildcards the list of wildcards to match, not null.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setWildcards(final List<String> wildcards) {
             setWildcards(requireWildcards(wildcards).toArray(EMPTY_STRING_ARRAY));
@@ -128,7 +129,7 @@ public Builder setWildcards(final List<String> wildcards) {
          * Sets the wildcards to match, not null.
          *
          * @param wildcards the wildcards to match, not null.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setWildcards(final String... wildcards) {
             this.wildcards = requireWildcards(wildcards);
@@ -274,14 +275,14 @@ public boolean accept(final File dir, final String name) {
     /**
      * Checks to see if the file name matches one of the wildcards.
      *
-     * @param file the file to check
-     *
+     * @param path the file to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name matches one of the wildcards.
      * @since 2.9.0
      */
     @Override
-    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(accept(Objects.toString(file.getFileName(), null)));
+    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
+        return toFileVisitResult(accept(PathUtils.getFileNameString(path)));
     }
 
     private boolean accept(final String name) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java b/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java
index 007e93ef..a9350b13 100644
--- a/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java
@@ -27,6 +27,7 @@
 import java.util.stream.Stream;
 
 import org.apache.commons.io.FilenameUtils;
+import org.apache.commons.io.file.PathUtils;
 
 /**
  * Filters files using the supplied wildcards.
@@ -59,15 +60,15 @@
  * final Path dir = PathUtils.current();
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new WildcardFilter("*test*.java~*~"));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
@@ -154,18 +155,19 @@ public boolean accept(final File dir, final String name) {
 
     /**
      * Checks to see if the file name matches one of the wildcards.
-     * @param file the file to check
      *
+     * @param path the file to check
+     * @param attributes the path's basic attributes (may be null).
      * @return true if the file name matches one of the wildcards
      * @since 2.9.0
      */
     @Override
-    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        if (Files.isDirectory(file)) {
+    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
+        if (Files.isDirectory(path)) {
             return FileVisitResult.TERMINATE;
         }
         return toDefaultFileVisitResult(
-                Stream.of(wildcards).anyMatch(wildcard -> FilenameUtils.wildcardMatch(Objects.toString(file.getFileName(), null), wildcard)));
+                Stream.of(wildcards).anyMatch(wildcard -> FilenameUtils.wildcardMatch(PathUtils.getFileNameString(path), wildcard)));
 
     }
 
diff --git a/src/main/java/org/apache/commons/io/filefilter/package-info.java b/src/main/java/org/apache/commons/io/filefilter/package-info.java
index 3bf71238..8114b4de 100644
--- a/src/main/java/org/apache/commons/io/filefilter/package-info.java
+++ b/src/main/java/org/apache/commons/io/filefilter/package-info.java
@@ -148,22 +148,22 @@
  * }
  * </pre>
  * <h2>Using NIO</h2>
- * <p>You can combine Java <b>file tree walking</b> by using <code>java.nio.file.Files.walk()</code> APIs with filters:</p>
+ * <p>You can combine Java <strong>file tree walking</strong> by using <code>java.nio.file.Files.walk()</code> APIs with filters:</p>
  * <pre>
  * final Path dir = Paths.get("");
  * // We are interested in files older than one day
  * final long cutoff = System.currentTimeMillis() - (24 * 60 * 60 * 1000);
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
  * //
- * // Walk one dir
- * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);
+ * // Walk one directory
+ * Files.<strong>walkFileTree</strong>(dir, Collections.emptySet(), 1, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getFileList());
  * //
  * visitor.getPathCounters().reset();
  * //
- * // Walk dir tree
- * Files.<b>walkFileTree</b>(dir, visitor);
+ * // Walk directory tree
+ * Files.<strong>walkFileTree</strong>(dir, visitor);
  * System.out.println(visitor.getPathCounters());
  * System.out.println(visitor.getDirList());
  * System.out.println(visitor.getFileList());
diff --git a/src/main/java/org/apache/commons/io/function/Constants.java b/src/main/java/org/apache/commons/io/function/Constants.java
index 6ad3a63c..89dd4c5a 100644
--- a/src/main/java/org/apache/commons/io/function/Constants.java
+++ b/src/main/java/org/apache/commons/io/function/Constants.java
@@ -28,6 +28,11 @@ final class Constants {
     @SuppressWarnings("rawtypes")
     static final IOBiConsumer IO_BI_CONSUMER = (t, u) -> {/* No-op */};
 
+    /**
+     * No-op singleton.
+     */
+    static final IORunnable IO_RUNNABLE = () -> {/* No-op */};
+
     /**
      * No-op singleton.
      */
diff --git a/src/main/java/org/apache/commons/io/function/Erase.java b/src/main/java/org/apache/commons/io/function/Erase.java
index 9c883bfb..eab44cd0 100644
--- a/src/main/java/org/apache/commons/io/function/Erase.java
+++ b/src/main/java/org/apache/commons/io/function/Erase.java
@@ -20,8 +20,10 @@
 
 /**
  * Erases {@link IOException} for the compiler but still throws that exception at runtime.
+ *
+ * @since 2.16.0
  */
-final class Erase {
+public final class Erase {
 
     /**
      * Delegates to the given {@link IOBiConsumer} but erases its {@link IOException} for the compiler, while still throwing
@@ -144,7 +146,7 @@ static <T> T get(final IOSupplier<T> supplier) {
      * @throws T Always thrown.
      */
     @SuppressWarnings("unchecked")
-    static <T extends Throwable> RuntimeException rethrow(final Throwable throwable) throws T {
+    public static <T extends Throwable> RuntimeException rethrow(final Throwable throwable) throws T {
         throw (T) throwable;
     }
 
diff --git a/src/main/java/org/apache/commons/io/function/IOConsumer.java b/src/main/java/org/apache/commons/io/function/IOConsumer.java
index e417178f..e35ad7ef 100644
--- a/src/main/java/org/apache/commons/io/function/IOConsumer.java
+++ b/src/main/java/org/apache/commons/io/function/IOConsumer.java
@@ -67,7 +67,7 @@ static <T> void forAll(final IOConsumer<T> action, final Stream<T> stream) throw
     }
 
     /**
-     * Performs an action for each element of the array gathering any exceptions.
+     * Performs an action for each element of the array, gathering any exceptions.
      *
      * @param action The action to apply to each input element.
      * @param array The input to stream.
diff --git a/src/main/java/org/apache/commons/io/function/IOIntConsumer.java b/src/main/java/org/apache/commons/io/function/IOIntConsumer.java
new file mode 100644
index 00000000..fb5f2913
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/function/IOIntConsumer.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.function;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.function.IntConsumer;
+
+/**
+ * Like {@link IntConsumer} but throws {@link IOException}.
+ *
+ * @since 2.18.0
+ */
+@FunctionalInterface
+public interface IOIntConsumer {
+
+    /**
+     * The constant no-op consumer.
+     */
+    IOIntConsumer NOOP = i -> {/* noop */};
+
+    /**
+     * Performs this operation on the given argument.
+     *
+     * @param value the input argument
+     * @throws IOException if an I/O error occurs.
+     */
+    void accept(int value) throws IOException;
+
+    /**
+     * Returns a composed {@code IOIntConsumer} that performs, in sequence, this operation followed by the {@code after} operation. If performing either
+     * operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the {@code after}
+     * operation will not be performed.
+     *
+     * @param after the operation to perform after this operation
+     * @return a composed {@code IOIntConsumer} that performs in sequence this operation followed by the {@code after} operation
+     * @throws NullPointerException if {@code after} is null
+     */
+    default IOIntConsumer andThen(final IOIntConsumer after) {
+        Objects.requireNonNull(after);
+        return (final int i) -> {
+            accept(i);
+            after.accept(i);
+        };
+    }
+
+    /**
+     * Creates a {@link Consumer} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.
+     *
+     * @return an UncheckedIOException IntConsumer.
+     */
+    default Consumer<Integer> asConsumer() {
+        return i -> Uncheck.accept(this, i);
+    }
+
+    /**
+     * Creates an {@link IntConsumer} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.
+     *
+     * @return an UncheckedIOException IntConsumer.
+     */
+    default IntConsumer asIntConsumer() {
+        return i -> Uncheck.accept(this, i);
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/function/IOIterator.java b/src/main/java/org/apache/commons/io/function/IOIterator.java
index dd64d232..ceaa3feb 100644
--- a/src/main/java/org/apache/commons/io/function/IOIterator.java
+++ b/src/main/java/org/apache/commons/io/function/IOIterator.java
@@ -32,6 +32,18 @@
  */
 public interface IOIterator<E> {
 
+    /**
+     * Adapts the given Iterable as an IOIterator.
+     *
+     * @param <E> the type of the stream elements.
+     * @param iterable The iterable to adapt
+     * @return A new IOIterator
+     * @since 2.17.0
+     */
+    static <E> IOIterator<E> adapt(final Iterable<E> iterable) {
+        return IOIteratorAdapter.adapt(iterable.iterator());
+    }
+
     /**
      * Adapts the given Iterator as an IOIterator.
      *
diff --git a/src/main/java/org/apache/commons/io/function/IORunnable.java b/src/main/java/org/apache/commons/io/function/IORunnable.java
index 60b76bd7..4d20a96b 100644
--- a/src/main/java/org/apache/commons/io/function/IORunnable.java
+++ b/src/main/java/org/apache/commons/io/function/IORunnable.java
@@ -28,6 +28,16 @@
 @FunctionalInterface
 public interface IORunnable {
 
+    /**
+     * Returns the constant no-op runnable.
+     *
+     * @return a constant no-op runnable.
+     * @since 2.16.0
+     */
+    static IORunnable noop() {
+        return Constants.IO_RUNNABLE;
+    }
+
     /**
      * Creates a {@link Runnable} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.
      *
diff --git a/src/main/java/org/apache/commons/io/function/IOStream.java b/src/main/java/org/apache/commons/io/function/IOStream.java
index 5e78e6c9..8b33b718 100644
--- a/src/main/java/org/apache/commons/io/function/IOStream.java
+++ b/src/main/java/org/apache/commons/io/function/IOStream.java
@@ -22,6 +22,7 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Spliterator;
@@ -93,8 +94,14 @@ public boolean hasNext() {
             }
 
             @Override
-            public T next() {
-                return t = t == IOStreams.NONE ? seed : Erase.apply(f, t);
+            public T next() throws NoSuchElementException {
+                try {
+                    return t = t == IOStreams.NONE ? seed : f.apply(t);
+                } catch (final IOException e) {
+                    final NoSuchElementException nsee = new NoSuchElementException();
+                    nsee.initCause(e);
+                    throw nsee;
+                }
             }
         };
         return adapt(StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false));
@@ -109,7 +116,6 @@ public T next() {
      * @param values the elements of the new stream, may be {@code null}.
      * @return the new stream on {@code values} or {@link Stream#empty()}.
      */
-    @SuppressWarnings("resource") // call to #empty()
     static <T> IOStream<T> of(final Iterable<T> values) {
         return values == null ? empty() : adapt(StreamSupport.stream(values.spliterator(), false));
     }
@@ -121,7 +127,6 @@ static <T> IOStream<T> of(final Iterable<T> values) {
      * @param values the elements of the new stream, may be {@code null}.
      * @return the new stream on {@code values} or {@link Stream#empty()}.
      */
-    @SuppressWarnings("resource")
     @SafeVarargs // Creating a stream from an array is safe
     static <T> IOStream<T> of(final T... values) {
         return values == null || values.length == 0 ? empty() : adapt(Arrays.stream(values));
@@ -258,7 +263,7 @@ default Optional<T> findFirst() {
      * @return Like {@link Stream#flatMap(java.util.function.Function)}.
      * @throws IOException if an I/O error occurs.
      */
-    @SuppressWarnings("unused") // thrown by Erase.
+    @SuppressWarnings({ "unused", "resource" }) // thrown by Erase; resource closed by caller.
     default <R> IOStream<R> flatMap(final IOFunction<? super T, ? extends IOStream<? extends R>> mapper) throws IOException {
         return adapt(unwrap().flatMap(t -> Erase.apply(mapper, t).unwrap()));
     }
diff --git a/src/main/java/org/apache/commons/io/function/IOStreamAdapter.java b/src/main/java/org/apache/commons/io/function/IOStreamAdapter.java
index aed21a7f..10a7dc97 100644
--- a/src/main/java/org/apache/commons/io/function/IOStreamAdapter.java
+++ b/src/main/java/org/apache/commons/io/function/IOStreamAdapter.java
@@ -28,7 +28,6 @@
  */
 final class IOStreamAdapter<T> extends IOBaseStreamAdapter<T, IOStream<T>, Stream<T>> implements IOStream<T> {
 
-    @SuppressWarnings("resource")
     static <T> IOStream<T> adapt(final Stream<T> delegate) {
         return delegate != null ? new IOStreamAdapter<>(delegate) : IOStream.empty();
     }
diff --git a/src/main/java/org/apache/commons/io/function/IOSupplier.java b/src/main/java/org/apache/commons/io/function/IOSupplier.java
index 5a81b407..a021e5fc 100644
--- a/src/main/java/org/apache/commons/io/function/IOSupplier.java
+++ b/src/main/java/org/apache/commons/io/function/IOSupplier.java
@@ -23,6 +23,9 @@
 
 /**
  * Like {@link Supplier} but throws {@link IOException}.
+ * <p>
+ * Using an IOSupplier allows you to compose usage of checked and unchecked exceptions as you best see fit.
+ * </p>
  *
  * @param <T> the return type of the operations.
  * @since 2.7
@@ -37,14 +40,25 @@ public interface IOSupplier<T> {
      * @since 2.12.0
      */
     default Supplier<T> asSupplier() {
-        return () -> Uncheck.get(this);
+        return this::getUnchecked;
     }
 
     /**
      * Gets a result.
      *
-     * @return a result
+     * @return a result.
      * @throws IOException if an I/O error occurs.
      */
     T get() throws IOException;
+
+    /**
+     * Gets a result.
+     *
+     * @return a result.
+     * @throws UncheckedIOException if an I/O error occurs.
+     * @since 2.17.0
+     */
+    default T getUnchecked() throws UncheckedIOException {
+        return Uncheck.get(this);
+    }
 }
diff --git a/src/main/java/org/apache/commons/io/function/Uncheck.java b/src/main/java/org/apache/commons/io/function/Uncheck.java
index a593b56a..f2450425 100644
--- a/src/main/java/org/apache/commons/io/function/Uncheck.java
+++ b/src/main/java/org/apache/commons/io/function/Uncheck.java
@@ -62,6 +62,22 @@ public static <T> void accept(final IOConsumer<T> consumer, final T t) {
         }
     }
 
+    /**
+     * Accepts an IO consumer with the given argument.
+     *
+     * @param i the input argument.
+     * @param consumer Consumes the value.
+     * @throws UncheckedIOException if an I/O error occurs.
+     * @since 2.18.0
+     */
+    public static void accept(final IOIntConsumer consumer, final int i) {
+        try {
+            consumer.accept(i);
+        } catch (final IOException e) {
+            throw wrap(e);
+        }
+    }
+
     /**
      * Accepts an IO consumer with the given arguments.
      *
@@ -330,7 +346,7 @@ public static <T> boolean test(final IOPredicate<T> predicate, final T t) {
     }
 
     /**
-     * Constructs a new UncheckedIOException for the given exception.
+     * Constructs a new {@link UncheckedIOException} for the given exception.
      *
      * @param e The exception to wrap.
      * @return a new {@link UncheckedIOException}.
@@ -340,7 +356,7 @@ private static UncheckedIOException wrap(final IOException e) {
     }
 
     /**
-     * Constructs a new UncheckedIOException for the given exception and detail message.
+     * Constructs a new {@link UncheckedIOException} for the given exception and detail message.
      *
      * @param e The exception to wrap.
      * @param message The UncheckedIOException message if an I/O error occurs.
diff --git a/src/main/java/org/apache/commons/io/function/UncheckedIOBaseStream.java b/src/main/java/org/apache/commons/io/function/UncheckedIOBaseStream.java
index 3e033ee0..118e7ca7 100644
--- a/src/main/java/org/apache/commons/io/function/UncheckedIOBaseStream.java
+++ b/src/main/java/org/apache/commons/io/function/UncheckedIOBaseStream.java
@@ -33,7 +33,7 @@
  * @param <S> the type of the IO stream extending {@code IOBaseStream}.
  * @param <B> the type of the stream extending {@code BaseStream}.
  */
-class UncheckedIOBaseStream<T, S extends IOBaseStream<T, S, B>, B extends BaseStream<T, B>> implements BaseStream<T, B> {
+final class UncheckedIOBaseStream<T, S extends IOBaseStream<T, S, B>, B extends BaseStream<T, B>> implements BaseStream<T, B> {
 
     private final S delegate;
 
diff --git a/src/main/java/org/apache/commons/io/input/AbstractInputStream.java b/src/main/java/org/apache/commons/io/input/AbstractInputStream.java
new file mode 100644
index 00000000..7a300a5f
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/input/AbstractInputStream.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Abstracts some InputStream operations for implementations in this package.
+ *
+ * @since 2.17.0
+ */
+public abstract class AbstractInputStream extends InputStream {
+
+    /**
+     * Whether {@link #close()} completed successfully.
+     */
+    private boolean closed;
+
+    /**
+     * Checks if this instance is closed and throws an IOException if so.
+     *
+     * @throws IOException if this instance is closed.
+     */
+    void checkOpen() throws IOException {
+        Input.checkOpen(!isClosed());
+    }
+
+    @Override
+    public void close() throws IOException {
+        super.close();
+        closed = true;
+    }
+
+    /**
+     * Tests whether this instance is closed; if {@link #close()} completed successfully.
+     *
+     * @return whether this instance is closed.
+     */
+    public boolean isClosed() {
+        return closed;
+    }
+
+    /**
+     * Sets whether this instance is closed.
+     *
+     * @param closed whether this instance is closed.
+     */
+    public void setClosed(final boolean closed) {
+        this.closed = closed;
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/input/AutoCloseInputStream.java b/src/main/java/org/apache/commons/io/input/AutoCloseInputStream.java
index 7a6089d0..de7451fd 100644
--- a/src/main/java/org/apache/commons/io/input/AutoCloseInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/AutoCloseInputStream.java
@@ -21,61 +21,68 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-import org.apache.commons.io.build.AbstractStreamBuilder;
-
 /**
- * Proxy stream that closes and discards the underlying stream as soon as the
- * end of input has been reached or when the stream is explicitly closed.
- * Not even a reference to the underlying stream is kept after it has been
- * closed, so any allocated in-memory buffers can be freed even if the
- * client application still keeps a reference to the proxy stream.
+ * Proxy stream that closes and discards the underlying stream as soon as the end of input has been reached or when the stream is explicitly closed. Not even a
+ * reference to the underlying stream is kept after it has been closed, so any allocated in-memory buffers can be freed even if the client application still
+ * keeps a reference to the proxy stream.
+ * <p>
+ * This class is typically used to release any resources related to an open stream as soon as possible even if the client application (by not explicitly closing
+ * the stream when no longer needed) or the underlying stream (by not releasing resources once the last byte has been read) do not do that.
+ * </p>
  * <p>
- * This class is typically used to release any resources related to an open
- * stream as soon as possible even if the client application (by not explicitly
- * closing the stream when no longer needed) or the underlying stream (by not
- * releasing resources once the last byte has been read) do not do that.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
  * @since 1.4
+ * @see Builder
  */
 public class AutoCloseInputStream extends ProxyInputStream {
 
+    // @formatter:off
     /**
      * Builds a new {@link AutoCloseInputStream} instance.
+     *
      * <p>
      * For example:
      * </p>
-     *
      * <pre>{@code
      * AutoCloseInputStream s = AutoCloseInputStream.builder()
      *   .setPath(path)
      *   .get();}
      * </pre>
-     *
      * <pre>{@code
      * AutoCloseInputStream s = AutoCloseInputStream.builder()
      *   .setInputStream(inputStream)
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.13.0
      */
-    public static class Builder extends AbstractStreamBuilder<AutoCloseInputStream, Builder> {
+    // @formatter:on
+    public static class Builder extends AbstractBuilder<AutoCloseInputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link AutoCloseInputStream}.
          * <p>
-         * This builder use the aspect InputStream.
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
+         * <p>
+         * This builder use the following aspects:
+         * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws IOException              if an I/O error occurs.
-         * @throws IllegalArgumentException if the buffer is not large enough to hold a complete character.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
+         * @see #getInputStream()
          */
-        @SuppressWarnings("resource") // Caller closes
         @Override
         public AutoCloseInputStream get() throws IOException {
-            return new AutoCloseInputStream(getInputStream());
+            return new AutoCloseInputStream(this);
         }
 
     }
@@ -90,15 +97,20 @@ public static Builder builder() {
         return new Builder();
     }
 
+    private AutoCloseInputStream(final Builder builder) throws IOException {
+        super(builder);
+    }
+
     /**
      * Constructs an automatically closing proxy for the given input stream.
      *
      * @param in underlying input stream
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
+    @SuppressWarnings("resource") // ClosedInputStream.nonNull() doesn't allocate
     @Deprecated
     public AutoCloseInputStream(final InputStream in) {
-        super(in);
+        super(ClosedInputStream.ifNull(in));
     }
 
     /**
@@ -113,31 +125,31 @@ protected void afterRead(final int n) throws IOException {
         if (n == EOF) {
             close();
         }
+        super.afterRead(n);
     }
 
     /**
-     * Closes the underlying input stream and replaces the reference to it
-     * with a {@link ClosedInputStream} instance.
+     * Closes the underlying input stream and replaces the reference to it with a {@link ClosedInputStream} instance.
      * <p>
-     * This method is automatically called by the read methods when the end
-     * of input has been reached.
+     * This method is automatically called by the read methods when the end of input has been reached.
+     * </p>
      * <p>
-     * Note that it is safe to call this method any number of times. The original
-     * underlying input stream is closed and discarded only once when this
-     * method is first called.
+     * Note that it is safe to call this method any number of times. The original underlying input stream is closed and discarded only once when this method is
+     * first called.
+     * </p>
      *
-     * @throws IOException if the underlying input stream can not be closed
+     * @throws IOException if the underlying input stream cannot be closed
      */
     @Override
     public void close() throws IOException {
-        in.close();
+        super.close();
         in = ClosedInputStream.INSTANCE;
     }
 
     /**
-     * Ensures that the stream is closed before it gets garbage-collected.
-     * As mentioned in {@link #close()}, this is a no-op if the stream has
-     * already been closed.
+     * Ensures that the stream is closed before it gets garbage-collected. As mentioned in {@link #close()}, this is a no-op if the stream has already been
+     * closed.
+     *
      * @throws Throwable if an error occurs
      */
     @Override
diff --git a/src/main/java/org/apache/commons/io/input/BOMInputStream.java b/src/main/java/org/apache/commons/io/input/BOMInputStream.java
index 425af99c..63c0275e 100644
--- a/src/main/java/org/apache/commons/io/input/BOMInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/BOMInputStream.java
@@ -27,7 +27,6 @@
 
 import org.apache.commons.io.ByteOrderMark;
 import org.apache.commons.io.IOUtils;
-import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
  * This class is used to wrap a stream that includes an encoded {@link ByteOrderMark} as its first bytes.
@@ -46,7 +45,7 @@
  * <li>UTF-32LE - {@link ByteOrderMark#UTF_32BE}</li>
  * </ul>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <h2>Example 1 - Detecting and excluding a UTF-8 BOM</h2>
  *
@@ -89,15 +88,20 @@
  *     // has a UTF-32BE BOM
  * }
  * </pre>
+ * <p>
+ * To build an instance, use {@link Builder}.
+ * </p>
  *
+ * @see Builder
  * @see org.apache.commons.io.ByteOrderMark
- * @see <a href="http://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia - Byte Order Mark</a>
+ * @see <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia - Byte Order Mark</a>
  * @since 2.0
  */
 public class BOMInputStream extends ProxyInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link BOMInputStream} instance.
+     * Builds a new {@link BOMInputStream}.
      *
      * <h2>Using NIO</h2>
      * <pre>{@code
@@ -116,9 +120,11 @@ public class BOMInputStream extends ProxyInputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
-    public static class Builder extends AbstractStreamBuilder<BOMInputStream, Builder> {
+    // @formatter:on
+    public static class Builder extends AbstractBuilder<BOMInputStream, Builder> {
 
         private static final ByteOrderMark[] DEFAULT = { ByteOrderMark.UTF_8 };
 
@@ -136,23 +142,31 @@ static ByteOrderMark getDefaultByteOrderMark() {
         private boolean include;
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link BOMInputStream}.
+         * <p>
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
+         * </p>
          * <p>
-         * This builder use the aspects InputStream, OpenOption[], include, and ByteOrderMark[].
+         * This builder use the following aspects: InputStream, OpenOption[], include, and ByteOrderMark[].
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>include}</li>
+         * <li>byteOrderMarks</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getInputStream()
          */
-        @SuppressWarnings("resource")
         @Override
         public BOMInputStream get() throws IOException {
-            return new BOMInputStream(getInputStream(), include, byteOrderMarks);
+            return new BOMInputStream(this);
         }
 
         /**
@@ -162,7 +176,7 @@ public BOMInputStream get() throws IOException {
          * </p>
          *
          * @param byteOrderMarks the ByteOrderMarks to detect and optionally exclude.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setByteOrderMarks(final ByteOrderMark... byteOrderMarks) {
             this.byteOrderMarks = byteOrderMarks != null ? byteOrderMarks.clone() : DEFAULT;
@@ -176,7 +190,7 @@ public Builder setByteOrderMarks(final ByteOrderMark... byteOrderMarks) {
          * </p>
          *
          * @param include true to include the UTF-8 BOM or false to exclude it. return this;
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setInclude(final boolean include) {
             this.include = include;
@@ -190,7 +204,6 @@ public Builder setInclude(final boolean include) {
      */
     private static final Comparator<ByteOrderMark> ByteOrderMarkLengthComparator = Comparator.comparing(ByteOrderMark::length).reversed();
 
-
     /**
      * Constructs a new {@link Builder}.
      *
@@ -214,6 +227,18 @@ public static Builder builder() {
     private boolean markedAtStart;
     private int markFbIndex;
 
+    private BOMInputStream(final Builder builder) throws IOException {
+        super(builder);
+        if (IOUtils.length(builder.byteOrderMarks) == 0) {
+            throw new IllegalArgumentException("No BOMs specified");
+        }
+        this.include = builder.include;
+        final List<ByteOrderMark> list = Arrays.asList(builder.byteOrderMarks);
+        // Sort the BOMs to match the longest BOM first because some BOMs have the same starting two bytes.
+        list.sort(ByteOrderMarkLengthComparator);
+        this.boms = list;
+    }
+
     /**
      * Constructs a new BOM InputStream that excludes a {@link ByteOrderMark#UTF_8} BOM.
      *
@@ -262,7 +287,6 @@ public BOMInputStream(final InputStream delegate, final boolean include, final B
         // Sort the BOMs to match the longest BOM first because some BOMs have the same starting two bytes.
         list.sort(ByteOrderMarkLengthComparator);
         this.boms = list;
-
     }
 
     /**
@@ -304,6 +328,7 @@ public ByteOrderMark getBOM() throws IOException {
             // Read first maxBomSize bytes
             for (int i = 0; i < firstBytes.length; i++) {
                 firstBytes[i] = in.read();
+                afterRead(firstBytes[i]);
                 fbLength++;
                 if (firstBytes[i] < 0) {
                     break;
@@ -328,7 +353,6 @@ public ByteOrderMark getBOM() throws IOException {
      * @return The BOM charset Name or null if no BOM found
      * @throws IOException
      *             if an error reading the first bytes of the stream occurs
-     *
      */
     public String getBOMCharsetName() throws IOException {
         getBOM();
@@ -367,14 +391,14 @@ public boolean hasBOM(final ByteOrderMark bom) throws IOException {
     /**
      * Invokes the delegate's {@code mark(int)} method.
      *
-     * @param readlimit
+     * @param readLimit
      *            read ahead limit
      */
     @Override
-    public synchronized void mark(final int readlimit) {
+    public synchronized void mark(final int readLimit) {
         markFbIndex = fbIndex;
         markedAtStart = firstBytes == null;
-        in.mark(readlimit);
+        in.mark(readLimit);
     }
 
     /**
@@ -406,6 +430,7 @@ private boolean matches(final ByteOrderMark bom) {
      */
     @Override
     public int read() throws IOException {
+        checkOpen();
         final int b = readFirstBytes();
         return b >= 0 ? b : in.read();
     }
@@ -450,6 +475,7 @@ public int read(final byte[] buf, int off, int len) throws IOException {
             }
         }
         final int secondCount = in.read(buf, off, len);
+        afterRead(secondCount);
         return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount;
     }
 
@@ -479,7 +505,6 @@ public synchronized void reset() throws IOException {
         if (markedAtStart) {
             firstBytes = null;
         }
-
         in.reset();
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/BoundedInputStream.java b/src/main/java/org/apache/commons/io/input/BoundedInputStream.java
index 902e6a55..d23cf569 100644
--- a/src/main/java/org/apache/commons/io/input/BoundedInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/BoundedInputStream.java
@@ -18,56 +18,342 @@
 
 import static org.apache.commons.io.IOUtils.EOF;
 
-import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.function.IOBiConsumer;
+
+//@formatter:off
 /**
- * Reads bytes up to a maximum length, if its count goes above that, it stops.
+ * Reads bytes up to a maximum count and stops once reached.
  * <p>
- * This is useful to wrap ServletInputStreams. The ServletInputStream will block if you try to read content from it that isn't there, because it doesn't know
- * whether the content hasn't arrived yet or whether the content has finished. So, one of these, initialized with the Content-length sent in the
- * ServletInputStream's header, will stop it blocking, providing it's been sent with a correct content length.
+ * To build an instance, see {@link AbstractBuilder}.
  * </p>
- *
+ * <p>
+ * By default, a {@link BoundedInputStream} is <em>unbound</em>; so make sure to call {@link AbstractBuilder#setMaxCount(long)}.
+ * </p>
+ * <p>
+ * You can find out how many bytes this stream has seen so far by calling {@link BoundedInputStream#getCount()}. This value reflects bytes read and skipped.
+ * </p>
+ * <h2>Using a ServletInputStream</h2>
+ * <p>
+ * A {@code ServletInputStream} can block if you try to read content that isn't there
+ * because it doesn't know whether the content hasn't arrived yet or whether the content has finished. Initialize an {@link BoundedInputStream} with the
+ * {@code Content-Length} sent in the {@code ServletInputStream}'s header, this stop it from blocking, providing it's been sent with a correct content
+ * length in the first place.
+ * </p>
+ * <h2>Using NIO</h2>
+ * <pre>{@code
+ * BoundedInputStream s = BoundedInputStream.builder()
+ *   .setPath(Paths.get("MyFile.xml"))
+ *   .setMaxCount(1024)
+ *   .setPropagateClose(false)
+ *   .get();
+ * }
+ * </pre>
+ * <h2>Using IO</h2>
+ * <pre>{@code
+ * BoundedInputStream s = BoundedInputStream.builder()
+ *   .setFile(new File("MyFile.xml"))
+ *   .setMaxCount(1024)
+ *   .setPropagateClose(false)
+ *   .get();
+ * }
+ * </pre>
+ * <h2>Counting Bytes</h2>
+ * <p>You can set the running count when building, which is most useful when starting from another stream:
+ * <pre>{@code
+ * InputStream in = ...;
+ * BoundedInputStream s = BoundedInputStream.builder()
+ *   .setInputStream(in)
+ *   .setCount(12)
+ *   .setMaxCount(1024)
+ *   .setPropagateClose(false)
+ *   .get();
+ * }
+ * </pre>
+ * <h2>Listening for the max count reached</h2>
+ * <pre>{@code
+ * BoundedInputStream s = BoundedInputStream.builder()
+ *   .setPath(Paths.get("MyFile.xml"))
+ *   .setMaxCount(1024)
+ *   .setOnMaxCount((max, count) -> System.out.printf("Max count %,d reached with a last read count of %,d%n", max, count))
+ *   .get();
+ * }
+ * </pre>
+ * @see Builder
  * @since 2.0
  */
-public class BoundedInputStream extends FilterInputStream {
+//@formatter:on
+public class BoundedInputStream extends ProxyInputStream {
 
-    /** The max count of bytes to read. */
-    private final long maxCount;
+    /**
+     * For subclassing builders from {@link BoundedInputStream} subclassses.
+     *
+     * @param <T> The subclass.
+     */
+    static abstract class AbstractBuilder<T extends AbstractBuilder<T>> extends ProxyInputStream.AbstractBuilder<BoundedInputStream, T> {
+
+        /** The current count of bytes counted. */
+        private long count;
+
+        /** The max count of bytes to read. */
+        private long maxCount = EOF;
+
+        private IOBiConsumer<Long, Long> onMaxCount = IOBiConsumer.noop();
+
+        /** Flag if {@link #close()} should be propagated, {@code true} by default. */
+        private boolean propagateClose = true;
+
+        long getCount() {
+            return count;
+        }
+
+        long getMaxCount() {
+            return maxCount;
+        }
+
+        IOBiConsumer<Long, Long> getOnMaxCount() {
+            return onMaxCount;
+        }
+
+        boolean isPropagateClose() {
+            return propagateClose;
+        }
+
+        /**
+         * Sets the current number of bytes counted.
+         * <p>
+         * Useful when building from another stream to carry forward a read count.
+         * </p>
+         * <p>
+         * Default is {@code 0}, negative means 0.
+         * </p>
+         *
+         * @param count The current number of bytes counted.
+         * @return {@code this} instance.
+         */
+        public T setCount(final long count) {
+            this.count = Math.max(0, count);
+            return asThis();
+        }
+
+        /**
+         * Sets the maximum number of bytes to return.
+         * <p>
+         * Default is {@value IOUtils#EOF}, negative means unbound.
+         * </p>
+         *
+         * @param maxCount The maximum number of bytes to return.
+         * @return {@code this} instance.
+         */
+        public T setMaxCount(final long maxCount) {
+            this.maxCount = Math.max(EOF, maxCount);
+            return asThis();
+        }
+
+        /**
+         * Sets the default {@link BoundedInputStream#onMaxLength(long, long)} behavior, {@code null} resets to a NOOP.
+         * <p>
+         * The first Long is the max count of bytes to read. The second Long is the count of bytes read.
+         * </p>
+         * <p>
+         * This does <em>not</em> override a {@code BoundedInputStream} subclass' implementation of the {@link BoundedInputStream#onMaxLength(long, long)}
+         * method.
+         * </p>
+         *
+         * @param onMaxCount the {@link ProxyInputStream#afterRead(int)} behavior.
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public T setOnMaxCount(final IOBiConsumer<Long, Long> onMaxCount) {
+            this.onMaxCount = onMaxCount != null ? onMaxCount : IOBiConsumer.noop();
+            return asThis();
+        }
+
+        /**
+         * Sets whether the {@link #close()} method should propagate to the underling {@link InputStream}.
+         * <p>
+         * Default is {@code true}.
+         * </p>
+         *
+         * @param propagateClose {@code true} if calling {@link #close()} propagates to the {@code close()} method of the underlying stream or {@code false} if
+         *                       it does not.
+         * @return {@code this} instance.
+         */
+        public T setPropagateClose(final boolean propagateClose) {
+            this.propagateClose = propagateClose;
+            return asThis();
+        }
+
+    }
+
+    //@formatter:off
+    /**
+     * Builds a new {@link BoundedInputStream}.
+     * <p>
+     * By default, a {@link BoundedInputStream} is <em>unbound</em>; so make sure to call {@link AbstractBuilder#setMaxCount(long)}.
+     * </p>
+     * <p>
+     * You can find out how many bytes this stream has seen so far by calling {@link BoundedInputStream#getCount()}. This value reflects bytes read and skipped.
+     * </p>
+     * <h2>Using a ServletInputStream</h2>
+     * <p>
+     * A {@code ServletInputStream} can block if you try to read content that isn't there
+     * because it doesn't know whether the content hasn't arrived yet or whether the content has finished. Initialize an {@link BoundedInputStream} with the
+     * {@code Content-Length} sent in the {@code ServletInputStream}'s header, this stop it from blocking, providing it's been sent with a correct content
+     * length in the first place.
+     * </p>
+     * <h2>Using NIO</h2>
+     * <pre>{@code
+     * BoundedInputStream s = BoundedInputStream.builder()
+     *   .setPath(Paths.get("MyFile.xml"))
+     *   .setMaxCount(1024)
+     *   .setPropagateClose(false)
+     *   .get();
+     * }
+     * </pre>
+     * <h2>Using IO</h2>
+     * <pre>{@code
+     * BoundedInputStream s = BoundedInputStream.builder()
+     *   .setFile(new File("MyFile.xml"))
+     *   .setMaxCount(1024)
+     *   .setPropagateClose(false)
+     *   .get();
+     * }
+     * </pre>
+     * <h2>Counting Bytes</h2>
+     * <p>You can set the running count when building, which is most useful when starting from another stream:
+     * <pre>{@code
+     * InputStream in = ...;
+     * BoundedInputStream s = BoundedInputStream.builder()
+     *   .setInputStream(in)
+     *   .setCount(12)
+     *   .setMaxCount(1024)
+     *   .setPropagateClose(false)
+     *   .get();
+     * }
+     * </pre>
+     *
+     * @see #get()
+     * @since 2.16.0
+     */
+    //@formatter:on
+    public static class Builder extends AbstractBuilder<Builder> {
+
+        /**
+         * Builds a new {@link BoundedInputStream}.
+         * <p>
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
+         * </p>
+         * <p>
+         * This builder use the following aspects:
+         * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getAfterRead()}</li>
+         * <li>{@link #getCount()}</li>
+         * <li>{@link #getMaxCount()}</li>
+         * <li>{@link #isPropagateClose()}</li>
+         * <li>{@link #getOnMaxCount()}</li>
+         * </ul>
+         *
+         * @return a new instance.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
+         * @see #getInputStream()
+         */
+        @Override
+        public BoundedInputStream get() throws IOException {
+            return new BoundedInputStream(this);
+        }
+
+    }
 
-    /** The count of bytes read. */
+    /**
+     * Constructs a new {@link AbstractBuilder}.
+     *
+     * @return a new {@link AbstractBuilder}.
+     * @since 2.16.0
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /** The current count of bytes counted. */
     private long count;
 
-    /** The marked position. */
-    private long mark = EOF;
+    /** The current mark. */
+    private long mark;
 
-    /** Flag if close should be propagated. */
+    /** The max count of bytes to read. */
+    private final long maxCount;
+
+    private final IOBiConsumer<Long, Long> onMaxCount;
+
+    /**
+     * Flag if close should be propagated.
+     *
+     * TODO Make final in 3.0.
+     */
     private boolean propagateClose = true;
 
+    BoundedInputStream(final Builder builder) throws IOException {
+        super(builder);
+        this.count = builder.getCount();
+        this.maxCount = builder.getMaxCount();
+        this.propagateClose = builder.isPropagateClose();
+        this.onMaxCount = builder.getOnMaxCount();
+    }
+
     /**
-     * Constructs a new {@link BoundedInputStream} that wraps the given input
-     * stream and is unlimited.
+     * Constructs a new {@link BoundedInputStream} that wraps the given input stream and is unlimited.
      *
      * @param in The wrapped input stream.
+     * @deprecated Use {@link AbstractBuilder#get()}.
      */
+    @Deprecated
     public BoundedInputStream(final InputStream in) {
         this(in, EOF);
     }
 
+    BoundedInputStream(final InputStream inputStream, final Builder builder) {
+        super(inputStream, builder);
+        this.count = builder.getCount();
+        this.maxCount = builder.getMaxCount();
+        this.propagateClose = builder.isPropagateClose();
+        this.onMaxCount = builder.getOnMaxCount();
+    }
+
     /**
-     * Constructs a new {@link BoundedInputStream} that wraps the given input
-     * stream and limits it to a certain size.
+     * Constructs a new {@link BoundedInputStream} that wraps the given input stream and limits it to a certain size.
      *
      * @param inputStream The wrapped input stream.
-     * @param maxLength The maximum number of bytes to return.
+     * @param maxCount    The maximum number of bytes to return.
+     * @deprecated Use {@link AbstractBuilder#get()}.
      */
-    public BoundedInputStream(final InputStream inputStream, final long maxLength) {
-        // Some badly designed methods - e.g. the servlet API - overload length
+    @Deprecated
+    public BoundedInputStream(final InputStream inputStream, final long maxCount) {
+        // Some badly designed methods - e.g. the Servlet API - overload length
         // such that "-1" means stream finished
-        super(inputStream);
-        this.maxCount = maxLength;
+        this(inputStream, builder().setMaxCount(maxCount));
+    }
+
+    /**
+     * Adds the number of read bytes to the count.
+     *
+     * @param n number of bytes read, or -1 if no more bytes are available
+     * @throws IOException Not thrown here but subclasses may throw.
+     * @since 2.0
+     */
+    @Override
+    protected synchronized void afterRead(final int n) throws IOException {
+        if (n != EOF) {
+            count += n;
+        }
+        super.afterRead(n);
     }
 
     /**
@@ -75,23 +361,22 @@ public BoundedInputStream(final InputStream inputStream, final long maxLength) {
      */
     @Override
     public int available() throws IOException {
-        if (isMaxLength()) {
-            onMaxLength(maxCount, count);
+        if (isMaxCount()) {
+            onMaxLength(maxCount, getCount());
             return 0;
         }
         return in.available();
     }
 
     /**
-     * Invokes the delegate's {@code close()} method
-     * if {@link #isPropagateClose()} is {@code true}.
+     * Invokes the delegate's {@link InputStream#close()} method if {@link #isPropagateClose()} is {@code true}.
      *
      * @throws IOException if an I/O error occurs.
      */
     @Override
     public void close() throws IOException {
         if (propagateClose) {
-            in.close();
+            super.close();
         }
     }
 
@@ -101,49 +386,68 @@ public void close() throws IOException {
      * @return The count of bytes read.
      * @since 2.12.0
      */
-    public long getCount() {
+    public synchronized long getCount() {
         return count;
     }
 
+    /**
+     * Gets the max count of bytes to read.
+     *
+     * @return The max count of bytes to read.
+     * @since 2.16.0
+     */
+    public long getMaxCount() {
+        return maxCount;
+    }
+
     /**
      * Gets the max count of bytes to read.
      *
      * @return The max count of bytes to read.
      * @since 2.12.0
+     * @deprecated Use {@link #getMaxCount()}.
      */
+    @Deprecated
     public long getMaxLength() {
         return maxCount;
     }
 
-    private boolean isMaxLength() {
-        return maxCount >= 0 && count >= maxCount;
+    /**
+     * Gets how many bytes remain to read.
+     *
+     * @return bytes how many bytes remain to read.
+     * @since 2.16.0
+     */
+    public long getRemaining() {
+        return Math.max(0, getMaxCount() - getCount());
+    }
+
+    private boolean isMaxCount() {
+        return maxCount >= 0 && getCount() >= maxCount;
     }
 
     /**
-     * Tests whether the {@link #close()} method
-     * should propagate to the underling {@link InputStream}.
+     * Tests whether the {@link #close()} method should propagate to the underling {@link InputStream}.
      *
-     * @return {@code true} if calling {@link #close()}
-     * propagates to the {@code close()} method of the
-     * underlying stream or {@code false} if it does not.
+     * @return {@code true} if calling {@link #close()} propagates to the {@code close()} method of the underlying stream or {@code false} if it does not.
      */
     public boolean isPropagateClose() {
         return propagateClose;
     }
 
     /**
-     * Invokes the delegate's {@code mark(int)} method.
+     * Invokes the delegate's {@link InputStream#mark(int)} method.
      *
-     * @param readlimit read ahead limit
+     * @param readLimit read ahead limit
      */
     @Override
-    public synchronized void mark(final int readlimit) {
-        in.mark(readlimit);
+    public synchronized void mark(final int readLimit) {
+        in.mark(readLimit);
         mark = count;
     }
 
     /**
-     * Invokes the delegate's {@code markSupported()} method.
+     * Invokes the delegate's {@link InputStream#markSupported()} method.
      *
      * @return true if mark is supported, otherwise false
      */
@@ -154,77 +458,68 @@ public boolean markSupported() {
 
     /**
      * A caller has caused a request that would cross the {@code maxLength} boundary.
+     * <p>
+     * Delegates to the consumer set in {@link Builder#setOnMaxCount(IOBiConsumer)}.
+     * </p>
      *
-     * @param maxLength The max count of bytes to read.
-     * @param count The count of bytes read.
+     * @param max The max count of bytes to read.
+     * @param count     The count of bytes read.
      * @throws IOException Subclasses may throw.
      * @since 2.12.0
      */
-    protected void onMaxLength(final long maxLength, final long count) throws IOException {
-        // for subclasses
+    @SuppressWarnings("unused")
+    // TODO Rename to onMaxCount for 3.0
+    protected void onMaxLength(final long max, final long count) throws IOException {
+        onMaxCount.accept(max, count);
     }
 
     /**
-     * Invokes the delegate's {@code read()} method if
-     * the current position is less than the limit.
+     * Invokes the delegate's {@link InputStream#read()} method if the current position is less than the limit.
      *
-     * @return the byte read or -1 if the end of stream or
-     * the limit has been reached.
+     * @return the byte read or -1 if the end of stream or the limit has been reached.
      * @throws IOException if an I/O error occurs.
      */
     @Override
     public int read() throws IOException {
-        if (isMaxLength()) {
-            onMaxLength(maxCount, count);
+        if (isMaxCount()) {
+            onMaxLength(maxCount, getCount());
             return EOF;
         }
-        final int result = in.read();
-        count++;
-        return result;
+        return super.read();
     }
 
     /**
-     * Invokes the delegate's {@code read(byte[])} method.
+     * Invokes the delegate's {@link InputStream#read(byte[])} method.
      *
      * @param b the buffer to read the bytes into
-     * @return the number of bytes read or -1 if the end of stream or
-     * the limit has been reached.
+     * @return the number of bytes read or -1 if the end of stream or the limit has been reached.
      * @throws IOException if an I/O error occurs.
      */
     @Override
     public int read(final byte[] b) throws IOException {
-        return this.read(b, 0, b.length);
+        return read(b, 0, b.length);
     }
 
     /**
-     * Invokes the delegate's {@code read(byte[], int, int)} method.
+     * Invokes the delegate's {@link InputStream#read(byte[], int, int)} method.
      *
-     * @param b the buffer to read the bytes into
+     * @param b   the buffer to read the bytes into
      * @param off The start offset
      * @param len The number of bytes to read
-     * @return the number of bytes read or -1 if the end of stream or
-     * the limit has been reached.
+     * @return the number of bytes read or -1 if the end of stream or the limit has been reached.
      * @throws IOException if an I/O error occurs.
      */
     @Override
     public int read(final byte[] b, final int off, final int len) throws IOException {
-        if (isMaxLength()) {
-            onMaxLength(maxCount, count);
-            return EOF;
-        }
-        final long maxRead = maxCount >= 0 ? Math.min(len, maxCount - count) : len;
-        final int bytesRead = in.read(b, off, (int) maxRead);
-
-        if (bytesRead == EOF) {
+        if (isMaxCount()) {
+            onMaxLength(maxCount, getCount());
             return EOF;
         }
-
-        count += bytesRead;
-        return bytesRead;
+        return super.read(b, off, (int) toReadLen(len));
     }
 
     /**
-     * Invokes the delegate's {@code reset()} method.
+     * Invokes the delegate's {@link InputStream#reset()} method.
      *
      * @throws IOException if an I/O error occurs.
      */
@@ -235,37 +530,39 @@ public synchronized void reset() throws IOException {
     }
 
     /**
-     * Sets whether the {@link #close()} method
-     * should propagate to the underling {@link InputStream}.
+     * Sets whether the {@link #close()} method should propagate to the underling {@link InputStream}.
      *
-     * @param propagateClose {@code true} if calling
-     * {@link #close()} propagates to the {@code close()}
-     * method of the underlying stream or
-     * {@code false} if it does not.
+     * @param propagateClose {@code true} if calling {@link #close()} propagates to the {@code close()} method of the underlying stream or {@code false} if it
+     *                       does not.
+     * @deprecated Use {@link AbstractBuilder#setPropagateClose(boolean)}.
      */
+    @Deprecated
     public void setPropagateClose(final boolean propagateClose) {
         this.propagateClose = propagateClose;
     }
 
     /**
-     * Invokes the delegate's {@code skip(long)} method.
+     * Invokes the delegate's {@link InputStream#skip(long)} method.
      *
      * @param n the number of bytes to skip
      * @return the actual number of bytes skipped
      * @throws IOException if an I/O error occurs.
      */
     @Override
-    public long skip(final long n) throws IOException {
-        final long toSkip = maxCount >= 0 ? Math.min(n, maxCount - count) : n;
-        final long skippedBytes = in.skip(toSkip);
-        count += skippedBytes;
-        return skippedBytes;
+    public synchronized long skip(final long n) throws IOException {
+        final long skip = super.skip(toReadLen(n));
+        count += skip;
+        return skip;
+    }
+
+    private long toReadLen(final long len) {
+        return maxCount >= 0 ? Math.min(len, maxCount - getCount()) : len;
     }
 
     /**
-     * Invokes the delegate's {@code toString()} method.
+     * Invokes the delegate's {@link InputStream#toString()} method.
      *
-     * @return the delegate's {@code toString()}
+     * @return the delegate's {@link InputStream#toString()}
      */
     @Override
     public String toString() {
diff --git a/src/main/java/org/apache/commons/io/input/BoundedReader.java b/src/main/java/org/apache/commons/io/input/BoundedReader.java
index 6a226e22..80423f90 100644
--- a/src/main/java/org/apache/commons/io/input/BoundedReader.java
+++ b/src/main/java/org/apache/commons/io/input/BoundedReader.java
@@ -28,7 +28,7 @@
  * when this limit is reached, regardless of state of underlying reader.
  *
  * <p>
- * One use case is to avoid overrunning the readAheadLimit supplied to {@link java.io.Reader#mark(int)}, since reading
+ * One use case is to avoid overrunning the readAheadLimit supplied to {@link Reader#mark(int)}, since reading
  * too many characters removes the ability to do a successful reset.
  * </p>
  *
diff --git a/src/main/java/org/apache/commons/io/input/BrokenInputStream.java b/src/main/java/org/apache/commons/io/input/BrokenInputStream.java
index 5eabb977..4a375f26 100644
--- a/src/main/java/org/apache/commons/io/input/BrokenInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/BrokenInputStream.java
@@ -20,8 +20,10 @@
 import java.io.InputStream;
 import java.util.function.Supplier;
 
+import org.apache.commons.io.function.Erase;
+
 /**
- * Always throws an {@link IOException} from all the {@link InputStream} methods where the exception is declared.
+ * Always throws an exception from all {@link InputStream} methods where {@link IOException} is declared.
  * <p>
  * This class is mostly useful for testing error handling.
  * </p>
@@ -31,7 +33,7 @@
 public class BrokenInputStream extends InputStream {
 
     /**
-     * The singleton instance.
+     * The singleton instance using a default IOException.
      *
      * @since 2.12.0
      */
@@ -40,7 +42,7 @@ public class BrokenInputStream extends InputStream {
     /**
      * A supplier for the exception that is thrown by all methods of this class.
      */
-    private final Supplier<IOException> exceptionSupplier;
+    private final Supplier<Throwable> exceptionSupplier;
 
     /**
      * Constructs a new stream that always throws an {@link IOException}.
@@ -53,73 +55,103 @@ public BrokenInputStream() {
      * Constructs a new stream that always throws the given exception.
      *
      * @param exception the exception to be thrown.
+     * @deprecated Use {@link #BrokenInputStream(Throwable)}.
      */
+    @Deprecated
     public BrokenInputStream(final IOException exception) {
         this(() -> exception);
     }
 
     /**
-     * Constructs a new stream that always throws an {@link IOException}.
+     * Constructs a new stream that always throws the supplied exception.
      *
-     * @param exceptionSupplier a supplier for the exception to be thrown.
+     * @param exceptionSupplier a supplier for the IOException or RuntimeException to be thrown.
      * @since 2.12.0
      */
-    public BrokenInputStream(final Supplier<IOException> exceptionSupplier) {
+    public BrokenInputStream(final Supplier<Throwable> exceptionSupplier) {
         this.exceptionSupplier = exceptionSupplier;
     }
 
+    /**
+     * Constructs a new stream that always throws the given exception.
+     *
+     * @param exception the exception to be thrown.
+     * @since 2.16.0
+     */
+    public BrokenInputStream(final Throwable exception) {
+        this(() -> exception);
+    }
+
     /**
      * Throws the configured exception.
      *
-     * @return nothing
-     * @throws IOException always thrown
+     * @return nothing.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public int available() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void close() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
+    }
+
+    /**
+     * Gets the Throwable to throw. Package-private for testing.
+     *
+     * @return  the Throwable to throw.
+     */
+    Throwable getThrowable() {
+        return exceptionSupplier.get();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @return nothing
-     * @throws IOException always thrown
+     * @return nothing.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public int read() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public synchronized void reset() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
+    }
+
+    /**
+     * Throws the configured exception from its supplier.
+     *
+     * @return Throws the configured exception from its supplier.
+     */
+    private RuntimeException rethrow() {
+        return Erase.rethrow(getThrowable());
     }
 
     /**
      * Throws the configured exception.
      *
-     * @param n ignored
-     * @return nothing
-     * @throws IOException always thrown
+     * @param n ignored.
+     * @return nothing.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public long skip(final long n) throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/input/BrokenReader.java b/src/main/java/org/apache/commons/io/input/BrokenReader.java
index 03530e8c..1b28408a 100644
--- a/src/main/java/org/apache/commons/io/input/BrokenReader.java
+++ b/src/main/java/org/apache/commons/io/input/BrokenReader.java
@@ -20,8 +20,10 @@
 import java.io.Reader;
 import java.util.function.Supplier;
 
+import org.apache.commons.io.function.Erase;
+
 /**
- * Always throws an {@link IOException} from all the {@link Reader} methods where the exception is declared.
+ * Always throws an exception from all {@link Reader} methods where {@link IOException} is declared.
  * <p>
  * This class is mostly useful for testing error handling.
  * </p>
@@ -40,7 +42,7 @@ public class BrokenReader extends Reader {
     /**
      * A supplier for the exception that is thrown by all methods of this class.
      */
-    private final Supplier<IOException> exceptionSupplier;
+    private final Supplier<Throwable> exceptionSupplier;
 
     /**
      * Constructs a new reader that always throws an {@link IOException}.
@@ -53,87 +55,108 @@ public BrokenReader() {
      * Constructs a new reader that always throws the given exception.
      *
      * @param exception the exception to be thrown.
+     * @deprecated Use {@link #BrokenReader(Throwable)}.
      */
+    @Deprecated
     public BrokenReader(final IOException exception) {
         this(() -> exception);
     }
 
     /**
-     * Constructs a new reader that always throws an {@link IOException}
+     * Constructs a new reader that always throws the supplied exception.
      *
-     * @param exceptionSupplier a supplier for the exception to be thrown.
+     * @param exceptionSupplier a supplier for the IOException or RuntimeException to be thrown.
      * @since 2.12.0
      */
-    public BrokenReader(final Supplier<IOException> exceptionSupplier) {
+    public BrokenReader(final Supplier<Throwable> exceptionSupplier) {
         this.exceptionSupplier = exceptionSupplier;
     }
 
+    /**
+     * Constructs a new reader that always throws the given exception.
+     *
+     * @param exception the exception to be thrown.
+     * @since 2.16.0
+     */
+    public BrokenReader(final Throwable exception) {
+        this(() -> exception);
+    }
+
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void close() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @param readAheadLimit ignored
-     * @throws IOException always thrown
+     * @param readAheadLimit ignored.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void mark(final int readAheadLimit) throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @param cbuf ignored
-     * @param off  ignored
-     * @param len  ignored
-     * @return nothing
-     * @throws IOException always thrown
+     * @param cbuf ignored.
+     * @param off  ignored.
+     * @param len  ignored.
+     * @return nothing.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public int read(final char[] cbuf, final int off, final int len) throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @return nothing
-     * @throws IOException always thrown
+     * @return nothing.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public boolean ready() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
-    public synchronized void reset() throws IOException {
-        throw exceptionSupplier.get();
+    public void reset() throws IOException {
+        throw rethrow();
+    }
+
+    /**
+     * Throws the configured exception from its supplier.
+     *
+     * @return Throws the configured exception from its supplier.
+     */
+    private RuntimeException rethrow() {
+        return Erase.rethrow(exceptionSupplier.get());
     }
 
     /**
      * Throws the configured exception.
      *
-     * @param n ignored
-     * @return nothing
-     * @throws IOException always thrown
+     * @param n ignored.
+     * @return nothing.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public long skip(final long n) throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java b/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java
index 182090da..b92eba0a 100644
--- a/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java
@@ -15,6 +15,7 @@
 
 import static org.apache.commons.io.IOUtils.EOF;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -25,30 +26,31 @@
 import java.util.Objects;
 
 import org.apache.commons.io.IOUtils;
-import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
  * {@link InputStream} implementation which uses direct buffer to read a file to avoid extra copy of data between Java and native memory which happens when
- * using {@link java.io.BufferedInputStream}. Unfortunately, this is not something already available in JDK, {@code sun.nio.ch.ChannelInputStream} supports
+ * using {@link BufferedInputStream}. Unfortunately, this is not something already available in JDK, {@code sun.nio.ch.ChannelInputStream} supports
  * reading a file using NIO, but does not support buffering.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * This class was ported and adapted from Apache Spark commit 933dc6cb7b3de1d8ccaf73d124d6eb95b947ed19 where it was called {@code NioBufferedFileInputStream}.
  * </p>
  *
+ * @see Builder
  * @since 2.9.0
  */
 public final class BufferedFileChannelInputStream extends InputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link BufferedFileChannelInputStream} instance.
+     * Builds a new {@link BufferedFileChannelInputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
-     *
      * <pre>{@code
      * BufferedFileChannelInputStream s = BufferedFileChannelInputStream.builder()
      *   .setFile(file)
@@ -58,7 +60,6 @@ public final class BufferedFileChannelInputStream extends InputStream {
      * <p>
      * Using NIO Path:
      * </p>
-     *
      * <pre>{@code
      * BufferedFileChannelInputStream s = BufferedFileChannelInputStream.builder()
      *   .setPath(path)
@@ -66,27 +67,53 @@ public final class BufferedFileChannelInputStream extends InputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<BufferedFileChannelInputStream, Builder> {
 
+        private FileChannel fileChannel;
+
         /**
-         * Constructs a new instance.
+         * Builds a new {@link BufferedFileChannelInputStream}.
          * <p>
-         * This builder use the aspects Path and buffer size.
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Path by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide a Path.
-         * @see AbstractOrigin#getPath()
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to a {@link Path}.
+         * @throws IOException If an I/O error occurs
+         * @see #getPath()
+         * @see #getBufferSize()
          */
         @Override
         public BufferedFileChannelInputStream get() throws IOException {
-            return new BufferedFileChannelInputStream(getPath(), getBufferSize());
+            return fileChannel != null ? new BufferedFileChannelInputStream(fileChannel, getBufferSize())
+                    : new BufferedFileChannelInputStream(getPath(), getBufferSize());
+        }
+
+        /**
+         * Sets the file channel.
+         * <p>
+         * This setting takes precedence over all others.
+         * </p>
+         *
+         * @param fileChannel the file channel.
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder setFileChannel(final FileChannel fileChannel) {
+            this.fileChannel = fileChannel;
+            return this;
         }
 
     }
@@ -130,6 +157,12 @@ public BufferedFileChannelInputStream(final File file, final int bufferSize) thr
         this(file.toPath(), bufferSize);
     }
 
+    private BufferedFileChannelInputStream(final FileChannel fileChannel, final int bufferSize) {
+        this.fileChannel = Objects.requireNonNull(fileChannel, "path");
+        byteBuffer = ByteBuffer.allocateDirect(bufferSize);
+        byteBuffer.flip();
+    }
+
     /**
      * Constructs a new instance for the given Path.
      *
@@ -150,16 +183,20 @@ public BufferedFileChannelInputStream(final Path path) throws IOException {
      * @throws IOException If an I/O error occurs
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
+    @SuppressWarnings("resource")
     @Deprecated
     public BufferedFileChannelInputStream(final Path path, final int bufferSize) throws IOException {
-        Objects.requireNonNull(path, "path");
-        fileChannel = FileChannel.open(path, StandardOpenOption.READ);
-        byteBuffer = ByteBuffer.allocateDirect(bufferSize);
-        byteBuffer.flip();
+        this(FileChannel.open(path, StandardOpenOption.READ), bufferSize);
     }
 
     @Override
     public synchronized int available() throws IOException {
+        if (!fileChannel.isOpen()) {
+            return 0;
+        }
+        if (!refill()) {
+            return 0;
+        }
         return byteBuffer.remaining();
     }
 
@@ -228,6 +265,7 @@ public synchronized int read(final byte[] b, final int offset, int len) throws I
      * @throws IOException if an I/O error occurs.
      */
     private boolean refill() throws IOException {
+        Input.checkOpen(fileChannel.isOpen());
         if (!byteBuffer.hasRemaining()) {
             byteBuffer.clear();
             int nRead = 0;
diff --git a/src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java b/src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java
index 72b1b1e8..6126b2a5 100644
--- a/src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java
+++ b/src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java
@@ -25,14 +25,14 @@
  * garbage collection. However, this should not be relied upon since it may not occur in a timely fashion -
  * especially since off heap ByeBuffers don't put pressure on the garbage collector.
  * <p>
- * <b>Warning:</b> Do not attempt to use a direct {@link ByteBuffer} that has been cleaned or bad things will happen.
+ * <strong>Warning:</strong> Do not attempt to use a direct {@link ByteBuffer} that has been cleaned or bad things will happen.
  * Don't use this class unless you can ensure that the cleaned buffer will not be accessed anymore.
  * </p>
  * <p>
  * See <a href=https://bugs.openjdk.java.net/browse/JDK-4724038>JDK-4724038</a>
  * </p>
  */
-class ByteBufferCleaner {
+final class ByteBufferCleaner {
 
     private interface Cleaner {
         void clean(ByteBuffer buffer) throws ReflectiveOperationException;
diff --git a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
index a87d08c1..02042462 100644
--- a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
@@ -37,17 +37,24 @@
 import org.apache.commons.io.function.Uncheck;
 
 /**
- * Implements an {@link InputStream} to read from String, StringBuffer, StringBuilder or CharBuffer.
+ * Implements an {@link InputStream} to read bytes from String, StringBuffer, StringBuilder or CharBuffer,
+ * encoded using the specified Charset. The Charset defaults to Charset.defaultCharset().
  * <p>
  * <strong>Note:</strong> Supports {@link #mark(int)} and {@link #reset()}.
  * </p>
+ * <p>
+ * To build an instance, use {@link Builder}.
+ * </p>
  *
+ * @see Builder
  * @since 2.2
  */
 public class CharSequenceInputStream extends InputStream {
 
+    //@formatter:off
     /**
-     * Builds a new {@link CharSequenceInputStream} instance.
+     * Builds a new {@link CharSequenceInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -70,17 +77,27 @@ public class CharSequenceInputStream extends InputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.13.0
      */
+    //@formatter:on
     public static class Builder extends AbstractStreamBuilder<CharSequenceInputStream, Builder> {
 
         private CharsetEncoder charsetEncoder = newEncoder(getCharset());
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link CharSequenceInputStream}.
+         * <p>
+         * You must set input that supports {@link #getCharSequence()}, otherwise, this method throws an exception.
+         * </p>
          * <p>
-         * This builder use the aspects the CharSequence, buffer size, and Charset.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getCharSequence()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>{@link CharsetEncoder}</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws IllegalArgumentException if the buffer is not large enough to hold a complete character.
@@ -105,7 +122,7 @@ public Builder setCharset(final Charset charset) {
          * Sets the charset encoder. Assumes that the caller has configured the encoder.
          *
          * @param newEncoder the charset encoder.
-         * @return this
+         * @return {@code this} instance.
          * @since 2.13.0
          */
         public Builder setCharsetEncoder(final CharsetEncoder newEncoder) {
@@ -179,6 +196,15 @@ private CharSequenceInputStream(final CharSequence cs, final int bufferSize, fin
         this.cBuf = CharBuffer.wrap(cs);
         this.cBufMark = NO_MARK;
         this.bBufMark = NO_MARK;
+        try {
+            fillBuffer();
+        } catch (final CharacterCodingException ex) {
+            // Reset everything without filling the buffer
+            // so the same exception can be thrown again later.
+            this.bBuf.clear();
+            this.bBuf.flip();
+            this.cBuf.rewind();
+        }
     }
 
     /**
@@ -209,23 +235,19 @@ public CharSequenceInputStream(final CharSequence cs, final String charset, fina
     }
 
     /**
-     * Return an estimate of the number of bytes remaining in the byte stream.
-     * @return the count of bytes that can be read without blocking (or returning EOF).
+     * Gets a lower bound on the number of bytes remaining in the byte stream.
      *
+     * @return the count of bytes that can be read without blocking (or returning EOF).
      * @throws IOException if an error occurs (probably not possible).
      */
     @Override
     public int available() throws IOException {
-        // The cached entries are in bBuf; since encoding always creates at least one byte
-        // per character, we can add the two to get a better estimate (e.g. if bBuf is empty)
-        // Note that the implementation in 2.4 could return zero even though there were
-        // encoded bytes still available.
-        return this.bBuf.remaining() + this.cBuf.remaining();
+        return this.bBuf.remaining();
     }
 
     @Override
     public void close() throws IOException {
-        // noop
+        bBuf.position(bBuf.limit());
     }
 
     /**
@@ -254,10 +276,10 @@ CharsetEncoder getCharsetEncoder() {
 
     /**
      * {@inheritDoc}
-     * @param readlimit max read limit (ignored).
+     * @param readLimit max read limit (ignored).
      */
     @Override
-    public synchronized void mark(final int readlimit) {
+    public synchronized void mark(final int readLimit) {
         this.cBufMark = this.cBuf.position();
         this.bBufMark = this.bBuf.position();
         this.cBuf.mark();
@@ -353,6 +375,7 @@ public synchronized void reset() throws IOException {
             this.cBufMark = NO_MARK;
             this.bBufMark = NO_MARK;
         }
+        mark(0);
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/io/input/CharSequenceReader.java b/src/main/java/org/apache/commons/io/input/CharSequenceReader.java
index f77777ae..132ec5e7 100644
--- a/src/main/java/org/apache/commons/io/input/CharSequenceReader.java
+++ b/src/main/java/org/apache/commons/io/input/CharSequenceReader.java
@@ -38,8 +38,14 @@
 public class CharSequenceReader extends Reader implements Serializable {
 
     private static final long serialVersionUID = 3724187752191401220L;
+
+    /** Source for reading. */
     private final CharSequence charSequence;
+
+    /** Reading index. */
     private int idx;
+
+    /** Reader mark. */
     private int mark;
 
     /**
@@ -237,7 +243,7 @@ public int read(final char[] array, final int offset, final int length) {
             if (c == EOF) {
                 return count;
             }
-            array[offset + i] = (char)c;
+            array[offset + i] = (char) c;
             count++;
         }
         return count;
@@ -292,14 +298,13 @@ private int start() {
     }
 
     /**
-     * Return a String representation of the underlying
+     * Gets a String representation of the underlying
      * character sequence.
      *
      * @return The contents of the character sequence
      */
     @Override
     public String toString() {
-        final CharSequence subSequence = charSequence.subSequence(start(), end());
-        return subSequence.toString();
+        return charSequence.subSequence(start(), end()).toString();
     }
 }
diff --git a/src/main/java/org/apache/commons/io/input/ChecksumInputStream.java b/src/main/java/org/apache/commons/io/input/ChecksumInputStream.java
new file mode 100644
index 00000000..0f9a213a
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/input/ChecksumInputStream.java
@@ -0,0 +1,248 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Objects;
+import java.util.zip.CheckedInputStream;
+import java.util.zip.Checksum;
+
+/**
+ * Automatically verifies a {@link Checksum} value once the stream is exhausted or the count threshold is reached.
+ * <p>
+ * If the {@link Checksum} does not meet the expected value when exhausted, then the input stream throws an
+ * {@link IOException}.
+ * </p>
+ * <p>
+ * If you do not need the verification or threshold feature, then use a plain {@link CheckedInputStream}.
+ * </p>
+ * <p>
+ * To build an instance, use {@link Builder}.
+ * </p>
+ *
+ * @see Builder
+ * @since 2.16.0
+ */
+public final class ChecksumInputStream extends CountingInputStream {
+
+    // @formatter:off
+    /**
+     * Builds a new {@link ChecksumInputStream}.
+     *
+     * <p>
+     * There is no default {@link Checksum}; you MUST provide one. This avoids any issue with a default {@link Checksum} being proven deficient or insecure
+     * in the future.
+     * </p>
+     * <h2>Using NIO</h2>
+     * <pre>{@code
+     * ChecksumInputStream s = ChecksumInputStream.builder()
+     *   .setPath(Paths.get("MyFile.xml"))
+     *   .setChecksum(new CRC32())
+     *   .setExpectedChecksumValue(12345)
+     *   .get();
+     * }</pre>
+     * <h2>Using IO</h2>
+     * <pre>{@code
+     * ChecksumInputStream s = ChecksumInputStream.builder()
+     *   .setFile(new File("MyFile.xml"))
+     *   .setChecksum(new CRC32())
+     *   .setExpectedChecksumValue(12345)
+     *   .get();
+     * }</pre>
+     * <h2>Validating only part of an InputStream</h2>
+     * <p>
+     * The following validates the first 100 bytes of the given input.
+     * </p>
+     * <pre>{@code
+     * ChecksumInputStream s = ChecksumInputStream.builder()
+     *   .setPath(Paths.get("MyFile.xml"))
+     *   .setChecksum(new CRC32())
+     *   .setExpectedChecksumValue(12345)
+     *   .setCountThreshold(100)
+     *   .get();
+     * }</pre>
+     * <p>
+     * To validate input <em>after</em> the beginning of a stream, build an instance with an InputStream starting where you want to validate.
+     * </p>
+     * <pre>{@code
+     * InputStream inputStream = ...;
+     * inputStream.read(...);
+     * inputStream.skip(...);
+     * ChecksumInputStream s = ChecksumInputStream.builder()
+     *   .setInputStream(inputStream)
+     *   .setChecksum(new CRC32())
+     *   .setExpectedChecksumValue(12345)
+     *   .setCountThreshold(100)
+     *   .get();
+     * }</pre>
+     *
+     * @see #get()
+     */
+    // @formatter:on
+    public static class Builder extends AbstractBuilder<ChecksumInputStream, Builder> {
+
+        /**
+         * There is no default {@link Checksum}, you MUST provide one. This avoids any issue with a default {@link Checksum} being proven deficient or insecure
+         * in the future.
+         */
+        private Checksum checksum;
+
+        /**
+         * The count threshold to limit how much input is consumed to update the {@link Checksum} before the input
+         * stream validates its value.
+         * <p>
+         * By default, all input updates the {@link Checksum}.
+         * </p>
+         */
+        private long countThreshold = -1;
+
+        /**
+         * The expected {@link Checksum} value once the stream is exhausted or the count threshold is reached.
+         */
+        private long expectedChecksumValue;
+
+        /**
+         * Builds a new {@link ChecksumInputStream}.
+         * <p>
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
+         * </p>
+         * <p>
+         * This builder use the following aspects:
+         * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link Checksum}</li>
+         * <li>expectedChecksumValue</li>
+         * <li>countThreshold</li>
+         * </ul>
+         *
+         * @return a new instance.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
+         * @see #getInputStream()
+         */
+        @Override
+        public ChecksumInputStream get() throws IOException {
+            return new ChecksumInputStream(this);
+        }
+
+        /**
+         * Sets the Checksum. There is no default {@link Checksum}, you MUST provide one. This avoids any issue with a default {@link Checksum} being proven
+         * deficient or insecure in the future.
+         *
+         * @param checksum the Checksum.
+         * @return {@code this} instance.
+         */
+        public Builder setChecksum(final Checksum checksum) {
+            this.checksum = checksum;
+            return this;
+        }
+
+        /**
+         * Sets the count threshold to limit how much input is consumed to update the {@link Checksum} before the input
+         * stream validates its value.
+         * <p>
+         * By default, all input updates the {@link Checksum}.
+         * </p>
+         *
+         * @param countThreshold the count threshold. A negative number means the threshold is unbound.
+         * @return {@code this} instance.
+         */
+        public Builder setCountThreshold(final long countThreshold) {
+            this.countThreshold = countThreshold;
+            return this;
+        }
+
+        /**
+         * The expected {@link Checksum} value once the stream is exhausted or the count threshold is reached.
+         *
+         * @param expectedChecksumValue The expected Checksum value.
+         * @return {@code this} instance.
+         */
+        public Builder setExpectedChecksumValue(final long expectedChecksumValue) {
+            this.expectedChecksumValue = expectedChecksumValue;
+            return this;
+        }
+
+    }
+
+    /**
+     * Constructs a new {@link Builder}.
+     *
+     * @return a new {@link Builder}.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /** The expected checksum. */
+    private final long expectedChecksumValue;
+
+    /**
+     * The count threshold to limit how much input is consumed to update the {@link Checksum} before the input stream
+     * validates its value.
+     * <p>
+     * By default, all input updates the {@link Checksum}.
+     * </p>
+     */
+    private final long countThreshold;
+
+    /**
+     * Constructs a new instance.
+     *
+     * @param builder build parameters.
+     */
+    @SuppressWarnings("resource")
+    private ChecksumInputStream(final Builder builder) throws IOException {
+        super(new CheckedInputStream(builder.getInputStream(), Objects.requireNonNull(builder.checksum, "builder.checksum")), builder);
+        this.countThreshold = builder.countThreshold;
+        this.expectedChecksumValue = builder.expectedChecksumValue;
+    }
+
+    @Override
+    protected synchronized void afterRead(final int n) throws IOException {
+        super.afterRead(n);
+        if ((countThreshold > 0 && getByteCount() >= countThreshold || n == EOF)
+                && expectedChecksumValue != getChecksum().getValue()) {
+            // Validate when past the threshold or at EOF
+            throw new IOException("Checksum verification failed.");
+        }
+    }
+
+    /**
+     * Gets the current checksum value.
+     *
+     * @return the current checksum value.
+     */
+    private Checksum getChecksum() {
+        return ((CheckedInputStream) in).getChecksum();
+    }
+
+    /**
+     * Gets the byte count remaining to read.
+     *
+     * @return bytes remaining to read, a negative number means the threshold is unbound.
+     */
+    public long getRemaining() {
+        return countThreshold - getByteCount();
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/input/CircularInputStream.java b/src/main/java/org/apache/commons/io/input/CircularInputStream.java
index 26d1c3f9..960f7e45 100644
--- a/src/main/java/org/apache/commons/io/input/CircularInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CircularInputStream.java
@@ -32,7 +32,7 @@
  * @see InfiniteCircularInputStream
  * @since 2.8.0
  */
-public class CircularInputStream extends InputStream {
+public class CircularInputStream extends AbstractInputStream {
 
     /**
      * Throws an {@link IllegalArgumentException} if the input contains -1.
@@ -51,7 +51,7 @@ private static byte[] validate(final byte[] repeatContent) {
     }
 
     private long byteCount;
-    private int position = -1;
+    private int position = IOUtils.EOF;
     private final byte[] repeatedContent;
     private final long targetByteCount;
 
@@ -69,9 +69,21 @@ public CircularInputStream(final byte[] repeatContent, final long targetByteCoun
         this.targetByteCount = targetByteCount;
     }
 
+    @Override
+    public int available() throws IOException {
+        // A negative targetByteCount means an infinite target count.
+        return isClosed() ? 0 : targetByteCount <= Integer.MAX_VALUE ? Math.max(Integer.MAX_VALUE, (int) targetByteCount) : Integer.MAX_VALUE;
+    }
+
+    @Override
+    public void close() throws IOException {
+        super.close();
+        byteCount = targetByteCount;
+    }
+
     @Override
     public int read() {
-        if (targetByteCount >= 0) {
+        if (targetByteCount >= 0 || isClosed()) {
             if (byteCount == targetByteCount) {
                 return IOUtils.EOF;
             }
diff --git a/src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java b/src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java
index 03521d90..be92f4ed 100644
--- a/src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java
@@ -30,6 +30,17 @@
  */
 public class CloseShieldInputStream extends ProxyInputStream {
 
+    /**
+     * Constructs a proxy that only shields {@link System#in} from closing.
+     *
+     * @param inputStream the candidate input stream.
+     * @return the given stream or a proxy on {@link System#in}.
+     * @since 2.17.0
+     */
+    public static InputStream systemIn(final InputStream inputStream) {
+        return inputStream == System.in ? wrap(inputStream) : inputStream;
+    }
+
     /**
      * Constructs a proxy that shields the given input stream from being closed.
      *
diff --git a/src/main/java/org/apache/commons/io/input/ClosedInputStream.java b/src/main/java/org/apache/commons/io/input/ClosedInputStream.java
index fc372e34..561965fd 100644
--- a/src/main/java/org/apache/commons/io/input/ClosedInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/ClosedInputStream.java
@@ -18,12 +18,13 @@
 
 import static org.apache.commons.io.IOUtils.EOF;
 
+import java.io.IOException;
 import java.io.InputStream;
 
 import org.apache.commons.io.IOUtils;
 
 /**
- * Always returns {@link IOUtils#EOF} to all attempts to read something from the stream.
+ * Always returns {@link IOUtils#EOF} to all attempts to read something from an input stream.
  * <p>
  * Typically uses of this class include testing for corner cases in methods that accept input streams and acting as a
  * sentinel value instead of a {@code null} input stream.
@@ -48,6 +49,16 @@ public class ClosedInputStream extends InputStream {
     @Deprecated
     public static final ClosedInputStream CLOSED_INPUT_STREAM = INSTANCE;
 
+    /**
+     * Returns {@link #INSTANCE} if the given InputStream is null, otherwise returns the given input stream.
+     *
+     * @param in the InputStream to test.
+     * @return {@link #INSTANCE} if the given InputStream is null, otherwise returns the given input stream.
+     */
+    static InputStream ifNull(final InputStream in) {
+        return in != null ? in : INSTANCE;
+    }
+
     /**
      * Returns -1 to indicate that the stream is closed.
      *
@@ -58,4 +69,17 @@ public int read() {
         return EOF;
     }
 
+    /**
+     * Returns -1 to indicate that the stream is closed.
+     *
+     * @param b ignored.
+     * @param off ignored.
+     * @param len ignored.
+     * @return always -1
+     */
+    @Override
+    public int read(final byte[] b, final int off, final int len) throws IOException {
+        return EOF;
+    }
+
 }
diff --git a/src/main/java/org/apache/commons/io/input/CountingInputStream.java b/src/main/java/org/apache/commons/io/input/CountingInputStream.java
index 4b706f28..790b4897 100644
--- a/src/main/java/org/apache/commons/io/input/CountingInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CountingInputStream.java
@@ -28,10 +28,12 @@
  * A typical use case would be during debugging, to ensure that data is being
  * read as expected.
  * </p>
+ * @deprecated Use {@link BoundedInputStream} (unbounded by default).
  */
+@Deprecated
 public class CountingInputStream extends ProxyInputStream {
 
-    /** The count of bytes that have passed. */
+    /** The count of bytes read. */
     private long count;
 
     /**
@@ -43,18 +45,27 @@ public CountingInputStream(final InputStream in) {
         super(in);
     }
 
+    CountingInputStream(final InputStream in, final ProxyInputStream.AbstractBuilder<?, ?> builder) {
+        super(in, builder);
+    }
+
+    CountingInputStream(final ProxyInputStream.AbstractBuilder<?, ?> builder) throws IOException {
+        super(builder);
+    }
 
     /**
      * Adds the number of read bytes to the count.
      *
      * @param n number of bytes read, or -1 if no more bytes are available
+     * @throws IOException Not thrown here but subclasses may throw.
      * @since 2.0
      */
     @Override
-    protected synchronized void afterRead(final int n) {
+    protected synchronized void afterRead(final int n) throws IOException {
         if (n != EOF) {
-            this.count += n;
+            count += n;
         }
+        super.afterRead(n);
     }
 
     /**
@@ -69,20 +80,22 @@ protected synchronized void afterRead(final int n) {
      * @since 1.3
      */
     public synchronized long getByteCount() {
-        return this.count;
+        return count;
     }
 
     /**
      * Gets number of bytes that have passed through this stream.
      * <p>
-     * NOTE: From v1.3 this method throws an ArithmeticException if the
+     * This method throws an ArithmeticException if the
      * count is greater than can be expressed by an {@code int}.
      * See {@link #getByteCount()} for a method using a {@code long}.
      * </p>
      *
      * @return the number of bytes accumulated
      * @throws ArithmeticException if the byte count is too large
+     * @deprecated Use {@link #getByteCount()}.
      */
+    @Deprecated
     public int getCount() {
         final long result = getByteCount();
         if (result > Integer.MAX_VALUE) {
@@ -103,22 +116,24 @@ public int getCount() {
      * @since 1.3
      */
     public synchronized long resetByteCount() {
-        final long tmp = this.count;
-        this.count = 0;
+        final long tmp = count;
+        count = 0;
         return tmp;
     }
 
     /**
      * Resets the byte count back to 0.
      * <p>
-     * NOTE: From v1.3 this method throws an ArithmeticException if the
+     * This method throws an ArithmeticException if the
      * count is greater than can be expressed by an {@code int}.
      * See {@link #resetByteCount()} for a method using a {@code long}.
      * </p>
      *
      * @return the count previous to resetting
      * @throws ArithmeticException if the byte count is too large
+     * @deprecated Use {@link #resetByteCount()}.
      */
+    @Deprecated
     public int resetCount() {
         final long result = resetByteCount();
         if (result > Integer.MAX_VALUE) {
@@ -139,7 +154,7 @@ public int resetCount() {
     @Override
     public synchronized long skip(final long length) throws IOException {
         final long skip = super.skip(length);
-        this.count += skip;
+        count += skip;
         return skip;
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/DemuxInputStream.java b/src/main/java/org/apache/commons/io/input/DemuxInputStream.java
index 451f4ce7..0dfdce4a 100644
--- a/src/main/java/org/apache/commons/io/input/DemuxInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/DemuxInputStream.java
@@ -59,7 +59,6 @@ public void close() throws IOException {
      * @return the byte read from stream
      * @throws IOException if an error occurs
      */
-    @SuppressWarnings("resource")
     @Override
     public int read() throws IOException {
         final InputStream inputStream = inputStreamLocal.get();
diff --git a/src/main/java/org/apache/commons/io/input/Input.java b/src/main/java/org/apache/commons/io/input/Input.java
new file mode 100644
index 00000000..9af87a68
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/input/Input.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+
+/**
+ * Package-wide internals for input.
+ */
+class Input {
+
+    /**
+     * Throws an IOException on false input.
+     *
+     * @param isOpen whether an input is open or not.
+     * @throws IOException if {@code isOpen} is false indicating an input is closed.
+     */
+    static void checkOpen(final boolean isOpen) throws IOException {
+        if (!isOpen) {
+            throw new IOException("Closed");
+        }
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/input/MarkShieldInputStream.java b/src/main/java/org/apache/commons/io/input/MarkShieldInputStream.java
index 97653fc1..20e56051 100644
--- a/src/main/java/org/apache/commons/io/input/MarkShieldInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/MarkShieldInputStream.java
@@ -16,11 +16,12 @@
  */
 package org.apache.commons.io.input;
 
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 /**
- * This is an alternative to {@link java.io.ByteArrayInputStream}
+ * This is an alternative to {@link ByteArrayInputStream}
  * which removes the synchronization overhead for non-concurrent
  * access; as such this class is not thread-safe.
  *
@@ -47,7 +48,7 @@ public MarkShieldInputStream(final InputStream in) {
 
     @SuppressWarnings("sync-override")
     @Override
-    public void mark(final int readlimit) {
+    public void mark(final int readLimit) {
         // no-op
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java b/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java
index 3d03f8ce..4363d959 100644
--- a/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java
@@ -27,7 +27,6 @@
 import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 
-import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
@@ -44,7 +43,7 @@
  * use case, the use of buffering may still further improve performance. For example:
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <pre>{@code
  * BufferedInputStream s = new BufferedInputStream(new GzipInputStream(
@@ -67,12 +66,15 @@
  *     .get());}
  * </pre>
  *
+ * @see Builder
  * @since 2.12.0
  */
-public final class MemoryMappedFileInputStream extends InputStream {
+public final class MemoryMappedFileInputStream extends AbstractInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link MemoryMappedFileInputStream} instance.
+     * Builds a new {@link MemoryMappedFileInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -83,12 +85,14 @@ public final class MemoryMappedFileInputStream extends InputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<MemoryMappedFileInputStream, Builder> {
 
         /**
-         * Constructs a new Builder.
+         * Constructs a new {@link Builder}.
          */
         public Builder() {
             setBufferSizeDefault(DEFAULT_BUFFER_SIZE);
@@ -96,18 +100,24 @@ public Builder() {
         }
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link MemoryMappedFileInputStream}.
          * <p>
-         * This builder use the aspects Path and buffer size.
+         * You must set input that supports {@link #getPath()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Path by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getPath()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide a Path.
-         * @see AbstractOrigin#getPath()
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to a {@link Path}.
+         * @throws IOException                   if an I/O error occurs.
+         * @see #getPath()
+         * @see #getBufferSize()
          */
         @Override
         public MemoryMappedFileInputStream get() throws IOException {
@@ -136,7 +146,6 @@ public static Builder builder() {
     private final int bufferSize;
     private final FileChannel channel;
     private ByteBuffer buffer = EMPTY_BUFFER;
-    private boolean closed;
 
     /**
      * The starting position (within the file) of the next sliding buffer.
@@ -157,6 +166,7 @@ private MemoryMappedFileInputStream(final Path file, final int bufferSize) throw
 
     @Override
     public int available() throws IOException {
+        //return buffer != null ? buffer.remaining(): 0;
         return buffer.remaining();
     }
 
@@ -168,17 +178,11 @@ private void cleanBuffer() {
 
     @Override
     public void close() throws IOException {
-        if (!closed) {
+        if (!isClosed()) {
             cleanBuffer();
-            buffer = null;
+            buffer = EMPTY_BUFFER;
             channel.close();
-            closed = true;
-        }
-    }
-
-    private void ensureOpen() throws IOException {
-        if (closed) {
-            throw new IOException("Stream closed");
+            super.close();
         }
     }
 
@@ -200,7 +204,7 @@ private void nextBuffer() throws IOException {
 
     @Override
     public int read() throws IOException {
-        ensureOpen();
+        checkOpen();
         if (!buffer.hasRemaining()) {
             nextBuffer();
             if (!buffer.hasRemaining()) {
@@ -212,7 +216,7 @@ public int read() throws IOException {
 
     @Override
     public int read(final byte[] b, final int off, final int len) throws IOException {
-        ensureOpen();
+        checkOpen();
         if (!buffer.hasRemaining()) {
             nextBuffer();
             if (!buffer.hasRemaining()) {
@@ -226,7 +230,7 @@ public int read(final byte[] b, final int off, final int len) throws IOException
 
     @Override
     public long skip(final long n) throws IOException {
-        ensureOpen();
+        checkOpen();
         if (n <= 0) {
             return 0;
         }
diff --git a/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java b/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java
index 97d7ff59..0413b411 100644
--- a/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java
@@ -21,15 +21,13 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.Provider;
+import java.util.Arrays;
 import java.util.Objects;
 
-import org.apache.commons.io.build.AbstractStreamBuilder;
-
 /**
- * This class is an example for using an {@link ObservableInputStream}. It creates its own {@link org.apache.commons.io.input.ObservableInputStream.Observer},
- * which calculates a checksum using a {@link MessageDigest}, for example, a SHA-512 sum.
+ * Calculates a checksum using a {@link MessageDigest}, for example, a SHA-512 sum.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * See the MessageDigest section in the <a href= "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest"> Java
@@ -38,13 +36,17 @@
  * <p>
  * <em>Note</em>: Neither {@link ObservableInputStream}, nor {@link MessageDigest}, are thread safe, so is {@link MessageDigestCalculatingInputStream}.
  * </p>
+ *
+ * @see Builder
  * @deprecated Use {@link MessageDigestInputStream}.
  */
 @Deprecated
 public class MessageDigestCalculatingInputStream extends ObservableInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link MessageDigestCalculatingInputStream} instance.
+     * Builds a new {@link MessageDigestCalculatingInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -54,15 +56,23 @@ public class MessageDigestCalculatingInputStream extends ObservableInputStream {
      *   .setMessageDigest("SHA-512")
      *   .get();}
      * </pre>
+     * <p>
+     * <em>The MD5 cryptographic algorithm is weak and should not be used.</em>
+     * </p>
      *
+     * @see #get()
      * @since 2.12.0
      */
-    public static class Builder extends AbstractStreamBuilder<MessageDigestCalculatingInputStream, Builder> {
+    // @formatter:on
+    public static class Builder extends AbstractBuilder<Builder> {
 
         private MessageDigest messageDigest;
 
         /**
-         * Constructs a new Builder.
+         * Constructs a new {@link Builder}.
+         * <p>
+         * The default for compatibility is the MD5 cryptographic algorithm which is weak and should not be used.
+         * </p>
          */
         public Builder() {
             try {
@@ -74,29 +84,35 @@ public Builder() {
         }
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link MessageDigestCalculatingInputStream}.
          * <p>
-         * This builder use the aspects InputStream, OpenOption[], and MessageDigest.
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getPath()}</li>
+         * <li>{@link MessageDigest}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
+         * @throws NullPointerException if messageDigest is null.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getInputStream()
          */
-        @SuppressWarnings("resource")
         @Override
         public MessageDigestCalculatingInputStream get() throws IOException {
-            return new MessageDigestCalculatingInputStream(getInputStream(), messageDigest);
+            setObservers(Arrays.asList(new MessageDigestMaintainingObserver(messageDigest)));
+            return new MessageDigestCalculatingInputStream(this);
         }
 
         /**
          * Sets the message digest.
          * <p>
-         * The MD5 cryptographic algorithm is weak and should not be used.
+         * <em>The MD5 cryptographic algorithm is weak and should not be used.</em>
          * </p>
          *
          * @param messageDigest the message digest.
@@ -108,7 +124,7 @@ public void setMessageDigest(final MessageDigest messageDigest) {
         /**
          * Sets the name of the name of the message digest algorithm.
          * <p>
-         * The MD5 cryptographic algorithm is weak and should not be used.
+         * <em>The MD5 cryptographic algorithm is weak and should not be used.</em>
          * </p>
          *
          * @param algorithm the name of the algorithm. See the MessageDigest section in the
@@ -150,7 +166,7 @@ public void data(final int input) throws IOException {
     }
 
     /**
-     * The default message digest algorithm.
+     * The default message digest algorithm {@code "MD5"}.
      * <p>
      * The MD5 cryptographic algorithm is weak and should not be used.
      * </p>
@@ -168,7 +184,10 @@ public static Builder builder() {
     }
 
     /**
-     * Gets a MessageDigest object that implements the default digest algorithm.
+     * Gets a MessageDigest object that implements the default digest algorithm {@code "MD5"}.
+     * <p>
+     * The MD5 cryptographic algorithm is weak and should not be used.
+     * </p>
      *
      * @return a Message Digest object that implements the default algorithm.
      * @throws NoSuchAlgorithmException if no Provider supports a MessageDigestSpi implementation.
@@ -180,6 +199,11 @@ static MessageDigest getDefaultMessageDigest() throws NoSuchAlgorithmException {
 
     private final MessageDigest messageDigest;
 
+    private MessageDigestCalculatingInputStream(final Builder builder) throws IOException {
+        super(builder);
+        this.messageDigest = builder.messageDigest;
+    }
+
     /**
      * Constructs a new instance, which calculates a signature on the given stream, using a {@link MessageDigest} with the "MD5" algorithm.
      * <p>
diff --git a/src/main/java/org/apache/commons/io/input/MessageDigestInputStream.java b/src/main/java/org/apache/commons/io/input/MessageDigestInputStream.java
index d822256b..b3a0082f 100644
--- a/src/main/java/org/apache/commons/io/input/MessageDigestInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/MessageDigestInputStream.java
@@ -20,15 +20,14 @@
 import java.io.InputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
 import java.util.Objects;
 
-import org.apache.commons.io.build.AbstractStreamBuilder;
-
 /**
  * This class is an example for using an {@link ObservableInputStream}. It creates its own {@link org.apache.commons.io.input.ObservableInputStream.Observer},
  * which calculates a checksum using a {@link MessageDigest}, for example, a SHA-512 sum.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * See the MessageDigest section in the <a href= "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest"> Java
@@ -41,12 +40,15 @@
  * <em>Note</em>: Neither {@link ObservableInputStream}, nor {@link MessageDigest}, are thread safe, so is {@link MessageDigestInputStream}.
  * </p>
  *
+ * @see Builder
  * @since 2.15.0
  */
 public final class MessageDigestInputStream extends ObservableInputStream {
 
+    // @formatter:off
     /**
-     * Builds new {@link MessageDigestInputStream} instances.
+     * Builds new {@link MessageDigestInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -59,46 +61,61 @@ public final class MessageDigestInputStream extends ObservableInputStream {
      * <p>
      * You must specify a message digest algorithm name or instance.
      * </p>
+     * <p>
+     * <em>The MD5 cryptographic algorithm is weak and should not be used.</em>
+     * </p>
+     *
+     * @see #get()
      */
-    public static class Builder extends AbstractStreamBuilder<MessageDigestInputStream, Builder> {
+    // @formatter:on
+    public static class Builder extends AbstractBuilder<Builder> {
 
+        /**
+         * No default by design, call MUST set one.
+         */
         private MessageDigest messageDigest;
 
         /**
-         * Constructs a new Builder.
+         * Constructs a new {@link Builder}.
          */
         public Builder() {
             // empty
         }
 
         /**
-         * Constructs a new instance.
+         * Builds new {@link MessageDigestInputStream}.
          * <p>
-         * This builder use the aspects InputStream, OpenOption[], and MessageDigest.
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getPath()}</li>
+         * <li>{@link MessageDigest}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
+         * @throws NullPointerException if messageDigest is null.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getInputStream()
          */
-        @SuppressWarnings("resource")
         @Override
         public MessageDigestInputStream get() throws IOException {
-            return new MessageDigestInputStream(getInputStream(), messageDigest);
+            setObservers(Arrays.asList(new MessageDigestMaintainingObserver(messageDigest)));
+            return new MessageDigestInputStream(this);
         }
 
         /**
          * Sets the message digest.
          * <p>
-         * The MD5 cryptographic algorithm is weak and should not be used.
+         * <em>The MD5 cryptographic algorithm is weak and should not be used.</em>
          * </p>
          *
          * @param messageDigest the message digest.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setMessageDigest(final MessageDigest messageDigest) {
             this.messageDigest = messageDigest;
@@ -108,13 +125,13 @@ public Builder setMessageDigest(final MessageDigest messageDigest) {
         /**
          * Sets the name of the name of the message digest algorithm.
          * <p>
-         * The MD5 cryptographic algorithm is weak and should not be used.
+         * <em>The MD5 cryptographic algorithm is weak and should not be used.</em>
          * </p>
          *
          * @param algorithm the name of the algorithm. See the MessageDigest section in the
          *                  <a href= "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest"> Java Cryptography
          *                  Architecture Standard Algorithm Name Documentation</a> for information about standard algorithm names.
-         * @return this
+         * @return {@code this} instance.
          * @throws NoSuchAlgorithmException if no Provider supports a MessageDigestSpi implementation for the specified algorithm.
          */
         public Builder setMessageDigest(final String algorithm) throws NoSuchAlgorithmException {
@@ -161,6 +178,9 @@ public static Builder builder() {
         return new Builder();
     }
 
+    /**
+     * A non-null MessageDigest.
+     */
     private final MessageDigest messageDigest;
 
     /**
@@ -169,23 +189,22 @@ public static Builder builder() {
      * The MD5 cryptographic algorithm is weak and should not be used.
      * </p>
      *
-     * @param inputStream   the stream to calculate the message digest for
-     * @param messageDigest the message digest to use
+     * @param builder A builder use to get the stream to calculate the message digest and the message digest to use
      * @throws NullPointerException if messageDigest is null.
      */
-    private MessageDigestInputStream(final InputStream inputStream, final MessageDigest messageDigest) {
-        super(inputStream, new MessageDigestMaintainingObserver(messageDigest));
-        this.messageDigest = messageDigest;
+    private MessageDigestInputStream(final Builder builder) throws IOException {
+        super(builder);
+        this.messageDigest = Objects.requireNonNull(builder.messageDigest, "builder.messageDigest");
     }
 
     /**
-     * Gets the {@link MessageDigest}, which is being used for generating the checksum.
+     * Gets the {@link MessageDigest}, which is being used for generating the checksum, never null.
      * <p>
      * <em>Note</em>: The checksum will only reflect the data, which has been read so far. This is probably not, what you expect. Make sure, that the complete
      * data has been read, if that is what you want. The easiest way to do so is by invoking {@link #consume()}.
      * </p>
      *
-     * @return the message digest used
+     * @return the message digest used, never null.
      */
     public MessageDigest getMessageDigest() {
         return messageDigest;
diff --git a/src/main/java/org/apache/commons/io/input/NullInputStream.java b/src/main/java/org/apache/commons/io/input/NullInputStream.java
index 4b550a71..741b39a6 100644
--- a/src/main/java/org/apache/commons/io/input/NullInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/NullInputStream.java
@@ -23,37 +23,30 @@
 import java.io.InputStream;
 
 /**
- * A functional, light weight {@link InputStream} that emulates
- * a stream of a specified size.
+ * A light weight {@link InputStream} that emulates a stream of a specified size.
  * <p>
- * This implementation provides a light weight
- * object for testing with an {@link InputStream}
- * where the contents don't matter.
+ * This implementation provides a light weight object for testing with an {@link InputStream} where the contents don't matter.
  * </p>
  * <p>
- * One use case would be for testing the handling of
- * large {@link InputStream} as it can emulate that
- * scenario without the overhead of actually processing
- * large numbers of bytes - significantly speeding up
- * test execution times.
+ * One use case would be for testing the handling of large {@link InputStream} as it can emulate that scenario without the overhead of actually processing large
+ * numbers of bytes - significantly speeding up test execution times.
  * </p>
  * <p>
- * This implementation returns zero from the method that
- * reads a byte and leaves the array unchanged in the read
- * methods that are passed a byte array.
- * If alternative data is required the {@code processByte()} and
- * {@code processBytes()} methods can be implemented to generate
- * data, for example:
+ * This implementation returns zero from the method that reads a byte and leaves the array unchanged in the read methods that are passed a byte array. If
+ * alternative data is required the {@code processByte()} and {@code processBytes()} methods can be implemented to generate data, for example:
  * </p>
  *
  * <pre>
  *  public class TestInputStream extends NullInputStream {
+ *
  *      public TestInputStream(int size) {
  *          super(size);
  *      }
+ *
  *      protected int processByte() {
  *          return ... // return required value here
  *      }
+ *
  *      protected void processBytes(byte[] bytes, int offset, int length) {
  *          for (int i = offset; i &lt; length; i++) {
  *              bytes[i] = ... // set array value here
@@ -64,67 +57,67 @@
  *
  * @since 1.3
  */
-public class NullInputStream extends InputStream {
+public class NullInputStream extends AbstractInputStream {
 
     /**
      * The singleton instance.
      *
+     * <p>
+     * Since instances hold state, call {@link #init()} to reuse.
+     * </p>
+     *
      * @since 2.12.0
+     * @deprecated Not reusable without calling {@link #init()} to reset state.
      */
+    @Deprecated
     public static final NullInputStream INSTANCE = new NullInputStream();
 
     private final long size;
     private long position;
     private long mark = -1;
-    private long readlimit;
-    private boolean eof;
+    private long readLimit;
     private final boolean throwEofException;
     private final boolean markSupported;
 
     /**
-     * Create an {@link InputStream} that emulates a size 0 stream
-     * which supports marking and does not throw EOFException.
+     * Constructs an {@link InputStream} that emulates a size 0 stream which supports marking and does not throw EOFException.
+     * <p>
+     * This is an "empty" input stream.
+     * </p>
      *
      * @since 2.7
      */
     public NullInputStream() {
-       this(0, true, false);
+        this(0, true, false);
     }
 
     /**
-     * Create an {@link InputStream} that emulates a specified size
-     * which supports marking and does not throw EOFException.
+     * Constructs an {@link InputStream} that emulates a specified size which supports marking and does not throw EOFException.
      *
      * @param size The size of the input stream to emulate.
      */
     public NullInputStream(final long size) {
-       this(size, true, false);
+        this(size, true, false);
     }
 
     /**
-     * Create an {@link InputStream} that emulates a specified
-     * size with option settings.
+     * Constructs an {@link InputStream} that emulates a specified size with option settings.
      *
-     * @param size The size of the input stream to emulate.
-     * @param markSupported Whether this instance will support
-     * the {@code mark()} functionality.
-     * @param throwEofException Whether this implementation
-     * will throw an {@link EOFException} or return -1 when the
-     * end of file is reached.
+     * @param size              The size of the input stream to emulate.
+     * @param markSupported     Whether this instance will support the {@code mark()} functionality.
+     * @param throwEofException Whether this implementation will throw an {@link EOFException} or return -1 when the end of file is reached.
      */
     public NullInputStream(final long size, final boolean markSupported, final boolean throwEofException) {
-       this.size = size;
-       this.markSupported = markSupported;
-       this.throwEofException = throwEofException;
+        this.size = size;
+        this.markSupported = markSupported;
+        this.throwEofException = throwEofException;
     }
 
-    /**
-     * Return the number of bytes that can be read.
-     *
-     * @return The number of bytes that can be read.
-     */
     @Override
     public int available() {
+        if (isClosed()) {
+            return 0;
+        }
         final long avail = size - position;
         if (avail <= 0) {
             return 0;
@@ -136,36 +129,30 @@ public int available() {
     }
 
     /**
-     * Close this input stream - resets the internal state to
-     * the initial values.
+     * Throws {@link EOFException} if {@code throwEofException} is enabled.
      *
-     * @throws IOException If an error occurs.
+     * @param message The {@link EOFException} message.
+     * @throws EOFException Thrown if {@code throwEofException} is enabled.
      */
-    @Override
-    public void close() throws IOException {
-        eof = false;
-        position = 0;
-        mark = -1;
+    private void checkThrowEof(final String message) throws EOFException {
+        if (throwEofException) {
+            throw new EOFException(message);
+        }
     }
 
     /**
-     * Handle End of File.
+     * Closes this input stream.
      *
-     * @return {@code -1} if {@code throwEofException} is
-     * set to {@code false}
-     * @throws EOFException if {@code throwEofException} is set
-     * to {@code true}.
+     * @throws IOException If an error occurs.
      */
-    private int doEndOfFile() throws EOFException {
-        eof = true;
-        if (throwEofException) {
-            throw new EOFException();
-        }
-        return EOF;
+    @Override
+    public void close() throws IOException {
+        super.close();
+        mark = -1;
     }
 
     /**
-     * Return the current position.
+     * Gets the current position.
      *
      * @return the current position.
      */
@@ -174,7 +161,7 @@ public long getPosition() {
     }
 
     /**
-     * Return the size this {@link InputStream} emulates.
+     * Gets the size this {@link InputStream} emulates.
      *
      * @return The size of the input stream to emulate.
      */
@@ -183,25 +170,49 @@ public long getSize() {
     }
 
     /**
-     * Mark the current position.
+     * Handles End of File.
+     *
+     * @return {@code -1} if {@code throwEofException} is set to {@code false}
+     * @throws IOException if {@code throwEofException} is set to {@code true}.
+     */
+    private int handleEof() throws IOException {
+        checkThrowEof("handleEof()");
+        return EOF;
+    }
+
+    /**
+     * Initializes or re-initializes this instance for reuse.
+     *
+     * @return this instance.
+     * @since 2.17.0
+     */
+    public NullInputStream init() {
+        setClosed(false);
+        position = 0;
+        mark = -1;
+        readLimit = 0;
+        return this;
+    }
+
+    /**
+     * Marks the current position.
      *
-     * @param readlimit The number of bytes before this marked position
-     * is invalid.
+     * @param readLimit The number of bytes before this marked position is invalid.
      * @throws UnsupportedOperationException if mark is not supported.
      */
     @Override
-    public synchronized void mark(final int readlimit) {
+    public synchronized void mark(final int readLimit) {
         if (!markSupported) {
             throw UnsupportedOperationExceptions.mark();
         }
         mark = position;
-        this.readlimit = readlimit;
+        this.readLimit = readLimit;
     }
 
     /**
-     * Indicates whether <i>mark</i> is supported.
+     * Tests whether <em>mark</em> is supported.
      *
-     * @return Whether <i>mark</i> is supported or not.
+     * @return Whether <em>mark</em> is supported or not.
      */
     @Override
     public boolean markSupported() {
@@ -209,7 +220,7 @@ public boolean markSupported() {
     }
 
     /**
-     * Return a byte value for the  {@code read()} method.
+     * Returns a byte value for the {@code read()} method.
      * <p>
      * This implementation returns zero.
      *
@@ -221,12 +232,12 @@ protected int processByte() {
     }
 
     /**
-     * Process the bytes for the {@code read(byte[], offset, length)}
-     * method.
+     * Processes the bytes for the {@code read(byte[], offset, length)} method.
      * <p>
      * This implementation leaves the byte array unchanged.
+     * </p>
      *
-     * @param bytes The byte array
+     * @param bytes  The byte array
      * @param offset The offset to start at.
      * @param length The number of bytes.
      */
@@ -235,37 +246,30 @@ protected void processBytes(final byte[] bytes, final int offset, final int leng
     }
 
     /**
-     * Read a byte.
+     * Reads a byte.
      *
-     * @return Either The byte value returned by {@code processByte()}
-     * or {@code -1} if the end of file has been reached and
-     * {@code throwEofException} is set to {@code false}.
-     * @throws EOFException if the end of file is reached and
-     * {@code throwEofException} is set to {@code true}.
-     * @throws IOException if trying to read past the end of file.
+     * @return Either The byte value returned by {@code processByte()} or {@code -1} if the end of file has been reached and {@code throwEofException} is set to
+     *         {@code false}.
+     * @throws EOFException if the end of file is reached and {@code throwEofException} is set to {@code true}.
+     * @throws IOException  if trying to read past the end of file.
      */
     @Override
     public int read() throws IOException {
-        if (eof) {
-            throw new IOException("Read after end of file");
-        }
+        checkOpen();
         if (position == size) {
-            return doEndOfFile();
+            return handleEof();
         }
         position++;
         return processByte();
     }
 
     /**
-     * Read some bytes into the specified array.
+     * Reads some bytes into the specified array.
      *
      * @param bytes The byte array to read into
-     * @return The number of bytes read or {@code -1}
-     * if the end of file has been reached and
-     * {@code throwEofException} is set to {@code false}.
-     * @throws EOFException if the end of file is reached and
-     * {@code throwEofException} is set to {@code true}.
-     * @throws IOException if trying to read past the end of file.
+     * @return The number of bytes read or {@code -1} if the end of file has been reached and {@code throwEofException} is set to {@code false}.
+     * @throws EOFException if the end of file is reached and {@code throwEofException} is set to {@code true}.
+     * @throws IOException  if trying to read past the end of file.
      */
     @Override
     public int read(final byte[] bytes) throws IOException {
@@ -273,30 +277,28 @@ public int read(final byte[] bytes) throws IOException {
     }
 
     /**
-     * Read the specified number bytes into an array.
+     * Reads the specified number bytes into an array.
      *
-     * @param bytes The byte array to read into.
+     * @param bytes  The byte array to read into.
      * @param offset The offset to start reading bytes into.
      * @param length The number of bytes to read.
-     * @return The number of bytes read or {@code -1}
-     * if the end of file has been reached and
-     * {@code throwEofException} is set to {@code false}.
-     * @throws EOFException if the end of file is reached and
-     * {@code throwEofException} is set to {@code true}.
-     * @throws IOException if trying to read past the end of file.
+     * @return The number of bytes read or {@code -1} if the end of file has been reached and {@code throwEofException} is set to {@code false}.
+     * @throws EOFException if the end of file is reached and {@code throwEofException} is set to {@code true}.
+     * @throws IOException  if trying to read past the end of file.
      */
     @Override
     public int read(final byte[] bytes, final int offset, final int length) throws IOException {
-        if (eof) {
-            throw new IOException("Read after end of file");
+        if (bytes.length == 0 || length == 0) {
+            return 0;
         }
+        checkOpen();
         if (position == size) {
-            return doEndOfFile();
+            return handleEof();
         }
         position += length;
         int returnLength = length;
         if (position > size) {
-            returnLength = length - (int)(position - size);
+            returnLength = length - (int) (position - size);
             position = size;
         }
         processBytes(bytes, offset, returnLength);
@@ -304,12 +306,10 @@ public int read(final byte[] bytes, final int offset, final int length) throws I
     }
 
     /**
-     * Reset the stream to the point when mark was last called.
+     * Resets the stream to the point when mark was last called.
      *
      * @throws UnsupportedOperationException if mark is not supported.
-     * @throws IOException If no position has been marked
-     * or the read limit has been exceeded since the last position was
-     * marked.
+     * @throws IOException                   If no position has been marked or the read limit has been exceeded since the last position was marked.
      */
     @Override
     public synchronized void reset() throws IOException {
@@ -319,33 +319,29 @@ public synchronized void reset() throws IOException {
         if (mark < 0) {
             throw new IOException("No position has been marked");
         }
-        if (position > mark + readlimit) {
-            throw new IOException("Marked position [" + mark +
-                    "] is no longer valid - passed the read limit [" +
-                    readlimit + "]");
+        if (position > mark + readLimit) {
+            throw new IOException("Marked position [" + mark + "] is no longer valid - passed the read limit [" + readLimit + "]");
         }
         position = mark;
-        eof = false;
+        setClosed(false);
     }
 
     /**
-     * Skip a specified number of bytes.
+     * Skips a specified number of bytes.
      *
      * @param numberOfBytes The number of bytes to skip.
-     * @return The number of bytes skipped or {@code -1}
-     * if the end of file has been reached and
-     * {@code throwEofException} is set to {@code false}.
-     * @throws EOFException if the end of file is reached and
-     * {@code throwEofException} is set to {@code true}.
-     * @throws IOException if trying to read past the end of file.
+     * @return The number of bytes skipped or {@code -1} if the end of file has been reached and {@code throwEofException} is set to {@code false}.
+     * @throws EOFException if the end of file is reached and {@code throwEofException} is set to {@code true}.
+     * @throws IOException  if trying to read past the end of file.
      */
     @Override
     public long skip(final long numberOfBytes) throws IOException {
-        if (eof) {
-            throw new IOException("Skip after end of file");
+        if (isClosed()) {
+            checkThrowEof("skip(long)");
+            return EOF;
         }
         if (position == size) {
-            return doEndOfFile();
+            return handleEof();
         }
         position += numberOfBytes;
         long returnLength = numberOfBytes;
diff --git a/src/main/java/org/apache/commons/io/input/NullReader.java b/src/main/java/org/apache/commons/io/input/NullReader.java
index ba221e04..62119f0d 100644
--- a/src/main/java/org/apache/commons/io/input/NullReader.java
+++ b/src/main/java/org/apache/commons/io/input/NullReader.java
@@ -76,7 +76,7 @@ public class NullReader extends Reader {
     private final long size;
     private long position;
     private long mark = -1;
-    private long readlimit;
+    private long readLimit;
     private boolean eof;
     private final boolean throwEofException;
     private final boolean markSupported;
@@ -168,23 +168,23 @@ public long getSize() {
     /**
      * Marks the current position.
      *
-     * @param readlimit The number of characters before this marked position
+     * @param readLimit The number of characters before this marked position
      * is invalid.
      * @throws UnsupportedOperationException if mark is not supported.
      */
     @Override
-    public synchronized void mark(final int readlimit) {
+    public synchronized void mark(final int readLimit) {
         if (!markSupported) {
             throw UnsupportedOperationExceptions.mark();
         }
         mark = position;
-        this.readlimit = readlimit;
+        this.readLimit = readLimit;
     }
 
     /**
-     * Indicates whether <i>mark</i> is supported.
+     * Indicates whether <em>mark</em> is supported.
      *
-     * @return Whether <i>mark</i> is supported or not.
+     * @return Whether <em>mark</em> is supported or not.
      */
     @Override
     public boolean markSupported() {
@@ -281,7 +281,7 @@ public int read(final char[] chars, final int offset, final int length) throws I
         position += length;
         int returnLength = length;
         if (position > size) {
-            returnLength = length - (int)(position - size);
+            returnLength = length - (int) (position - size);
             position = size;
         }
         processChars(chars, offset, returnLength);
@@ -304,10 +304,10 @@ public synchronized void reset() throws IOException {
         if (mark < 0) {
             throw new IOException("No position has been marked");
         }
-        if (position > mark + readlimit) {
+        if (position > mark + readLimit) {
             throw new IOException("Marked position [" + mark +
                     "] is no longer valid - passed the read limit [" +
-                    readlimit + "]");
+                    readLimit + "]");
         }
         position = mark;
         eof = false;
diff --git a/src/main/java/org/apache/commons/io/input/ObservableInputStream.java b/src/main/java/org/apache/commons/io/input/ObservableInputStream.java
index a97702fb..7be7b7a2 100644
--- a/src/main/java/org/apache/commons/io/input/ObservableInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/ObservableInputStream.java
@@ -43,6 +43,42 @@
  */
 public class ObservableInputStream extends ProxyInputStream {
 
+    /**
+     * For subclassing builders from {@link BoundedInputStream} subclassses.
+     *
+     * @param <T> The subclass.
+     * @since 2.18.0
+     */
+    public static abstract class AbstractBuilder<T extends AbstractBuilder<T>> extends ProxyInputStream.AbstractBuilder<ObservableInputStream, T> {
+
+        private List<Observer> observers;
+
+        /**
+         * Sets the list of observer callbacks.
+         *
+         * @param observers The list of observer callbacks.
+         */
+        public void setObservers(final List<Observer> observers) {
+            this.observers = observers;
+        }
+
+    }
+
+
+    /**
+     * Builds instances of {@link ObservableInputStream}.
+     *
+     * @since 2.18.0
+     */
+    public static class Builder extends AbstractBuilder<Builder> {
+
+        @Override
+        public ObservableInputStream get() throws IOException {
+            return new ObservableInputStream(this);
+        }
+
+    }
+
     /**
      * Abstracts observer callback for {@link ObservableInputStream}s.
      */
@@ -109,6 +145,11 @@ public void finished() throws IOException {
 
     private final List<Observer> observers;
 
+    ObservableInputStream(final AbstractBuilder builder) throws IOException {
+        super(builder);
+        this.observers = builder.observers;
+    }
+
     /**
      * Constructs a new ObservableInputStream for the given InputStream.
      *
@@ -178,13 +219,13 @@ private void forEachObserver(final IOConsumer<Observer> action) throws IOExcepti
     }
 
     /**
-     * Gets all currently registered observers.
+     * Gets a copy of currently registered observers.
      *
-     * @return a list of the currently registered observers.
+     * @return a copy of the list of currently registered observers.
      * @since 2.9.0
      */
     public List<Observer> getObservers() {
-        return observers;
+        return new ArrayList<>(observers);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/input/ProxyInputStream.java b/src/main/java/org/apache/commons/io/input/ProxyInputStream.java
index 4344cba3..e529a21f 100644
--- a/src/main/java/org/apache/commons/io/input/ProxyInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/ProxyInputStream.java
@@ -23,73 +23,166 @@
 import java.io.InputStream;
 
 import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.build.AbstractStreamBuilder;
+import org.apache.commons.io.function.Erase;
+import org.apache.commons.io.function.IOConsumer;
+import org.apache.commons.io.function.IOIntConsumer;
 
 /**
- * A Proxy stream which acts as expected, that is it passes the method
- * calls on to the proxied stream and doesn't change which methods are
- * being called.
+ * A proxy stream which acts as a {@link FilterInputStream}, by passing all method calls on to the proxied stream, not changing which methods are called.
  * <p>
- * It is an alternative base class to FilterInputStream
- * to increase reusability, because FilterInputStream changes the
- * methods being called, such as read(byte[]) to read(byte[], int, int).
+ * It is an alternative base class to {@link FilterInputStream} to increase reusability, because {@link FilterInputStream} changes the methods being called,
+ * such as read(byte[]) to read(byte[], int, int).
  * </p>
  * <p>
- * See the protected methods for ways in which a subclass can easily decorate
- * a stream with custom pre-, post- or error processing functionality.
+ * In addition, this class allows you to:
  * </p>
+ * <ul>
+ * <li>notify a subclass that <em>n</em> bytes are about to be read through {@link #beforeRead(int)}</li>
+ * <li>notify a subclass that <em>n</em> bytes were read through {@link #afterRead(int)}</li>
+ * <li>notify a subclass that an exception was caught through {@link #handleIOException(IOException)}</li>
+ * <li>{@link #unwrap()} itself</li>
+ * </ul>
  */
 public abstract class ProxyInputStream extends FilterInputStream {
 
+    /**
+     * Abstracts builder properties for subclasses.
+     *
+     * @param <T> The InputStream type.
+     * @param <B> The builder type.
+     * @since 2.18.0
+     */
+    protected static abstract class AbstractBuilder<T, B extends AbstractStreamBuilder<T, B>> extends AbstractStreamBuilder<T, B> {
+
+        private IOIntConsumer afterRead;
+
+        /**
+         * Gets the {@link ProxyInputStream#afterRead(int)} consumer.
+         *
+         * @return the {@link ProxyInputStream#afterRead(int)} consumer.
+         */
+        public IOIntConsumer getAfterRead() {
+            return afterRead;
+        }
+
+        /**
+         * Sets the {@link ProxyInputStream#afterRead(int)} behavior, null resets to a NOOP.
+         * <p>
+         * Setting this value causes the {@link ProxyInputStream#afterRead(int) afterRead} method to delegate to the given consumer.
+         * </p>
+         * <p>
+         * If a subclass overrides {@link ProxyInputStream#afterRead(int) afterRead} and does not call {@code super.afterRead(int)}, then the given consumer is
+         * not called.
+         * </p>
+         * <p>
+         * This does <em>not</em> override a {@code ProxyInputStream} subclass' implementation of the {@link ProxyInputStream#afterRead(int)} method, it can
+         * supplement it.
+         * </p>
+         *
+         * @param afterRead the {@link ProxyInputStream#afterRead(int)} behavior.
+         * @return this instance.
+         */
+        public B setAfterRead(final IOIntConsumer afterRead) {
+            this.afterRead = afterRead;
+            return asThis();
+        }
+
+    }
+
+    /**
+     * Tracks whether {@link #close()} has been called or not.
+     */
+    private boolean closed;
+
+    /**
+     * Handles exceptions.
+     */
+    private final IOConsumer<IOException> exceptionHandler;
+
+    private final IOIntConsumer afterRead;
+
     /**
      * Constructs a new ProxyInputStream.
      *
-     * @param proxy  the InputStream to delegate to
+     * @param builder  How to build an instance.
+     * @throws IOException if an I/O error occurs.
+     * @since 2.18.0
+     */
+    @SuppressWarnings("resource")
+    protected ProxyInputStream(final AbstractBuilder<?, ?> builder) throws IOException {
+        // the delegate is stored in a protected superclass instance variable named 'in'.
+        this(builder.getInputStream(), builder);
+    }
+
+    /**
+     * Constructs a new ProxyInputStream.
+     *
+     * @param proxy  the InputStream to proxy.
      */
     public ProxyInputStream(final InputStream proxy) {
+        // the delegate is stored in a protected superclass variable named 'in'.
+        super(proxy);
+        this.exceptionHandler = Erase::rethrow;
+        this.afterRead = IOIntConsumer.NOOP;
+    }
+
+    /**
+     * Constructs a new ProxyInputStream.
+     *
+     * @param proxy  the InputStream to proxy.
+     * @param builder  How to build an instance.
+     * @since 2.18.0
+     */
+    protected ProxyInputStream(final InputStream proxy, final AbstractBuilder<?, ?> builder) {
+        // the delegate is stored in a protected superclass instance variable named 'in'.
         super(proxy);
-        // the proxy is stored in a protected superclass variable named 'in'
+        this.exceptionHandler = Erase::rethrow;
+        this.afterRead = builder.getAfterRead() != null ? builder.getAfterRead() : IOIntConsumer.NOOP;
     }
 
     /**
-     * Invoked by the read methods after the proxied call has returned
-     * successfully. The number of bytes returned to the caller (or -1 if
-     * the end of stream was reached) is given as an argument.
+     * Called by the {@code read} methods after the proxied call has returned successfully. The argument is the number of bytes returned to the caller or
+     * {@link IOUtils#EOF EOF} if the end of stream was reached.
      * <p>
-     * Subclasses can override this method to add common post-processing
-     * functionality without having to override all the read methods.
-     * The default implementation does nothing.
+     * The default delegates to the consumer given to {@link AbstractBuilder#setAfterRead(IOIntConsumer)}.
      * </p>
      * <p>
-     * Note this method is <em>not</em> called from {@link #skip(long)} or
-     * {@link #reset()}. You need to explicitly override those methods if
-     * you want to add post-processing steps also to them.
+     * Alternatively, a subclasses can override this method to add post-processing functionality without having to override all the read methods.
      * </p>
+     * <p>
+     * Note this method is <em>not</em> called from {@link #skip(long)} or {@link #reset()}. You need to explicitly override those methods if you want to add
+     * post-processing steps also to them.
+     * </p>
+     *
+     * @param n number of bytes read, or {@link IOUtils#EOF EOF} if the end of stream was reached.
+     * @throws IOException Thrown by a subclass or the consumer given to {@link AbstractBuilder#setAfterRead(IOIntConsumer)}.
      * @since 2.0
-     * @param n number of bytes read, or -1 if the end of stream was reached
-     * @throws IOException if the post-processing fails
      */
-    @SuppressWarnings("unused") // Possibly thrown from subclasses.
     protected void afterRead(final int n) throws IOException {
-        // no-op
+        afterRead.accept(n);
     }
 
     /**
-     * Invokes the delegate's {@code available()} method.
-     * @return the number of available bytes
+     * Invokes the delegate's {@link InputStream#available()} method.
+     *
+     * @return the number of available bytes, 0 if the stream is closed.
      * @throws IOException if an I/O error occurs.
      */
     @Override
     public int available() throws IOException {
-        try {
-            return super.available();
-        } catch (final IOException e) {
-            handleIOException(e);
-            return 0;
+        if (in != null && !isClosed()) {
+            try {
+                return in.available();
+            } catch (final IOException e) {
+                handleIOException(e);
+            }
         }
+        return 0;
     }
 
     /**
-     * Invoked by the read methods before the call is proxied. The number
+     * Invoked by the {@code read} methods before the call is proxied. The number
      * of bytes that the caller wanted to read (1 for the {@link #read()}
      * method, buffer length for {@link #read(byte[])}, etc.) is given as
      * an argument.
@@ -103,59 +196,88 @@ public int available() throws IOException {
      * {@link #reset()}. You need to explicitly override those methods if
      * you want to add pre-processing steps also to them.
      * </p>
+     *
      * @since 2.0
-     * @param n number of bytes that the caller asked to be read
-     * @throws IOException if the pre-processing fails
+     * @param n number of bytes that the caller asked to be read.
+     * @throws IOException if the pre-processing fails in a subclass.
      */
     @SuppressWarnings("unused") // Possibly thrown from subclasses.
     protected void beforeRead(final int n) throws IOException {
-        // no-op
+        // no-op default
     }
 
     /**
-     * Invokes the delegate's {@code close()} method.
+     * Checks if this instance is closed and throws an IOException if so.
+     *
+     * @throws IOException if this instance is closed.
+     */
+    void checkOpen() throws IOException {
+        Input.checkOpen(!isClosed());
+    }
+
+    /**
+     * Invokes the delegate's {@link InputStream#close()} method.
+     *
      * @throws IOException if an I/O error occurs.
      */
     @Override
     public void close() throws IOException {
         IOUtils.close(in, this::handleIOException);
+        closed = true;
     }
 
     /**
-     * Handle any IOExceptions thrown; by default, throws the given exception.
+     * Handles any IOExceptions thrown; by default, throws the given exception.
      * <p>
      * This method provides a point to implement custom exception
      * handling. The default behavior is to re-throw the exception.
      * </p>
-     * @param e The IOException thrown
+     *
+     * @param e The IOException thrown.
      * @throws IOException if an I/O error occurs.
      * @since 2.0
      */
     protected void handleIOException(final IOException e) throws IOException {
-        throw e;
+        exceptionHandler.accept(e);
+    }
+
+    /**
+     * Tests whether this instance is closed.
+     *
+     * @return whether this instance is closed.
+     */
+    boolean isClosed() {
+        return closed;
     }
 
     /**
-     * Invokes the delegate's {@code mark(int)} method.
-     * @param readlimit read ahead limit
+     * Invokes the delegate's {@link InputStream#mark(int)} method.
+     *
+     * @param readLimit read ahead limit.
      */
     @Override
-    public synchronized void mark(final int readlimit) {
-        in.mark(readlimit);
+    public synchronized void mark(final int readLimit) {
+        if (in != null) {
+            in.mark(readLimit);
+        }
     }
 
     /**
-     * Invokes the delegate's {@code markSupported()} method.
-     * @return true if mark is supported, otherwise false
+     * Invokes the delegate's {@link InputStream#markSupported()} method.
+     *
+     * @return {@code true} if this stream instance supports the mark and reset methods; {@code false} otherwise.
+     * @see #mark(int)
+     * @see #reset()
      */
     @Override
     public boolean markSupported() {
-        return in.markSupported();
+        return in != null && in.markSupported();
     }
 
     /**
-     * Invokes the delegate's {@code read()} method.
-     * @return the byte read or -1 if the end of stream
+     * Invokes the delegate's {@link InputStream#read()} method unless the stream is closed.
+     *
+     * @return the byte read or {@link IOUtils#EOF EOF} if we reached the end of stream.
      * @throws IOException if an I/O error occurs.
      */
     @Override
@@ -172,16 +294,22 @@ public int read() throws IOException {
     }
 
     /**
-     * Invokes the delegate's {@code read(byte[])} method.
-     * @param bts the buffer to read the bytes into
-     * @return the number of bytes read or EOF if the end of stream
-     * @throws IOException if an I/O error occurs.
+     * Invokes the delegate's {@link InputStream#read(byte[])} method.
+     *
+     * @param b the buffer to read the bytes into.
+     * @return the number of bytes read or {@link IOUtils#EOF EOF} if we reached the end of stream.
+     * @throws IOException
+     *                     <ul>
+     *                     <li>If the first byte cannot be read for any reason other than the end of the file,
+     *                     <li>if the input stream has been closed, or</li>
+     *                     <li>if some other I/O error occurs.</li>
+     *                     </ul>
      */
     @Override
-    public int read(final byte[] bts) throws IOException {
+    public int read(final byte[] b) throws IOException {
         try {
-            beforeRead(IOUtils.length(bts));
-            final int n = in.read(bts);
+            beforeRead(IOUtils.length(b));
+            final int n = in.read(b);
             afterRead(n);
             return n;
         } catch (final IOException e) {
@@ -191,18 +319,24 @@ public int read(final byte[] bts) throws IOException {
     }
 
     /**
-     * Invokes the delegate's {@code read(byte[], int, int)} method.
-     * @param bts the buffer to read the bytes into
-     * @param off The start offset
-     * @param len The number of bytes to read
-     * @return the number of bytes read or -1 if the end of stream
-     * @throws IOException if an I/O error occurs.
+     * Invokes the delegate's {@link InputStream#read(byte[], int, int)} method.
+     *
+     * @param b   the buffer to read the bytes into.
+     * @param off The start offset.
+     * @param len The number of bytes to read.
+     * @return the number of bytes read or {@link IOUtils#EOF EOF} if we reached the end of stream.
+     * @throws IOException
+     *                     <ul>
+     *                     <li>If the first byte cannot be read for any reason other than the end of the file,
+     *                     <li>if the input stream has been closed, or</li>
+     *                     <li>if some other I/O error occurs.</li>
+     *                     </ul>
      */
     @Override
-    public int read(final byte[] bts, final int off, final int len) throws IOException {
+    public int read(final byte[] b, final int off, final int len) throws IOException {
         try {
             beforeRead(len);
-            final int n = in.read(bts, off, len);
+            final int n = in.read(b, off, len);
             afterRead(n);
             return n;
         } catch (final IOException e) {
@@ -212,8 +346,9 @@ public int read(final byte[] bts, final int off, final int len) throws IOExcepti
     }
 
     /**
-     * Invokes the delegate's {@code reset()} method.
-     * @throws IOException if an I/O error occurs.
+     * Invokes the delegate's {@link InputStream#reset()} method.
+     *
+     * @throws IOException if this stream has not been marked or if the mark has been invalidated.
      */
     @Override
     public synchronized void reset() throws IOException {
@@ -225,19 +360,42 @@ public synchronized void reset() throws IOException {
     }
 
     /**
-     * Invokes the delegate's {@code skip(long)} method.
-     * @param ln the number of bytes to skip
-     * @return the actual number of bytes skipped
-     * @throws IOException if an I/O error occurs.
+     * Package-private for testing.
+     *
+     * @param in The input stream to set in {@link java.io.FilterInputStream#in}.
+     */
+    void setIn(final InputStream in) {
+        this.in = in;
+    }
+
+    /**
+     * Invokes the delegate's {@link InputStream#skip(long)} method.
+     *
+     * @param n the number of bytes to skip.
+     * @return the actual number of bytes skipped.
+     * @throws IOException if the stream does not support seek, or if some other I/O error occurs.
      */
     @Override
-    public long skip(final long ln) throws IOException {
+    public long skip(final long n) throws IOException {
         try {
-            return in.skip(ln);
+            return in.skip(n);
         } catch (final IOException e) {
             handleIOException(e);
             return 0;
         }
     }
 
+    /**
+     * Unwraps this instance by returning the underlying {@link InputStream}.
+     * <p>
+     * Use with caution; useful to query the underlying {@link InputStream}.
+     * </p>
+     *
+     * @return the underlying {@link InputStream}.
+     * @since 2.16.0
+     */
+    public InputStream unwrap() {
+        return in;
+    }
+
 }
diff --git a/src/main/java/org/apache/commons/io/input/ProxyReader.java b/src/main/java/org/apache/commons/io/input/ProxyReader.java
index f05f5b0b..8873d2fd 100644
--- a/src/main/java/org/apache/commons/io/input/ProxyReader.java
+++ b/src/main/java/org/apache/commons/io/input/ProxyReader.java
@@ -40,11 +40,11 @@ public abstract class ProxyReader extends FilterReader {
     /**
      * Constructs a new ProxyReader.
      *
-     * @param proxy  the Reader to delegate to
+     * @param delegate  the Reader to delegate to
      */
-    public ProxyReader(final Reader proxy) {
-        super(proxy);
-        // the proxy is stored in a protected superclass variable named 'in'
+    public ProxyReader(final Reader delegate) {
+        // the delegate is stored in a protected superclass variable named 'in'
+        super(delegate);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/input/QueueInputStream.java b/src/main/java/org/apache/commons/io/input/QueueInputStream.java
index 1ed2e84a..874e7a7f 100644
--- a/src/main/java/org/apache/commons/io/input/QueueInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/QueueInputStream.java
@@ -32,14 +32,13 @@
 import org.apache.commons.io.output.QueueOutputStream;
 
 /**
- * Simple alternative to JDK {@link java.io.PipedInputStream}; queue input stream provides what's written in queue output stream.
+ * Simple alternative to JDK {@link PipedInputStream}; queue input stream provides what's written in queue output stream.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * Example usage:
  * </p>
- *
  * <pre>
  * QueueInputStream inputStream = new QueueInputStream();
  * QueueOutputStream outputStream = inputStream.newQueueOutputStream();
@@ -56,17 +55,19 @@
  * {@link IOException}.
  * </p>
  *
+ * @see Builder
  * @see QueueOutputStream
  * @since 2.9.0
  */
 public class QueueInputStream extends InputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link QueueInputStream} instance.
+     * Builds a new {@link QueueInputStream}.
+     *
      * <p>
      * For example:
      * </p>
-     *
      * <pre>{@code
      * QueueInputStream s = QueueInputStream.builder()
      *   .setBlockingQueue(new LinkedBlockingQueue<>())
@@ -74,18 +75,24 @@ public class QueueInputStream extends InputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<QueueInputStream, Builder> {
 
         private BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>();
         private Duration timeout = Duration.ZERO;
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link QueueInputStream}.
          * <p>
-         * This builder use the aspects BlockingQueue and timeout.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #setBlockingQueue(BlockingQueue)}</li>
+         * <li>timeout</li>
+         * </ul>
          *
          * @return a new instance.
          */
@@ -98,7 +105,7 @@ public QueueInputStream get() {
          * Sets backing queue for the stream.
          *
          * @param blockingQueue backing queue for the stream.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setBlockingQueue(final BlockingQueue<Integer> blockingQueue) {
             this.blockingQueue = blockingQueue != null ? blockingQueue : new LinkedBlockingQueue<>();
@@ -109,7 +116,7 @@ public Builder setBlockingQueue(final BlockingQueue<Integer> blockingQueue) {
          * Sets the polling timeout.
          *
          * @param timeout the polling timeout.
-         * @return this.
+         * @return {@code this} instance.
          */
         public Builder setTimeout(final Duration timeout) {
             if (timeout != null && timeout.toNanos() < 0) {
diff --git a/src/main/java/org/apache/commons/io/input/RandomAccessFileInputStream.java b/src/main/java/org/apache/commons/io/input/RandomAccessFileInputStream.java
index 647ee4d1..522ac460 100644
--- a/src/main/java/org/apache/commons/io/input/RandomAccessFileInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/RandomAccessFileInputStream.java
@@ -17,26 +17,29 @@
 
 package org.apache.commons.io.input;
 
+import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.util.Objects;
 
-import org.apache.commons.io.RandomAccessFileMode;
 import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
  * Streams data from a {@link RandomAccessFile} starting at its current position.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
+ *
+ * @see Builder
  * @since 2.8.0
  */
-public class RandomAccessFileInputStream extends InputStream {
+public class RandomAccessFileInputStream extends AbstractInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link RandomAccessFileInputStream} instance.
+     * Builds a new {@link RandomAccessFileInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -47,49 +50,50 @@ public class RandomAccessFileInputStream extends InputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<RandomAccessFileInputStream, Builder> {
 
-        private RandomAccessFile randomAccessFile;
-        private boolean closeOnClose;
+        // private RandomAccessFile randomAccessFile;
+        private boolean propagateClose;
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link RandomAccessFileInputStream}.
          * <p>
-         * This builder use the aspects RandomAccessFile or File, and closeOnClose. Only set one of RandomAccessFile or an origin that can be converted to a
-         * File.
+         * You must set input that supports {@link RandomAccessFile} or {@link File}, otherwise, this method throws an exception. Only set one of
+         * RandomAccessFile or an origin that can be converted to a File.
          * </p>
          * <p>
-         * If RandomAccessFile is not set, then you must provide an origin that can be converted to a File by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link RandomAccessFile}</li>
+         * <li>{@link File}</li>
+         * <li>closeOnClose</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws IllegalStateException if both RandomAccessFile and origin are set.
-         * @throws UnsupportedOperationException if the origin cannot provide a File.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws IllegalStateException         if both RandomAccessFile and origin are set.
+         * @throws UnsupportedOperationException if the origin cannot be converted to a {@link File}.
          * @see AbstractOrigin#getFile()
          */
         @SuppressWarnings("resource") // Caller closes depending on settings
         @Override
         public RandomAccessFileInputStream get() throws IOException {
-            if (randomAccessFile != null) {
-                if (getOrigin() != null) {
-                    throw new IllegalStateException(String.format("Only set one of RandomAccessFile (%s) or origin (%s)", randomAccessFile, getOrigin()));
-                }
-                return new RandomAccessFileInputStream(randomAccessFile, closeOnClose);
-            }
-            return new RandomAccessFileInputStream(RandomAccessFileMode.READ_ONLY.create(getOrigin().getFile()), closeOnClose);
+            return new RandomAccessFileInputStream(getRandomAccessFile(), propagateClose);
         }
 
         /**
          * Sets whether to close the underlying file when this stream is closed.
          *
-         * @param closeOnClose Whether to close the underlying file when this stream is closed.
-         * @return this
+         * @param propagateClose Whether to close the underlying file when this stream is closed.
+         * @return {@code this} instance.
          */
-        public Builder setCloseOnClose(final boolean closeOnClose) {
-            this.closeOnClose = closeOnClose;
+        public Builder setCloseOnClose(final boolean propagateClose) {
+            this.propagateClose = propagateClose;
             return this;
         }
 
@@ -97,11 +101,11 @@ public Builder setCloseOnClose(final boolean closeOnClose) {
          * Sets the RandomAccessFile to stream.
          *
          * @param randomAccessFile the RandomAccessFile to stream.
-         * @return this
+         * @return {@code this} instance.
          */
-        public Builder setRandomAccessFile(final RandomAccessFile randomAccessFile) {
-            this.randomAccessFile = randomAccessFile;
-            return this;
+        @Override // MUST keep this method for binary compatibility since the super version of this method uses a generic which compiles to Object.
+        public Builder setRandomAccessFile(final RandomAccessFile randomAccessFile) { // NOPMD see above.
+            return super.setRandomAccessFile(randomAccessFile);
         }
 
     }
@@ -116,7 +120,7 @@ public static Builder builder() {
         return new Builder();
     }
 
-    private final boolean closeOnClose;
+    private final boolean propagateClose;
     private final RandomAccessFile randomAccessFile;
 
     /**
@@ -134,17 +138,17 @@ public RandomAccessFileInputStream(final RandomAccessFile file) {
      * Constructs a new instance.
      *
      * @param file         The file to stream.
-     * @param closeOnClose Whether to close the underlying file when this stream is closed.
+     * @param propagateClose Whether to close the underlying file when this stream is closed.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
     @Deprecated
-    public RandomAccessFileInputStream(final RandomAccessFile file, final boolean closeOnClose) {
+    public RandomAccessFileInputStream(final RandomAccessFile file, final boolean propagateClose) {
         this.randomAccessFile = Objects.requireNonNull(file, "file");
-        this.closeOnClose = closeOnClose;
+        this.propagateClose = propagateClose;
     }
 
     /**
-     * Returns an estimate of the number of bytes that can be read (or skipped over) from this input stream.
+     * Gets an estimate of the number of bytes that can be read (or skipped over) from this input stream.
      *
      * If there are more than {@link Integer#MAX_VALUE} bytes available, return {@link Integer#MAX_VALUE}.
      *
@@ -161,19 +165,19 @@ public int available() throws IOException {
     }
 
     /**
-     * Returns the number of bytes that can be read (or skipped over) from this input stream.
+     * Gets the number of bytes that can be read (or skipped over) from this input stream.
      *
      * @return The number of bytes that can be read.
      * @throws IOException If an I/O error occurs.
      */
     public long availableLong() throws IOException {
-        return randomAccessFile.length() - randomAccessFile.getFilePointer();
+        return isClosed() ? 0 : randomAccessFile.length() - randomAccessFile.getFilePointer();
     }
 
     @Override
     public void close() throws IOException {
         super.close();
-        if (closeOnClose) {
+        if (propagateClose) {
             randomAccessFile.close();
         }
     }
@@ -188,12 +192,12 @@ public RandomAccessFile getRandomAccessFile() {
     }
 
     /**
-     * Returns whether to close the underlying file when this stream is closed.
+     * Tests whether to close the underlying file when this stream is closed.
      *
      * @return Whether to close the underlying file when this stream is closed.
      */
     public boolean isCloseOnClose() {
-        return closeOnClose;
+        return propagateClose;
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java b/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java
index dc4fc08d..86dae2d6 100644
--- a/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java
@@ -38,18 +38,21 @@
  * read() call is issued. The read ahead buffer is used to asynchronously read from the underlying input stream. When the current active buffer is exhausted, we
  * flip the two buffers so that we can start reading from the read ahead buffer without being blocked by disk I/O.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * This class was ported and adapted from Apache Spark commit 933dc6cb7b3de1d8ccaf73d124d6eb95b947ed19.
  * </p>
  *
+ * @see Builder
  * @since 2.9.0
  */
 public class ReadAheadInputStream extends FilterInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link ReadAheadInputStream} instance.
+     * Builds a new {@link ReadAheadInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -60,25 +63,34 @@ public class ReadAheadInputStream extends FilterInputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<ReadAheadInputStream, Builder> {
 
         private ExecutorService executorService;
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link ReadAheadInputStream}.
          * <p>
-         * This builder use the aspects InputStream, OpenOption[], buffer size, ExecutorService.
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>{@link ExecutorService}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getInputStream()
+         * @see #getBufferSize()
          */
         @SuppressWarnings("resource")
         @Override
@@ -91,7 +103,7 @@ public ReadAheadInputStream get() throws IOException {
          * Sets the executor service for the read-ahead thread.
          *
          * @param executorService the executor service for the read-ahead thread.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setExecutorService(final ExecutorService executorService) {
             this.executorService = executorService;
@@ -169,7 +181,7 @@ private static ExecutorService newExecutorService() {
     private boolean isReading;
 
     // Whether there is a reader waiting for data.
-    private final AtomicBoolean isWaiting = new AtomicBoolean(false);
+    private final AtomicBoolean isWaiting = new AtomicBoolean();
 
     private final ExecutorService executorService;
 
@@ -473,7 +485,9 @@ public long skip(final long n) throws IOException {
      * @throws IOException if an I/O error occurs.
      */
     private long skipInternal(final long n) throws IOException {
-        assert stateChangeLock.isLocked();
+        if (!stateChangeLock.isLocked()) {
+            throw new IllegalStateException("Expected stateChangeLock to be locked");
+        }
         waitForAsyncReadComplete();
         if (isEndOfStream()) {
             return 0;
@@ -483,7 +497,9 @@ private long skipInternal(final long n) throws IOException {
             int toSkip = (int) n;
             // We need to skip from both active buffer and read ahead buffer
             toSkip -= activeBuffer.remaining();
-            assert toSkip > 0; // skipping from activeBuffer already handled.
+            if (toSkip <= 0) { // skipping from activeBuffer already handled.
+                throw new IllegalStateException("Expected toSkip > 0, actual: " + toSkip);
+            }
             activeBuffer.position(0);
             activeBuffer.flip();
             readAheadBuffer.position(toSkip + readAheadBuffer.position());
diff --git a/src/main/java/org/apache/commons/io/input/ReaderInputStream.java b/src/main/java/org/apache/commons/io/input/ReaderInputStream.java
index cfe79fc1..e493884a 100644
--- a/src/main/java/org/apache/commons/io/input/ReaderInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/ReaderInputStream.java
@@ -18,8 +18,11 @@
 
 import static org.apache.commons.io.IOUtils.EOF;
 
+import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
@@ -31,7 +34,6 @@
 
 import org.apache.commons.io.Charsets;
 import org.apache.commons.io.IOUtils;
-import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 import org.apache.commons.io.charset.CharsetEncoders;
 
@@ -43,14 +45,14 @@
  * Since in general it is not possible to predict the number of characters to be read from the {@link Reader} to satisfy a read request on the
  * {@link ReaderInputStream}, all reads from the {@link Reader} are buffered. There is therefore no well defined correlation between the current position of the
  * {@link Reader} and that of the {@link ReaderInputStream}. This also implies that in general there is no need to wrap the underlying {@link Reader} in a
- * {@link java.io.BufferedReader}.
+ * {@link BufferedReader}.
  * </p>
  * <p>
- * {@link ReaderInputStream} implements the inverse transformation of {@link java.io.InputStreamReader}; in the following example, reading from {@code in2}
+ * {@link ReaderInputStream} implements the inverse transformation of {@link InputStreamReader}; in the following example, reading from {@code in2}
  * would return the same byte sequence as reading from {@code in} (provided that the initial byte sequence is legal with respect to the charset encoding):
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <pre>
  * InputStream inputStream = ...
@@ -62,14 +64,14 @@
  *   .get();
  * </pre>
  * <p>
- * {@link ReaderInputStream} implements the same transformation as {@link java.io.OutputStreamWriter}, except that the control flow is reversed: both classes
- * transform a character stream into a byte stream, but {@link java.io.OutputStreamWriter} pushes data to the underlying stream, while {@link ReaderInputStream}
+ * {@link ReaderInputStream} implements the same transformation as {@link OutputStreamWriter}, except that the control flow is reversed: both classes
+ * transform a character stream into a byte stream, but {@link OutputStreamWriter} pushes data to the underlying stream, while {@link ReaderInputStream}
  * pulls it from the underlying stream.
  * </p>
  * <p>
  * Note that while there are use cases where there is no alternative to using this class, very often the need to use this class is an indication of a flaw in
  * the design of the code. This class is typically used in situations where an existing API only accepts an {@link InputStream}, but where the most natural way
- * to produce the data is as a character stream, i.e. by providing a {@link Reader} instance. An example of a situation where this problem may appear is when
+ * to produce the data is as a character stream, by providing a {@link Reader} instance. An example of a situation where this problem may appear is when
  * implementing the {@code javax.activation.DataSource} interface from the Java Activation Framework.
  * </p>
  * <p>
@@ -79,13 +81,16 @@
  * Instances of {@link ReaderInputStream} are not thread safe.
  * </p>
  *
+ * @see Builder
  * @see org.apache.commons.io.output.WriterOutputStream
  * @since 2.0
  */
-public class ReaderInputStream extends InputStream {
+public class ReaderInputStream extends AbstractInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link ReaderInputStream} instance.
+     * Builds a new {@link ReaderInputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -96,31 +101,41 @@ public class ReaderInputStream extends InputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<ReaderInputStream, Builder> {
 
         private CharsetEncoder charsetEncoder = newEncoder(getCharset());
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link ReaderInputStream}.
+         *
          * <p>
-         * This builder use the aspects Reader, Charset, CharsetEncoder, buffer size.
+         * You must set input that supports {@link #getReader()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Reader by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getReader()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>{@link #getCharset()}</li>
+         * <li>{@link CharsetEncoder}</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a Reader.
          * @throws IllegalStateException if the {@code origin} is {@code null}.
-         * @see AbstractOrigin#getReader(Charset)
+         * @see #getReader()
+         * @see CharsetEncoder
+         * @see #getBufferSize()
          */
         @SuppressWarnings("resource")
         @Override
         public ReaderInputStream get() throws IOException {
-            return new ReaderInputStream(checkOrigin().getReader(getCharset()), charsetEncoder, getBufferSize());
+            return new ReaderInputStream(getReader(), charsetEncoder, getBufferSize());
         }
 
         CharsetEncoder getCharsetEncoder() {
@@ -138,7 +153,7 @@ public Builder setCharset(final Charset charset) {
          * Sets the charset encoder. Assumes that the caller has configured the encoder.
          *
          * @param newEncoder the charset encoder, null resets to a default encoder.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setCharsetEncoder(final CharsetEncoder newEncoder) {
             charsetEncoder = CharsetEncoders.toCharsetEncoder(newEncoder, () -> newEncoder(getCharsetDefault()));
@@ -323,6 +338,14 @@ public ReaderInputStream(final Reader reader, final String charsetName, final in
         this(reader, Charsets.toCharset(charsetName), bufferSize);
     }
 
+    @Override
+    public int available() throws IOException {
+        if (encoderOut.hasRemaining()) {
+            return encoderOut.remaining();
+        }
+        return 0;
+    }
+
     /**
      * Closes the stream. This method will cause the underlying {@link Reader} to be closed.
      *
@@ -331,6 +354,7 @@ public ReaderInputStream(final Reader reader, final String charsetName, final in
     @Override
     public void close() throws IOException {
         reader.close();
+        super.close();
     }
 
     /**
@@ -384,6 +408,7 @@ CharsetEncoder getCharsetEncoder() {
      */
     @Override
     public int read() throws IOException {
+        checkOpen();
         for (;;) {
             if (encoderOut.hasRemaining()) {
                 return encoderOut.get() & 0xFF;
diff --git a/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java b/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java
index 7ef620fe..51ffb64e 100644
--- a/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java
+++ b/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java
@@ -36,21 +36,23 @@
 import org.apache.commons.io.Charsets;
 import org.apache.commons.io.FileSystem;
 import org.apache.commons.io.StandardLineSeparator;
-import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
  * Reads lines in a file reversely (similar to a BufferedReader, but starting at the last line). Useful for e.g. searching in log files.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @since 2.2
  */
 public class ReversedLinesFileReader implements Closeable {
 
+    // @formatter:off
     /**
-     * Builds a new {@link ReversedLinesFileReader} instance.
+     * Builds a new {@link ReversedLinesFileReader}.
+     *
      * <p>
      * For example:
      * </p>
@@ -62,12 +64,14 @@ public class ReversedLinesFileReader implements Closeable {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<ReversedLinesFileReader, Builder> {
 
         /**
-         * Constructs a new Builder.
+         * Constructs a new {@link Builder}.
          */
         public Builder() {
             setBufferSizeDefault(DEFAULT_BLOCK_SIZE);
@@ -75,18 +79,26 @@ public Builder() {
         }
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link ReversedLinesFileReader}.
          * <p>
-         * This builder use the aspects Path, Charset, buffer size.
+         * You must set input that supports {@link #getInputStream()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Path by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>{@link #getCharset()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide a Path.
-         * @see AbstractOrigin#getPath()
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to a {@link Path}.
+         * @throws IOException                   if an I/O error occurs.
+         * @see #getPath()
+         * @see #getBufferSize()
+         * @see #getCharset()
          */
         @Override
         public ReversedLinesFileReader get() throws IOException {
@@ -95,7 +107,7 @@ public ReversedLinesFileReader get() throws IOException {
 
     }
 
-    private class FilePart {
+    private final class FilePart {
         private final long no;
 
         private final byte[] data;
@@ -191,7 +203,7 @@ private String readLine() { //NOPMD Bug in PMD
                     break; // skip last few bytes and leave it to the next file part
                 }
 
-                // --- check for newline ---
+                // check for newline
                 if ((newLineMatchByteCount = getNewLineMatchByteCount(data, i)) > 0 /* found newline */) {
                     final int lineStart = i + 1;
                     final int lineLengthBytes = currentLastBytePos - lineStart + 1;
@@ -207,17 +219,17 @@ private String readLine() { //NOPMD Bug in PMD
                     break; // found line
                 }
 
-                // --- move cursor ---
+                // move cursor
                 i -= byteDecrement;
 
-                // --- end of file part handling ---
+                // end of file part handling
                 if (i < 0) {
                     createLeftOver();
                     break; // end of file part
                 }
             }
 
-            // --- last file part handling ---
+            // last file part handling
             if (isLastFilePart && leftOver != null) {
                 // there will be no line break anymore, this is the first line of the file
                 line = new String(leftOver, charset);
@@ -331,11 +343,7 @@ public ReversedLinesFileReader(final File file, final int blockSize, final Chars
      *                  system).
      * @param charsetName  the encoding of the file, null uses the default Charset.
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of
-     *                                                      {@link UnsupportedEncodingException}
-     *                                                      in version 2.2 if the
-     *                                                      encoding is not
-     *                                                      supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
     @Deprecated
@@ -436,11 +444,7 @@ public ReversedLinesFileReader(final Path file, final int blockSize, final Chars
      *                    system).
      * @param charsetName the encoding of the file, null uses the default Charset.
      * @throws IOException                                  if an I/O error occurs
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of
-     *                                                      {@link UnsupportedEncodingException}
-     *                                                      in version 2.2 if the
-     *                                                      encoding is not
-     *                                                      supported.
+     * @throws java.nio.charset.UnsupportedCharsetException if the encoding is not supported
      * @since 2.7
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
diff --git a/src/main/java/org/apache/commons/io/input/SwappedDataInputStream.java b/src/main/java/org/apache/commons/io/input/SwappedDataInputStream.java
index 9239b520..e182974c 100644
--- a/src/main/java/org/apache/commons/io/input/SwappedDataInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/SwappedDataInputStream.java
@@ -26,8 +26,8 @@
 import org.apache.commons.io.EndianUtils;
 
 /**
- * DataInput for systems relying on little endian data formats. When read, values will be changed from little endian to
- * big endian formats for internal usage.
+ * DataInput for systems relying on little-endian data formats. When read, values will be changed from little-endian to
+ * big-endian formats for internal usage.
  * <p>
  * Provenance: Avalon Excalibur (IO)
  * </p>
@@ -68,9 +68,9 @@ public byte readByte() throws IOException, EOFException {
     }
 
     /**
-     * Reads a character delegating to {@link #readShort()}.
+     * Reads a 2 byte, unsigned, little endian UTF-16 code point.
      *
-     * @return the byte read or -1 if the end of stream
+     * @return the UTF-16 code point read or -1 if the end of stream
      * @throws IOException if an I/O error occurs.
      * @throws EOFException if an end of file is reached unexpectedly
      */
@@ -80,7 +80,7 @@ public char readChar() throws IOException, EOFException {
     }
 
     /**
-     * Delegates to {@link EndianUtils#readSwappedDouble(InputStream)}.
+     * Reads an 8 byte, two's complement, little-endian long.
      *
      * @return the read long
      * @throws IOException if an I/O error occurs.
@@ -92,9 +92,9 @@ public double readDouble() throws IOException, EOFException {
     }
 
     /**
-     * Delegates to {@link EndianUtils#readSwappedFloat(InputStream)}.
+     * Reads a 4 byte, IEEE 754, little-endian float.
      *
-     * @return the read long
+     * @return the read float
      * @throws IOException if an I/O error occurs.
      * @throws EOFException if an end of file is reached unexpectedly
      */
@@ -141,9 +141,9 @@ public void readFully(final byte[] data, final int offset, final int length) thr
     }
 
     /**
-     * Delegates to {@link EndianUtils#readSwappedInteger(InputStream)}.
+     * Reads a 4 byte, two's complement little-endian integer.
      *
-     * @return the read long
+     * @return the read int
      * @throws EOFException if an end of file is reached unexpectedly
      * @throws IOException if an I/O error occurs.
      */
@@ -157,7 +157,8 @@ public int readInt() throws IOException, EOFException {
      *
      * @return the line read
      * @throws EOFException if an end of file is reached unexpectedly
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException if an I/O error occurs
+     * @throws UnsupportedOperationException always
      */
     @Override
     public String readLine() throws IOException, EOFException {
@@ -165,7 +166,7 @@ public String readLine() throws IOException, EOFException {
     }
 
     /**
-     * Delegates to {@link EndianUtils#readSwappedLong(InputStream)}.
+     * Reads an 8 byte, two's complement little-endian integer.
      *
      * @return the read long
      * @throws EOFException if an end of file is reached unexpectedly
@@ -177,9 +178,9 @@ public long readLong() throws IOException, EOFException {
     }
 
     /**
-     * Delegates to {@link EndianUtils#readSwappedShort(InputStream)}.
+     * Reads a 2 byte, two's complement, little-endian integer.
      *
-     * @return the read long
+     * @return the read short
      * @throws EOFException if an end of file is reached unexpectedly
      * @throws IOException if an I/O error occurs.
      */
@@ -201,9 +202,9 @@ public int readUnsignedByte() throws IOException, EOFException {
     }
 
     /**
-     * Delegates to {@link EndianUtils#readSwappedUnsignedShort(InputStream)}.
+     * Reads a 2 byte, unsigned, little-endian integer.
      *
-     * @return the read long
+     * @return the read short
      * @throws EOFException if an end of file is reached unexpectedly
      * @throws IOException if an I/O error occurs.
      */
@@ -215,9 +216,10 @@ public int readUnsignedShort() throws IOException, EOFException {
     /**
      * Not currently supported - throws {@link UnsupportedOperationException}.
      *
-     * @return UTF String read
+     * @return never
      * @throws EOFException if an end of file is reached unexpectedly
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException if an I/O error occurs
+     * @throws UnsupportedOperationException always
      */
     @Override
     public String readUTF() throws IOException, EOFException {
@@ -228,12 +230,11 @@ public String readUTF() throws IOException, EOFException {
      * Invokes the delegate's {@code skip(int)} method.
      *
      * @param count the number of bytes to skip
-     * @return the number of bytes to skipped or -1 if the end of stream
-     * @throws EOFException if an end of file is reached unexpectedly
-     * @throws IOException if an I/O error occurs.
+     * @return the number of bytes skipped or -1 if the end of stream
+     * @throws IOException if an I/O error occurs
      */
     @Override
-    public int skipBytes(final int count) throws IOException, EOFException {
+    public int skipBytes(final int count) throws IOException {
         return (int) in.skip(count);
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/Tailer.java b/src/main/java/org/apache/commons/io/input/Tailer.java
index 70ba0f2c..051f15b8 100644
--- a/src/main/java/org/apache/commons/io/input/Tailer.java
+++ b/src/main/java/org/apache/commons/io/input/Tailer.java
@@ -47,18 +47,16 @@
 /**
  * Simple implementation of the UNIX "tail -f" functionality.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <h2>1. Create a TailerListener implementation</h2>
  * <p>
  * First you need to create a {@link TailerListener} implementation; ({@link TailerListenerAdapter} is provided for
  * convenience so that you don't have to implement every method).
  * </p>
- *
  * <p>
  * For example:
  * </p>
- *
  * <pre>
  * public class MyTailerListener extends TailerListenerAdapter {
  *     public void handle(String line) {
@@ -66,9 +64,7 @@
  *     }
  * }
  * </pre>
- *
  * <h2>2. Using a Tailer</h2>
- *
  * <p>
  * You can create and use a Tailer in one of three ways:
  * </p>
@@ -77,13 +73,10 @@
  * <li>Using an {@link java.util.concurrent.Executor}</li>
  * <li>Using a {@link Thread}</li>
  * </ul>
- *
  * <p>
  * An example of each is shown below.
  * </p>
- *
  * <h3>2.1 Using a Builder</h3>
- *
  * <pre>
  * TailerListener listener = new MyTailerListener();
  * Tailer tailer = Tailer.builder()
@@ -92,9 +85,7 @@
  *   .setDelayDuration(delay)
  *   .get();
  * </pre>
- *
  * <h3>2.2 Using an Executor</h3>
- *
  * <pre>
  * TailerListener listener = new MyTailerListener();
  * Tailer tailer = new Tailer(file, listener, delay);
@@ -108,10 +99,7 @@
  *
  * executor.execute(tailer);
  * </pre>
- *
- *
  * <h3>2.3 Using a Thread</h3>
- *
  * <pre>
  * TailerListener listener = new MyTailerListener();
  * Tailer tailer = new Tailer(file, listener, delay);
@@ -119,21 +107,17 @@
  * thread.setDaemon(true); // optional
  * thread.start();
  * </pre>
- *
  * <h2>3. Stopping a Tailer</h2>
  * <p>
  * Remember to stop the tailer when you have done with it:
  * </p>
- *
  * <pre>
  * tailer.stop();
  * </pre>
- *
  * <h2>4. Interrupting a Tailer</h2>
  * <p>
  * You can interrupt the thread a tailer is running on by calling {@link Thread#interrupt()}.
  * </p>
- *
  * <pre>
  * thread.interrupt();
  * </pre>
@@ -144,6 +128,7 @@
  * The file is read using the default Charset; this can be overridden if necessary.
  * </p>
  *
+ * @see Builder
  * @see TailerListener
  * @see TailerListenerAdapter
  * @since 2.0
@@ -154,8 +139,10 @@
  */
 public class Tailer implements Runnable, AutoCloseable {
 
+    // @formatter:off
     /**
-     * Builds a {@link Tailer} with default values.
+     * Builds a new {@link Tailer}.
+     *
      * <p>
      * For example:
      * </p>
@@ -173,8 +160,10 @@ public class Tailer implements Runnable, AutoCloseable {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<Tailer, Builder> {
 
         private static final Duration DEFAULT_DELAY_DURATION = Duration.ofMillis(DEFAULT_DELAY_MILLIS);
@@ -194,22 +183,32 @@ private static Thread newDaemonThread(final Runnable runnable) {
         private Tailable tailable;
         private TailerListener tailerListener;
         private Duration delayDuration = DEFAULT_DELAY_DURATION;
-        private boolean end;
+        private boolean tailFromEnd;
         private boolean reOpen;
         private boolean startThread = true;
         private ExecutorService executorService = Executors.newSingleThreadExecutor(Builder::newDaemonThread);
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link Tailer}.
+         *
          * <p>
-         * This builder use the aspects tailable, Charset, TailerListener, delayDuration, end, reOpen, buffer size.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>{@link #getCharset()}</li>
+         * <li>{@link Tailable}</li>
+         * <li>{@link TailerListener}</li>
+         * <li>delayDuration</li>
+         * <li>tailFromEnd</li>
+         * <li>reOpen</li>
+         * </ul>
          *
          * @return a new instance.
          */
         @Override
         public Tailer get() {
-            final Tailer tailer = new Tailer(tailable, getCharset(), tailerListener, delayDuration, end, reOpen, getBufferSize());
+            final Tailer tailer = new Tailer(tailable, getCharset(), tailerListener, delayDuration, tailFromEnd, reOpen, getBufferSize());
             if (startThread) {
                 executorService.submit(tailer);
             }
@@ -220,7 +219,7 @@ public Tailer get() {
          * Sets the delay duration. null resets to the default delay of one second.
          *
          * @param delayDuration the delay between checks of the file for new content.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setDelayDuration(final Duration delayDuration) {
             this.delayDuration = delayDuration != null ? delayDuration : DEFAULT_DELAY_DURATION;
@@ -231,7 +230,7 @@ public Builder setDelayDuration(final Duration delayDuration) {
          * Sets the executor service to use when startThread is true.
          *
          * @param executorService the executor service to use when startThread is true.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setExecutorService(final ExecutorService executorService) {
             this.executorService = Objects.requireNonNull(executorService, "executorService");
@@ -253,7 +252,7 @@ protected Builder setOrigin(final AbstractOrigin<?, ?> origin) {
          * Sets the re-open behavior.
          *
          * @param reOpen whether to close/reopen the file between chunks
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setReOpen(final boolean reOpen) {
             this.reOpen = reOpen;
@@ -264,7 +263,7 @@ public Builder setReOpen(final boolean reOpen) {
          * Sets the daemon thread startup behavior.
          *
          * @param startThread whether to create a daemon thread automatically.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setStartThread(final boolean startThread) {
             this.startThread = startThread;
@@ -275,7 +274,7 @@ public Builder setStartThread(final boolean startThread) {
          * Sets the tailable.
          *
          * @param tailable the tailable.
-         * @return this.
+         * @return {@code this} instance.
          */
         public Builder setTailable(final Tailable tailable) {
             this.tailable = Objects.requireNonNull(tailable, "tailable");
@@ -286,7 +285,7 @@ public Builder setTailable(final Tailable tailable) {
          * Sets the listener.
          *
          * @param tailerListener the listener.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setTailerListener(final TailerListener tailerListener) {
             this.tailerListener = Objects.requireNonNull(tailerListener, "tailerListener");
@@ -297,10 +296,10 @@ public Builder setTailerListener(final TailerListener tailerListener) {
          * Sets the tail start behavior.
          *
          * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setTailFromEnd(final boolean end) {
-            this.end = end;
+            this.tailFromEnd = end;
             return this;
         }
     }
diff --git a/src/main/java/org/apache/commons/io/input/TailerListener.java b/src/main/java/org/apache/commons/io/input/TailerListener.java
index ae866854..4c4c1ec2 100644
--- a/src/main/java/org/apache/commons/io/input/TailerListener.java
+++ b/src/main/java/org/apache/commons/io/input/TailerListener.java
@@ -26,7 +26,7 @@ public interface TailerListener {
     /**
      * This method is called if the tailed file is not found.
      * <p>
-     * <b>Note:</b> this is called from the tailer thread.
+     * <strong>Note:</strong> this is called from the tailer thread.
      * </p>
      */
     void fileNotFound();
@@ -37,7 +37,7 @@ public interface TailerListener {
      * This method is called before the file is reopened, and fileNotFound may
      * be called if the new file has not yet been created.
      * <p>
-     * <b>Note:</b> this is called from the tailer thread.
+     * <strong>Note:</strong> this is called from the tailer thread.
      * </p>
      */
     void fileRotated();
@@ -45,7 +45,7 @@ public interface TailerListener {
     /**
      * Handles an Exception.
      * <p>
-     * <b>Note:</b> this is called from the tailer thread.
+     * <strong>Note:</strong> this is called from the tailer thread.
      * </p>
      * @param ex the exception.
      */
@@ -54,7 +54,7 @@ public interface TailerListener {
     /**
      * Handles a line from a Tailer.
      * <p>
-     * <b>Note:</b> this is called from the tailer thread.
+     * <strong>Note:</strong> this is called from the tailer thread.
      * </p>
      * @param line the line.
      */
diff --git a/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java b/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java
index 6b8760cb..51b7d9c3 100644
--- a/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java
+++ b/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java
@@ -26,7 +26,7 @@ public class TailerListenerAdapter implements TailerListener {
     /**
      * Called each time the Tailer reaches the end of the file.
      *
-     * <b>Note:</b> this is called from the tailer thread.
+     * <strong>Note:</strong> this is called from the tailer thread.
      *
      * Note: a future version of commons-io will pull this method up to the TailerListener interface,
      * for now clients must subclass this class to use this feature.
diff --git a/src/main/java/org/apache/commons/io/input/ThrottledInputStream.java b/src/main/java/org/apache/commons/io/input/ThrottledInputStream.java
new file mode 100644
index 00000000..1fcc7818
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/input/ThrottledInputStream.java
@@ -0,0 +1,205 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provides bandwidth throttling on a specified InputStream. It is implemented as a wrapper on top of another InputStream instance. The throttling works by
+ * examining the number of bytes read from the underlying InputStream from the beginning, and sleep()ing for a time interval if the byte-transfer is found
+ * exceed the specified tolerable maximum. (Thus, while the read-rate might exceed the maximum for a short interval, the average tends towards the
+ * specified maximum, overall.)
+ * <p>
+ * To build an instance, see {@link Builder}
+ * </p>
+ * <p>
+ * Inspired by Apache HBase's class of the same name.
+ * </p>
+ *
+ * @see Builder
+ * @since 2.16.0
+ */
+public final class ThrottledInputStream extends CountingInputStream {
+
+    // @formatter:off
+    /**
+     * Builds a new {@link ThrottledInputStream}.
+     *
+     * <h2>Using NIO</h2>
+     * <pre>{@code
+     * ThrottledInputStream in = ThrottledInputStream.builder()
+     *   .setPath(Paths.get("MyFile.xml"))
+     *   .setMaxBytesPerSecond(100_000)
+     *   .get();
+     * }
+     * </pre>
+     * <h2>Using IO</h2>
+     * <pre>{@code
+     * ThrottledInputStream in = ThrottledInputStream.builder()
+     *   .setFile(new File("MyFile.xml"))
+     *   .setMaxBytesPerSecond(100_000)
+     *   .get();
+     * }
+     * </pre>
+     * <pre>{@code
+     * ThrottledInputStream in = ThrottledInputStream.builder()
+     *   .setInputStream(inputStream)
+     *   .setMaxBytesPerSecond(100_000)
+     *   .get();
+     * }
+     * </pre>
+     *
+     * @see #get()
+     */
+    // @formatter:on
+    public static class Builder extends AbstractBuilder<ThrottledInputStream, Builder> {
+
+        /**
+         * Effectively not throttled.
+         */
+        private long maxBytesPerSecond = Long.MAX_VALUE;
+
+        /**
+         * Builds a new {@link ThrottledInputStream}.
+         * <p>
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
+         * </p>
+         * <p>
+         * This builder use the following aspects:
+         * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>maxBytesPerSecond</li>
+         * </ul>
+         *
+         * @return a new instance.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
+         * @see #getInputStream()
+         */
+        @SuppressWarnings("resource")
+        @Override
+        public ThrottledInputStream get() throws IOException {
+            return new ThrottledInputStream(this);
+        }
+
+        /**
+         * Sets the maximum bytes per second.
+         *
+         * @param maxBytesPerSecond the maximum bytes per second.
+         */
+        public void setMaxBytesPerSecond(final long maxBytesPerSecond) {
+            this.maxBytesPerSecond = maxBytesPerSecond;
+        }
+
+    }
+
+    /**
+     * Constructs a new {@link Builder}.
+     *
+     * @return a new {@link Builder}.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    static long toSleepMillis(final long bytesRead, final long maxBytesPerSec, final long elapsedMillis) {
+        if (elapsedMillis < 0) {
+            throw new IllegalArgumentException("The elapsed time should be greater or equal to zero");
+        }
+        if (bytesRead <= 0 || maxBytesPerSec <= 0 || elapsedMillis == 0) {
+            return 0;
+        }
+        // We use this class to load the single source file, so the bytesRead
+        // and maxBytesPerSec aren't greater than Double.MAX_VALUE.
+        // We can get the precise sleep time by using the double value.
+        final long millis = (long) ((double) bytesRead / (double) maxBytesPerSec * 1000 - elapsedMillis);
+        if (millis <= 0) {
+            return 0;
+        }
+        return millis;
+    }
+
+    private final long maxBytesPerSecond;
+    private final long startTime = System.currentTimeMillis();
+    private Duration totalSleepDuration = Duration.ZERO;
+
+    private ThrottledInputStream(final Builder builder) throws IOException {
+        super(builder);
+        if (builder.maxBytesPerSecond <= 0) {
+            throw new IllegalArgumentException("Bandwidth " + builder.maxBytesPerSecond + " is invalid.");
+        }
+        this.maxBytesPerSecond = builder.maxBytesPerSecond;
+    }
+
+    @Override
+    protected void beforeRead(final int n) throws IOException {
+        throttle();
+    }
+
+    /**
+     * Gets the read-rate from this stream, since creation. Calculated as bytesRead/elapsedTimeSinceStart.
+     *
+     * @return Read rate, in bytes/sec.
+     */
+    private long getBytesPerSecond() {
+        final long elapsedSeconds = (System.currentTimeMillis() - startTime) / 1000;
+        if (elapsedSeconds == 0) {
+            return getByteCount();
+        }
+        return getByteCount() / elapsedSeconds;
+    }
+
+    private long getSleepMillis() {
+        return toSleepMillis(getByteCount(), maxBytesPerSecond, System.currentTimeMillis() - startTime);
+    }
+
+    /**
+     * Gets the total duration spent in sleep.
+     *
+     * @return Duration spent in sleep.
+     */
+    Duration getTotalSleepDuration() {
+        return totalSleepDuration;
+    }
+
+    private void throttle() throws InterruptedIOException {
+        final long sleepMillis = getSleepMillis();
+        if (sleepMillis > 0) {
+            totalSleepDuration = totalSleepDuration.plus(sleepMillis, ChronoUnit.MILLIS);
+            try {
+                TimeUnit.MILLISECONDS.sleep(sleepMillis);
+            } catch (final InterruptedException e) {
+                throw new InterruptedIOException("Thread aborted");
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public String toString() {
+        return "ThrottledInputStream[bytesRead=" + getByteCount() + ", maxBytesPerSec=" + maxBytesPerSecond + ", bytesPerSec=" + getBytesPerSecond()
+                + ", totalSleepDuration=" + totalSleepDuration + ']';
+    }
+}
diff --git a/src/main/java/org/apache/commons/io/input/TimestampedObserver.java b/src/main/java/org/apache/commons/io/input/TimestampedObserver.java
index c331c86c..27540b8d 100644
--- a/src/main/java/org/apache/commons/io/input/TimestampedObserver.java
+++ b/src/main/java/org/apache/commons/io/input/TimestampedObserver.java
@@ -45,6 +45,13 @@ public class TimestampedObserver extends Observer {
     private volatile Instant closeInstant;
     private final Instant openInstant = Instant.now();
 
+    /**
+     * Constructs a new instance.
+     */
+    public TimestampedObserver() {
+        // empty
+    }
+
     @Override
     public void closed() throws IOException {
         closeInstant = Instant.now();
diff --git a/src/main/java/org/apache/commons/io/input/UncheckedBufferedReader.java b/src/main/java/org/apache/commons/io/input/UncheckedBufferedReader.java
index c0cd7c5a..a8b46b79 100644
--- a/src/main/java/org/apache/commons/io/input/UncheckedBufferedReader.java
+++ b/src/main/java/org/apache/commons/io/input/UncheckedBufferedReader.java
@@ -22,18 +22,17 @@
 import java.io.Reader;
 import java.io.UncheckedIOException;
 import java.nio.CharBuffer;
-import java.nio.charset.Charset;
 
-import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 import org.apache.commons.io.function.Uncheck;
 
 /**
  * A {@link BufferedReader} that throws {@link UncheckedIOException} instead of {@link IOException}.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see BufferedReader
  * @see IOException
  * @see UncheckedIOException
@@ -41,8 +40,10 @@
  */
 public final class UncheckedBufferedReader extends BufferedReader {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UncheckedBufferedReader} instance.
+     * Builds a new {@link UncheckedBufferedReader}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -63,28 +64,36 @@ public final class UncheckedBufferedReader extends BufferedReader {
      *   .setCharset(Charset.defaultCharset())
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UncheckedBufferedReader, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UncheckedBufferedReader}.
+         *
          * <p>
-         * This builder use the aspects Reader, Charset, buffer size.
+         * You must set input that supports {@link #getReader()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Reader by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getReader()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a Reader.
          * @throws IllegalStateException if the {@code origin} is {@code null}.
-         * @see AbstractOrigin#getReader(Charset)
+         * @see #getReader()
+         * @see #getBufferSize()
          */
         @Override
         public UncheckedBufferedReader get() {
             // This an unchecked class, so this method is as well.
-            return Uncheck.get(() -> new UncheckedBufferedReader(checkOrigin().getReader(getCharset()), getBufferSize()));
+            return Uncheck.get(() -> new UncheckedBufferedReader(getReader(), getBufferSize()));
         }
 
     }
diff --git a/src/main/java/org/apache/commons/io/input/UncheckedFilterInputStream.java b/src/main/java/org/apache/commons/io/input/UncheckedFilterInputStream.java
index d1b00c2b..3fa04986 100644
--- a/src/main/java/org/apache/commons/io/input/UncheckedFilterInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/UncheckedFilterInputStream.java
@@ -29,9 +29,10 @@
 /**
  * A {@link BufferedReader} that throws {@link UncheckedIOException} instead of {@link IOException}.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see BufferedReader
  * @see IOException
  * @see UncheckedIOException
@@ -39,8 +40,10 @@
  */
 public final class UncheckedFilterInputStream extends FilterInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UncheckedFilterInputStream} instance.
+     * Builds a new {@link UncheckedFilterInputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -57,18 +60,23 @@ public final class UncheckedFilterInputStream extends FilterInputStream {
      *   .setPath(path)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UncheckedFilterInputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UncheckedFilterInputStream}.
          * <p>
-         * This builder use the aspect InputStream and OpenOption[].
+         * You must set input that supports {@link #getInputStream()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
diff --git a/src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java b/src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java
index 4b9fe8e1..176e8bcc 100644
--- a/src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java
+++ b/src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java
@@ -22,18 +22,17 @@
 import java.io.Reader;
 import java.io.UncheckedIOException;
 import java.nio.CharBuffer;
-import java.nio.charset.Charset;
 
-import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 import org.apache.commons.io.function.Uncheck;
 
 /**
  * A {@link FilterReader} that throws {@link UncheckedIOException} instead of {@link IOException}.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see FilterReader
  * @see IOException
  * @see UncheckedIOException
@@ -41,8 +40,10 @@
  */
 public final class UncheckedFilterReader extends FilterReader {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UncheckedFilterReader} instance.
+     * Builds a new {@link UncheckedFilterReader}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -59,28 +60,33 @@ public final class UncheckedFilterReader extends FilterReader {
      *   .setPath(path)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UncheckedFilterReader, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UncheckedFilterReader}.
          * <p>
-         * This builder use the aspects Reader and Charset.
+         * You must set input that supports {@link #getReader()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Reader by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getReader()}</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a Reader.
          * @throws IllegalStateException if the {@code origin} is {@code null}.
-         * @see AbstractOrigin#getReader(Charset)
+         * @see #getReader()
          */
         @Override
         public UncheckedFilterReader get() {
             // This an unchecked class, so this method is as well.
-            return Uncheck.get(() -> new UncheckedFilterReader(checkOrigin().getReader(getCharset())));
+            return Uncheck.get(() -> new UncheckedFilterReader(getReader()));
         }
 
     }
diff --git a/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java b/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java
index 7b0ebb22..c19ac652 100644
--- a/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java
@@ -82,7 +82,7 @@ private int handleEos(final boolean previousWasSlashCr) {
      * {@inheritDoc}
      */
     @Override
-    public synchronized void mark(final int readlimit) {
+    public synchronized void mark(final int readLimit) {
         throw UnsupportedOperationExceptions.mark();
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/UnsupportedOperationExceptions.java b/src/main/java/org/apache/commons/io/input/UnsupportedOperationExceptions.java
index f8507523..36282196 100644
--- a/src/main/java/org/apache/commons/io/input/UnsupportedOperationExceptions.java
+++ b/src/main/java/org/apache/commons/io/input/UnsupportedOperationExceptions.java
@@ -24,7 +24,7 @@
  * TODO Consider making this public and use from LineIterator but this feels like it belongs in LANG rather than IO.
  * </p>
  */
-class UnsupportedOperationExceptions {
+final class UnsupportedOperationExceptions {
 
     private static final String MARK_RESET = "mark/reset";
 
diff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java
index b33a1187..c715daef 100644
--- a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java
@@ -32,7 +32,7 @@
  * takes place when filling that buffer, but this is usually outweighed by the performance benefits.
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * A typical application pattern for the class looks like this:
@@ -48,14 +48,17 @@
  * Provenance: Apache Harmony and modified.
  * </p>
  *
+ * @see Builder
  * @see BufferedInputStream
  * @since 2.12.0
  */
 //@NotThreadSafe
 public final class UnsynchronizedBufferedInputStream extends UnsynchronizedFilterInputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UnsynchronizedBufferedInputStream} instance.
+     * Builds a new {@link UnsynchronizedBufferedInputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -74,22 +77,31 @@ public final class UnsynchronizedBufferedInputStream extends UnsynchronizedFilte
      *   .setBufferSize(8192)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UnsynchronizedBufferedInputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UnsynchronizedBufferedInputStream}.
          * <p>
-         * This builder use the aspects InputStream, OpenOption[] and buffer size.
+         * You must set input that supports {@link #getInputStream()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getInputStream()
+         * @see #getBufferSize()
          */
         @SuppressWarnings("resource") // Caller closes.
         @Override
@@ -173,7 +185,7 @@ public void close() throws IOException {
 
     private int fillBuffer(final InputStream localIn, byte[] localBuf) throws IOException {
         if (markPos == IOUtils.EOF || pos - markPos >= markLimit) {
-            /* Mark position not set or exceeded readlimit */
+            /* Mark position not set or exceeded readLimit */
             final int result = localIn.read(localBuf);
             if (result > 0) {
                 markPos = IOUtils.EOF;
@@ -183,7 +195,7 @@ private int fillBuffer(final InputStream localIn, byte[] localBuf) throws IOExce
             return result;
         }
         if (markPos == 0 && markLimit > localBuf.length) {
-            /* Increase buffer size to accommodate the readlimit */
+            /* Increase buffer size to accommodate the readLimit */
             int newLength = localBuf.length * 2;
             if (newLength > markLimit) {
                 newLength = markLimit;
@@ -196,7 +208,7 @@ private int fillBuffer(final InputStream localIn, byte[] localBuf) throws IOExce
         } else if (markPos > 0) {
             System.arraycopy(localBuf, markPos, localBuf, 0, localBuf.length - markPos);
         }
-        /* Set the new position and mark position */
+        // Set the new position and mark position
         pos -= markPos;
         count = markPos = 0;
         final int bytesread = localIn.read(localBuf, pos, localBuf.length - pos);
@@ -209,16 +221,16 @@ byte[] getBuffer() {
     }
 
     /**
-     * Sets a mark position in this stream. The parameter {@code readlimit} indicates how many bytes can be read before a mark is invalidated. Calling
-     * {@code reset()} will reposition the stream back to the marked position if {@code readlimit} has not been surpassed. The underlying buffer may be
-     * increased in size to allow {@code readlimit} number of bytes to be supported.
+     * Sets a mark position in this stream. The parameter {@code readLimit} indicates how many bytes can be read before a mark is invalidated. Calling
+     * {@code reset()} will reposition the stream back to the marked position if {@code readLimit} has not been surpassed. The underlying buffer may be
+     * increased in size to allow {@code readLimit} number of bytes to be supported.
      *
-     * @param readlimit the number of bytes that can be read before the mark is invalidated.
+     * @param readLimit the number of bytes that can be read before the mark is invalidated.
      * @see #reset()
      */
     @Override
-    public void mark(final int readlimit) {
-        markLimit = readlimit;
+    public void mark(final int readLimit) {
+        markLimit = readLimit;
         markPos = pos;
     }
 
@@ -358,7 +370,7 @@ public int read(final byte[] dest, int offset, final int length) throws IOExcept
     /**
      * Resets this stream to the last marked location.
      *
-     * @throws IOException if this stream is closed, no mark has been set or the mark is no longer valid because more than {@code readlimit} bytes have been
+     * @throws IOException if this stream is closed, no mark has been set or the mark is no longer valid because more than {@code readLimit} bytes have been
      *                     read since setting the mark.
      * @see #mark(int)
      */
diff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java
new file mode 100644
index 00000000..8ff11faa
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java
@@ -0,0 +1,478 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.CR;
+import static org.apache.commons.io.IOUtils.EOF;
+import static org.apache.commons.io.IOUtils.LF;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.commons.io.IOUtils;
+
+/**
+ * Wraps an existing {@link Reader} and buffers the input <em>without any synchronization</em>. Expensive interaction with the underlying reader is minimized,
+ * since most (smaller) requests can be satisfied by accessing the buffer alone. The drawback is that some extra space is required to hold the buffer and that
+ * copying takes place when filling that buffer, but this is usually outweighed by the performance benefits.
+ * <p>
+ * A typical application pattern for the class looks like this:
+ * </p>
+ *
+ * <pre>{@code
+ * UnsynchronizedBufferedReader buf = new UnsynchronizedBufferedReader(new FileReader("file"));
+ * }</pre>
+ * <p>
+ * Provenance: Apache Harmony's java.io.BufferedReader, renamed, and modified.
+ * </p>
+ *
+ * @see BufferedReader
+ * @see BufferedWriter
+ * @since 2.17.0
+ */
+public class UnsynchronizedBufferedReader extends UnsynchronizedReader {
+
+    private static final char NUL = '\0';
+
+    private final Reader in;
+
+    /**
+     * The characters that can be read and refilled in bulk. We maintain three indices into this buffer:
+     *
+     * <pre>
+     *     { X X X X X X X X X X X X - - }
+     *           ^     ^             ^
+     *           |     |             |
+     *         mark   pos           end
+     * </pre>
+     * <p>
+     * Pos points to the next readable character. End is one greater than the last readable character. When {@code pos == end}, the buffer is empty and must be
+     * {@link #fillBuf() filled} before characters can be read.
+     * </p>
+     * <p>
+     * Mark is the value pos will be set to on calls to {@link #reset()}. Its value is in the range {@code [0...pos]}. If the mark is {@code -1}, the buffer
+     * cannot be reset.
+     * </p>
+     * <p>
+     * MarkLimit limits the distance between the mark and the pos. When this limit is exceeded, {@link #reset()} is permitted (but not required) to throw an
+     * exception. For shorter distances, {@link #reset()} shall not throw (unless the reader is closed).
+     * </p>
+     */
+    private char[] buf;
+
+    private int pos;
+
+    private int end;
+
+    private int mark = -1;
+
+    private int markLimit = -1;
+
+    /**
+     * Constructs a new BufferedReader on the Reader {@code in}. The buffer gets the default size (8 KB).
+     *
+     * @param in the Reader that is buffered.
+     */
+    public UnsynchronizedBufferedReader(final Reader in) {
+        this(in, IOUtils.DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Constructs a new BufferedReader on the Reader {@code in}. The buffer size is specified by the parameter {@code size}.
+     *
+     * @param in   the Reader that is buffered.
+     * @param size the size of the buffer to allocate.
+     * @throws IllegalArgumentException if {@code size <= 0}.
+     */
+    public UnsynchronizedBufferedReader(final Reader in, final int size) {
+        if (size <= 0) {
+            throw new IllegalArgumentException("size <= 0");
+        }
+        this.in = in;
+        buf = new char[size];
+    }
+
+    /**
+     * Peeks at the next input character, refilling the buffer if necessary. If this character is a newline character ("\n"), it is discarded.
+     */
+    final void chompNewline() throws IOException {
+        if ((pos != end || fillBuf() != EOF) && buf[pos] == LF) {
+            pos++;
+        }
+    }
+
+    /**
+     * Closes this reader. This implementation closes the buffered source reader and releases the buffer. Nothing is done if this reader has already been
+     * closed.
+     *
+     * @throws IOException if an error occurs while closing this reader.
+     */
+    @Override
+    public void close() throws IOException {
+        if (!isClosed()) {
+            in.close();
+            buf = null;
+            super.close();
+        }
+    }
+
+    /**
+     * Populates the buffer with data. It is an error to call this method when the buffer still contains data; ie. if {@code pos < end}.
+     *
+     * @return the number of bytes read into the buffer, or -1 if the end of the source stream has been reached.
+     */
+    private int fillBuf() throws IOException {
+        // assert(pos == end);
+
+        if (mark == EOF || pos - mark >= markLimit) {
+            /* mark isn't set or has exceeded its limit. use the whole buffer */
+            final int result = in.read(buf, 0, buf.length);
+            if (result > 0) {
+                mark = -1;
+                pos = 0;
+                end = result;
+            }
+            return result;
+        }
+
+        if (mark == 0 && markLimit > buf.length) {
+            /* the only way to make room when mark=0 is by growing the buffer */
+            int newLength = buf.length * 2;
+            if (newLength > markLimit) {
+                newLength = markLimit;
+            }
+            final char[] newbuf = new char[newLength];
+            System.arraycopy(buf, 0, newbuf, 0, buf.length);
+            buf = newbuf;
+        } else if (mark > 0) {
+            /* make room by shifting the buffered data to left mark positions */
+            System.arraycopy(buf, mark, buf, 0, buf.length - mark);
+            pos -= mark;
+            end -= mark;
+            mark = 0;
+        }
+
+        /* Set the new position and mark position */
+        final int count = in.read(buf, pos, buf.length - pos);
+        if (count != EOF) {
+            end += count;
+        }
+        return count;
+    }
+
+    /**
+     * Sets a mark position in this reader. The parameter {@code markLimit} indicates how many characters can be read before the mark is invalidated. Calling
+     * {@link #reset()} will reposition the reader back to the marked position if {@code markLimit} has not been surpassed.
+     *
+     * @param markLimit the number of characters that can be read before the mark is invalidated.
+     * @throws IllegalArgumentException if {@code markLimit < 0}.
+     * @throws IOException              if an error occurs while setting a mark in this reader.
+     * @see #markSupported()
+     * @see #reset()
+     */
+    @Override
+    public void mark(final int markLimit) throws IOException {
+        if (markLimit < 0) {
+            throw new IllegalArgumentException();
+        }
+        checkOpen();
+        this.markLimit = markLimit;
+        mark = pos;
+    }
+
+    /**
+     * Tests whether this reader supports the {@link #mark(int)} and {@link #reset()} methods. This implementation returns {@code true}.
+     *
+     * @return {@code true} for {@code BufferedReader}.
+     * @see #mark(int)
+     * @see #reset()
+     */
+    @Override
+    public boolean markSupported() {
+        return true;
+    }
+
+    /**
+     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will still return this value.
+     *
+     * @return the next character
+     * @throws IOException If an I/O error occurs
+     */
+    public int peek() throws IOException {
+        mark(1);
+        final int c = read();
+        reset();
+        return c;
+    }
+
+    /**
+     * Populates the buffer with the next {@code buf.length} characters in the current reader without consuming them. The next call to {@link #read()} will
+     * still return the next value.
+     *
+     * @param buf the buffer to fill for the look ahead.
+     * @return the buffer itself
+     * @throws IOException If an I/O error occurs
+     */
+    public int peek(final char[] buf) throws IOException {
+        final int n = buf.length;
+        mark(n);
+        final int c = read(buf, 0, n);
+        reset();
+        return c;
+    }
+
+    /**
+     * Reads a single character from this reader and returns it with the two higher-order bytes set to 0. If possible, BufferedReader returns a character from
+     * the buffer. If there are no characters available in the buffer, it fills the buffer and then returns a character. It returns -1 if there are no more
+     * characters in the source reader.
+     *
+     * @return the character read or -1 if the end of the source reader has been reached.
+     * @throws IOException if this reader is closed or some other I/O error occurs.
+     */
+    @Override
+    public int read() throws IOException {
+        checkOpen();
+        /* Are there buffered characters available? */
+        if (pos < end || fillBuf() != EOF) {
+            return buf[pos++];
+        }
+        return EOF;
+    }
+
+    /**
+     * Reads at most {@code length} characters from this reader and stores them at {@code offset} in the character array {@code buffer}. Returns the number of
+     * characters actually read or -1 if the end of the source reader has been reached. If all the buffered characters have been used, a mark has not been set
+     * and the requested number of characters is larger than this readers buffer size, BufferedReader bypasses the buffer and simply places the results directly
+     * into {@code buffer}.
+     *
+     * @param buffer the character array to store the characters read.
+     * @param offset the initial position in {@code buffer} to store the bytes read from this reader.
+     * @param length the maximum number of characters to read, must be non-negative.
+     * @return number of characters read or -1 if the end of the source reader has been reached.
+     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code length < 0}, or if {@code offset + length} is greater than the size of {@code buffer}.
+     * @throws IOException               if this reader is closed or some other I/O error occurs.
+     */
+    @Override
+    public int read(final char[] buffer, int offset, final int length) throws IOException {
+        checkOpen();
+        if (offset < 0 || offset > buffer.length - length || length < 0) {
+            throw new IndexOutOfBoundsException();
+        }
+        int outstanding = length;
+        while (outstanding > 0) {
+
+            /*
+             * If there are bytes in the buffer, grab those first.
+             */
+            final int available = end - pos;
+            if (available > 0) {
+                final int count = available >= outstanding ? outstanding : available;
+                System.arraycopy(buf, pos, buffer, offset, count);
+                pos += count;
+                offset += count;
+                outstanding -= count;
+            }
+
+            /*
+             * Before attempting to read from the underlying stream, make sure we really, really want to. We won't bother if we're done, or if we've already got
+             * some bytes and reading from the underlying stream would block.
+             */
+            if (outstanding == 0 || outstanding < length && !in.ready()) {
+                break;
+            }
+
+            // assert(pos == end);
+
+            /*
+             * If we're unmarked and the requested size is greater than our buffer, read the bytes directly into the caller's buffer. We don't read into smaller
+             * buffers because that could result in a many reads.
+             */
+            if ((mark == -1 || pos - mark >= markLimit) && outstanding >= buf.length) {
+                final int count = in.read(buffer, offset, outstanding);
+                if (count > 0) {
+                    outstanding -= count;
+                    mark = -1;
+                }
+
+                break; // assume the source stream gave us all that it could
+            }
+
+            if (fillBuf() == EOF) {
+                break; // source is exhausted
+            }
+        }
+
+        final int count = length - outstanding;
+        return count > 0 || count == length ? count : EOF;
+    }
+
+    /**
+     * Returns the next line of text available from this reader. A line is represented by zero or more characters followed by {@code LF}, {@code CR},
+     * {@code "\r\n"} or the end of the reader. The string does not include the newline sequence.
+     *
+     * @return the contents of the line or {@code null} if no characters were read before the end of the reader has been reached.
+     * @throws IOException if this reader is closed or some other I/O error occurs.
+     */
+    public String readLine() throws IOException {
+        checkOpen();
+        /* has the underlying stream been exhausted? */
+        if (pos == end && fillBuf() == EOF) {
+            return null;
+        }
+        for (int charPos = pos; charPos < end; charPos++) {
+            final char ch = buf[charPos];
+            if (ch > CR) {
+                continue;
+            }
+            if (ch == LF) {
+                final String res = new String(buf, pos, charPos - pos);
+                pos = charPos + 1;
+                return res;
+            }
+            if (ch == CR) {
+                final String res = new String(buf, pos, charPos - pos);
+                pos = charPos + 1;
+                if ((pos < end || fillBuf() != EOF) && buf[pos] == LF) {
+                    pos++;
+                }
+                return res;
+            }
+        }
+
+        char eol = NUL;
+        final StringBuilder result = new StringBuilder(80);
+        /* Typical Line Length */
+
+        result.append(buf, pos, end - pos);
+        while (true) {
+            pos = end;
+
+            /* Are there buffered characters available? */
+            if (eol == LF) {
+                return result.toString();
+            }
+            // attempt to fill buffer
+            if (fillBuf() == EOF) {
+                // characters or null.
+                return result.length() > 0 || eol != NUL ? result.toString() : null;
+            }
+            for (int charPos = pos; charPos < end; charPos++) {
+                final char c = buf[charPos];
+                if (eol != NUL) {
+                    if (eol == CR && c == LF) {
+                        if (charPos > pos) {
+                            result.append(buf, pos, charPos - pos - 1);
+                        }
+                        pos = charPos + 1;
+                    } else {
+                        if (charPos > pos) {
+                            result.append(buf, pos, charPos - pos - 1);
+                        }
+                        pos = charPos;
+                    }
+                    return result.toString();
+                }
+                if (c == LF || c == CR) {
+                    eol = c;
+                }
+            }
+            if (eol == NUL) {
+                result.append(buf, pos, end - pos);
+            } else {
+                result.append(buf, pos, end - pos - 1);
+            }
+        }
+    }
+
+    /**
+     * Tests whether this reader is ready to be read without blocking.
+     *
+     * @return {@code true} if this reader will not block when {@code read} is called, {@code false} if unknown or blocking will occur.
+     * @throws IOException if this reader is closed or some other I/O error occurs.
+     * @see #read()
+     * @see #read(char[], int, int)
+     * @see #readLine()
+     */
+    @Override
+    public boolean ready() throws IOException {
+        checkOpen();
+        return end - pos > 0 || in.ready();
+    }
+
+    /**
+     * Resets this reader's position to the last {@code mark()} location. Invocations of {@code read()} and {@code skip()} will occur from this new location.
+     *
+     * @throws IOException if this reader is closed or no mark has been set.
+     * @see #mark(int)
+     * @see #markSupported()
+     */
+    @Override
+    public void reset() throws IOException {
+        checkOpen();
+        if (mark == -1) {
+            throw new IOException("mark == -1");
+        }
+        pos = mark;
+    }
+
+    /**
+     * Skips {@code amount} characters in this reader. Subsequent {@code read()}s will not return these characters unless {@code reset()} is used. Skipping
+     * characters may invalidate a mark if {@code markLimit} is surpassed.
+     *
+     * @param amount the maximum number of characters to skip.
+     * @return the number of characters actually skipped.
+     * @throws IllegalArgumentException if {@code amount < 0}.
+     * @throws IOException              if this reader is closed or some other I/O error occurs.
+     * @see #mark(int)
+     * @see #markSupported()
+     * @see #reset()
+     */
+    @Override
+    public long skip(final long amount) throws IOException {
+        if (amount < 0) {
+            throw new IllegalArgumentException();
+        }
+        checkOpen();
+        if (amount < 1) {
+            return 0;
+        }
+        if (end - pos >= amount) {
+            pos += Math.toIntExact(amount);
+            return amount;
+        }
+
+        long read = end - pos;
+        pos = end;
+        while (read < amount) {
+            if (fillBuf() == EOF) {
+                return read;
+            }
+            if (end - pos >= amount - read) {
+                pos += Math.toIntExact(amount - read);
+                return amount;
+            }
+            // Couldn't get all the characters, skip what we read
+            read += end - pos;
+            pos = end;
+        }
+        return amount;
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java
index f10c1120..e351baad 100644
--- a/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java
@@ -16,8 +16,6 @@
  */
 package org.apache.commons.io.input;
 
-import static java.lang.Math.min;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -27,72 +25,82 @@
 import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
- * This is an alternative to {@link java.io.ByteArrayInputStream} which removes the synchronization overhead for non-concurrent access; as such this class is
+ * This is an alternative to {@link ByteArrayInputStream} which removes the synchronization overhead for non-concurrent access; as such this class is
  * not thread-safe.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see ByteArrayInputStream
  * @since 2.7
  */
 //@NotThreadSafe
 public class UnsynchronizedByteArrayInputStream extends InputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UnsynchronizedByteArrayInputStream} instance.
+     * Builds a new {@link UnsynchronizedByteArrayInputStream}.
+     *
      * <p>
      * Using a Byte Array:
      * </p>
-     *
      * <pre>{@code
      * UnsynchronizedByteArrayInputStream s = UnsynchronizedByteArrayInputStream.builder()
      *   .setByteArray(byteArray)
      *   .setOffset(0)
      *   .setLength(byteArray.length)
-     *   .get();}
+     *   .get();
+     * }
      * </pre>
      * <p>
      * Using File IO:
      * </p>
-     *
      * <pre>{@code
      * UnsynchronizedByteArrayInputStream s = UnsynchronizedByteArrayInputStream.builder()
      *   .setFile(file)
      *   .setOffset(0)
      *   .setLength(byteArray.length)
-     *   .get();}
+     *   .get();
+     * }
      * </pre>
      * <p>
      * Using NIO Path:
      * </p>
-     *
      * <pre>{@code
      * UnsynchronizedByteArrayInputStream s = UnsynchronizedByteArrayInputStream.builder()
      *   .setPath(path)
      *   .setOffset(0)
      *   .setLength(byteArray.length)
-     *   .get();}
+     *   .get();
+     * }
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UnsynchronizedByteArrayInputStream, Builder> {
 
         private int offset;
         private int length;
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UnsynchronizedByteArrayInputStream}.
          * <p>
-         * This builder use the aspects byte[], offset and length.
+         * You must set input that supports {@code byte[]} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a byte[] by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@code byte[]}</li>
+         * <li>offset</li>
+         * <li>length</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a byte[].
-         * @throws IllegalStateException if the {@code origin} is {@code null}.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
          * @see AbstractOrigin#getByteArray()
          */
         @Override
@@ -110,7 +118,7 @@ public Builder setByteArray(final byte[] origin) {
          * Sets the length.
          *
          * @param length Must be greater or equal to 0.
-         * @return this.
+         * @return {@code this} instance.
          */
         public Builder setLength(final int length) {
             if (length < 0) {
@@ -124,7 +132,7 @@ public Builder setLength(final int length) {
          * Sets the offset.
          *
          * @param offset Must be greater or equal to 0.
-         * @return this.
+         * @return {@code this} instance.
          */
         public Builder setOffset(final int offset) {
             if (offset < 0) {
@@ -150,6 +158,18 @@ public static Builder builder() {
         return new Builder();
     }
 
+    private static int minPosLen(final byte[] data, final int defaultValue) {
+        requireNonNegative(defaultValue, "defaultValue");
+        return Math.min(defaultValue, data.length > 0 ? data.length : defaultValue);
+    }
+
+    private static int requireNonNegative(final int value, final String name) {
+        if (value < 0) {
+            throw new IllegalArgumentException(name + " cannot be negative");
+        }
+        return value;
+    }
+
     /**
      * The underlying data buffer.
      */
@@ -158,7 +178,7 @@ public static Builder builder() {
     /**
      * End Of Data.
      *
-     * Similar to data.length, i.e. the last readable offset + 1.
+     * Similar to data.length, which is the last readable offset + 1.
      */
     private final int eod;
 
@@ -180,10 +200,7 @@ public static Builder builder() {
      */
     @Deprecated
     public UnsynchronizedByteArrayInputStream(final byte[] data) {
-        this.data = Objects.requireNonNull(data, "data");
-        this.offset = 0;
-        this.eod = data.length;
-        this.markedOffset = this.offset;
+        this(data, data.length, 0, 0);
     }
 
     /**
@@ -197,14 +214,7 @@ public UnsynchronizedByteArrayInputStream(final byte[] data) {
      */
     @Deprecated
     public UnsynchronizedByteArrayInputStream(final byte[] data, final int offset) {
-        Objects.requireNonNull(data, "data");
-        if (offset < 0) {
-            throw new IllegalArgumentException("offset cannot be negative");
-        }
-        this.data = data;
-        this.offset = min(offset, data.length > 0 ? data.length : offset);
-        this.eod = data.length;
-        this.markedOffset = this.offset;
+        this(data, data.length, Math.min(requireNonNegative(offset, "offset"), minPosLen(data, offset)), minPosLen(data, offset));
     }
 
     /**
@@ -219,16 +229,19 @@ public UnsynchronizedByteArrayInputStream(final byte[] data, final int offset) {
      */
     @Deprecated
     public UnsynchronizedByteArrayInputStream(final byte[] data, final int offset, final int length) {
-        if (offset < 0) {
-            throw new IllegalArgumentException("offset cannot be negative");
-        }
-        if (length < 0) {
-            throw new IllegalArgumentException("length cannot be negative");
-        }
+        requireNonNegative(offset, "offset");
+        requireNonNegative(length, "length");
         this.data = Objects.requireNonNull(data, "data");
-        this.offset = min(offset, data.length > 0 ? data.length : offset);
-        this.eod = min(this.offset + length, data.length);
-        this.markedOffset = this.offset;
+        this.eod = Math.min(minPosLen(data, offset) + length, data.length);
+        this.offset = minPosLen(data, offset);
+        this.markedOffset = minPosLen(data, offset);
+    }
+
+    private UnsynchronizedByteArrayInputStream(final byte[] data, final int eod, final int offset, final int markedOffset) {
+        this.data = Objects.requireNonNull(data, "data");
+        this.eod = eod;
+        this.offset = offset;
+        this.markedOffset = markedOffset;
     }
 
     @Override
@@ -238,7 +251,7 @@ public int available() {
 
     @SuppressWarnings("sync-override")
     @Override
-    public void mark(final int readlimit) {
+    public void mark(final int readLimit) {
         this.markedOffset = this.offset;
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedFilterInputStream.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedFilterInputStream.java
index 0465cd6b..fd199ceb 100644
--- a/src/main/java/org/apache/commons/io/input/UnsynchronizedFilterInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedFilterInputStream.java
@@ -31,20 +31,23 @@
  * and provide some additional functionality on top of it usually inherit from this class.
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
  * Provenance: Apache Harmony and modified.
  * </p>
  *
+ * @see Builder
  * @see FilterInputStream
  * @since 2.12.0
  */
 //@NotThreadSafe
 public class UnsynchronizedFilterInputStream extends InputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UnsynchronizedFilterInputStream} instance.
+     * Builds a new {@link UnsynchronizedFilterInputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -61,21 +64,28 @@ public class UnsynchronizedFilterInputStream extends InputStream {
      *   .setPath(path)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UnsynchronizedFilterInputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UnsynchronizedFilterInputStream}.
          * <p>
-         * This builder use the aspect InputStream and OpenOption[].
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getInputStream()
          */
         @SuppressWarnings("resource") // Caller closes.
@@ -131,19 +141,19 @@ public void close() throws IOException {
     }
 
     /**
-     * Sets a mark position in this stream. The parameter {@code readlimit} indicates how many bytes can be read before the mark is invalidated. Sending
-     * {@code reset()} will reposition this stream back to the marked position, provided that {@code readlimit} has not been surpassed.
+     * Sets a mark position in this stream. The parameter {@code readLimit} indicates how many bytes can be read before the mark is invalidated. Sending
+     * {@code reset()} will reposition this stream back to the marked position, provided that {@code readLimit} has not been surpassed.
      * <p>
      * This implementation sets a mark in the filtered stream.
      *
-     * @param readlimit the number of bytes that can be read from this stream before the mark is invalidated.
+     * @param readLimit the number of bytes that can be read from this stream before the mark is invalidated.
      * @see #markSupported()
      * @see #reset()
      */
     @SuppressWarnings("sync-override") // by design.
     @Override
-    public void mark(final int readlimit) {
-        inputStream.mark(readlimit);
+    public void mark(final int readLimit) {
+        inputStream.mark(readLimit);
     }
 
     /**
@@ -204,7 +214,7 @@ public int read(final byte[] buffer, final int offset, final int count) throws I
     /**
      * Resets this stream to the last marked location. This implementation resets the target stream.
      *
-     * @throws IOException if this stream is already closed, no mark has been set or the mark is no longer valid because more than {@code readlimit} bytes have
+     * @throws IOException if this stream is already closed, no mark has been set or the mark is no longer valid because more than {@code readLimit} bytes have
      *                     been read since setting the mark.
      * @see #mark(int)
      * @see #markSupported()
diff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedReader.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedReader.java
new file mode 100644
index 00000000..73f0bb84
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedReader.java
@@ -0,0 +1,115 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.commons.io.IOUtils;
+
+/**
+ * A {@link Reader} without any of the superclass' synchronization.
+ *
+ * @since 2.17.0
+ */
+public abstract class UnsynchronizedReader extends Reader {
+
+    /**
+     * The maximum skip-buffer size.
+     */
+    private static final int MAX_SKIP_BUFFER_SIZE = IOUtils.DEFAULT_BUFFER_SIZE;
+
+    /**
+     * Whether {@link #close()} completed successfully.
+     */
+    private boolean closed;
+
+    /**
+     * The skip buffer, defaults to null until allocated in {@link UnsynchronizedReader#skip(long)}.
+     */
+    private char skipBuffer[];
+
+    /**
+     * Checks if this instance is closed and throws an IOException if so.
+     *
+     * @throws IOException if this instance is closed.
+     */
+    void checkOpen() throws IOException {
+        Input.checkOpen(!isClosed());
+    }
+
+    @Override
+    public void close() throws IOException {
+        closed = true;
+    }
+
+    /**
+     * Tests whether this instance is closed; if {@link #close()} completed successfully.
+     *
+     * @return whether this instance is closed.
+     */
+    public boolean isClosed() {
+        return closed;
+    }
+
+    /**
+     * Sets whether this instance is closed.
+     *
+     * @param closed whether this instance is closed.
+     */
+    public void setClosed(final boolean closed) {
+        this.closed = closed;
+    }
+
+    /**
+     * Skips characters by reading from this instance.
+     *
+     * This method will <em>block</em> until:
+     * <ul>
+     * <li>some characters are available,</li>
+     * <li>an I/O error occurs, or</li>
+     * <li>the end of the stream is reached.</li>
+     * </ul>
+     *
+     * @param n The number of characters to skip.
+     * @return The number of characters actually skipped.
+     * @throws IllegalArgumentException If {@code n} is negative.
+     * @throws IOException              If an I/O error occurs.
+     */
+    @Override
+    public long skip(final long n) throws IOException {
+        if (n < 0L) {
+            throw new IllegalArgumentException("skip value < 0");
+        }
+        final int bufSize = (int) Math.min(n, MAX_SKIP_BUFFER_SIZE);
+        if (skipBuffer == null || skipBuffer.length < bufSize) {
+            skipBuffer = new char[bufSize];
+        }
+        long remaining = n;
+        while (remaining > 0) {
+            final int countOrEof = read(skipBuffer, 0, (int) Math.min(remaining, bufSize));
+            if (countOrEof == EOF) {
+                break;
+            }
+            remaining -= countOrEof;
+        }
+        return n - remaining;
+    }
+}
diff --git a/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java b/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java
index e5ba818d..eb753475 100644
--- a/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java
@@ -28,7 +28,7 @@
  *
  * @since 2.5
  */
-public class WindowsLineEndingInputStream  extends InputStream {
+public class WindowsLineEndingInputStream extends InputStream {
 
     private boolean atEos;
 
@@ -40,17 +40,17 @@ public class WindowsLineEndingInputStream  extends InputStream {
 
     private boolean injectSlashLf;
 
-    private final boolean lineFeedAtEndOfFile;
+    private final boolean lineFeedAtEos;
 
     /**
-     * Constructs an input stream that filters another stream
+     * Constructs an input stream that filters another stream.
      *
-     * @param in                        The input stream to wrap
-     * @param ensureLineFeedAtEndOfFile true to ensure that the file ends with CRLF
+     * @param in                        The input stream to wrap.
+     * @param lineFeedAtEos true to ensure that the stream ends with CRLF.
      */
-    public WindowsLineEndingInputStream(final InputStream in, final boolean ensureLineFeedAtEndOfFile) {
+    public WindowsLineEndingInputStream(final InputStream in, final boolean lineFeedAtEos) {
         this.in = in;
-        this.lineFeedAtEndOfFile = ensureLineFeedAtEndOfFile;
+        this.lineFeedAtEos = lineFeedAtEos;
     }
 
     /**
@@ -67,10 +67,10 @@ public void close() throws IOException {
     /**
      * Handles the end of stream condition.
      *
-     * @return The next char to output to the stream
+     * @return The next char to output to the stream.
      */
     private int handleEos() {
-        if (!lineFeedAtEndOfFile) {
+        if (!lineFeedAtEos) {
             return EOF;
         }
         if (!atSlashLf && !atSlashCr) {
@@ -89,7 +89,7 @@ private int handleEos() {
      * {@inheritDoc}
      */
     @Override
-    public synchronized void mark(final int readlimit) {
+    public synchronized void mark(final int readLimit) {
         throw UnsupportedOperationExceptions.mark();
     }
 
@@ -106,7 +106,12 @@ public int read() throws IOException {
             return LF;
         }
         final boolean prevWasSlashR = atSlashCr;
-        final int target = readWithUpdate();
+        final int target = in.read();
+        atEos = target == EOF;
+        if (!atEos) {
+            atSlashCr = target == CR;
+            atSlashLf = target == LF;
+        }
         if (atEos) {
             return handleEos();
         }
@@ -116,20 +121,4 @@ public int read() throws IOException {
         }
         return target;
     }
-
-    /**
-     * Reads the next item from the target, updating internal flags in the process
-     * @return the next int read from the target stream
-     * @throws IOException upon error
-     */
-    private int readWithUpdate() throws IOException {
-        final int target = this.in.read();
-        atEos = target == EOF;
-        if (atEos) {
-            return target;
-        }
-        atSlashCr = target == CR;
-        atSlashLf = target == LF;
-        return target;
-    }
 }
diff --git a/src/main/java/org/apache/commons/io/input/XmlStreamReader.java b/src/main/java/org/apache/commons/io/input/XmlStreamReader.java
index 290e5360..00c21a78 100644
--- a/src/main/java/org/apache/commons/io/input/XmlStreamReader.java
+++ b/src/main/java/org/apache/commons/io/input/XmlStreamReader.java
@@ -58,23 +58,25 @@
  * </p>
  * <p>
  * By default the charset encoding detection is lenient, the constructor with the lenient flag can be used for a script (following HTTP MIME and XML
- * specifications). All this is nicely explained by Mark Pilgrim in his blog, <a href="http://diveintomark.org/archives/2004/02/13/xml-media-types"> Determining
- * the character encoding of a feed</a>.
+ * specifications). All this is nicely explained by Mark Pilgrim in his blog, <a href="https://diveintomark.org/archives/2004/02/13/xml-media-types">
+ * Determining the character encoding of a feed</a>.
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <p>
- * Originally developed for <a href="http://rome.dev.java.net">ROME</a> under Apache License 2.0.
+ * Originally developed for <a href="https://rome.dev.java.net">ROME</a> under Apache License 2.0.
  * </p>
  *
+ * @see Builder
  * @see org.apache.commons.io.output.XmlStreamWriter
  * @since 2.0
  */
 public class XmlStreamReader extends Reader {
 
+    // @formatter:off
     /**
-     * Builds a new {@link XmlStreamWriter} instance.
+     * Builds a new {@link XmlStreamWriter}.
      *
      * Constructs a Reader using an InputStream and the associated content-type header. This constructor is lenient regarding the encoding detection.
      * <p>
@@ -107,11 +109,14 @@ public class XmlStreamReader extends Reader {
      * XmlStreamReader r = XmlStreamReader.builder()
      *   .setPath(path)
      *   .setCharset(StandardCharsets.UTF_8)
-     *   .get();}
+     *   .get();
+     * }
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<XmlStreamReader, Builder> {
 
         private boolean nullCharset = true;
@@ -119,19 +124,25 @@ public static class Builder extends AbstractStreamBuilder<XmlStreamReader, Build
         private String httpContentType;
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link XmlStreamWriter}.
          * <p>
-         * This builder use the aspect InputStream, OpenOption[], httpContentType, lenient, and defaultEncoding.
+         * You must set input that supports {@link #getInputStream()}, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an InputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getCharset()}</li>
+         * <li>lenient</li>
+         * <li>httpContentType</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an InputStream.
-         * @throws IOException                   thrown if there is a problem reading the stream.
-         * @throws XmlStreamReaderException      thrown if the charset encoding could not be determined according to the specification.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link InputStream}.
+         * @throws IOException                   if an I/O error occurs.
+         * @throws XmlStreamReaderException thrown if the Charset encoding could not be determined according to the specification.
          * @see #getInputStream()
          */
         @SuppressWarnings("resource")
@@ -161,7 +172,7 @@ public Builder setCharset(final String charset) {
          * Sets the HTTP content type.
          *
          * @param httpContentType the HTTP content type.
-         * @return this.
+         * @return {@code this} instance.
          */
         public Builder setHttpContentType(final String httpContentType) {
             this.httpContentType = httpContentType;
@@ -172,7 +183,7 @@ public Builder setHttpContentType(final String httpContentType) {
          * Sets the lenient toggle.
          *
          * @param lenient the lenient toggle.
-         * @return this.
+         * @return {@code this} instance.
          */
         public Builder setLenient(final boolean lenient) {
             this.lenient = lenient;
@@ -212,23 +223,29 @@ public Builder setLenient(final boolean lenient) {
     private static final Pattern CHARSET_PATTERN = Pattern.compile("charset=[\"']?([.[^; \"']]*)[\"']?");
 
     /**
-     * Pattern capturing the encoding of the "xml" processing instruction.
+     * Pattern capturing the encoding of the <a href="https://www.w3.org/TR/REC-xml/#sec-pi">{@code 'xml'} processing instruction</a>.
+     * <p>
+     * See also the <a href="https://www.w3.org/TR/2008/REC-xml-20081126/#NT-EncName">NT-EncName</a> XML specification.
+     * </p>
+     * <p>
+     * Note the documented pattern is:
+     * </p>
+     * <pre>
+     * EncName   ::=   [A-Za-z] ([A-Za-z0-9._] | '-')*
+     * </pre>
      * <p>
-     * See also the <a href="https://www.w3.org/TR/2008/REC-xml-20081126/#NT-EncName">XML specification</a>.
+     * However this does not match all the aliases that are supported by Java. For example, {@code '437'}, {@code 'ISO_8859-1:1987'} and
+     * {@code 'ebcdic-de-273+euro'}.
      * </p>
      */
     public static final Pattern ENCODING_PATTERN = Pattern.compile(
     // @formatter:off
             "^<\\?xml\\s+"
-            + "version\\s*=\\s*(?:(?:\"1\\.[0-9]+\")|(?:'1.[0-9]+'))\\s+"
+            + "(?:version\\s*=\\s*(?:(?:\"1\\.[0-9]+\")|(?:'1.[0-9]+'))\\s+)??"
             + "encoding\\s*=\\s*"
             + "((?:\"[A-Za-z0-9][A-Za-z0-9._+:-]*\")"  // double-quoted
             +  "|(?:'[A-Za-z0-9][A-Za-z0-9._+:-]*'))", // single-quoted
             Pattern.MULTILINE);
-    // N.B. the documented pattern is
-    // EncName   ::=   [A-Za-z] ([A-Za-z0-9._] | '-')*
-    // However this does not match all the aliases that are supported by Java.
-    // e.g.  '437', 'ISO_8859-1:1987' and 'ebcdic-de-273+euro'
     // @formatter:on
 
     private static final String RAW_EX_1 = "Illegal encoding, BOM [{0}] XML guess [{1}] XML prolog [{2}] encoding mismatch";
@@ -281,11 +298,7 @@ static String getContentTypeMime(final String httpContentType) {
         String mime = null;
         if (httpContentType != null) {
             final int i = httpContentType.indexOf(";");
-            if (i >= 0) {
-                mime = httpContentType.substring(0, i);
-            } else {
-                mime = httpContentType;
-            }
+            mime = i >= 0 ? httpContentType.substring(0, i) : httpContentType;
             mime = mime.trim();
         }
         return mime;
@@ -327,7 +340,7 @@ private static String getXmlProlog(final InputStream inputStream, final String g
                 inputStream.reset();
                 final BufferedReader bReader = new BufferedReader(new StringReader(xmlProlog.substring(0, firstGT + 1)));
                 final StringBuilder prolog = new StringBuilder();
-                IOConsumer.forEach(bReader.lines(), prolog::append);
+                IOConsumer.forEach(bReader.lines(), l -> prolog.append(l).append(' '));
                 final Matcher m = ENCODING_PATTERN.matcher(prolog);
                 if (m.find()) {
                     encoding = m.group(1).toUpperCase(Locale.ROOT);
@@ -376,7 +389,7 @@ static boolean isTextXml(final String mime) {
      *
      * @param file File to create a Reader from.
      * @throws NullPointerException if the input is {@code null}.
-     * @throws IOException thrown if there is a problem reading the file.
+     * @throws IOException          thrown if there is a problem reading the file.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
     @Deprecated
@@ -395,7 +408,7 @@ public XmlStreamReader(final File file) throws IOException {
      *
      * @param inputStream InputStream to create a Reader from.
      * @throws NullPointerException if the input stream is {@code null}.
-     * @throws IOException thrown if there is a problem reading the stream.
+     * @throws IOException          thrown if there is a problem reading the stream.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
     @Deprecated
@@ -429,7 +442,7 @@ public XmlStreamReader(final InputStream inputStream) throws IOException {
      *
      * @param inputStream InputStream to create a Reader from.
      * @param lenient     indicates if the charset encoding detection should be relaxed.
-     * @throws NullPointerException if the input stream is {@code null}.
+     * @throws NullPointerException     if the input stream is {@code null}.
      * @throws IOException              thrown if there is a problem reading the stream.
      * @throws XmlStreamReaderException thrown if the charset encoding could not be determined according to the specification.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
@@ -466,7 +479,7 @@ public XmlStreamReader(final InputStream inputStream, final boolean lenient) thr
      * @param inputStream     InputStream to create a Reader from.
      * @param lenient         indicates if the charset encoding detection should be relaxed.
      * @param defaultEncoding The default encoding
-     * @throws NullPointerException if the input stream is {@code null}.
+     * @throws NullPointerException     if the input stream is {@code null}.
      * @throws IOException              thrown if there is a problem reading the stream.
      * @throws XmlStreamReaderException thrown if the charset encoding could not be determined according to the specification.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
@@ -474,11 +487,11 @@ public XmlStreamReader(final InputStream inputStream, final boolean lenient) thr
     @Deprecated
     @SuppressWarnings("resource") // InputStream is managed through a InputStreamReader in this instance.
     public XmlStreamReader(final InputStream inputStream, final boolean lenient, final String defaultEncoding) throws IOException {
-        Objects.requireNonNull(inputStream, "inputStream");
         this.defaultEncoding = defaultEncoding;
-        final BOMInputStream bom = new BOMInputStream(new BufferedInputStream(inputStream, IOUtils.DEFAULT_BUFFER_SIZE), false, BOMS);
+        final BOMInputStream bom = new BOMInputStream(new BufferedInputStream(Objects.requireNonNull(inputStream, "inputStream"), IOUtils.DEFAULT_BUFFER_SIZE),
+                false, BOMS);
         final BOMInputStream pis = new BOMInputStream(bom, true, XML_GUESS_BYTES);
-        this.encoding = doRawStream(bom, pis, lenient);
+        this.encoding = processHttpStream(bom, pis, lenient);
         this.reader = new InputStreamReader(pis, encoding);
     }
 
@@ -495,7 +508,7 @@ public XmlStreamReader(final InputStream inputStream, final boolean lenient, fin
      * @param inputStream     InputStream to create the reader from.
      * @param httpContentType content-type header to use for the resolution of the charset encoding.
      * @throws NullPointerException if the input stream is {@code null}.
-     * @throws IOException thrown if there is a problem reading the file.
+     * @throws IOException          thrown if there is a problem reading the file.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
     @Deprecated
@@ -531,7 +544,7 @@ public XmlStreamReader(final InputStream inputStream, final String httpContentTy
      * @param inputStream     InputStream to create the reader from.
      * @param httpContentType content-type header to use for the resolution of the charset encoding.
      * @param lenient         indicates if the charset encoding detection should be relaxed.
-     * @throws NullPointerException if the input stream is {@code null}.
+     * @throws NullPointerException     if the input stream is {@code null}.
      * @throws IOException              thrown if there is a problem reading the file.
      * @throws XmlStreamReaderException thrown if the charset encoding could not be determined according to the specification.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
@@ -570,7 +583,7 @@ public XmlStreamReader(final InputStream inputStream, final String httpContentTy
      * @param httpContentType content-type header to use for the resolution of the charset encoding.
      * @param lenient         indicates if the charset encoding detection should be relaxed.
      * @param defaultEncoding The default encoding
-     * @throws NullPointerException if the input stream is {@code null}.
+     * @throws NullPointerException     if the input stream is {@code null}.
      * @throws IOException              thrown if there is a problem reading the file.
      * @throws XmlStreamReaderException thrown if the charset encoding could not be determined according to the specification.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
@@ -579,11 +592,11 @@ public XmlStreamReader(final InputStream inputStream, final String httpContentTy
     @SuppressWarnings("resource") // InputStream is managed through a InputStreamReader in this instance.
     public XmlStreamReader(final InputStream inputStream, final String httpContentType, final boolean lenient, final String defaultEncoding)
             throws IOException {
-        Objects.requireNonNull(inputStream, "inputStream");
         this.defaultEncoding = defaultEncoding;
-        final BOMInputStream bom = new BOMInputStream(new BufferedInputStream(inputStream, IOUtils.DEFAULT_BUFFER_SIZE), false, BOMS);
+        final BOMInputStream bom = new BOMInputStream(new BufferedInputStream(Objects.requireNonNull(inputStream, "inputStream"), IOUtils.DEFAULT_BUFFER_SIZE),
+                false, BOMS);
         final BOMInputStream pis = new BOMInputStream(bom, true, XML_GUESS_BYTES);
-        this.encoding = processHttpStream(bom, pis, httpContentType, lenient);
+        this.encoding = processHttpStream(bom, pis, lenient, httpContentType);
         this.reader = new InputStreamReader(pis, encoding);
     }
 
@@ -598,7 +611,7 @@ public XmlStreamReader(final InputStream inputStream, final String httpContentTy
      *
      * @param file File to create a Reader from.
      * @throws NullPointerException if the input is {@code null}.
-     * @throws IOException thrown if there is a problem reading the file.
+     * @throws IOException          thrown if there is a problem reading the file.
      * @since 2.11.0
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
@@ -622,7 +635,7 @@ public XmlStreamReader(final Path file) throws IOException {
      *
      * @param url URL to create a Reader from.
      * @throws NullPointerException if the input is {@code null}.
-     * @throws IOException thrown if there is a problem reading the stream of the URL.
+     * @throws IOException          thrown if there is a problem reading the stream of the URL.
      */
     public XmlStreamReader(final URL url) throws IOException {
         this(Objects.requireNonNull(url, "url").openConnection(), null);
@@ -644,7 +657,7 @@ public XmlStreamReader(final URL url) throws IOException {
      * @param urlConnection   URLConnection to create a Reader from.
      * @param defaultEncoding The default encoding
      * @throws NullPointerException if the input is {@code null}.
-     * @throws IOException thrown if there is a problem reading the stream of the URLConnection.
+     * @throws IOException          thrown if there is a problem reading the stream of the URLConnection.
      */
     public XmlStreamReader(final URLConnection urlConnection, final String defaultEncoding) throws IOException {
         Objects.requireNonNull(urlConnection, "urlConnection");
@@ -667,25 +680,25 @@ public XmlStreamReader(final URLConnection urlConnection, final String defaultEn
             .get();
         // @formatter:on
         if (urlConnection instanceof HttpURLConnection || contentType != null) {
-            this.encoding = processHttpStream(bomInput, piInput, contentType, lenient);
+            this.encoding = processHttpStream(bomInput, piInput, lenient, contentType);
         } else {
-            this.encoding = doRawStream(bomInput, piInput, lenient);
+            this.encoding = processHttpStream(bomInput, piInput, lenient);
         }
         this.reader = new InputStreamReader(piInput, encoding);
     }
 
     /**
      * Calculates the HTTP encoding.
-     *
-     * @param httpContentType The HTTP content type
      * @param bomEnc          BOM encoding
      * @param xmlGuessEnc     XML Guess encoding
      * @param xmlEnc          XML encoding
      * @param lenient         indicates if the charset encoding detection should be relaxed.
+     * @param httpContentType The HTTP content type
+     *
      * @return the HTTP encoding
      * @throws IOException thrown if there is a problem reading the stream.
      */
-    String calculateHttpEncoding(final String httpContentType, final String bomEnc, final String xmlGuessEnc, final String xmlEnc, final boolean lenient)
+    String calculateHttpEncoding(final String bomEnc, final String xmlGuessEnc, final String xmlEnc, final boolean lenient, final String httpContentType)
             throws IOException {
 
         // Lenient and has XML encoding
@@ -841,7 +854,7 @@ private String doLenientDetection(String httpContentType, XmlStreamReaderExcepti
             httpContentType = httpContentType.substring("text/html".length());
             httpContentType = "text/xml" + httpContentType;
             try {
-                return calculateHttpEncoding(httpContentType, ex.getBomEncoding(), ex.getXmlGuessEncoding(), ex.getXmlEncoding(), true);
+                return calculateHttpEncoding(ex.getBomEncoding(), ex.getXmlGuessEncoding(), ex.getXmlEncoding(), true, httpContentType);
             } catch (final XmlStreamReaderException ex2) {
                 ex = ex2;
             }
@@ -856,29 +869,6 @@ private String doLenientDetection(String httpContentType, XmlStreamReaderExcepti
         return encoding;
     }
 
-    /**
-     * Process the raw stream.
-     *
-     * @param bom     BOMInputStream to detect byte order marks
-     * @param pis     BOMInputStream to guess XML encoding
-     * @param lenient indicates if the charset encoding detection should be relaxed.
-     * @return the encoding to be used
-     * @throws IOException thrown if there is a problem reading the stream.
-     */
-    private String doRawStream(final BOMInputStream bom, final BOMInputStream pis, final boolean lenient) throws IOException {
-        final String bomEnc = bom.getBOMCharsetName();
-        final String xmlGuessEnc = pis.getBOMCharsetName();
-        final String xmlEnc = getXmlProlog(pis, xmlGuessEnc);
-        try {
-            return calculateRawEncoding(bomEnc, xmlGuessEnc, xmlEnc);
-        } catch (final XmlStreamReaderException ex) {
-            if (lenient) {
-                return doLenientDetection(null, ex);
-            }
-            throw ex;
-        }
-    }
-
     /**
      * Gets the default encoding to use if none is set in HTTP content-type, XML prolog and the rules based on content-type are not adequate.
      * <p>
@@ -900,23 +890,46 @@ public String getEncoding() {
         return encoding;
     }
 
+    /**
+     * Process the raw stream.
+     *
+     * @param bomInput     BOMInputStream to detect byte order marks
+     * @param piInput     BOMInputStream to guess XML encoding
+     * @param lenient indicates if the charset encoding detection should be relaxed.
+     * @return the encoding to be used
+     * @throws IOException thrown if there is a problem reading the stream.
+     */
+    private String processHttpStream(final BOMInputStream bomInput, final BOMInputStream piInput, final boolean lenient) throws IOException {
+        final String bomEnc = bomInput.getBOMCharsetName();
+        final String xmlGuessEnc = piInput.getBOMCharsetName();
+        final String xmlEnc = getXmlProlog(piInput, xmlGuessEnc);
+        try {
+            return calculateRawEncoding(bomEnc, xmlGuessEnc, xmlEnc);
+        } catch (final XmlStreamReaderException ex) {
+            if (lenient) {
+                return doLenientDetection(null, ex);
+            }
+            throw ex;
+        }
+    }
+
     /**
      * Processes an HTTP stream.
      *
      * @param bomInput        BOMInputStream to detect byte order marks
      * @param piInput         BOMInputStream to guess XML encoding
-     * @param httpContentType The HTTP content type
      * @param lenient         indicates if the charset encoding detection should be relaxed.
+     * @param httpContentType The HTTP content type
      * @return the encoding to be used
      * @throws IOException thrown if there is a problem reading the stream.
      */
-    private String processHttpStream(final BOMInputStream bomInput, final BOMInputStream piInput, final String httpContentType, final boolean lenient)
+    private String processHttpStream(final BOMInputStream bomInput, final BOMInputStream piInput, final boolean lenient, final String httpContentType)
             throws IOException {
         final String bomEnc = bomInput.getBOMCharsetName();
         final String xmlGuessEnc = piInput.getBOMCharsetName();
         final String xmlEnc = getXmlProlog(piInput, xmlGuessEnc);
         try {
-            return calculateHttpEncoding(httpContentType, bomEnc, xmlGuessEnc, xmlEnc, lenient);
+            return calculateHttpEncoding(bomEnc, xmlGuessEnc, xmlEnc, lenient, httpContentType);
         } catch (final XmlStreamReaderException ex) {
             if (lenient) {
                 return doLenientDetection(httpContentType, ex);
diff --git a/src/main/java/org/apache/commons/io/input/XmlStreamReaderException.java b/src/main/java/org/apache/commons/io/input/XmlStreamReaderException.java
index 1402a748..bc506509 100644
--- a/src/main/java/org/apache/commons/io/input/XmlStreamReaderException.java
+++ b/src/main/java/org/apache/commons/io/input/XmlStreamReaderException.java
@@ -20,7 +20,7 @@
 
 /**
  * The XmlStreamReaderException is thrown by the XmlStreamReader constructors if
- * the charset encoding can not be determined according to the XML 1.0
+ * the charset encoding cannot be determined according to the XML 1.0
  * specification and RFC 3023.
  * <p>
  * The exception returns the unconsumed InputStream to allow the application to
@@ -35,18 +35,33 @@ public class XmlStreamReaderException extends IOException {
 
     private static final long serialVersionUID = 1L;
 
+    /**
+     * The Byte-Order-Mark (BOM) encoding or null.
+     */
     private final String bomEncoding;
 
+    /**
+     * The guessed encoding.
+     */
     private final String xmlGuessEncoding;
 
+    /**
+     * The XML encoding.
+     */
     private final String xmlEncoding;
 
+    /**
+     * The MIME type in the content type.
+     */
     private final String contentTypeMime;
 
+    /**
+     * The encoding in the content type.
+     */
     private final String contentTypeEncoding;
 
     /**
-     * Constructs an exception instance if the charset encoding could not be
+     * Constructs an exception instance if the Charset encoding could not be
      * determined.
      * <p>
      * Instances of this exception are thrown by the XmlStreamReader.
@@ -63,7 +78,7 @@ public XmlStreamReaderException(final String msg, final String bomEnc,
     }
 
     /**
-     * Constructs an exception instance if the charset encoding could not be
+     * Constructs an exception instance if the Charset encoding could not be
      * determined.
      * <p>
      * Instances of this exception are thrown by the XmlStreamReader.
@@ -87,7 +102,7 @@ public XmlStreamReaderException(final String msg, final String ctMime, final Str
     }
 
     /**
-     * Returns the BOM encoding found in the InputStream.
+     * Gets the BOM encoding found in the InputStream.
      *
      * @return the BOM encoding, null if none.
      */
@@ -96,7 +111,7 @@ public String getBomEncoding() {
     }
 
     /**
-     * Returns the encoding in the content-type used to attempt determining the
+     * Gets the encoding in the content-type used to attempt determining the
      * encoding.
      *
      * @return the encoding in the content-type, null if there was not
@@ -108,7 +123,7 @@ public String getContentTypeEncoding() {
     }
 
     /**
-     * Returns the MIME type in the content-type used to attempt determining the
+     * Gets the MIME type in the content-type used to attempt determining the
      * encoding.
      *
      * @return the MIME type in the content-type, null if there was not
@@ -119,7 +134,7 @@ public String getContentTypeMime() {
     }
 
     /**
-     * Returns the encoding found in the XML prolog of the InputStream.
+     * Gets the encoding found in the XML prolog of the input.
      *
      * @return the encoding of the XML prolog, null if none.
      */
@@ -128,7 +143,7 @@ public String getXmlEncoding() {
     }
 
     /**
-     * Returns the encoding guess based on the first bytes of the InputStream.
+     * Gets the encoding guess based on the first bytes of the input.
      *
      * @return the encoding guess, null if it couldn't be guessed.
      */
diff --git a/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java b/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java
index 2432cd54..2d4414f4 100644
--- a/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java
@@ -18,6 +18,7 @@
 
 import static org.apache.commons.io.IOUtils.EOF;
 
+import java.io.BufferedInputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -27,7 +28,9 @@
 
 /**
  * Implements a buffered input stream, which is internally based on a {@link CircularByteBuffer}. Unlike the
- * {@link java.io.BufferedInputStream}, this one doesn't need to reallocate byte arrays internally.
+ * {@link BufferedInputStream}, this one doesn't need to reallocate byte arrays internally.
+ *
+ * @since 2.7
  */
 public class CircularBufferInputStream extends FilterInputStream {
 
diff --git a/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java b/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java
index f8e6dd3d..84cf1e03 100644
--- a/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java
+++ b/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java
@@ -26,8 +26,11 @@
  * from the buffer takes place at the same time than writing to. Such is the
  * case, for example, when using the buffer within a filtering input stream,
  * like the {@link CircularBufferInputStream}.
+ *
+ * @since 2.7
  */
 public class CircularByteBuffer {
+
     private final byte[] buffer;
     private int startOffset;
     private int endOffset;
@@ -114,7 +117,7 @@ public void clear() {
     }
 
     /**
-     * Returns the number of bytes, that are currently present in the buffer.
+     * Gets the number of bytes, that are currently present in the buffer.
      *
      * @return the number of bytes
      */
@@ -123,7 +126,7 @@ public int getCurrentNumberOfBytes() {
     }
 
     /**
-     * Returns the number of bytes, that can currently be added to the buffer.
+     * Gets the number of bytes, that can currently be added to the buffer.
      *
      * @return the number of bytes that can be added
      */
@@ -132,19 +135,19 @@ public int getSpace() {
     }
 
     /**
-     * Returns, whether the buffer is currently holding, at least, a single byte.
+     * Tests whether the buffer is currently holding at least a single byte.
      *
-     * @return true if the buffer is not empty
+     * @return true whether the buffer is currently holding at least a single byte.
      */
     public boolean hasBytes() {
         return currentNumberOfBytes > 0;
     }
 
     /**
-     * Returns, whether there is currently room for a single byte in the buffer.
+     * Tests whether there is currently room for a single byte in the buffer.
      * Same as {@link #hasSpace(int) hasSpace(1)}.
      *
-     * @return true if there is space for a byte
+     * @return true whether there is currently room for a single byte in the buffer.
      * @see #hasSpace(int)
      * @see #getSpace()
      */
@@ -153,10 +156,10 @@ public boolean hasSpace() {
     }
 
     /**
-     * Returns, whether there is currently room for the given number of bytes in the buffer.
+     * Tests whether there is currently room for the given number of bytes in the buffer.
      *
      * @param count the byte count
-     * @return true if there is space for the given number of bytes
+     * @return true whether there is currently room for the given number of bytes in the buffer.
      * @see #hasSpace()
      * @see #getSpace()
      */
diff --git a/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java b/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java
index 086ac9d2..b70b5efa 100644
--- a/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java
@@ -25,6 +25,8 @@
 /**
  * Implements a buffered input stream, which allows to peek into the buffers first bytes. This comes in handy when
  * manually implementing scanners, lexers, parsers, and the like.
+ *
+ * @since 2.7
  */
 public class PeekableInputStream extends CircularBufferInputStream {
 
diff --git a/src/main/java/org/apache/commons/io/monitor/FileAlterationMonitor.java b/src/main/java/org/apache/commons/io/monitor/FileAlterationMonitor.java
index f4c07e18..4fc26d9c 100644
--- a/src/main/java/org/apache/commons/io/monitor/FileAlterationMonitor.java
+++ b/src/main/java/org/apache/commons/io/monitor/FileAlterationMonitor.java
@@ -17,6 +17,7 @@
 package org.apache.commons.io.monitor;
 
 import java.time.Duration;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -121,7 +122,7 @@ public long getInterval() {
      * @return The set of {@link FileAlterationObserver}
      */
     public Iterable<FileAlterationObserver> getObservers() {
-        return observers;
+        return new ArrayList<>(observers);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java b/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java
index d34e825b..39386731 100644
--- a/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java
+++ b/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java
@@ -18,7 +18,9 @@
 
 import java.io.File;
 import java.io.FileFilter;
+import java.io.IOException;
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
@@ -28,33 +30,33 @@
 
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOCase;
+import org.apache.commons.io.build.AbstractOriginSupplier;
 import org.apache.commons.io.comparator.NameFileComparator;
+import org.apache.commons.io.filefilter.TrueFileFilter;
 
 /**
- * FileAlterationObserver represents the state of files below a root directory,
- * checking the file system and notifying listeners of create, change or
- * delete events.
+ * FileAlterationObserver represents the state of files below a root directory, checking the file system and notifying listeners of create, change or delete
+ * events.
  * <p>
  * To use this implementation:
+ * </p>
  * <ul>
- *   <li>Create {@link FileAlterationListener} implementation(s) that process
- *      the file/directory create, change and delete events</li>
- *   <li>Register the listener(s) with a {@link FileAlterationObserver} for
- *       the appropriate directory.</li>
- *   <li>Either register the observer(s) with a {@link FileAlterationMonitor} or
- *       run manually.</li>
+ * <li>Create {@link FileAlterationListener} implementation(s) that process the file/directory create, change and delete events</li>
+ * <li>Register the listener(s) with a {@link FileAlterationObserver} for the appropriate directory.</li>
+ * <li>Either register the observer(s) with a {@link FileAlterationMonitor} or run manually.</li>
  * </ul>
+ * <h2>Basic Usage</h2> Create a {@link FileAlterationObserver} for the directory and register the listeners:
  *
- * <h2>Basic Usage</h2>
- * Create a {@link FileAlterationObserver} for the directory and register the listeners:
  * <pre>
  *      File directory = new File(FileUtils.current(), "src");
  *      FileAlterationObserver observer = new FileAlterationObserver(directory);
  *      observer.addListener(...);
  *      observer.addListener(...);
  * </pre>
- * To manually observe a directory, initialize the observer and invoked the
- * {@link #checkAndNotify()} method as required:
+ * <p>
+ * To manually observe a directory, initialize the observer and invoked the {@link #checkAndNotify()} method as required:
+ * </p>
+ *
  * <pre>
  *      // initialize
  *      observer.init();
@@ -67,8 +69,10 @@
  *      // finished
  *      observer.finish();
  * </pre>
- * Alternatively, register the observer(s) with a {@link FileAlterationMonitor},
- * which creates a new thread, invoking the observer at the specified interval:
+ * <p>
+ * Alternatively, register the observer(s) with a {@link FileAlterationMonitor}, which creates a new thread, invoking the observer at the specified interval:
+ * </p>
+ *
  * <pre>
  *      long interval = ...
  *      FileAlterationMonitor monitor = new FileAlterationMonitor(interval);
@@ -78,20 +82,17 @@
  *      monitor.stop();
  * </pre>
  *
- * <h2>File Filters</h2>
- * This implementation can monitor portions of the file system
- * by using {@link FileFilter}s to observe only the files and/or directories
- * that are of interest. This makes it more efficient and reduces the
- * noise from <i>unwanted</i> file system events.
+ * <h2>File Filters</h2> This implementation can monitor portions of the file system by using {@link FileFilter}s to observe only the files and/or directories
+ * that are of interest. This makes it more efficient and reduces the noise from <em>unwanted</em> file system events.
  * <p>
- * <a href="https://commons.apache.org/io/">Commons IO</a> has a good range of
- * useful, ready-made
- * <a href="../filefilter/package-summary.html">File Filter</a>
+ * <a href="https://commons.apache.org/io/">Commons IO</a> has a good range of useful, ready-made <a href="../filefilter/package-summary.html">File Filter</a>
  * implementations for this purpose.
+ * </p>
  * <p>
- * For example, to only observe 1) visible directories and 2) files with a ".java" suffix
- * in a root directory called "src" you could set up a {@link FileAlterationObserver} in the following
- * way:
+ * For example, to only observe 1) visible directories and 2) files with a ".java" suffix in a root directory called "src" you could set up a
+ * {@link FileAlterationObserver} in the following way:
+ * </p>
+ *
  * <pre>
  *      // Create a FileFilter
  *      IOFileFilter directories = FileFilterUtils.and(
@@ -109,12 +110,11 @@
  * </pre>
  *
  * <h2>FileEntry</h2>
- * {@link FileEntry} represents the state of a file or directory, capturing
- * {@link File} attributes at a point in time. Custom implementations of
- * {@link FileEntry} can be used to capture additional properties that the
- * basic implementation does not support. The {@link FileEntry#refresh(File)}
- * method is used to determine if a file or directory has changed since the last
- * check and stores the current state of the {@link File}'s properties.
+ * <p>
+ * {@link FileEntry} represents the state of a file or directory, capturing {@link File} attributes at a point in time. Custom implementations of
+ * {@link FileEntry} can be used to capture additional properties that the basic implementation does not support. The {@link FileEntry#refresh(File)} method is
+ * used to determine if a file or directory has changed since the last check and stores the current state of the {@link File}'s properties.
+ * </p>
  * <h2>Deprecating Serialization</h2>
  * <p>
  * <em>Serialization is deprecated and will be removed in 3.0.</em>
@@ -122,22 +122,118 @@
  *
  * @see FileAlterationListener
  * @see FileAlterationMonitor
- *
  * @since 2.0
  */
 public class FileAlterationObserver implements Serializable {
 
+    /**
+     * Builds instances of {@link FileAlterationObserver}.
+     *
+     * @since 2.18.0
+     */
+    public static final class Builder extends AbstractOriginSupplier<FileAlterationObserver, Builder> {
+
+        private FileEntry rootEntry;
+        private FileFilter fileFilter;
+        private IOCase ioCase;
+
+        private Builder() {
+            // empty
+        }
+
+        /**
+         * Gets a new {@link FileAlterationObserver} instance.
+         */
+        @Override
+        public FileAlterationObserver get() throws IOException {
+            return new FileAlterationObserver(rootEntry != null ? rootEntry : new FileEntry(checkOrigin().getFile()), fileFilter, toComparator(ioCase));
+        }
+
+        /**
+         * Sets the file filter or null if none.
+         *
+         * @param fileFilter file filter or null if none.
+         * @return This instance.
+         */
+        public Builder setFileFilter(final FileFilter fileFilter) {
+            this.fileFilter = fileFilter;
+            return asThis();
+        }
+
+        /**
+         * Sets what case sensitivity to use comparing file names, null means system sensitive.
+         *
+         * @param ioCase what case sensitivity to use comparing file names, null means system sensitive.
+         * @return This instance.
+         */
+        public Builder setIOCase(final IOCase ioCase) {
+            this.ioCase = ioCase;
+            return asThis();
+        }
+
+        /**
+         * Sets the root directory to observe.
+         *
+         * @param rootEntry the root directory to observe.
+         * @return This instance.
+         */
+        public Builder setRootEntry(final FileEntry rootEntry) {
+            this.rootEntry = rootEntry;
+            return asThis();
+        }
+
+    }
+
     private static final long serialVersionUID = 1185122225658782848L;
-    private final List<FileAlterationListener> listeners = new CopyOnWriteArrayList<>();
+
+    /**
+     * Creates a new builder.
+     *
+     * @return a new builder.
+     * @since 2.18.0
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    private static Comparator<File> toComparator(final IOCase ioCase) {
+        switch (IOCase.value(ioCase, IOCase.SYSTEM)) {
+        case SYSTEM:
+            return NameFileComparator.NAME_SYSTEM_COMPARATOR;
+        case INSENSITIVE:
+            return NameFileComparator.NAME_INSENSITIVE_COMPARATOR;
+        default:
+            return NameFileComparator.NAME_COMPARATOR;
+        }
+    }
+
+    /**
+     * List of listeners.
+     */
+    private transient final List<FileAlterationListener> listeners = new CopyOnWriteArrayList<>();
+
+    /**
+     * The root directory to observe.
+     */
     private final FileEntry rootEntry;
-    private final FileFilter fileFilter;
+
+    /**
+     * The file filter or null if none.
+     */
+    private transient final FileFilter fileFilter;
+
+    /**
+     * Compares file names.
+     */
     private final Comparator<File> comparator;
 
     /**
      * Constructs an observer for the specified directory.
      *
-     * @param directory the directory to observe
+     * @param directory the directory to observe.
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public FileAlterationObserver(final File directory) {
         this(directory, null);
     }
@@ -145,21 +241,24 @@ public FileAlterationObserver(final File directory) {
     /**
      * Constructs an observer for the specified directory and file filter.
      *
-     * @param directory the directory to observe
-     * @param fileFilter The file filter or null if none
+     * @param directory  The directory to observe.
+     * @param fileFilter The file filter or null if none.
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public FileAlterationObserver(final File directory, final FileFilter fileFilter) {
         this(directory, fileFilter, null);
     }
 
     /**
-     * Constructs an observer for the specified directory, file filter and
-     * file comparator.
+     * Constructs an observer for the specified directory, file filter and file comparator.
      *
-     * @param directory the directory to observe
-     * @param fileFilter The file filter or null if none
-     * @param ioCase  what case sensitivity to use comparing file names, null means system sensitive
+     * @param directory  The directory to observe.
+     * @param fileFilter The file filter or null if none.
+     * @param ioCase     What case sensitivity to use comparing file names, null means system sensitive.
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public FileAlterationObserver(final File directory, final FileFilter fileFilter, final IOCase ioCase) {
         this(new FileEntry(directory), fileFilter, ioCase);
     }
@@ -167,32 +266,36 @@ public FileAlterationObserver(final File directory, final FileFilter fileFilter,
     /**
      * Constructs an observer for the specified directory, file filter and file comparator.
      *
-     * @param rootEntry the root directory to observe
-     * @param fileFilter The file filter or null if none
-     * @param ioCase what case sensitivity to use comparing file names, null means system sensitive
+     * @param rootEntry  The root directory to observe.
+     * @param fileFilter The file filter or null if none.
+     * @param comparator How to compare files.
      */
-    protected FileAlterationObserver(final FileEntry rootEntry, final FileFilter fileFilter, final IOCase ioCase) {
+    private FileAlterationObserver(final FileEntry rootEntry, final FileFilter fileFilter, final Comparator<File> comparator) {
         Objects.requireNonNull(rootEntry, "rootEntry");
         Objects.requireNonNull(rootEntry.getFile(), "rootEntry.getFile()");
         this.rootEntry = rootEntry;
-        this.fileFilter = fileFilter;
-        switch (IOCase.value(ioCase, IOCase.SYSTEM)) {
-        case SYSTEM:
-            this.comparator = NameFileComparator.NAME_SYSTEM_COMPARATOR;
-            break;
-        case INSENSITIVE:
-            this.comparator = NameFileComparator.NAME_INSENSITIVE_COMPARATOR;
-            break;
-        default:
-            this.comparator = NameFileComparator.NAME_COMPARATOR;
-        }
+        this.fileFilter = fileFilter != null ? fileFilter : TrueFileFilter.INSTANCE;
+        this.comparator = Objects.requireNonNull(comparator, "comparator");
+    }
+
+    /**
+     * Constructs an observer for the specified directory, file filter and file comparator.
+     *
+     * @param rootEntry  The root directory to observe.
+     * @param fileFilter The file filter or null if none.
+     * @param ioCase     What case sensitivity to use comparing file names, null means system sensitive.
+     */
+    protected FileAlterationObserver(final FileEntry rootEntry, final FileFilter fileFilter, final IOCase ioCase) {
+        this(rootEntry, fileFilter, toComparator(ioCase));
     }
 
     /**
      * Constructs an observer for the specified directory.
      *
-     * @param directoryName the name of the directory to observe
+     * @param directoryName the name of the directory to observe.
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public FileAlterationObserver(final String directoryName) {
         this(new File(directoryName));
     }
@@ -200,9 +303,11 @@ public FileAlterationObserver(final String directoryName) {
     /**
      * Constructs an observer for the specified directory and file filter.
      *
-     * @param directoryName the name of the directory to observe
-     * @param fileFilter The file filter or null if none
+     * @param directoryName the name of the directory to observe.
+     * @param fileFilter    The file filter or null if none.
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public FileAlterationObserver(final String directoryName, final FileFilter fileFilter) {
         this(new File(directoryName), fileFilter);
     }
@@ -210,10 +315,12 @@ public FileAlterationObserver(final String directoryName, final FileFilter fileF
     /**
      * Constructs an observer for the specified directory, file filter and file comparator.
      *
-     * @param directoryName the name of the directory to observe
-     * @param fileFilter The file filter or null if none
-     * @param ioCase what case sensitivity to use comparing file names, null means system sensitive
+     * @param directoryName the name of the directory to observe.
+     * @param fileFilter    The file filter or null if none.
+     * @param ioCase        what case sensitivity to use comparing file names, null means system sensitive.
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public FileAlterationObserver(final String directoryName, final FileFilter fileFilter, final IOCase ioCase) {
         this(new File(directoryName), fileFilter, ioCase);
     }
@@ -221,7 +328,7 @@ public FileAlterationObserver(final String directoryName, final FileFilter fileF
     /**
      * Adds a file system listener.
      *
-     * @param listener The file system listener
+     * @param listener The file system listener.
      */
     public void addListener(final FileAlterationListener listener) {
         if (listener != null) {
@@ -229,6 +336,39 @@ public void addListener(final FileAlterationListener listener) {
         }
     }
 
+    /**
+     * Compares two file lists for files which have been created, modified or deleted.
+     *
+     * @param parentEntry     The parent entry.
+     * @param previousEntries The original list of file entries.
+     * @param currentEntries  The current list of files entries.
+     */
+    private void checkAndFire(final FileEntry parentEntry, final FileEntry[] previousEntries, final File[] currentEntries) {
+        int c = 0;
+        final FileEntry[] actualEntries = currentEntries.length > 0 ? new FileEntry[currentEntries.length] : FileEntry.EMPTY_FILE_ENTRY_ARRAY;
+        for (final FileEntry previousEntry : previousEntries) {
+            while (c < currentEntries.length && comparator.compare(previousEntry.getFile(), currentEntries[c]) > 0) {
+                actualEntries[c] = createFileEntry(parentEntry, currentEntries[c]);
+                fireOnCreate(actualEntries[c]);
+                c++;
+            }
+            if (c < currentEntries.length && comparator.compare(previousEntry.getFile(), currentEntries[c]) == 0) {
+                fireOnChange(previousEntry, currentEntries[c]);
+                checkAndFire(previousEntry, previousEntry.getChildren(), listFiles(currentEntries[c]));
+                actualEntries[c] = previousEntry;
+                c++;
+            } else {
+                checkAndFire(previousEntry, previousEntry.getChildren(), FileUtils.EMPTY_FILE_ARRAY);
+                fireOnDelete(previousEntry);
+            }
+        }
+        for (; c < currentEntries.length; c++) {
+            actualEntries[c] = createFileEntry(parentEntry, currentEntries[c]);
+            fireOnCreate(actualEntries[c]);
+        }
+        parentEntry.setChildren(actualEntries);
+    }
+
     /**
      * Checks whether the file and its children have been created, modified or deleted.
      */
@@ -240,9 +380,9 @@ public void checkAndNotify() {
         // fire directory/file events
         final File rootFile = rootEntry.getFile();
         if (rootFile.exists()) {
-            checkAndNotify(rootEntry, rootEntry.getChildren(), listFiles(rootFile));
+            checkAndFire(rootEntry, rootEntry.getChildren(), listFiles(rootFile));
         } else if (rootEntry.isExists()) {
-            checkAndNotify(rootEntry, rootEntry.getChildren(), FileUtils.EMPTY_FILE_ARRAY);
+            checkAndFire(rootEntry, rootEntry.getChildren(), FileUtils.EMPTY_FILE_ARRAY);
         }
         // Else: Didn't exist and still doesn't
 
@@ -250,69 +390,54 @@ public void checkAndNotify() {
         listeners.forEach(listener -> listener.onStop(this));
     }
 
-    /**
-     * Compares two file lists for files which have been created, modified or deleted.
-     *
-     * @param parent The parent entry
-     * @param previous The original list of files
-     * @param files  The current list of files
-     */
-    private void checkAndNotify(final FileEntry parent, final FileEntry[] previous, final File[] files) {
-        int c = 0;
-        final FileEntry[] current = files.length > 0 ? new FileEntry[files.length] : FileEntry.EMPTY_FILE_ENTRY_ARRAY;
-        for (final FileEntry entry : previous) {
-            while (c < files.length && comparator.compare(entry.getFile(), files[c]) > 0) {
-                current[c] = createFileEntry(parent, files[c]);
-                doCreate(current[c]);
-                c++;
-            }
-            if (c < files.length && comparator.compare(entry.getFile(), files[c]) == 0) {
-                doMatch(entry, files[c]);
-                checkAndNotify(entry, entry.getChildren(), listFiles(files[c]));
-                current[c] = entry;
-                c++;
-            } else {
-                checkAndNotify(entry, entry.getChildren(), FileUtils.EMPTY_FILE_ARRAY);
-                doDelete(entry);
-            }
-        }
-        for (; c < files.length; c++) {
-            current[c] = createFileEntry(parent, files[c]);
-            doCreate(current[c]);
-        }
-        parent.setChildren(current);
-    }
-
     /**
      * Creates a new file entry for the specified file.
      *
-     * @param parent The parent file entry
-     * @param file The file to create an entry for
-     * @return A new file entry
+     * @param parent The parent file entry.
+     * @param file   The file to wrap.
+     * @return A new file entry.
      */
     private FileEntry createFileEntry(final FileEntry parent, final File file) {
         final FileEntry entry = parent.newChildInstance(file);
         entry.refresh(file);
-        entry.setChildren(doListFiles(file, entry));
+        entry.setChildren(listFileEntries(file, entry));
         return entry;
     }
 
     /**
      * Final processing.
      *
-     * @throws Exception if an error occurs
+     * @throws Exception if an error occurs.
      */
     @SuppressWarnings("unused") // Possibly thrown from subclasses.
     public void destroy() throws Exception {
         // noop
     }
 
+    /**
+     * Fires directory/file change events to the registered listeners.
+     *
+     * @param entry The previous file system entry.
+     * @param file  The current file.
+     */
+    private void fireOnChange(final FileEntry entry, final File file) {
+        if (entry.refresh(file)) {
+            listeners.forEach(listener -> {
+                if (entry.isDirectory()) {
+                    listener.onDirectoryChange(file);
+                } else {
+                    listener.onFileChange(file);
+                }
+            });
+        }
+    }
+
     /**
      * Fires directory/file created events to the registered listeners.
      *
-     * @param entry The file entry
+     * @param entry The file entry.
      */
-    private void doCreate(final FileEntry entry) {
+    private void fireOnCreate(final FileEntry entry) {
         listeners.forEach(listener -> {
             if (entry.isDirectory()) {
                 listener.onDirectoryCreate(entry.getFile());
@@ -320,15 +445,15 @@ private void doCreate(final FileEntry entry) {
                 listener.onFileCreate(entry.getFile());
             }
         });
-        Stream.of(entry.getChildren()).forEach(this::doCreate);
+        Stream.of(entry.getChildren()).forEach(this::fireOnCreate);
     }
 
     /**
      * Fires directory/file delete events to the registered listeners.
      *
-     * @param entry The file entry
+     * @param entry The file entry.
      */
-    private void doDelete(final FileEntry entry) {
+    private void fireOnDelete(final FileEntry entry) {
         listeners.forEach(listener -> {
             if (entry.isDirectory()) {
                 listener.onDirectoryDelete(entry.getFile());
@@ -338,41 +463,14 @@ private void doDelete(final FileEntry entry) {
         });
     }
 
-    /**
-     * Lists the files
-     * @param file The file to list files for
-     * @param entry the parent entry
-     * @return The child files
-     */
-    private FileEntry[] doListFiles(final File file, final FileEntry entry) {
-        final File[] files = listFiles(file);
-        final FileEntry[] children = files.length > 0 ? new FileEntry[files.length] : FileEntry.EMPTY_FILE_ENTRY_ARRAY;
-        Arrays.setAll(children, i -> createFileEntry(entry, files[i]));
-        return children;
-    }
-
-    /**
-     * Fires directory/file change events to the registered listeners.
-     *
-     * @param entry The previous file system entry
-     * @param file The current file
-     */
-    private void doMatch(final FileEntry entry, final File file) {
-        if (entry.refresh(file)) {
-            listeners.forEach(listener -> {
-                if (entry.isDirectory()) {
-                    listener.onDirectoryChange(file);
-                } else {
-                    listener.onFileChange(file);
-                }
-            });
-        }
+    Comparator<File> getComparator() {
+        return comparator;
     }
 
     /**
      * Returns the directory being observed.
      *
-     * @return the directory being observed
+     * @return the directory being observed.
      */
     public File getDirectory() {
         return rootEntry.getFile();
@@ -381,7 +479,7 @@ public File getDirectory() {
     /**
      * Returns the fileFilter.
      *
-     * @return the fileFilter
+     * @return the fileFilter.
      * @since 2.1
      */
     public FileFilter getFileFilter() {
@@ -394,45 +492,45 @@ public FileFilter getFileFilter() {
      * @return The file system listeners
      */
     public Iterable<FileAlterationListener> getListeners() {
-        return listeners;
+        return new ArrayList<>(listeners);
     }
 
     /**
      * Initializes the observer.
      *
-     * @throws Exception if an error occurs
+     * @throws Exception if an error occurs.
      */
     @SuppressWarnings("unused") // Possibly thrown from subclasses.
     public void initialize() throws Exception {
         rootEntry.refresh(rootEntry.getFile());
-        rootEntry.setChildren(doListFiles(rootEntry.getFile(), rootEntry));
+        rootEntry.setChildren(listFileEntries(rootEntry.getFile(), rootEntry));
     }
 
     /**
-     * Lists the contents of a directory
+     * Lists the file entries in {@code file}.
      *
-     * @param file The file to list the contents of
-     * @return the directory contents or a zero length array if
-     * the empty or the file is not a directory
+     * @param file  The directory to list.
+     * @param entry the parent entry.
+     * @return The child file entries.
      */
-    private File[] listFiles(final File file) {
-        File[] children = null;
-        if (file.isDirectory()) {
-            children = fileFilter == null ? file.listFiles() : file.listFiles(fileFilter);
-        }
-        if (children == null) {
-            children = FileUtils.EMPTY_FILE_ARRAY;
-        }
-        if (comparator != null && children.length > 1) {
-            Arrays.sort(children, comparator);
-        }
-        return children;
+    private FileEntry[] listFileEntries(final File file, final FileEntry entry) {
+        return Stream.of(listFiles(file)).map(f -> createFileEntry(entry, f)).toArray(FileEntry[]::new);
+    }
+
+    /**
+     * Lists the contents of a directory.
+     *
+     * @param directory The directory to list.
+     * @return the directory contents or a zero length array if the empty or the file is not a directory
+     */
+    private File[] listFiles(final File directory) {
+        return directory.isDirectory() ? sort(directory.listFiles(fileFilter)) : FileUtils.EMPTY_FILE_ARRAY;
     }
 
     /**
      * Removes a file system listener.
      *
-     * @param listener The file system listener
+     * @param listener The file system listener.
      */
     public void removeListener(final FileAlterationListener listener) {
         if (listener != null) {
@@ -440,10 +538,20 @@ public void removeListener(final FileAlterationListener listener) {
         }
     }
 
+    private File[] sort(final File[] files) {
+        if (files == null) {
+            return FileUtils.EMPTY_FILE_ARRAY;
+        }
+        if (files.length > 1) {
+            Arrays.sort(files, comparator);
+        }
+        return files;
+    }
+
     /**
      * Returns a String representation of this observer.
      *
-     * @return a String representation of this observer
+     * @return a String representation of this observer.
      */
     @Override
     public String toString() {
@@ -452,10 +560,8 @@ public String toString() {
         builder.append("[file='");
         builder.append(getDirectory().getPath());
         builder.append('\'');
-        if (fileFilter != null) {
-            builder.append(", ");
-            builder.append(fileFilter.toString());
-        }
+        builder.append(", ");
+        builder.append(fileFilter.toString());
         builder.append(", listeners=");
         builder.append(listeners.size());
         builder.append("]");
diff --git a/src/main/java/org/apache/commons/io/monitor/FileEntry.java b/src/main/java/org/apache/commons/io/monitor/FileEntry.java
index 837f2df5..2630cfae 100644
--- a/src/main/java/org/apache/commons/io/monitor/FileEntry.java
+++ b/src/main/java/org/apache/commons/io/monitor/FileEntry.java
@@ -57,13 +57,28 @@ public class FileEntry implements Serializable {
 
     static final FileEntry[] EMPTY_FILE_ENTRY_ARRAY = {};
 
+    /** The parent. */
     private final FileEntry parent;
+
+    /** My children. */
     private FileEntry[] children;
+
+    /** Monitored file. */
     private final File file;
+
+    /** Monitored file name. */
     private String name;
+
+    /** Whether the file exists. */
     private boolean exists;
+
+    /** Whether the file is a directory or not. */
     private boolean directory;
+
+    /** The file's last modified timestamp. */
     private SerializableFileTime lastModified = SerializableFileTime.EPOCH;
+
+    /** The file's length. */
     private long length;
 
     /**
@@ -78,8 +93,8 @@ public FileEntry(final File file) {
     /**
      * Constructs a new monitor for a specified {@link File}.
      *
-     * @param parent The parent
-     * @param file The file being monitored
+     * @param parent The parent.
+     * @param file The file being monitored.
      */
     public FileEntry(final FileEntry parent, final File file) {
         this.file = Objects.requireNonNull(file, "file");
diff --git a/src/main/java/org/apache/commons/io/monitor/SerializableFileTime.java b/src/main/java/org/apache/commons/io/monitor/SerializableFileTime.java
index 9fa58170..3dace793 100644
--- a/src/main/java/org/apache/commons/io/monitor/SerializableFileTime.java
+++ b/src/main/java/org/apache/commons/io/monitor/SerializableFileTime.java
@@ -35,7 +35,7 @@
  * <em>Serialization is deprecated and will be removed in 3.0.</em>
  * </p>
  */
-class SerializableFileTime implements Serializable {
+final class SerializableFileTime implements Serializable {
 
     static final SerializableFileTime EPOCH = new SerializableFileTime(FileTimes.EPOCH);
 
@@ -68,8 +68,15 @@ public int hashCode() {
         return fileTime.hashCode();
     }
 
-    private void readObject(final ObjectInputStream ois) throws ClassNotFoundException, IOException {
-        this.fileTime = FileTime.from((Instant) ois.readObject());
+    /**
+     * Deserializes an instance from an ObjectInputStream.
+     *
+     * @param in The source ObjectInputStream.
+     * @throws IOException            Any of the usual Input/Output related exceptions.
+     * @throws ClassNotFoundException A class of a serialized object cannot be found.
+     */
+    private void readObject(final ObjectInputStream in) throws ClassNotFoundException, IOException {
+        this.fileTime = FileTime.from((Instant) in.readObject());
     }
 
     long to(final TimeUnit unit) {
diff --git a/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java b/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java
index 6e47aa39..236116e4 100644
--- a/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java
@@ -143,12 +143,16 @@ protected void needNewBuffer(final int newCount) {
     }
 
     /**
-     * @see java.io.ByteArrayOutputStream#reset()
+     * See {@link ByteArrayOutputStream#reset()}.
+     *
+     * @see ByteArrayOutputStream#reset()
      */
     public abstract void reset();
 
     /**
-     * @see java.io.ByteArrayOutputStream#reset()
+     * Implements a default reset behavior.
+     *
+     * @see ByteArrayOutputStream#reset()
      */
     protected void resetImpl() {
         count = 0;
@@ -259,7 +263,7 @@ protected <T extends InputStream> InputStream toInputStream(final InputStreamCon
      * using the platform default charset.
      * @return the contents of the byte array as a String
      * @see java.io.ByteArrayOutputStream#toString()
-     * @deprecated 2.5 use {@link #toString(String)} instead
+     * @deprecated Use {@link #toString(String)} instead
      */
     @Override
     @Deprecated
diff --git a/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java b/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java
index 17886b53..40489a95 100644
--- a/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java
@@ -18,13 +18,14 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
+import java.io.Writer;
 
 /**
  * OutputStream implementation that writes the data to an {@link Appendable}
  * Object.
  * <p>
- * For example, can be used with any {@link java.io.Writer} or a {@link java.lang.StringBuilder}
- * or {@link java.lang.StringBuffer}.
+ * For example, can be used with any {@link Writer} or a {@link StringBuilder}
+ * or {@link StringBuffer}.
  * </p>
  *
  * @since 2.5
@@ -46,7 +47,7 @@ public AppendableOutputStream(final T appendable) {
     }
 
     /**
-     * Return the target appendable.
+     * Gets the target appendable.
      *
      * @return the target appendable
      */
@@ -62,7 +63,7 @@ public T getAppendable() {
      */
     @Override
     public void write(final int b) throws IOException {
-        appendable.append((char)b);
+        appendable.append((char) b);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/output/AppendableWriter.java b/src/main/java/org/apache/commons/io/output/AppendableWriter.java
index 8e234e64..e887adf6 100644
--- a/src/main/java/org/apache/commons/io/output/AppendableWriter.java
+++ b/src/main/java/org/apache/commons/io/output/AppendableWriter.java
@@ -24,8 +24,8 @@
  * Writer implementation that writes the data to an {@link Appendable}
  * Object.
  * <p>
- * For example, can be used with a {@link java.lang.StringBuilder}
- * or {@link java.lang.StringBuffer}.
+ * For example, can be used with a {@link StringBuilder}
+ * or {@link StringBuffer}.
  * </p>
  *
  * @since 2.7
@@ -108,7 +108,7 @@ public void flush() throws IOException {
     }
 
     /**
-     * Return the target appendable.
+     * Gets the target appendable.
      *
      * @return the target appendable
      */
@@ -126,7 +126,7 @@ public T getAppendable() {
      */
     @Override
     public void write(final char[] cbuf, final int off, final int len) throws IOException {
-        Objects.requireNonNull(cbuf, "Character array is missing");
+        Objects.requireNonNull(cbuf, "cbuf");
         if (len < 0 || off + len > cbuf.length) {
             throw new IndexOutOfBoundsException("Array Size=" + cbuf.length +
                     ", offset=" + off + ", length=" + len);
@@ -144,7 +144,7 @@ public void write(final char[] cbuf, final int off, final int len) throws IOExce
      */
     @Override
     public void write(final int c) throws IOException {
-        appendable.append((char)c);
+        appendable.append((char) c);
     }
 
     /**
@@ -158,7 +158,7 @@ public void write(final int c) throws IOException {
     @Override
     public void write(final String str, final int off, final int len) throws IOException {
         // appendable.append will add "null" for a null String; add an explicit null check
-        Objects.requireNonNull(str, "String is missing");
+        Objects.requireNonNull(str, "str");
         appendable.append(str, off, off + len);
     }
 
diff --git a/src/main/java/org/apache/commons/io/output/BrokenOutputStream.java b/src/main/java/org/apache/commons/io/output/BrokenOutputStream.java
index 4accc56d..5b1dad04 100644
--- a/src/main/java/org/apache/commons/io/output/BrokenOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/BrokenOutputStream.java
@@ -20,12 +20,12 @@
 import java.io.OutputStream;
 import java.util.function.Supplier;
 
+import org.apache.commons.io.function.Erase;
+
 /**
- * Broken output stream. This stream always throws an {@link IOException} from
- * all {@link OutputStream} methods.
+ * Always throws an exception from all {@link OutputStream} methods where {@link IOException} is declared.
  * <p>
- * This class is mostly useful for testing error handling in code that uses an
- * output stream.
+ * This class is mostly useful for testing error handling.
  * </p>
  *
  * @since 2.0
@@ -33,16 +33,16 @@
 public class BrokenOutputStream extends OutputStream {
 
     /**
-     * A singleton instance.
+     * The singleton instance using a default IOException.
      *
      * @since 2.12.0
      */
     public static final BrokenOutputStream INSTANCE = new BrokenOutputStream();
 
     /**
-     * A supplier for the exception that is thrown by all methods of this class.
+     * Supplies the exception that is thrown by all methods of this class.
      */
-    private final Supplier<IOException> exceptionSupplier;
+    private final Supplier<Throwable> exceptionSupplier;
 
     /**
      * Constructs a new stream that always throws an {@link IOException}.
@@ -55,50 +55,71 @@ public BrokenOutputStream() {
      * Constructs a new stream that always throws the given exception.
      *
      * @param exception the exception to be thrown.
+     * @deprecated Use {@link #BrokenOutputStream(Throwable)}.
      */
+    @Deprecated
     public BrokenOutputStream(final IOException exception) {
         this(() -> exception);
     }
 
     /**
-     * Constructs a new stream that always throws an {@link IOException}.
+     * Constructs a new stream that always throws the supplied exception.
      *
-     * @param exceptionSupplier a supplier for the exception to be thrown.
+     * @param exceptionSupplier a supplier for the IOException or RuntimeException to be thrown.
      * @since 2.12.0
      */
-    public BrokenOutputStream(final Supplier<IOException> exceptionSupplier) {
+    public BrokenOutputStream(final Supplier<Throwable> exceptionSupplier) {
         this.exceptionSupplier = exceptionSupplier;
     }
 
+    /**
+     * Constructs a new stream that always throws the given exception.
+     *
+     * @param exception the exception to be thrown.
+     * @since 2.16.0
+     */
+    public BrokenOutputStream(final Throwable exception) {
+        this(() -> exception);
+    }
+
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void close() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void flush() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
+    }
+
+    /**
+     * Throws the configured exception from its supplier.
+     *
+     * @return Throws the configured exception from its supplier.
+     */
+    private RuntimeException rethrow() {
+        return Erase.rethrow(exceptionSupplier.get());
     }
 
     /**
      * Throws the configured exception.
      *
-     * @param b ignored
-     * @throws IOException always thrown
+     * @param b ignored.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void write(final int b) throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/output/BrokenWriter.java b/src/main/java/org/apache/commons/io/output/BrokenWriter.java
index c56d9a31..800d669e 100644
--- a/src/main/java/org/apache/commons/io/output/BrokenWriter.java
+++ b/src/main/java/org/apache/commons/io/output/BrokenWriter.java
@@ -20,10 +20,12 @@
 import java.io.Writer;
 import java.util.function.Supplier;
 
+import org.apache.commons.io.function.Erase;
+
 /**
- * Always throws an {@link IOException} from all {@link Writer} methods.
+ * Always throws an exception from all {@link Writer} methods where {@link IOException} is declared.
  * <p>
- * This class is mostly useful for testing error handling in code that uses a writer.
+ * This class is mostly useful for testing error handling.
  * </p>
  *
  * @since 2.0
@@ -31,16 +33,16 @@
 public class BrokenWriter extends Writer {
 
     /**
-     * The singleton instance.
+     * The singleton instance using a default IOException.
      *
      * @since 2.12.0
      */
     public static final BrokenWriter INSTANCE = new BrokenWriter();
 
     /**
-     * A supplier for the exception that is thrown by all methods of this class.
+     * Supplies the exception that is thrown by all methods of this class.
      */
-    private final Supplier<IOException> exceptionSupplier;
+    private final Supplier<Throwable> exceptionSupplier;
 
     /**
      * Constructs a new writer that always throws an {@link IOException}.
@@ -53,52 +55,73 @@ public BrokenWriter() {
      * Constructs a new writer that always throws the given exception.
      *
      * @param exception the exception to be thrown.
+     * @deprecated Use {@link #BrokenWriter(Throwable)}.
      */
+    @Deprecated
     public BrokenWriter(final IOException exception) {
         this(() -> exception);
     }
 
     /**
-     * Constructs a new writer that always throws an {@link IOException}.
+     * Constructs a new writer that always throws the supplied exception.
      *
-     * @param exceptionSupplier a supplier for the exception to be thrown.
+     * @param exceptionSupplier a supplier for the IOException or RuntimeException to be thrown.
      * @since 2.12.0
      */
-    public BrokenWriter(final Supplier<IOException> exceptionSupplier) {
+    public BrokenWriter(final Supplier<Throwable> exceptionSupplier) {
         this.exceptionSupplier = exceptionSupplier;
     }
 
+    /**
+     * Constructs a new writer that always throws the given exception.
+     *
+     * @param exception the exception to be thrown.
+     * @since 2.16.0
+     */
+    public BrokenWriter(final Throwable exception) {
+        this(() -> exception);
+    }
+
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void close() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
     /**
      * Throws the configured exception.
      *
-     * @throws IOException always thrown
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void flush() throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
+    }
+
+    /**
+     * Throws the configured exception from its supplier.
+     *
+     * @return Throws the configured exception from its supplier.
+     */
+    private RuntimeException rethrow() {
+        return Erase.rethrow(exceptionSupplier.get());
     }
 
     /**
      * Throws the configured exception.
      *
-     * @param cbuf ignored
-     * @param off ignored
-     * @param len ignored
-     * @throws IOException always thrown
+     * @param cbuf ignored.
+     * @param off  ignored.
+     * @param len  ignored.
+     * @throws IOException always throws the exception configured in a constructor.
      */
     @Override
     public void write(final char[] cbuf, final int off, final int len) throws IOException {
-        throw exceptionSupplier.get();
+        throw rethrow();
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java b/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java
index b8e2abe2..43de7922 100644
--- a/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java
@@ -26,18 +26,22 @@
 /**
  * OutputStream which breaks larger output blocks into chunks. Native code may need to copy the input array; if the write buffer is very large this can cause
  * OOME.
+ * <p>
+ * To build an instance, see {@link Builder}
+ * </p>
  *
+ * @see Builder
  * @since 2.5
  */
 public class ChunkedOutputStream extends FilterOutputStream {
 
     // @formatter:off
     /**
-     * Builds a new {@link UnsynchronizedByteArrayOutputStream} instance.
+     * Builds a new {@link UnsynchronizedByteArrayOutputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
-     *
      * <pre>{@code
      * UnsynchronizedByteArrayOutputStream s = UnsynchronizedByteArrayOutputStream.builder()
      *   .setBufferSize(8192)
@@ -47,7 +51,6 @@ public class ChunkedOutputStream extends FilterOutputStream {
      * <p>
      * Using NIO Path:
      * </p>
-     *
      * <pre>{@code
      * UnsynchronizedByteArrayOutputStream s = UnsynchronizedByteArrayOutputStream.builder()
      *   .setBufferSize(8192)
@@ -55,21 +58,28 @@ public class ChunkedOutputStream extends FilterOutputStream {
      * }
      * </pre>
      *
+     * @see #get()
      * @since 2.13.0
      */
     // @formatter:on
     public static class Builder extends AbstractStreamBuilder<ChunkedOutputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UnsynchronizedByteArrayOutputStream}.
          * <p>
-         * This builder use the aspects OutputStream and buffer size (chunk size).
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getInputStream()}</li>
+         * <li>{@link #getBufferSize()} (chunk size)</li>
+         * </ul>
          *
          * @return a new instance.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link OutputStream}.
          * @throws IOException                   if an I/O error occurs.
-         * @throws UnsupportedOperationException if the origin cannot be converted to an OutputStream.
          * @see #getOutputStream()
+         * @see #getBufferSize()
          */
         @Override
         public ChunkedOutputStream get() throws IOException {
diff --git a/src/main/java/org/apache/commons/io/output/ChunkedWriter.java b/src/main/java/org/apache/commons/io/output/ChunkedWriter.java
index 417f19e6..5e003f41 100644
--- a/src/main/java/org/apache/commons/io/output/ChunkedWriter.java
+++ b/src/main/java/org/apache/commons/io/output/ChunkedWriter.java
@@ -32,7 +32,7 @@
 public class ChunkedWriter extends FilterWriter {
 
     /**
-     * The default chunk size to use, i.e. {@value} bytes.
+     * The default chunk size to use: {@value} bytes.
      */
     private static final int DEFAULT_CHUNK_SIZE = IOUtils.DEFAULT_BUFFER_SIZE;
 
diff --git a/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java b/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java
index 8050e46a..4d1d38a6 100644
--- a/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java
@@ -22,8 +22,8 @@
 /**
  * Throws an IOException on all attempts to write to the stream.
  * <p>
- * Typically uses of this class include testing for corner cases in methods that accept an output stream and acting as a
- * sentinel value instead of a {@code null} output stream.
+ * Typically uses of this class include testing for corner cases in methods that accept an output stream and acting as a sentinel value instead of a
+ * {@code null} output stream.
  * </p>
  *
  * @since 1.4
@@ -55,6 +55,19 @@ public void flush() throws IOException {
         throw new IOException("flush() failed: stream is closed");
     }
 
+    /**
+     * Throws an {@link IOException} to indicate that the stream is closed.
+     *
+     * @param b   ignored
+     * @param off ignored
+     * @param len ignored
+     * @throws IOException always thrown
+     */
+    @Override
+    public void write(final byte b[], final int off, final int len) throws IOException {
+        throw new IOException("write(byte[], int, int) failed: stream is closed");
+    }
+
     /**
      * Throws an {@link IOException} to indicate that the stream is closed.
      *
@@ -63,6 +76,6 @@ public void flush() throws IOException {
      */
     @Override
     public void write(final int b) throws IOException {
-        throw new IOException("write(" + b + ") failed: stream is closed");
+        throw new IOException("write(int) failed: stream is closed");
     }
 }
diff --git a/src/main/java/org/apache/commons/io/output/CountingOutputStream.java b/src/main/java/org/apache/commons/io/output/CountingOutputStream.java
index 5be3721e..9f799cc9 100644
--- a/src/main/java/org/apache/commons/io/output/CountingOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/CountingOutputStream.java
@@ -40,7 +40,6 @@ public CountingOutputStream(final OutputStream out) {
         super(out);
     }
 
-
     /**
      * Updates the count with the number of bytes that are being written.
      *
@@ -87,7 +86,7 @@ public int getCount() {
     }
 
     /**
-     * Set the byte count back to 0.
+     * Sets the byte count back to 0.
      * <p>
      * NOTE: This method is an alternative for {@code resetCount()}.
      * It was added because that method returns an integer which will
@@ -104,7 +103,7 @@ public synchronized long resetByteCount() {
     }
 
     /**
-     * Set the byte count back to 0.
+     * Sets the byte count back to 0.
      * <p>
      * NOTE: From v1.3 this method throws an ArithmeticException if the
      * count is greater than can be expressed by an {@code int}.
diff --git a/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java b/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java
index 3382bdcd..9599edc8 100644
--- a/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java
@@ -32,17 +32,28 @@
  * An output stream which will retain data in memory until a specified threshold is reached, and only then commit it to disk. If the stream is closed before the
  * threshold is reached, the data will not be written to disk at all.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
+ * </p>
+ * <p>
+ * The caller is responsible for deleting the output file ({@link #getFile()}, {@link #getPath()}) created by a DeferredFileOutputStream when the caller only
+ * configured a prefix.
+ * </p>
+ * <p>
+ * The caller is responsible for deleting the output file passed to a constructor or builder through {@link Builder#setOutputFile(File)} or
+ * {@link Builder#setOutputFile(Path)}.
  * </p>
  * <p>
  * This class originated in FileUpload processing. In this use case, you do not know in advance the size of the file being uploaded. If the file is small you
  * want to store it in memory (for speed), but if the file is large you want to store it to file (to avoid memory issues).
  * </p>
+ *
+ * @see Builder
  */
 public class DeferredFileOutputStream extends ThresholdingOutputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link DeferredFileOutputStream} instance.
+     * Builds a new {@link DeferredFileOutputStream}.
      * <p>
      * For example:
      * </p>
@@ -57,11 +68,13 @@ public class DeferredFileOutputStream extends ThresholdingOutputStream {
      *   .get();}
      * </pre>
      * <p>
-     * The only super's aspect used us buffer size.
+     * The only super's aspect used is buffer size.
      * </p>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<DeferredFileOutputStream, Builder> {
 
         private int threshold;
@@ -79,10 +92,18 @@ public Builder() {
         }
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link DeferredFileOutputStream}.
          * <p>
-         * This builder use the aspects threshold, outputFile, prefix, suffix, directory, buffer size.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>threshold</li>
+         * <li>outputFile</li>
+         * <li>prefix</li>
+         * <li>suffix</li>
+         * <li>directory</li>
+         * </ul>
          *
          * @return a new instance.
          */
@@ -95,7 +116,7 @@ public DeferredFileOutputStream get() {
          * Sets the temporary file directory.
          *
          * @param directory Temporary file directory.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setDirectory(final File directory) {
             this.directory = toPath(directory, null);
@@ -106,7 +127,7 @@ public Builder setDirectory(final File directory) {
          * Sets the temporary file directory.
          *
          * @param directory Temporary file directory.
-         * @return this
+         * @return {@code this} instance.
          * @since 2.14.0
          */
         public Builder setDirectory(final Path directory) {
@@ -118,7 +139,7 @@ public Builder setDirectory(final Path directory) {
          * Sets the file to which data is saved beyond the threshold.
          *
          * @param outputFile The file to which data is saved beyond the threshold.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setOutputFile(final File outputFile) {
             this.outputFile = toPath(outputFile, null);
@@ -129,7 +150,7 @@ public Builder setOutputFile(final File outputFile) {
          * Sets the file to which data is saved beyond the threshold.
          *
          * @param outputFile The file to which data is saved beyond the threshold.
-         * @return this
+         * @return {@code this} instance.
          * @since 2.14.0
          */
         public Builder setOutputFile(final Path outputFile) {
@@ -141,7 +162,7 @@ public Builder setOutputFile(final Path outputFile) {
          * Sets the prefix to use for the temporary file.
          *
          * @param prefix Prefix to use for the temporary file.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setPrefix(final String prefix) {
             this.prefix = prefix;
@@ -152,7 +173,7 @@ public Builder setPrefix(final String prefix) {
          * Sets the suffix to use for the temporary file.
          *
          * @param suffix Suffix to use for the temporary file.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setSuffix(final String suffix) {
             this.suffix = suffix;
@@ -163,7 +184,7 @@ public Builder setSuffix(final String suffix) {
          * Sets the number of bytes at which to trigger an event.
          *
          * @param threshold The number of bytes at which to trigger an event.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setThreshold(final int threshold) {
             this.threshold = threshold;
@@ -360,9 +381,11 @@ public byte[] getData() {
      * Gets either the output File specified in the constructor or the temporary File created or null.
      * <p>
      * If the constructor specifying the File is used then it returns that same output File, even when threshold has not been reached.
+     * </p>
      * <p>
      * If constructor specifying a temporary File prefix/suffix is used then the temporary File created once the threshold is reached is returned if the
      * threshold was not reached then {@code null} is returned.
+     * </p>
      *
      * @return The File for this output stream, or {@code null} if no such File exists.
      */
@@ -374,9 +397,11 @@ public File getFile() {
      * Gets either the output Path specified in the constructor or the temporary Path created or null.
      * <p>
      * If the constructor specifying the file is used then it returns that same output Path, even when threshold has not been reached.
+     * </p>
      * <p>
      * If constructor specifying a temporary Path prefix/suffix is used then the temporary Path created once the threshold is reached is returned if the
      * threshold was not reached then {@code null} is returned.
+     * </p>
      *
      * @return The Path for this output stream, or {@code null} if no such Path exists.
      * @since 2.14.0
@@ -389,7 +414,6 @@ public Path getPath() {
      * Gets the current output stream. This may be memory based or disk based, depending on the current state with respect to the threshold.
      *
      * @return The underlying output stream.
-     *
      * @throws IOException if an error occurs.
      */
     @Override
@@ -447,7 +471,6 @@ public InputStream toInputStream() throws IOException {
         if (!closed) {
             throw new IOException("Stream not closed");
         }
-
         if (isInMemory()) {
             return memoryOutputStream.toInputStream();
         }
@@ -468,7 +491,6 @@ public void writeTo(final OutputStream outputStream) throws IOException {
         if (!closed) {
             throw new IOException("Stream not closed");
         }
-
         if (isInMemory()) {
             memoryOutputStream.writeTo(outputStream);
         } else {
diff --git a/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java b/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java
index 751f0e36..5d46d8bc 100644
--- a/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java
+++ b/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java
@@ -41,23 +41,26 @@
  * </p>
  * <p>
  * The encoding must be specified using either the name of the {@link Charset}, the {@link Charset}, or a {@link CharsetEncoder}. If the default encoding is
- * required then use the {@link java.io.FileWriter} directly, rather than this implementation.
+ * required then use the {@link FileWriter} directly, rather than this implementation.
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @since 1.4
  */
 public class FileWriterWithEncoding extends ProxyWriter {
 
+    // @formatter:off
     /**
-     * Builds a new {@link FileWriterWithEncoding} instance.
+     * Builds a new {@link FileWriterWithEncoding}.
+     *
      * <p>
      * Using a CharsetEncoder:
      * </p>
      * <pre>{@code
-     * FileWriterWithEncoding s = FileWriterWithEncoding.builder()
+     * FileWriterWithEncoding w = FileWriterWithEncoding.builder()
      *   .setPath(path)
      *   .setAppend(false)
      *   .setCharsetEncoder(StandardCharsets.UTF_8.newEncoder())
@@ -67,15 +70,17 @@ public class FileWriterWithEncoding extends ProxyWriter {
      * Using a Charset:
      * </p>
      * <pre>{@code
-     * FileWriterWithEncoding s = FileWriterWithEncoding.builder()
+     * FileWriterWithEncoding w = FileWriterWithEncoding.builder()
      *   .setPath(path)
      *   .setAppend(false)
      *   .setCharsetEncoder(StandardCharsets.UTF_8)
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<FileWriterWithEncoding, Builder> {
 
         private boolean append;
@@ -83,14 +88,18 @@ public static class Builder extends AbstractStreamBuilder<FileWriterWithEncoding
         private CharsetEncoder charsetEncoder = super.getCharset().newEncoder();
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link FileWriterWithEncoding}.
          * <p>
-         * This builder use the aspects File, CharsetEncoder, and append.
+         * You must set input that supports {@link File} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a File by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link File}</li>
+         * <li>{@link CharsetEncoder}</li>
+         * <li>append</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a File.
@@ -104,14 +113,14 @@ public FileWriterWithEncoding get() throws IOException {
                 throw new IllegalStateException(String.format("Mismatched Charset(%s) and CharsetEncoder(%s)", getCharset(), charsetEncoder.charset()));
             }
             final Object encoder = charsetEncoder != null ? charsetEncoder : getCharset();
-            return new FileWriterWithEncoding(FileWriterWithEncoding.initWriter(checkOrigin().getFile(), encoder, append));
+            return new FileWriterWithEncoding(initWriter(checkOrigin().getFile(), encoder, append));
         }
 
         /**
          * Sets whether or not to append.
          *
          * @param append Whether or not to append.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setAppend(final boolean append) {
             this.append = append;
@@ -122,7 +131,7 @@ public Builder setAppend(final boolean append) {
          * Sets charsetEncoder to use for encoding.
          *
          * @param charsetEncoder The charsetEncoder to use for encoding.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setCharsetEncoder(final CharsetEncoder charsetEncoder) {
             this.charsetEncoder = charsetEncoder;
diff --git a/src/main/java/org/apache/commons/io/output/LockableFileWriter.java b/src/main/java/org/apache/commons/io/output/LockableFileWriter.java
index b33abc81..6032f04b 100644
--- a/src/main/java/org/apache/commons/io/output/LockableFileWriter.java
+++ b/src/main/java/org/apache/commons/io/output/LockableFileWriter.java
@@ -21,6 +21,7 @@
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
 import java.io.Writer;
 import java.nio.charset.Charset;
 import java.util.Objects;
@@ -28,7 +29,6 @@
 import org.apache.commons.io.Charsets;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.build.AbstractOrigin;
-import org.apache.commons.io.build.AbstractOriginSupplier;
 import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
@@ -37,21 +37,25 @@
  * This class provides a simple alternative to {@link FileWriter} that will use a lock file to prevent duplicate writes.
  * </p>
  * <p>
- * <b>Note:</b> The lock file is deleted when {@link #close()} is called - or if the main file cannot be opened initially. In the (unlikely) event that the lock
- * file cannot be deleted, an exception is thrown.
+ * <strong>Note:</strong> The lock file is deleted when {@link #close()} is called - or if the main file cannot be opened initially. In the (unlikely) event
+ * that the lock file cannot be deleted, an exception is thrown.
  * </p>
  * <p>
  * By default, the file will be overwritten, but this may be changed to append. The lock directory may be specified, but defaults to the system property
  * {@code java.io.tmpdir}. The encoding may also be specified, and defaults to the platform default.
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
+ *
+ * @see Builder
  */
 public class LockableFileWriter extends Writer {
 
+    // @formatter:off
     /**
-     * Builds a new {@link LockableFileWriter} instance.
+     * Builds a new {@link LockableFileWriter}.
+     *
      * <p>
      * Using a CharsetEncoder:
      * </p>
@@ -63,15 +67,17 @@ public class LockableFileWriter extends Writer {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<LockableFileWriter, Builder> {
 
         private boolean append;
-        private AbstractOrigin<?, ?> lockDirectory = AbstractOriginSupplier.newFileOrigin(FileUtils.getTempDirectoryPath());
+        private AbstractOrigin<?, ?> lockDirectory = newFileOrigin(FileUtils.getTempDirectoryPath());
 
         /**
-         * Constructs a new Builder.
+         * Builds a new {@link LockableFileWriter}.
          */
         public Builder() {
             setBufferSizeDefault(AbstractByteArrayOutputStream.DEFAULT_SIZE);
@@ -81,12 +87,17 @@ public Builder() {
         /**
          * Constructs a new instance.
          * <p>
-         * This builder use the aspects File, Charset, append, and lockDirectory.
+         * You must set input that supports {@link File} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a File by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link File}</li>
+         * <li>{@link #getCharset()}</li>
+         * <li>append</li>
+         * <li>lockDirectory</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a File.
@@ -102,7 +113,7 @@ public LockableFileWriter get() throws IOException {
          * Sets whether to append (true) or overwrite (false).
          *
          * @param append whether to append (true) or overwrite (false).
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setAppend(final boolean append) {
             this.append = append;
@@ -113,10 +124,10 @@ public Builder setAppend(final boolean append) {
          * Sets the directory in which the lock file should be held.
          *
          * @param lockDirectory the directory in which the lock file should be held.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setLockDirectory(final File lockDirectory) {
-            this.lockDirectory = AbstractOriginSupplier.newFileOrigin(lockDirectory != null ? lockDirectory : FileUtils.getTempDirectory());
+            this.lockDirectory = newFileOrigin(lockDirectory != null ? lockDirectory : FileUtils.getTempDirectory());
             return this;
         }
 
@@ -124,10 +135,10 @@ public Builder setLockDirectory(final File lockDirectory) {
          * Sets the directory in which the lock file should be held.
          *
          * @param lockDirectory the directory in which the lock file should be held.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setLockDirectory(final String lockDirectory) {
-            this.lockDirectory = AbstractOriginSupplier.newFileOrigin(lockDirectory != null ? lockDirectory : FileUtils.getTempDirectoryPath());
+            this.lockDirectory = newFileOrigin(lockDirectory != null ? lockDirectory : FileUtils.getTempDirectoryPath());
             return this;
         }
 
@@ -190,7 +201,7 @@ public LockableFileWriter(final File file, final boolean append) throws IOExcept
      * @param lockDir the directory in which the lock file should be held
      * @throws NullPointerException if the file is null
      * @throws IOException          in case of an I/O error
-     * @deprecated 2.5 use {@link #LockableFileWriter(File, Charset, boolean, String)} instead
+     * @deprecated Use {@link #LockableFileWriter(File, Charset, boolean, String)} instead
      */
     @Deprecated
     public LockableFileWriter(final File file, final boolean append, final String lockDir) throws IOException {
@@ -255,7 +266,7 @@ public LockableFileWriter(final File file, final Charset charset, final boolean
      * @param charsetName the name of the requested charset, null means platform default
      * @throws NullPointerException                         if the file is null
      * @throws IOException                                  in case of an I/O error
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io.UnsupportedEncodingException} in version 2.2 if the encoding is not
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
      *                                                      supported.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
@@ -273,7 +284,7 @@ public LockableFileWriter(final File file, final String charsetName) throws IOEx
      * @param lockDir     the directory in which the lock file should be held
      * @throws NullPointerException                         if the file is null
      * @throws IOException                                  in case of an I/O error
-     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io.UnsupportedEncodingException} in version 2.2 if the encoding is not
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
      *                                                      supported.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
      */
diff --git a/src/main/java/org/apache/commons/io/output/NullAppendable.java b/src/main/java/org/apache/commons/io/output/NullAppendable.java
index 14ed4fab..40889f4c 100644
--- a/src/main/java/org/apache/commons/io/output/NullAppendable.java
+++ b/src/main/java/org/apache/commons/io/output/NullAppendable.java
@@ -20,7 +20,7 @@
 import java.io.IOException;
 
 /**
- * Appends all data to the famous <b>/dev/null</b>.
+ * Appends all data to the famous <strong>/dev/null</strong>.
  * <p>
  * This Appendable has no destination (file/socket etc.) and all characters written to it are ignored and lost.
  * </p>
diff --git a/src/main/java/org/apache/commons/io/output/NullOutputStream.java b/src/main/java/org/apache/commons/io/output/NullOutputStream.java
index de630bf4..55cd98c0 100644
--- a/src/main/java/org/apache/commons/io/output/NullOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/NullOutputStream.java
@@ -22,7 +22,7 @@
 /**
  * Never writes data. Calls never go beyond this class.
  * <p>
- * This output stream has no destination (file/socket etc.) and all bytes written to it are ignored and lost.
+ * This output stream has no destination and all bytes written to it are ignored.
  * </p>
  */
 public class NullOutputStream extends OutputStream {
@@ -44,46 +44,48 @@ public class NullOutputStream extends OutputStream {
 
     /**
      * Deprecated in favor of {@link #INSTANCE}.
-     *
+     * <p>
      * TODO: Will be private in 3.0.
+     * </p>
      *
      * @deprecated Use {@link #INSTANCE}.
      */
     @Deprecated
     public NullOutputStream() {
+        // empty
     }
 
     /**
-     * Does nothing - output to {@code /dev/null}.
+     * Does nothing.
      *
-     * @param b The bytes to write
-     * @throws IOException never
+     * @param b The This method ignores this parameter.
+     * @throws IOException This method never throws any exceptions.
      */
     @Override
     public void write(final byte[] b) throws IOException {
-        // To /dev/null
+        // noop
     }
 
     /**
-     * Does nothing - output to {@code /dev/null}.
+     * Does nothing.
      *
-     * @param b The bytes to write
-     * @param off The start offset
-     * @param len The number of bytes to write
+     * @param b This method ignores this parameter.
+     * @param off This method ignores this parameter.
+     * @param len This method ignores this parameter.
      */
     @Override
     public void write(final byte[] b, final int off, final int len) {
-        // To /dev/null
+        // noop
     }
 
     /**
-     * Does nothing - output to {@code /dev/null}.
+     * Does nothing.
      *
-     * @param b The byte to write
+     * @param b This method ignores this parameter.
      */
     @Override
     public void write(final int b) {
-        // To /dev/null
+        // noop
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/output/ProxyCollectionWriter.java b/src/main/java/org/apache/commons/io/output/ProxyCollectionWriter.java
index 008feb57..e3c1d107 100644
--- a/src/main/java/org/apache/commons/io/output/ProxyCollectionWriter.java
+++ b/src/main/java/org/apache/commons/io/output/ProxyCollectionWriter.java
@@ -77,7 +77,6 @@ protected void afterWrite(final int n) throws IOException {
      * @throws IOException if an I/O error occurs.
      * @since 2.0
      */
-    @SuppressWarnings("resource") // Fluent API.
     @Override
     public Writer append(final char c) throws IOException {
         try {
@@ -97,7 +96,6 @@ public Writer append(final char c) throws IOException {
      * @return this writer
      * @throws IOException if an I/O error occurs.
      */
-    @SuppressWarnings("resource") // Fluent API.
     @Override
     public Writer append(final CharSequence csq) throws IOException {
         try {
@@ -120,7 +118,6 @@ public Writer append(final CharSequence csq) throws IOException {
      * @return this writer
      * @throws IOException if an I/O error occurs.
      */
-    @SuppressWarnings("resource") // Fluent API.
     @Override
     public Writer append(final CharSequence csq, final int start, final int end) throws IOException {
         try {
diff --git a/src/main/java/org/apache/commons/io/output/ProxyOutputStream.java b/src/main/java/org/apache/commons/io/output/ProxyOutputStream.java
index b73f4121..303d0294 100644
--- a/src/main/java/org/apache/commons/io/output/ProxyOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/ProxyOutputStream.java
@@ -37,11 +37,11 @@ public class ProxyOutputStream extends FilterOutputStream {
     /**
      * Constructs a new ProxyOutputStream.
      *
-     * @param proxy  the OutputStream to delegate to
+     * @param delegate  the OutputStream to delegate to
      */
-    public ProxyOutputStream(final OutputStream proxy) {
-        super(proxy);
-        // the proxy is stored in a protected superclass variable named 'out'
+    public ProxyOutputStream(final OutputStream delegate) {
+        // the delegate is stored in a protected superclass variable named 'out'
+        super(delegate);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/output/ProxyWriter.java b/src/main/java/org/apache/commons/io/output/ProxyWriter.java
index b67b22a8..2d56afb6 100644
--- a/src/main/java/org/apache/commons/io/output/ProxyWriter.java
+++ b/src/main/java/org/apache/commons/io/output/ProxyWriter.java
@@ -33,11 +33,11 @@ public class ProxyWriter extends FilterWriter {
     /**
      * Constructs a new ProxyWriter.
      *
-     * @param proxy  the Writer to delegate to
+     * @param delegate  the Writer to delegate to
      */
-    public ProxyWriter(final Writer proxy) {
-        super(proxy);
-        // the proxy is stored in a protected superclass variable named 'out'
+    public ProxyWriter(final Writer delegate) {
+        // the delegate is stored in a protected superclass variable named 'out'
+        super(delegate);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/output/QueueOutputStream.java b/src/main/java/org/apache/commons/io/output/QueueOutputStream.java
index dc2319b9..66e7cdeb 100644
--- a/src/main/java/org/apache/commons/io/output/QueueOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/QueueOutputStream.java
@@ -28,7 +28,7 @@
 import org.apache.commons.io.input.QueueInputStream;
 
 /**
- * Simple alternative to JDK {@link java.io.PipedOutputStream}; queue input stream provides what's written in queue
+ * Simple alternative to JDK {@link PipedOutputStream}; queue input stream provides what's written in queue
  * output stream.
  * <p>
  * Example usage:
diff --git a/src/main/java/org/apache/commons/io/output/RandomAccessFileOutputStream.java b/src/main/java/org/apache/commons/io/output/RandomAccessFileOutputStream.java
new file mode 100644
index 00000000..0edaba63
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/output/RandomAccessFileOutputStream.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.nio.file.StandardOpenOption;
+import java.util.Objects;
+
+import org.apache.commons.io.build.AbstractStreamBuilder;
+
+/**
+ * An {@link OutputStream} that writes to a {@link RandomAccessFile}.
+ *
+ * @since 2.18.0
+ */
+public final class RandomAccessFileOutputStream extends OutputStream {
+
+    // @formatter:off
+    /**
+     * Builds a new {@link RandomAccessFileOutputStream}.
+     * <p>
+     * For example:
+     * </p>
+     * <pre>{@code
+     * RandomAccessFileOutputStream s = RandomAccessFileOutputStream.builder()
+     *   .setFile("myfile.txt")
+     *   .setOpenOptions(StandardOpenOption.SYNC)
+     *   .get();}
+     * </pre>
+     * <p>
+     * The only super's aspect used is buffer size.
+     * </p>
+     *
+     * @see #get()
+     */
+    // @formatter:on
+    public final static class Builder extends AbstractStreamBuilder<RandomAccessFileOutputStream, Builder> {
+
+        /**
+         * Use {@link RandomAccessFileOutputStream#builder()}.
+         */
+        private Builder() {
+            setOpenOptions(StandardOpenOption.WRITE);
+        }
+
+        @SuppressWarnings("resource")
+        @Override
+        public RandomAccessFileOutputStream get() throws IOException {
+            return new RandomAccessFileOutputStream(getRandomAccessFile());
+        }
+
+    }
+
+    /**
+     * Constructs a new {@link Builder}.
+     *
+     * @return a new {@link Builder}.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    private final RandomAccessFile randomAccessFile;
+
+    private RandomAccessFileOutputStream(final RandomAccessFile randomAccessFile) {
+        this.randomAccessFile = Objects.requireNonNull(randomAccessFile);
+    }
+
+    @Override
+    public void close() throws IOException {
+        this.randomAccessFile.close();
+        super.close();
+    }
+
+    @SuppressWarnings("resource")
+    @Override
+    public void flush() throws IOException {
+        randomAccessFile.getChannel().force(true);
+        super.flush();
+    }
+
+    @Override
+    public void write(final int b) throws IOException {
+        randomAccessFile.write(b);
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java b/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java
index 398f73a7..be88fdf8 100644
--- a/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java
+++ b/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java
@@ -17,26 +17,27 @@
 package org.apache.commons.io.output;
 
 import java.io.Serializable;
+import java.io.StringWriter;
 import java.io.Writer;
 
 /**
  * {@link Writer} implementation that outputs to a {@link StringBuilder}.
  * <p>
- * <strong>NOTE:</strong> This implementation, as an alternative to
- * {@code java.io.StringWriter}, provides an <i>un-synchronized</i>
- * (i.e. for use in a single thread) implementation for better performance.
- * For safe usage with multiple {@link Thread}s then
- * {@code java.io.StringWriter} should be used.
+ * <strong>NOTE:</strong> This implementation, as an alternative to {@link StringWriter}, provides an <em>un-synchronized</em> implementation for better
+ * performance for use in a single thread. For safe usage with multiple {@link Thread}s, a {@link StringWriter} should be used.
  * </p>
  * <h2>Deprecating Serialization</h2>
  * <p>
  * <em>Serialization is deprecated and will be removed in 3.0.</em>
  * </p>
+ *
  * @since 2.0
  */
 public class StringBuilderWriter extends Writer implements Serializable {
 
     private static final long serialVersionUID = -146927496096066153L;
+
+    /** The append target. */
     private final StringBuilder builder;
 
     /**
@@ -120,9 +121,8 @@ public void flush() {
         // no-op
     }
 
-
     /**
-     * Returns the underlying builder.
+     * Gets the underlying builder.
      *
      * @return The underlying builder
      */
diff --git a/src/main/java/org/apache/commons/io/output/TeeOutputStream.java b/src/main/java/org/apache/commons/io/output/TeeOutputStream.java
index b1456a4c..a9c20974 100644
--- a/src/main/java/org/apache/commons/io/output/TeeOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/TeeOutputStream.java
@@ -20,7 +20,7 @@
 import java.io.OutputStream;
 
 /**
- * Classic splitter of {@link OutputStream}. Named after the Unix 'tee' command. It allows a stream to be branched off
+ * Classic splitter of {@link OutputStream}. Named after the UNIX 'tee' command. It allows a stream to be branched off
  * so there are now two streams.
  */
 public class TeeOutputStream extends ProxyOutputStream {
diff --git a/src/main/java/org/apache/commons/io/output/TeeWriter.java b/src/main/java/org/apache/commons/io/output/TeeWriter.java
index 2db4e6af..c0aee7d8 100644
--- a/src/main/java/org/apache/commons/io/output/TeeWriter.java
+++ b/src/main/java/org/apache/commons/io/output/TeeWriter.java
@@ -21,7 +21,7 @@
 import java.util.Collection;
 
 /**
- * Classic splitter of {@link Writer}. Named after the Unix 'tee' command. It allows a stream to be branched off so
+ * Classic splitter of {@link Writer}. Named after the UNIX 'tee' command. It allows a stream to be branched off so
  * there are now two streams.
  * <p>
  * This currently a only convenience class with the proper name "TeeWriter".
diff --git a/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java b/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java
index 8102eb58..c0bf6013 100644
--- a/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java
@@ -23,9 +23,12 @@
 import org.apache.commons.io.function.IOFunction;
 
 /**
- * An output stream which triggers an event when a specified number of bytes of data have been written to it. The event
- * can be used, for example, to throw an exception if a maximum has been reached, or to switch the underlying stream
- * type when the threshold is exceeded.
+ * An output stream which triggers an event on the first write that causes
+ * the total number of bytes written to the stream to exceed a configured threshold,
+ * and every subsequent write. The event
+ * can be used, for example, to throw an exception if a maximum has been reached,
+ * or to switch the underlying stream when the threshold is exceeded.
+ *
  * <p>
  * This class overrides all {@link OutputStream} methods. However, these overrides ultimately call the corresponding
  * methods in the underlying output stream implementation.
@@ -78,6 +81,7 @@ public ThresholdingOutputStream(final int threshold) {
 
     /**
      * Constructs an instance of this class which will trigger an event at the specified threshold.
+     * A negative threshold has no meaning and will be treated as 0
      *
      * @param threshold The number of bytes at which to trigger an event.
      * @param thresholdConsumer Accepts reaching the threshold.
@@ -86,7 +90,7 @@ public ThresholdingOutputStream(final int threshold) {
      */
     public ThresholdingOutputStream(final int threshold, final IOConsumer<ThresholdingOutputStream> thresholdConsumer,
         final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter) {
-        this.threshold = threshold;
+        this.threshold = threshold < 0 ? 0 : threshold;
         this.thresholdConsumer = thresholdConsumer == null ? IOConsumer.noop() : thresholdConsumer;
         this.outputStreamGetter = outputStreamGetter == null ? NOOP_OS_GETTER : outputStreamGetter;
     }
@@ -244,6 +248,8 @@ public void write(final byte[] b) throws IOException {
     @SuppressWarnings("resource") // the underlying stream is managed by a subclass.
     @Override
     public void write(final byte[] b, final int off, final int len) throws IOException {
+        // TODO we could write the sub-array up the threshold, fire the event,
+        // and then write the rest so the event is always fired at the precise point.
         checkThreshold(len);
         // TODO for 4.0: Replace with getOutputStream()
         getStream().write(b, off, len);
diff --git a/src/main/java/org/apache/commons/io/output/UncheckedAppendableImpl.java b/src/main/java/org/apache/commons/io/output/UncheckedAppendableImpl.java
index 17cbe327..a02354fa 100644
--- a/src/main/java/org/apache/commons/io/output/UncheckedAppendableImpl.java
+++ b/src/main/java/org/apache/commons/io/output/UncheckedAppendableImpl.java
@@ -31,7 +31,7 @@
  * @see UncheckedIOException
  * @since 2.12.0
  */
-class UncheckedAppendableImpl implements UncheckedAppendable {
+final class UncheckedAppendableImpl implements UncheckedAppendable {
 
     private final Appendable appendable;
 
diff --git a/src/main/java/org/apache/commons/io/output/UncheckedFilterOutputStream.java b/src/main/java/org/apache/commons/io/output/UncheckedFilterOutputStream.java
index 91f115db..cfcceb02 100644
--- a/src/main/java/org/apache/commons/io/output/UncheckedFilterOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/UncheckedFilterOutputStream.java
@@ -28,18 +28,20 @@
 /**
  * A {@link FilterOutputStream} that throws {@link UncheckedIOException} instead of {@link UncheckedIOException}.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see FilterOutputStream
  * @see UncheckedIOException
- * @see UncheckedIOException
  * @since 2.12.0
  */
 public final class UncheckedFilterOutputStream extends FilterOutputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UncheckedFilterOutputStream} instance.
+     * Builds a new {@link UncheckedFilterOutputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -56,21 +58,28 @@ public final class UncheckedFilterOutputStream extends FilterOutputStream {
      *   .setPath(path)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UncheckedFilterOutputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UncheckedFilterOutputStream}.
          * <p>
-         * This builder use the aspect OutputStream and OpenOption[].
+         * You must set input that supports {@link #getOutputStream()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an OutputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getOutputStream()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an OutputStream.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link OutputStream}.
+         * @throws IOException                   if an I/O error occurs.
          * @see #getOutputStream()
          */
         @SuppressWarnings("resource")
diff --git a/src/main/java/org/apache/commons/io/output/UncheckedFilterWriter.java b/src/main/java/org/apache/commons/io/output/UncheckedFilterWriter.java
index f152f487..b9e25897 100644
--- a/src/main/java/org/apache/commons/io/output/UncheckedFilterWriter.java
+++ b/src/main/java/org/apache/commons/io/output/UncheckedFilterWriter.java
@@ -28,9 +28,10 @@
 /**
  * A {@link FilterWriter} that throws {@link UncheckedIOException} instead of {@link IOException}.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see FilterWriter
  * @see IOException
  * @see UncheckedIOException
@@ -38,8 +39,10 @@
  */
 public final class UncheckedFilterWriter extends FilterWriter {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UncheckedFilterWriter} instance.
+     * Builds a new {@link UncheckedFilterWriter}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -56,18 +59,23 @@ public final class UncheckedFilterWriter extends FilterWriter {
      *   .setPath(path)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UncheckedFilterWriter, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UncheckedFilterWriter}.
          * <p>
-         * This builder use the aspects Writer, OpenOption[], and Charset.
+         * You must set input that supports {@link #getWriter()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Writer by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getWriter()}</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a Writer.
diff --git a/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java b/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java
index 232e7186..cd0b231f 100644
--- a/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java
@@ -27,18 +27,21 @@
 import org.apache.commons.io.input.UnsynchronizedByteArrayInputStream;
 
 /**
- * Implements a version of {@link AbstractByteArrayOutputStream} <b>without</b> any concurrent thread safety.
+ * Implements a version of {@link AbstractByteArrayOutputStream} <strong>without</strong> any concurrent thread safety.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @since 2.7
  */
 //@NotThreadSafe
 public final class UnsynchronizedByteArrayOutputStream extends AbstractByteArrayOutputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link UnsynchronizedByteArrayOutputStream} instance.
+     * Builds a new {@link UnsynchronizedByteArrayOutputStream}.
+     *
      * <p>
      * Using File IO:
      * </p>
@@ -55,14 +58,21 @@ public final class UnsynchronizedByteArrayOutputStream extends AbstractByteArray
      *   .setBufferSize(8192)
      *   .get();}
      * </pre>
+     *
+     * @see #get()
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<UnsynchronizedByteArrayOutputStream, Builder> {
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link UnsynchronizedByteArrayOutputStream}.
+         *
          * <p>
-         * This builder use the aspect buffer size.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getBufferSize()}</li>
+         * </ul>
          *
          * @return a new instance.
          * @see AbstractOrigin#getByteArray()
diff --git a/src/main/java/org/apache/commons/io/output/WriterOutputStream.java b/src/main/java/org/apache/commons/io/output/WriterOutputStream.java
index bc2c5c21..115231eb 100644
--- a/src/main/java/org/apache/commons/io/output/WriterOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/WriterOutputStream.java
@@ -16,8 +16,11 @@
  */
 package org.apache.commons.io.output;
 
+import java.io.BufferedWriter;
 import java.io.IOException;
+import java.io.InputStreamReader;
 import java.io.OutputStream;
+import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
@@ -39,16 +42,16 @@
  * <p>
  * The output of the {@link CharsetDecoder} is buffered using a fixed size buffer. This implies that the data is written to the underlying {@link Writer} in
  * chunks that are no larger than the size of this buffer. By default, the buffer is flushed only when it overflows or when {@link #flush()} or {@link #close()}
- * is called. In general there is therefore no need to wrap the underlying {@link Writer} in a {@link java.io.BufferedWriter}. {@link WriterOutputStream} can
+ * is called. In general there is therefore no need to wrap the underlying {@link Writer} in a {@link BufferedWriter}. {@link WriterOutputStream} can
  * also be instructed to flush the buffer after each write operation. In this case, all available data is written immediately to the underlying {@link Writer},
  * implying that the current position of the {@link Writer} is correlated to the current position of the {@link WriterOutputStream}.
  * </p>
  * <p>
- * {@link WriterOutputStream} implements the inverse transformation of {@link java.io.OutputStreamWriter}; in the following example, writing to {@code out2}
+ * {@link WriterOutputStream} implements the inverse transformation of {@link OutputStreamWriter}; in the following example, writing to {@code out2}
  * would have the same result as writing to {@code out} directly (provided that the byte sequence is legal with respect to the charset encoding):
  * </p>
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  * <pre>
  * OutputStream out = ...
@@ -60,8 +63,8 @@
  *   .get();
  * </pre>
  * <p>
- * {@link WriterOutputStream} implements the same transformation as {@link java.io.InputStreamReader}, except that the control flow is reversed: both classes
- * transform a byte stream into a character stream, but {@link java.io.InputStreamReader} pulls data from the underlying stream, while
+ * {@link WriterOutputStream} implements the same transformation as {@link InputStreamReader}, except that the control flow is reversed: both classes
+ * transform a byte stream into a character stream, but {@link InputStreamReader} pulls data from the underlying stream, while
  * {@link WriterOutputStream} pushes it to the underlying stream.
  * </p>
  * <p>
@@ -73,13 +76,16 @@
  * Instances of {@link WriterOutputStream} are not thread safe.
  * </p>
  *
+ * @see Builder
  * @see org.apache.commons.io.input.ReaderInputStream
  * @since 2.0
  */
 public class WriterOutputStream extends OutputStream {
 
+    // @formatter:off
     /**
-     * Builds a new {@link WriterOutputStream} instance.
+     * Builds a new {@link WriterOutputStream}.
+     *
      * <p>
      * For example:
      * </p>
@@ -92,8 +98,10 @@ public class WriterOutputStream extends OutputStream {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:on
     public static class Builder extends AbstractStreamBuilder<WriterOutputStream, Builder> {
 
         private CharsetDecoder charsetDecoder;
@@ -107,14 +115,19 @@ public Builder() {
         }
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link WriterOutputStream}.
          * <p>
-         * This builder use the aspect Writer, OpenOption[], Charset, CharsetDecoder, buffer size and writeImmediately.
+         * You must set input that supports {@link #getWriter()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to a Writer by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getWriter()}</li>
+         * <li>{@link #getBufferSize()}</li>
+         * <li>charsetDecoder</li>
+         * <li>writeImmediately</li>
+         * </ul>
          *
          * @return a new instance.
          * @throws UnsupportedOperationException if the origin cannot provide a Writer.
@@ -144,7 +157,7 @@ public Builder setCharset(final String charset) {
          * Sets the charset decoder.
          *
          * @param charsetDecoder the charset decoder.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setCharsetDecoder(final CharsetDecoder charsetDecoder) {
             this.charsetDecoder = charsetDecoder != null ? charsetDecoder : getCharsetDefault().newDecoder();
@@ -153,14 +166,14 @@ public Builder setCharsetDecoder(final CharsetDecoder charsetDecoder) {
         }
 
         /**
-         * Sets whether the output buffer will be flushed after each write operation ({@code true}), i.e. all available data will be written to the underlying
-         * {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when {@link #flush()} or {@link #close()}
-         * is called.
+         * Sets whether the output buffer will be flushed after each write operation ({@code true}), meaning all available data will be written to the
+         * underlying {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when {@link #flush()} or
+         * {@link #close()} is called.
          *
-         * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, i.e. all available data will be written to the
-         *                         underlying {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when
+         * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, meaning all available data will be written to
+         *                         the underlying {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when
          *                         {@link #flush()} or {@link #close()} is called.
-         * @return this
+         * @return {@code this} instance.
          */
         public Builder setWriteImmediately(final boolean writeImmediately) {
             this.writeImmediately = writeImmediately;
@@ -262,7 +275,7 @@ public WriterOutputStream(final Writer writer, final Charset charset) {
      * @param writer           the target {@link Writer}
      * @param charset          the charset encoding
      * @param bufferSize       the size of the output buffer in number of characters
-     * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, i.e. all available data will be written to the
+     * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, meaning all available data will be written to the
      *                         underlying {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when
      *                         {@link #flush()} or {@link #close()} is called.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
@@ -300,7 +313,7 @@ public WriterOutputStream(final Writer writer, final CharsetDecoder decoder) {
      * @param writer           the target {@link Writer}
      * @param decoder          the charset decoder
      * @param bufferSize       the size of the output buffer in number of characters
-     * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, i.e. all available data will be written to the
+     * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, meaning all available data will be written to the
      *                         underlying {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when
      *                         {@link #flush()} or {@link #close()} is called.
      * @since 2.1
@@ -334,7 +347,7 @@ public WriterOutputStream(final Writer writer, final String charsetName) {
      * @param writer           the target {@link Writer}
      * @param charsetName      the name of the charset encoding
      * @param bufferSize       the size of the output buffer in number of characters
-     * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, i.e. all available data will be written to the
+     * @param writeImmediately If {@code true} the output buffer will be flushed after each write operation, meaning all available data will be written to the
      *                         underlying {@link Writer} immediately. If {@code false}, the output buffer will only be flushed when it overflows or when
      *                         {@link #flush()} or {@link #close()} is called.
      * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}
diff --git a/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java b/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java
index 6f732a72..a8ccc249 100644
--- a/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java
+++ b/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java
@@ -38,16 +38,19 @@
 /**
  * Character stream that handles all the necessary work to figure out the charset encoding of the XML document written to the stream.
  * <p>
- * To build an instance, see {@link Builder}.
+ * To build an instance, use {@link Builder}.
  * </p>
  *
+ * @see Builder
  * @see XmlStreamReader
  * @since 2.0
  */
 public class XmlStreamWriter extends Writer {
 
+    // @formatter:off
     /**
-     * Builds a new {@link XmlStreamWriter} instance.
+     * Builds a new {@link XmlStreamWriter}.
+     *
      * <p>
      * For example:
      * </p>
@@ -58,12 +61,14 @@ public class XmlStreamWriter extends Writer {
      *   .get();}
      * </pre>
      *
+     * @see #get()
      * @since 2.12.0
      */
+    // @formatter:off
     public static class Builder extends AbstractStreamBuilder<XmlStreamWriter, Builder> {
 
         /**
-         * Constructs a new Builder.
+         * Constructs a new {@link Builder}.
          */
         public Builder() {
             setCharsetDefault(StandardCharsets.UTF_8);
@@ -71,17 +76,21 @@ public Builder() {
         }
 
         /**
-         * Constructs a new instance.
+         * Builds a new {@link XmlStreamWriter}.
          * <p>
-         * This builder use the aspect OutputStream, OpenOption[], and Charset.
+         * You must set input that supports {@link #getOutputStream()} on this builder, otherwise, this method throws an exception.
          * </p>
          * <p>
-         * You must provide an origin that can be converted to an OutputStream by this builder, otherwise, this call will throw an
-         * {@link UnsupportedOperationException}.
+         * This builder use the following aspects:
          * </p>
+         * <ul>
+         * <li>{@link #getOutputStream()}</li>
+         * <li>{@link #getCharset()}</li>
+         * </ul>
          *
          * @return a new instance.
-         * @throws UnsupportedOperationException if the origin cannot provide an OutputStream.
+         * @throws IllegalStateException         if the {@code origin} is {@code null}.
+         * @throws UnsupportedOperationException if the origin cannot be converted to an {@link OutputStream}.
          * @throws IOException                   if an I/O error occurs.
          * @see #getOutputStream()
          */
diff --git a/src/main/java/org/apache/commons/io/package-info.java b/src/main/java/org/apache/commons/io/package-info.java
index 6633c106..25cfe244 100644
--- a/src/main/java/org/apache/commons/io/package-info.java
+++ b/src/main/java/org/apache/commons/io/package-info.java
@@ -18,20 +18,21 @@
 /**
  * Provides classes for working with streams, readers, writers and files. The most commonly used classes are described here:
  * <p>
- * <b>IOUtils</b> is the most frequently used class. It provides operations to read, write, copy and close streams.
+ * <strong>IOUtils</strong> is the most frequently used class. It provides operations to read, write, copy and close streams.
  * </p>
  * <p>
- * <b>FileUtils</b> provides operations based around the JDK File class. These include reading, writing, copying, comparing and deleting.
+ * <strong>FileUtils</strong> provides operations based around the JDK File class. These include reading, writing, copying, comparing and deleting.
  * </p>
  * <p>
- * <b>FilenameUtils</b> provides utilities based on filenames. This utility class manipulates file names without using File objects. It aims to simplify the
- * transition between Windows and Unix. Before using this class however, you should consider whether you should be using File objects.
+ * <strong>FilenameUtils</strong> provides utilities based on filenames. This utility class manipulates file names without using File objects. It aims to
+ * simplify the transition between Windows and Unix. Before using this class however, you should consider whether you should be using File objects.
  * </p>
  * <p>
- * <b>FileSystemUtils</b> allows access to the filing system in ways the JDK does not support. At present this allows you to get the free space on a drive.
+ * <strong>FileSystemUtils</strong> allows access to the filing system in ways the JDK does not support. At present this allows you to get the free space on a
+ * drive.
  * </p>
  * <p>
- * <b>EndianUtils</b> swaps data between Big-Endian and Little-Endian formats.
+ * <strong>EndianUtils</strong> swaps data between Big-Endian and Little-Endian formats.
  * </p>
  */
 package org.apache.commons.io;
diff --git a/src/main/java/org/apache/commons/io/serialization/ClassNameMatcher.java b/src/main/java/org/apache/commons/io/serialization/ClassNameMatcher.java
index f454bc3f..7fa9f564 100644
--- a/src/main/java/org/apache/commons/io/serialization/ClassNameMatcher.java
+++ b/src/main/java/org/apache/commons/io/serialization/ClassNameMatcher.java
@@ -21,6 +21,7 @@
 /**
  * An object that matches a Class name to a condition.
  */
+@FunctionalInterface
 public interface ClassNameMatcher {
 
     /**
diff --git a/src/main/java/org/apache/commons/io/serialization/ObjectStreamClassPredicate.java b/src/main/java/org/apache/commons/io/serialization/ObjectStreamClassPredicate.java
new file mode 100644
index 00000000..93cd0bd2
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/serialization/ObjectStreamClassPredicate.java
@@ -0,0 +1,204 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.commons.io.serialization;
+
+import java.io.ObjectStreamClass;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+
+/**
+ * A predicate (boolean-valued function) of one argument to accept and reject classes.
+ * <p>
+ * The reject list takes precedence over the accept list.
+ * </p>
+ *
+ * @since 2.18.0
+ */
+public class ObjectStreamClassPredicate implements Predicate<ObjectStreamClass> {
+
+    // This is not a Set for now to avoid ClassNameMatchers requiring proper implementations of hashCode() and equals().
+    private final List<ClassNameMatcher> acceptMatchers = new ArrayList<>();
+
+    // This is not a Set for now to avoid ClassNameMatchers requiring proper implementations of hashCode() and equals().
+    private final List<ClassNameMatcher> rejectMatchers = new ArrayList<>();
+
+    /**
+     * Constructs a new instance.
+     */
+    public ObjectStreamClassPredicate() {
+        // empty
+    }
+
+    /**
+     * Accepts the specified classes for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param classes Classes to accept
+     * @return this object
+     */
+    public ObjectStreamClassPredicate accept(final Class<?>... classes) {
+        Stream.of(classes).map(c -> new FullClassNameMatcher(c.getName())).forEach(acceptMatchers::add);
+        return this;
+    }
+
+    /**
+     * Accepts class names where the supplied ClassNameMatcher matches for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param matcher a class name matcher to <em>accept</em> objects.
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate accept(final ClassNameMatcher matcher) {
+        acceptMatchers.add(matcher);
+        return this;
+    }
+
+    /**
+     * Accepts class names that match the supplied pattern for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param pattern a Pattern for compiled regular expression.
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate accept(final Pattern pattern) {
+        acceptMatchers.add(new RegexpClassNameMatcher(pattern));
+        return this;
+    }
+
+    /**
+     * Accepts the wildcard specified classes for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param patterns Wildcard file name patterns as defined by {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String)
+     *                 FilenameUtils.wildcardMatch}
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate accept(final String... patterns) {
+        Stream.of(patterns).map(WildcardClassNameMatcher::new).forEach(acceptMatchers::add);
+        return this;
+    }
+
+    /**
+     * Rejects the specified classes for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param classes Classes to reject
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate reject(final Class<?>... classes) {
+        Stream.of(classes).map(c -> new FullClassNameMatcher(c.getName())).forEach(rejectMatchers::add);
+        return this;
+    }
+
+    /**
+     * Rejects class names where the supplied ClassNameMatcher matches for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param m the matcher to use
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate reject(final ClassNameMatcher m) {
+        rejectMatchers.add(m);
+        return this;
+    }
+
+    /**
+     * Rejects class names that match the supplied pattern for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param pattern standard Java regexp
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate reject(final Pattern pattern) {
+        rejectMatchers.add(new RegexpClassNameMatcher(pattern));
+        return this;
+    }
+
+    /**
+     * Rejects the wildcard specified classes for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param patterns Wildcard file name patterns as defined by {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String)
+     *                 FilenameUtils.wildcardMatch}
+     * @return this instance.
+     */
+    public ObjectStreamClassPredicate reject(final String... patterns) {
+        Stream.of(patterns).map(WildcardClassNameMatcher::new).forEach(rejectMatchers::add);
+        return this;
+    }
+
+    /**
+     * Tests that the ObjectStreamClass conforms to requirements.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param objectStreamClass The ObjectStreamClass to test.
+     * @return true if the input is accepted, false if rejected, false if neither.
+     */
+    @Override
+    public boolean test(final ObjectStreamClass objectStreamClass) {
+        return test(objectStreamClass.getName());
+    }
+
+    /**
+     * Tests that the class name conforms to requirements.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
+     *
+     * @param name The class name to test.
+     * @return true if the input is accepted, false if rejected, false if neither.
+     */
+    public boolean test(final String name) {
+        // The reject list takes precedence over the accept list.
+        for (final ClassNameMatcher m : rejectMatchers) {
+            if (m.matches(name)) {
+                return false;
+            }
+        }
+        for (final ClassNameMatcher m : acceptMatchers) {
+            if (m.matches(name)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/apache/commons/io/serialization/ValidatingObjectInputStream.java b/src/main/java/org/apache/commons/io/serialization/ValidatingObjectInputStream.java
index 6e60f32e..9c931724 100644
--- a/src/main/java/org/apache/commons/io/serialization/ValidatingObjectInputStream.java
+++ b/src/main/java/org/apache/commons/io/serialization/ValidatingObjectInputStream.java
@@ -23,176 +23,416 @@
 import java.io.InvalidClassException;
 import java.io.ObjectInputStream;
 import java.io.ObjectStreamClass;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.regex.Pattern;
-import java.util.stream.Stream;
+
+import org.apache.commons.io.build.AbstractStreamBuilder;
 
 /**
- * An {@link ObjectInputStream} that's restricted to deserialize
- * a limited set of classes.
+ * An {@link ObjectInputStream} that's restricted to deserialize a limited set of classes.
  *
  * <p>
- * Various accept/reject methods allow for specifying which classes
- * can be deserialized.
+ * Various accept/reject methods allow for specifying which classes can be deserialized.
+ * </p>
+ * <h2>Reading safely</h2>
+ * <p>
+ * Here is the only way to safely read a HashMap of String keys and Integer values:
  * </p>
  *
+ * <pre>{@code
+ * // Defining Object fixture
+ * final HashMap<String, Integer> map1 = new HashMap<>();
+ * map1.put("1", 1);
+ * // Writing serialized fixture
+ * final byte[] byteArray;
+ * try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
+ *         final ObjectOutputStream oos = new ObjectOutputStream(baos)) {
+ *     oos.writeObject(map1);
+ *     oos.flush();
+ *     byteArray = baos.toByteArray();
+ * }
+ * // Reading
+ * try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+ *         ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()
+ *             .accept(HashMap.class, Number.class, Integer.class)
+ *             .setInputStream(bais)
+ *             .get()) {
+ *     // String.class is automatically accepted
+ *     final HashMap<String, Integer> map2 = (HashMap<String, Integer>) vois.readObject();
+ *     assertEquals(map1, map2);
+ * }
+ * // Reusing a configuration
+ * final ObjectStreamClassPredicate predicate = new ObjectStreamClassPredicate()
+ *     .accept(HashMap.class, Number.class, Integer.class);
+ * try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+ *         ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()
+ *             .setPredicate(predicate)
+ *             .setInputStream(bais)
+ *             .get()) {
+ *     // String.class is automatically accepted
+ *     final HashMap<String, Integer> map2 = (HashMap<String, Integer>) vois.readObject();
+ *     assertEquals(map1, map2);
+ * }
+ * }</pre>
  * <p>
- * Design inspired by <a
- * href="http://www.ibm.com/developerworks/library/se-lookahead/">IBM
- * DeveloperWorks Article</a>.
+ * Design inspired by a <a href="http://www.ibm.com/developerworks/library/se-lookahead/">IBM DeveloperWorks Article</a>.
  * </p>
+ *
+ * @since 2.5
  */
 public class ValidatingObjectInputStream extends ObjectInputStream {
-    private final List<ClassNameMatcher> acceptMatchers = new ArrayList<>();
-    private final List<ClassNameMatcher> rejectMatchers = new ArrayList<>();
 
+    // @formatter:off
     /**
-     * Constructs an object to deserialize the specified input stream.
-     * At least one accept method needs to be called to specify which
-     * classes can be deserialized, as by default no classes are
-     * accepted.
+     * Builds a new {@link ValidatingObjectInputStream}.
+     *
+     * <h2>Using NIO</h2>
+     * <pre>{@code
+     * ValidatingObjectInputStream s = ValidatingObjectInputStream.builder()
+     *   .setPath(Paths.get("MyFile.ser"))
+     *   .get();}
+     * </pre>
+     * <h2>Using IO</h2>
+     * <pre>{@code
+     * ValidatingObjectInputStream s = ValidatingObjectInputStream.builder()
+     *   .setFile(new File("MyFile.ser"))
+     *   .get();}
+     * </pre>
+     *
+     * @see #get()
+     * @since 2.18.0
+     */
+    // @formatter:on
+    public static class Builder extends AbstractStreamBuilder<ValidatingObjectInputStream, Builder> {
+
+        private ObjectStreamClassPredicate predicate = new ObjectStreamClassPredicate();
+
+        /**
+         * Constructs a new instance.
+         *
+         * @deprecated Use {@link #builder()}.
+         */
+        @Deprecated
+        public Builder() {
+            // empty
+        }
+
+        /**
+         * Accepts the specified classes for deserialization, unless they are otherwise rejected.
+         *
+         * @param classes Classes to accept
+         * @return this object
+         * @since 2.18.0
+         */
+        public Builder accept(final Class<?>... classes) {
+            predicate.accept(classes);
+            return this;
+        }
+
+        /**
+         * Accepts class names where the supplied ClassNameMatcher matches for deserialization, unless they are otherwise rejected.
+         *
+         * @param matcher a class name matcher to <em>accept</em> objects.
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder accept(final ClassNameMatcher matcher) {
+            predicate.accept(matcher);
+            return this;
+        }
+
+        /**
+         * Accepts class names that match the supplied pattern for deserialization, unless they are otherwise rejected.
+         *
+         * @param pattern a Pattern for compiled regular expression.
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder accept(final Pattern pattern) {
+            predicate.accept(pattern);
+            return this;
+        }
+
+        /**
+         * Accepts the wildcard specified classes for deserialization, unless they are otherwise rejected.
+         *
+         * @param patterns Wildcard file name patterns as defined by {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String)
+         *                 FilenameUtils.wildcardMatch}
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder accept(final String... patterns) {
+            predicate.accept(patterns);
+            return this;
+        }
+
+        @Override
+        public ValidatingObjectInputStream get() throws IOException {
+            return new ValidatingObjectInputStream(getInputStream(), predicate);
+        }
+
+        /**
+         * Gets the predicate.
+         *
+         * @return the predicate.
+         * @since 2.18.0
+         */
+        public ObjectStreamClassPredicate getPredicate() {
+            return predicate;
+        }
+
+        /**
+         * Rejects the specified classes for deserialization, even if they are otherwise accepted.
+         *
+         * @param classes Classes to reject
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder reject(final Class<?>... classes) {
+            predicate.reject(classes);
+            return this;
+        }
+
+        /**
+         * Rejects class names where the supplied ClassNameMatcher matches for deserialization, even if they are otherwise accepted.
+         *
+         * @param matcher the matcher to use
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder reject(final ClassNameMatcher matcher) {
+            predicate.reject(matcher);
+            return this;
+        }
+
+        /**
+         * Rejects class names that match the supplied pattern for deserialization, even if they are otherwise accepted.
+         *
+         * @param pattern standard Java regexp
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder reject(final Pattern pattern) {
+            predicate.reject(pattern);
+            return this;
+        }
+
+        /**
+         * Rejects the wildcard specified classes for deserialization, even if they are otherwise accepted.
+         *
+         * @param patterns Wildcard file name patterns as defined by {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String)
+         *                 FilenameUtils.wildcardMatch}
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder reject(final String... patterns) {
+            predicate.reject(patterns);
+            return this;
+        }
+
+        /**
+         * Sets the predicate, null resets to an empty new ObjectStreamClassPredicate.
+         *
+         * @param predicate the predicate.
+         * @return this instance.
+         * @since 2.18.0
+         */
+        public Builder setPredicate(final ObjectStreamClassPredicate predicate) {
+            this.predicate = predicate != null ? predicate : new ObjectStreamClassPredicate();
+            return this;
+        }
+
+    }
+
+    /**
+     * Constructs a new {@link Builder}.
+     *
+     * @return a new {@link Builder}.
+     * @since 2.18.0
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    private final ObjectStreamClassPredicate predicate;
+
+    /**
+     * Constructs an instance to deserialize the specified input stream. At least one accept method needs to be called to specify which classes can be
+     * deserialized, as by default no classes are accepted.
      *
      * @param input an input stream
      * @throws IOException if an I/O error occurs while reading stream header
+     * @deprecated Use {@link #builder()}.
      */
+    @Deprecated
     public ValidatingObjectInputStream(final InputStream input) throws IOException {
+        this(input, new ObjectStreamClassPredicate());
+    }
+
+    /**
+     * Constructs an instance to deserialize the specified input stream. At least one accept method needs to be called to specify which classes can be
+     * deserialized, as by default no classes are accepted.
+     *
+     * @param input     an input stream.
+     * @param predicate how to accept and reject classes.
+     * @throws IOException if an I/O error occurs while reading stream header.
+     */
+    private ValidatingObjectInputStream(final InputStream input, final ObjectStreamClassPredicate predicate) throws IOException {
         super(input);
+        this.predicate = predicate;
     }
 
     /**
-     * Accept the specified classes for deserialization, unless they
-     * are otherwise rejected.
+     * Accepts the specified classes for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
      * @param classes Classes to accept
-     * @return this object
+     * @return this instance.
      */
     public ValidatingObjectInputStream accept(final Class<?>... classes) {
-        Stream.of(classes).map(c -> new FullClassNameMatcher(c.getName())).forEach(acceptMatchers::add);
+        predicate.accept(classes);
         return this;
     }
 
     /**
-     * Accept class names where the supplied ClassNameMatcher matches for
-     * deserialization, unless they are otherwise rejected.
+     * Accepts class names where the supplied ClassNameMatcher matches for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param m the matcher to use
-     * @return this object
+     * @param matcher a class name matcher to <em>accept</em> objects.
+     * @return this instance.
      */
-    public ValidatingObjectInputStream accept(final ClassNameMatcher m) {
-        acceptMatchers.add(m);
+    public ValidatingObjectInputStream accept(final ClassNameMatcher matcher) {
+        predicate.accept(matcher);
         return this;
     }
 
     /**
-     * Accept class names that match the supplied pattern for
-     * deserialization, unless they are otherwise rejected.
+     * Accepts class names that match the supplied pattern for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param pattern standard Java regexp
-     * @return this object
+     * @param pattern a Pattern for compiled regular expression.
+     * @return this instance.
      */
     public ValidatingObjectInputStream accept(final Pattern pattern) {
-        acceptMatchers.add(new RegexpClassNameMatcher(pattern));
+        predicate.accept(pattern);
         return this;
     }
 
     /**
-     * Accept the wildcard specified classes for deserialization,
-     * unless they are otherwise rejected.
+     * Accepts the wildcard specified classes for deserialization, unless they are otherwise rejected.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param patterns Wildcard file name patterns as defined by
-     *                  {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String) FilenameUtils.wildcardMatch}
-     * @return this object
+     * @param patterns Wildcard file name patterns as defined by {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String)
+     *                 FilenameUtils.wildcardMatch}.
+     * @return this instance.
      */
     public ValidatingObjectInputStream accept(final String... patterns) {
-        Stream.of(patterns).map(WildcardClassNameMatcher::new).forEach(acceptMatchers::add);
+        predicate.accept(patterns);
         return this;
     }
 
     /**
      * Checks that the class name conforms to requirements.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param name The class name
-     * @throws InvalidClassException when a non-accepted class is encountered
+     * @param name The class name to test.
+     * @throws InvalidClassException Thrown when a rejected or non-accepted class is found.
      */
     private void checkClassName(final String name) throws InvalidClassException {
-        // Reject has precedence over accept
-        for (final ClassNameMatcher m : rejectMatchers) {
-            if (m.matches(name)) {
-                invalidClassNameFound(name);
-            }
-        }
-
-        boolean ok = false;
-        for (final ClassNameMatcher m : acceptMatchers) {
-            if (m.matches(name)) {
-                ok = true;
-                break;
-            }
-        }
-        if (!ok) {
+        if (!predicate.test(name)) {
             invalidClassNameFound(name);
         }
     }
 
     /**
-     * Called to throw {@link InvalidClassException} if an invalid
-     * class name is found during deserialization. Can be overridden, for example
-     * to log those class names.
+     * Called to throw {@link InvalidClassException} if an invalid class name is found during deserialization. Can be overridden, for example to log those class
+     * names.
      *
-     * @param className name of the invalid class
-     * @throws InvalidClassException if the specified class is not allowed
+     * @param className name of the invalid class.
+     * @throws InvalidClassException Thrown with a message containing the class name.
      */
     protected void invalidClassNameFound(final String className) throws InvalidClassException {
         throw new InvalidClassException("Class name not accepted: " + className);
     }
 
     /**
-     * Reject the specified classes for deserialization, even if they
-     * are otherwise accepted.
+     * Delegates to {@link #readObject()} and casts to the generic {@code T}.
+     *
+     * @param <T> The return type.
+     * @return Result from {@link #readObject()}.
+     * @throws ClassNotFoundException Thrown by {@link #readObject()}.
+     * @throws IOException            Thrown by {@link #readObject()}.
+     * @throws ClassCastException     Thrown when {@link #readObject()} does not match {@code T}.
+     * @since 2.18.0
+     */
+    @SuppressWarnings("unchecked")
+    public <T> T readObjectCast() throws ClassNotFoundException, IOException {
+        return (T) super.readObject();
+    }
+
+    /**
+     * Rejects the specified classes for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param classes Classes to reject
-     * @return this object
+     * @param classes Classes to reject.
+     * @return this instance.
      */
     public ValidatingObjectInputStream reject(final Class<?>... classes) {
-        Stream.of(classes).map(c -> new FullClassNameMatcher(c.getName())).forEach(rejectMatchers::add);
+        predicate.reject(classes);
         return this;
     }
 
     /**
-     * Reject class names where the supplied ClassNameMatcher matches for
-     * deserialization, even if they are otherwise accepted.
+     * Rejects class names where the supplied ClassNameMatcher matches for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param m the matcher to use
-     * @return this object
+     * @param matcher a class name matcher to <em>reject</em> objects.
+     * @return this instance.
      */
-    public ValidatingObjectInputStream reject(final ClassNameMatcher m) {
-        rejectMatchers.add(m);
+    public ValidatingObjectInputStream reject(final ClassNameMatcher matcher) {
+        predicate.reject(matcher);
         return this;
     }
 
     /**
-     * Reject class names that match the supplied pattern for
-     * deserialization, even if they are otherwise accepted.
+     * Rejects class names that match the supplied pattern for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param pattern standard Java regexp
-     * @return this object
+     * @param pattern a Pattern for compiled regular expression.
+     * @return this instance.
      */
     public ValidatingObjectInputStream reject(final Pattern pattern) {
-        rejectMatchers.add(new RegexpClassNameMatcher(pattern));
+        predicate.reject(pattern);
         return this;
     }
 
     /**
-     * Reject the wildcard specified classes for deserialization,
-     * even if they are otherwise accepted.
+     * Rejects the wildcard specified classes for deserialization, even if they are otherwise accepted.
+     * <p>
+     * The reject list takes precedence over the accept list.
+     * </p>
      *
-     * @param patterns Wildcard file name patterns as defined by
-     *                  {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String) FilenameUtils.wildcardMatch}
-     * @return this object
+     * @param patterns An array of wildcard file name patterns as defined by {@link org.apache.commons.io.FilenameUtils#wildcardMatch(String, String)
+     *                 FilenameUtils.wildcardMatch}
+     * @return this instance.
      */
     public ValidatingObjectInputStream reject(final String... patterns) {
-        Stream.of(patterns).map(WildcardClassNameMatcher::new).forEach(rejectMatchers::add);
+        predicate.reject(patterns);
         return this;
     }
 
@@ -201,4 +441,4 @@ protected Class<?> resolveClass(final ObjectStreamClass osc) throws IOException,
         checkClassName(osc.getName());
         return super.resolveClass(osc);
     }
-}
\ No newline at end of file
+}
diff --git a/src/site/xdoc/description.xml b/src/site/xdoc/description.xml
index 828f4240..75fdd18c 100644
--- a/src/site/xdoc/description.xml
+++ b/src/site/xdoc/description.xml
@@ -21,7 +21,6 @@ limitations under the License.
   <author email="dev@commons.apache.org">Commons Documentation Team</author>
  </properties>
   <body>
-
     <section name="User guide">
         <p>
             Commons-IO contains
@@ -32,13 +31,11 @@ limitations under the License.
             <a href="#File comparators">file comparators</a> and
             <a href="#Streams">stream implementations</a>.
         </p>
-
         <p>
             For a more detailed descriptions, take a look at the
             <a href="api-release/index.html">Javadocs</a>.
         </p>
     </section>
-
     <section name="Utility classes">
         <subsection name="IOUtils">
             <p>
@@ -63,11 +60,9 @@ limitations under the License.
  } finally {
    in.close();
  }</source>
-
             <p>
                 With the IOUtils class, that could be done with:
             </p>
-
             <source>
  InputStream in = new URL( "https://commons.apache.org" ).openStream();
  try {
@@ -75,7 +70,6 @@ limitations under the License.
  } finally {
    IOUtils.closeQuietly(in);
  }</source>
-
             <p>
                 In certain application domains, such IO operations are
                 common, and this class can save a great deal of time. And you can
@@ -87,9 +81,7 @@ limitations under the License.
                 Using the above technique to read a 1GB file would result in an
                 attempt to create a 1GB String object!
             </p>
-
         </subsection>
-
         <subsection name="FileUtils">
             <p>
                 The <a href="apidocs/index.html?org/apache/commons/io/FileUtils.html">FileUtils</a>
@@ -136,9 +128,7 @@ limitations under the License.
             <source>
  long freeSpace = FileSystemUtils.freeSpace("C:/");</source>
         </subsection>
-
     </section>
-
     <section name="Endian classes">
         <p>
             Different computer architectures adopt different
@@ -148,33 +138,26 @@ limitations under the License.
             subsequent bytes at higher addresses. For "Big Endian"
             architectures (eg Motorola), the situation is reversed.
         </p>
-
         <p>
-        There are two classes in this package of relevance:
+          There are two classes in this package of relevance:
         </p>
-
         <ul>
            <li>
            The <a href="apidocs/index.html?org/apache/commons/io/EndianUtils.html">EndianUtils</a>
            class contains static methods for swapping the Endian-ness
            of Java primitives and streams.
            </li>
-
            <li>
            The <a href="apidocs/index.html?org/apache/commons/io/input/SwappedDataInputStream.html">SwappedDataInputStream</a>
            class is an implementation of the <code>DataInput</code> interface. With
            this, one can read data from files of non-native Endian-ness.
            </li>
         </ul>
-
         <p>
             For more information, see
-            <a
-                href="http://www.cs.umass.edu/~verts/cs32/endian.html">http://www.cs.umass.edu/~verts/cs32/endian.html</a>
+            <a href="http://www.cs.umass.edu/~verts/cs32/endian.html">http://www.cs.umass.edu/~verts/cs32/endian.html</a>
          </p>
-
     </section>
-
     <section name="Line iterator">
         <p>
             The <code>org.apache.commons.io.LineIterator</code> class
@@ -194,7 +177,6 @@ limitations under the License.
    LineIterator.closeQuietly(iterator);
  }</source>
     </section>
-
     <section name="File filters">
         <p>
             The <code>org.apache.commons.io.filefilter</code>
@@ -212,10 +194,9 @@ limitations under the License.
         <p>
             See the
             <a href="apidocs/index.html?org/apache/commons/io/filefilter/package-summary.html">filefilter</a>
-            package javadoc for more details.
+            package Javadoc for more details.
         </p>
     </section>
-
     <section name="File comparators">
         <p>
             The <code>org.apache.commons.io.comparator</code>
@@ -227,10 +208,60 @@ limitations under the License.
         <p>
             See the
             <a href="apidocs/index.html?org/apache/commons/io/comparator/package-summary.html">comparator</a>
-            package javadoc for more details.
+            package Javadoc for more details.
         </p>
     </section>
-
+    <section name="Safe Deserialization">
+      <p>
+        You can safely deserialize any input using a <a href="apidocs/index.html?org/apache/commons/io/serialization/ValidatingObjectInputStream.html">ValidatingObjectInputStream</a>.
+      </p>
+      <p>
+        Here is the only way to safely read a <code>HashMap</code> of <code>String</code> keys and <code>Integer</code> values:
+      </p>
+      <source>
+        ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()
+          .setPath(Paths.get("MyFile.ser"))
+          .get();
+        vois.accept(HashMap.class, Number.class, Integer.class);
+        HashMap&lt;String, Integer&gt; map2 = (HashMap&lt;String, Integer&gt;) vois.readObject();
+      </source>
+      <p>
+        Here is an example that performs a roundtrip:
+      </p>
+      <source>
+        // Data
+        final HashMap&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();
+        map1.put("1", 1);
+        // Write
+        final byte[] byteArray;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                final ObjectOutputStream oos = new ObjectOutputStream(baos)) {
+            oos.writeObject(map1);
+            oos.flush();
+            byteArray = baos.toByteArray();
+        }
+        // Read
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder().setInputStream(bais).get()) {
+            // String.class is automatically accepted
+            vois.accept(HashMap.class, Number.class, Integer.class);
+            final HashMap&lt;String, Integer&lt; map2 = (HashMap&lt;String, Integer&gt;) vois.readObject();
+            assertEquals(map1, map2);
+        }
+        // Reusing a configuration
+        final ObjectStreamClassPredicate predicate = new ObjectStreamClassPredicate()
+                .accept(HashMap.class, Number.class, Integer.class);
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()
+                        .setPredicate(predicate)
+                        .setInputStream(bais)
+                        .get()) {
+            // String.class is automatically accepted
+            final HashMap&lt;String, Integer&lt; map2 = (HashMap&lt;String, Integer&lt;) vois.readObject();
+            assertEquals(map1, map2);
+        }
+      </source>
+    </section>
     <section name="Streams">
         <p>
             The <code>org.apache.commons.io.input</code> and
@@ -250,10 +281,8 @@ limitations under the License.
             See the
             <a href="apidocs/index.html?org/apache/commons/io/input/package-summary.html">input</a> or
             <a href="apidocs/index.html?org/apache/commons/io/output/package-summary.html">output</a>
-            package javadoc for more details.
+            package Javadoc for more details.
         </p>
     </section>
-
   </body>
-
 </document>
diff --git a/src/site/xdoc/download_io.xml b/src/site/xdoc/download_io.xml
index 02445fe0..812feb53 100644
--- a/src/site/xdoc/download_io.xml
+++ b/src/site/xdoc/download_io.xml
@@ -113,32 +113,32 @@ limitations under the License.
       </p>
     </subsection>
     </section>
-    <section name="Apache Commons IO 2.15.0 (requires Java 8)">
+    <section name="Apache Commons IO 2.18.0 (requires Java 8)">
       <subsection name="Binaries">
         <table>
           <tr>
-              <td><a href="[preferred]/commons/io/binaries/commons-io-2.15.0-bin.tar.gz">commons-io-2.15.0-bin.tar.gz</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.15.0-bin.tar.gz.sha512">sha512</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.15.0-bin.tar.gz.asc">pgp</a></td>
+              <td><a href="[preferred]/commons/io/binaries/commons-io-2.18.0-bin.tar.gz">commons-io-2.18.0-bin.tar.gz</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.18.0-bin.tar.gz.sha512">sha512</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.18.0-bin.tar.gz.asc">pgp</a></td>
           </tr>
           <tr>
-              <td><a href="[preferred]/commons/io/binaries/commons-io-2.15.0-bin.zip">commons-io-2.15.0-bin.zip</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.15.0-bin.zip.sha512">sha512</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.15.0-bin.zip.asc">pgp</a></td>
+              <td><a href="[preferred]/commons/io/binaries/commons-io-2.18.0-bin.zip">commons-io-2.18.0-bin.zip</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.18.0-bin.zip.sha512">sha512</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/binaries/commons-io-2.18.0-bin.zip.asc">pgp</a></td>
           </tr>
         </table>
       </subsection>
       <subsection name="Source">
         <table>
           <tr>
-              <td><a href="[preferred]/commons/io/source/commons-io-2.15.0-src.tar.gz">commons-io-2.15.0-src.tar.gz</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.15.0-src.tar.gz.sha512">sha512</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.15.0-src.tar.gz.asc">pgp</a></td>
+              <td><a href="[preferred]/commons/io/source/commons-io-2.18.0-src.tar.gz">commons-io-2.18.0-src.tar.gz</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.18.0-src.tar.gz.sha512">sha512</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.18.0-src.tar.gz.asc">pgp</a></td>
           </tr>
           <tr>
-              <td><a href="[preferred]/commons/io/source/commons-io-2.15.0-src.zip">commons-io-2.15.0-src.zip</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.15.0-src.zip.sha512">sha512</a></td>
-              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.15.0-src.zip.asc">pgp</a></td>
+              <td><a href="[preferred]/commons/io/source/commons-io-2.18.0-src.zip">commons-io-2.18.0-src.zip</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.18.0-src.zip.sha512">sha512</a></td>
+              <td><a href="https://downloads.apache.org/commons/io/source/commons-io-2.18.0-src.zip.asc">pgp</a></td>
           </tr>
         </table>
       </subsection>
diff --git a/src/site/xdoc/index.xml b/src/site/xdoc/index.xml
index faecfc29..6b560861 100644
--- a/src/site/xdoc/index.xml
+++ b/src/site/xdoc/index.xml
@@ -21,79 +21,76 @@ limitations under the License.
     <author email="dev@commons.apache.org">Commons Documentation Team</author>
   </properties>
   <body>
-    <!-- ================================================== -->
     <section name="Apache Commons IO">
       <p>
         Apache Commons IO is a library of utilities to assist with developing IO functionality.
       </p>
       <p>
-        There are six main areas included:
+        Main areas include:
       </p>
       <ul>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/package-summary.html">io</a>
+          <a href="apidocs/org/apache/commons/io/package-summary.html">io</a>
           - This package defines utility classes for working with streams, readers, writers and files.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/build/package-summary.html">build</a>
+          <a href="apidocs/org/apache/commons/io/build/package-summary.html">build</a>
           - This package provides classes to implement IO builders.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/charset/package-summary.html">charset</a>
+          <a href="apidocs/org/apache/commons/io/charset/package-summary.html">charset</a>
           - This package provides classes to work with code from <code>java.nio.charset</code>.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/comparator/package-summary.html">comparator</a>
+          <a href="apidocs/org/apache/commons/io/comparator/package-summary.html">comparator</a>
           - This package provides various Comparator implementations for Files and Paths.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/file/package-summary.html">file</a>
+          <a href="apidocs/org/apache/commons/io/file/package-summary.html">file</a>
           - This package provides extensions in the realm of java.nio.file.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/file/attribute/package-summary.html">file.attribute</a>
+          <a href="apidocs/org/apache/commons/io/file/attribute/package-summary.html">file.attribute</a>
           - This package provides help using <code>java.nio.file.attribute</code> types.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/file/spi/package-summary.html">file SPI</a>
+          <a href="apidocs/org/apache/commons/io/file/spi/package-summary.html">file SPI</a>
           - This package provides extensions in the realm of <code>java.nio.file.spi</code>.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/filefilter/package-summary.html">filefilter</a>
+          <a href="apidocs/org/apache/commons/io/filefilter/package-summary.html">filefilter</a>
           - This package defines an interface (IOFileFilter) that combines both FileFilter and FilenameFilter.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/function/package-summary.html">function</a>
+          <a href="apidocs/org/apache/commons/io/function/package-summary.html">function</a>
           - This package defines IO-only related functional interfaces for lambda expressions and method references.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/input/package-summary.html">input</a>
+          <a href="apidocs/org/apache/commons/io/input/package-summary.html">input</a>
           - This package provides implementations of input classes, such as InputStream and Reader.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/input/buffer/package-summary.html">input.buffer</a>
+          <a href="apidocs/org/apache/commons/io/input/buffer/package-summary.html">input.buffer</a>
           - This package provides implementations of buffered input classes, such as CircularBufferInputStream and PeekableInputStream.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/monitor/package-summary.html">monitor</a>
+          <a href="apidocs/org/apache/commons/io/monitor/package-summary.html">monitor</a>
           - This package provides a component for monitoring file system events (directory and file create, update and delete events).
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/output/package-summary.html">output</a>
+          <a href="apidocs/org/apache/commons/io/output/package-summary.html">output</a>
           - This package provides implementations of output classes, such as OutputStream and Writer.
         </li>
         <li>
-          <a href="apidocs/index.html?org/apache/commons/io/serialization/package-summary.html">serialization</a>
+          <a href="apidocs/org/apache/commons/io/serialization/package-summary.html">serialization</a>
           - This package provides a framework for controlling the deserialization of classes.
         </li>
       </ul>
     </section>
-    <!-- ================================================== -->
     <section name="Releases">
-
       <subsection name="Latest Release (Java 8 and up)">
         <p>
-          Commons IO 2.13.0 requires a minimum of Java 8 -
+          Commons IO requires a minimum of Java 8 -
           <a href="https://commons.apache.org/io/download_io.cgi">Download now</a>
           .
         </p>
@@ -105,7 +102,6 @@ limitations under the License.
           .
         </p>
       </subsection>
-
       <subsection name="Previous Releases">
         <p>
           See the
@@ -118,15 +114,13 @@ limitations under the License.
           The Java platform requirements are:
         </p>
         <ul>
-          <li>Version 2.7 and up requires Java 8.</li>
-          <li>Version 2.6 requires Java 7.</li>
-          <li>Version 2.3 through 2.5 requires Java 6.</li>
-          <li>Version 2.2 requires Java 5.</li>
+          <li>Version 2.7 and up requires Java 8 or above.</li>
+          <li>Version 2.6 requires Java 7 or above.</li>
+          <li>Version 2.3 through 2.5 requires Java 6 or above.</li>
+          <li>Version 2.2 requires Java 5 or above.</li>
         </ul>
       </subsection>
-
     </section>
-    <!-- ================================================== -->
     <section name="Support">
       <p>
         The
@@ -144,6 +138,5 @@ limitations under the License.
         Please read the instructions carefully to submit a useful bug report or enhancement request.
       </p>
     </section>
-    <!-- ================================================== -->
   </body>
 </document>
diff --git a/src/test/java/org/apache/commons/io/AbstractFileUtilsDeleteDirectoryTest.java b/src/test/java/org/apache/commons/io/AbstractFileUtilsDeleteDirectoryTest.java
index da77488c..1ef6dad8 100644
--- a/src/test/java/org/apache/commons/io/AbstractFileUtilsDeleteDirectoryTest.java
+++ b/src/test/java/org/apache/commons/io/AbstractFileUtilsDeleteDirectoryTest.java
@@ -42,7 +42,7 @@ public void testDeleteDirectoryNullArgument() {
     }
 
     @Test
-    public void testDeleteDirWithASymlinkDir() throws Exception {
+    public void testDeleteDirWithASymbolicLinkDir2() throws Exception {
 
         final File realOuter = new File(top, "realouter");
         assertTrue(realOuter.mkdirs());
@@ -60,7 +60,7 @@ public void testDeleteDirWithASymlinkDir() throws Exception {
         assertEquals(1, randomDirectory.list().length);
 
         final File symlinkDirectory = new File(realOuter, "fakeinner");
-        assertTrue(setupSymlink(randomDirectory, symlinkDirectory));
+        Files.createSymbolicLink(symlinkDirectory.toPath(), randomDirectory.toPath());
 
         assertEquals(1, symlinkDirectory.list().length);
 
@@ -69,11 +69,11 @@ public void testDeleteDirWithASymlinkDir() throws Exception {
         assertEquals(1, top.list().length);
 
         // ensure that the contents of the symlink were NOT removed.
-        assertEquals(1, randomDirectory.list().length, "Contents of sym link should not have been removed");
+        assertEquals(1, randomDirectory.list().length, "Contents of symbolic link should not have been removed");
     }
 
     @Test
-    public void testDeleteDirWithASymlinkDir2() throws Exception {
+    public void testDeleteDirWithASymlinkDir() throws Exception {
 
         final File realOuter = new File(top, "realouter");
         assertTrue(realOuter.mkdirs());
@@ -91,7 +91,7 @@ public void testDeleteDirWithASymlinkDir2() throws Exception {
         assertEquals(1, randomDirectory.list().length);
 
         final File symlinkDirectory = new File(realOuter, "fakeinner");
-        Files.createSymbolicLink(symlinkDirectory.toPath(), randomDirectory.toPath());
+        assertTrue(setupSymlink(randomDirectory, symlinkDirectory));
 
         assertEquals(1, symlinkDirectory.list().length);
 
@@ -100,7 +100,7 @@ public void testDeleteDirWithASymlinkDir2() throws Exception {
         assertEquals(1, top.list().length);
 
         // ensure that the contents of the symlink were NOT removed.
-        assertEquals(1, randomDirectory.list().length, "Contents of sym link should not have been removed");
+        assertEquals(1, randomDirectory.list().length, "Contents of symbolic link should not have been removed");
     }
 
     @Test
@@ -135,7 +135,7 @@ public void testDeleteDirWithSymlinkFile() throws Exception {
     }
 
     @Test
-    public void testDeleteInvalidLinks() throws Exception {
+    public void testDeleteInvalidSymbolicLinks() throws Exception {
         final File aFile = new File(top, "realParentDirA");
         assertTrue(aFile.mkdir());
         final File bFile = new File(aFile, "realChildDirB");
@@ -158,7 +158,7 @@ public void testDeleteInvalidLinks() throws Exception {
     }
 
     @Test
-    public void testDeleteParentSymlink() throws Exception {
+    public void testDeleteParentSymbolicLink2() throws Exception {
         final File realParent = new File(top, "realparent");
         assertTrue(realParent.mkdirs());
 
@@ -175,23 +175,23 @@ public void testDeleteParentSymlink() throws Exception {
         assertEquals(1, randomDirectory.list().length);
 
         final File symlinkDirectory = new File(realParent, "fakeinner");
-        assertTrue(setupSymlink(randomDirectory, symlinkDirectory));
+        Files.createSymbolicLink(symlinkDirectory.toPath(), randomDirectory.toPath());
 
         assertEquals(1, symlinkDirectory.list().length);
 
         final File symlinkParentDirectory = new File(top, "fakeouter");
-        assertTrue(setupSymlink(realParent, symlinkParentDirectory));
+        Files.createSymbolicLink(symlinkParentDirectory.toPath(), realParent.toPath());
 
         // assert only the symlink is deleted, but not followed
         FileUtils.deleteDirectory(symlinkParentDirectory);
         assertEquals(2, top.list().length);
 
         // ensure that the contents of the symlink were NOT removed.
-        assertEquals(1, randomDirectory.list().length, "Contents of sym link should not have been removed");
+        assertEquals(1, randomDirectory.list().length, "Contents of symbolic link should not have been removed");
     }
 
     @Test
-    public void testDeleteParentSymlink2() throws Exception {
+    public void testDeleteParentSymlink() throws Exception {
         final File realParent = new File(top, "realparent");
         assertTrue(realParent.mkdirs());
 
@@ -208,19 +208,19 @@ public void testDeleteParentSymlink2() throws Exception {
         assertEquals(1, randomDirectory.list().length);
 
         final File symlinkDirectory = new File(realParent, "fakeinner");
-        Files.createSymbolicLink(symlinkDirectory.toPath(), randomDirectory.toPath());
+        assertTrue(setupSymlink(randomDirectory, symlinkDirectory));
 
         assertEquals(1, symlinkDirectory.list().length);
 
         final File symlinkParentDirectory = new File(top, "fakeouter");
-        Files.createSymbolicLink(symlinkParentDirectory.toPath(), realParent.toPath());
+        assertTrue(setupSymlink(realParent, symlinkParentDirectory));
 
         // assert only the symlink is deleted, but not followed
         FileUtils.deleteDirectory(symlinkParentDirectory);
         assertEquals(2, top.list().length);
 
         // ensure that the contents of the symlink were NOT removed.
-        assertEquals(1, randomDirectory.list().length, "Contents of sym link should not have been removed");
+        assertEquals(1, randomDirectory.list().length, "Contents of symbolic link should not have been removed");
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/BrokenTestFactories.java b/src/test/java/org/apache/commons/io/BrokenTestFactories.java
new file mode 100644
index 00000000..91ed8522
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/BrokenTestFactories.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.file.FileSystemNotFoundException;
+import java.util.stream.Stream;
+
+import org.apache.commons.io.input.BrokenInputStream;
+import org.apache.commons.io.input.BrokenReader;
+import org.apache.commons.io.output.BrokenOutputStream;
+import org.apache.commons.io.output.BrokenWriter;
+
+/**
+ * Factory for parameterized tests of {@link BrokenInputStream}, {@link BrokenReader}, {@link BrokenOutputStream}, and {@link BrokenWriter}.
+ */
+public class BrokenTestFactories {
+
+    /**
+     * A custom Error class.
+     */
+    public static final class CustomError extends Error {
+
+        private static final long serialVersionUID = 1L;
+
+    }
+
+    /**
+     * A custom Exception class.
+     */
+    public static final class CustomException extends Exception {
+
+        private static final long serialVersionUID = 1L;
+
+    }
+
+    /**
+     * A custom RuntimeException class.
+     */
+    public static final class CustomRuntimeException extends RuntimeException {
+
+        private static final long serialVersionUID = 1L;
+
+    }
+
+    /**
+     * Creates a stream of all throwable types used in testing broken streams.
+     *
+     * @return a stream of all throwable types used in testing broken streams.
+     */
+    public static Stream<Class<? extends Throwable>> parameters() {
+        // @formatter:off
+        return Stream.of(
+            Throwable.class,                    // JRE Root class
+            Exception.class,                    // JRE Root Exception class
+            IOException.class,                  // JRE Root IOException class
+            FileNotFoundException.class,        // JRE IOException subclass
+            RuntimeException.class,             // JRE Root RuntimeException
+            FileSystemNotFoundException.class,  // JRE RuntimeException subclass in NIO
+            IllegalArgumentException.class,     // JRE RuntimeException subclass
+            IllegalStateException.class,        // JRE RuntimeException subclass
+            Error.class,                        // JRE Error root class
+            ExceptionInInitializerError.class,  // JRE Error subclass
+            CustomException.class,              // Custom Exception subclass
+            CustomRuntimeException.class,       // Custom RuntimeException subclass
+            CustomError.class                   // Custom Error subclass
+        );
+        // @formatter:on
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/CharsetsTest.java b/src/test/java/org/apache/commons/io/CharsetsTest.java
index 7c988978..8594011d 100644
--- a/src/test/java/org/apache/commons/io/CharsetsTest.java
+++ b/src/test/java/org/apache/commons/io/CharsetsTest.java
@@ -18,6 +18,7 @@
 package org.apache.commons.io;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
@@ -36,6 +37,10 @@ public class CharsetsTest {
      * For parameterized tests.
      */
     public static final String AVAIL_CHARSETS = "org.apache.commons.io.CharsetsTest#availableCharsetsKeySet";
+    /**
+     * For parameterized tests.
+     */
+    public static final String REQUIRED_CHARSETS = "org.apache.commons.io.CharsetsTest#getRequiredCharsetNames";
 
     /**
      * For parameterized tests.
@@ -46,6 +51,15 @@ public static Set<String> availableCharsetsKeySet() {
         return Charset.availableCharsets().keySet();
     }
 
+    /**
+     * For parameterized tests.
+     *
+     * @return {@code Charset.requiredCharsets().keySet()}.
+     */
+    public static Set<String> getRequiredCharsetNames() {
+        return Charsets.requiredCharsets().keySet();
+    }
+
     @Test
     public void testIso8859_1() {
         assertEquals("ISO-8859-1", Charsets.ISO_8859_1.name());
@@ -74,10 +88,10 @@ public void testToCharset_String() {
 
     @Test
     public void testToCharset_String_Charset() {
-        assertEquals(null, Charsets.toCharset((String) null, null));
+        assertNull(Charsets.toCharset((String) null, null));
         assertEquals(Charset.defaultCharset(), Charsets.toCharset((String) null, Charset.defaultCharset()));
         assertEquals(Charset.defaultCharset(), Charsets.toCharset((Charset) null, Charset.defaultCharset()));
-        assertEquals(null, Charsets.toCharset((Charset) null, null));
+        assertNull(Charsets.toCharset((Charset) null, null));
         assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset(), Charset.defaultCharset()));
         assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8, Charset.defaultCharset()));
         assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8, null));
@@ -85,27 +99,27 @@ public void testToCharset_String_Charset() {
 
     @Test
     public void testUsAscii() {
-        assertEquals("US-ASCII", Charsets.US_ASCII.name());
+        assertEquals(StandardCharsets.US_ASCII.name(), Charsets.US_ASCII.name());
     }
 
     @Test
     public void testUtf16() {
-        assertEquals("UTF-16", Charsets.UTF_16.name());
+        assertEquals(StandardCharsets.UTF_16.name(), Charsets.UTF_16.name());
     }
 
     @Test
     public void testUtf16Be() {
-        assertEquals("UTF-16BE", Charsets.UTF_16BE.name());
+        assertEquals(StandardCharsets.UTF_16BE.name(), Charsets.UTF_16BE.name());
     }
 
     @Test
     public void testUtf16Le() {
-        assertEquals("UTF-16LE", Charsets.UTF_16LE.name());
+        assertEquals(StandardCharsets.UTF_16LE.name(), Charsets.UTF_16LE.name());
     }
 
     @Test
     public void testUtf8() {
-        assertEquals("UTF-8", Charsets.UTF_8.name());
+        assertEquals(StandardCharsets.UTF_8.name(), Charsets.UTF_8.name());
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/CopyUtilsTest.java b/src/test/java/org/apache/commons/io/CopyUtilsTest.java
index e0bab26a..aef6b996 100644
--- a/src/test/java/org/apache/commons/io/CopyUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/CopyUtilsTest.java
@@ -55,7 +55,7 @@ public class CopyUtilsTest {
     private final byte[] inData = TestUtils.generateTestData(FILE_SIZE);
 
     @Test
-    public void copy_byteArrayToOutputStream() throws Exception {
+    public void testCopy_byteArrayToOutputStream() throws Exception {
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
@@ -66,7 +66,7 @@ public void copy_byteArrayToOutputStream() throws Exception {
     }
 
     @Test
-    public void copy_byteArrayToWriter() throws Exception {
+    public void testCopy_byteArrayToWriter() throws Exception {
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
         final Writer writer = new java.io.OutputStreamWriter(out, StandardCharsets.US_ASCII);
@@ -78,9 +78,35 @@ public void copy_byteArrayToWriter() throws Exception {
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
     }
 
+    @Test
+    public void testCopy_byteArrayToWriterWithEncoding() throws Exception {
+        final String inDataStr = "data";
+        final String charsetName = StandardCharsets.UTF_8.name();
+        final StringWriter writer = new StringWriter();
+        CopyUtils.copy(inDataStr.getBytes(charsetName), writer, charsetName);
+        assertEquals(inDataStr, writer.toString());
+    }
+
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
+    @Test
+    public void testCopy_inputStreamToOutputStream() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new ThrowOnCloseInputStream(in);
+
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
+
+        final int count = CopyUtils.copy(in, out);
+
+        assertEquals(0, in.available(), "Not all bytes were read");
+        assertEquals(inData.length, baout.size(), "Sizes differ");
+        assertArrayEquals(inData, baout.toByteArray(), "Content differs");
+        assertEquals(inData.length, count);
+    }
+
     @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void copy_inputStreamToWriter() throws Exception {
+    public void testCopy_inputStreamToWriter() throws Exception {
         InputStream in = new ByteArrayInputStream(inData);
         in = new ThrowOnCloseInputStream(in);
 
@@ -97,7 +123,7 @@ public void copy_inputStreamToWriter() throws Exception {
     }
 
     @Test
-    public void copy_inputStreamToWriterWithEncoding() throws Exception {
+    public void testCopy_inputStreamToWriterWithEncoding() throws Exception {
         final String inDataStr = "data";
         final String charsetName = StandardCharsets.UTF_8.name();
         final StringWriter writer = new StringWriter();
@@ -107,141 +133,115 @@ public void copy_inputStreamToWriterWithEncoding() throws Exception {
 
     @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void copy_readerToWriter() throws Exception {
+    public void testCopy_readerToOutputStream() throws Exception {
         InputStream in = new ByteArrayInputStream(inData);
         in = new ThrowOnCloseInputStream(in);
         final Reader reader = new java.io.InputStreamReader(in, StandardCharsets.US_ASCII);
 
-        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
-        final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
-        final Writer writer = new java.io.OutputStreamWriter(out, StandardCharsets.US_ASCII);
-
-        final int count = CopyUtils.copy(reader, writer);
-        writer.flush();
-        assertEquals(inData.length, count, "The number of characters returned by copy is wrong");
-        assertEquals(inData.length, baout.size(), "Sizes differ");
-        assertArrayEquals(inData, baout.toByteArray(), "Content differs");
-    }
-
-    @Test
-    public void copy_stringToOutputStream() throws Exception {
-        final String str = new String(inData, StandardCharsets.US_ASCII);
-
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
-        CopyUtils.copy(str, out);
+        CopyUtils.copy(reader, out);
         //Note: this method *does* flush. It is equivalent to:
         //  OutputStreamWriter _out = new OutputStreamWriter(fout);
-        //  IOUtils.copy( str, _out, 4096 ); // copy( Reader, Writer, int );
+        //  IOUtils.copy( fin, _out, 4096 ); // copy( Reader, Writer, int );
         //  _out.flush();
         //  out = fout;
-        // note: we don't flush here; this IOUtils method does it for us
 
+        // Note: rely on the method to flush
         assertEquals(inData.length, baout.size(), "Sizes differ");
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
     }
 
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void copy_stringToOutputStreamString() throws Exception {
-        final String str = new String(inData, StandardCharsets.US_ASCII);
+    public void testCopy_readerToOutputStreamString() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new ThrowOnCloseInputStream(in);
+        final Reader reader = new java.io.InputStreamReader(in, StandardCharsets.US_ASCII);
 
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
-        CopyUtils.copy(str, out, StandardCharsets.US_ASCII.name());
+        CopyUtils.copy(reader, out, StandardCharsets.US_ASCII.name());
         //Note: this method *does* flush. It is equivalent to:
         //  OutputStreamWriter _out = new OutputStreamWriter(fout);
-        //  IOUtils.copy( str, _out, 4096 ); // copy( Reader, Writer, int );
+        //  IOUtils.copy( fin, _out, 4096 ); // copy( Reader, Writer, int );
         //  _out.flush();
         //  out = fout;
-        // note: we don't flush here; this IOUtils method does it for us
 
+        // Note: rely on the method to flush
         assertEquals(inData.length, baout.size(), "Sizes differ");
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
     }
 
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void copy_stringToWriter() throws Exception {
-        final String str = new String(inData, StandardCharsets.US_ASCII);
+    public void testCopy_readerToWriter() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new ThrowOnCloseInputStream(in);
+        final Reader reader = new java.io.InputStreamReader(in, StandardCharsets.US_ASCII);
 
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
         final Writer writer = new java.io.OutputStreamWriter(out, StandardCharsets.US_ASCII);
 
-        CopyUtils.copy(str, writer);
+        final int count = CopyUtils.copy(reader, writer);
         writer.flush();
-
+        assertEquals(inData.length, count, "The number of characters returned by copy is wrong");
         assertEquals(inData.length, baout.size(), "Sizes differ");
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
     }
 
     @Test
-    public void testCopy_byteArrayToWriterWithEncoding() throws Exception {
-        final String inDataStr = "data";
-        final String charsetName = StandardCharsets.UTF_8.name();
-        final StringWriter writer = new StringWriter();
-        CopyUtils.copy(inDataStr.getBytes(charsetName), writer, charsetName);
-        assertEquals(inDataStr, writer.toString());
-    }
-
-    @SuppressWarnings("resource") // 'in' is deliberately not closed
-    @Test
-    public void testCopy_inputStreamToOutputStream() throws Exception {
-        InputStream in = new ByteArrayInputStream(inData);
-        in = new ThrowOnCloseInputStream(in);
+    public void testCopy_stringToOutputStream() throws Exception {
+        final String str = new String(inData, StandardCharsets.US_ASCII);
 
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
-        final int count = CopyUtils.copy(in, out);
+        CopyUtils.copy(str, out);
+        //Note: this method *does* flush. It is equivalent to:
+        //  OutputStreamWriter _out = new OutputStreamWriter(fout);
+        //  IOUtils.copy( str, _out, 4096 ); // copy( Reader, Writer, int );
+        //  _out.flush();
+        //  out = fout;
+        // note: we don't flush here; this IOUtils method does it for us
 
-        assertEquals(0, in.available(), "Not all bytes were read");
         assertEquals(inData.length, baout.size(), "Sizes differ");
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
-        assertEquals(inData.length, count);
     }
 
-    @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void testCopy_readerToOutputStream() throws Exception {
-        InputStream in = new ByteArrayInputStream(inData);
-        in = new ThrowOnCloseInputStream(in);
-        final Reader reader = new java.io.InputStreamReader(in, StandardCharsets.US_ASCII);
+    public void testCopy_stringToOutputStreamString() throws Exception {
+        final String str = new String(inData, StandardCharsets.US_ASCII);
 
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
-        CopyUtils.copy(reader, out);
+        CopyUtils.copy(str, out, StandardCharsets.US_ASCII.name());
         //Note: this method *does* flush. It is equivalent to:
         //  OutputStreamWriter _out = new OutputStreamWriter(fout);
-        //  IOUtils.copy( fin, _out, 4096 ); // copy( Reader, Writer, int );
+        //  IOUtils.copy( str, _out, 4096 ); // copy( Reader, Writer, int );
         //  _out.flush();
         //  out = fout;
+        // note: we don't flush here; this IOUtils method does it for us
 
-        // Note: rely on the method to flush
         assertEquals(inData.length, baout.size(), "Sizes differ");
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
     }
 
-    @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void testCopy_readerToOutputStreamString() throws Exception {
-        InputStream in = new ByteArrayInputStream(inData);
-        in = new ThrowOnCloseInputStream(in);
-        final Reader reader = new java.io.InputStreamReader(in, StandardCharsets.US_ASCII);
+    public void testCopy_stringToWriter() throws Exception {
+        final String str = new String(inData, StandardCharsets.US_ASCII);
 
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final OutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
+        final Writer writer = new java.io.OutputStreamWriter(out, StandardCharsets.US_ASCII);
 
-        CopyUtils.copy(reader, out, StandardCharsets.US_ASCII.name());
-        //Note: this method *does* flush. It is equivalent to:
-        //  OutputStreamWriter _out = new OutputStreamWriter(fout);
-        //  IOUtils.copy( fin, _out, 4096 ); // copy( Reader, Writer, int );
-        //  _out.flush();
-        //  out = fout;
+        CopyUtils.copy(str, writer);
+        writer.flush();
 
-        // Note: rely on the method to flush
         assertEquals(inData.length, baout.size(), "Sizes differ");
         assertArrayEquals(inData, baout.toByteArray(), "Content differs");
     }
diff --git a/src/test/java/org/apache/commons/io/DirectoryWalkerTest.java b/src/test/java/org/apache/commons/io/DirectoryWalkerTest.java
index ccb5c110..9ddf56ce 100644
--- a/src/test/java/org/apache/commons/io/DirectoryWalkerTest.java
+++ b/src/test/java/org/apache/commons/io/DirectoryWalkerTest.java
@@ -52,17 +52,16 @@ static class TestCancelWalker extends DirectoryWalker<File> {
             this.suppressCancel = suppressCancel;
         }
 
-        /** find files. */
+        /** Find files. */
         protected List<File> find(final File startDirectory) throws IOException {
-           final List<File> results = new ArrayList<>();
-           walk(startDirectory, results);
-           return results;
+            final List<File> results = new ArrayList<>();
+            walk(startDirectory, results);
+            return results;
         }
 
         /** Handles Cancel. */
         @Override
-        protected void handleCancelled(final File startDirectory, final Collection<File> results,
-                       final CancelException cancel) throws IOException {
+        protected void handleCancelled(final File startDirectory, final Collection<File> results, final CancelException cancel) throws IOException {
             if (!suppressCancel) {
                 super.handleCancelled(startDirectory, results, cancel);
             }
@@ -116,15 +115,15 @@ protected TestFileFinder(final IOFileFilter dirFilter, final IOFileFilter fileFi
             super(dirFilter, fileFilter, depthLimit);
         }
 
-        /** find files. */
+        /** Find files. */
         protected List<File> find(final File startDirectory) {
-           final List<File> results = new ArrayList<>();
-           try {
-               walk(startDirectory, results);
-           } catch(final IOException ex) {
-               fail(ex.toString());
-           }
-           return results;
+            final List<File> results = new ArrayList<>();
+            try {
+                walk(startDirectory, results);
+            } catch (final IOException ex) {
+                fail(ex.toString());
+            }
+            return results;
         }
 
         /** Handles a directory end by adding the File to the result set. */
@@ -149,15 +148,15 @@ protected TestFileFinderString(final FileFilter filter, final int depthLimit) {
             super(filter, depthLimit);
         }
 
-        /** find files. */
+        /** Find files. */
         protected List<String> find(final File startDirectory) {
-           final List<String> results = new ArrayList<>();
-           try {
-               walk(startDirectory, results);
-           } catch(final IOException ex) {
-               fail(ex.toString());
-           }
-           return results;
+            final List<String> results = new ArrayList<>();
+            try {
+                walk(startDirectory, results);
+            } catch (final IOException ex) {
+                fail(ex.toString());
+            }
+            return results;
         }
 
         /** Handles a file by adding the File to the result set. */
@@ -181,17 +180,16 @@ static class TestMultiThreadCancelWalker extends DirectoryWalker<File> {
             this.suppressCancel = suppressCancel;
         }
 
-        /** find files. */
+        /** Find files. */
         protected List<File> find(final File startDirectory) throws IOException {
-           results = new ArrayList<>();
-           walk(startDirectory, results);
-           return results;
+            results = new ArrayList<>();
+            walk(startDirectory, results);
+            return results;
         }
 
         /** Handles Cancel. */
         @Override
-        protected void handleCancelled(final File startDirectory, final Collection<File> results,
-                       final CancelException cancel) throws IOException {
+        protected void handleCancelled(final File startDirectory, final Collection<File> results, final CancelException cancel) throws IOException {
             if (!suppressCancel) {
                 super.handleCancelled(startDirectory, results, cancel);
             }
@@ -245,7 +243,6 @@ protected boolean handleIsCancelled(final File file, final int depth, final Coll
     // Filters
     private static final IOFileFilter dirsFilter        = createNameFilter(dirs);
 
-
     private static final IOFileFilter ioFilesFilter = createNameFilter(ioFiles);
 
     private static final IOFileFilter outputFilesFilter = createNameFilter(outputFiles);
@@ -274,13 +271,13 @@ private static IOFileFilter createNameFilter(final File[] files) {
      */
     private void checkContainsFiles(final String prefix, final File[] files, final Collection<File> results) {
         for (int i = 0; i < files.length; i++) {
-            assertTrue(results.contains(files[i]), prefix + "["+i+"] " + files[i]);
+            assertTrue(results.contains(files[i]), prefix + "[" + i + "] " + files[i]);
         }
     }
 
     private void checkContainsString(final String prefix, final File[] files, final Collection<String> results) {
         for (int i = 0; i < files.length; i++) {
-            assertTrue(results.contains(files[i].toString()), prefix + "["+i+"] " + files[i]);
+            assertTrue(results.contains(files[i].toString()), prefix + "[" + i + "] " + files[i]);
         }
     }
 
@@ -325,7 +322,7 @@ public void testCancel() {
         } catch (final DirectoryWalker.CancelException cancel) {
             assertEquals(cancelName, cancel.getFile().getName(), "File:  " + cancelName);
             assertEquals(5, cancel.getDepth(), "Depth: " + cancelName);
-        } catch(final IOException ex) {
+        } catch (final IOException ex) {
             fail("IOException: " + cancelName + " " + ex);
         }
 
@@ -337,7 +334,7 @@ public void testCancel() {
         } catch (final DirectoryWalker.CancelException cancel) {
             assertEquals(cancelName, cancel.getFile().getName(), "File:  " + cancelName);
             assertEquals(3, cancel.getDepth(), "Depth: " + cancelName);
-        } catch(final IOException ex) {
+        } catch (final IOException ex) {
             fail("IOException: " + cancelName + " " + ex);
         }
 
@@ -346,7 +343,7 @@ public void testCancel() {
             final List<File> results = new TestCancelWalker(cancelName, true).find(javaDir);
             final File lastFile = results.get(results.size() - 1);
             assertEquals(cancelName, lastFile.getName(), "Suppress:  " + cancelName);
-        } catch(final IOException ex) {
+        } catch (final IOException ex) {
             fail("Suppress threw " + ex);
         }
 
@@ -365,8 +362,6 @@ public void testFilter() {
         checkContainsFiles("Output File", outputFiles, results);
     }
 
-    // ------------ Convenience Test Methods ------------------------------------
-
     /**
      * Test Filtering and limit to depth 0
      */
@@ -461,8 +456,6 @@ public void testFilterDirAndFile4() {
         checkContainsFiles("[DirAndFile4] File", ioFiles, resultFiles);
     }
 
-    // ------------ Test DirectoryWalker implementation --------------------------
-
     /**
      * Test Filtering
      */
@@ -474,8 +467,6 @@ public void testFilterString() {
         checkContainsString("Output File", outputFiles, results);
     }
 
-    // ------------ Test DirectoryWalker implementation --------------------------
-
     /**
      * test an invalid start directory
      */
@@ -487,8 +478,6 @@ public void testHandleStartDirectoryFalse() {
 
     }
 
-    // ------------ Test DirectoryWalker implementation --------------------------
-
     /**
      * Test Limiting to current directory
      */
@@ -529,7 +518,7 @@ public void testMultiThreadCancel() {
             final File last = walker.results.get(walker.results.size() - 1);
             assertEquals(cancelName, last.getName());
             assertEquals(5, cancel.getDepth(), "Depth: " + cancelName);
-        } catch(final IOException ex) {
+        } catch (final IOException ex) {
             fail("IOException: " + cancelName + " " + ex);
         }
 
@@ -542,7 +531,7 @@ public void testMultiThreadCancel() {
         } catch (final DirectoryWalker.CancelException cancel) {
             assertEquals(cancelName, cancel.getFile().getName(), "File:  " + cancelName);
             assertEquals(3, cancel.getDepth(), "Depth: " + cancelName);
-        } catch(final IOException ex) {
+        } catch (final IOException ex) {
             fail("IOException: " + cancelName + " " + ex);
         }
 
@@ -552,7 +541,7 @@ public void testMultiThreadCancel() {
             final List<File> results = walker.find(javaDir);
             final File lastFile = results.get(results.size() - 1);
             assertEquals(cancelName, lastFile.getName(), "Suppress:  " + cancelName);
-        } catch(final IOException ex) {
+        } catch (final IOException ex) {
             fail("Suppress threw " + ex);
         }
 
diff --git a/src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java b/src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java
deleted file mode 100644
index ad7337dd..00000000
--- a/src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java
+++ /dev/null
@@ -1,525 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.io;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
-
-import java.io.File;
-import java.io.FileFilter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.apache.commons.io.filefilter.FileFilterUtils;
-import org.apache.commons.io.filefilter.IOFileFilter;
-import org.apache.commons.io.filefilter.NameFileFilter;
-import org.apache.commons.io.filefilter.OrFileFilter;
-import org.junit.jupiter.api.Test;
-
-/**
- * This is used to test DirectoryWalker for correctness when using Java4 (i.e. no generics).
- *
- * @see DirectoryWalker
- */
-@SuppressWarnings({"unchecked", "rawtypes"}) // Java4
-public class DirectoryWalkerTestCaseJava4 {
-
-    /**
-     * Test DirectoryWalker implementation that finds files in a directory hierarchy
-     * applying a file filter.
-     */
-    static class TestCancelWalker extends DirectoryWalker {
-        private final String cancelFileName;
-        private final boolean suppressCancel;
-
-        TestCancelWalker(final String cancelFileName, final boolean suppressCancel) {
-            this.cancelFileName = cancelFileName;
-            this.suppressCancel = suppressCancel;
-        }
-
-        /**
-         * find files.
-         */
-        protected List find(final File startDirectory) throws IOException {
-            final List results = new ArrayList();
-            walk(startDirectory, results);
-            return results;
-        }
-
-        /**
-         * Handles Cancel.
-         */
-        @Override
-        protected void handleCancelled(final File startDirectory, final Collection results,
-                                       final CancelException cancel) throws IOException {
-            if (!suppressCancel) {
-                super.handleCancelled(startDirectory, results, cancel);
-            }
-        }
-
-        /**
-         * Handles a directory end by adding the File to the result set.
-         */
-        @Override
-        protected void handleDirectoryEnd(final File directory, final int depth, final Collection results) throws IOException {
-            results.add(directory);
-            if (cancelFileName.equals(directory.getName())) {
-                throw new CancelException(directory, depth);
-            }
-        }
-
-        /**
-         * Handles a file by adding the File to the result set.
-         */
-        @Override
-        protected void handleFile(final File file, final int depth, final Collection results) throws IOException {
-            results.add(file);
-            if (cancelFileName.equals(file.getName())) {
-                throw new CancelException(file, depth);
-            }
-        }
-    }
-    /**
-     * Test DirectoryWalker implementation that always returns false
-     * from handleDirectoryStart()
-     */
-    private static final class TestFalseFileFinder extends TestFileFinder {
-
-        protected TestFalseFileFinder(final FileFilter filter, final int depthLimit) {
-            super(filter, depthLimit);
-        }
-
-        /**
-         * Always returns false.
-         */
-        @Override
-        protected boolean handleDirectory(final File directory, final int depth, final Collection results) {
-            return false;
-        }
-    }
-    /**
-     * Test DirectoryWalker implementation that finds files in a directory hierarchy
-     * applying a file filter.
-     */
-    private static class TestFileFinder extends DirectoryWalker {
-
-        protected TestFileFinder(final FileFilter filter, final int depthLimit) {
-            super(filter, depthLimit);
-        }
-
-        protected TestFileFinder(final IOFileFilter dirFilter, final IOFileFilter fileFilter, final int depthLimit) {
-            super(dirFilter, fileFilter, depthLimit);
-        }
-
-        /**
-         * find files.
-         */
-        protected List<File> find(final File startDirectory) {
-            final List<File> results = new ArrayList<>();
-            try {
-                walk(startDirectory, results);
-            } catch (final IOException ex) {
-                fail(ex.toString());
-            }
-            return results;
-        }
-
-        /**
-         * Handles a directory end by adding the File to the result set.
-         */
-        @Override
-        protected void handleDirectoryEnd(final File directory, final int depth, final Collection results) {
-            results.add(directory);
-        }
-
-        /**
-         * Handles a file by adding the File to the result set.
-         */
-        @Override
-        protected void handleFile(final File file, final int depth, final Collection results) {
-            results.add(file);
-        }
-    }
-    /**
-     * Test DirectoryWalker implementation that finds files in a directory hierarchy
-     * applying a file filter.
-     */
-    static class TestMultiThreadCancelWalker extends DirectoryWalker {
-        private final String cancelFileName;
-        private final boolean suppressCancel;
-        private boolean cancelled;
-        public List results;
-
-        TestMultiThreadCancelWalker(final String cancelFileName, final boolean suppressCancel) {
-            this.cancelFileName = cancelFileName;
-            this.suppressCancel = suppressCancel;
-        }
-
-        /**
-         * find files.
-         */
-        protected List find(final File startDirectory) throws IOException {
-            results = new ArrayList();
-            walk(startDirectory, results);
-            return results;
-        }
-
-        /**
-         * Handles Cancel.
-         */
-        @Override
-        protected void handleCancelled(final File startDirectory, final Collection results,
-                                       final CancelException cancel) throws IOException {
-            if (!suppressCancel) {
-                super.handleCancelled(startDirectory, results, cancel);
-            }
-        }
-
-        /**
-         * Handles a directory end by adding the File to the result set.
-         */
-        @Override
-        protected void handleDirectoryEnd(final File directory, final int depth, final Collection results) throws IOException {
-            results.add(directory);
-            assertFalse(cancelled);
-            if (cancelFileName.equals(directory.getName())) {
-                cancelled = true;
-            }
-        }
-
-        /**
-         * Handles a file by adding the File to the result set.
-         */
-        @Override
-        protected void handleFile(final File file, final int depth, final Collection results) throws IOException {
-            results.add(file);
-            assertFalse(cancelled);
-            if (cancelFileName.equals(file.getName())) {
-                cancelled = true;
-            }
-        }
-
-        /**
-         * Handles Cancelled.
-         */
-        @Override
-        protected boolean handleIsCancelled(final File file, final int depth, final Collection results) throws IOException {
-            return cancelled;
-        }
-    }
-    // Directories
-    private static final File current = FileUtils.current();
-    private static final File javaDir = new File("src/main/java");
-    private static final File orgDir = new File(javaDir, "org");
-    private static final File apacheDir = new File(orgDir, "apache");
-
-    private static final File commonsDir = new File(apacheDir, "commons");
-    private static final File ioDir = new File(commonsDir, "io");
-    private static final File outputDir = new File(ioDir, "output");
-    private static final File[] dirs = {orgDir, apacheDir, commonsDir, ioDir, outputDir};
-    // Files
-    private static final File fileNameUtils = new File(ioDir, "FilenameUtils.java");
-    private static final File ioUtils = new File(ioDir, "IOUtils.java");
-
-    private static final File proxyWriter = new File(outputDir, "ProxyWriter.java");
-    private static final File nullStream = new File(outputDir, "NullOutputStream.java");
-    private static final File[] ioFiles = {fileNameUtils, ioUtils};
-    private static final File[] outputFiles = {proxyWriter, nullStream};
-    // Filters
-    private static final IOFileFilter dirsFilter = createNameFilter(dirs);
-
-    private static final IOFileFilter ioFilesFilter = createNameFilter(ioFiles);
-
-
-    private static final IOFileFilter outputFilesFilter = createNameFilter(outputFiles);
-
-    private static final IOFileFilter ioDirAndFilesFilter = new OrFileFilter(dirsFilter, ioFilesFilter);
-
-    private static final IOFileFilter dirsAndFilesFilter = new OrFileFilter(ioDirAndFilesFilter, outputFilesFilter);
-
-    // Filter to exclude SVN files
-    private static final IOFileFilter NOT_SVN = FileFilterUtils.makeSVNAware(null);
-
-    /**
-     * Create a name filter containing the names of the files
-     * in the array.
-     */
-    private static IOFileFilter createNameFilter(final File[] files) {
-        final String[] names = new String[files.length];
-        for (int i = 0; i < files.length; i++) {
-            names[i] = files[i].getName();
-        }
-        return new NameFileFilter(names);
-    }
-
-    /**
-     * Check the files in the array are in the results list.
-     */
-    private void checkContainsFiles(final String prefix, final File[] files, final Collection results) {
-        for (int i = 0; i < files.length; i++) {
-            assertTrue(results.contains(files[i]), prefix + "[" + i + "] " + files[i]);
-        }
-    }
-
-    /**
-     * Extract the directories.
-     */
-    private List directoriesOnly(final Collection<File> results) {
-        final List list = new ArrayList(results.size());
-        for (final File file : results) {
-            if (file.isDirectory()) {
-                list.add(file);
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Extract the files.
-     */
-    private List filesOnly(final Collection<File> results) {
-        final List list = new ArrayList(results.size());
-        for (final File file : results) {
-            if (file.isFile()) {
-                list.add(file);
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Test Cancel
-     * @throws IOException
-     */
-    @Test
-    public void testCancel() throws IOException {
-        String cancelName = null;
-
-        // Cancel on a file
-        try {
-            cancelName = "DirectoryWalker.java";
-            new TestCancelWalker(cancelName, false).find(javaDir);
-            fail("CancelException not thrown for '" + cancelName + "'");
-        } catch (final DirectoryWalker.CancelException cancel) {
-            assertEquals(cancelName, cancel.getFile().getName(), "File:  " + cancelName);
-            assertEquals(5, cancel.getDepth(), "Depth: " + cancelName);
-        }
-
-        // Cancel on a directory
-        try {
-            cancelName = "commons";
-            new TestCancelWalker(cancelName, false).find(javaDir);
-            fail("CancelException not thrown for '" + cancelName + "'");
-        } catch (final DirectoryWalker.CancelException cancel) {
-            assertEquals(cancelName, cancel.getFile().getName(), "File:  " + cancelName);
-            assertEquals(3, cancel.getDepth(), "Depth: " + cancelName);
-        }
-
-        // Suppress CancelException (use same file name as preceding test)
-        final List results = new TestCancelWalker(cancelName, true).find(javaDir);
-        final File lastFile = (File) results.get(results.size() - 1);
-        assertEquals(cancelName, lastFile.getName(), "Suppress:  " + cancelName);
-    }
-
-    /**
-     * Test Filtering
-     */
-    @Test
-    public void testFilter() {
-        final List<File> results = new TestFileFinder(dirsAndFilesFilter, -1).find(javaDir);
-        assertEquals(1 + dirs.length + ioFiles.length + outputFiles.length, results.size(), "Result Size");
-        assertTrue(results.contains(javaDir), "Start Dir");
-        checkContainsFiles("Dir", dirs, results);
-        checkContainsFiles("IO File", ioFiles, results);
-        checkContainsFiles("Output File", outputFiles, results);
-    }
-
-    /**
-     * Test Filtering and limit to depth 0
-     */
-    @Test
-    public void testFilterAndLimitA() {
-        final List<File> results = new TestFileFinder(NOT_SVN, 0).find(javaDir);
-        assertEquals(1, results.size(), "[A] Result Size");
-        assertTrue(results.contains(javaDir), "[A] Start Dir");
-    }
-
-    /**
-     * Test Filtering and limit to depth 1
-     */
-    @Test
-    public void testFilterAndLimitB() {
-        final List<File> results = new TestFileFinder(NOT_SVN, 1).find(javaDir);
-        assertEquals(2, results.size(), "[B] Result Size");
-        assertTrue(results.contains(javaDir), "[B] Start Dir");
-        assertTrue(results.contains(orgDir), "[B] Org Dir");
-    }
-
-    // ------------ Convenience Test Methods ------------------------------------
-
-    /**
-     * Test Filtering and limit to depth 3
-     */
-    @Test
-    public void testFilterAndLimitC() {
-        final List<File> results = new TestFileFinder(NOT_SVN, 3).find(javaDir);
-        assertEquals(4, results.size(), "[C] Result Size");
-        assertTrue(results.contains(javaDir), "[C] Start Dir");
-        assertTrue(results.contains(orgDir), "[C] Org Dir");
-        assertTrue(results.contains(apacheDir), "[C] Apache Dir");
-        assertTrue(results.contains(commonsDir), "[C] Commons Dir");
-    }
-
-    /**
-     * Test Filtering and limit to depth 5
-     */
-    @Test
-    public void testFilterAndLimitD() {
-        final List<File> results = new TestFileFinder(dirsAndFilesFilter, 5).find(javaDir);
-        assertEquals(1 + dirs.length + ioFiles.length, results.size(), "[D] Result Size");
-        assertTrue(results.contains(javaDir), "[D] Start Dir");
-        checkContainsFiles("[D] Dir", dirs, results);
-        checkContainsFiles("[D] File", ioFiles, results);
-    }
-
-    /**
-     * Test separate dir and file filters
-     */
-    @Test
-    public void testFilterDirAndFile1() {
-        final List<File> results = new TestFileFinder(dirsFilter, ioFilesFilter, -1).find(javaDir);
-        assertEquals(1 + dirs.length + ioFiles.length, results.size(), "[DirAndFile1] Result Size");
-        assertTrue(results.contains(javaDir), "[DirAndFile1] Start Dir");
-        checkContainsFiles("[DirAndFile1] Dir", dirs, results);
-        checkContainsFiles("[DirAndFile1] File", ioFiles, results);
-    }
-
-    /**
-     * Test separate dir and file filters
-     */
-    @Test
-    public void testFilterDirAndFile2() {
-        final List<File> results = new TestFileFinder(null, null, -1).find(javaDir);
-        assertTrue(results.size() > 1 + dirs.length + ioFiles.length, "[DirAndFile2] Result Size");
-        assertTrue(results.contains(javaDir), "[DirAndFile2] Start Dir");
-        checkContainsFiles("[DirAndFile2] Dir", dirs, results);
-        checkContainsFiles("[DirAndFile2] File", ioFiles, results);
-    }
-
-    /**
-     * Test separate dir and file filters
-     */
-    @Test
-    public void testFilterDirAndFile3() {
-        final List<File> results = new TestFileFinder(dirsFilter, null, -1).find(javaDir);
-        final List resultDirs = directoriesOnly(results);
-        assertEquals(1 + dirs.length, resultDirs.size(), "[DirAndFile3] Result Size");
-        assertTrue(results.contains(javaDir), "[DirAndFile3] Start Dir");
-        checkContainsFiles("[DirAndFile3] Dir", dirs, resultDirs);
-    }
-
-    /**
-     * Test separate dir and file filters
-     */
-    @Test
-    public void testFilterDirAndFile4() {
-        final List<File> results = new TestFileFinder(null, ioFilesFilter, -1).find(javaDir);
-        final List resultFiles = filesOnly(results);
-        assertEquals(ioFiles.length, resultFiles.size(), "[DirAndFile4] Result Size");
-        assertTrue(results.contains(javaDir), "[DirAndFile4] Start Dir");
-        checkContainsFiles("[DirAndFile4] File", ioFiles, resultFiles);
-    }
-
-    /**
-     * test an invalid start directory
-     */
-    @Test
-    public void testHandleStartDirectoryFalse() {
-
-        final List<File> results = new TestFalseFileFinder(null, -1).find(current);
-        assertEquals(0, results.size(), "Result Size");
-
-    }
-
-    /**
-     * Test Limiting to current directory
-     */
-    @Test
-    public void testLimitToCurrent() {
-        final List<File> results = new TestFileFinder(null, 0).find(current);
-        assertEquals(1, results.size(), "Result Size");
-        assertTrue(results.contains(FileUtils.current()), "Current Dir");
-    }
-
-    /**
-     * Test an invalid start directory
-     */
-    @Test
-    public void testMissingStartDirectory() {
-
-        // TODO is this what we want with invalid directory?
-        final File invalidDir = new File("invalid-dir");
-        final List<File> results = new TestFileFinder(null, -1).find(invalidDir);
-        assertEquals(1, results.size(), "Result Size");
-        assertTrue(results.contains(invalidDir), "Current Dir");
-
-        assertThrows(NullPointerException.class, () -> new TestFileFinder(null, -1).find(null));
-    }
-
-    /**
-     * Test Cancel
-     * @throws IOException
-     */
-    @Test
-    public void testMultiThreadCancel() throws IOException {
-        String cancelName = "DirectoryWalker.java";
-        TestMultiThreadCancelWalker walker = new TestMultiThreadCancelWalker(cancelName, false);
-        // Cancel on a file
-        try {
-            walker.find(javaDir);
-            fail("CancelException not thrown for '" + cancelName + "'");
-        } catch (final DirectoryWalker.CancelException cancel) {
-            final File last = (File) walker.results.get(walker.results.size() - 1);
-            assertEquals(cancelName, last.getName());
-            assertEquals(5, cancel.getDepth(), "Depth: " + cancelName);
-        }
-
-        // Cancel on a directory
-        try {
-            cancelName = "commons";
-            walker = new TestMultiThreadCancelWalker(cancelName, false);
-            walker.find(javaDir);
-            fail("CancelException not thrown for '" + cancelName + "'");
-        } catch (final DirectoryWalker.CancelException cancel) {
-            assertEquals(cancelName, cancel.getFile().getName(), "File:  " + cancelName);
-            assertEquals(3, cancel.getDepth(), "Depth: " + cancelName);
-        }
-
-        // Suppress CancelException (use same file name as preceding test)
-        walker = new TestMultiThreadCancelWalker(cancelName, true);
-        final List results = walker.find(javaDir);
-        final File lastFile = (File) results.get(results.size() - 1);
-        assertEquals(cancelName, lastFile.getName(), "Suppress:  " + cancelName);
-
-    }
-
-}
diff --git a/src/test/java/org/apache/commons/io/EndianUtilsTest.java b/src/test/java/org/apache/commons/io/EndianUtilsTest.java
index 4247644d..54abb414 100644
--- a/src/test/java/org/apache/commons/io/EndianUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/EndianUtilsTest.java
@@ -43,6 +43,20 @@ public void testEOFException() {
         assertThrows(EOFException.class, () -> EndianUtils.readSwappedDouble(input));
     }
 
+    @Test
+    public void testInvalidOffset() throws IOException {
+        final byte[] bytes = {};
+
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.readSwappedInteger(bytes, 0));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.readSwappedLong(bytes, 0));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.readSwappedShort(bytes, 0));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.readSwappedUnsignedInteger(bytes, 0));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.readSwappedUnsignedShort(bytes, 0));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.writeSwappedInteger(bytes, 0, 0));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.writeSwappedLong(bytes, 0, 0L));
+        assertThrows(IllegalArgumentException.class, () -> EndianUtils.writeSwappedShort(bytes, 0, (short) 0));
+    }
+
     @Test
     public void testReadSwappedDouble() throws IOException {
         final byte[] bytes = { 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01 };
@@ -193,7 +207,7 @@ public void testSymmetryOfLong() {
     // tests #IO-117
     @Test
     public void testUnsignedOverrun() throws Exception {
-        final byte[] target = { 0, 0, 0, (byte)0x80 };
+        final byte[] target = { 0, 0, 0, (byte) 0x80 };
         final long expected = 0x80000000L;
 
         long actual = EndianUtils.readSwappedUnsignedInteger(target, 0);
diff --git a/src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java b/src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java
index b5074515..55aa26b3 100644
--- a/src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java
+++ b/src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java
@@ -48,7 +48,7 @@ public class FileCleaningTrackerTest extends AbstractTempDirTest {
     private File testFile;
     private Path testPath;
 
-    private FileCleaningTracker theInstance;
+    private FileCleaningTracker fileCleaningTracker;
 
     RandomAccessFile createRandomAccessFile() throws FileNotFoundException {
         return RandomAccessFileMode.READ_WRITE.create(testFile);
@@ -78,14 +78,14 @@ private void pauseForDeleteToComplete(Path file) {
     public void setUp() {
         testFile = new File(tempDirFile, "file-test.txt");
         testPath = testFile.toPath();
-        theInstance = newInstance();
+        fileCleaningTracker = newInstance();
     }
 
     private String showFailures() {
-        if (theInstance.deleteFailures.size() == 1) {
-            return "[Delete Failed: " + theInstance.deleteFailures.get(0) + "]";
+        if (fileCleaningTracker.deleteFailures.size() == 1) {
+            return "[Delete Failed: " + fileCleaningTracker.deleteFailures.get(0) + "]";
         }
-        return "[Delete Failures: " + theInstance.deleteFailures.size() + "]";
+        return "[Delete Failures: " + fileCleaningTracker.deleteFailures.size() + "]";
     }
 
     @AfterEach
@@ -99,16 +99,16 @@ public void tearDown() {
          * not.
          */
         {
-            if (theInstance != null) {
-                theInstance.q = new ReferenceQueue<>();
-                theInstance.trackers.clear();
-                theInstance.deleteFailures.clear();
-                theInstance.exitWhenFinished = false;
-                theInstance.reaper = null;
+            if (fileCleaningTracker != null) {
+                fileCleaningTracker.q = new ReferenceQueue<>();
+                fileCleaningTracker.trackers.clear();
+                fileCleaningTracker.deleteFailures.clear();
+                fileCleaningTracker.exitWhenFinished = false;
+                fileCleaningTracker.reaper = null;
             }
         }
 
-        theInstance = null;
+        fileCleaningTracker = null;
     }
 
     @Test
@@ -125,16 +125,16 @@ public void testFileCleanerDirectory_ForceStrategy_FileSource() throws Exception
         assertTrue(tempDirFile.exists());
 
         Object obj = new Object();
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(tempDirFile, obj, FileDeleteStrategy.FORCE);
-        assertEquals(1, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(tempDirFile, obj, FileDeleteStrategy.FORCE);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
 
         obj = null;
 
         waitUntilTrackCount();
         pauseForDeleteToComplete(testFile.getParentFile());
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertFalse(new File(testFile.getPath()).exists(), showFailures());
         assertFalse(testFile.getParentFile().exists(), showFailures());
     }
@@ -153,16 +153,16 @@ public void testFileCleanerDirectory_ForceStrategy_PathSource() throws Exception
         assertTrue(Files.exists(tempDirPath));
 
         Object obj = new Object();
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(tempDirPath, obj, FileDeleteStrategy.FORCE);
-        assertEquals(1, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(tempDirPath, obj, FileDeleteStrategy.FORCE);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
 
         obj = null;
 
         waitUntilTrackCount();
         pauseForDeleteToComplete(testPath.getParent());
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertFalse(Files.exists(testPath), showFailures());
         assertFalse(Files.exists(testPath.getParent()), showFailures());
     }
@@ -174,15 +174,15 @@ public void testFileCleanerDirectory_NullStrategy() throws Exception {
         assertTrue(tempDirFile.exists());
 
         Object obj = new Object();
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(tempDirFile, obj, null);
-        assertEquals(1, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(tempDirFile, obj, null);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
 
         obj = null;
 
         waitUntilTrackCount();
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertTrue(testFile.exists());  // not deleted, as dir not empty
         assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty
     }
@@ -194,15 +194,15 @@ public void testFileCleanerDirectoryFileSource() throws Exception {
         assertTrue(tempDirFile.exists());
 
         Object obj = new Object();
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(tempDirFile, obj);
-        assertEquals(1, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(tempDirFile, obj);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
 
         obj = null;
 
         waitUntilTrackCount();
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertTrue(testFile.exists());  // not deleted, as dir not empty
         assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty
     }
@@ -214,32 +214,32 @@ public void testFileCleanerDirectoryPathSource() throws Exception {
         assertTrue(Files.exists(tempDirPath));
 
         Object obj = new Object();
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(tempDirPath, obj);
-        assertEquals(1, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(tempDirPath, obj);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
 
         obj = null;
 
         waitUntilTrackCount();
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertTrue(Files.exists(testPath));  // not deleted, as dir not empty
         assertTrue(Files.exists(testPath.getParent()));  // not deleted, as dir not empty
     }
 
     @Test
     public void testFileCleanerExitWhenFinished_NoTrackAfter() {
-        assertFalse(theInstance.exitWhenFinished);
-        theInstance.exitWhenFinished();
-        assertTrue(theInstance.exitWhenFinished);
-        assertNull(theInstance.reaper);
+        assertFalse(fileCleaningTracker.exitWhenFinished);
+        fileCleaningTracker.exitWhenFinished();
+        assertTrue(fileCleaningTracker.exitWhenFinished);
+        assertNull(fileCleaningTracker.reaper);
 
         final String path = testFile.getPath();
         final Object marker = new Object();
 
-        assertThrows(IllegalStateException.class, () -> theInstance.track(path, marker));
-        assertTrue(theInstance.exitWhenFinished);
-        assertNull(theInstance.reaper);
+        assertThrows(IllegalStateException.class, () -> fileCleaningTracker.track(path, marker));
+        assertTrue(fileCleaningTracker.exitWhenFinished);
+        assertNull(fileCleaningTracker.reaper);
     }
 
     @Test
@@ -252,16 +252,16 @@ public void testFileCleanerExitWhenFinished1() throws Exception {
         RandomAccessFile raf = createRandomAccessFile();
         assertTrue(testFile.exists(), "2-testFile exists");
 
-        assertEquals(0, theInstance.getTrackCount(), "3-Track Count");
-        theInstance.track(path, raf);
-        assertEquals(1, theInstance.getTrackCount(), "4-Track Count");
-        assertFalse(theInstance.exitWhenFinished, "5-exitWhenFinished");
-        assertTrue(theInstance.reaper.isAlive(), "6-reaper.isAlive");
+        assertEquals(0, fileCleaningTracker.getTrackCount(), "3-Track Count");
+        fileCleaningTracker.track(path, raf);
+        assertEquals(1, fileCleaningTracker.getTrackCount(), "4-Track Count");
+        assertFalse(fileCleaningTracker.exitWhenFinished, "5-exitWhenFinished");
+        assertTrue(fileCleaningTracker.reaper.isAlive(), "6-reaper.isAlive");
 
-        assertFalse(theInstance.exitWhenFinished, "7-exitWhenFinished");
-        theInstance.exitWhenFinished();
-        assertTrue(theInstance.exitWhenFinished, "8-exitWhenFinished");
-        assertTrue(theInstance.reaper.isAlive(), "9-reaper.isAlive");
+        assertFalse(fileCleaningTracker.exitWhenFinished, "7-exitWhenFinished");
+        fileCleaningTracker.exitWhenFinished();
+        assertTrue(fileCleaningTracker.exitWhenFinished, "8-exitWhenFinished");
+        assertTrue(fileCleaningTracker.reaper.isAlive(), "9-reaper.isAlive");
 
         raf.close();
         testFile = null;
@@ -270,10 +270,10 @@ public void testFileCleanerExitWhenFinished1() throws Exception {
         waitUntilTrackCount();
         pauseForDeleteToComplete(new File(path));
 
-        assertEquals(0, theInstance.getTrackCount(), "10-Track Count");
+        assertEquals(0, fileCleaningTracker.getTrackCount(), "10-Track Count");
         assertFalse(new File(path).exists(), "11-testFile exists " + showFailures());
-        assertTrue(theInstance.exitWhenFinished, "12-exitWhenFinished");
-        assertFalse(theInstance.reaper.isAlive(), "13-reaper.isAlive");
+        assertTrue(fileCleaningTracker.exitWhenFinished, "12-exitWhenFinished");
+        assertFalse(fileCleaningTracker.reaper.isAlive(), "13-reaper.isAlive");
     }
 
     @Test
@@ -284,11 +284,11 @@ public void testFileCleanerExitWhenFinished2() throws Exception {
         RandomAccessFile r = createRandomAccessFile();
         assertTrue(testFile.exists());
 
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(path, r);
-        assertEquals(1, theInstance.getTrackCount());
-        assertFalse(theInstance.exitWhenFinished);
-        assertTrue(theInstance.reaper.isAlive());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(path, r);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
+        assertFalse(fileCleaningTracker.exitWhenFinished);
+        assertTrue(fileCleaningTracker.reaper.isAlive());
 
         r.close();
         testFile = null;
@@ -297,32 +297,32 @@ public void testFileCleanerExitWhenFinished2() throws Exception {
         waitUntilTrackCount();
         pauseForDeleteToComplete(new File(path));
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertFalse(new File(path).exists(), showFailures());
-        assertFalse(theInstance.exitWhenFinished);
-        assertTrue(theInstance.reaper.isAlive());
+        assertFalse(fileCleaningTracker.exitWhenFinished);
+        assertTrue(fileCleaningTracker.reaper.isAlive());
 
-        assertFalse(theInstance.exitWhenFinished);
-        theInstance.exitWhenFinished();
-        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {
+        assertFalse(fileCleaningTracker.exitWhenFinished);
+        fileCleaningTracker.exitWhenFinished();
+        for (int i = 0; i < 20 && fileCleaningTracker.reaper.isAlive(); i++) {
             TestUtils.sleep(500L);  // allow reaper thread to die
         }
-        assertTrue(theInstance.exitWhenFinished);
-        assertFalse(theInstance.reaper.isAlive());
+        assertTrue(fileCleaningTracker.exitWhenFinished);
+        assertFalse(fileCleaningTracker.reaper.isAlive());
     }
 
     @Test
     public void testFileCleanerExitWhenFinishedFirst() throws Exception {
-        assertFalse(theInstance.exitWhenFinished);
-        theInstance.exitWhenFinished();
-        assertTrue(theInstance.exitWhenFinished);
-        assertNull(theInstance.reaper);
+        assertFalse(fileCleaningTracker.exitWhenFinished);
+        fileCleaningTracker.exitWhenFinished();
+        assertTrue(fileCleaningTracker.exitWhenFinished);
+        assertNull(fileCleaningTracker.reaper);
 
         waitUntilTrackCount();
 
-        assertEquals(0, theInstance.getTrackCount());
-        assertTrue(theInstance.exitWhenFinished);
-        assertNull(theInstance.reaper);
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        assertTrue(fileCleaningTracker.exitWhenFinished);
+        assertNull(fileCleaningTracker.reaper);
     }
 
     @Test
@@ -330,40 +330,40 @@ public void testFileCleanerFile() throws Exception {
         final String path = testFile.getPath();
 
         assertFalse(testFile.exists());
-        RandomAccessFile r = createRandomAccessFile();
+        RandomAccessFile raf = createRandomAccessFile();
         assertTrue(testFile.exists());
 
-        assertEquals(0, theInstance.getTrackCount());
-        theInstance.track(path, r);
-        assertEquals(1, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
+        fileCleaningTracker.track(path, raf);
+        assertEquals(1, fileCleaningTracker.getTrackCount());
 
-        r.close();
+        raf.close();
         testFile = null;
-        r = null;
+        raf = null;
 
         waitUntilTrackCount();
         pauseForDeleteToComplete(new File(path));
 
-        assertEquals(0, theInstance.getTrackCount());
+        assertEquals(0, fileCleaningTracker.getTrackCount());
         assertFalse(new File(path).exists(), showFailures());
     }
     @Test
     public void testFileCleanerNull() {
-        assertThrows(NullPointerException.class, () -> theInstance.track((File) null, new Object()));
-        assertThrows(NullPointerException.class, () -> theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL));
-        assertThrows(NullPointerException.class, () -> theInstance.track((String) null, new Object()));
-        assertThrows(NullPointerException.class, () -> theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL));
+        assertThrows(NullPointerException.class, () -> fileCleaningTracker.track((File) null, new Object()));
+        assertThrows(NullPointerException.class, () -> fileCleaningTracker.track((File) null, new Object(), FileDeleteStrategy.NORMAL));
+        assertThrows(NullPointerException.class, () -> fileCleaningTracker.track((String) null, new Object()));
+        assertThrows(NullPointerException.class, () -> fileCleaningTracker.track((String) null, new Object(), FileDeleteStrategy.NORMAL));
     }
 
     private void waitUntilTrackCount() throws Exception {
         System.gc();
         TestUtils.sleep(500);
         int count = 0;
-        while (theInstance.getTrackCount() != 0 && count++ < 5) {
+        while (fileCleaningTracker.getTrackCount() != 0 && count++ < 5) {
             List<String> list = new ArrayList<>();
             try {
                 long i = 0;
-                while (theInstance.getTrackCount() != 0) {
+                while (fileCleaningTracker.getTrackCount() != 0) {
                     list.add(
                         "A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String "
                             + i++);
@@ -374,7 +374,7 @@ private void waitUntilTrackCount() throws Exception {
             System.gc();
             TestUtils.sleep(1000);
         }
-        if (theInstance.getTrackCount() != 0) {
+        if (fileCleaningTracker.getTrackCount() != 0) {
             throw new IllegalStateException("Your JVM is not releasing References, try running the test with less memory (-Xmx)");
         }
 
diff --git a/src/test/java/org/apache/commons/io/FileSystemTest.java b/src/test/java/org/apache/commons/io/FileSystemTest.java
index 8e7a8c5d..9efde1ff 100644
--- a/src/test/java/org/apache/commons/io/FileSystemTest.java
+++ b/src/test/java/org/apache/commons/io/FileSystemTest.java
@@ -58,7 +58,7 @@ public void testIsLegalName() {
             assertTrue(fs.isLegalFileName("0"), fs.name()); // Assume simple name always legal
             for (final String candidate : fs.getReservedFileNames()) {
                 // Reserved file names are not legal
-                assertFalse(fs.isLegalFileName(candidate));
+                assertFalse(fs.isLegalFileName(candidate), candidate);
             }
         }
     }
diff --git a/src/test/java/org/apache/commons/io/FileSystemUtilsTest.java b/src/test/java/org/apache/commons/io/FileSystemUtilsTest.java
index 617f03c0..fff75e42 100644
--- a/src/test/java/org/apache/commons/io/FileSystemUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/FileSystemUtilsTest.java
@@ -16,21 +16,12 @@
  */
 package org.apache.commons.io;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.time.Duration;
-import java.util.Locale;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests {@link FileSystemUtils}.
@@ -38,460 +29,62 @@
 @SuppressWarnings("deprecation") // testing deprecated class
 public class FileSystemUtilsTest {
 
-    static class MockFileSystemUtils extends FileSystemUtils {
-        private final int exitCode;
-        private final byte[] bytes;
-        private final String cmd;
-
-        public MockFileSystemUtils(final int exitCode, final String lines) {
-            this(exitCode, lines, null);
-        }
-
-        public MockFileSystemUtils(final int exitCode, final String lines, final String cmd) {
-            this.exitCode = exitCode;
-            this.bytes = lines.getBytes();
-            this.cmd = cmd;
-        }
-
-        @Override
-        Process openProcess(final String[] params) {
-            if (cmd != null) {
-                assertEquals(cmd, params[params.length - 1]);
-            }
-            return new Process() {
-                @Override
-                public void destroy() {
-                }
-
-                @Override
-                public int exitValue() {
-                    return exitCode;
-                }
-
-                @Override
-                public InputStream getErrorStream() {
-                    return null;
-                }
-
-                @Override
-                public InputStream getInputStream() {
-                    return new ByteArrayInputStream(bytes);
-                }
-
-                @Override
-                public OutputStream getOutputStream() {
-                    return null;
-                }
-
-                @Override
-                public int waitFor() throws InterruptedException {
-                    return exitCode;
-                }
-            };
-        }
-    }
-
-    private static final Duration NEG_1_TIMEOUT = Duration.ofMillis(-1);
-
-    @Test
-    public void testGetFreeSpace_String() throws Exception {
-        // test coverage, as we can't check value
-        if (File.separatorChar == '/') {
-            // have to figure out Unix block size
-            final String[] cmd;
-            String osName = System.getProperty("os.name");
-            osName = osName.toLowerCase(Locale.ENGLISH);
-
-            if (osName.contains("hp-ux") || osName.contains("aix")) {
-                cmd = new String[]{"df", "-P", "/"};
-            } else if (osName.contains("sunos") || osName.contains("sun os")
-                    || osName.contains("solaris")) {
-                cmd = new String[]{"/usr/xpg4/bin/df", "-P", "/"};
-            } else {
-                cmd = new String[]{"df", "/"};
-            }
-            final Process proc = Runtime.getRuntime().exec(cmd);
-            boolean kilobyteBlock = true;
-            try (BufferedReader r = new BufferedReader(new InputStreamReader(proc.getInputStream()))){
-                final String line = r.readLine();
-                assertNotNull(line, "Unexpected null line");
-                if (line.contains("512")) {
-                    kilobyteBlock = false;
-                }
-            }
-
-            // now perform the test
-            final long free = FileSystemUtils.freeSpace("/");
-            final long kb = FileSystemUtils.freeSpaceKb("/");
-            // Assume disk space does not fluctuate
-            // more than 1% between the above two calls;
-            // this is also small enough to verify freeSpaceKb uses
-            // kibibytes (1024) instead of SI kilobytes (1000)
-            final double acceptableDelta = kb * 0.01d;
-            if (kilobyteBlock) {
-                assertEquals(free, kb, acceptableDelta);
-            } else {
-                assertEquals(free / 2d, kb, acceptableDelta);
-            }
-        } else {
-            final long bytes = FileSystemUtils.freeSpace("");
-            final long kb = FileSystemUtils.freeSpaceKb("");
-            // Assume disk space does not fluctuate more than 1%
-            final double acceptableDelta = kb * 0.01d;
-            assertEquals((double) bytes / 1024, kb, acceptableDelta);
-        }
-    }
-
-    @Test
-    public void testGetFreeSpaceOS_String_InitError() throws Exception {
-        final FileSystemUtils fsu = new FileSystemUtils();
-        assertThrows(IllegalStateException.class, () -> fsu.freeSpaceOS("", -1, false, NEG_1_TIMEOUT));
-        assertThrows(IllegalStateException.class, () -> fsu.freeSpaceOS("", -1, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceOS_String_NullPath() throws Exception {
-        final FileSystemUtils fsu = new FileSystemUtils();
-        assertThrows(NullPointerException.class, () -> fsu.freeSpaceOS(null, 1, false, NEG_1_TIMEOUT));
-        assertThrows(NullPointerException.class, () -> fsu.freeSpaceOS(null, 1, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceOS_String_Other() throws Exception {
-        final FileSystemUtils fsu = new FileSystemUtils();
-        assertThrows(IllegalStateException.class, () -> fsu.freeSpaceOS("", 0, false, NEG_1_TIMEOUT));
-        assertThrows(NullPointerException.class, () -> fsu.freeSpaceOS(null, 1, true, NEG_1_TIMEOUT));
-        assertThrows(IllegalStateException.class, () -> fsu.freeSpaceOS("", 0, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceOS_String_Unix() throws Exception {
-        final FileSystemUtils fsu = new FileSystemUtils() {
-            @Override
-            protected long freeSpaceUnix(final String path, final boolean kb, final boolean posix, final Duration timeout) throws IOException {
-                return kb ? 12345L : 54321;
-            }
-        };
-        assertEquals(54321L, fsu.freeSpaceOS("", 2, false, NEG_1_TIMEOUT));
-        assertEquals(12345L, fsu.freeSpaceOS("", 2, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceOS_String_Windows() throws Exception {
-        final FileSystemUtils fsu = new FileSystemUtils() {
-            @Override
-            protected long freeSpaceWindows(final String path, final Duration timeout) throws IOException {
-                return 12345L;
-            }
-        };
-        assertEquals(12345L, fsu.freeSpaceOS("", 1, false, NEG_1_TIMEOUT));
-        assertEquals(12345L / 1024, fsu.freeSpaceOS("", 1, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_EmptyPath() throws Exception {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "xxx:/home/users/s     14428928  12956424   1472504  90% /home/users/s";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IllegalArgumentException.class, () -> fsu.freeSpaceUnix("", false, false, NEG_1_TIMEOUT));
-        assertThrows(IllegalArgumentException.class, () -> fsu.freeSpaceUnix("", true, false, NEG_1_TIMEOUT));
-        assertThrows(IllegalArgumentException.class, () -> fsu.freeSpaceUnix("", true, true, NEG_1_TIMEOUT));
-        assertThrows(IllegalArgumentException.class, () -> fsu.freeSpaceUnix("", false, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-
-    public void testGetFreeSpaceUnix_String_EmptyResponse() {
-        final String lines = "";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, true, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_InvalidResponse1() {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "                      14428928  12956424       100";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, true, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_InvalidResponse2() {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "xxx:/home/users/s     14428928  12956424   nnnnnnn  90% /home/users/s";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, true, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_InvalidResponse3() {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "xxx:/home/users/s     14428928  12956424        -1  90% /home/users/s";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, true, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_InvalidResponse4() {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "xxx-yyyyyyy-zzz:/home/users/s";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, false, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", false, true, NEG_1_TIMEOUT));
-        assertThrows(IOException.class, () -> fsu.freeSpaceUnix("/home/users/s", true, true, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_LongResponse() throws Exception {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "xxx-yyyyyyy-zzz:/home/users/s\n" +
-                        "                      14428928  12956424   1472504  90% /home/users/s";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(1472504L, fsu.freeSpaceUnix("/home/users/s", false, false, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_LongResponseKb() throws Exception {
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "xxx-yyyyyyy-zzz:/home/users/s\n" +
-                        "                      14428928  12956424   1472504  90% /home/users/s";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(1472504L, fsu.freeSpaceUnix("/home/users/s", true, false, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_NormalResponseFreeBSD() throws Exception {
-        // from Apache 'FreeBSD 6.1-RELEASE (SMP-turbo)'
-        final String lines =
-                "Filesystem  1K-blocks      Used    Avail Capacity  Mounted on\n" +
-                        "/dev/xxxxxx    128990    102902    15770    87%    /";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(15770L, fsu.freeSpaceUnix("/", false, false, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_NormalResponseKbFreeBSD() throws Exception {
-        // from Apache 'FreeBSD 6.1-RELEASE (SMP-turbo)'
-        // df and df -k are identical, but df -kP uses 512 blocks (not relevant as not used)
-        final String lines =
-                "Filesystem  1K-blocks      Used    Avail Capacity  Mounted on\n" +
-                        "/dev/xxxxxx    128990    102902    15770    87%    /";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(15770L, fsu.freeSpaceUnix("/", true, false, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_NormalResponseKbLinux() throws Exception {
-        // from Sourceforge 'GNU bash, version 2.05b.0(1)-release (i386-redhat-linux-gnu)'
-        // df, df -k and df -kP are all identical
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "/dev/xxx                497944    308528    189416  62% /";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(189416L, fsu.freeSpaceUnix("/", true, false, NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceUnix_String_NormalResponseKbSolaris() throws Exception {
-        // from IO-91 - ' SunOS et 5.10 Generic_118822-25 sun4u sparc SUNW,Ultra-4'
-        // non-kb response does not contain free space - see IO-91
-        final String lines =
-                "Filesystem            kbytes    used   avail capacity  Mounted on\n" +
-                        "/dev/dsk/x0x0x0x0    1350955  815754  481163    63%";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(481163L, fsu.freeSpaceUnix("/dev/dsk/x0x0x0x0", true, false, NEG_1_TIMEOUT));
+    static char[] getIllegalFileNameChars() {
+        return FileSystem.getCurrent().getIllegalFileNameChars();
     }
 
-    @Test
-    public void testGetFreeSpaceUnix_String_NormalResponseLinux() throws Exception {
-        // from Sourceforge 'GNU bash, version 2.05b.0(1)-release (i386-redhat-linux-gnu)'
-        final String lines =
-                "Filesystem           1K-blocks      Used Available Use% Mounted on\n" +
-                        "/dev/xxx                497944    308528    189416  62% /";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(189416L, fsu.freeSpaceUnix("/", false, false, NEG_1_TIMEOUT));
+    @ParameterizedTest
+    @MethodSource("getIllegalFileNameChars")
+    public void testGetFreeSpace_IllegalFileName(final char illegalFileNameChar) throws Exception {
+        assertThrows(IllegalArgumentException.class, () -> FileSystemUtils.freeSpace("\\ \"" + illegalFileNameChar));
     }
 
     @Test
-    public void testGetFreeSpaceWindows_String_EmptyMultiLineResponse() {
-        final String lines = "\n\n";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceWindows("C:", NEG_1_TIMEOUT));
+    public void testGetFreeSpace_IllegalFileNames() throws Exception {
+        assertThrows(IllegalArgumentException.class, () -> FileSystemUtils.freeSpace("\\ \""));
     }
 
     @Test
-    public void testGetFreeSpaceWindows_String_EmptyPath() throws Exception {
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)         180260 bytes\n" +
-                        "              10 Dir(s)     41411551232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines, "dir /a /-c ");
-        assertEquals(41411551232L, fsu.freeSpaceWindows("", NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceWindows_String_EmptyResponse() {
-        final String lines = "";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceWindows("C:", NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceWindows_String_InvalidTextResponse() {
-        final String lines = "BlueScreenOfDeath";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceWindows("C:", NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceWindows_String_NormalResponse() throws Exception {
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)         180260 bytes\n" +
-                        "              10 Dir(s)     41411551232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines, "dir /a /-c \"C:\"");
-        assertEquals(41411551232L, fsu.freeSpaceWindows("C:", NEG_1_TIMEOUT));
-    }
-    @Test
-    public void testGetFreeSpaceWindows_String_NoSuchDirectoryResponse() {
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\empty" +
-                        "\n";
-        final FileSystemUtils fsu = new MockFileSystemUtils(1, lines);
-        assertThrows(IOException.class, () -> fsu.freeSpaceWindows("C:", NEG_1_TIMEOUT));
-    }
-
-    @Test
-    public void testGetFreeSpaceWindows_String_ParseCommaFormatBytes() throws Exception {
-        // this is the format of response when calling dir /c
-        // we have now switched to dir /-c, so we should never get this
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)        180,260 bytes\n" +
-                        "              10 Dir(s)  41,411,551,232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(41411551232L, fsu.freeSpaceWindows("", NEG_1_TIMEOUT));
+    public void testGetFreeSpace_String() throws Exception {
+        assertThrows(NullPointerException.class, () -> FileSystemUtils.freeSpace(null));
+        assertThrows(IllegalArgumentException.class, () -> FileSystemUtils.freeSpace("this directory does not exist, at all."));
+        // "" means current dir.
+        assertTrue(FileSystemUtils.freeSpace("") > 0);
+        assertTrue(FileSystemUtils.freeSpace("target") > 0);
+        // files worked as well in previous versions.
+        assertTrue(FileSystemUtils.freeSpace("pom.xml") > 0);
     }
 
     @Test
-    public void testGetFreeSpaceWindows_String_ParseCommaFormatBytes_Big() throws Exception {
-        // test with very large free space
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)        180,260 bytes\n" +
-                        "              10 Dir(s)  141,411,551,232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(141411551232L, fsu.freeSpaceWindows("", NEG_1_TIMEOUT));
+    public void testGetFreeSpaceKb() throws Exception {
+        assertTrue(FileSystemUtils.freeSpaceKb() > 0);
     }
 
     @Test
-    public void testGetFreeSpaceWindows_String_ParseCommaFormatBytes_Small() throws Exception {
-        // test with very large free space
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)        180,260 bytes\n" +
-                        "              10 Dir(s)  1,232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
-        assertEquals(1232L, fsu.freeSpaceWindows("", NEG_1_TIMEOUT));
+    public void testGetFreeSpaceKb_long() throws Exception {
+        assertTrue(FileSystemUtils.freeSpaceKb(0) > 0);
     }
 
     @Test
-    public void testGetFreeSpaceWindows_String_quoted() throws Exception {
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)         180260 bytes\n" +
-                        "              10 Dir(s)     41411551232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines, "dir /a /-c \"C:\\somedir\"");
-        assertEquals(41411551232L, fsu.freeSpaceWindows("\"C:\\somedir\"", NEG_1_TIMEOUT));
+    public void testGetFreeSpaceKb_String() throws Exception {
+        assertThrows(NullPointerException.class, () -> FileSystemUtils.freeSpaceKb(null));
+        assertThrows(IllegalArgumentException.class, () -> FileSystemUtils.freeSpaceKb("this directory does not exist, at all."));
+        // "" means current dir.
+        assertTrue(FileSystemUtils.freeSpaceKb("") > 0);
+        assertTrue(FileSystemUtils.freeSpaceKb("target") > 0);
+        // files worked as well in previous versions.
+        assertTrue(FileSystemUtils.freeSpaceKb("pom.xml") > 0);
     }
 
     @Test
-    public void testGetFreeSpaceWindows_String_StripDrive() throws Exception {
-        final String lines =
-                " Volume in drive C is HDD\n" +
-                        " Volume Serial Number is XXXX-YYYY\n" +
-                        "\n" +
-                        " Directory of C:\\Documents and Settings\\Xxxx\n" +
-                        "\n" +
-                        "19/08/2005  22:43    <DIR>          .\n" +
-                        "19/08/2005  22:43    <DIR>          ..\n" +
-                        "11/08/2005  01:07                81 build.properties\n" +
-                        "17/08/2005  21:44    <DIR>          Desktop\n" +
-                        "               7 File(s)         180260 bytes\n" +
-                        "              10 Dir(s)     41411551232 bytes free";
-        final FileSystemUtils fsu = new MockFileSystemUtils(0, lines, "dir /a /-c \"C:\\somedir\"");
-        assertEquals(41411551232L, fsu.freeSpaceWindows("C:\\somedir", NEG_1_TIMEOUT));
+    public void testGetFreeSpaceKb_String_long() throws Exception {
+        assertThrows(NullPointerException.class, () -> FileSystemUtils.freeSpaceKb(null, 0));
+        assertThrows(IllegalArgumentException.class, () -> FileSystemUtils.freeSpaceKb("this directory does not exist, at all.", 0));
+        // "" means current dir.
+        assertTrue(FileSystemUtils.freeSpaceKb("", 0) > 0);
+        assertTrue(FileSystemUtils.freeSpaceKb("target", 0) > 0);
+        // files worked as well in previous versions.
+        assertTrue(FileSystemUtils.freeSpaceKb("pom.xml", 0) > 0);
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java b/src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java
index 38db7645..a2366300 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java
@@ -25,6 +25,7 @@
 import java.util.List;
 
 import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.SystemProperties;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 
@@ -52,10 +53,9 @@ private boolean setupSymlink(final File res, final File link) throws Exception {
         return proc.waitFor() == 0;
     }
 
-
     @Test
     public void testCleanDirWithASymlinkDir() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -85,12 +85,12 @@ public void testCleanDirWithASymlinkDir() throws Exception {
         assertEquals(0, realOuter.list().length);
 
         // ensure that the contents of the symlink were NOT removed.
-        assertEquals(1, randomDirectory.list().length, "Contents of sym link should not have been removed");
+        assertEquals(1, randomDirectory.list().length, "Contents of symbolic link should not have been removed");
     }
 
     @Test
     public void testCleanDirWithParentSymlinks() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -119,17 +119,18 @@ public void testCleanDirWithParentSymlinks() throws Exception {
         assertTrue(setupSymlink(realParent, symlinkParentDirectory));
 
         // assert contents of the real directory were removed including the symlink
-        FileUtils.cleanDirectory(symlinkParentDirectory);// should clean the contents of this but not recurse into other links
+        // should clean the contents of this but not recurse into other links
+        FileUtils.cleanDirectory(symlinkParentDirectory);
         assertEquals(0, symlinkParentDirectory.list().length);
         assertEquals(0, realParent.list().length);
 
         // ensure that the contents of the symlink were NOT removed.
-        assertEquals(1, randomDirectory.list().length, "Contents of sym link should not have been removed");
+        assertEquals(1, randomDirectory.list().length, "Contents of symbolic link should not have been removed");
     }
 
     @Test
     public void testCleanDirWithSymlinkFile() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -161,10 +162,9 @@ public void testCleanDirWithSymlinkFile() throws Exception {
         assertFalse(symlinkFile.exists());
     }
 
-
     @Test
     public void testCorrectlyIdentifySymlinkWithParentSymLink() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -187,7 +187,7 @@ public void testCorrectlyIdentifySymlinkWithParentSymLink() throws Exception {
 
     @Test
     public void testIdentifiesBrokenSymlinkFile() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -207,7 +207,7 @@ public void testIdentifiesBrokenSymlinkFile() throws Exception {
 
     @Test
     public void testIdentifiesSymlinkDir() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -224,7 +224,7 @@ public void testIdentifiesSymlinkDir() throws Exception {
 
     @Test
     public void testIdentifiesSymlinkFile() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
@@ -241,7 +241,7 @@ public void testIdentifiesSymlinkFile() throws Exception {
 
     @Test
     public void testStillClearsIfGivenDirectoryIsASymlink() throws Exception {
-        if (System.getProperty("os.name").startsWith("Win")) {
+        if (SystemProperties.getOsName().startsWith("Win")) {
             // Can't use "ln" for symlinks on the command line in Windows.
             return;
         }
diff --git a/src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java b/src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java
index 6bc2223e..cce762bd 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java
@@ -60,7 +60,7 @@ private void assertAclEntryList(final Path sourcePath, final Path destPath) thro
     }
 
     @Test
-    public void copyDirectoryToDirectoryThrowsIllegalArgumentExceptionWithCorrectMessageWhenDstDirIsNotDirectory()
+    public void testCopyDirectoryToDirectoryThrowsIllegalArgumentExceptionWithCorrectMessageWhenDstDirIsNotDirectory()
         throws IOException {
         final File srcDir = new File(temporaryFolder, "sourceDirectory");
         srcDir.mkdir();
@@ -72,18 +72,18 @@ public void copyDirectoryToDirectoryThrowsIllegalArgumentExceptionWithCorrectMes
     }
 
     @Test
-    public void copyDirectoryToDirectoryThrowsIllegalExceptionWithCorrectMessageWhenSrcDirIsNotDirectory()
+    public void testCopyDirectoryToDirectoryThrowsIllegalExceptionWithCorrectMessageWhenSrcDirIsNotDirectory()
         throws IOException {
         try (TempFile srcDir = TempFile.create("notadirectory", null)) {
             final File destDir = new File(temporaryFolder, "destinationDirectory");
             destDir.mkdirs();
-            final String expectedMessage = String.format("Parameter 'sourceDir' is not a directory: '%s'", srcDir);
+            final String expectedMessage = String.format("Parameter 'srcDir' is not a directory: '%s'", srcDir);
             assertExceptionTypeAndMessage(srcDir.toFile(), destDir, IllegalArgumentException.class, expectedMessage);
         }
     }
 
     @Test
-    public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessageWhenDstDirIsNull() {
+    public void testCopyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessageWhenDstDirIsNull() {
         final File srcDir = new File(temporaryFolder, "sourceDirectory");
         srcDir.mkdir();
         final File destDir = null;
@@ -91,7 +91,7 @@ public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessage
     }
 
     @Test
-    public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessageWhenSrcDirIsNull() {
+    public void testCopyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessageWhenSrcDirIsNull() {
         final File srcDir = null;
         final File destinationDirectory = new File(temporaryFolder, "destinationDirectory");
         destinationDirectory.mkdir();
@@ -99,7 +99,7 @@ public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessage
     }
 
     @Test
-    public void copyFileAndCheckAcl() throws IOException {
+    public void testCopyFileAndCheckAcl() throws IOException {
         try (TempFile sourcePath = TempFile.create("TempOutput", ".bin")) {
             final Path destPath = Paths.get(temporaryFolder.getAbsolutePath(), "SomeFile.bin");
             // Test copy attributes without replace FIRST.
diff --git a/src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java b/src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java
index ac387856..de0117a3 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java
@@ -25,13 +25,12 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 
-
 /**
  * Tests {@link FileUtils}.
  */
 public class FileUtilsCopyToFileTest {
 
-    private class CheckingInputStream extends ByteArrayInputStream {
+    private final class CheckingInputStream extends ByteArrayInputStream {
         private boolean closed;
 
         public CheckingInputStream(final byte[] data) {
@@ -77,7 +76,7 @@ public void setUp() throws Exception {
      */
     @Test
     public void testCopyInputStreamToFile() throws IOException {
-        try(CheckingInputStream inputStream = new CheckingInputStream(testData)) {
+        try (CheckingInputStream inputStream = new CheckingInputStream(testData)) {
             FileUtils.copyInputStreamToFile(inputStream, testFile);
             assertTrue(inputStream.isClosed(), "inputStream should be closed");
         }
@@ -92,7 +91,7 @@ public void testCopyInputStreamToFile() throws IOException {
      */
     @Test
     public void testCopyToFile() throws IOException {
-        try(CheckingInputStream inputStream = new CheckingInputStream(testData)) {
+        try (CheckingInputStream inputStream = new CheckingInputStream(testData)) {
             FileUtils.copyToFile(inputStream, testFile);
             assertFalse(inputStream.isClosed(), "inputStream should NOT be closed");
         }
diff --git a/src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java b/src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java
index 60600ff5..ad50f2f8 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java
@@ -88,7 +88,8 @@ public void testThrowsOnCannotDeleteFile() throws Exception {
         try {
             // deleteDirectory calls forceDelete
             final IOExceptionList ioExceptionList = (IOExceptionList) assertThrows(IOException.class, () -> FileUtils.deleteDirectory(nested));
-            assertTrue(ioExceptionList.getCause(0).getMessage().endsWith("Cannot delete file: " + file.getAbsolutePath()));
+            final String message = ioExceptionList.getCause(0).getMessage();
+            assertTrue(message.endsWith("Cannot delete file: " + file.getAbsolutePath()), message);
         } finally {
             chmod(nested, 755, false);
             FileUtils.deleteDirectory(nested);
diff --git a/src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java b/src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java
index 3e92fef6..272aae45 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java
@@ -21,6 +21,7 @@
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 
 import org.junit.jupiter.api.BeforeEach;
@@ -31,7 +32,6 @@
  * This class ensure the correctness of {@link FileUtils#directoryContains(File,File)}.
  *
  * @see FileUtils#directoryContains(File, File)
- * @since 2.2
  */
 public class FileUtilsDirectoryContainsTest {
 
@@ -115,7 +115,7 @@ public void testDirectoryDoesNotContainsDirectory() throws IOException {
     public void testDirectoryDoesNotExist() {
         final File dir = new File("DOESNOTEXIST");
         assertFalse(dir.exists());
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.directoryContains(dir, file1));
+        assertThrows(FileNotFoundException.class, () -> FileUtils.directoryContains(dir, file1));
     }
 
     @Test
@@ -168,6 +168,6 @@ public void testUnrealizedContainment() {
         final File file = new File(dir, "DOESNOTEXIST2");
         assertFalse(dir.exists());
         assertFalse(file.exists());
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.directoryContains(dir, file));
+        assertThrows(FileNotFoundException.class, () -> FileUtils.directoryContains(dir, file));
     }
 }
diff --git a/src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java b/src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java
index e65bc8de..926f67fa 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java
@@ -18,17 +18,30 @@
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 
 import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
+import org.apache.commons.io.file.PathUtils;
 import org.apache.commons.io.filefilter.FileFilterUtils;
 import org.apache.commons.io.filefilter.IOFileFilter;
+import org.apache.commons.io.function.Uncheck;
 import org.apache.commons.lang3.function.Consumers;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -42,23 +55,6 @@ public class FileUtilsListFilesTest {
     @TempDir
     public File temporaryFolder;
 
-    private Collection<String> filesToFilenames(final Collection<File> files) {
-        return files.stream().map(File::getName).collect(Collectors.toList());
-    }
-
-    /**
-     * Consumes and closes the underlying stream.
-     *
-     * @param files The iterator to consume.
-     * @return a new collection.
-     */
-    private Collection<String> filesToFilenames(final Iterator<File> files) {
-        final Collection<String> fileNames = new ArrayList<>();
-        // Iterator.forEachRemaining() closes the underlying stream.
-        files.forEachRemaining(f -> fileNames.add(f.getName()));
-        return fileNames;
-    }
-
     @SuppressWarnings("ResultOfMethodCallIgnored")
     @BeforeEach
     public void setUp() throws Exception {
@@ -81,6 +77,8 @@ public void setUp() throws Exception {
         FileUtils.touch(file);
         file = new File(dir, "dummy-index.html");
         FileUtils.touch(file);
+        file = new File(dir, "dummy-indexhtml");
+        FileUtils.touch(file);
 
         dir = dir.getParentFile();
         dir = new File(dir, "CVS");
@@ -97,7 +95,7 @@ public void testIterateFilesByExtension() {
 
         Iterator<File> files = FileUtils.iterateFiles(temporaryFolder, extensions, false);
         try {
-            final Collection<String> fileNames = filesToFilenames(files);
+            final Collection<String> fileNames = toFileNames(files);
             assertEquals(1, fileNames.size());
             assertTrue(fileNames.contains("dummy-build.xml"));
             assertFalse(fileNames.contains("README"));
@@ -109,7 +107,7 @@ public void testIterateFilesByExtension() {
 
         try {
             files = FileUtils.iterateFiles(temporaryFolder, extensions, true);
-            final Collection<String> fileNames = filesToFilenames(files);
+            final Collection<String> fileNames = toFileNames(files);
             assertEquals(4, fileNames.size());
             assertTrue(fileNames.contains("dummy-file.txt"));
             assertFalse(fileNames.contains("dummy-index.html"));
@@ -120,7 +118,7 @@ public void testIterateFilesByExtension() {
 
         files = FileUtils.iterateFiles(temporaryFolder, null, false);
         try {
-            final Collection<String> fileNames = filesToFilenames(files);
+            final Collection<String> fileNames = toFileNames(files);
             assertEquals(2, fileNames.size());
             assertTrue(fileNames.contains("dummy-build.xml"));
             assertTrue(fileNames.contains("README"));
@@ -137,43 +135,43 @@ public void testListFiles() {
         Collection<String> fileNames;
         IOFileFilter fileFilter;
         IOFileFilter dirFilter;
-
+        //
         // First, find non-recursively
         fileFilter = FileFilterUtils.trueFileFilter();
         files = FileUtils.listFiles(temporaryFolder, fileFilter, null);
-        fileNames = filesToFilenames(files);
+        fileNames = toFileNames(files);
         assertTrue(fileNames.contains("dummy-build.xml"), "'dummy-build.xml' is missing");
         assertFalse(fileNames.contains("dummy-index.html"), "'dummy-index.html' shouldn't be found");
         assertFalse(fileNames.contains("Entries"), "'Entries' shouldn't be found");
-
+        //
         // Second, find recursively
         fileFilter = FileFilterUtils.trueFileFilter();
         dirFilter = FileFilterUtils.notFileFilter(FileFilterUtils.nameFileFilter("CVS"));
         files = FileUtils.listFiles(temporaryFolder, fileFilter, dirFilter);
-        fileNames = filesToFilenames(files);
+        fileNames = toFileNames(files);
         assertTrue(fileNames.contains("dummy-build.xml"), "'dummy-build.xml' is missing");
         assertTrue(fileNames.contains("dummy-index.html"), "'dummy-index.html' is missing");
         assertFalse(fileNames.contains("Entries"), "'Entries' shouldn't be found");
-
+        //
         // Do the same as above but now with the filter coming from FileFilterUtils
         fileFilter = FileFilterUtils.trueFileFilter();
         dirFilter = FileFilterUtils.makeCVSAware(null);
         files = FileUtils.listFiles(temporaryFolder, fileFilter, dirFilter);
-        fileNames = filesToFilenames(files);
+        fileNames = toFileNames(files);
         assertTrue(fileNames.contains("dummy-build.xml"), "'dummy-build.xml' is missing");
         assertTrue(fileNames.contains("dummy-index.html"), "'dummy-index.html' is missing");
         assertFalse(fileNames.contains("Entries"), "'Entries' shouldn't be found");
-
+        //
         // Again with the CVS filter but now with a non-null parameter
         fileFilter = FileFilterUtils.trueFileFilter();
         dirFilter = FileFilterUtils.prefixFileFilter("sub");
         dirFilter = FileFilterUtils.makeCVSAware(dirFilter);
         files = FileUtils.listFiles(temporaryFolder, fileFilter, dirFilter);
-        fileNames = filesToFilenames(files);
+        fileNames = toFileNames(files);
         assertTrue(fileNames.contains("dummy-build.xml"), "'dummy-build.xml' is missing");
         assertTrue(fileNames.contains("dummy-index.html"), "'dummy-index.html' is missing");
         assertFalse(fileNames.contains("Entries"), "'Entries' shouldn't be found");
-
+        // Edge case
         assertThrows(NullPointerException.class, () -> FileUtils.listFiles(temporaryFolder, null, null));
     }
 
@@ -183,24 +181,125 @@ public void testListFilesByExtension() {
 
         Collection<File> files = FileUtils.listFiles(temporaryFolder, extensions, false);
         assertEquals(1, files.size());
-        Collection<String> fileNames = filesToFilenames(files);
+        Collection<String> fileNames = toFileNames(files);
         assertTrue(fileNames.contains("dummy-build.xml"));
         assertFalse(fileNames.contains("README"));
         assertFalse(fileNames.contains("dummy-file.txt"));
 
         files = FileUtils.listFiles(temporaryFolder, extensions, true);
-        fileNames = filesToFilenames(files);
-        assertEquals(4, fileNames.size());
+        fileNames = toFileNames(files);
+        assertEquals(4, fileNames.size(), fileNames::toString);
         assertTrue(fileNames.contains("dummy-file.txt"));
         assertFalse(fileNames.contains("dummy-index.html"));
 
         files = FileUtils.listFiles(temporaryFolder, null, false);
-        assertEquals(2, files.size());
-        fileNames = filesToFilenames(files);
+        assertEquals(2, files.size(), files::toString);
+        fileNames = toFileNames(files);
         assertTrue(fileNames.contains("dummy-build.xml"));
         assertTrue(fileNames.contains("README"));
         assertFalse(fileNames.contains("dummy-file.txt"));
+
+        final File directory = new File(temporaryFolder, "subdir1/subsubdir1");
+        files = FileUtils.listFiles(directory, new String[] { "html" }, false);
+        fileNames = toFileNames(files);
+        assertFalse(files.isEmpty(), directory::toString);
+        assertTrue(fileNames.contains("dummy-index.html"));
+        assertFalse(fileNames.contains("dummy-indexhtml"));
+        files = FileUtils.listFiles(temporaryFolder, new String[] { "html" }, true);
+        fileNames = toFileNames(files);
+        assertFalse(files.isEmpty(), temporaryFolder::toString);
+        assertTrue(fileNames.contains("dummy-index.html"));
+        assertFalse(fileNames.contains("dummy-indexhtml"));
+    }
+
+    @Test
+    public void testListFilesWithDeletion() throws IOException {
+        final String[] extensions = {"xml", "txt"};
+        final List<File> list;
+        final File xFile = new File(temporaryFolder, "x.xml");
+        if (!xFile.createNewFile()) {
+            fail("could not create test file: " + xFile);
+        }
+        final Collection<File> files = FileUtils.listFiles(temporaryFolder, extensions, true);
+        assertEquals(5, files.size());
+        try (Stream<File> stream = Uncheck.get(() -> FileUtils.streamFiles(temporaryFolder, true, extensions))) {
+            assertTrue(xFile.delete());
+            list = stream.collect(Collectors.toList());
+            assertFalse(list.contains(xFile), list::toString);
+        }
+        assertEquals(4, list.size());
+    }
+
+    /**
+     * Tests <a href="https://issues.apache.org/jira/browse/IO-856">IO-856</a> ListFiles should not fail on vanishing files.
+     */
+    @Test
+    public void testListFilesWithDeletionThreaded() throws ExecutionException, InterruptedException {
+        // test for IO-856
+        // create random directory in tmp, create the directory if it does not exist
+        final Path tempPath = PathUtils.getTempDirectory().resolve("IO-856");
+        final File tempDir = tempPath.toFile();
+        if (!tempDir.exists() && !tempDir.mkdirs()) {
+            fail("Could not create file path: " + tempDir.getAbsolutePath());
+        }
+        final int waitTime = 10_000;
+        final int maxFiles = 500;
+        final byte[] bytes = "TEST".getBytes(StandardCharsets.UTF_8);
+        final CompletableFuture<Void> c1 = CompletableFuture.runAsync(() -> {
+            final long endTime = System.currentTimeMillis() + waitTime;
+            int count = 0;
+            while (System.currentTimeMillis() < endTime && count < maxFiles) {
+                final File file = new File(tempDir.getAbsolutePath(), UUID.randomUUID() + ".deletetester");
+                file.deleteOnExit();
+                try {
+                    Files.write(file.toPath(), bytes);
+                    count++;
+                } catch (final Exception e) {
+                    fail("Could not create test file: '" + file.getAbsolutePath() + "': " + e, e);
+                }
+                if (!file.delete()) {
+                    fail("Could not delete test file: '" + file.getAbsolutePath() + "'");
+                }
+            }
+            // System.out.printf("Created %,d%n", count);
+        });
+        final CompletableFuture<Void> c2 = CompletableFuture.runAsync(() -> {
+            final long endTime = System.currentTimeMillis() + waitTime;
+            int max = 0;
+            try {
+                while (System.currentTimeMillis() < endTime) {
+                    final Collection<File> files = FileUtils.listFiles(tempDir, new String[] { ".deletetester" }, false);
+                    assertNotNull(files);
+                    max = Math.max(max, files.size());
+                }
+            } catch (final Exception e) {
+                System.out.printf("List size max %,d%n", max);
+                fail("IO-856 test failure: " + e, e);
+                // The exception can be hidden.
+                e.printStackTrace();
+            }
+            // System.out.printf("List size max %,d%n", max);
+        });
+        // wait for the threads to finish
+        c1.get();
+        c2.get();
+    }
+
+    private Collection<String> toFileNames(final Collection<File> files) {
+        return files.stream().map(File::getName).collect(Collectors.toList());
     }
 
+    /**
+     * Consumes and closes the underlying stream.
+     *
+     * @param files The iterator to consume.
+     * @return a new collection.
+     */
+    private Collection<String> toFileNames(final Iterator<File> files) {
+        final Collection<String> fileNames = new ArrayList<>();
+        // Iterator.forEachRemaining() closes the underlying stream.
+        files.forEachRemaining(f -> fileNames.add(f.getName()));
+        return fileNames;
+    }
 
 }
diff --git a/src/test/java/org/apache/commons/io/FileUtilsTest.java b/src/test/java/org/apache/commons/io/FileUtilsTest.java
index 2c820c8d..f11dec5f 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsTest.java
@@ -17,6 +17,7 @@
 package org.apache.commons.io;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
@@ -24,8 +25,11 @@
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.jupiter.api.Assumptions.assumeFalse;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
 
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
@@ -36,12 +40,14 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.UncheckedIOException;
 import java.math.BigInteger;
 import java.net.URL;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.nio.charset.UnsupportedCharsetException;
 import java.nio.file.Files;
+import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardCopyOption;
@@ -75,20 +81,24 @@
 import java.util.zip.Checksum;
 
 import org.apache.commons.io.file.AbstractTempDirTest;
+import org.apache.commons.io.file.Counters.PathCounters;
 import org.apache.commons.io.file.PathUtils;
-import org.apache.commons.io.file.PathUtilsIsEmptyTest;
 import org.apache.commons.io.file.TempDirectory;
 import org.apache.commons.io.file.TempFile;
 import org.apache.commons.io.filefilter.IOFileFilter;
 import org.apache.commons.io.filefilter.NameFileFilter;
 import org.apache.commons.io.filefilter.WildcardFileFilter;
 import org.apache.commons.io.test.TestUtils;
+import org.apache.commons.lang3.SystemProperties;
 import org.apache.commons.lang3.SystemUtils;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.condition.EnabledIf;
+import org.junit.jupiter.api.condition.EnabledOnOs;
+import org.junit.jupiter.api.condition.OS;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
 
@@ -126,6 +136,8 @@ List<File> list(final File startDirectory) throws IOException {
         }
     }
 
+    private static final Path DIR_SIZE_1 = Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1");
+
     private static final String UTF_8 = StandardCharsets.UTF_8.name();
 
     /** Test data. */
@@ -159,9 +171,7 @@ List<File> list(final File startDirectory) throws IOException {
 
     private File testFile1;
     private File testFile2;
-
     private long testFile1Size;
-
     private long testFile2Size;
 
     private void assertContentMatchesAfterCopyURLToFileFor(final String resourceName, final File destination) throws IOException {
@@ -187,7 +197,7 @@ private void consumeRemaining(final Iterator<File> iterator) {
         }
     }
 
-    private Path createCircularOsSymLink(final String linkName, final String targetName) throws IOException {
+    private Path createCircularOsSymbolicLink(final String linkName, final String targetName) throws IOException {
         return Files.createSymbolicLink(Paths.get(linkName), Paths.get(targetName));
     }
 
@@ -195,7 +205,7 @@ private Path createCircularOsSymLink(final String linkName, final String targetN
      * May throw java.nio.file.FileSystemException: C:\Users\...\FileUtilsTestCase\cycle: A required privilege is not held
      * by the client. On Windows, you are fine if you run a terminal with admin karma.
      */
-    private void createCircularSymLink(final File file) throws IOException {
+    private void createCircularSymbolicLink(final File file) throws IOException {
         assertTrue(file.exists());
         final String linkName = file + "/cycle";
         final String targetName = file + "/..";
@@ -209,11 +219,10 @@ private void createCircularSymLink(final File file) throws IOException {
             // On Windows, you are fine if you run a terminal with admin karma.
             Files.createSymbolicLink(linkPath, targetPath);
         } catch (final UnsupportedOperationException e) {
-            e.printStackTrace();
-            createCircularOsSymLink(linkName, targetName);
+            createCircularOsSymbolicLink(linkName, targetName);
         }
         // Sanity check:
-        assertTrue(Files.isSymbolicLink(linkPath), () -> "Expected a sym link here: " + linkName);
+        assertTrue(Files.isSymbolicLink(linkPath), () -> "Expected a symbolic link here: " + linkName);
     }
 
     private void createFilesForTestCopyDirectory(final File grandParentDir, final File parentDir, final File childDir) throws IOException {
@@ -237,12 +246,12 @@ private void createFilesForTestCopyDirectory(final File grandParentDir, final Fi
         FileUtils.writeStringToFile(file6, "File 6 in grandChild2", "UTF8");
     }
 
-    private Path createTempSymlinkedRelativeDir() throws IOException {
+    private ImmutablePair<Path, Path> createTempSymbolicLinkedRelativeDir() throws IOException {
         final Path targetDir = tempDirPath.resolve("subdir");
-        final Path symlinkDir = tempDirPath.resolve("symlinked-dir");
+        final Path symLinkedDir = tempDirPath.resolve("symlinked-dir");
         Files.createDirectory(targetDir);
-        Files.createSymbolicLink(symlinkDir, targetDir);
-        return symlinkDir;
+        Files.createSymbolicLink(symLinkedDir, targetDir);
+        return ImmutablePair.of(symLinkedDir, targetDir);
     }
 
     private Set<String> getFilePathSet(final List<File> files) {
@@ -265,9 +274,8 @@ private String getName() {
 
     private void iterateFilesAndDirs(final File dir, final IOFileFilter fileFilter,
         final IOFileFilter dirFilter, final Collection<File> expectedFilesAndDirs) {
-        final Iterator<File> iterator;
+        final Iterator<File> iterator = FileUtils.iterateFilesAndDirs(dir, fileFilter, dirFilter);
         int filesCount = 0;
-        iterator = FileUtils.iterateFilesAndDirs(dir, fileFilter, dirFilter);
         try {
             final List<File> actualFiles = new ArrayList<>();
             while (iterator.hasNext()) {
@@ -284,7 +292,7 @@ private void iterateFilesAndDirs(final File dir, final IOFileFilter fileFilter,
         }
     }
 
-    void openOutputStream_noParent(final boolean createFile) throws Exception {
+    private void openOutputStream_noParent(final boolean createFile) throws Exception {
         final File file = new File("test.txt");
         assertNull(file.getParentFile());
         try {
@@ -304,19 +312,12 @@ void openOutputStream_noParent(final boolean createFile) throws Exception {
 
     private boolean setLastModifiedMillis(final File testFile, final long millis) {
         return testFile.setLastModified(millis);
-//        try {
-//            Files.setLastModifiedTime(testFile.toPath(), FileTime.fromMillis(millis));
-//        } catch (IOException e) {
-//            return false;
-//        }
-//        return true;
     }
 
     @BeforeEach
     public void setUp() throws Exception {
         testFile1 = new File(tempDirFile, "file1-test.txt");
         testFile2 = new File(tempDirFile, "file1a-test.txt");
-
         testFile1Size = testFile1.length();
         testFile2Size = testFile2.length();
         if (!testFile1.getParentFile().exists()) {
@@ -403,8 +404,7 @@ public void test_openOutputStream_existsButIsDirectory() {
      */
     @Test
     public void test_openOutputStream_intoExistingSymlinkedDir() throws Exception {
-        final Path symlinkedDir = createTempSymlinkedRelativeDir();
-
+        final Path symlinkedDir = createTempSymbolicLinkedRelativeDir().getLeft();
         final File file = symlinkedDir.resolve("test.txt").toFile();
         try (FileOutputStream out = FileUtils.openOutputStream(file)) {
             out.write(0);
@@ -536,7 +536,7 @@ public void testChecksum() throws Exception {
         // create a test file
         final String text = "Imagination is more important than knowledge - Einstein";
         final File file = new File(tempDirFile, "checksum-test.txt");
-        FileUtils.writeStringToFile(file, text, "US-ASCII");
+        FileUtils.writeStringToFile(file, text, StandardCharsets.US_ASCII.name());
 
         // compute the expected checksum
         final Checksum expectedChecksum = new CRC32();
@@ -557,7 +557,7 @@ public void testChecksumCRC32() throws Exception {
         // create a test file
         final String text = "Imagination is more important than knowledge - Einstein";
         final File file = new File(tempDirFile, "checksum-test.txt");
-        FileUtils.writeStringToFile(file, text, "US-ASCII");
+        FileUtils.writeStringToFile(file, text, StandardCharsets.US_ASCII.name());
 
         // compute the expected checksum
         final Checksum expectedChecksum = new CRC32();
@@ -575,12 +575,12 @@ public void testChecksumDouble() throws Exception {
         // create a test file
         final String text1 = "Imagination is more important than knowledge - Einstein";
         final File file1 = new File(tempDirFile, "checksum-test.txt");
-        FileUtils.writeStringToFile(file1, text1, "US-ASCII");
+        FileUtils.writeStringToFile(file1, text1, StandardCharsets.US_ASCII.name());
 
         // create a second test file
         final String text2 = "To be or not to be - Shakespeare";
         final File file2 = new File(tempDirFile, "checksum-test2.txt");
-        FileUtils.writeStringToFile(file2, text2, "US-ASCII");
+        FileUtils.writeStringToFile(file2, text2, StandardCharsets.US_ASCII.name());
 
         // compute the expected checksum
         final Checksum expectedChecksum = new CRC32();
@@ -607,7 +607,7 @@ public void testChecksumOnNullChecksum() throws Exception {
         // create a test file
         final String text = "Imagination is more important than knowledge - Einstein";
         final File file = new File(tempDirFile, "checksum-test.txt");
-        FileUtils.writeStringToFile(file, text, "US-ASCII");
+        FileUtils.writeStringToFile(file, text, StandardCharsets.US_ASCII.name());
         assertThrows(NullPointerException.class, () -> FileUtils.checksum(file, null));
     }
 
@@ -753,6 +753,169 @@ public void testContentEqualsIgnoreEOL() throws Exception {
         assertTrue(FileUtils.contentEqualsIgnoreEOL(file1, file2, null));
     }
 
+    /**
+     * See what happens when copyDirectory copies a directory that is a symlink
+     * to another directory containing non-symlinked files.
+     * This is a characterization test to explore current behavior, and arguably
+     * represents a bug. This behavior, and the test, is likely to change
+     * and should not be relied on.
+     */
+    @Test
+    public void testCopyDir_SymbolicLink() throws Exception {
+        // Make a directory
+        final File realDirectory = new File(tempDirFile, "real_directory");
+        realDirectory.mkdir();
+        final File content = new File(realDirectory, "hello.txt");
+        FileUtils.writeStringToFile(content, "HELLO WORLD", "UTF8");
+
+        // Make a symlink to the directory
+        final Path linkPath = tempDirFile.toPath().resolve("link_to_directory");
+        Files.createSymbolicLink(linkPath, realDirectory.toPath());
+
+        // Now copy symlink
+        final File destination = new File(tempDirFile, "destination");
+
+        // Is the copy a symlink or an actual directory?
+        FileUtils.copyDirectory(linkPath.toFile(), destination);
+
+        // delete the original file so that if we can read the bytes from the
+        // copied directory it's definitely been copied, not linked.
+        assumeTrue(content.delete());
+
+        assertFalse(Files.isSymbolicLink(destination.toPath()));
+        final File copied_content = new File(destination, "hello.txt");
+        final String actual = FileUtils.readFileToString(copied_content, "UTF8");
+        assertEquals("HELLO WORLD", actual);
+    }
+
+    @Test
+    public void testCopyDir_SymbolicLinkCycle() throws Exception {
+        // Make a directory
+        final File topDirectory = new File(tempDirFile, "topDirectory");
+        topDirectory.mkdir();
+        final File content = new File(topDirectory, "hello.txt");
+        FileUtils.writeStringToFile(content, "HELLO WORLD", "UTF8");
+        final File childDirectory = new File(topDirectory, "child_directory");
+        childDirectory.mkdir();
+
+        // Make a symlink to the top directory
+        final Path linkPath = childDirectory.toPath().resolve("link_to_top");
+        Files.createSymbolicLink(linkPath, topDirectory.toPath());
+
+        // Now copy symlink
+        final File destination = new File(tempDirFile, "destination");
+        FileUtils.copyDirectory(linkPath.toFile(), destination);
+
+        // delete the original file so that if we can read the bytes from the
+        // copied directory it's definitely been copied, not linked.
+        assumeTrue(content.delete());
+
+        assertFalse(Files.isSymbolicLink(destination.toPath()));
+        final File copied_content = new File(destination, "hello.txt");
+        final String actual = FileUtils.readFileToString(copied_content, "UTF8");
+        assertEquals("HELLO WORLD", actual);
+
+        final File[] copied = destination.listFiles();
+        assertEquals(2, copied.length);
+    }
+
+    /**
+     * Tests IO-807.
+     */
+    @Test
+    public void testCopyDirectory_brokenSymbolicLink() throws IOException {
+        // Make a file
+        final File sourceDirectory = new File(tempDirFile, "source_directory");
+        sourceDirectory.mkdir();
+        final File targetFile = new File(sourceDirectory, "hello.txt");
+        FileUtils.writeStringToFile(targetFile, "HELLO WORLD", "UTF8");
+
+        // Make a symlink to the file
+        final Path targetPath = targetFile.toPath();
+        final Path linkPath = sourceDirectory.toPath().resolve("linkfile");
+        Files.createSymbolicLink(linkPath, targetPath);
+        assumeTrue(Files.isSymbolicLink(linkPath), () -> "Expected a symlink here: " + linkPath);
+        assumeTrue(Files.exists(linkPath));
+        assumeTrue(Files.exists(linkPath, LinkOption.NOFOLLOW_LINKS));
+
+        // Delete the file file to break the symlink
+        assumeTrue(targetFile.delete());
+        assumeFalse(Files.exists(linkPath));
+        assumeTrue(Files.exists(linkPath, LinkOption.NOFOLLOW_LINKS));
+
+        // Now copy sourceDirectory, including the broken link, to another directory
+        final File destination = new File(tempDirFile, "destination");
+        FileUtils.copyDirectory(sourceDirectory, destination);
+        assertTrue(destination.exists());
+        final Path copiedBrokenSymlink = new File(destination, "linkfile").toPath();
+
+        // test for the existence of the copied symbolic link as a link
+        assertTrue(Files.isSymbolicLink(copiedBrokenSymlink));
+
+        // shouldn't be able to read through to the source of the link.
+        // If we can, then the link points somewhere other than the deleted file
+        assertFalse(Files.exists(copiedBrokenSymlink));
+    }
+
+    @Test
+    public void testCopyDirectory_SymbolicLink() throws IOException {
+        // Make a file
+        final File sourceDirectory = new File(tempDirFile, "source_directory");
+        sourceDirectory.mkdir();
+        final File targetFile = new File(sourceDirectory, "hello.txt");
+        FileUtils.writeStringToFile(targetFile, "HELLO WORLD", "UTF8");
+
+        // Make a symlink to the file
+        final Path targetPath = targetFile.toPath();
+        final Path linkPath = sourceDirectory.toPath().resolve("linkfile");
+        Files.createSymbolicLink(linkPath, targetPath);
+        assumeTrue(Files.isSymbolicLink(linkPath), () -> "Expected a symlink here: " + linkPath);
+        assumeTrue(Files.exists(linkPath));
+        assumeTrue(Files.exists(linkPath, LinkOption.NOFOLLOW_LINKS));
+
+        // Now copy sourceDirectory to another directory
+        final File destination = new File(tempDirFile, "destination");
+        FileUtils.copyDirectory(sourceDirectory, destination);
+        assertTrue(destination.exists());
+        final Path copiedSymlink = new File(destination, "linkfile").toPath();
+
+        // test for the existence of the copied symbolic link as a link
+        assertTrue(Files.isSymbolicLink(copiedSymlink));
+        assertTrue(Files.exists(copiedSymlink));
+    }
+
+    /**
+     * Test what happens when copyDirectory copies a directory that contains a symlink
+     * to a file outside the copied directory.
+     */
+    @Test
+    public void testCopyDirectory_SymbolicLinkExternalFile() throws Exception {
+        // make a file
+        final File content = new File(tempDirFile, "hello.txt");
+        FileUtils.writeStringToFile(content, "HELLO WORLD", "UTF8");
+
+        // Make a directory
+        final File realDirectory = new File(tempDirFile, "real_directory");
+        realDirectory.mkdir();
+
+        // Make a symlink to the file
+        final Path linkPath = realDirectory.toPath().resolve("link_to_file");
+        Files.createSymbolicLink(linkPath, content.toPath());
+
+        // Now copy the directory
+        final File destination = new File(tempDirFile, "destination");
+        FileUtils.copyDirectory(realDirectory, destination);
+
+        // test that the copied directory contains a link to the original file
+        final File copiedLink = new File(destination, "link_to_file");
+        assertTrue(Files.isSymbolicLink(copiedLink.toPath()));
+        final String actual = FileUtils.readFileToString(copiedLink, "UTF8");
+        assertEquals("HELLO WORLD", actual);
+
+        final Path source = Files.readSymbolicLink(copiedLink.toPath());
+        assertEquals(content.toPath(), source);
+    }
+
     @Test
     public void testCopyDirectoryExceptions() {
         //
@@ -790,26 +953,6 @@ public void testCopyDirectoryFiltered() throws IOException {
         assertEquals("file3.txt", files.get(2).getName());
     }
 
-//   @Test public void testToURLs2() throws Exception {
-//        File[] files = new File[] {
-//            new File(temporaryFolder, "file1.txt"),
-//            null,
-//        };
-//        URL[] urls = FileUtils.toURLs(files);
-//
-//        assertEquals(files.length, urls.length);
-//        assertTrue(urls[0].toExternalForm().startsWith("file:"));
-//        assertTrue(urls[0].toExternalForm().indexOf("file1.txt") > 0);
-//        assertEquals(null, urls[1]);
-//    }
-//
-//   @Test public void testToURLs3() throws Exception {
-//        File[] files = null;
-//        URL[] urls = FileUtils.toURLs(files);
-//
-//        assertEquals(0, urls.length);
-//    }
-
     @Test
     public void testCopyDirectoryPreserveDates() throws Exception {
         final File source = new File(tempDirFile, "source");
@@ -951,7 +1094,7 @@ public void testCopyDirectoryToExistingDest() throws Exception {
         subDir.mkdir();
         final File subFile = new File(subDir, "A.txt");
         FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
-        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
+        final File destDir = new File(SystemProperties.getJavaIoTmpdir(), "tmp-FileUtilsTestCase");
         FileUtils.deleteDirectory(destDir);
         destDir.mkdirs();
 
@@ -1050,6 +1193,27 @@ public void testCopyDirectoryWithPotentialFalsePartialMatch() throws IOException
         assertEquals(parFiles.size(), newFilePaths.size());
     }
 
+    @Test
+    public void testCopyFile_SymbolicLink() throws Exception {
+        // Make a file
+        final File sourceDirectory = new File(tempDirFile, "source_directory");
+        sourceDirectory.mkdir();
+        final File targetFile = new File(sourceDirectory, "hello.txt");
+        FileUtils.writeStringToFile(targetFile, "HELLO WORLD", "UTF8");
+
+        // Make a symlink to the file
+        final Path targetPath = targetFile.toPath();
+        final Path linkPath = sourceDirectory.toPath().resolve("linkfile");
+        Files.createSymbolicLink(linkPath, targetPath);
+
+        // Now copy symlink to another directory
+        final File destination = new File(tempDirFile, "destination");
+        FileUtils.copyFile(linkPath.toFile(), destination);
+        assertFalse(Files.isSymbolicLink(destination.toPath()));
+        final String contents = FileUtils.readFileToString(destination, StandardCharsets.UTF_8);
+        assertEquals("HELLO WORLD", contents);
+    }
+
     @Test
     public void testCopyFile1() throws Exception {
         final File destination = new File(tempDirFile, "copy1.txt");
@@ -1139,7 +1303,6 @@ public void testCopyFileLarge() throws Exception {
         final File largeFile = new File(tempDirFile, "large.txt");
         final File destination = new File(tempDirFile, "copylarge.txt");
 
-        System.out.println("START:   " + new java.util.Date());
         if (!largeFile.getParentFile().exists()) {
             fail("Cannot create file " + largeFile
                     + " as the parent directory does not exist");
@@ -1147,9 +1310,7 @@ public void testCopyFileLarge() throws Exception {
         try (final OutputStream output = new BufferedOutputStream(Files.newOutputStream(largeFile.toPath()))) {
             TestUtils.generateTestData(output, FileUtils.ONE_GB);
         }
-        System.out.println("CREATED: " + new java.util.Date());
         FileUtils.copyFile(largeFile, destination);
-        System.out.println("COPIED:  " + new java.util.Date());
 
         assertTrue(destination.exists(), "Check Exist");
         assertEquals(largeFile.length(), destination.length(), "Check Full copy");
@@ -1164,6 +1325,18 @@ public void testCopyFileToOutputStream() throws Exception {
         assertArrayEquals(expected, destination.toByteArray(), "Check Full copy");
     }
 
+    @Test
+    public void testCopyFileToReadOnlyDirectory() throws Exception {
+        final File directory = new File(tempDirFile, "readonly");
+        if (!directory.exists()) {
+            assumeTrue(directory.mkdirs());
+        }
+        assumeTrue(directory.setWritable(false));
+
+        assertThrows(IOException.class, () -> FileUtils.copyFileToDirectory(testFile1, directory),
+            "Should not be able to copy a file into a readonly directory");
+    }
+
     @Test
     public void testCopyToDirectoryWithDirectory() throws IOException {
         final File destDirectory = new File(tempDirFile, "destination");
@@ -1243,9 +1416,7 @@ public void testCopyToDirectoryWithIterable() throws IOException {
 
     @Test
     public void testCopyToDirectoryWithIterableSourceDoesNotExist() {
-        assertThrows(IOException.class,
-                () -> FileUtils.copyToDirectory(Collections.singleton(new File(tempDirFile, "doesNotExists")),
-                        tempDirFile));
+        assertThrows(IOException.class, () -> FileUtils.copyToDirectory(Collections.singleton(new File(tempDirFile, "doesNotExists")), tempDirFile));
     }
 
     @Test
@@ -1296,7 +1467,6 @@ public void testCopyURLToFileWithTimeout() throws Exception {
              InputStream resStream = getClass().getResourceAsStream(resourceName);) {
             assertTrue(IOUtils.contentEquals(resStream, fis), "Content is not equal.");
         }
-        //TODO Maybe test copy to itself like for copyFile()
     }
 
     /**
@@ -1377,10 +1547,73 @@ public void testDelete() throws Exception {
     }
 
     @Test
-    public void testDeleteDirectoryWithNonDirectory() {
+    public void testDeleteDirectoryFailsOnFile() {
+        // Fail request to delete a directory for a file
         assertThrows(IllegalArgumentException.class, () -> FileUtils.deleteDirectory(testFile1));
     }
 
+    @Test
+    public void testDeleteDirectoryNoopIfAbsent() {
+        // Noop on non-existent entry
+        assertDoesNotThrow(() -> FileUtils.deleteDirectory(new File("does not exist.nope")));
+    }
+
+    @Test
+    public void testDeleteDirectorySymbolicLink() throws IOException {
+        final Path symlinkedDir = createTempSymbolicLinkedRelativeDir().getLeft();
+        FileUtils.deleteDirectory(symlinkedDir.toFile());
+        assertFalse(Files.exists(symlinkedDir));
+    }
+
+    @Test
+    public void testDeleteDirectorySymbolicLinkAbsent() throws IOException {
+        final ImmutablePair<Path, Path> pair = createTempSymbolicLinkedRelativeDir();
+        final Path symlinkedDir = pair.getLeft();
+        final Path targetDir = pair.getRight();
+        assertTrue(Files.exists(symlinkedDir), symlinkedDir::toString);
+        Files.delete(symlinkedDir);
+        assertTrue(Files.exists(targetDir), targetDir::toString);
+        assertFalse(Files.exists(symlinkedDir), symlinkedDir::toString);
+        // actual test
+        FileUtils.deleteDirectory(symlinkedDir.toFile());
+        assertFalse(Files.exists(symlinkedDir), symlinkedDir::toString);
+    }
+
+    @Test
+    public void testDeleteDirectorySymbolicLinkAbsentDeepTarget() throws IOException {
+        final ImmutablePair<Path, Path> pair = createTempSymbolicLinkedRelativeDir();
+        final Path symLinkedDir = pair.getLeft();
+        final Path targetDir = pair.getRight();
+        // more setup
+        final Path targetDir2 = targetDir.resolve("subdir2");
+        final Path symLinkedDir2 = targetDir.resolve("symlinked-dir2");
+        Files.createDirectory(targetDir2);
+        Files.createSymbolicLink(symLinkedDir2, targetDir2);
+        assertTrue(Files.exists(symLinkedDir2), symLinkedDir2::toString);
+        // remove target directory, keeping symbolic link
+        Files.delete(targetDir2);
+        assertFalse(Files.exists(targetDir2), targetDir2::toString);
+        assertFalse(Files.exists(symLinkedDir2), symLinkedDir2::toString);
+        // actual test
+        FileUtils.deleteDirectory(targetDir.toFile());
+        assertFalse(Files.exists(targetDir), targetDir::toString);
+    }
+
+    @Test
+    public void testDeleteDirectorySymbolicLinkAbsentTarget() throws IOException {
+        final ImmutablePair<Path, Path> pair = createTempSymbolicLinkedRelativeDir();
+        final Path symlinkedDir = pair.getLeft();
+        final Path targetDir = pair.getRight();
+        assertTrue(Files.exists(symlinkedDir), symlinkedDir::toString);
+        // remove target directory, keeping symbolic link
+        Files.delete(targetDir);
+        assertFalse(Files.exists(targetDir), targetDir::toString);
+        assertFalse(Files.exists(symlinkedDir), symlinkedDir::toString);
+        // actual test
+        FileUtils.deleteDirectory(symlinkedDir.toFile());
+        assertFalse(Files.exists(symlinkedDir), symlinkedDir::toString);
+    }
+
     @Test
     public void testDeleteQuietlyDir() throws IOException {
         final File testDirectory = new File(tempDirFile, "testDeleteQuietlyDir");
@@ -1478,10 +1711,10 @@ public void testForceDeleteAFile2() throws Exception {
     }
 
     @Test
-    public void testForceDeleteAFile3() {
+    public void testForceDeleteAFileDoesNotExist() {
         final File destination = new File(tempDirFile, "no_such_file");
         assertFalse(destination.exists(), "Check No Exist");
-        assertThrows(IOException.class, () -> FileUtils.forceDelete(destination));
+        assertThrowsExactly(FileNotFoundException.class, () -> FileUtils.forceDelete(destination));
 
     }
 
@@ -1493,6 +1726,49 @@ public void testForceDeleteDir() throws Exception {
         assertFalse(testDirectory.exists(), "TestDirectory must not exist");
     }
 
+    /**
+     * TODO Passes on macOS, fails on Linux and Windows with AccessDeniedException.
+     */
+    @Test
+    @EnabledOnOs(value = OS.MAC)
+    public void testForceDeleteReadOnlyDirectory() throws Exception {
+        try (TempDirectory destDir = TempDirectory.create("dir-");
+                TempFile destination = TempFile.create(destDir, "test-", ".txt")) {
+            // sanity check structure
+            assertTrue(Files.isDirectory(destDir.get()));
+            assertEquals(destDir.get(), destination.get().getParent());
+            // sanity check attributes
+            final File file = destination.toFile();
+            assertTrue(file.setReadOnly());
+            assertTrue(file.canRead());
+            assertFalse(file.canWrite());
+            // sanity check that File.delete() deletes a read-only directory.
+            final PathCounters delete = destDir.delete();
+            assertEquals(1, delete.getDirectoryCounter().get());
+            assertEquals(1, delete.getFileCounter().get());
+            assertFalse(file.exists());
+            assertFalse(destDir.exists());
+        }
+        try (TempDirectory destDir = TempDirectory.create("dir-");
+                TempFile destination = TempFile.create(destDir, "test-", ".txt")) {
+            // sanity check structure
+            assertTrue(Files.isDirectory(destDir.get()));
+            assertEquals(destDir.get(), destination.get().getParent());
+            // sanity check attributes
+            final File dir = destDir.toFile();
+            // real test
+            assertTrue(dir.setReadOnly());
+            assertTrue(dir.canRead());
+            assertFalse(dir.canWrite());
+            assertTrue(dir.exists(), "File doesn't exist to delete");
+            // TODO Passes on macOS, fails on Linux and Windows with AccessDeniedException.
+            FileUtils.forceDelete(dir);
+            assertFalse(destination.exists(), "Check deletion");
+            assertFalse(dir.exists(), "Check deletion");
+            assertFalse(destDir.exists(), "Check deletion");
+        }
+    }
+
     @Test
     public void testForceDeleteReadOnlyFile() throws Exception {
         try (TempFile destination = TempFile.create("test-", ".txt")) {
@@ -1515,6 +1791,77 @@ public void testForceDeleteReadOnlyFile() throws Exception {
         }
     }
 
+    /**
+     * TODO Passes on macOS, fails on Linux and Windows with AccessDeniedException.
+     */
+    @Test
+    @EnabledOnOs(value = OS.MAC)
+    public void testForceDeleteUnwritableDirectory() throws Exception {
+        try (TempDirectory destDir = TempDirectory.create("dir-");
+                TempFile file = TempFile.create(destDir, "test-", ".txt")) {
+            // sanity check structure
+            assertTrue(Files.isDirectory(destDir.get()));
+            assertEquals(destDir.get(), file.get().getParent());
+            // sanity check attributes
+            final File dir = destDir.toFile();
+            assertTrue(dir.canWrite());
+            // Windows: setWritable(false) returns false.
+            assertTrue(dir.setWritable(false), () -> "setWritable(false) on " + dir);
+            assertFalse(dir.canWrite());
+            assertTrue(dir.canRead());
+            // sanity check that File.delete() cannot delete non-empty directories.
+            assertFalse(dir.delete());
+            // delete underlying file.
+            assertFalse(file.toFile().delete());
+            // reset attribute so we can delete file and auto-close/delete dir.
+            assertTrue(dir.setWritable(true));
+            assertTrue(file.toFile().delete());
+        }
+        try (TempDirectory destDir = TempDirectory.create("dir-");
+                TempFile file = TempFile.create(destDir, "test-", ".txt")) {
+            // sanity check structure
+            assertTrue(Files.isDirectory(destDir.get()));
+            assertEquals(destDir.get(), file.get().getParent());
+            // sanity check attributes
+            final File dir = destDir.toFile();
+            assertTrue(dir.canWrite());
+            assertTrue(dir.setWritable(false));
+            assertFalse(dir.canWrite());
+            assertTrue(dir.canRead());
+            // sanity check that File.delete() cannot delete non-empty directories.
+            assertFalse(dir.delete());
+            // test
+            // Linux: Fails with AccessDeniedException.
+            FileUtils.forceDelete(dir);
+            assertFalse(file.exists());
+            assertFalse(dir.exists());
+        }
+    }
+
+    @Test
+    public void testForceDeleteUnwritableFile() throws Exception {
+        try (TempFile destination = TempFile.create("test-", ".txt")) {
+            final File file = destination.toFile();
+            assertTrue(file.canWrite());
+            assertTrue(file.setWritable(false));
+            assertFalse(file.canWrite());
+            assertTrue(file.canRead());
+            // sanity check that File.delete() deletes unwritable files.
+            assertTrue(file.delete());
+        }
+        try (TempFile destination = TempFile.create("test-", ".txt")) {
+            final File file = destination.toFile();
+            // real test
+            assertTrue(file.canWrite());
+            assertTrue(file.setWritable(false));
+            assertFalse(file.canWrite());
+            assertTrue(file.canRead());
+            assertTrue(file.exists(), "File doesn't exist to delete");
+            FileUtils.forceDelete(file);
+            assertFalse(file.exists(), "Check deletion");
+        }
+    }
+
     @Test
     public void testForceMkdir() throws Exception {
         // Tests with existing directory
@@ -1591,23 +1938,24 @@ public void testGetTempDirectory() {
 
     @Test
     public void testGetTempDirectoryPath() {
-        assertEquals(System.getProperty("java.io.tmpdir"), FileUtils.getTempDirectoryPath());
+        assertEquals(SystemProperties.getJavaIoTmpdir(), FileUtils.getTempDirectoryPath());
     }
 
     @Test
     public void testGetUserDirectory() {
-        final File userDirectory = new File(System.getProperty("user.home"));
+        final File userDirectory = new File(SystemProperties.getUserHome());
         assertEquals(userDirectory, FileUtils.getUserDirectory());
     }
 
     @Test
     public void testGetUserDirectoryPath() {
-        assertEquals(System.getProperty("user.home"), FileUtils.getUserDirectoryPath());
+        assertEquals(SystemProperties.getUserHome(), FileUtils.getUserDirectoryPath());
     }
 
     @Test
     public void testIO276() throws Exception {
         final File dir = new File("target", "IO276");
+        Files.deleteIfExists(dir.toPath());
         assertTrue(dir.mkdirs(), dir + " should not be present");
         final File file = new File(dir, "IO276.txt");
         assertTrue(file.createNewFile(), file + " should not be present");
@@ -1669,7 +2017,7 @@ public void testIsEmptyDirectory() throws IOException {
             final File tempDirAsFile = tempDir.toFile();
             Assertions.assertTrue(FileUtils.isEmptyDirectory(tempDirAsFile));
         }
-        Assertions.assertFalse(FileUtils.isEmptyDirectory(PathUtilsIsEmptyTest.DIR_SIZE_1.toFile()));
+        Assertions.assertFalse(FileUtils.isEmptyDirectory(DIR_SIZE_1.toFile()));
     }
 
     @ParameterizedTest
@@ -1750,7 +2098,7 @@ public void testIsFileNewerOlder(final long millis) throws Exception {
         assertFalse(FileUtils.isFileNewer(newFile, localDatePlusDay, localTime0), "New File - Newer - LocalDate plus one day,LocalTime");
         assertFalse(FileUtils.isFileNewer(newFile, localDatePlusDay, offsetTime0), "New File - Newer - LocalDate plus one day,OffsetTime");
         assertFalse(FileUtils.isFileNewer(invalidFile, refFile), "Illegal - Newer - File");
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.isFileNewer(newFile, invalidFile));
+        assertThrows(UncheckedIOException.class, () -> FileUtils.isFileNewer(newFile, invalidFile));
 
         // Test isFileOlder()
         assertTrue(FileUtils.isFileOlder(oldFile, refFile), "Old File - Older - File");
@@ -1784,7 +2132,7 @@ public void testIsFileNewerOlder(final long millis) throws Exception {
         assertTrue(FileUtils.isFileOlder(newFile, localDatePlusDay, offsetTime0), "New File - Older - LocalDate plus one day,OffsetTime");
 
         assertFalse(FileUtils.isFileOlder(invalidFile, refFile), "Illegal - Older - File");
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.isFileOlder(newFile, invalidFile));
+        assertThrows(UncheckedIOException.class, () -> FileUtils.isFileOlder(newFile, invalidFile));
 
         // Null File
         assertThrows(NullPointerException.class, () -> FileUtils.isFileNewer(null, now));
@@ -1793,12 +2141,12 @@ public void testIsFileNewerOlder(final long millis) throws Exception {
         assertThrows(NullPointerException.class, () -> FileUtils.isFileNewer(oldFile, (File) null));
 
         // Invalid reference File
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.isFileNewer(oldFile, invalidFile));
+        assertThrows(UncheckedIOException.class, () -> FileUtils.isFileNewer(oldFile, invalidFile));
 
         // Null reference Date
         assertThrows(NullPointerException.class, () -> FileUtils.isFileNewer(oldFile, (Date) null));
 
-        // ----- Test isFileOlder() exceptions -----
+        // Test isFileOlder() exceptions
         // Null File
         assertThrows(NullPointerException.class, () -> FileUtils.isFileOlder(null, now));
 
@@ -1809,7 +2157,7 @@ public void testIsFileNewerOlder(final long millis) throws Exception {
         assertThrows(NullPointerException.class, () -> FileUtils.isFileOlder(oldFile, (Date) null));
 
         // Invalid reference File
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.isFileOlder(oldFile, invalidFile));
+        assertThrows(UncheckedIOException.class, () -> FileUtils.isFileOlder(oldFile, invalidFile));
     }
 
     @Test
@@ -1914,7 +2262,6 @@ public void testIterateFilesAndDirs() throws IOException {
             iterateFilesAndDirs(subDir1, fileFilterAllFiles, fileFilterAllDirs, expectedFilesAndDirs);
             //
             // "*.txt" and "*"
-            final int filesCount;
             expectedFilesAndDirs = Arrays.asList(subDir1, subDir2, someFile, subDir3, subDir4);
             iterateFilesAndDirs(subDir1, fileFilterExtTxt, fileFilterAllDirs, expectedFilesAndDirs);
             //
@@ -2590,7 +2937,7 @@ public void testSizeOfDirectory() throws Exception {
         file.mkdir();
 
         // Create a cyclic symlink
-        this.createCircularSymLink(file);
+        createCircularSymbolicLink(file);
 
         assertEquals(TEST_DIRECTORY_SIZE, FileUtils.sizeOfDirectory(file), "Unexpected directory size");
     }
@@ -2609,7 +2956,7 @@ public void testSizeOfDirectoryAsBigInteger() throws Exception {
         // Null argument
         assertThrows(NullPointerException.class, () -> FileUtils.sizeOfDirectoryAsBigInteger(null));
         // Non-existent file
-        assertThrows(IllegalArgumentException.class, () -> FileUtils.sizeOfDirectoryAsBigInteger(file));
+        assertThrows(UncheckedIOException.class, () -> FileUtils.sizeOfDirectoryAsBigInteger(file));
 
         // Creates file
         file.createNewFile();
@@ -2621,7 +2968,7 @@ public void testSizeOfDirectoryAsBigInteger() throws Exception {
         file.delete();
         file.mkdir();
 
-        createCircularSymLink(file);
+        createCircularSymbolicLink(file);
 
         assertEquals(TEST_DIRECTORY_SIZE_BI, FileUtils.sizeOfDirectoryAsBigInteger(file), "Unexpected directory size");
 
@@ -2799,6 +3146,23 @@ public void testToURLs1() throws Exception {
         assertTrue(urls[2].toExternalForm().contains("test%20file.txt"));
     }
 
+    @Test
+    public void testToURLs2() {
+        final File[] files = {
+            new File(tempDirFile, "file1.txt"),
+            null,
+        };
+        assertThrows(NullPointerException.class, () -> FileUtils.toURLs(files),
+                "Can't convert null URL");
+    }
+
+    @Test
+    public void testToURLs3() {
+        final File[] files = null;
+        assertThrows(NullPointerException.class, () -> FileUtils.toURLs(files),
+                "Can't convert null list");
+    }
+
     @Test
     public void testToURLs3a() throws Exception {
         final File[] files = {}; // empty array
@@ -2917,7 +3281,6 @@ public void testWriteCharSequence2() throws Exception {
         TestUtils.assertEqualContent(text, file);
     }
 
-
     @Test
     public void testWriteLines_3arg_nullSeparator() throws Exception {
         final Object[] data = {
@@ -2925,19 +3288,19 @@ public void testWriteLines_3arg_nullSeparator() throws Exception {
         final List<Object> list = Arrays.asList(data);
 
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", list);
+        FileUtils.writeLines(file, StandardCharsets.US_ASCII.name(), list);
 
         final String expected = "hello" + System.lineSeparator() + "world" + System.lineSeparator() +
                 System.lineSeparator() + "this is" + System.lineSeparator() +
                 System.lineSeparator() + "some text" + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file, "US-ASCII");
+        final String actual = FileUtils.readFileToString(file, StandardCharsets.US_ASCII.name());
         assertEquals(expected, actual);
     }
 
     @Test
     public void testWriteLines_3argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        FileUtils.writeStringToFile(file, "This line was there before you...", StandardCharsets.UTF_8);
 
         final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
         FileUtils.writeLines(file, linesToAppend, false);
@@ -2952,7 +3315,7 @@ public void testWriteLines_3argsWithAppendOptionFalse_ShouldDeletePreviousFileLi
     @Test
     public void testWriteLines_3argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        FileUtils.writeStringToFile(file, "This line was there before you...", StandardCharsets.UTF_8);
 
         final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
         FileUtils.writeLines(file, linesToAppend, true);
@@ -2972,10 +3335,10 @@ public void testWriteLines_4arg() throws Exception {
         final List<Object> list = Arrays.asList(data);
 
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", list, "*");
+        FileUtils.writeLines(file, StandardCharsets.US_ASCII.name(), list, "*");
 
         final String expected = "hello*world**this is**some text*";
-        final String actual = FileUtils.readFileToString(file, "US-ASCII");
+        final String actual = FileUtils.readFileToString(file, StandardCharsets.US_ASCII.name());
         assertEquals(expected, actual);
     }
 
@@ -2986,19 +3349,19 @@ public void testWriteLines_4arg_nullSeparator() throws Exception {
         final List<Object> list = Arrays.asList(data);
 
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", list, null);
+        FileUtils.writeLines(file, StandardCharsets.US_ASCII.name(), list, null);
 
         final String expected = "hello" + System.lineSeparator() + "world" + System.lineSeparator() +
                 System.lineSeparator() + "this is" + System.lineSeparator() +
                 System.lineSeparator() + "some text" + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file, "US-ASCII");
+        final String actual = FileUtils.readFileToString(file, StandardCharsets.US_ASCII.name());
         assertEquals(expected, actual);
     }
 
     @Test
     public void testWriteLines_4arg_Writer_nullData() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", null, "*");
+        FileUtils.writeLines(file, StandardCharsets.US_ASCII.name(), null, "*");
 
         assertEquals(0, file.length(), "Sizes differ");
     }
@@ -3138,11 +3501,9 @@ public void testWriteStringToFileIntoNonExistentSubdir() throws Exception {
      */
     @Test
     public void testWriteStringToFileIntoSymlinkedDir() throws Exception {
-        final Path symlinkDir = createTempSymlinkedRelativeDir();
-
+        final Path symlinkDir = createTempSymbolicLinkedRelativeDir().getLeft();
         final File file = symlinkDir.resolve("file").toFile();
         FileUtils.writeStringToFile(file, "Hello /u1234", StandardCharsets.UTF_8);
-
         final byte[] text = "Hello /u1234".getBytes();
         TestUtils.assertEqualContent(text, file);
     }
@@ -3199,7 +3560,7 @@ public void testWriteStringToFileWithNullStringCharset() throws Exception {
     @Test
     public void testWriteWithEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        FileUtils.writeStringToFile(file, "This line was there before you...", StandardCharsets.UTF_8);
 
         FileUtils.write(file, "this is brand new data", (String) null, false);
 
@@ -3211,7 +3572,7 @@ public void testWriteWithEncoding_WithAppendOptionFalse_ShouldDeletePreviousFile
     @Test
     public void testWriteWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        FileUtils.writeStringToFile(file, "This line was there before you...", StandardCharsets.UTF_8);
 
         FileUtils.write(file, "this is brand new data", (String) null, true);
 
diff --git a/src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java b/src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java
index a601b273..69a87e30 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java
@@ -16,12 +16,15 @@
  */
 package org.apache.commons.io;
 
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-import java.util.concurrent.CountDownLatch;
+import java.io.File;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
 
 /**
  * Tests FileUtils.waitFor().
@@ -33,36 +36,71 @@
  */
 public class FileUtilsWaitForTest {
 
-    @Test
-    public void testWaitFor0() {
-        FileUtils.waitFor(FileUtils.current(), 0);
-    }
+    // Assume that this file does not exist
+    private final File NOSUCHFILE = new File("a.b.c.d." + System.currentTimeMillis());
 
-    /**
-     * TODO Fails randomly.
-     */
     @Test
-    public void testWaitForInterrupted() throws InterruptedException {
+    public void testIO_488() throws InterruptedException {
+        final long start = System.currentTimeMillis();
         final AtomicBoolean wasInterrupted = new AtomicBoolean();
-        final CountDownLatch started = new CountDownLatch(2);
-        final int seconds = 10;
+        final int seconds = 3;
         final Thread thread1 = new Thread(() -> {
-            started.countDown();
-            assertTrue(FileUtils.waitFor(FileUtils.current(), seconds));
+            // This will wait (assuming the file is not found)
+            assertFalse(FileUtils.waitFor(NOSUCHFILE, seconds), "Should not find file");
             wasInterrupted.set(Thread.currentThread().isInterrupted());
         });
         thread1.start();
-        // Make sure the thread does not finish before we interrupt it:
-        started.countDown();
-        thread1.interrupt();
-        started.await();
+        Thread.sleep(500); // This should be enough to ensure the waitFor loop has been entered
+        thread1.interrupt(); // Try to interrupt waitFor
         thread1.join();
-        assertTrue(wasInterrupted.get());
+        assertTrue(wasInterrupted.get(), "Should have been interrupted");
+        final long elapsed = System.currentTimeMillis() - start;
+        assertTrue(elapsed >= seconds * 1000, "Should wait for n seconds, actual: " + elapsed);
+    }
+
+    @Test
+    @Timeout(value = 30, unit = TimeUnit.MILLISECONDS) // Should complete quickly as the path is present
+    public void testWaitFor0() {
+        assertTrue(FileUtils.waitFor(FileUtils.current(), 0));
+    }
+
+    @Test
+    @Timeout(value = 30, unit = TimeUnit.MILLISECONDS) // Should complete quickly even though the path is missing
+    public void testWaitFor0Absent() {
+        assertFalse(FileUtils.waitFor(NOSUCHFILE, 0));
+    }
+
+    @Test
+    @Timeout(value = 30, unit = TimeUnit.MILLISECONDS) // Should complete quickly as the path is present
+    public void testWaitFor10() {
+        assertTrue(FileUtils.waitFor(FileUtils.current(), 10));
+    }
+
+    @Test
+    @Timeout(value = 30, unit = TimeUnit.MILLISECONDS) // Should complete quickly as the path is present
+    public void testWaitFor100() {
+        assertTrue(FileUtils.waitFor(FileUtils.current(), 100));
     }
 
     @Test
+    @Timeout(value = 3, unit = TimeUnit.SECONDS) // Allow for timeout waiting for non-existent file
+    public void testWaitFor5Absent() {
+        final long start = System.currentTimeMillis();
+        assertFalse(FileUtils.waitFor(NOSUCHFILE, 2));
+        final long elapsed = System.currentTimeMillis() - start;
+        assertTrue(elapsed >= 2000, "Must reach timeout - expected 2000, actual: " + elapsed);
+    }
+
+    @Test
+    @Timeout(value = 300, unit = TimeUnit.MILLISECONDS) // Should complete quickly as the path is present
     public void testWaitForNegativeDuration() {
-        FileUtils.waitFor(FileUtils.current(), -1);
+        assertTrue(FileUtils.waitFor(FileUtils.current(), -1));
+    }
+
+    @Test
+    @Timeout(value = 30, unit = TimeUnit.MILLISECONDS) // Should complete quickly even though the path is missing
+    public void testWaitForNegativeDurationAbsent() {
+        assertFalse(FileUtils.waitFor(NOSUCHFILE, -1));
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/FilenameUtilsTest.java b/src/test/java/org/apache/commons/io/FilenameUtilsTest.java
index 31b750ef..00618f9b 100644
--- a/src/test/java/org/apache/commons/io/FilenameUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/FilenameUtilsTest.java
@@ -202,6 +202,7 @@ public void testEqualsNormalizedOnSystem() {
         assertEquals(WINDOWS, FilenameUtils.equalsNormalizedOnSystem("file.txt", "FILE.TXT"));
         assertTrue(FilenameUtils.equalsNormalizedOnSystem("a\\b\\file.txt", "a/b/file.txt"));
         assertFalse(FilenameUtils.equalsNormalizedOnSystem("a/b/", "a/b"));
+        assertFalse(FilenameUtils.equalsNormalizedOnSystem("//a.html", "//ab.html"));
     }
 
     @Test
@@ -407,7 +408,6 @@ public void testGetPath() {
         assertEquals("a/b/", FilenameUtils.getPath("~user/a/b/c.txt"));
     }
 
-
     @Test
     public void testGetPath_with_null_character() {
         assertThrows(IllegalArgumentException.class, () -> FilenameUtils.getPath("~user/a/\u0000b/c.txt"));
@@ -934,7 +934,7 @@ public void testNormalize_with_null_character() {
 
     @Test
     public void testNormalizeFromJavaDoc() {
-        // Examples from javadoc
+        // Examples from Javadoc
         assertEquals(SEP + "foo" + SEP, FilenameUtils.normalize("/foo//"));
         assertEquals(SEP + "foo" + SEP, FilenameUtils.normalize(SEP + "foo" + SEP + "." + SEP));
         assertEquals(SEP + "bar", FilenameUtils.normalize(SEP + "foo" + SEP + ".." + SEP + "bar"));
diff --git a/src/test/java/org/apache/commons/io/IOCaseTest.java b/src/test/java/org/apache/commons/io/IOCaseTest.java
index 6ca30c0c..afd85cc6 100644
--- a/src/test/java/org/apache/commons/io/IOCaseTest.java
+++ b/src/test/java/org/apache/commons/io/IOCaseTest.java
@@ -119,7 +119,6 @@ public void test_checkEndsWith_functionality() {
         assertFalse(IOCase.SENSITIVE.checkEndsWith(null, null));
     }
 
-
     @Test
     public void test_checkEquals_case() {
         assertTrue(IOCase.SENSITIVE.checkEquals("ABC", "ABC"));
@@ -144,15 +143,18 @@ public void test_checkEquals_functionality() {
         assertFalse(IOCase.SENSITIVE.checkEquals("", "ABC"));
         assertTrue(IOCase.SENSITIVE.checkEquals("", ""));
 
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkEquals("ABC", null));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkEquals(null, "ABC"));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkEquals(null, null));
+        assertFalse(IOCase.SENSITIVE.checkEquals("ABC", null));
+        assertFalse(IOCase.SENSITIVE.checkEquals(null, "ABC"));
+        assertTrue(IOCase.SENSITIVE.checkEquals(null, null));
     }
 
     @Test
     public void test_checkIndexOf_case() {
         assertEquals(1,  IOCase.SENSITIVE.checkIndexOf("ABC", 0, "BC"));
         assertEquals(-1, IOCase.SENSITIVE.checkIndexOf("ABC", 0, "Bc"));
+        assertEquals(-1, IOCase.SENSITIVE.checkIndexOf(null, 0, "Bc"));
+        assertEquals(-1, IOCase.SENSITIVE.checkIndexOf(null, 0, null));
+        assertEquals(-1, IOCase.SENSITIVE.checkIndexOf("ABC", 0, null));
 
         assertEquals(1, IOCase.INSENSITIVE.checkIndexOf("ABC", 0, "BC"));
         assertEquals(1, IOCase.INSENSITIVE.checkIndexOf("ABC", 0, "Bc"));
@@ -200,9 +202,9 @@ public void test_checkIndexOf_functionality() {
         // too long
         assertEquals(-1,   IOCase.SENSITIVE.checkIndexOf("DEF", 0, "ABCDEFGHIJ"));
 
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkIndexOf("ABC", 0, null));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkIndexOf(null, 0, "ABC"));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkIndexOf(null, 0, null));
+        assertEquals(-1, IOCase.SENSITIVE.checkIndexOf("ABC", 0, null));
+        assertEquals(-1, IOCase.SENSITIVE.checkIndexOf(null, 0, "ABC"));
+        assertEquals(-1, IOCase.SENSITIVE.checkIndexOf(null, 0, null));
     }
 
     @Test
@@ -239,12 +241,12 @@ public void test_checkRegionMatches_functionality() {
         assertFalse(IOCase.SENSITIVE.checkRegionMatches("", 1, "ABC"));
         assertFalse(IOCase.SENSITIVE.checkRegionMatches("", 1, ""));
 
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkRegionMatches("ABC", 0, null));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkRegionMatches(null, 0, "ABC"));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkRegionMatches(null, 0, null));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkRegionMatches("ABC", 1, null));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkRegionMatches(null, 1, "ABC"));
-        assertThrows(NullPointerException.class, () -> IOCase.SENSITIVE.checkRegionMatches(null, 1, null));
+        assertFalse(IOCase.SENSITIVE.checkRegionMatches("ABC", 0, null));
+        assertFalse(IOCase.SENSITIVE.checkRegionMatches(null, 0, "ABC"));
+        assertFalse(IOCase.SENSITIVE.checkRegionMatches(null, 0, null));
+        assertFalse(IOCase.SENSITIVE.checkRegionMatches("ABC", 1, null));
+        assertFalse(IOCase.SENSITIVE.checkRegionMatches(null, 1, "ABC"));
+        assertFalse(IOCase.SENSITIVE.checkRegionMatches(null, 1, null));
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java b/src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java
index 6f5d7bdb..b01bc04a 100644
--- a/src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java
+++ b/src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java
@@ -36,7 +36,7 @@ public class IOExceptionWithCauseTest {
     public void testIOExceptionStringThrowable() {
         final Throwable cause = new IllegalArgumentException("cause");
         final IOException exception = new IOException("message", cause);
-        this.validate(exception, cause, "message");
+        validate(exception, cause, "message");
     }
 
     /**
@@ -47,7 +47,7 @@ public void testIOExceptionStringThrowable() {
     public void testIOExceptionThrowable() {
         final Throwable cause = new IllegalArgumentException("cause");
         final IOException exception = new IOException(cause);
-        this.validate(exception, cause, "java.lang.IllegalArgumentException: cause");
+        validate(exception, cause, "java.lang.IllegalArgumentException: cause");
     }
 
     void validate(final Throwable throwable, final Throwable expectedCause, final String expectedMessage) {
diff --git a/src/test/java/org/apache/commons/io/IORandomAccessFileTest.java b/src/test/java/org/apache/commons/io/IORandomAccessFileTest.java
new file mode 100644
index 00000000..0e832049
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/IORandomAccessFileTest.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.apache.commons.io.build.AbstractOriginTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+
+/**
+ * Tests {@link IORandomAccessFile}.
+ */
+public class IORandomAccessFileTest {
+
+    protected static final String FILE_NAME_RW = "target/" + AbstractOriginTest.class.getSimpleName() + ".txt";
+
+    private File newFileFixture() throws IOException {
+        final File file = new File(FILE_NAME_RW);
+        FileUtils.touch(file);
+        return file;
+    }
+
+    @ParameterizedTest
+    @EnumSource(RandomAccessFileMode.class)
+    public void testFile(final RandomAccessFileMode mode) throws IOException {
+        final File file = newFileFixture();
+        final String modeStr = mode.getMode();
+        try (IORandomAccessFile raf = new IORandomAccessFile(file, modeStr)) {
+            assertEquals(file, raf.getFile());
+            assertEquals(modeStr, raf.getMode());
+        }
+    }
+
+    @ParameterizedTest
+    @EnumSource(RandomAccessFileMode.class)
+    public void testString(final RandomAccessFileMode mode) throws IOException {
+        final File file = newFileFixture();
+        final String modeStr = mode.getMode();
+        try (IORandomAccessFile raf = new IORandomAccessFile(FILE_NAME_RW, modeStr)) {
+            assertEquals(file, raf.getFile());
+            assertEquals(modeStr, raf.getMode());
+        }
+    }
+
+    @Test
+    public void testToString() throws IOException {
+        final File file = newFileFixture();
+        try (IORandomAccessFile raf = new IORandomAccessFile(FILE_NAME_RW, "r")) {
+            assertEquals(file.toString(), raf.toString());
+        }
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/IOUtilsCopyTest.java b/src/test/java/org/apache/commons/io/IOUtilsCopyTest.java
index 1dbe9c2b..3cc973a1 100644
--- a/src/test/java/org/apache/commons/io/IOUtilsCopyTest.java
+++ b/src/test/java/org/apache/commons/io/IOUtilsCopyTest.java
@@ -99,19 +99,19 @@ public void testCopy_inputStreamToOutputStream() throws Exception {
     }
 
     /**
-     * Test Copying file > 2GB  - see issue# IO-84
+     * Test Copying file > 2GB - see issue# IO-84
      */
     @Test
     public void testCopy_inputStreamToOutputStream_IO84() throws Exception {
-        final long size = (long)Integer.MAX_VALUE + (long)1;
-        final InputStream  in  = new NullInputStream(size);
+        final long size = (long) Integer.MAX_VALUE + (long) 1;
+        final NullInputStream in = new NullInputStream(size);
         final OutputStream out = NullOutputStream.INSTANCE;
 
         // Test copy() method
         assertEquals(-1, IOUtils.copy(in, out));
 
         // reset the input
-        in.close();
+        in.init();
 
         // Test copyLarge() method
         assertEquals(size, IOUtils.copyLarge(in, out), "copyLarge()");
@@ -420,7 +420,7 @@ public void testCopy_readerToWriter() throws Exception {
      */
     @Test
     public void testCopy_readerToWriter_IO84() throws Exception {
-        final long size = (long)Integer.MAX_VALUE + (long)1;
+        final long size = (long) Integer.MAX_VALUE + (long) 1;
         final Reader reader = new NullReader(size);
         final Writer writer = new NullWriter();
 
diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java
index c921abc1..da57350c 100644
--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java
@@ -26,6 +26,7 @@
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -147,15 +148,11 @@ public void setUp() {
             if (!testFile.getParentFile().exists()) {
                 throw new IOException("Cannot create file " + testFile + " as the parent directory does not exist");
             }
-            final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath));
-            try {
+            try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {
                 TestUtils.generateTestData(output, FILE_SIZE);
-            } finally {
-                IOUtils.closeQuietly(output);
             }
-        } catch (final IOException ioe) {
-            throw new RuntimeException(
-                "Can't run this test because the environment could not be built: " + ioe.getMessage());
+        } catch (final IOException e) {
+            fail("Can't run this test because the environment could not be built: " + e.getMessage());
         }
         // Create and init a byte array as input data
         iarr = new byte[200];
@@ -484,14 +481,14 @@ public void testConstants() {
     @Test
     public void testConsumeInputStream() throws Exception {
         final long size = (long) Integer.MAX_VALUE + (long) 1;
-        final InputStream in = new NullInputStream(size);
+        final NullInputStream in = new NullInputStream(size);
         final OutputStream out = NullOutputStream.INSTANCE;
 
         // Test copy() method
         assertEquals(-1, IOUtils.copy(in, out));
 
         // reset the input
-        in.close();
+        in.init();
 
         // Test consume() method
         assertEquals(size, IOUtils.consume(in), "consume()");
@@ -1018,6 +1015,36 @@ public void testReadFully_Reader_Offset() throws Exception {
         IOUtils.closeQuietly(reader);
     }
 
+    @Test
+    public void testReadLines_CharSequence() throws IOException {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        CharSequence csq = null;
+        try {
+            final String[] data = {"hello", "/u1234", "", "this is", "some text"};
+            TestUtils.createLineBasedFile(file, data);
+            csq = new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);
+            final List<String> lines = IOUtils.readLines(csq);
+            assertEquals(Arrays.asList(data), lines);
+        } finally {
+            TestUtils.deleteFile(file);
+        }
+    }
+
+    @Test
+    public void testReadLines_CharSequenceAsStringBuilder() throws IOException {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        StringBuilder csq = null;
+        try {
+            final String[] data = {"hello", "/u1234", "", "this is", "some text"};
+            TestUtils.createLineBasedFile(file, data);
+            csq = new StringBuilder(new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8));
+            final List<String> lines = IOUtils.readLines(csq);
+            assertEquals(Arrays.asList(data), lines);
+        } finally {
+            TestUtils.deleteFile(file);
+        }
+    }
+
     @Test
     public void testReadLines_InputStream() throws Exception {
         final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
@@ -1061,7 +1088,6 @@ public void testReadLines_Reader() throws Exception {
         try {
             final String[] data = {"hello", "/u1234", "", "this is", "some text"};
             TestUtils.createLineBasedFile(file, data);
-
             in = new InputStreamReader(Files.newInputStream(file.toPath()));
             final List<String> lines = IOUtils.readLines(in);
             assertEquals(Arrays.asList(data), lines);
@@ -1269,7 +1295,7 @@ public void testSingleEOL(final String s1, final String s2, final boolean ifEqua
         assertTrue(IOUtils.contentEqualsIgnoreEOL(
                 new CharArrayReader(s1.toCharArray()),
                 new CharArrayReader(s1.toCharArray())
-        ),"failed at :{" + s1 + "," + s1 + "}");
+        ), "failed at :{" + s1 + "," + s1 + "}");
         assertTrue(IOUtils.contentEqualsIgnoreEOL(
                 new CharArrayReader(s2.toCharArray()),
                 new CharArrayReader(s2.toCharArray())
@@ -1683,7 +1709,7 @@ private void testToString_URI(final String encoding) throws Exception {
 
     @Test
     public void testToString_URI_CharsetName() throws Exception {
-        testToString_URI("US-ASCII");
+        testToString_URI(StandardCharsets.US_ASCII.name());
     }
 
     @Test
@@ -1708,7 +1734,7 @@ private void testToString_URL(final String encoding) throws Exception {
 
     @Test
     public void testToString_URL_CharsetName() throws Exception {
-        testToString_URL("US-ASCII");
+        testToString_URL(StandardCharsets.US_ASCII.name());
     }
 
     @Test
@@ -1753,7 +1779,7 @@ public void testWriteBigString() throws IOException {
     public void testWriteLines() throws IOException {
         final String[] data = {"The", "quick"};
         final ByteArrayOutputStream out = new ByteArrayOutputStream();
-        IOUtils.writeLines(Arrays.asList(data), "\n", out, "UTF-16");
+        IOUtils.writeLines(Arrays.asList(data), "\n", out, StandardCharsets.UTF_16.name());
         final String result = new String(out.toByteArray(), StandardCharsets.UTF_16);
         assertEquals("The\nquick\n", result);
     }
diff --git a/src/test/java/org/apache/commons/io/IOUtilsWriteTest.java b/src/test/java/org/apache/commons/io/IOUtilsWriteTest.java
index ded62ee7..8ebe4660 100644
--- a/src/test/java/org/apache/commons/io/IOUtilsWriteTest.java
+++ b/src/test/java/org/apache/commons/io/IOUtilsWriteTest.java
@@ -558,7 +558,7 @@ public void testWriteLines_OutputStream_Encoding_nullData() throws Exception {
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final ThrowOnFlushAndCloseOutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
-        IOUtils.writeLines(null, "*", out, "US-ASCII");
+        IOUtils.writeLines(null, "*", out, StandardCharsets.US_ASCII.name());
         out.off();
         out.flush();
 
@@ -592,7 +592,7 @@ public void testWriteLines_OutputStream_Encoding_nullSeparator() throws Exceptio
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final ThrowOnFlushAndCloseOutputStream out = new ThrowOnFlushAndCloseOutputStream(baout, false, true);
 
-        IOUtils.writeLines(list, null, out, "US-ASCII");
+        IOUtils.writeLines(list, null, out, StandardCharsets.US_ASCII.name());
         out.off();
         out.flush();
 
@@ -603,9 +603,9 @@ public void testWriteLines_OutputStream_Encoding_nullSeparator() throws Exceptio
 
     @Test
     public void testWriteLines_OutputStream_Encoding_nullStream() throws Exception {
-        final Object[] data = {"hello", "world"};
+        final Object[] data = { "hello", "world" };
         final List<Object> list = Arrays.asList(data);
-        assertThrows(NullPointerException.class, () -> IOUtils.writeLines(list, "*", null, "US-ASCII"));
+        assertThrows(NullPointerException.class, () -> IOUtils.writeLines(list, "*", null, StandardCharsets.US_ASCII.name()));
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/LineIteratorTest.java b/src/test/java/org/apache/commons/io/LineIteratorTest.java
index 70fd90e5..9b02cf59 100644
--- a/src/test/java/org/apache/commons/io/LineIteratorTest.java
+++ b/src/test/java/org/apache/commons/io/LineIteratorTest.java
@@ -205,7 +205,7 @@ public void testFilteringBufferedReader() throws Exception {
         final List<String> lines = createLinesFile(testFile, encoding, 9);
 
         final Reader reader = new BufferedReader(Files.newBufferedReader(testFile.toPath()));
-        this.testFiltering(lines, reader);
+        testFiltering(lines, reader);
     }
 
     @Test
@@ -217,7 +217,7 @@ public void testFilteringFileReader() throws Exception {
         final List<String> lines = createLinesFile(testFile, encoding, 9);
 
         final Reader reader = Files.newBufferedReader(testFile.toPath());
-        this.testFiltering(lines, reader);
+        testFiltering(lines, reader);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/RandomAccessFileModeTest.java b/src/test/java/org/apache/commons/io/RandomAccessFileModeTest.java
new file mode 100644
index 00000000..1acaa80e
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/RandomAccessFileModeTest.java
@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+
+/**
+ * Tests {@link RandomAccessFileMode}.
+ */
+public class RandomAccessFileModeTest {
+
+    private static final byte[] BYTES_FIXTURE = "Foo".getBytes(StandardCharsets.US_ASCII);
+
+    private static final String FIXTURE = "test.txt";
+
+    /**
+     * Temporary directory.
+     */
+    @TempDir
+    public Path tempDir;
+
+    private byte[] read(final RandomAccessFile randomAccessFile) throws IOException {
+        return RandomAccessFiles.read(randomAccessFile, 0, (int) randomAccessFile.length());
+    }
+
+    @ParameterizedTest
+    @EnumSource(RandomAccessFileMode.class)
+    public void testCreateFile(final RandomAccessFileMode randomAccessFileMode) throws IOException {
+        final byte[] expected = BYTES_FIXTURE;
+        final Path fixture = writeFixture(expected);
+        try (RandomAccessFile randomAccessFile = randomAccessFileMode.create(fixture.toFile())) {
+            assertArrayEquals(expected, read(randomAccessFile));
+        }
+    }
+
+    @ParameterizedTest
+    @EnumSource(RandomAccessFileMode.class)
+    public void testCreatePath(final RandomAccessFileMode randomAccessFileMode) throws IOException {
+        final byte[] expected = BYTES_FIXTURE;
+        final Path fixture = writeFixture(expected);
+        randomAccessFileMode.accept(fixture, raf -> assertArrayEquals(expected, read(raf)));
+    }
+
+    @ParameterizedTest
+    @EnumSource(RandomAccessFileMode.class)
+    public void testCreateString(final RandomAccessFileMode randomAccessFileMode) throws IOException {
+        final byte[] expected = BYTES_FIXTURE;
+        final Path fixture = writeFixture(expected);
+        try (RandomAccessFile randomAccessFile = randomAccessFileMode.create(fixture.toString())) {
+            assertArrayEquals(expected, read(randomAccessFile));
+        }
+    }
+
+    @Test
+    public void testGetMode() {
+        assertEquals("r", RandomAccessFileMode.READ_ONLY.getMode());
+        assertEquals("rw", RandomAccessFileMode.READ_WRITE.getMode());
+        assertEquals("rwd", RandomAccessFileMode.READ_WRITE_SYNC_CONTENT.getMode());
+        assertEquals("rws", RandomAccessFileMode.READ_WRITE_SYNC_ALL.getMode());
+    }
+
+    @Test
+    public void testImplies() {
+        assertTrue(RandomAccessFileMode.READ_WRITE_SYNC_ALL.implies(RandomAccessFileMode.READ_WRITE_SYNC_CONTENT));
+        assertTrue(RandomAccessFileMode.READ_WRITE_SYNC_CONTENT.implies(RandomAccessFileMode.READ_WRITE));
+        assertTrue(RandomAccessFileMode.READ_WRITE.implies(RandomAccessFileMode.READ_ONLY));
+        assertFalse(RandomAccessFileMode.READ_ONLY.implies(RandomAccessFileMode.READ_WRITE_SYNC_ALL));
+    }
+
+    @ParameterizedTest
+    @EnumSource(RandomAccessFileMode.class)
+    public void testIoString(final RandomAccessFileMode randomAccessFileMode) throws IOException {
+        final byte[] expected = BYTES_FIXTURE;
+        final Path fixture = writeFixture(expected);
+        try (IORandomAccessFile randomAccessFile = randomAccessFileMode.io(fixture.toString())) {
+            assertArrayEquals(expected, read(randomAccessFile));
+        }
+    }
+
+    /**
+     * Tests the standard {@link Enum#toString()} behavior.
+     */
+    @Test
+    public void testToString() {
+        assertEquals("READ_ONLY", RandomAccessFileMode.READ_ONLY.toString());
+        assertEquals("READ_WRITE", RandomAccessFileMode.READ_WRITE.toString());
+        assertEquals("READ_WRITE_SYNC_ALL", RandomAccessFileMode.READ_WRITE_SYNC_ALL.toString());
+        assertEquals("READ_WRITE_SYNC_CONTENT", RandomAccessFileMode.READ_WRITE_SYNC_CONTENT.toString());
+    }
+
+    @ParameterizedTest
+    @EnumSource(LinkOption.class)
+    public void testValueOf(final LinkOption option) {
+        assertTrue(RandomAccessFileMode.valueOf(option).implies(RandomAccessFileMode.READ_ONLY));
+    }
+
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testValueOf(final StandardOpenOption option) {
+        assertTrue(RandomAccessFileMode.valueOf(option).implies(RandomAccessFileMode.READ_ONLY));
+    }
+
+    @Test
+    public void testValueOfMode() {
+        assertEquals(RandomAccessFileMode.READ_ONLY, RandomAccessFileMode.valueOfMode("r"));
+        assertEquals(RandomAccessFileMode.READ_WRITE, RandomAccessFileMode.valueOfMode("rw"));
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_CONTENT, RandomAccessFileMode.valueOfMode("rwd"));
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_ALL, RandomAccessFileMode.valueOfMode("rws"));
+    }
+
+    @Test
+    public void testValueOfOpenOptions() {
+        // READ_ONLY
+        assertEquals(RandomAccessFileMode.READ_ONLY, RandomAccessFileMode.valueOf(StandardOpenOption.READ));
+        // READ_WRITE
+        assertEquals(RandomAccessFileMode.READ_WRITE, RandomAccessFileMode.valueOf(StandardOpenOption.WRITE));
+        assertEquals(RandomAccessFileMode.READ_WRITE, RandomAccessFileMode.valueOf(StandardOpenOption.READ, StandardOpenOption.WRITE));
+        // READ_WRITE_SYNC_CONTENT
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_CONTENT, RandomAccessFileMode.valueOf(StandardOpenOption.DSYNC));
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_CONTENT, RandomAccessFileMode.valueOf(StandardOpenOption.WRITE, StandardOpenOption.DSYNC));
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_CONTENT,
+                RandomAccessFileMode.valueOf(StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DSYNC));
+        // READ_WRITE_SYNC_ALL
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_ALL, RandomAccessFileMode.valueOf(StandardOpenOption.SYNC));
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_ALL, RandomAccessFileMode.valueOf(StandardOpenOption.READ, StandardOpenOption.SYNC));
+        assertEquals(RandomAccessFileMode.READ_WRITE_SYNC_ALL,
+                RandomAccessFileMode.valueOf(StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.SYNC));
+    }
+
+    private Path writeFixture(final byte[] bytes) throws IOException {
+        return Files.write(tempDir.resolve(FIXTURE), bytes, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/RandomAccessFilesTest.java b/src/test/java/org/apache/commons/io/RandomAccessFilesTest.java
index ce7fa8fd..564a27af 100644
--- a/src/test/java/org/apache/commons/io/RandomAccessFilesTest.java
+++ b/src/test/java/org/apache/commons/io/RandomAccessFilesTest.java
@@ -27,49 +27,54 @@
 import java.io.RandomAccessFile;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.Arrays;
 
-import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link RandomAccessFiles}.
  */
 public class RandomAccessFilesTest {
 
-    private static final String FILE_NAME_RO_20 = "src/test/resources/org/apache/commons/io/test-file-20byteslength.bin";
-    private static final String FILE_NAME_RO_0 = "src/test/resources/org/apache/commons/io/test-file-empty.bin";
-    private static final String FILE_NAME_RO_0_BIS = "src/test/resources/org/apache/commons/io/test-file-empty2.bin";
+    private static final Path PATH_RO_20 = Paths.get("src/test/resources/org/apache/commons/io/test-file-20byteslength.bin");
+    private static final Path PATH_RO_0 = Paths.get("src/test/resources/org/apache/commons/io/test-file-empty.bin");
+    private static final Path PATH_RO_0_BIS = Paths.get("src/test/resources/org/apache/commons/io/test-file-empty2.bin");
 
-    @Test
-    public void testContentEquals() throws IOException {
-        try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            assertEquals(raf1, raf1);
-            assertTrue(RandomAccessFiles.contentEquals(raf1, raf1));
-        }
+    @ParameterizedTest()
+    @EnumSource(value = RandomAccessFileMode.class)
+    public void testContentEquals(final RandomAccessFileMode mode) throws IOException {
+        mode.accept(PATH_RO_20, raf -> {
+            assertEquals(raf, raf);
+            assertTrue(RandomAccessFiles.contentEquals(raf, raf));
+        });
         // as above, to make sure resources are OK
-        try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            assertEquals(raf1, raf1);
-            assertTrue(RandomAccessFiles.contentEquals(raf1, raf1));
-        }
-        // same 20 bytes
-        try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20);
-                RandomAccessFile raf2 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
+        mode.accept(PATH_RO_20, raf -> {
+            assertEquals(raf, raf);
+            assertTrue(RandomAccessFiles.contentEquals(raf, raf));
+        });
+        // same 20 bytes, 2 RAFs
+        try (RandomAccessFile raf1 = mode.create(PATH_RO_20);
+                RandomAccessFile raf2 = mode.create(PATH_RO_20)) {
             assertTrue(RandomAccessFiles.contentEquals(raf1, raf2));
         }
+        // as above, nested
+        mode.accept(PATH_RO_20, raf1 -> mode.accept(PATH_RO_20, raf2 -> assertTrue(RandomAccessFiles.contentEquals(raf1, raf2))));
         // same empty file
-        try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_0);
-                RandomAccessFile raf2 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_0)) {
+        try (RandomAccessFile raf1 = mode.create(PATH_RO_0);
+                RandomAccessFile raf2 = mode.create(PATH_RO_0)) {
             assertTrue(RandomAccessFiles.contentEquals(raf1, raf2));
             assertTrue(RandomAccessFiles.contentEquals(RandomAccessFiles.reset(raf2), RandomAccessFiles.reset(raf1)));
         }
         // diff empty file
-        try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_0);
-                RandomAccessFile raf2 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_0_BIS)) {
+        try (RandomAccessFile raf1 = mode.create(PATH_RO_0);
+                RandomAccessFile raf2 = mode.create(PATH_RO_0_BIS)) {
             assertTrue(RandomAccessFiles.contentEquals(raf1, raf2));
             assertTrue(RandomAccessFiles.contentEquals(RandomAccessFiles.reset(raf2), RandomAccessFiles.reset(raf1)));
         }
-        try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_0);
-                RandomAccessFile raf2 = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
+        try (RandomAccessFile raf1 = mode.create(PATH_RO_0);
+                RandomAccessFile raf2 = mode.create(PATH_RO_20)) {
             assertFalse(RandomAccessFiles.contentEquals(raf1, raf2));
             assertFalse(RandomAccessFiles.contentEquals(RandomAccessFiles.reset(raf2), RandomAccessFiles.reset(raf1)));
         }
@@ -85,8 +90,8 @@ public void testContentEquals() throws IOException {
             Arrays.fill(bytes2, (byte) 2);
             Files.write(bigFile1, bytes1);
             Files.write(bigFile2, bytes2);
-            try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(bigFile1);
-                    RandomAccessFile raf2 = RandomAccessFileMode.READ_ONLY.create(bigFile2)) {
+            try (RandomAccessFile raf1 = mode.create(bigFile1);
+                    RandomAccessFile raf2 = mode.create(bigFile2)) {
                 assertFalse(RandomAccessFiles.contentEquals(raf1, raf2));
                 assertFalse(RandomAccessFiles.contentEquals(RandomAccessFiles.reset(raf2), RandomAccessFiles.reset(raf1)));
                 assertTrue(RandomAccessFiles.contentEquals(RandomAccessFiles.reset(raf1), RandomAccessFiles.reset(raf1)));
@@ -95,8 +100,8 @@ public void testContentEquals() throws IOException {
             final byte[] bytes3 = bytes1.clone();
             bytes3[bytes3.length - 1] = 9;
             Files.write(bigFile3, bytes3);
-            try (RandomAccessFile raf1 = RandomAccessFileMode.READ_ONLY.create(bigFile1);
-                    RandomAccessFile raf3 = RandomAccessFileMode.READ_ONLY.create(bigFile3)) {
+            try (RandomAccessFile raf1 = mode.create(bigFile1);
+                    RandomAccessFile raf3 = mode.create(bigFile3)) {
                 assertFalse(RandomAccessFiles.contentEquals(raf1, raf3));
                 assertFalse(RandomAccessFiles.contentEquals(RandomAccessFiles.reset(raf3), RandomAccessFiles.reset(raf1)));
             }
@@ -108,30 +113,14 @@ public void testContentEquals() throws IOException {
         }
     }
 
-    @Test
-    public void testRead() throws IOException {
-        try (final RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            final byte[] buffer = RandomAccessFiles.read(raf, 0, 0);
-            assertArrayEquals(new byte[] {}, buffer);
-        }
-        try (final RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            final byte[] buffer = RandomAccessFiles.read(raf, 1, 0);
-            assertArrayEquals(new byte[] {}, buffer);
-        }
-        try (final RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            final byte[] buffer = RandomAccessFiles.read(raf, 0, 1);
-            assertArrayEquals(new byte[] { '1' }, buffer);
-        }
-        try (final RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            final byte[] buffer = RandomAccessFiles.read(raf, 1, 1);
-            assertArrayEquals(new byte[] { '2' }, buffer);
-        }
-        try (final RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            final byte[] buffer = RandomAccessFiles.read(raf, 0, 20);
-            assertEquals(20, buffer.length);
-        }
-        try (final RandomAccessFile raf = RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO_20)) {
-            assertThrows(IOException.class, () -> RandomAccessFiles.read(raf, 0, 21));
-        }
+    @ParameterizedTest()
+    @EnumSource(value = RandomAccessFileMode.class)
+    public void testRead(final RandomAccessFileMode mode) throws IOException {
+        mode.accept(PATH_RO_20, raf -> assertArrayEquals(new byte[] {}, RandomAccessFiles.read(raf, 0, 0)));
+        mode.accept(PATH_RO_20, raf -> assertArrayEquals(new byte[] {}, RandomAccessFiles.read(raf, 1, 0)));
+        mode.accept(PATH_RO_20, raf -> assertArrayEquals(new byte[] { '1' }, RandomAccessFiles.read(raf, 0, 1)));
+        mode.accept(PATH_RO_20, raf -> assertArrayEquals(new byte[] { '2' }, RandomAccessFiles.read(raf, 1, 1)));
+        mode.accept(PATH_RO_20, raf -> assertEquals(20, RandomAccessFiles.read(raf, 0, 20).length));
+        mode.accept(PATH_RO_20, raf -> assertThrows(IOException.class, () -> RandomAccessFiles.read(raf, 0, 21)));
     }
 }
diff --git a/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java b/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java
index 8cd1c1ff..9a6416c0 100644
--- a/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java
@@ -14,23 +14,36 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.commons.io.build;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.RandomAccessFile;
 import java.io.Reader;
 import java.io.Writer;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.nio.file.StandardOpenOption;
 import java.util.Objects;
 
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.build.AbstractOrigin.RandomAccessFileOrigin;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link AbstractOrigin} and subclasses.
@@ -43,10 +56,17 @@ public abstract class AbstractOriginTest<T, B extends AbstractOrigin<T, B>> {
     protected static final String FILE_RES_RO = "/org/apache/commons/io/test-file-20byteslength.bin";
     protected static final String FILE_NAME_RO = "src/test/resources" + FILE_RES_RO;
     protected static final String FILE_NAME_RW = "target/" + AbstractOriginTest.class.getSimpleName() + ".txt";
+    private static final int RO_LENGTH = 20;
 
     protected AbstractOrigin<T, B> originRo;
     protected AbstractOrigin<T, B> originRw;
 
+    @BeforeEach
+    public void beforeEach() throws IOException {
+        setOriginRo(newOriginRo());
+        setOriginRw(newOriginRw());
+    }
+
     protected AbstractOrigin<T, B> getOriginRo() {
         return Objects.requireNonNull(originRo, "originRo");
     }
@@ -55,6 +75,15 @@ protected AbstractOrigin<T, B> getOriginRw() {
         return Objects.requireNonNull(originRw, "originRw");
     }
 
+    @SuppressWarnings("resource")
+    private boolean isValid(final RandomAccessFile raf) throws IOException {
+        return Objects.requireNonNull(raf).getFD().valid();
+    }
+
+    protected abstract B newOriginRo() throws IOException;
+
+    protected abstract B newOriginRw() throws IOException;
+
     protected void setOriginRo(final AbstractOrigin<T, B> origin) {
         this.originRo = origin;
     }
@@ -89,8 +118,17 @@ public void testGetCharSequence() throws IOException {
     }
 
     @Test
-    public void testGetFile() {
-        assertNotNull(getOriginRo().getFile());
+    public void testGetFile() throws IOException {
+        testGetFile(getOriginRo().getFile(), RO_LENGTH);
+        FileUtils.touch(getOriginRw().getFile());
+        testGetFile(getOriginRw().getFile(), 0);
+    }
+
+    private void testGetFile(final File file, final long expectedLen) throws IOException {
+        assertNotNull(file);
+        assertTrue(file.exists(), () -> "File does not exist: " + file);
+        final int length = FileUtils.readFileToByteArray(file).length;
+        assertEquals(length, expectedLen, () -> String.format("File %s, actual length=%,d", file, length));
     }
 
     @Test
@@ -108,8 +146,77 @@ public void testGetOutputStream() throws IOException {
     }
 
     @Test
-    public void testGetPath() {
-        assertNotNull(getOriginRo().getPath());
+    public void testGetPath() throws IOException {
+        testGetPath(getOriginRo().getPath(), RO_LENGTH);
+        FileUtils.touch(getOriginRw().getPath().toFile());
+        testGetPath(getOriginRw().getPath(), 0);
+    }
+
+    private void testGetPath(final Path path, final long expectedLen) throws IOException {
+        assertNotNull(path);
+        assertTrue(Files.exists(path));
+        final int length = Files.readAllBytes(path).length;
+        assertEquals(length, expectedLen, () -> String.format("Path %s, actual length=%,d", path, length));
+    }
+
+    @Test
+    public void testGetRandomAccessFile() throws IOException {
+        // Default
+        try (final RandomAccessFile raf = getOriginRo().getRandomAccessFile()) {
+            assertNotNull(raf);
+            assertTrue(isValid(raf));
+        }
+        final boolean isRafOriginRo = getOriginRo() instanceof RandomAccessFileOrigin;
+        final boolean isRafOriginRw = getOriginRw() instanceof RandomAccessFileOrigin;
+        // Same as above, but underlying resource is now closed.
+        try (final RandomAccessFile raf = getOriginRo().getRandomAccessFile()) {
+            assertNotNull(raf);
+            assertFalse(isRafOriginRo && isValid(raf));
+        }
+        // Read
+        try (final RandomAccessFile raf = getOriginRo().getRandomAccessFile(StandardOpenOption.READ)) {
+            assertNotNull(raf);
+            assertFalse(isRafOriginRo && isValid(raf));
+        }
+        // Write, first access
+        try (final RandomAccessFile raf = getOriginRw().getRandomAccessFile(StandardOpenOption.WRITE)) {
+            assertNotNull(raf);
+            if (isRafOriginRw || getOriginRw().getFile() != null) {
+                assertTrue(isValid(raf), () -> getOriginRw().toString());
+            } else {
+                // Can't get there from here.
+                assertFalse(isValid(raf), () -> getOriginRw().toString());
+            }
+        }
+        // Read, Write, underlying resource is now closed.
+        try (final RandomAccessFile raf = getOriginRw().getRandomAccessFile(StandardOpenOption.READ, StandardOpenOption.WRITE)) {
+            assertNotNull(raf);
+            assertFalse(isRafOriginRw && isValid(raf));
+        }
+    }
+
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) throws IOException {
+        // Default
+        try (final RandomAccessFile raf = getOriginRw().getRandomAccessFile()) {
+            assertNotNull(raf);
+            assertTrue(isValid(raf));
+        }
+        // Same as above, but underlying resource is now closed.
+        final boolean isRafOrigin = getOriginRw() instanceof RandomAccessFileOrigin;
+        try (final RandomAccessFile raf = getOriginRw().getRandomAccessFile()) {
+            assertNotNull(raf);
+            assertFalse(isRafOrigin && isValid(raf));
+        }
+        try (final RandomAccessFile raf = getOriginRw().getRandomAccessFile(openOption)) {
+            assertNotNull(raf);
+            assertFalse(isRafOrigin && isValid(raf));
+        }
+        try (final RandomAccessFile raf = getOriginRw().getRandomAccessFile(openOption)) {
+            assertNotNull(raf);
+            assertFalse(isRafOrigin && isValid(raf));
+        }
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java b/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java
new file mode 100644
index 00000000..f0545851
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.build;
+
+import java.io.RandomAccessFile;
+
+import org.apache.commons.io.IORandomAccessFile;
+import org.apache.commons.io.build.AbstractOrigin.AbstractRandomAccessFileOrigin;
+import org.apache.commons.io.build.AbstractOrigin.IORandomAccessFileOrigin;
+import org.apache.commons.io.build.AbstractOrigin.RandomAccessFileOrigin;
+
+/**
+ * Tests {@link RandomAccessFileOrigin} and {@link IORandomAccessFileOrigin}.
+ *
+ * @param <T> the type of instances to build.
+ * @param <B> the type of builder subclass.
+ * @see RandomAccessFile
+ * @see IORandomAccessFile
+ */
+public abstract class AbstractRandomAccessFileOriginTest<T extends RandomAccessFile, B extends AbstractRandomAccessFileOrigin<T, B>>
+        extends AbstractOriginTest<T, B> {
+
+}
diff --git a/src/test/java/org/apache/commons/io/build/AbstractSupplierTest.java b/src/test/java/org/apache/commons/io/build/AbstractSupplierTest.java
new file mode 100644
index 00000000..e9b3be77
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/build/AbstractSupplierTest.java
@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.build;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link AbstractSupplier}.
+ * <p>
+ * This code is used in Javadoc.
+ * </p>
+ */
+public class AbstractSupplierTest {
+
+    /**
+     * Builds {@link Foo} instances.
+     */
+    public static class Builder extends AbstractSupplier<Foo, Builder> {
+
+        private String bar1;
+        private String bar2;
+        private String bar3;
+
+        /**
+         * Builds a new {@link Foo}.
+         */
+        @Override
+        public Foo get() {
+            return new Foo(bar1, bar2, bar3);
+        }
+
+        public Builder setBar1(final String bar1) {
+            this.bar1 = bar1;
+            return this;
+        }
+
+        public Builder setBar2(final String bar2) {
+            this.bar2 = bar2;
+            return this;
+        }
+
+        public Builder setBar3(final String bar3) {
+            this.bar3 = bar3;
+            return this;
+        }
+    }
+
+    /**
+     * Domain class.
+     */
+    public static class Foo {
+
+        public static Builder builder() {
+            return new Builder();
+        }
+
+        private final String bar1;
+        private final String bar2;
+        private final String bar3;
+
+        private Foo(final String bar1, final String bar2, final String bar3) {
+            this.bar1 = bar1;
+            this.bar2 = bar2;
+            this.bar3 = bar3;
+        }
+
+        public String getBar1() {
+            return bar1;
+        }
+
+        public String getBar2() {
+            return bar2;
+        }
+
+        public String getBar3() {
+            return bar3;
+        }
+
+    }
+
+    @Test
+    public void test() {
+        // @formatter:off
+        final Foo foo = Foo.builder()
+            .setBar1("value1")
+            .setBar2("value2")
+            .setBar3("value3")
+            .get();
+        // @formatter:on
+        assertEquals("value1", foo.getBar1());
+        assertEquals("value2", foo.getBar2());
+        assertEquals("value3", foo.getBar3());
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java b/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java
index 9653d8b6..0176758c 100644
--- a/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java
@@ -20,11 +20,14 @@
 
 import java.io.IOException;
 import java.nio.file.Files;
+import java.nio.file.OpenOption;
 import java.nio.file.Paths;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.commons.io.build.AbstractOrigin.ByteArrayOrigin;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link ByteArrayOrigin}.
@@ -33,10 +36,14 @@
  */
 public class ByteArrayOriginTest extends AbstractOriginTest<byte[], ByteArrayOrigin> {
 
-    @BeforeEach
-    public void beforeEach() throws IOException {
-        setOriginRo(new ByteArrayOrigin(Files.readAllBytes(Paths.get(FILE_NAME_RO))));
-        setOriginRw(new ByteArrayOrigin(new byte[] { 1 }));
+    @Override
+    protected ByteArrayOrigin newOriginRo() throws IOException {
+        return new ByteArrayOrigin(Files.readAllBytes(Paths.get(FILE_NAME_RO)));
+    }
+
+    @Override
+    protected ByteArrayOrigin newOriginRw() {
+        return new ByteArrayOrigin(new byte[] { 1 });
     }
 
     @Override
@@ -60,6 +67,21 @@ public void testGetPath() {
         assertThrows(UnsupportedOperationException.class, super::testGetPath);
     }
 
+    @Override
+    @Test
+    public void testGetRandomAccessFile() {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);
+    }
+
+    @Override
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));
+    }
+
     @Override
     @Test
     public void testGetWriter() {
diff --git a/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java b/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java
index f506047e..804414d6 100644
--- a/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java
@@ -16,28 +16,43 @@
  */
 package org.apache.commons.io.build;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.Reader;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.OpenOption;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.build.AbstractOrigin.CharSequenceOrigin;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link CharSequenceOrigin}.
  *
  * A CharSequenceOrigin can convert into some of the other aspects.
+ *
+ * @see CharSequence
  */
 public class CharSequenceOriginTest extends AbstractOriginTest<CharSequence, CharSequenceOrigin> {
 
-    @BeforeEach
-    public void beforeEach() throws FileNotFoundException, IOException {
-        setOriginRo(new CharSequenceOrigin(IOUtils.resourceToString(FILE_RES_RO, StandardCharsets.UTF_8)));
-        setOriginRw(new CharSequenceOrigin("World"));
+    private String getFixtureStringFromFile() throws IOException {
+        return IOUtils.resourceToString(FILE_RES_RO, StandardCharsets.UTF_8);
+    }
+
+    @Override
+    protected CharSequenceOrigin newOriginRo() throws IOException {
+        return new CharSequenceOrigin(getFixtureStringFromFile());
+    }
+
+    @Override
+    protected CharSequenceOrigin newOriginRw() {
+        return new CharSequenceOrigin("World");
     }
 
     @Override
@@ -61,6 +76,30 @@ public void testGetPath() {
         assertThrows(UnsupportedOperationException.class, super::testGetPath);
     }
 
+    @Override
+    @Test
+    public void testGetRandomAccessFile() {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);
+    }
+
+    @Override
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));
+    }
+
+    @Test
+    public void testGetReaderIgnoreCharset() throws IOException {
+        // The CharSequenceOrigin ignores the given Charset.
+        try (final Reader reader = getOriginRo().getReader(StandardCharsets.UTF_16LE)) {
+            assertNotNull(reader);
+            assertEquals(getFixtureStringFromFile(), IOUtils.toString(reader));
+        }
+    }
+
     @Override
     @Test
     public void testGetWriter() {
diff --git a/src/test/java/org/apache/commons/io/build/FileOriginTest.java b/src/test/java/org/apache/commons/io/build/FileOriginTest.java
index ec57f389..27af8fb1 100644
--- a/src/test/java/org/apache/commons/io/build/FileOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/FileOriginTest.java
@@ -19,19 +19,24 @@
 import java.io.File;
 
 import org.apache.commons.io.build.AbstractOrigin.FileOrigin;
-import org.junit.jupiter.api.BeforeEach;
 
 /**
  * Tests {@link FileOrigin}.
  *
  * A FileOrigin can convert into all other aspects.
+ *
+ * @see File
  */
 public class FileOriginTest extends AbstractOriginTest<File, FileOrigin> {
 
-    @BeforeEach
-    public void beforeEach() {
-        setOriginRo(new FileOrigin(new File(FILE_NAME_RO)));
-        setOriginRw(new FileOrigin(new File(FILE_NAME_RW)));
+    @Override
+    protected FileOrigin newOriginRo() {
+        return new FileOrigin(new File(FILE_NAME_RO));
+    }
+
+    @Override
+    protected FileOrigin newOriginRw() {
+        return new FileOrigin(new File(FILE_NAME_RW));
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java b/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java
new file mode 100644
index 00000000..86a759f4
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.build;
+
+import java.io.FileNotFoundException;
+import java.io.RandomAccessFile;
+
+import org.apache.commons.io.IORandomAccessFile;
+import org.apache.commons.io.RandomAccessFileMode;
+import org.apache.commons.io.build.AbstractOrigin.IORandomAccessFileOrigin;
+
+/**
+ * Tests {@link IORandomAccessFileOrigin}.
+ *
+ * @see RandomAccessFile
+ */
+public class IORandomAccessFileOriginTest extends AbstractOriginTest<IORandomAccessFile, IORandomAccessFileOrigin> {
+
+    @SuppressWarnings("resource")
+    @Override
+    protected IORandomAccessFileOrigin newOriginRo() throws FileNotFoundException {
+        return new IORandomAccessFileOrigin(RandomAccessFileMode.READ_ONLY.io(FILE_NAME_RO));
+    }
+
+    @SuppressWarnings("resource")
+    @Override
+    protected IORandomAccessFileOrigin newOriginRw() throws FileNotFoundException {
+        return new IORandomAccessFileOrigin(RandomAccessFileMode.READ_WRITE.io(FILE_NAME_RW));
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java b/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java
index 2d2f1b3a..0e47489b 100644
--- a/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java
@@ -21,24 +21,34 @@
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
+import java.nio.file.OpenOption;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.commons.io.build.AbstractOrigin.InputStreamOrigin;
 import org.apache.commons.io.input.CharSequenceInputStream;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link InputStreamOrigin}.
  *
  * A InputStreamOrigin can convert into some of the other aspects.
+ *
+ * @see InputStream
  */
 public class InputStreamOriginTest extends AbstractOriginTest<InputStream, InputStreamOrigin> {
 
     @SuppressWarnings("resource")
-    @BeforeEach
-    public void beforeEach() throws FileNotFoundException {
-        setOriginRo(new InputStreamOrigin(new FileInputStream(FILE_NAME_RO)));
-        setOriginRw(new InputStreamOrigin(CharSequenceInputStream.builder().setCharSequence("World").get()));
+    @Override
+    protected InputStreamOrigin newOriginRo() throws FileNotFoundException {
+        return new InputStreamOrigin(new FileInputStream(FILE_NAME_RO));
+    }
+
+    @SuppressWarnings("resource")
+    @Override
+    protected InputStreamOrigin newOriginRw() {
+        return new InputStreamOrigin(CharSequenceInputStream.builder().setCharSequence("World").get());
     }
 
     @Override
@@ -62,6 +72,21 @@ public void testGetPath() {
         assertThrows(UnsupportedOperationException.class, super::testGetPath);
     }
 
+    @Override
+    @Test
+    public void testGetRandomAccessFile() {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);
+    }
+
+    @Override
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));
+    }
+
     @Override
     @Test
     public void testGetWriter() {
diff --git a/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java b/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java
index fcd6f10d..74f621e6 100644
--- a/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java
@@ -19,24 +19,32 @@
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.OutputStream;
+import java.nio.file.OpenOption;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.commons.io.build.AbstractOrigin.OutputStreamOrigin;
 import org.apache.commons.io.output.ByteArrayOutputStream;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link OutputStreamOrigin}.
  *
  * A OutputStreamOrigin can convert into some of the other aspects.
+ *
+ * @see OutputStream
  */
 public class OutputStreamOriginTest extends AbstractOriginTest<OutputStream, OutputStreamOrigin> {
 
-    @SuppressWarnings("resource")
-    @BeforeEach
-    public void beforeEach() {
-        setOriginRo(new OutputStreamOrigin(new ByteArrayOutputStream()));
-        setOriginRw(new OutputStreamOrigin(new ByteArrayOutputStream()));
+    @Override
+    protected OutputStreamOrigin newOriginRo() {
+        return new OutputStreamOrigin(new ByteArrayOutputStream());
+    }
+
+    @Override
+    protected OutputStreamOrigin newOriginRw() {
+        return new OutputStreamOrigin(new ByteArrayOutputStream());
     }
 
     @Override
@@ -95,6 +103,21 @@ public void testGetPath() {
         assertThrows(UnsupportedOperationException.class, super::testGetPath);
     }
 
+    @Override
+    @Test
+    public void testGetRandomAccessFile() {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);
+    }
+
+    @Override
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));
+    }
+
     @Override
     @Test
     public void testGetReader() {
diff --git a/src/test/java/org/apache/commons/io/build/PathOriginTest.java b/src/test/java/org/apache/commons/io/build/PathOriginTest.java
index b94f2ea5..182c2557 100644
--- a/src/test/java/org/apache/commons/io/build/PathOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/PathOriginTest.java
@@ -20,19 +20,24 @@
 import java.nio.file.Paths;
 
 import org.apache.commons.io.build.AbstractOrigin.PathOrigin;
-import org.junit.jupiter.api.BeforeEach;
 
 /**
  * Tests {@link PathOrigin}.
  *
  * A PathOrigin can convert into all other aspects.
+ *
+ * @see Path
  */
 public class PathOriginTest extends AbstractOriginTest<Path, PathOrigin> {
 
-    @BeforeEach
-    public void beforeEach() {
-        setOriginRo(new PathOrigin(Paths.get(FILE_NAME_RO)));
-        setOriginRw(new PathOrigin(Paths.get(FILE_NAME_RW)));
+    @Override
+    protected PathOrigin newOriginRo() {
+        return new PathOrigin(Paths.get(FILE_NAME_RO));
+    }
+
+    @Override
+    protected PathOrigin newOriginRw() {
+        return new PathOrigin(Paths.get(FILE_NAME_RW));
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java b/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java
new file mode 100644
index 00000000..9924498c
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.build;
+
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.FileNotFoundException;
+import java.io.RandomAccessFile;
+
+import org.apache.commons.io.RandomAccessFileMode;
+import org.apache.commons.io.build.AbstractOrigin.RandomAccessFileOrigin;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link RandomAccessFileOrigin}.
+ *
+ * @see RandomAccessFile
+ */
+public class RandomAccessFileOriginTest extends AbstractRandomAccessFileOriginTest<RandomAccessFile, RandomAccessFileOrigin> {
+
+    @SuppressWarnings("resource")
+    @Override
+    protected RandomAccessFileOrigin newOriginRo() throws FileNotFoundException {
+        return new RandomAccessFileOrigin(RandomAccessFileMode.READ_ONLY.create(FILE_NAME_RO));
+    }
+
+    @SuppressWarnings("resource")
+    @Override
+    protected RandomAccessFileOrigin newOriginRw() throws FileNotFoundException {
+        return new RandomAccessFileOrigin(RandomAccessFileMode.READ_WRITE.create(FILE_NAME_RW));
+    }
+
+    @Override
+    @Test
+    public void testGetFile() {
+        // Cannot convert a Writer to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetFile);
+    }
+
+    @Override
+    @Test
+    public void testGetPath() {
+        // Cannot convert a Writer to a Path.
+        assertThrows(UnsupportedOperationException.class, super::testGetPath);
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java b/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java
index d63cb86a..58708827 100644
--- a/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java
@@ -21,24 +21,32 @@
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.Reader;
+import java.nio.file.OpenOption;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.commons.io.build.AbstractOrigin.ReaderOrigin;
 import org.apache.commons.io.input.CharSequenceReader;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link ReaderOrigin}.
  *
  * A ReaderOrigin can convert into some of the other aspects.
+ *
+ * @see Reader
  */
 public class ReaderOriginTest extends AbstractOriginTest<Reader, ReaderOrigin> {
 
-    @SuppressWarnings("resource")
-    @BeforeEach
-    public void beforeEach() throws FileNotFoundException {
-        setOriginRo(new ReaderOrigin(new FileReader(FILE_NAME_RO)));
-        setOriginRw(new ReaderOrigin(new CharSequenceReader("World")));
+    @Override
+    protected ReaderOrigin newOriginRo() throws FileNotFoundException {
+        return new ReaderOrigin(new FileReader(FILE_NAME_RO));
+    }
+
+    @Override
+    protected ReaderOrigin newOriginRw() {
+        return new ReaderOrigin(new CharSequenceReader("World"));
     }
 
     @Override
@@ -62,6 +70,21 @@ public void testGetPath() {
         assertThrows(UnsupportedOperationException.class, super::testGetPath);
     }
 
+    @Override
+    @Test
+    public void testGetRandomAccessFile() {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);
+    }
+
+    @Override
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));
+    }
+
     @Override
     @Test
     public void testGetWriter() {
diff --git a/src/test/java/org/apache/commons/io/build/URIOriginTest.java b/src/test/java/org/apache/commons/io/build/URIOriginTest.java
index f609d7a2..e33dcfd0 100644
--- a/src/test/java/org/apache/commons/io/build/URIOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/URIOriginTest.java
@@ -16,23 +16,53 @@
  */
 package org.apache.commons.io.build;
 
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+
+import java.io.InputStream;
 import java.net.URI;
 import java.nio.file.Paths;
 
 import org.apache.commons.io.build.AbstractOrigin.URIOrigin;
-import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 
 /**
  * Tests {@link URIOrigin}.
  *
  * A URIOrigin can convert into all other aspects.
+ *
+ * @see URI
  */
 public class URIOriginTest extends AbstractOriginTest<URI, URIOrigin> {
 
-    @BeforeEach
-    public void beforeEach() {
-        setOriginRo(new URIOrigin(Paths.get(FILE_NAME_RO).toUri()));
-        setOriginRw(new URIOrigin(Paths.get(FILE_NAME_RW).toUri()));
+    @Override
+    protected URIOrigin newOriginRo() {
+        return new URIOrigin(Paths.get(FILE_NAME_RO).toUri());
+    }
+
+    @Override
+    protected URIOrigin newOriginRw() {
+        return new URIOrigin(Paths.get(FILE_NAME_RW).toUri());
     }
 
+    @ParameterizedTest
+    @ValueSource(strings = {
+            "http://example.com",
+            "https://example.com"
+    })
+    void testGetInputStream(final String uri) throws Exception {
+        final AbstractOrigin.URIOrigin origin = new AbstractOrigin.URIOrigin(new URI(uri));
+        try (final InputStream in = origin.getInputStream()) {
+            assertNotEquals(-1, in.read());
+        }
+    }
+
+    @Test
+    void testGetInputStreamFileURI() throws Exception {
+        final AbstractOrigin.URIOrigin origin = getOriginRo().asThis();
+        try (final InputStream in = origin.getInputStream()) {
+            assertNotEquals(-1, in.read());
+        }
+    }
 }
diff --git a/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java b/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java
index c7779e39..1caefef7 100644
--- a/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java
+++ b/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java
@@ -20,22 +20,31 @@
 
 import java.io.StringWriter;
 import java.io.Writer;
+import java.nio.file.OpenOption;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.commons.io.build.AbstractOrigin.WriterOrigin;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
 /**
  * Tests {@link WriterOrigin}.
  *
  * A WriterOrigin can convert into some of the other aspects.
+ *
+ * @see Writer
  */
 public class WriterStreamOriginTest extends AbstractOriginTest<Writer, WriterOrigin> {
 
-    @BeforeEach
-    public void beforeEach() {
-        setOriginRo(new WriterOrigin(new StringWriter()));
-        setOriginRw(new WriterOrigin(new StringWriter()));
+    @Override
+    protected WriterOrigin newOriginRo() {
+        return newOriginRw();
+    }
+
+    @Override
+    protected WriterOrigin newOriginRw() {
+        return new WriterOrigin(new StringWriter());
     }
 
     @Override
@@ -94,6 +103,21 @@ public void testGetPath() {
         assertThrows(UnsupportedOperationException.class, super::testGetPath);
     }
 
+    @Override
+    @Test
+    public void testGetRandomAccessFile() {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);
+    }
+
+    @Override
+    @ParameterizedTest
+    @EnumSource(StandardOpenOption.class)
+    public void testGetRandomAccessFile(final OpenOption openOption) {
+        // Cannot convert a RandomAccessFile to a File.
+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));
+    }
+
     @Override
     @Test
     public void testGetReader() {
diff --git a/src/test/java/org/apache/commons/io/channels/FileChannelsTest.java b/src/test/java/org/apache/commons/io/channels/FileChannelsTest.java
new file mode 100644
index 00000000..7a3b260a
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/channels/FileChannelsTest.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.channels;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.channels.FileChannel;
+
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.file.AbstractTempDirTest;
+import org.apache.commons.lang3.StringUtils;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link FileChannels}.
+ */
+public class FileChannelsTest extends AbstractTempDirTest {
+
+    private static final int BUFFER_SIZE = 1024;
+    private static final String CONTENT = StringUtils.repeat("x", BUFFER_SIZE);
+
+    private boolean isEmpty(final File empty) {
+        return empty.length() == 0;
+    }
+
+    private void testContentEquals(final String content1, final String content2) throws IOException {
+        assertTrue(FileChannels.contentEquals(null, null, BUFFER_SIZE));
+
+        // Prepare test files with same size but different content
+        // (first 3 bytes are different, followed by a large amount of equal content)
+        final File file1 = new File(tempDirFile, "test1.txt");
+        final File file2 = new File(tempDirFile, "test2.txt");
+        FileUtils.writeStringToFile(file1, content1, US_ASCII);
+        FileUtils.writeStringToFile(file2, content2, US_ASCII);
+
+        // File checksums are different
+        assertNotEquals(FileUtils.checksumCRC32(file1), FileUtils.checksumCRC32(file2));
+
+        try (FileInputStream stream1 = new FileInputStream(file1);
+                FileInputStream stream2 = new FileInputStream(file2);
+                FileChannel channel1 = stream1.getChannel();
+                FileChannel channel2 = stream2.getChannel()) {
+            assertFalse(FileChannels.contentEquals(channel1, channel2, BUFFER_SIZE));
+        }
+        try (FileInputStream stream1 = new FileInputStream(file1);
+                FileInputStream stream2 = new FileInputStream(file2);
+                FileChannel channel1 = stream1.getChannel();
+                FileChannel channel2 = stream2.getChannel()) {
+            assertTrue(FileChannels.contentEquals(channel1, channel1, BUFFER_SIZE));
+            assertTrue(FileChannels.contentEquals(channel2, channel2, BUFFER_SIZE));
+        }
+    }
+
+    @Test
+    public void testContentEqualsDifferentPostfix() throws IOException {
+        testContentEquals(CONTENT + "ABC", CONTENT + "XYZ");
+    }
+
+    @Test
+    public void testContentEqualsDifferentPrefix() throws IOException {
+        testContentEquals("ABC" + CONTENT, "XYZ" + CONTENT);
+    }
+
+    @Test
+    public void testContentEqualsEmpty() throws IOException {
+        assertTrue(FileChannels.contentEquals(null, null, BUFFER_SIZE));
+
+        final File empty = new File(tempDirFile, "empty.txt");
+        final File notEmpty = new File(tempDirFile, "not-empty.txt");
+        FileUtils.writeStringToFile(empty, StringUtils.EMPTY, US_ASCII);
+        FileUtils.writeStringToFile(notEmpty, "X", US_ASCII);
+        assertTrue(isEmpty(empty));
+        assertFalse(isEmpty(notEmpty));
+
+        // File checksums are different
+        assertNotEquals(FileUtils.checksumCRC32(empty), FileUtils.checksumCRC32(notEmpty));
+
+        try (FileInputStream streamEmpty = new FileInputStream(empty);
+                FileInputStream streamNotEmpty = new FileInputStream(notEmpty);
+                FileChannel channelEmpty = streamEmpty.getChannel();
+                FileChannel channelNotEmpty = streamNotEmpty.getChannel()) {
+            assertFalse(FileChannels.contentEquals(channelEmpty, channelNotEmpty, BUFFER_SIZE));
+            assertFalse(FileChannels.contentEquals(null, channelNotEmpty, BUFFER_SIZE));
+            assertFalse(FileChannels.contentEquals(channelNotEmpty, null, BUFFER_SIZE));
+            assertTrue(FileChannels.contentEquals(channelEmpty, channelEmpty, BUFFER_SIZE));
+            assertTrue(FileChannels.contentEquals(null, channelEmpty, BUFFER_SIZE));
+            assertTrue(FileChannels.contentEquals(channelEmpty, null, BUFFER_SIZE));
+            assertTrue(FileChannels.contentEquals(channelNotEmpty, channelNotEmpty, BUFFER_SIZE));
+        }
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java b/src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java
index 5bcca947..ddcd0326 100644
--- a/src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java
+++ b/src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java
@@ -38,10 +38,10 @@ public abstract class ComparatorAbstractTest {
     @TempDir
     public File dir;
 
-    /** comparator instance */
+    /** Comparator instance */
     protected AbstractFileComparator comparator;
 
-    /** reverse comparator instance */
+    /** Reverse comparator instance */
     protected Comparator<File> reverse;
 
     /** File which compares equal to  "equalFile2" */
@@ -96,7 +96,7 @@ public void testSortArray() {
      */
     @Test
     public void testSortArrayNull() {
-        assertNull(comparator.sort((File[])null));
+        assertNull(comparator.sort((File[]) null));
     }
 
     /**
@@ -119,7 +119,7 @@ public void testSortList() {
      */
     @Test
     public void testSortListNull() {
-        assertNull(comparator.sort((List<File>)null));
+        assertNull(comparator.sort((List<File>) null));
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java b/src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java
index ad5ada43..63613b66 100644
--- a/src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java
+++ b/src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java
@@ -36,43 +36,6 @@
  */
 public class CompositeFileComparatorTest extends ComparatorAbstractTest {
 
-    /**
-     * Test Constructor with null array
-     */
-    @Test
-    public void constructorArray_Null() {
-        final Comparator<File> c = new CompositeFileComparator((Comparator<File>[])null);
-        assertEquals(0, c.compare(lessFile, moreFile), "less,more");
-        assertEquals(0, c.compare(moreFile, lessFile), "more,less");
-        assertEquals("CompositeFileComparator{}", c.toString(), "toString");
-    }
-
-    /**
-     * Test Constructor with null Iterable
-     */
-    @Test
-    public void constructorIterable_Null() {
-        final Comparator<File> c = new CompositeFileComparator((Iterable<Comparator<File>>)null);
-        assertEquals(0, c.compare(lessFile, moreFile), "less,more");
-        assertEquals(0, c.compare(moreFile, lessFile), "more,less");
-        assertEquals("CompositeFileComparator{}", c.toString(), "toString");
-    }
-
-    /**
-     * Test Constructor with null Iterable
-     */
-    @Test
-    public void constructorIterable_order() {
-        final List<Comparator<File>> list = new ArrayList<>();
-        list.add(SizeFileComparator.SIZE_COMPARATOR);
-        list.add(ExtensionFileComparator.EXTENSION_COMPARATOR);
-        final Comparator<File> c = new CompositeFileComparator(list);
-
-        assertEquals(0, c.compare(equalFile1, equalFile2), "equal");
-        assertTrue(c.compare(lessFile, moreFile) < 0, "less");
-        assertTrue(c.compare(moreFile, lessFile) > 0, "more");
-    }
-
     @BeforeEach
     public void setUp() throws Exception {
         comparator = new CompositeFileComparator(SizeFileComparator.SIZE_COMPARATOR, ExtensionFileComparator.EXTENSION_COMPARATOR);
@@ -115,4 +78,41 @@ public void setUp() throws Exception {
             TestUtils.generateTestData(output, 48);
         }
     }
+
+    /**
+     * Test Constructor with null array
+     */
+    @Test
+    public void testConstructorArray_Null() {
+        final Comparator<File> c = new CompositeFileComparator((Comparator<File>[]) null);
+        assertEquals(0, c.compare(lessFile, moreFile), "less,more");
+        assertEquals(0, c.compare(moreFile, lessFile), "more,less");
+        assertEquals("CompositeFileComparator{}", c.toString(), "toString");
+    }
+
+    /**
+     * Test Constructor with null Iterable
+     */
+    @Test
+    public void testConstructorIterable_Null() {
+        final Comparator<File> c = new CompositeFileComparator((Iterable<Comparator<File>>) null);
+        assertEquals(0, c.compare(lessFile, moreFile), "less,more");
+        assertEquals(0, c.compare(moreFile, lessFile), "more,less");
+        assertEquals("CompositeFileComparator{}", c.toString(), "toString");
+    }
+
+    /**
+     * Test Constructor with null Iterable
+     */
+    @Test
+    public void testConstructorIterable_order() {
+        final List<Comparator<File>> list = new ArrayList<>();
+        list.add(SizeFileComparator.SIZE_COMPARATOR);
+        list.add(ExtensionFileComparator.EXTENSION_COMPARATOR);
+        final Comparator<File> c = new CompositeFileComparator(list);
+
+        assertEquals(0, c.compare(equalFile1, equalFile2), "equal");
+        assertTrue(c.compare(lessFile, moreFile) < 0, "less");
+        assertTrue(c.compare(moreFile, lessFile) > 0, "more");
+    }
 }
diff --git a/src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java b/src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java
index 6a6a505c..8c1c0d54 100644
--- a/src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java
+++ b/src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java
@@ -30,7 +30,6 @@
  */
 public class ExtensionFileComparatorTest extends ComparatorAbstractTest {
 
-
     @BeforeEach
     public void setUp() {
         comparator = (AbstractFileComparator) ExtensionFileComparator.EXTENSION_COMPARATOR;
diff --git a/src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java b/src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java
index 6c5d0f13..2dd70cd4 100644
--- a/src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java
+++ b/src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java
@@ -30,7 +30,6 @@
  */
 public class PathFileComparatorTest extends ComparatorAbstractTest {
 
-
     @BeforeEach
     public void setUp() {
         comparator = (AbstractFileComparator) PathFileComparator.PATH_COMPARATOR;
diff --git a/src/test/java/org/apache/commons/io/file/AbstractPathWrapper.java b/src/test/java/org/apache/commons/io/file/AbstractPathWrapper.java
index 674ee3de..ef7ba419 100644
--- a/src/test/java/org/apache/commons/io/file/AbstractPathWrapper.java
+++ b/src/test/java/org/apache/commons/io/file/AbstractPathWrapper.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.net.URI;
 import java.nio.file.FileSystem;
+import java.nio.file.Files;
 import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.nio.file.WatchEvent.Kind;
@@ -80,6 +81,16 @@ public boolean equals(final Object obj) {
         return Objects.equals(path, other.path);
     }
 
+    /**
+     * Delegates to {@link Files#exists(Path, LinkOption...)}.
+     *
+     * @param options See {@link Files#exists(Path, LinkOption...)}.
+     * @return See {@link Files#exists(Path, LinkOption...)}.
+     */
+    public boolean exists(final LinkOption... options) {
+        return Files.exists(path, options);
+    }
+
     @Override
     public void forEach(final Consumer<? super Path> action) {
         path.forEach(action);
diff --git a/src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java b/src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java
index 16bd66cc..6db3a0e8 100644
--- a/src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java
+++ b/src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java
@@ -31,6 +31,26 @@
  */
 public abstract class AbstractTempDirTest {
 
+    protected static final String SUB_DIR = "subdir";
+    protected static final String SYMLINKED_DIR = "symlinked-dir";
+
+    /**
+     * Creates directory test fixtures in the given directory {@code rootDir}.
+     * <ol>
+     * <li>{@code rootDir/subdir}</li>
+     * <li>{@code rootDir/symlinked-dir} -> {@code rootDir/subdir}</li>
+     * </ol>
+     * @param rootDir Root for directory entries.
+     * @return Path for {@code tempDirPath/subdir}.
+     * @throws IOException if an I/O error occurs or the parent directory does not exist.
+     */
+    protected static Path createTempSymbolicLinkedRelativeDir(final Path rootDir) throws IOException {
+        final Path targetDir = rootDir.resolve(SUB_DIR);
+        final Path symlinkDir = rootDir.resolve(SYMLINKED_DIR);
+        Files.createDirectory(targetDir);
+        return Files.createSymbolicLink(symlinkDir, targetDir);
+    }
+
     /**
      * A temporary directory managed by JUnit.
      */
@@ -38,14 +58,14 @@ public abstract class AbstractTempDirTest {
     public Path managedTempDirPath;
 
     /**
-     * A temporary directory managed by each test so we can optionally fiddle with its permissions independently.
+     * A File version of this test's Path object.
      */
-    public Path tempDirPath;
+    public File tempDirFile;
 
     /**
-     * A File version of this test's Path object.
+     * A temporary directory managed by each test so we can optionally fiddle with its permissions independently.
      */
-    public File tempDirFile;
+    public Path tempDirPath;
 
     @BeforeEach
     public void beforeEachCreateTempDirs() throws IOException {
@@ -53,7 +73,7 @@ public void beforeEachCreateTempDirs() throws IOException {
         tempDirFile = tempDirPath.toFile();
     }
 
-
+    @SuppressWarnings("resource") // no FileSystem allocation
     protected final boolean isPosixFilePermissionsSupported() {
         return FileSystems.getDefault().supportedFileAttributeViews().contains("posix");
     }
diff --git a/src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java b/src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java
index 62069b62..45b5513e 100644
--- a/src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java
+++ b/src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java
@@ -19,6 +19,7 @@
 
 import static org.apache.commons.io.file.CounterAssertions.assertCounts;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
@@ -111,6 +112,25 @@ public void testEmptyFolder(final Supplier<AccumulatorPathVisitor> supplier) thr
         assertEquals(accPathVisitor.hashCode(), accPathVisitor.hashCode());
     }
 
+    @Test
+    public void testEqualsHashCode() {
+        final AccumulatorPathVisitor visitor0 = AccumulatorPathVisitor.withLongCounters();
+        final AccumulatorPathVisitor visitor1 = AccumulatorPathVisitor.withLongCounters();
+        assertEquals(visitor0, visitor0);
+        assertEquals(visitor0, visitor1);
+        assertEquals(visitor1, visitor0);
+        assertEquals(visitor0.hashCode(), visitor0.hashCode());
+        assertEquals(visitor0.hashCode(), visitor1.hashCode());
+        assertEquals(visitor1.hashCode(), visitor0.hashCode());
+        visitor0.getPathCounters().getByteCounter().increment();
+        assertEquals(visitor0, visitor0);
+        assertNotEquals(visitor0, visitor1);
+        assertNotEquals(visitor1, visitor0);
+        assertEquals(visitor0.hashCode(), visitor0.hashCode());
+        assertNotEquals(visitor0.hashCode(), visitor1.hashCode());
+        assertNotEquals(visitor1.hashCode(), visitor0.hashCode());
+    }
+
     /**
      * Tests a directory with one file of size 0.
      */
diff --git a/src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java b/src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java
index 569bf67a..52983f96 100644
--- a/src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java
+++ b/src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java
@@ -29,6 +29,7 @@
 
 import org.apache.commons.io.file.Counters.PathCounters;
 import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -136,4 +137,23 @@ public void testCleanFolders2FileSize2(final CleaningPathVisitor visitor) throws
         assertEquals(visitFileTree, visitFileTree);
         assertEquals(visitFileTree.hashCode(), visitFileTree.hashCode());
     }
+
+    @Test
+    public void testEqualsHashCode() {
+        final CountingPathVisitor visitor0 = CleaningPathVisitor.withLongCounters();
+        final CountingPathVisitor visitor1 = CleaningPathVisitor.withLongCounters();
+        assertEquals(visitor0, visitor0);
+        assertEquals(visitor0, visitor1);
+        assertEquals(visitor1, visitor0);
+        assertEquals(visitor0.hashCode(), visitor0.hashCode());
+        assertEquals(visitor0.hashCode(), visitor1.hashCode());
+        assertEquals(visitor1.hashCode(), visitor0.hashCode());
+        visitor0.getPathCounters().getByteCounter().increment();
+        assertEquals(visitor0, visitor0);
+        assertNotEquals(visitor0, visitor1);
+        assertNotEquals(visitor1, visitor0);
+        assertEquals(visitor0.hashCode(), visitor0.hashCode());
+        assertNotEquals(visitor0.hashCode(), visitor1.hashCode());
+        assertNotEquals(visitor1.hashCode(), visitor0.hashCode());
+    }
 }
diff --git a/src/test/java/org/apache/commons/io/file/DeletablePath.java b/src/test/java/org/apache/commons/io/file/DeletablePath.java
index 9f9fbf07..e998dc09 100644
--- a/src/test/java/org/apache/commons/io/file/DeletablePath.java
+++ b/src/test/java/org/apache/commons/io/file/DeletablePath.java
@@ -39,7 +39,6 @@ public DeletablePath(final Path path) {
         super(path);
     }
 
-
     @Override
     public void close() throws IOException {
         delete();
diff --git a/src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java b/src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java
index 800c2723..d20b76e4 100644
--- a/src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java
+++ b/src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java
@@ -18,28 +18,32 @@
 package org.apache.commons.io.file;
 
 import static org.apache.commons.io.file.CounterAssertions.assertCounts;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 
 import org.apache.commons.io.file.Counters.PathCounters;
 import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.io.TempDir;
+import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests {@link DeletingPathVisitor}.
  */
-public class DeletingPathVisitorTest extends TestArguments {
+public class DeletingPathVisitorTest extends AbstractTempDirTest {
 
-    @TempDir
-    private Path tempDir;
+    private static final String ARGS = "org.apache.commons.io.file.TestArguments#";
 
     private void applyDeleteEmptyDirectory(final DeletingPathVisitor visitor) throws IOException {
-        Files.walkFileTree(tempDir, visitor);
+        Files.walkFileTree(tempDirPath, visitor);
         assertCounts(1, 0, 0, visitor);
     }
 
@@ -47,59 +51,59 @@ private void applyDeleteEmptyDirectory(final DeletingPathVisitor visitor) throws
      * Tests an empty folder.
      */
     @ParameterizedTest
-    @MethodSource("deletingPathVisitors")
+    @MethodSource(ARGS + "deletingPathVisitors")
     public void testDeleteEmptyDirectory(final DeletingPathVisitor visitor) throws IOException {
         applyDeleteEmptyDirectory(visitor);
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
      * Tests an empty folder.
      */
     @ParameterizedTest
-    @MethodSource("pathCounters")
+    @MethodSource(ARGS + "pathCounters")
     public void testDeleteEmptyDirectoryNullCtorArg(final PathCounters pathCounters) throws IOException {
         applyDeleteEmptyDirectory(new DeletingPathVisitor(pathCounters, (String[]) null));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
      * Tests a directory with one file of size 0.
      */
     @ParameterizedTest
-    @MethodSource("deletingPathVisitors")
+    @MethodSource(ARGS + "deletingPathVisitors")
     public void testDeleteFolders1FileSize0(final DeletingPathVisitor visitor) throws IOException {
-        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-0"), tempDir);
-        assertCounts(1, 1, 0, PathUtils.visitFileTree(visitor, tempDir));
+        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-0"), tempDirPath);
+        assertCounts(1, 1, 0, PathUtils.visitFileTree(visitor, tempDirPath));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
      * Tests a directory with one file of size 1.
      */
     @ParameterizedTest
-    @MethodSource("deletingPathVisitors")
+    @MethodSource(ARGS + "deletingPathVisitors")
     public void testDeleteFolders1FileSize1(final DeletingPathVisitor visitor) throws IOException {
-        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1"), tempDir);
-        assertCounts(1, 1, 1, PathUtils.visitFileTree(visitor, tempDir));
+        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1"), tempDirPath);
+        assertCounts(1, 1, 1, PathUtils.visitFileTree(visitor, tempDirPath));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
      * Tests a directory with one file of size 1 but skip that file.
      */
     @ParameterizedTest
-    @MethodSource("pathCounters")
+    @MethodSource(ARGS + "pathCounters")
     public void testDeleteFolders1FileSize1Skip(final PathCounters pathCounters) throws IOException {
-        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1"), tempDir);
+        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1"), tempDirPath);
         final String skipFileName = "file-size-1.bin";
         final CountingPathVisitor visitor = new DeletingPathVisitor(pathCounters, skipFileName);
-        assertCounts(1, 1, 1, PathUtils.visitFileTree(visitor, tempDir));
-        final Path skippedFile = tempDir.resolve(skipFileName);
+        assertCounts(1, 1, 1, PathUtils.visitFileTree(visitor, tempDirPath));
+        final Path skippedFile = tempDirPath.resolve(skipFileName);
         Assertions.assertTrue(Files.exists(skippedFile));
         Files.delete(skippedFile);
     }
@@ -108,11 +112,68 @@ public void testDeleteFolders1FileSize1Skip(final PathCounters pathCounters) thr
      * Tests a directory with two subdirectories, each containing one file of size 1.
      */
     @ParameterizedTest
-    @MethodSource("deletingPathVisitors")
+    @MethodSource(ARGS + "deletingPathVisitors")
     public void testDeleteFolders2FileSize2(final DeletingPathVisitor visitor) throws IOException {
-        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-2-file-size-2"), tempDir);
-        assertCounts(3, 2, 2, PathUtils.visitFileTree(visitor, tempDir));
+        PathUtils.copyDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-2-file-size-2"), tempDirPath);
+        assertCounts(3, 2, 2, PathUtils.visitFileTree(visitor, tempDirPath));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
+    }
+
+    @Test
+    public void testEqualsHashCode() {
+        final DeletingPathVisitor visitor0 = DeletingPathVisitor.withLongCounters();
+        final DeletingPathVisitor visitor1 = DeletingPathVisitor.withLongCounters();
+        assertEquals(visitor0, visitor0);
+        assertEquals(visitor0, visitor1);
+        assertEquals(visitor1, visitor0);
+        assertEquals(visitor0.hashCode(), visitor0.hashCode());
+        assertEquals(visitor0.hashCode(), visitor1.hashCode());
+        assertEquals(visitor1.hashCode(), visitor0.hashCode());
+        visitor0.getPathCounters().getByteCounter().increment();
+        assertEquals(visitor0, visitor0);
+        assertNotEquals(visitor0, visitor1);
+        assertNotEquals(visitor1, visitor0);
+        assertEquals(visitor0.hashCode(), visitor0.hashCode());
+        assertNotEquals(visitor0.hashCode(), visitor1.hashCode());
+        assertNotEquals(visitor1.hashCode(), visitor0.hashCode());
+    }
+
+    /**
+     * Tests https://issues.apache.org/jira/browse/IO-850
+     */
+    @Test
+    public void testIO850DirectoriesAndFiles() throws IOException {
+        final Path rootDir = Files.createDirectory(managedTempDirPath.resolve("IO850"));
+        createTempSymbolicLinkedRelativeDir(rootDir);
+        final Path targetDir = rootDir.resolve(SUB_DIR);
+        final Path symlinkDir = rootDir.resolve(SYMLINKED_DIR);
+        Files.write(targetDir.resolve("file0.txt"), "Hello".getBytes(StandardCharsets.UTF_8));
+        final Path subDir0 = Files.createDirectory(targetDir.resolve("subDir0"));
+        Files.write(subDir0.resolve("file1.txt"), "Hello".getBytes(StandardCharsets.UTF_8));
+        final DeletingPathVisitor visitor = DeletingPathVisitor.withLongCounters();
+        Files.walkFileTree(rootDir, visitor);
+        assertFalse(Files.exists(targetDir));
+        assertFalse(Files.exists(symlinkDir));
+        assertFalse(Files.exists(rootDir));
+        assertTrue(visitor.getPathCounters().getDirectoryCounter().get() > 0);
+        assertTrue(visitor.getPathCounters().getFileCounter().get() > 0);
+    }
+
+    /**
+     * Tests https://issues.apache.org/jira/browse/IO-850
+     */
+    @Test
+    public void testIO850DirectoriesOnly() throws IOException {
+        final Path rootDir = Files.createDirectory(managedTempDirPath.resolve("IO850"));
+        createTempSymbolicLinkedRelativeDir(rootDir);
+        final Path targetDir = rootDir.resolve(SUB_DIR);
+        final Path symlinkDir = rootDir.resolve(SYMLINKED_DIR);
+        final DeletingPathVisitor visitor = DeletingPathVisitor.withLongCounters();
+        Files.walkFileTree(rootDir, visitor);
+        assertFalse(Files.exists(targetDir));
+        assertFalse(Files.exists(symlinkDir));
+        assertFalse(Files.exists(rootDir));
+        assertTrue(visitor.getPathCounters().getDirectoryCounter().get() > 0);
     }
 }
diff --git a/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java b/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java
index 60e5442b..326a9e48 100644
--- a/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java
+++ b/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java
@@ -44,7 +44,7 @@ public void testFilterByName() throws Exception {
         try (DirectoryStream<Path> stream = Files.newDirectoryStream(PathUtils.current(), streamFilter)) {
             final Iterator<Path> iterator = stream.iterator();
             final Path path = iterator.next();
-            assertEquals(PATH_FIXTURE, path.getFileName().toString());
+            assertEquals(PATH_FIXTURE, PathUtils.getFileNameString(path));
             assertFalse(iterator.hasNext());
         }
     }
@@ -55,7 +55,7 @@ public void testFilterByNameNot() throws Exception {
         final DirectoryStreamFilter streamFilter = new DirectoryStreamFilter(pathFilter);
         assertEquals(pathFilter, streamFilter.getPathFilter());
         try (DirectoryStream<Path> stream = Files.newDirectoryStream(PathUtils.current(), streamFilter)) {
-            stream.forEach(path -> assertNotEquals(PATH_FIXTURE, path.getFileName().toString()));
+            stream.forEach(path -> assertNotEquals(PATH_FIXTURE, PathUtils.getFileNameString(path)));
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/file/FilesUncheckTest.java b/src/test/java/org/apache/commons/io/file/FilesUncheckTest.java
index 80f4d37b..6cf8447b 100644
--- a/src/test/java/org/apache/commons/io/file/FilesUncheckTest.java
+++ b/src/test/java/org/apache/commons/io/file/FilesUncheckTest.java
@@ -96,7 +96,7 @@ public void deleteFixtures() throws IOException {
 
     @Test
     public void testCopyInputStreamPathCopyOptionArray() {
-        assertEquals(0, FilesUncheck.copy(NullInputStream.INSTANCE, NEW_FILE_PATH, PathUtils.EMPTY_COPY_OPTIONS));
+        assertEquals(0, FilesUncheck.copy(new NullInputStream(), NEW_FILE_PATH, PathUtils.EMPTY_COPY_OPTIONS));
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java b/src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java
index 13ea17f2..38769267 100644
--- a/src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java
+++ b/src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java
@@ -23,6 +23,8 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -196,4 +198,30 @@ public void testFileContentEquals() throws Exception {
         assertTrue(PathUtils.fileContentEquals(path1, path2));
     }
 
+    @Test
+    public void testFileContentEqualsZip() throws Exception {
+        final Path path1 = Paths.get("src/test/resources/org/apache/commons/io/bla.zip");
+        final Path path2 = Paths.get("src/test/resources/org/apache/commons/io/bla-copy.zip");
+        // moby.zip is from https://issues.apache.org/jira/browse/COMPRESS-93
+        final Path path3 = Paths.get("src/test/resources/org/apache/commons/io/moby.zip");
+        assertTrue(PathUtils.fileContentEquals(path1, path2));
+        assertFalse(PathUtils.fileContentEquals(path1, path3));
+    }
+
+    @Test
+    public void testFileContentEqualsZipFileSystem() throws Exception {
+        try (FileSystem fileSystem = FileSystems.newFileSystem(Paths.get("src/test/resources/org/apache/commons/io/test-same-size-diff-contents.zip"),
+                ClassLoader.getSystemClassLoader())) {
+            // Contains one char: A
+            final Path path1 = fileSystem.getPath("/test-same-size-diff-contents/A.txt");
+            // Contains one char: B
+            final Path path2 = fileSystem.getPath("/test-same-size-diff-contents/B.txt");
+            assertTrue(Files.exists(path1));
+            assertTrue(Files.exists(path2));
+            assertTrue(PathUtils.fileContentEquals(path1, path1));
+            assertTrue(PathUtils.fileContentEquals(path2, path2));
+            assertFalse(PathUtils.fileContentEquals(path1, path2));
+        }
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java b/src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java
index 6383f646..bafd9ed5 100644
--- a/src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java
+++ b/src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java
@@ -32,44 +32,23 @@
 
 import org.apache.commons.io.file.Counters.PathCounters;
 import org.apache.commons.lang3.SystemUtils;
-import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 /**
  * Tests {@link DeletingPathVisitor}.
  */
-public class PathUtilsDeleteFileTest {
-
-    private Path tempDir;
-
-    @AfterEach
-    public void afterEach() throws IOException {
-        // backstop
-        if (Files.exists(tempDir) && PathUtils.isEmptyDirectory(tempDir)) {
-            Files.deleteIfExists(tempDir);
-        }
-    }
-
-    @BeforeEach
-    public void beforeEach() throws IOException {
-        tempDir = Files.createTempDirectory(getClass().getCanonicalName());
-    }
+public class PathUtilsDeleteFileTest extends AbstractTempDirTest {
 
     @Test
-    public void testDeleteBrokenLink() throws IOException {
+    public void testDeleteBrokenSymbolicLink() throws IOException {
         assumeFalse(SystemUtils.IS_OS_WINDOWS);
-
-        final Path missingFile = tempDir.resolve("missing.txt");
-        final Path brokenLink = tempDir.resolve("broken.txt");
+        final Path missingFile = tempDirPath.resolve("missing.txt");
+        final Path brokenLink = tempDirPath.resolve("broken.txt");
         Files.createSymbolicLink(brokenLink, missingFile);
-
         assertTrue(Files.exists(brokenLink, LinkOption.NOFOLLOW_LINKS));
         assertFalse(Files.exists(missingFile, LinkOption.NOFOLLOW_LINKS));
-
         PathUtils.deleteFile(brokenLink);
-
         assertFalse(Files.exists(brokenLink, LinkOption.NOFOLLOW_LINKS), "Symbolic link not removed");
     }
 
@@ -79,10 +58,10 @@ public void testDeleteBrokenLink() throws IOException {
     @Test
     public void testDeleteFileDirectory1FileSize0() throws IOException {
         final String fileName = "file-size-0.bin";
-        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-0/" + fileName), tempDir);
-        assertCounts(0, 1, 0, PathUtils.deleteFile(tempDir.resolve(fileName)));
+        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-0/" + fileName), tempDirPath);
+        assertCounts(0, 1, 0, PathUtils.deleteFile(tempDirPath.resolve(fileName)));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
@@ -91,10 +70,10 @@ public void testDeleteFileDirectory1FileSize0() throws IOException {
     @Test
     public void testDeleteFileDirectory1FileSize1() throws IOException {
         final String fileName = "file-size-1.bin";
-        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1/" + fileName), tempDir);
-        assertCounts(0, 1, 1, PathUtils.deleteFile(tempDir.resolve(fileName)));
+        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1/" + fileName), tempDirPath);
+        assertCounts(0, 1, 1, PathUtils.deleteFile(tempDirPath.resolve(fileName)));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
@@ -102,9 +81,9 @@ public void testDeleteFileDirectory1FileSize1() throws IOException {
      */
     @Test
     public void testDeleteFileDoesNotExist() throws IOException {
-        testDeleteFileEmpty(PathUtils.deleteFile(tempDir.resolve("file-does-not-exist.bin")));
+        testDeleteFileEmpty(PathUtils.deleteFile(tempDirPath.resolve("file-does-not-exist.bin")));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     private void testDeleteFileEmpty(final PathCounters pathCounts) {
@@ -116,9 +95,9 @@ private void testDeleteFileEmpty(final PathCounters pathCounts) {
      */
     @Test
     public void testDeleteFileEmptyDirectory() throws IOException {
-        Assertions.assertThrows(NoSuchFileException.class, () -> testDeleteFileEmpty(PathUtils.deleteFile(tempDir)));
+        Assertions.assertThrows(NoSuchFileException.class, () -> testDeleteFileEmpty(PathUtils.deleteFile(tempDirPath)));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
@@ -127,8 +106,8 @@ public void testDeleteFileEmptyDirectory() throws IOException {
     @Test
     public void testDeleteReadOnlyFileDirectory1FileSize1() throws IOException {
         final String fileName = "file-size-1.bin";
-        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1/" + fileName), tempDir);
-        final Path resolved = tempDir.resolve(fileName);
+        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1/" + fileName), tempDirPath);
+        final Path resolved = tempDirPath.resolve(fileName);
         PathUtils.setReadOnly(resolved, true);
         if (SystemUtils.IS_OS_WINDOWS) {
             // Fails on Windows's Ubuntu subsystem.
@@ -137,7 +116,7 @@ public void testDeleteReadOnlyFileDirectory1FileSize1() throws IOException {
         }
         assertCounts(0, 1, 1, PathUtils.deleteFile(resolved, StandardDeleteOption.OVERRIDE_READ_ONLY));
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 
     /**
@@ -146,8 +125,8 @@ public void testDeleteReadOnlyFileDirectory1FileSize1() throws IOException {
     @Test
     public void testSetReadOnlyFileDirectory1FileSize1() throws IOException {
         final String fileName = "file-size-1.bin";
-        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1/" + fileName), tempDir);
-        final Path resolved = tempDir.resolve(fileName);
+        PathUtils.copyFileToDirectory(Paths.get("src/test/resources/org/apache/commons/io/dirs-1-file-size-1/" + fileName), tempDirPath);
+        final Path resolved = tempDirPath.resolve(fileName);
         PathUtils.setReadOnly(resolved, true);
         if (SystemUtils.IS_OS_WINDOWS) {
             // Fails on Windows's Ubuntu subsystem.
@@ -157,6 +136,6 @@ public void testSetReadOnlyFileDirectory1FileSize1() throws IOException {
         PathUtils.setReadOnly(resolved, false);
         PathUtils.deleteFile(resolved);
         // This will throw if not empty.
-        Files.deleteIfExists(tempDir);
+        Files.deleteIfExists(tempDirPath);
     }
 }
diff --git a/src/test/java/org/apache/commons/io/file/PathUtilsTest.java b/src/test/java/org/apache/commons/io/file/PathUtilsTest.java
index 622937e4..c98ae72c 100644
--- a/src/test/java/org/apache/commons/io/file/PathUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/file/PathUtilsTest.java
@@ -55,6 +55,7 @@
 import org.apache.commons.io.test.TestUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.SystemProperties;
 import org.apache.commons.lang3.SystemUtils;
 import org.junit.jupiter.api.Test;
 
@@ -73,24 +74,6 @@ public class PathUtilsTest extends AbstractTempDirTest {
 
     private static final String PATH_FIXTURE = "NOTICE.txt";
 
-    /**
-     * Creates directory test fixtures.
-     * <ol>
-     * <li>tempDirPath/subdir</li>
-     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>
-     * </ol>
-     *
-     * @return Path to tempDirPath/subdir
-     * @throws IOException if an I/O error occurs or the parent directory does not exist.
-     */
-    private Path createTempSymlinkedRelativeDir() throws IOException {
-        final Path targetDir = tempDirPath.resolve("subdir");
-        final Path symlinkDir = tempDirPath.resolve("symlinked-dir");
-        Files.createDirectory(targetDir);
-        Files.createSymbolicLink(symlinkDir, targetDir);
-        return symlinkDir;
-    }
-
     private Path current() {
         return PathUtils.current();
     }
@@ -154,7 +137,8 @@ public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() th
     @Test
     public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {
         final Path archivePath = Paths.get(TEST_JAR_PATH);
-        try (FileSystem archive = openArchive(archivePath, false); final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {
+        try (FileSystem archive = openArchive(archivePath, false);
+                final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {
             final Path targetDir = targetArchive.getPath("targetDir");
             Files.createDirectory(targetDir);
             // relative jar -> relative dir
@@ -233,7 +217,7 @@ public void testCreateDirectoriesNew() throws IOException {
 
     @Test
     public void testCreateDirectoriesSymlink() throws IOException {
-        final Path symlinkedDir = createTempSymlinkedRelativeDir();
+        final Path symlinkedDir = createTempSymbolicLinkedRelativeDir(tempDirPath);
         final String leafDirName = "child";
         final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);
         assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);
@@ -241,10 +225,91 @@ public void testCreateDirectoriesSymlink() throws IOException {
 
     @Test
     public void testCreateDirectoriesSymlinkClashing() throws IOException {
-        final Path symlinkedDir = createTempSymlinkedRelativeDir();
+        final Path symlinkedDir = createTempSymbolicLinkedRelativeDir(tempDirPath);
         assertEquals(symlinkedDir, PathUtils.createParentDirectories(symlinkedDir.resolve("child")));
     }
 
+    @Test
+    public void testGetBaseNamePathBaseCases() {
+        assertEquals("bar", PathUtils.getBaseName(Paths.get("a/b/c/bar.foo")));
+        assertEquals("foo", PathUtils.getBaseName(Paths.get("foo")));
+        assertEquals("", PathUtils.getBaseName(Paths.get("")));
+        assertEquals("", PathUtils.getBaseName(Paths.get(".")));
+        for (final File f : File.listRoots()) {
+            assertNull(PathUtils.getBaseName(f.toPath()));
+        }
+        if (SystemUtils.IS_OS_WINDOWS) {
+            assertNull(PathUtils.getBaseName(Paths.get("C:\\")));
+        }
+    }
+
+    @Test
+    public void testGetBaseNamePathCornerCases() {
+        assertNull(PathUtils.getBaseName((Path) null));
+        assertEquals("foo", PathUtils.getBaseName(Paths.get("foo.")));
+        assertEquals("", PathUtils.getBaseName(Paths.get("bar/.foo")));
+    }
+
+    @Test
+    public void testGetDosFileAttributeView() {
+        // dir
+        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(current());
+        final Path path = Paths.get("this-file-does-not-exist-at.all");
+        assertFalse(Files.exists(path));
+        if (SystemUtils.IS_OS_MAC) {
+            assertNull(dosFileAttributeView);
+            // missing file
+            assertNull(PathUtils.getDosFileAttributeView(path));
+        } else {
+            assertNotNull(dosFileAttributeView);
+            // missing file
+            assertNotNull(PathUtils.getDosFileAttributeView(path));
+        }
+        // null
+        assertThrows(NullPointerException.class, () -> PathUtils.getDosFileAttributeView(null));
+    }
+
+    @Test
+    public void testGetExtension() {
+        assertNull(PathUtils.getExtension(null));
+        assertEquals("ext", PathUtils.getExtension(Paths.get("file.ext")));
+        assertEquals("", PathUtils.getExtension(Paths.get("README")));
+        assertEquals("com", PathUtils.getExtension(Paths.get("domain.dot.com")));
+        assertEquals("jpeg", PathUtils.getExtension(Paths.get("image.jpeg")));
+        assertEquals("", PathUtils.getExtension(Paths.get("a.b/c")));
+        assertEquals("txt", PathUtils.getExtension(Paths.get("a.b/c.txt")));
+        assertEquals("", PathUtils.getExtension(Paths.get("a/b/c")));
+        assertEquals("", PathUtils.getExtension(Paths.get("a.b\\c")));
+        assertEquals("txt", PathUtils.getExtension(Paths.get("a.b\\c.txt")));
+        assertEquals("", PathUtils.getExtension(Paths.get("a\\b\\c")));
+        assertEquals("", PathUtils.getExtension(Paths.get("C:\\temp\\foo.bar\\README")));
+        assertEquals("ext", PathUtils.getExtension(Paths.get("../filename.ext")));
+
+        if (File.separatorChar != '\\') {
+            // Upwards compatibility:
+            assertEquals("txt", PathUtils.getExtension(Paths.get("foo.exe:bar.txt")));
+        }
+    }
+
+    @Test
+    public void testGetFileName() {
+        assertNull(PathUtils.getFileName(null, null));
+        assertNull(PathUtils.getFileName(null, Path::toString));
+        assertNull(PathUtils.getFileName(Paths.get("/"), Path::toString));
+        assertNull(PathUtils.getFileName(Paths.get("/"), Path::toString));
+        assertEquals("", PathUtils.getFileName(Paths.get(""), Path::toString));
+        assertEquals("a", PathUtils.getFileName(Paths.get("a"), Path::toString));
+        assertEquals("a", PathUtils.getFileName(Paths.get("p", "a"), Path::toString));
+    }
+
+    @Test
+    public void testGetFileNameString() {
+        assertNull(PathUtils.getFileNameString(Paths.get("/")));
+        assertEquals("", PathUtils.getFileNameString(Paths.get("")));
+        assertEquals("a", PathUtils.getFileNameString(Paths.get("a")));
+        assertEquals("a", PathUtils.getFileNameString(Paths.get("p", "a")));
+    }
+
     @Test
     public void testGetLastModifiedFileTime_File_Present() throws IOException {
         assertNotNull(PathUtils.getLastModifiedFileTime(current().toFile()));
@@ -278,7 +343,7 @@ public void testGetLastModifiedFileTime_URL_Present() throws IOException, URISyn
 
     @Test
     public void testGetTempDirectory() {
-        final Path tempDirectory = Paths.get(System.getProperty("java.io.tmpdir"));
+        final Path tempDirectory = Paths.get(SystemProperties.getJavaIoTmpdir());
         assertEquals(tempDirectory, PathUtils.getTempDirectory());
     }
 
@@ -311,6 +376,12 @@ public void testIsPosix() throws IOException {
         assertEquals(isPosix, PathUtils.isPosix(current()));
     }
 
+    @Test
+    public void testIsPosixAbsentFile() {
+        assertFalse(PathUtils.isPosix(Paths.get("ImNotHereAtAllEver.never")));
+        assertFalse(PathUtils.isPosix(null));
+    }
+
     @Test
     public void testIsRegularFile() throws IOException {
         assertFalse(PathUtils.isRegularFile(null));
@@ -330,7 +401,7 @@ public void testNewDirectoryStream() throws Exception {
         try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(current(), pathFilter)) {
             final Iterator<Path> iterator = stream.iterator();
             final Path path = iterator.next();
-            assertEquals(PATH_FIXTURE, path.getFileName().toString());
+            assertEquals(PATH_FIXTURE, PathUtils.getFileNameString(path));
             assertFalse(iterator.hasNext());
         }
     }
@@ -365,7 +436,7 @@ public void testNewOutputStreamNewFileAppendTrue() throws IOException {
 
     @Test
     public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {
-        final Path symlinkDir = createTempSymlinkedRelativeDir();
+        final Path symlinkDir = createTempSymbolicLinkedRelativeDir(tempDirPath);
         final Path file = symlinkDir.resolve("test.txt");
         try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {
             // empty
@@ -469,6 +540,11 @@ public void testSetReadOnlyFile() throws IOException {
         PathUtils.deleteFile(resolved);
     }
 
+    @Test
+    public void testSetReadOnlyFileAbsent() {
+        assertThrows(IOException.class, () -> PathUtils.setReadOnly(Paths.get("does-not-exist-at-all-ever-never"), true));
+    }
+
     @Test
     public void testTouch() throws IOException {
         assertThrows(NullPointerException.class, () -> FileUtils.touch(null));
diff --git a/src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java b/src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java
index 8d506ccf..d2ef1638 100644
--- a/src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java
+++ b/src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java
@@ -19,10 +19,12 @@
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.nio.file.attribute.FileTime;
 import java.time.Instant;
 import java.util.Date;
+import java.util.concurrent.TimeUnit;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
@@ -75,6 +77,18 @@ public static Stream<Arguments> fileTimeToNtfsProvider() {
         // @formatter:on
     }
 
+    public static Stream<Arguments> isUnixFileTimeProvider() {
+        // @formatter:off
+        return Stream.of(
+            Arguments.of("2022-12-27T12:45:22Z", true),
+            Arguments.of("2038-01-19T03:14:07Z", true),
+            Arguments.of("1901-12-13T23:14:08Z", true),
+            Arguments.of("1901-12-13T03:14:08Z", false),
+            Arguments.of("2038-01-19T03:14:08Z", false),
+            Arguments.of("2099-06-30T12:31:42Z", false));
+        // @formatter:on
+    }
+
     @ParameterizedTest
     @MethodSource("dateToNtfsProvider")
     public void testDateToFileTime(final String instant, final long ignored) {
@@ -90,6 +104,7 @@ public void testDateToNtfsTime(final String instant, final long ntfsTime) {
         final long ntfsMillis = Math.floorDiv(ntfsTime, FileTimes.HUNDRED_NANOS_PER_MILLISECOND) * FileTimes.HUNDRED_NANOS_PER_MILLISECOND;
         final Date parsed = Date.from(Instant.parse(instant));
         assertEquals(ntfsMillis, FileTimes.toNtfsTime(parsed));
+        assertEquals(ntfsMillis, FileTimes.toNtfsTime(parsed.getTime()));
     }
 
     @Test
@@ -113,7 +128,28 @@ public void testFileTimeToNtfsTime(final String instant, final long ntfsTime) {
         assertEquals(ntfsTime, FileTimes.toNtfsTime(parsed));
     }
 
-    //
+    @ParameterizedTest
+    @MethodSource("dateToNtfsProvider")
+    public void testFromUnixTime(final String instant, final long ntfsTime) {
+        final long epochSecond = Instant.parse(instant).getEpochSecond();
+        assertEquals(epochSecond, FileTimes.fromUnixTime(epochSecond).to(TimeUnit.SECONDS));
+    }
+
+    @ParameterizedTest
+    @MethodSource("isUnixFileTimeProvider")
+    public void testIsUnixTime(final String instant, final boolean isUnixTime) {
+        assertEquals(isUnixTime, FileTimes.isUnixTime(FileTime.from(Instant.parse(instant))));
+    }
+
+    public void testIsUnixTimeFileTimeNull() {
+        assertTrue(FileTimes.isUnixTime(null));
+    }
+
+    @ParameterizedTest
+    @MethodSource("isUnixFileTimeProvider")
+    public void testIsUnixTimeLong(final String instant, final boolean isUnixTime) {
+        assertEquals(isUnixTime, FileTimes.isUnixTime(Instant.parse(instant).getEpochSecond()));
+    }
 
     @Test
     public void testMinusMillis() {
@@ -179,4 +215,10 @@ public void testPlusSeconds() {
         assertEquals(Instant.EPOCH.plusSeconds(seconds), FileTimes.plusSeconds(FileTimes.EPOCH, seconds).toInstant());
         assertEquals(Instant.EPOCH, FileTimes.plusSeconds(FileTimes.EPOCH, 0).toInstant());
     }
+
+    @ParameterizedTest
+    @MethodSource("isUnixFileTimeProvider")
+    public void testToUnixTime(final String instant, final boolean isUnixTime) {
+        assertEquals(isUnixTime, FileTimes.isUnixTime(FileTimes.toUnixTime(FileTime.from(Instant.parse(instant)))));
+    }
 }
diff --git a/src/test/java/org/apache/commons/io/filefilter/AbstractConditionalFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/AbstractConditionalFileFilterTest.java
index a663e5f6..3a0dbe35 100644
--- a/src/test/java/org/apache/commons/io/filefilter/AbstractConditionalFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/AbstractConditionalFileFilterTest.java
@@ -60,7 +60,7 @@ public abstract class AbstractConditionalFileFilterTest extends AbstractIOFileFi
 
     @BeforeEach
     public void setUp() {
-        this.workingPath = determineWorkingDirectoryPath(this.getWorkingPathNamePropertyKey(), this.getDefaultWorkingPath());
+        this.workingPath = determineWorkingDirectoryPath(getWorkingPathNamePropertyKey(), getDefaultWorkingPath());
         this.file = new File(this.workingPath, TEST_FILE_NAME_PREFIX + 1 + TEST_FILE_TYPE);
         this.trueFilters = new TesterTrueFileFilter[4];
         this.falseFilters = new TesterFalseFileFilter[4];
@@ -75,7 +75,7 @@ public void setUp() {
     @Test
     public void testAdd() {
         final List<TesterTrueFileFilter> filters = new ArrayList<>();
-        final ConditionalFileFilter fileFilter = this.getConditionalFileFilter();
+        final ConditionalFileFilter fileFilter = getConditionalFileFilter();
         filters.add(new TesterTrueFileFilter());
         filters.add(new TesterTrueFileFilter());
         filters.add(new TesterTrueFileFilter());
@@ -93,11 +93,11 @@ public void testAdd() {
 
     @Test
     public void testFilterBuiltUsingAdd() {
-        final List<List<IOFileFilter>> testFilters = this.getTestFilters();
-        final List<boolean[]> testTrueResults = this.getTrueResults();
-        final List<boolean[]> testFalseResults = this.getFalseResults();
-        final List<Boolean> testFileResults = this.getFileResults();
-        final List<Boolean> testFilenameResults = this.getFilenameResults();
+        final List<List<IOFileFilter>> testFilters = getTestFilters();
+        final List<boolean[]> testTrueResults = getTrueResults();
+        final List<boolean[]> testFalseResults = getFalseResults();
+        final List<Boolean> testFileResults = getFileResults();
+        final List<Boolean> testFilenameResults = getFilenameResults();
 
         for (int i = 1; i < testFilters.size(); i++) {
             final List<IOFileFilter> filters = testFilters.get(i);
@@ -107,7 +107,7 @@ public void testFilterBuiltUsingAdd() {
             final boolean fileNameResults = testFilenameResults.get(i);
 
             // Test conditional AND filter created by passing filters to the constructor
-            final IOFileFilter filter = this.buildFilterUsingAdd(filters);
+            final IOFileFilter filter = buildFilterUsingAdd(filters);
 
             // Test as a file filter
             resetTrueFilters(this.trueFilters);
@@ -127,11 +127,11 @@ public void testFilterBuiltUsingAdd() {
 
     @Test
     public void testFilterBuiltUsingConstructor() {
-        final List<List<IOFileFilter>> testFilters = this.getTestFilters();
-        final List<boolean[]> testTrueResults = this.getTrueResults();
-        final List<boolean[]> testFalseResults = this.getFalseResults();
-        final List<Boolean> testFileResults = this.getFileResults();
-        final List<Boolean> testFilenameResults = this.getFilenameResults();
+        final List<List<IOFileFilter>> testFilters = getTestFilters();
+        final List<boolean[]> testTrueResults = getTrueResults();
+        final List<boolean[]> testFalseResults = getFalseResults();
+        final List<Boolean> testFileResults = getFileResults();
+        final List<Boolean> testFilenameResults = getFilenameResults();
 
         for (int i = 1; i < testFilters.size(); i++) {
             final List<IOFileFilter> filters = testFilters.get(i);
@@ -141,7 +141,7 @@ public void testFilterBuiltUsingConstructor() {
             final boolean fileNameResults = testFilenameResults.get(i);
 
             // Test conditional AND filter created by passing filters to the constructor
-            final IOFileFilter filter = this.buildFilterUsingConstructor(filters);
+            final IOFileFilter filter = buildFilterUsingConstructor(filters);
 
             // Test as a file filter
             resetTrueFilters(this.trueFilters);
@@ -161,7 +161,7 @@ public void testFilterBuiltUsingConstructor() {
 
     @Test
     public void testNoFilters() {
-        final ConditionalFileFilter fileFilter = this.getConditionalFileFilter();
+        final ConditionalFileFilter fileFilter = getConditionalFileFilter();
         final File file = new File(this.workingPath, TEST_FILE_NAME_PREFIX + 1 + TEST_FILE_TYPE);
         assertFileFiltering(1, (IOFileFilter) fileFilter, file, false);
         assertFilenameFiltering(1, (IOFileFilter) fileFilter, file, false);
@@ -170,7 +170,7 @@ public void testNoFilters() {
     @Test
     public void testRemove() {
         final List<TesterTrueFileFilter> filters = new ArrayList<>();
-        final ConditionalFileFilter fileFilter = this.getConditionalFileFilter();
+        final ConditionalFileFilter fileFilter = getConditionalFileFilter();
         filters.add(new TesterTrueFileFilter());
         filters.add(new TesterTrueFileFilter());
         filters.add(new TesterTrueFileFilter());
diff --git a/src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java
index ca6f8874..d7b6a13d 100644
--- a/src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java
@@ -30,7 +30,7 @@
 import org.junit.jupiter.api.io.TempDir;
 
 /**
- * Used to test FileFilterUtils.
+ * Tests {@link FileFilterUtils} and friends.
  */
 public class AbstractFilterTest {
 
diff --git a/src/test/java/org/apache/commons/io/filefilter/AbstractIOFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/AbstractIOFileFilterTest.java
index f5ba2791..ac9db71f 100644
--- a/src/test/java/org/apache/commons/io/filefilter/AbstractIOFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/AbstractIOFileFilterTest.java
@@ -24,7 +24,7 @@
 
 public abstract class AbstractIOFileFilterTest {
 
-    class TesterFalseFileFilter extends FalseFileFilter {
+    final class TesterFalseFileFilter extends FalseFileFilter {
 
         private static final long serialVersionUID = -3603047664010401872L;
         private boolean invoked;
@@ -54,7 +54,7 @@ public void setInvoked(final boolean invoked) {
         }
     }
 
-    class TesterTrueFileFilter extends TrueFileFilter {
+    final class TesterTrueFileFilter extends TrueFileFilter {
 
         private static final long serialVersionUID = 1828930358172422914L;
         private boolean invoked;
@@ -111,16 +111,11 @@ public static void assertFiltering(final int testNumber, final IOFileFilter filt
         assertEquals(expected, filter.accept(file.toPath(), null),
                 "test " + testNumber + " Filter(File) " + filter.getClass().getName() + " not " + expected + " for " + file);
 
-        if (file != null && file.getParentFile() != null) {
+        if (file.getParentFile() != null) {
             assertEquals(expected, filter.accept(file.getParentFile(), file.getName()),
                     "test " + testNumber + " Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for " + file);
             assertEquals(expected, filter.matches(file.toPath()),
                     "test " + testNumber + " Filter(File) " + filter.getClass().getName() + " not " + expected + " for " + file);
-        } else if (file == null) {
-            assertEquals(expected, filter.accept(file),
-                    "test " + testNumber + " Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null");
-            assertEquals(expected, filter.matches(null),
-                    "test " + testNumber + " Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null");
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java
index c0ea7941..4ef34e80 100644
--- a/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java
@@ -66,14 +66,14 @@ public void testJavadocExampleUsingNio() throws IOException {
         final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoffMillis),
             TrueFileFilter.INSTANCE);
         //
-        // Walk one dir
+        // Walk one directory
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
         // System.out.println(visitor.getPathCounters());
         // System.out.println(visitor.getFileList());
         //
         visitor.getPathCounters().reset();
         //
-        // Walk dir tree
+        // Walk directory tree
         Files.walkFileTree(dir, visitor);
         // System.out.println(visitor.getPathCounters());
         // System.out.println(visitor.getDirList());
diff --git a/src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java
index 3dffd9a2..9678893d 100644
--- a/src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java
@@ -91,20 +91,6 @@ protected String getWorkingPathNamePropertyKey() {
     return WORKING_PATH_NAME_PROPERTY_KEY;
   }
 
-  @Test
-  public void setTestFiltersClearsOld() {
-    // test that new filters correctly clear old filters
-    final List<IOFileFilter> simpleEmptyFileFilter = Collections.singletonList(EmptyFileFilter.EMPTY);
-    final AndFileFilter andFileFilter = new AndFileFilter(simpleEmptyFileFilter);
-    // make sure the filters at this point are the same
-    assertEquals(simpleEmptyFileFilter, andFileFilter.getFileFilters());
-
-    final List<IOFileFilter> simpleNonEmptyFilter = Collections.singletonList(EmptyFileFilter.NOT_EMPTY);
-    // when calling the setter the filters should reference the new filters
-    andFileFilter.setFileFilters(simpleNonEmptyFilter);
-    assertEquals(simpleNonEmptyFilter, andFileFilter.getFileFilters());
-  }
-
   @BeforeEach
   public void setUpTestFilters() {
     // filters
@@ -310,4 +296,18 @@ public void setUpTestFilters() {
       testFilenameResults.add(9, Boolean.FALSE);
     }
   }
+
+  @Test
+  public void testSetTestFiltersClearsOld() {
+    // test that new filters correctly clear old filters
+    final List<IOFileFilter> simpleEmptyFileFilter = Collections.singletonList(EmptyFileFilter.EMPTY);
+    final AndFileFilter andFileFilter = new AndFileFilter(simpleEmptyFileFilter);
+    // make sure the filters at this point are the same
+    assertEquals(simpleEmptyFileFilter, andFileFilter.getFileFilters());
+
+    final List<IOFileFilter> simpleNonEmptyFilter = Collections.singletonList(EmptyFileFilter.NOT_EMPTY);
+    // when calling the setter the filters should reference the new filters
+    andFileFilter.setFileFilters(simpleNonEmptyFilter);
+    assertEquals(simpleNonEmptyFilter, andFileFilter.getFileFilters());
+  }
 }
diff --git a/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java
index eae17962..c20de4bc 100644
--- a/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java
@@ -63,14 +63,14 @@ public void testJavadocExampleUsingNio() throws IOException {
         final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(DirectoryFileFilter.INSTANCE,
             TrueFileFilter.INSTANCE);
         //
-        // Walk one dir
+        // Walk one directory
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
         // System.out.println(visitor.getPathCounters());
         // System.out.println(visitor.getFileList());
         //
         visitor.getPathCounters().reset();
         //
-        // Walk dir tree
+        // Walk directory tree
         Files.walkFileTree(dir, visitor);
         // System.out.println(visitor.getPathCounters());
         // System.out.println(visitor.getDirList());
diff --git a/src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java
index 858c4a19..c471fab6 100644
--- a/src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java
@@ -19,6 +19,7 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
@@ -54,7 +55,7 @@
 import org.junit.jupiter.api.Test;
 
 /**
- * Used to test FileFilterUtils.
+ * Tests {@link FileFilterUtils}.
  */
 public class FileFilterTest extends AbstractFilterTest {
 
@@ -205,10 +206,14 @@ public void testCanExecute() throws Exception {
             }
             assertTrue(executableFile.setExecutable(true));
             assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executablePath.get(), true);
+            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, (Path) null, false);
             assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executableFile, true);
+            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, (File) null, false);
             executableFile.setExecutable(false);
             assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executablePath.get(), false);
+            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, (Path) null, true);
             assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executableFile, false);
+            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, (File) null, true);
         }
     }
 
@@ -224,11 +229,17 @@ public void testCanRead() throws Exception {
         }
         assertTrue(readOnlyFile.setReadOnly());
         assertFiltering(CanReadFileFilter.CAN_READ, readOnlyFile, true);
+        assertFiltering(CanReadFileFilter.CAN_READ, (File) null, false);
         assertFiltering(CanReadFileFilter.CAN_READ, readOnlyPath, true);
+        assertFiltering(CanReadFileFilter.CAN_READ, (Path) null, false);
         assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyFile, false);
+        assertFiltering(CanReadFileFilter.CANNOT_READ, (File) null, true);
         assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyPath, false);
+        assertFiltering(CanReadFileFilter.CANNOT_READ, (Path) null, true);
         assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyFile, true);
+        assertFiltering(CanReadFileFilter.READ_ONLY, (File) null, false);
         assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyPath, true);
+        assertFiltering(CanReadFileFilter.READ_ONLY, (Path) null, false);
         readOnlyFile.delete();
     }
 
@@ -244,11 +255,15 @@ public void testCanWrite() throws Exception {
         }
         assertTrue(readOnlyFile.setReadOnly());
         assertFiltering(CanWriteFileFilter.CAN_WRITE, temporaryFolder, true);
-        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, temporaryFolder, false);
         assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyFile, false);
+        assertFiltering(CanWriteFileFilter.CAN_WRITE, (File) null, false);
         assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyPath, false);
+        assertFiltering(CanWriteFileFilter.CAN_WRITE, (Path) null, false);
+        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, temporaryFolder, false);
         assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyFile, true);
         assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyPath, true);
+        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, (File) null, true);
+        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, (Path) null, true);
         readOnlyFile.delete();
     }
 
@@ -376,6 +391,9 @@ public void testDirectory() throws IOException {
         assertFiltering(filter, new File("LICENSE.txt"), false);
         assertFiltering(filter, new File("LICENSE.txt").toPath(), false);
 
+        assertFiltering(filter, (File) null, false);
+        assertFiltering(filter, (Path) null, false);
+
         assertSame(DirectoryFileFilter.DIRECTORY, DirectoryFileFilter.INSTANCE);
     }
 
@@ -388,8 +406,12 @@ public void testEmpty() throws Exception {
         emptyDirFile.mkdirs();
         assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, true);
         assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, true);
+        assertFiltering(EmptyFileFilter.EMPTY, (File) null, true);
+        assertFiltering(EmptyFileFilter.EMPTY, (Path) null, true);
         assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, false);
         assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, false);
+        assertFiltering(EmptyFileFilter.NOT_EMPTY, (File) null, false);
+        assertFiltering(EmptyFileFilter.NOT_EMPTY, (Path) null, false);
 
         // Empty File
         final File emptyFile = new File(emptyDirFile, "empty-file.txt");
@@ -479,6 +501,7 @@ public void testFiles() throws IOException {
         // XXX: This test presumes the current working dir is the base dir of the source checkout.
         final IOFileFilter filter = FileFileFilter.INSTANCE;
 
+        assertFiltering(filter, (File) null, false);
         assertFiltering(filter, new File("src/"), false);
         assertFiltering(filter, new File("src/").toPath(), false);
         assertFiltering(filter, new File("src/java/"), false);
@@ -628,7 +651,7 @@ public void testFilterListNullParameters() {
         final IOFileFilter filter = FileFilterUtils.trueFileFilter();
         List<File> filteredList = FileFilterUtils.filterList(filter, Collections.singletonList(null));
         assertEquals(1, filteredList.size());
-        assertEquals(null, filteredList.get(0));
+        assertNull(filteredList.get(0));
 
         filteredList = FileFilterUtils.filterList(filter, (List<File>) null);
         assertEquals(0, filteredList.size());
@@ -713,8 +736,10 @@ public void testHidden() throws IOException {
         final Path path = temporaryFolder.toPath();
         assertFiltering(HiddenFileFilter.HIDDEN, temporaryFolder, false);
         assertFiltering(HiddenFileFilter.HIDDEN, path, false);
+        assertFiltering(HiddenFileFilter.HIDDEN, (Path) null, true);
         assertFiltering(HiddenFileFilter.VISIBLE, temporaryFolder, true);
         assertFiltering(HiddenFileFilter.VISIBLE, path, true);
+        assertFiltering(HiddenFileFilter.VISIBLE, (Path) null, false);
     }
 
     @Test
@@ -954,7 +979,6 @@ public void testMakeDirectoryOnly() throws Exception {
         fileB.delete();
     }
 
-    // -----------------------------------------------------------------------
     @Test
     public void testMakeFileOnly() throws Exception {
         assertSame(FileFileFilter.INSTANCE, FileFilterUtils.makeFileOnly(null));
@@ -1037,7 +1061,10 @@ public void testMakeSVNAware() throws Exception {
 
     @Test
     public void testNameFilter() throws IOException {
-        assertFooBarFileFiltering(new NameFileFilter("foo", "bar"));
+        final NameFileFilter filter = new NameFileFilter("foo", "bar");
+        assertFooBarFileFiltering(filter);
+        assertFiltering(filter, (File) null, false);
+        assertFiltering(filter, (Path) null, false);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java
index cca9c678..ca778c64 100644
--- a/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java
@@ -64,7 +64,7 @@ public void testJavadocExampleUsingNio() throws IOException {
         final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new NameFileFilter("NOTICE.txt"),
             TrueFileFilter.INSTANCE);
         //
-        // Walk one dir
+        // Walk one directory
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
         // System.out.println(visitor.getPathCounters());
         // System.out.println(visitor.getFileList());
@@ -78,7 +78,7 @@ public void testJavadocExampleUsingNio() throws IOException {
         //
         visitor.getPathCounters().reset();
         //
-        // Walk dir tree
+        // Walk directory tree
         Files.walkFileTree(dir, visitor);
         // System.out.println(visitor.getPathCounters());
         // System.out.println(visitor.getDirList());
diff --git a/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java
index c0571299..181d13b9 100644
--- a/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java
@@ -42,20 +42,16 @@ public class RegexFileFilterTest {
 
     public void assertFiltering(final IOFileFilter filter, final File file, final boolean expected) {
         // Note. This only tests the (File, String) version if the parent of
-        //       the File passed in is not null
-        assertEquals(expected, filter.accept(file),
-                "Filter(File) " + filter.getClass().getName() + " not " + expected + " for " + file);
+        // the File passed in is not null
+        assertEquals(expected, filter.accept(file), "Filter(File) " + filter.getClass().getName() + " not " + expected + " for " + file);
 
         if (file != null && file.getParentFile() != null) {
             assertEquals(expected, filter.accept(file.getParentFile(), file.getName()),
                     "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for " + file);
-            assertEquals(expected, filter.matches(file.toPath()),
-                    "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for " + file);
+            assertEquals(expected, filter.matches(file.toPath()), "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for " + file);
         } else if (file == null) {
-            assertEquals(expected, filter.accept(file),
-                    "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null");
-            assertEquals(expected, filter.matches(null),
-                    "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null");
+            assertEquals(expected, filter.accept(file), "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null");
+            assertEquals(expected, filter.matches(null), "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null");
         }
         // Just don't blow up
         assertNotNull(filter.toString());
@@ -72,11 +68,10 @@ public void assertFiltering(final IOFileFilter filter, final Path path, final bo
 
         if (path != null && path.getParent() != null) {
             assertEquals(expectedFileVisitResult, filter.accept(path, null),
-                "Filter(Path, Path) " + filter.getClass().getName() + " not " + expectedFileVisitResult + " for "
-                    + path);
+                    "Filter(Path, Path) " + filter.getClass().getName() + " not " + expectedFileVisitResult + " for " + path);
         } else if (path == null) {
             assertEquals(expectedFileVisitResult, filter.accept(path, null),
-                "Filter(Path, Path) " + filter.getClass().getName() + " not " + expectedFileVisitResult + " for null");
+                    "Filter(Path, Path) " + filter.getClass().getName() + " not " + expectedFileVisitResult + " for null");
         }
         // Just don't blow up
         assertNotNull(filter.toString());
@@ -166,7 +161,13 @@ public void testRegexFileNameOnly() throws IOException {
         final String patternStr = "Foo.*";
         assertFiltering(assertSerializable(new RegexFileFilter(patternStr)), path, true);
         assertFiltering(assertSerializable(new RegexFileFilter(Pattern.compile(patternStr), (Function<Path, String> & Serializable) Path::toString)), path,
-            false);
+                false);
+        //
+        assertFiltering(new RegexFileFilter(Pattern.compile(patternStr), (Function<Path, String> & Serializable) null), path, false);
+        assertFiltering(new RegexFileFilter(Pattern.compile(patternStr), (Function<Path, String> & Serializable) p -> null), path, false);
+        //
+        assertFiltering(assertSerializable(new RegexFileFilter(Pattern.compile(patternStr), (Function<Path, String> & Serializable) null)), path, false);
+        assertFiltering(assertSerializable(new RegexFileFilter(Pattern.compile(patternStr), (Function<Path, String> & Serializable) p -> null)), path, false);
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/function/EraseTest.java b/src/test/java/org/apache/commons/io/function/EraseTest.java
index cabaebb9..cfd0d295 100644
--- a/src/test/java/org/apache/commons/io/function/EraseTest.java
+++ b/src/test/java/org/apache/commons/io/function/EraseTest.java
@@ -30,7 +30,7 @@
 /**
  * Tests {@code Erase}.
  */
-class EraseTest {
+final class EraseTest {
 
     private final AtomicInteger intRef = new AtomicInteger();
     private final AtomicBoolean boolRef = new AtomicBoolean();
diff --git a/src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java b/src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java
index af056462..350a3510 100644
--- a/src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java
+++ b/src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java
@@ -17,9 +17,10 @@
 
 package org.apache.commons.io.function;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 import java.nio.file.Files;
@@ -50,9 +51,9 @@ private boolean not(final boolean value) throws IOException {
     public void testAndThenIOFunction() throws IOException {
         final IOBiFunction<Path, LinkOption[], Boolean> isDirectory = Files::isDirectory;
         final IOFunction<Boolean, Boolean> not = this::not;
-        assertEquals(true, isDirectory.apply(PathUtils.current(), PathUtils.EMPTY_LINK_OPTION_ARRAY));
+        assertTrue( isDirectory.apply(PathUtils.current(), PathUtils.EMPTY_LINK_OPTION_ARRAY));
         final IOBiFunction<Path, LinkOption[], Boolean> andThen = isDirectory.andThen(not);
-        assertEquals(false, andThen.apply(PathUtils.current(), PathUtils.EMPTY_LINK_OPTION_ARRAY));
+        assertFalse(andThen.apply(PathUtils.current(), PathUtils.EMPTY_LINK_OPTION_ARRAY));
     }
 
     /**
@@ -63,7 +64,7 @@ public void testAndThenIOFunction() throws IOException {
     @Test
     public void testApply() throws IOException {
         final IOBiFunction<Path, LinkOption[], Boolean> isDirectory = Files::isDirectory;
-        assertEquals(true, isDirectory.apply(PathUtils.current(), PathUtils.EMPTY_LINK_OPTION_ARRAY));
+        assertTrue( isDirectory.apply(PathUtils.current(), PathUtils.EMPTY_LINK_OPTION_ARRAY));
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/io/function/IOIntConsumerTest.java b/src/test/java/org/apache/commons/io/function/IOIntConsumerTest.java
new file mode 100644
index 00000000..7b861116
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/function/IOIntConsumerTest.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.function;
+
+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link IOIntConsumer}.
+ */
+public class IOIntConsumerTest {
+
+    @Test
+    void testAccept() throws IOException {
+        assertDoesNotThrow(() -> IOIntConsumer.NOOP.accept(0));
+        assertDoesNotThrow(() -> IOIntConsumer.NOOP.accept('.'));
+        final AtomicReference<String> ref = new AtomicReference<>();
+        final IOIntConsumer consumer = s -> ref.set(s + "-");
+        consumer.accept(65);
+        assertEquals(65 + "-", ref.get());
+    }
+
+    @Test
+    void testAndThen() throws IOException {
+        final AtomicReference<String> ref = new AtomicReference<>();
+        final IOIntConsumer consumer1 = s -> ref.set(s + "-");
+        final IOIntConsumer consumer2 = s -> ref.set(ref.get() + "=" + s);
+        consumer1.andThen(consumer2).accept(66);
+        assertEquals(66 + "-=" + 66, ref.get());
+    }
+
+    @Test
+    void testAsConsumer() {
+        assertThrows(UncheckedIOException.class, () -> Optional.of(65).ifPresent(TestUtils.throwingIOIntConsumer().asConsumer()));
+        final AtomicReference<String> ref = new AtomicReference<>();
+        final IOIntConsumer consumer1 = s -> ref.set(s + "A");
+        Optional.of(2).ifPresent(consumer1.asConsumer());
+        assertEquals("2A", ref.get());
+    }
+
+    @Test
+    void testasIntConsumer() {
+        final AtomicReference<String> ref = new AtomicReference<>();
+        final IOIntConsumer consumer1 = s -> ref.set(s + "A");
+        consumer1.asIntConsumer().accept(2);
+        assertEquals("2A", ref.get());
+    }
+
+    @Test
+    void testNOOP() {
+        // nothing happens:
+        assertDoesNotThrow(() -> IOIntConsumer.NOOP.accept(0));
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java b/src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java
index 7ab20d20..38aff29b 100644
--- a/src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java
+++ b/src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java
@@ -23,7 +23,7 @@
  * Placeholder for future possible development and makes sure we can extend IOBaseStreamAdapter cleanly with proper
  * generics.
  */
-class IOIntStreamAdapter extends IOBaseStreamAdapter<Integer, IOIntStream, IntStream> implements IOIntStream {
+final class IOIntStreamAdapter extends IOBaseStreamAdapter<Integer, IOIntStream, IntStream> implements IOIntStream {
 
     static IOIntStream adapt(final IntStream stream) {
         return new IOIntStreamAdapter(stream);
diff --git a/src/test/java/org/apache/commons/io/function/IOIteratorTest.java b/src/test/java/org/apache/commons/io/function/IOIteratorTest.java
index ca090ddc..4aeb739f 100644
--- a/src/test/java/org/apache/commons/io/function/IOIteratorTest.java
+++ b/src/test/java/org/apache/commons/io/function/IOIteratorTest.java
@@ -51,7 +51,12 @@ private List<Path> newPathList() {
     }
 
     @Test
-    public void testAdapt() throws IOException {
+    public void testAdaptIterable() throws IOException {
+        assertEquals(TestConstants.ABS_PATH_A, IOIterator.adapt(newPathList()).next());
+    }
+
+    @Test
+    public void testAdaptIterator() throws IOException {
         assertEquals(TestConstants.ABS_PATH_A, iterator.next());
     }
 
diff --git a/src/test/java/org/apache/commons/io/function/IORunnableTest.java b/src/test/java/org/apache/commons/io/function/IORunnableTest.java
index 4788f6ee..a73038c3 100644
--- a/src/test/java/org/apache/commons/io/function/IORunnableTest.java
+++ b/src/test/java/org/apache/commons/io/function/IORunnableTest.java
@@ -20,6 +20,7 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 import java.io.UncheckedIOException;
@@ -55,4 +56,11 @@ public void testAsRunnable() throws Exception {
         assertNull(Executors.callable(runnable.asRunnable()).call());
     }
 
+    @SuppressWarnings("cast")
+    @Test
+    public void testNoop() throws IOException {
+        assertTrue(IORunnable.noop() instanceof IORunnable);
+        IORunnable.noop().run();
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java b/src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java
index e9704884..ba377b36 100644
--- a/src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java
+++ b/src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java
@@ -114,7 +114,7 @@ public void testGetExactSizeIfKnown() {
 
     @Test
     public void testHasCharacteristics() {
-        assertEquals(true, spliterator.hasCharacteristics(spliterator.characteristics()));
+        assertTrue( spliterator.hasCharacteristics(spliterator.characteristics()));
         assertEquals(spliterator.unwrap().hasCharacteristics(spliterator.unwrap().characteristics()),
             spliterator.hasCharacteristics(spliterator.characteristics()));
         assertEquals(spliterator.unwrap().hasCharacteristics(spliterator.unwrap().characteristics()),
diff --git a/src/test/java/org/apache/commons/io/function/IOStreamTest.java b/src/test/java/org/apache/commons/io/function/IOStreamTest.java
index 3e2ef9c5..71f5182e 100644
--- a/src/test/java/org/apache/commons/io/function/IOStreamTest.java
+++ b/src/test/java/org/apache/commons/io/function/IOStreamTest.java
@@ -29,6 +29,7 @@
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Collectors;
@@ -296,7 +297,7 @@ public void testIterateException() throws IOException {
         final IOStream<Long> stream = IOStream.iterate(1L, TestUtils.throwingIOUnaryOperator());
         final IOIterator<Long> iterator = stream.iterator();
         assertEquals(1L, iterator.next());
-        assertThrows(IOException.class, () -> iterator.next());
+        assertThrows(NoSuchElementException.class, () -> iterator.next());
     }
 
     @SuppressWarnings("resource") // custom stream not recognized by compiler warning machinery
@@ -461,7 +462,7 @@ public void testPeek() throws IOException {
         if (AT_LEAST_JAVA_11) {
             assertEquals(1, IOStream.of("B").peek(e -> compareAndSetRE(ref, null, e)).count());
             assertEquals(1, IOStream.of("B").peek(e -> compareAndSetIO(ref, null, e)).count());
-            assertEquals(null, ref.get());
+            assertNull(ref.get());
         } else {
             // Java 8
             assertThrows(RuntimeException.class, () -> IOStream.of("B").peek(e -> compareAndSetRE(ref, null, e)).count());
diff --git a/src/test/java/org/apache/commons/io/function/IOSupplierTest.java b/src/test/java/org/apache/commons/io/function/IOSupplierTest.java
index 7a8e94f5..ef60b29a 100644
--- a/src/test/java/org/apache/commons/io/function/IOSupplierTest.java
+++ b/src/test/java/org/apache/commons/io/function/IOSupplierTest.java
@@ -39,10 +39,14 @@ private String getThrowsIO(final IOSupplier<String> supplier) throws IOException
         return supplier.get();
     }
 
-    private String getThrowsNone(final IOSupplier<String> supplier) {
+    private String getThrowsNoneAsSupplier(final IOSupplier<String> supplier) {
         return supplier.asSupplier().get();
     }
 
+    private String getThrowsNoneGetUnchecked(final IOSupplier<String> supplier) {
+        return supplier.getUnchecked();
+    }
+
     @BeforeEach
     public void initEach() {
         ref1 = new AtomicReference<>();
@@ -51,8 +55,12 @@ public void initEach() {
     @Test
     public void testAsSupplier() {
         assertThrows(UncheckedIOException.class, () -> TestConstants.THROWING_IO_SUPPLIER.asSupplier().get());
-        assertEquals("new1", getThrowsNone(() -> TestUtils.compareAndSetThrowsIO(ref1, "new1")));
-        assertEquals("new1", ref1.get());
+        final String s1 = "string1";
+        final String s2 = "string2";
+        assertEquals(s1, getThrowsNoneAsSupplier(() -> TestUtils.compareAndSetThrowsIO(ref1, null, s1)));
+        assertEquals(s1, ref1.get());
+        assertEquals(s2, getThrowsNoneAsSupplier(() -> TestUtils.compareAndSetThrowsIO(ref1, s1, s2)));
+        assertEquals(s2, ref1.get());
         assertNotEquals(TestConstants.THROWING_IO_SUPPLIER.asSupplier(), TestConstants.THROWING_IO_SUPPLIER.asSupplier());
     }
 
@@ -66,4 +74,16 @@ public void testGet() throws IOException {
         assertEquals("new1", ref1.get());
     }
 
+    @Test
+    public void testGetUnchecked() {
+        assertThrows(UncheckedIOException.class, () -> TestConstants.THROWING_IO_SUPPLIER.asSupplier().get());
+        final String s1 = "string1";
+        final String s2 = "string2";
+        assertEquals(s1, getThrowsNoneGetUnchecked(() -> TestUtils.compareAndSetThrowsIO(ref1, null, s1)));
+        assertEquals(s1, ref1.get());
+        assertEquals(s2, getThrowsNoneGetUnchecked(() -> TestUtils.compareAndSetThrowsIO(ref1, s1, s2)));
+        assertEquals(s2, ref1.get());
+        assertNotEquals(TestConstants.THROWING_IO_SUPPLIER.asSupplier(), TestConstants.THROWING_IO_SUPPLIER.asSupplier());
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/io/function/TestConstants.java b/src/test/java/org/apache/commons/io/function/TestConstants.java
index dfea176a..803dd4b3 100644
--- a/src/test/java/org/apache/commons/io/function/TestConstants.java
+++ b/src/test/java/org/apache/commons/io/function/TestConstants.java
@@ -26,7 +26,7 @@
 /**
  * Test fixtures for this package.
  */
-class TestConstants {
+final class TestConstants {
 
     static final Path ABS_PATH_A = Paths.get("LICENSE.txt").toAbsolutePath();
 
@@ -42,6 +42,8 @@ class TestConstants {
 
     static IOConsumer<Object> THROWING_IO_CONSUMER = t -> throwIOException();
 
+    static IOIntConsumer THROWING_IO_INT_CONSUMER = t -> throwIOException();
+
     static IOFunction<Object, Object> THROWING_IO_FUNCTION = t -> throwIOException();
 
     static IOIntSupplier THROWING_IO_INT_SUPPLIER = TestConstants::throwIOException;
diff --git a/src/test/java/org/apache/commons/io/function/TestUtils.java b/src/test/java/org/apache/commons/io/function/TestUtils.java
index 9d05f026..f656f65d 100644
--- a/src/test/java/org/apache/commons/io/function/TestUtils.java
+++ b/src/test/java/org/apache/commons/io/function/TestUtils.java
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-class TestUtils {
+final class TestUtils {
 
     static int compareAndSetThrowsIO(final AtomicInteger ref, final int update) throws IOException {
         return compareAndSetThrowsIO(ref, 0, update);
@@ -94,6 +94,10 @@ static <T, U> IOFunction<T, U> throwingIOFunction() {
         return (IOFunction<T, U>) TestConstants.THROWING_IO_FUNCTION;
     }
 
+    static IOIntConsumer throwingIOIntConsumer() {
+        return TestConstants.THROWING_IO_INT_CONSUMER;
+    }
+
     @SuppressWarnings("unchecked")
     static <T> IOPredicate<T> throwingIOPredicate() {
         return (IOPredicate<T>) TestConstants.THROWING_IO_PREDICATE;
diff --git a/src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java b/src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java
index b8684781..0e0658ff 100644
--- a/src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java
@@ -17,6 +17,8 @@
 package org.apache.commons.io.input;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -30,7 +32,7 @@
 import org.junit.jupiter.api.Test;
 
 /**
- * Tests functionality of {@link BufferedFileChannelInputStream}.
+ * Tests {@link InputStream} subclasses.
  * <p>
  * This class was ported and adapted from Apache Spark commit 933dc6cb7b3de1d8ccaf73d124d6eb95b947ed19 where it was
  * called {@code GenericFileInputStreamSuite}.
@@ -38,6 +40,14 @@
  */
 public abstract class AbstractInputStreamTest {
 
+    static final String ARRAY_LENGTHS_NAME = "org.apache.commons.io.input.AbstractInputStreamTest#getArrayLengths";
+
+    static final int[] ARRAY_LENGTHS = { 0, 1, 2, 4, 8, 16, 32, 64, 128 };
+
+    static int[] getArrayLengths() {
+        return ARRAY_LENGTHS;
+    }
+
     private byte[] randomBytes;
 
     protected Path inputFile;
@@ -58,6 +68,37 @@ public void tearDown() throws IOException {
         IOUtils.close(inputStreams);
     }
 
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        for (final InputStream inputStream : inputStreams) {
+            inputStream.close();
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        for (final InputStream inputStream : inputStreams) {
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableAfterRead() throws Exception {
+        for (final InputStream inputStream : inputStreams) {
+            assertNotEquals(IOUtils.EOF, inputStream.read());
+            assertTrue(inputStream.available() > 0);
+        }
+    }
+
+    @Test
+    public void testAvailableAtEnd() throws Exception {
+        for (final InputStream inputStream : inputStreams) {
+            IOUtils.consume(inputStream);
+            assertEquals(0, inputStream.available());
+        }
+    }
+
     @Test
     public void testBytesSkipped() throws IOException {
         for (final InputStream inputStream : inputStreams) {
@@ -134,8 +175,7 @@ public void testReadOneByte() throws IOException {
     public void testReadPastEOF() throws IOException {
         final InputStream is = inputStreams[0];
         final byte[] buf = new byte[1024];
-        int read;
-        while ((read = is.read(buf, 0, buf.length)) != -1) {
+        while (is.read(buf, 0, buf.length) != -1) {
             // empty
         }
 
diff --git a/src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java b/src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java
index 1e615843..dbcc2735 100644
--- a/src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java
@@ -18,11 +18,18 @@
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.test.CustomIOException;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -35,31 +42,90 @@ public class AutoCloseInputStreamTest {
 
     private AutoCloseInputStream stream;
 
-    private boolean closed;
-
+    @SuppressWarnings("deprecation")
     @BeforeEach
     public void setUp() {
         data = new byte[] { 'x', 'y', 'z' };
-        stream = new AutoCloseInputStream(new ByteArrayInputStream(data) {
-            @Override
-            public void close() {
-                closed = true;
-            }
-        });
-        closed = false;
+        stream = new AutoCloseInputStream(new ByteArrayInputStream(data));
+    }
+
+    @Test
+    public void testAfterReadConsumer() throws Exception {
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = AutoCloseInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = AutoCloseInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
+
+    @Test
+    public void testAvailableAfterClose() throws IOException {
+        final InputStream shadow;
+        try (InputStream inputStream = new AutoCloseInputStream(new ByteArrayInputStream(data))) {
+            assertEquals(3, inputStream.available());
+            shadow = inputStream;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAll() throws IOException {
+        try (InputStream inputStream = new AutoCloseInputStream(new ByteArrayInputStream(data))) {
+            assertEquals(3, inputStream.available());
+            IOUtils.toByteArray(inputStream);
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableNull() throws IOException {
+        try (InputStream inputStream = new AutoCloseInputStream(null)) {
+            assertEquals(0, inputStream.available());
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testBuilderGet() {
+        // java.lang.IllegalStateException: origin == null
+        assertThrows(IllegalStateException.class, () -> AutoCloseInputStream.builder().get());
     }
 
     @Test
     public void testClose() throws IOException {
         stream.close();
-        assertTrue(closed, "closed");
+        assertTrue(stream.isClosed(), "closed");
         assertEquals(-1, stream.read(), "read()");
+        assertTrue(stream.isClosed(), "closed");
+    }
+
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(AutoCloseInputStream.builder());
     }
 
     @Test
     public void testFinalize() throws Throwable {
         stream.finalize();
-        assertTrue(closed, "closed");
+        assertTrue(stream.isClosed(), "closed");
         assertEquals(-1, stream.read(), "read()");
     }
 
@@ -67,10 +133,10 @@ public void testFinalize() throws Throwable {
     public void testRead() throws IOException {
         for (final byte element : data) {
             assertEquals(element, stream.read(), "read()");
-            assertFalse(closed, "closed");
+            assertFalse(stream.isClosed(), "closed");
         }
         assertEquals(-1, stream.read(), "read()");
-        assertTrue(closed, "closed");
+        assertTrue(stream.isClosed(), "closed");
     }
 
     @Test
@@ -78,14 +144,14 @@ public void testReadBuffer() throws IOException {
         final byte[] b = new byte[data.length * 2];
         int total = 0;
         for (int n = 0; n != -1; n = stream.read(b)) {
-            assertFalse(closed, "closed");
+            assertFalse(stream.isClosed(), "closed");
             for (int i = 0; i < n; i++) {
                 assertEquals(data[total + i], b[i], "read(b)");
             }
             total += n;
         }
         assertEquals(data.length, total, "read(b)");
-        assertTrue(closed, "closed");
+        assertTrue(stream.isClosed(), "closed");
         assertEquals(-1, stream.read(b), "read(b)");
     }
 
@@ -94,14 +160,14 @@ public void testReadBufferOffsetLength() throws IOException {
         final byte[] b = new byte[data.length * 2];
         int total = 0;
         for (int n = 0; n != -1; n = stream.read(b, total, b.length - total)) {
-            assertFalse(closed, "closed");
+            assertFalse(stream.isClosed(), "closed");
             total += n;
         }
         assertEquals(data.length, total, "read(b, off, len)");
         for (int i = 0; i < data.length; i++) {
             assertEquals(data[i], b[i], "read(b, off, len)");
         }
-        assertTrue(closed, "closed");
+        assertTrue(stream.isClosed(), "closed");
         assertEquals(-1, stream.read(b, 0, b.length), "read(b, off, len)");
     }
 
@@ -152,4 +218,14 @@ public void testResetBeforeEndSetInputStream() throws IOException {
         }
     }
 
+    @Test
+    public void testrReadAfterClose() throws IOException {
+        final InputStream shadow;
+        try (InputStream inputStream = new AutoCloseInputStream(new ByteArrayInputStream(data))) {
+            assertEquals(3, inputStream.available());
+            shadow = inputStream;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java b/src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java
index 9ce5d54e..2bb22d03 100644
--- a/src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java
@@ -21,6 +21,7 @@
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assumptions.assumeFalse;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
@@ -31,12 +32,16 @@
 import java.io.Reader;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 
 import org.apache.commons.io.ByteOrderMark;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.test.CustomIOException;
+import org.apache.commons.lang3.SystemProperties;
 import org.junit.jupiter.api.Test;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
@@ -53,15 +58,15 @@ public class BOMInputStreamTest {
      *  A mock InputStream that expects {@code close()} to be called.
      */
     private static final class ExpectCloseInputStream extends InputStream {
-        private boolean _closeCalled;
+        private boolean closed;
 
         public void assertCloseCalled() {
-            assertTrue(_closeCalled);
+            assertTrue(closed);
         }
 
         @Override
         public void close() throws IOException {
-            _closeCalled = true;
+            closed = true;
         }
 
         @Override
@@ -189,9 +194,9 @@ private void readBOMInputStreamTwice(final String resource) throws Exception {
             try (BOMInputStream bomInputStream = BOMInputStream.builder().setInputStream(inputStream).get()) {
                 bomInputStream.mark(1_000_000);
 
-                this.readFile(bomInputStream);
+                readFile(bomInputStream);
                 bomInputStream.reset();
-                this.readFile(bomInputStream);
+                readFile(bomInputStream);
                 inputStream.close();
             }
         }
@@ -206,25 +211,45 @@ private void readFile(final BOMInputStream bomInputStream) throws Exception {
     }
 
     @Test
-    public void skipReturnValueWithBom() throws IOException {
-        final byte[] data = { (byte) 0x31, (byte) 0x32, (byte) 0x33 };
-        try (BOMInputStream is1 = BOMInputStream.builder().setInputStream(createUtf8Input(data, true)).get()) {
-            assertEquals(2, is1.skip(2));
-            assertEquals((byte) 0x33, is1.read());
+    public void testAfterReadConsumer() throws Exception {
+        final byte[] data = { 'A', 'B', 'C', 'D' };
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = BOMInputStream.builder()
+                .setInputStream(createUtf8Input(data, true))
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = BOMInputStream.builder()
+                .setInputStream(createUtf8Input(data, true))
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
         }
+        // @formatter:on
     }
 
     @Test
-    public void skipReturnValueWithoutBom() throws IOException {
-        final byte[] data = { (byte) 0x31, (byte) 0x32, (byte) 0x33 };
-        try (BOMInputStream is2 = BOMInputStream.builder().setInputStream(createUtf8Input(data, false)).get()) {
-            assertEquals(2, is2.skip(2)); // IO-428
-            assertEquals((byte) 0x33, is2.read());
+    public void testAvailableWithBOMAfterClose() throws Exception {
+        final byte[] data = { 'A', 'B', 'C', 'D' };
+        final InputStream shadow;
+        try (InputStream in = BOMInputStream.builder().setInputStream(createUtf8Input(data, true)).get()) {
+            assertEquals(7, in.available());
+            shadow = in;
         }
+        assertEquals(0, shadow.available());
     }
 
     @Test
-    public void testAvailableWithBOM() throws Exception {
+    public void testAvailableWithBOMAfterOpen() throws Exception {
         final byte[] data = { 'A', 'B', 'C', 'D' };
         try (InputStream in = BOMInputStream.builder().setInputStream(createUtf8Input(data, true)).get()) {
             assertEquals(7, in.available());
@@ -239,6 +264,12 @@ public void testAvailableWithoutBOM() throws Exception {
         }
     }
 
+    @Test
+    public void testBuilderGet() {
+        // java.lang.IllegalStateException: origin == null
+        assertThrows(IllegalStateException.class, () -> BOMInputStream.builder().get());
+    }
+
     @Test
     // this is here for coverage
     public void testClose() throws Exception {
@@ -250,6 +281,11 @@ public void testClose() throws Exception {
         }
     }
 
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(BOMInputStream.builder());
+    }
+
     @Test
     public void testEmptyBufferWithBOM() throws Exception {
         final byte[] data = {};
@@ -420,6 +456,16 @@ public void testNoBoms() throws Exception {
                 .close());
     }
 
+    @Test
+    public void testReadAfterClose() throws Exception {
+        final byte[] data = { 'A', 'B', 'C', 'D' };
+        try (InputStream in = BOMInputStream.builder().setInputStream(createUtf8Input(data, true)).get()) {
+            assertEquals(7, in.available());
+            in.close();
+            assertThrows(IOException.class, in::read);
+        }
+    }
+
     @Test
     public void testReadEmpty() throws Exception {
         final byte[] data = {};
@@ -446,12 +492,12 @@ public void testReadSmall() throws Exception {
 
     @Test
     public void testReadTwiceWithBOM() throws Exception {
-        this.readBOMInputStreamTwice("/org/apache/commons/io/testfileBOM.xml");
+        readBOMInputStreamTwice("/org/apache/commons/io/testfileBOM.xml");
     }
 
     @Test
     public void testReadTwiceWithoutBOM() throws Exception {
-        this.readBOMInputStreamTwice("/org/apache/commons/io/testfileNoBOM.xml");
+        readBOMInputStreamTwice("/org/apache/commons/io/testfileNoBOM.xml");
     }
 
     @Test
@@ -606,7 +652,7 @@ public void testReadWithoutBOM() throws Exception {
 
     @Test
     public void testReadXmlWithBOMUcs2() throws Exception {
-        assumeFalse(System.getProperty("java.vendor").contains("IBM"), "This test does not pass on some IBM VMs xml parsers");
+        assumeFalse(SystemProperties.getJavaVendor().contains("IBM"), "This test does not pass on some IBM VMs xml parsers");
 
         // UCS-2 is BE.
         assumeTrue(Charset.isSupported("ISO-10646-UCS-2"));
@@ -685,7 +731,6 @@ public void testReadXmlWithBOMUtf8() throws Exception {
         parseXml(createUtf8Input(data, true));
     }
 
-
     @Test
     public void testReadXmlWithoutBOMUtf32Be() throws Exception {
         assumeTrue(jvmAndSaxBothSupportCharset("UTF_32BE"), "JVM and SAX need to support UTF_32BE for this");
@@ -706,6 +751,24 @@ public void testReadXmlWithoutBOMUtf32Le() throws Exception {
         parseXml(createUtf32BeDataStream(data, false));
     }
 
+    @Test
+    public void testSkipReturnValueWithBom() throws IOException {
+        final byte[] data = { (byte) 0x31, (byte) 0x32, (byte) 0x33 };
+        try (BOMInputStream is1 = BOMInputStream.builder().setInputStream(createUtf8Input(data, true)).get()) {
+            assertEquals(2, is1.skip(2));
+            assertEquals((byte) 0x33, is1.read());
+        }
+    }
+
+    @Test
+    public void testSkipReturnValueWithoutBom() throws IOException {
+        final byte[] data = { (byte) 0x31, (byte) 0x32, (byte) 0x33 };
+        try (BOMInputStream is2 = BOMInputStream.builder().setInputStream(createUtf8Input(data, false)).get()) {
+            assertEquals(2, is2.skip(2)); // IO-428
+            assertEquals((byte) 0x33, is2.read());
+        }
+    }
+
     @Test
     public void testSkipWithBOM() throws Exception {
         final byte[] data = { 'A', 'B', 'C', 'D' };
diff --git a/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java b/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java
index 36473361..aa284948 100644
--- a/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java
@@ -16,128 +16,594 @@
  */
 package org.apache.commons.io.input;
 
+import static org.apache.commons.io.IOUtils.EOF;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.test.CustomIOException;
+import org.apache.commons.lang3.mutable.MutableInt;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 
 /**
  * Tests for {@link BoundedInputStream}.
  */
 public class BoundedInputStreamTest {
 
-    private void compare(final String msg, final byte[] expected, final byte[] actual) {
-        assertEquals(expected.length, actual.length, msg + " length");
+    private void compare(final String message, final byte[] expected, final byte[] actual) {
+        assertEquals(expected.length, actual.length, () -> message + " (array length equals check)");
+        final MutableInt mi = new MutableInt();
         for (int i = 0; i < expected.length; i++) {
-            assertEquals(expected[i], actual[i], msg + " byte[" + i + "]");
+            mi.setValue(i);
+            assertEquals(expected[i], actual[i], () -> message + " byte[" + mi + "]");
         }
     }
 
     @Test
-    public void testOnMaxLength() throws Exception {
-        BoundedInputStream bounded;
-        final byte[] helloWorld = "Hello World".getBytes();
-        final byte[] hello = "Hello".getBytes();
+    public void testAfterReadConsumer() throws Exception {
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
         final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setMaxCount(hello.length)
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setMaxCount(hello.length)
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
 
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = BoundedInputStream.builder().setCharSequence("Hi").get()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = BoundedInputStream.builder().setCharSequence("Hi").get()) {
+            assertTrue(in.available() > 0);
+        }
+    }
+
+    @Test
+    public void testBuilderGet() {
+        // java.lang.IllegalStateException: origin == null
+        assertThrows(IllegalStateException.class, () -> BoundedInputStream.builder().get());
+    }
+
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(BoundedInputStream.builder());
+    }
+
+    @ParameterizedTest
+    @ValueSource(longs = { -100, -1, 0, 1, 2, 4, 8, 16, 32, 64 })
+    public void testCounts(final long startCount) throws Exception {
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        final long actualStart = startCount < 0 ? 0 : startCount;
         // limit = length
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length) {
-            @Override
-            protected void onMaxLength(final long max, final long readCount) {
-                boolRef.set(true);
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setCount(startCount)
+                .setMaxCount(helloWorld.length).get()) {
+            assertTrue(bounded.markSupported());
+            assertEquals(helloWorld.length, bounded.getMaxCount());
+            assertEquals(helloWorld.length, bounded.getMaxLength());
+            assertEquals(actualStart, bounded.getCount());
+            assertEquals(Math.max(0, bounded.getMaxCount() - actualStart), bounded.getRemaining());
+            assertEquals(Math.max(0, bounded.getMaxLength() - actualStart), bounded.getRemaining());
+            int readCount = 0;
+            for (int i = 0; i < helloWorld.length; i++) {
+                final byte expectedCh = bounded.getRemaining() > 0 ? helloWorld[i] : EOF;
+                final int actualCh = bounded.read();
+                assertEquals(expectedCh, actualCh, "limit = length byte[" + i + "]");
+                if (actualCh != EOF) {
+                    readCount++;
+                }
+                assertEquals(helloWorld.length, bounded.getMaxCount());
+                assertEquals(helloWorld.length, bounded.getMaxLength());
+                assertEquals(actualStart + readCount, bounded.getCount(), "i=" + i);
+                assertEquals(Math.max(0, bounded.getMaxCount() - (readCount + actualStart)), bounded.getRemaining());
+                assertEquals(Math.max(0, bounded.getMaxLength() - (readCount + actualStart)), bounded.getRemaining());
+            }
+            assertEquals(-1, bounded.read(), "limit = length end");
+            assertEquals(helloWorld.length, bounded.getMaxLength());
+            assertEquals(readCount + actualStart, bounded.getCount());
+            assertEquals(0, bounded.getRemaining());
+            assertEquals(0, bounded.available());
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit > length
+        final int maxCountP1 = helloWorld.length + 1;
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setCount(startCount)
+                .setMaxCount(maxCountP1).get()) {
+            assertTrue(bounded.markSupported());
+            assertEquals(maxCountP1, bounded.getMaxLength());
+            assertEquals(actualStart, bounded.getCount());
+            assertEquals(Math.max(0, bounded.getMaxCount() - actualStart), bounded.getRemaining());
+            assertEquals(Math.max(0, bounded.getMaxLength() - actualStart), bounded.getRemaining());
+            int readCount = 0;
+            for (int i = 0; i < helloWorld.length; i++) {
+                final byte expectedCh = bounded.getRemaining() > 0 ? helloWorld[i] : EOF;
+                final int actualCh = bounded.read();
+                assertEquals(expectedCh, actualCh, "limit = length byte[" + i + "]");
+                if (actualCh != EOF) {
+                    readCount++;
+                }
+                assertEquals(maxCountP1, bounded.getMaxCount());
+                assertEquals(maxCountP1, bounded.getMaxLength());
+                assertEquals(actualStart + readCount, bounded.getCount(), "i=" + i);
+                assertEquals(Math.max(0, bounded.getMaxCount() - (readCount + actualStart)), bounded.getRemaining());
+                assertEquals(Math.max(0, bounded.getMaxLength() - (readCount + actualStart)), bounded.getRemaining());
+            }
+            assertEquals(-1, bounded.read(), "limit > length end");
+            assertEquals(0, bounded.available());
+            assertEquals(maxCountP1, bounded.getMaxLength());
+            assertEquals(readCount + actualStart, bounded.getCount());
+            assertEquals(Math.max(0, maxCountP1 - bounded.getCount()), bounded.getRemaining());
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit < length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(hello.length).get()) {
+            assertTrue(bounded.markSupported());
+            assertEquals(hello.length, bounded.getMaxLength());
+            assertEquals(0, bounded.getCount());
+            assertEquals(bounded.getMaxLength(), bounded.getRemaining());
+            int readCount = 0;
+            for (int i = 0; i < hello.length; i++) {
+                assertEquals(hello[i], bounded.read(), "limit < length byte[" + i + "]");
+                readCount++;
+                assertEquals(hello.length, bounded.getMaxLength());
+                assertEquals(readCount, bounded.getCount());
+                assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
             }
-        };
-        assertFalse(boolRef.get());
-        for (int i = 0; i < helloWorld.length; i++) {
-            assertEquals(helloWorld[i], bounded.read(), "limit = length byte[" + i + "]");
+            assertEquals(-1, bounded.read(), "limit < length end");
+            assertEquals(0, bounded.available());
+            assertEquals(hello.length, bounded.getMaxLength());
+            assertEquals(readCount, bounded.getCount());
+            assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+    }
+
+    @Test
+    public void testMarkReset() throws Exception {
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        final int helloWorldLen = helloWorld.length;
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        final byte[] world = " World".getBytes(StandardCharsets.UTF_8);
+        final int helloLen = hello.length;
+        // limit = -1
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.mark(0);
+            compare("limit = -1", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit = -1", hello, IOUtils.toByteArray(bounded, helloLen));
+            bounded.mark(helloWorldLen);
+            compare("limit = -1", world, IOUtils.toByteArray(bounded));
+            bounded.reset();
+            compare("limit = -1", world, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit = 0
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(0).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.mark(0);
+            compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            bounded.mark(helloWorldLen);
+            compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit = length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.mark(0);
+            compare("limit = length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit = length", hello, IOUtils.toByteArray(bounded, helloLen));
+            bounded.mark(helloWorldLen);
+            compare("limit = length", world, IOUtils.toByteArray(bounded));
+            bounded.reset();
+            compare("limit = length", world, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
         }
-        assertEquals(-1, bounded.read(), "limit = length end");
+        // limit > length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length + 1).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.mark(0);
+            compare("limit > length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit > length", helloWorld, IOUtils.toByteArray(bounded));
+            bounded.reset();
+            compare("limit > length", hello, IOUtils.toByteArray(bounded, helloLen));
+            bounded.mark(helloWorldLen);
+            compare("limit > length", world, IOUtils.toByteArray(bounded));
+            bounded.reset();
+            compare("limit > length", world, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit < length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length - (hello.length + 1)).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.mark(0);
+            compare("limit < length", hello, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit < length", hello, IOUtils.toByteArray(bounded));
+            bounded.reset();
+            compare("limit < length", hello, IOUtils.toByteArray(bounded, helloLen));
+            bounded.mark(helloWorldLen);
+            compare("limit < length", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            bounded.reset();
+            compare("limit < length", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+    }
+
+    @Test
+    public void testOnMaxCountConsumer() throws Exception {
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (BoundedInputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setMaxCount(hello.length)
+                .setOnMaxCount(null) // should not blow up
+                .setOnMaxCount((m, c) -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
         assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (BoundedInputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setMaxCount(hello.length)
+                .setOnMaxCount((m, c) -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
 
+    @SuppressWarnings("deprecation")
+    @Test
+    public void testOnMaxLength() throws Exception {
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // limit = length
+        try (BoundedInputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length)
+                .setOnMaxCount((m, c) -> boolRef.set(true))
+                .get()) {
+            assertTrue(bounded.markSupported());
+            assertEquals(helloWorld.length, bounded.getMaxCount());
+            assertEquals(helloWorld.length, bounded.getMaxLength());
+            assertEquals(0, bounded.getCount());
+            assertEquals(bounded.getMaxCount(), bounded.getRemaining());
+            assertEquals(bounded.getMaxLength(), bounded.getRemaining());
+            assertFalse(boolRef.get());
+            int readCount = 0;
+            for (int i = 0; i < helloWorld.length; i++) {
+                assertEquals(helloWorld[i], bounded.read(), "limit = length byte[" + i + "]");
+                readCount++;
+                assertEquals(helloWorld.length, bounded.getMaxCount());
+                assertEquals(helloWorld.length, bounded.getMaxLength());
+                assertEquals(readCount, bounded.getCount());
+                assertEquals(bounded.getMaxCount() - readCount, bounded.getRemaining());
+                assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
+            }
+            assertEquals(-1, bounded.read(), "limit = length end");
+            assertEquals(0, bounded.available());
+            assertEquals(helloWorld.length, bounded.getMaxLength());
+            assertEquals(readCount, bounded.getCount());
+            assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
+            assertTrue(boolRef.get());
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
         // limit > length
         boolRef.set(false);
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length + 1) {
-            @Override
-            protected void onMaxLength(final long max, final long readCount) {
-                boolRef.set(true);
+        final int length2 = helloWorld.length + 1;
+        try (BoundedInputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(length2)
+                .setOnMaxCount((m, c) -> boolRef.set(true))
+                .get()) {
+            assertTrue(bounded.markSupported());
+            assertEquals(length2, bounded.getMaxLength());
+            assertEquals(0, bounded.getCount());
+            assertEquals(bounded.getMaxLength(), bounded.getRemaining());
+            assertFalse(boolRef.get());
+            int readCount = 0;
+            for (int i = 0; i < helloWorld.length; i++) {
+                assertEquals(helloWorld[i], bounded.read(), "limit > length byte[" + i + "]");
+                readCount++;
+                assertEquals(length2, bounded.getMaxLength());
+                assertEquals(readCount, bounded.getCount());
+                assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
             }
-        };
-        assertFalse(boolRef.get());
-        for (int i = 0; i < helloWorld.length; i++) {
-            assertEquals(helloWorld[i], bounded.read(), "limit > length byte[" + i + "]");
+            assertEquals(0, bounded.available());
+            assertEquals(-1, bounded.read(), "limit > length end");
+            assertEquals(length2, bounded.getMaxLength());
+            assertEquals(readCount, bounded.getCount());
+            assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
+            assertFalse(boolRef.get());
+            // should be invariant
+            assertTrue(bounded.markSupported());
         }
-        assertEquals(-1, bounded.read(), "limit > length end");
-        assertFalse(boolRef.get());
-
         // limit < length
         boolRef.set(false);
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), hello.length) {
-            @Override
-            protected void onMaxLength(final long max, final long readCount) {
-                boolRef.set(true);
+        try (BoundedInputStream bounded = BoundedInputStream.builder()
+                .setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(hello.length)
+                .setOnMaxCount((m, c) -> boolRef.set(true))
+                .get()) {
+            assertTrue(bounded.markSupported());
+            assertEquals(hello.length, bounded.getMaxLength());
+            assertEquals(0, bounded.getCount());
+            assertEquals(bounded.getMaxLength(), bounded.getRemaining());
+            assertFalse(boolRef.get());
+            int readCount = 0;
+            for (int i = 0; i < hello.length; i++) {
+                assertEquals(hello[i], bounded.read(), "limit < length byte[" + i + "]");
+                readCount++;
+                assertEquals(hello.length, bounded.getMaxLength());
+                assertEquals(readCount, bounded.getCount());
+                assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
             }
-        };
-        assertFalse(boolRef.get());
-        for (int i = 0; i < hello.length; i++) {
-            assertEquals(hello[i], bounded.read(), "limit < length byte[" + i + "]");
+            assertEquals(-1, bounded.read(), "limit < length end");
+            assertEquals(hello.length, bounded.getMaxLength());
+            assertEquals(readCount, bounded.getCount());
+            assertEquals(bounded.getMaxLength() - readCount, bounded.getRemaining());
+            assertTrue(boolRef.get());
+            // should be invariant
+            assertTrue(bounded.markSupported());
         }
-        assertEquals(-1, bounded.read(), "limit < length end");
-        assertTrue(boolRef.get());
     }
 
+    @SuppressWarnings("deprecation")
     @Test
-    public void testReadArray() throws Exception {
-
-        BoundedInputStream bounded;
-        final byte[] helloWorld = "Hello World".getBytes();
-        final byte[] hello = "Hello".getBytes();
-
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld));
-        compare("limit = -1", helloWorld, IOUtils.toByteArray(bounded));
-
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), 0);
-        compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
-
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length);
-        compare("limit = length", helloWorld, IOUtils.toByteArray(bounded));
+    public void testPublicConstructors() throws IOException {
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        try (ByteArrayInputStream baos = new ByteArrayInputStream(helloWorld);
+                BoundedInputStream inputStream = new BoundedInputStream(baos)) {
+            assertSame(baos, inputStream.unwrap());
+        }
+        final long maxCount = 2;
+        try (ByteArrayInputStream baos = new ByteArrayInputStream(helloWorld);
+                BoundedInputStream inputStream = new BoundedInputStream(baos, maxCount)) {
+            assertSame(baos, inputStream.unwrap());
+            assertSame(maxCount, inputStream.getMaxCount());
+        }
+    }
 
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length + 1);
-        compare("limit > length", helloWorld, IOUtils.toByteArray(bounded));
+    @SuppressWarnings("resource")
+    @Test
+    public void testReadAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = BoundedInputStream.builder().setCharSequence("Hi").get()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
 
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length - 6);
-        compare("limit < length", hello, IOUtils.toByteArray(bounded));
+    @Test
+    public void testReadArray() throws Exception {
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).get()) {
+            assertTrue(bounded.markSupported());
+            compare("limit = -1", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(0).get()) {
+            assertTrue(bounded.markSupported());
+            compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length).get()) {
+            assertTrue(bounded.markSupported());
+            compare("limit = length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length + 1).get()) {
+            assertTrue(bounded.markSupported());
+            compare("limit > length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length - 6).get()) {
+            assertTrue(bounded.markSupported());
+            compare("limit < length", hello, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
     }
 
+    @SuppressWarnings("deprecation")
     @Test
     public void testReadSingle() throws Exception {
-        BoundedInputStream bounded;
-        final byte[] helloWorld = "Hello World".getBytes();
-        final byte[] hello = "Hello".getBytes();
-
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
         // limit = length
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length);
-        for (int i = 0; i < helloWorld.length; i++) {
-            assertEquals(helloWorld[i], bounded.read(), "limit = length byte[" + i + "]");
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(helloWorld.length)
+                .get()) {
+            assertTrue(bounded.markSupported());
+            for (int i = 0; i < helloWorld.length; i++) {
+                assertEquals(helloWorld[i], bounded.read(), "limit = length byte[" + i + "]");
+            }
+            assertEquals(-1, bounded.read(), "limit = length end");
+            // should be invariant
+            assertTrue(bounded.markSupported());
         }
-        assertEquals(-1, bounded.read(), "limit = length end");
-
         // limit > length
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), helloWorld.length + 1);
-        for (int i = 0; i < helloWorld.length; i++) {
-            assertEquals(helloWorld[i], bounded.read(), "limit > length byte[" + i + "]");
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(helloWorld.length + 1)
+                .get()) {
+            assertTrue(bounded.markSupported());
+            for (int i = 0; i < helloWorld.length; i++) {
+                assertEquals(helloWorld[i], bounded.read(), "limit > length byte[" + i + "]");
+            }
+            assertEquals(-1, bounded.read(), "limit > length end");
+            // should be invariant
+            assertTrue(bounded.markSupported());
         }
-        assertEquals(-1, bounded.read(), "limit > length end");
+        // limit < length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(hello.length).get()) {
+            assertTrue(bounded.markSupported());
+            for (int i = 0; i < hello.length; i++) {
+                assertEquals(hello[i], bounded.read(), "limit < length byte[" + i + "]");
+            }
+            assertEquals(-1, bounded.read(), "limit < length end");
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+    }
 
+    @Test
+    public void testReset() throws Exception {
+        final byte[] helloWorld = "Hello World".getBytes(StandardCharsets.UTF_8);
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        // limit = -1
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.reset();
+            compare("limit = -1", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit = -1", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit = 0
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld)).setMaxCount(0).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.reset();
+            compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit = 0", IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit = length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.reset();
+            compare("limit = length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit = length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
+        // limit > length
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length + 1).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.reset();
+            compare("limit > length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit > length", helloWorld, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+        }
         // limit < length
-        bounded = new BoundedInputStream(new ByteArrayInputStream(helloWorld), hello.length);
-        for (int i = 0; i < hello.length; i++) {
-            assertEquals(hello[i], bounded.read(), "limit < length byte[" + i + "]");
+        try (BoundedInputStream bounded = BoundedInputStream.builder().setInputStream(new ByteArrayInputStream(helloWorld))
+                .setMaxCount(helloWorld.length - 6).get()) {
+            assertTrue(bounded.markSupported());
+            bounded.reset();
+            compare("limit < length", hello, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
+            // again
+            bounded.reset();
+            compare("limit < length", hello, IOUtils.toByteArray(bounded));
+            // should be invariant
+            assertTrue(bounded.markSupported());
         }
-        assertEquals(-1, bounded.read(), "limit < length end");
     }
 }
diff --git a/src/test/java/org/apache/commons/io/input/BoundedReaderTest.java b/src/test/java/org/apache/commons/io/input/BoundedReaderTest.java
index 41204391..a17f7e51 100644
--- a/src/test/java/org/apache/commons/io/input/BoundedReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/BoundedReaderTest.java
@@ -54,8 +54,8 @@ public class BoundedReaderTest {
     private final Reader shortReader = new BufferedReader(new StringReader("01"));
 
     @Test
-    public void closeTest() throws IOException {
-        final AtomicBoolean closed = new AtomicBoolean(false);
+    public void testCloseTest() throws IOException {
+        final AtomicBoolean closed = new AtomicBoolean();
         try (Reader sr = new BufferedReader(new StringReader("01234567890")) {
             @Override
             public void close() throws IOException {
@@ -71,8 +71,46 @@ public void close() throws IOException {
         assertTrue(closed.get());
     }
 
+    private void testLineNumberReader(final Reader source) throws IOException {
+        try (LineNumberReader reader = new LineNumberReader(new BoundedReader(source, 10_000_000))) {
+            while (reader.readLine() != null) {
+                // noop
+            }
+        }
+    }
+
+    public void testLineNumberReaderAndFileReaderLastLine(final String data) throws IOException {
+        try (TempFile path = TempFile.create(getClass().getSimpleName(), ".txt")) {
+            final File file = path.toFile();
+            FileUtils.write(file, data, StandardCharsets.ISO_8859_1);
+            try (Reader source = Files.newBufferedReader(file.toPath())) {
+                testLineNumberReader(source);
+            }
+        }
+    }
+
+    @Test
+    public void testLineNumberReaderAndFileReaderLastLineEolNo() {
+        assertTimeout(TIMEOUT, () -> testLineNumberReaderAndFileReaderLastLine(STRING_END_NO_EOL));
+    }
+
     @Test
-    public void markReset() throws IOException {
+    public void testLineNumberReaderAndFileReaderLastLineEolYes() {
+        assertTimeout(TIMEOUT, () -> testLineNumberReaderAndFileReaderLastLine(STRING_END_EOL));
+    }
+
+    @Test
+    public void testLineNumberReaderAndStringReaderLastLineEolNo() {
+        assertTimeout(TIMEOUT, () -> testLineNumberReader(new StringReader(STRING_END_NO_EOL)));
+    }
+
+    @Test
+    public void testLineNumberReaderAndStringReaderLastLineEolYes() {
+        assertTimeout(TIMEOUT, () -> testLineNumberReader(new StringReader(STRING_END_EOL)));
+    }
+
+    @Test
+    public void testMarkReset() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.mark(3);
             mr.read();
@@ -87,7 +125,7 @@ public void markReset() throws IOException {
     }
 
     @Test
-    public void markResetFromOffset1() throws IOException {
+    public void testMarkResetFromOffset1() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.mark(3);
             mr.read();
@@ -102,7 +140,7 @@ public void markResetFromOffset1() throws IOException {
     }
 
     @Test
-    public void markResetMarkMore() throws IOException {
+    public void testMarkResetMarkMore() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.mark(4);
             mr.read();
@@ -117,7 +155,7 @@ public void markResetMarkMore() throws IOException {
     }
 
     @Test
-    public void markResetWithMarkOutsideBoundedReaderMax() throws IOException {
+    public void testMarkResetWithMarkOutsideBoundedReaderMax() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.mark(4);
             mr.read();
@@ -128,7 +166,7 @@ public void markResetWithMarkOutsideBoundedReaderMax() throws IOException {
     }
 
     @Test
-    public void markResetWithMarkOutsideBoundedReaderMaxAndInitialOffset() throws IOException {
+    public void testMarkResetWithMarkOutsideBoundedReaderMaxAndInitialOffset() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.read();
             mr.mark(3);
@@ -139,7 +177,18 @@ public void markResetWithMarkOutsideBoundedReaderMaxAndInitialOffset() throws IO
     }
 
     @Test
-    public void readMulti() throws IOException {
+    public void testReadBytesEOF() {
+        assertTimeout(TIMEOUT, () -> {
+            final BoundedReader mr = new BoundedReader(sr, 3);
+            try (BufferedReader br = new BufferedReader(mr)) {
+                br.readLine();
+                br.readLine();
+            }
+        });
+    }
+
+    @Test
+    public void testReadMulti() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             final char[] cbuf = new char[4];
             Arrays.fill(cbuf, 'X');
@@ -153,7 +202,7 @@ public void readMulti() throws IOException {
     }
 
     @Test
-    public void readMultiWithOffset() throws IOException {
+    public void testReadMultiWithOffset() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             final char[] cbuf = new char[4];
             Arrays.fill(cbuf, 'X');
@@ -167,7 +216,7 @@ public void readMultiWithOffset() throws IOException {
     }
 
     @Test
-    public void readTillEnd() throws IOException {
+    public void testReadTillEnd() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.read();
             mr.read();
@@ -177,7 +226,7 @@ public void readTillEnd() throws IOException {
     }
 
     @Test
-    public void shortReader() throws IOException {
+    public void testShortReader() throws IOException {
         try (BoundedReader mr = new BoundedReader(shortReader, 3)) {
             mr.read();
             mr.read();
@@ -186,60 +235,11 @@ public void shortReader() throws IOException {
     }
 
     @Test
-    public void skipTest() throws IOException {
+    public void testSkipTest() throws IOException {
         try (BoundedReader mr = new BoundedReader(sr, 3)) {
             mr.skip(2);
             mr.read();
             assertEquals(-1, mr.read());
         }
     }
-
-    private void testLineNumberReader(final Reader source) throws IOException {
-        try (LineNumberReader reader = new LineNumberReader(new BoundedReader(source, 10_000_000))) {
-            while (reader.readLine() != null) {
-                // noop
-            }
-        }
-    }
-
-    public void testLineNumberReaderAndFileReaderLastLine(final String data) throws IOException {
-        try (TempFile path = TempFile.create(getClass().getSimpleName(), ".txt")) {
-            final File file = path.toFile();
-            FileUtils.write(file, data, StandardCharsets.ISO_8859_1);
-            try (Reader source = Files.newBufferedReader(file.toPath())) {
-                testLineNumberReader(source);
-            }
-        }
-    }
-
-    @Test
-    public void testLineNumberReaderAndFileReaderLastLineEolNo() {
-        assertTimeout(TIMEOUT, () -> testLineNumberReaderAndFileReaderLastLine(STRING_END_NO_EOL));
-    }
-
-    @Test
-    public void testLineNumberReaderAndFileReaderLastLineEolYes() {
-        assertTimeout(TIMEOUT, () -> testLineNumberReaderAndFileReaderLastLine(STRING_END_EOL));
-    }
-
-    @Test
-    public void testLineNumberReaderAndStringReaderLastLineEolNo() {
-        assertTimeout(TIMEOUT, () -> testLineNumberReader(new StringReader(STRING_END_NO_EOL)));
-    }
-
-    @Test
-    public void testLineNumberReaderAndStringReaderLastLineEolYes() {
-        assertTimeout(TIMEOUT, () -> testLineNumberReader(new StringReader(STRING_END_EOL)));
-    }
-
-    @Test
-    public void testReadBytesEOF() {
-        assertTimeout(TIMEOUT, () -> {
-            final BoundedReader mr = new BoundedReader(sr, 3);
-            try (BufferedReader br = new BufferedReader(mr)) {
-                br.readLine();
-                br.readLine();
-            }
-        });
-    }
 }
diff --git a/src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java b/src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java
index 97447dcf..b1ca5a02 100644
--- a/src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java
@@ -17,54 +17,106 @@
 package org.apache.commons.io.input;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
 import java.io.InputStream;
 
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests {@link BrokenInputStream}.
  */
 public class BrokenInputStreamTest {
 
-    private IOException exception;
+    private static BrokenInputStream createBrokenInputStream(final Throwable exception) {
+        if (exception instanceof IOException) {
+            return new BrokenInputStream((IOException) exception);
+        }
+        return new BrokenInputStream(exception);
+    }
 
-    private InputStream stream;
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testAvailable(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenInputStream stream = createBrokenInputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.available()));
+    }
 
-    @BeforeEach
-    public void setUp() {
-        exception = new IOException("test exception");
-        stream = new BrokenInputStream(exception);
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testClose(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenInputStream stream = createBrokenInputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.close()));
     }
 
     @Test
-    public void testAvailable() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.available()));
+    public void testInstance() {
+        assertNotNull(BrokenInputStream.INSTANCE);
     }
 
     @Test
-    public void testClose() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.close()));
+    public void testIO469() throws Throwable {
+        // The exception handling and nested blocks here look ugly.
+        // Do NOT try to rationalize them by combining them, using try-with-resources or assertThrows,
+        // or any similar improvements one would make in normal code. This tests
+        // a very specific bug that comes up in unusual exception structures like this.
+        // If this is improved, that bug will no longer be tested.
+        final InputStream in = new BrokenInputStream();
+        Throwable localThrowable2 = null;
+        try {
+            try {
+                in.read();
+            } catch (final Throwable localThrowable1) {
+                localThrowable2 = localThrowable1;
+                throw localThrowable1;
+            } finally {
+                try {
+                    in.close();
+                } catch (final Throwable x2) {
+                    localThrowable2.addSuppressed(x2);
+                }
+            }
+        } catch (final IOException expected) {
+            final Throwable[] suppressed = expected.getSuppressed();
+            assertEquals(1, suppressed.length);
+        }
     }
 
-    @Test
-    public void testRead() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.read()));
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.read(new byte[1])));
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.read(new byte[1], 0, 1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testRead(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenInputStream stream = createBrokenInputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.read()));
+        assertEquals(exception, assertThrows(clazz, () -> stream.read(new byte[1])));
+        assertEquals(exception, assertThrows(clazz, () -> stream.read(new byte[1], 0, 1)));
     }
 
-    @Test
-    public void testReset() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.reset()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testReset(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenInputStream stream = createBrokenInputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.reset()));
     }
 
-    @Test
-    public void testSkip() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.skip(1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testSkip(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenInputStream stream = createBrokenInputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.skip(1)));
     }
 
     @Test
@@ -81,4 +133,5 @@ public void testTryWithResources() {
         assertEquals(IOException.class, suppressed[0].getClass());
         assertEquals("Broken input stream", suppressed[0].getMessage());
     }
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java b/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java
index dec1efc9..ecafa751 100644
--- a/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java
@@ -23,27 +23,29 @@
 import java.io.IOException;
 import java.io.Reader;
 
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests {@link BrokenReader}.
  */
 public class BrokenReaderTest {
 
-    private IOException exception;
-
-    private Reader brokenReader;
-
-    @BeforeEach
-    public void setUp() {
-        exception = new IOException("test exception");
-        brokenReader = new BrokenReader(exception);
+    private static BrokenReader createBrokenReader(final Throwable exception) {
+        if (exception instanceof IOException) {
+            return new BrokenReader((IOException) exception);
+        }
+        return new BrokenReader(exception);
     }
 
-    @Test
-    public void testClose() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.close()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testClose(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.close()));
     }
 
     @Test
@@ -51,39 +53,67 @@ public void testInstance() {
         assertNotNull(BrokenReader.INSTANCE);
     }
 
-    @Test
-    public void testMark() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.mark(1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testMark(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.mark(1)));
     }
 
-    @Test
-    public void testRead() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.read()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testRead(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read()));
     }
 
-    @Test
-    public void testReadCharArray() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.read(new char[1])));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testReadCharArray(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(new char[1])));
     }
 
-    @Test
-    public void testReadCharArrayIndexed() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.read(new char[1], 0, 1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testReadCharArrayIndexed(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(new char[1], 0, 1)));
     }
 
-    @Test
-    public void testReady() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.ready()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testReady(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.ready()));
     }
 
-    @Test
-    public void testReset() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.reset()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testReset(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.reset()));
     }
 
-    @Test
-    public void testSkip() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.skip(1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testSkip(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenReader brokenReader = createBrokenReader(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.skip(1)));
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java b/src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java
index 0a56ae8e..f04b7dee 100644
--- a/src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java
@@ -16,11 +16,16 @@
  */
 package org.apache.commons.io.input;
 
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.channels.FileChannel;
 import java.nio.file.StandardOpenOption;
 
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 /**
  * Tests functionality of {@link BufferedFileChannelInputStream}.
@@ -43,7 +48,32 @@ public void setUp() throws IOException {
             BufferedFileChannelInputStream.builder().setPath(inputFile).setBufferSize(123).get(), // small, unaligned buffer size
             BufferedFileChannelInputStream.builder().setURI(inputFile.toUri()).setBufferSize(1024).get(), // URI and buffer size
             BufferedFileChannelInputStream.builder().setPath(inputFile).setOpenOptions(StandardOpenOption.READ).get(), // open options
+            BufferedFileChannelInputStream.builder().setFileChannel(FileChannel.open(inputFile)).get(), // FileChannel
         };
         //@formatter:on
     }
+
+    @Override
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        for (final InputStream inputStream : inputStreams) {
+            assertTrue(inputStream.available() > 0);
+        }
+    }
+
+    @Test
+    public void testBuilderGet() {
+        // java.lang.IllegalStateException: origin == null
+        assertThrows(IllegalStateException.class, () -> BufferedFileChannelInputStream.builder().get());
+    }
+
+    @Test
+    public void testReadAfterClose() throws Exception {
+        for (final InputStream inputStream : inputStreams) {
+            inputStream.close();
+            assertThrows(IOException.class, inputStream::read);
+        }
+    }
+
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java b/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
index a8e06b81..b2d23ce6 100644
--- a/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
@@ -20,21 +20,25 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
 import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderResult;
+import java.nio.charset.CodingErrorAction;
 import java.nio.charset.StandardCharsets;
+import java.nio.charset.UnmappableCharacterException;
 import java.util.Random;
-import java.util.Set;
 
-import org.apache.commons.io.Charsets;
 import org.apache.commons.io.CharsetsTest;
 import org.apache.commons.io.IOUtils;
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -64,10 +68,6 @@ private int checkAvail(final InputStream is, final int min) throws Exception {
         return available;
     }
 
-    private Set<String> getRequiredCharsetNames() {
-        return Charsets.requiredCharsets().keySet();
-    }
-
     private boolean isAvailabilityTestableForCharset(final String csName) {
         return Charset.forName(csName).canEncode()
                 && !"COMPOUND_TEXT".equalsIgnoreCase(csName) && !"x-COMPOUND_TEXT".equalsIgnoreCase(csName)
@@ -105,6 +105,30 @@ public void testAvailable(final String csName) throws Exception {
         }
     }
 
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = CharSequenceInputStream.builder().setCharSequence("Hi").get()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    /**
+     * IO-781 available() returns 2 but only 1 byte is read afterwards.
+     */
+    @Test
+    public void testAvailableAfterOpen() throws IOException {
+        final Charset charset = Charset.forName("Big5");
+        try (CharSequenceInputStream in = new CharSequenceInputStream("\uD800\uDC00", charset)) {
+            final int available = in.available();
+            final byte[] data = new byte[available];
+            final int bytesRead = in.read(data);
+            assertEquals(available, bytesRead);
+        }
+    }
+
     private void testAvailableRead(final String csName) throws Exception {
         final String input = "test";
         try (InputStream r = new CharSequenceInputStream(input, csName)) {
@@ -168,11 +192,10 @@ public void testBufferedRead_AvailableCharset(final String csName) throws IOExce
         }
     }
 
-    @Test
-    public void testBufferedRead_RequiredCharset() throws IOException {
-        for (final String csName : getRequiredCharsetNames()) {
-            testBufferedRead(TEST_STRING, csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testBufferedRead_RequiredCharset(final String csName) throws IOException {
+        testBufferedRead(TEST_STRING, csName);
     }
 
     @Test
@@ -180,6 +203,17 @@ public void testBufferedRead_UTF8() throws IOException {
         testBufferedRead(TEST_STRING, UTF_8);
     }
 
+    @Test
+    public void testCharacterCodingException() throws IOException {
+        final Charset charset = StandardCharsets.US_ASCII;
+        final CharSequenceInputStream in = CharSequenceInputStream.builder()
+            .setCharsetEncoder(charset.newEncoder().onUnmappableCharacter(CodingErrorAction.REPORT))
+            .setCharSequence("\u0080")
+            .get();
+        assertEquals(0, in.available());
+        assertThrows(UnmappableCharacterException.class, in::read);
+    }
+
     private void testCharsetMismatchInfiniteLoop(final String csName) throws IOException {
         // Input is UTF-8 bytes: 0xE0 0xB2 0xA0
         final char[] inputChars = { (char) 0xE0, (char) 0xB2, (char) 0xA0 };
@@ -192,11 +226,10 @@ private void testCharsetMismatchInfiniteLoop(final String csName) throws IOExcep
         }
     }
 
-    @Test
-    public void testCharsetMismatchInfiniteLoop_RequiredCharsets() throws IOException {
-        for (final String csName : getRequiredCharsetNames()) {
-            testCharsetMismatchInfiniteLoop(csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testCharsetMismatchInfiniteLoop_RequiredCharsets(final String csName) throws IOException {
+        testCharsetMismatchInfiniteLoop(csName);
     }
 
     // Test is broken if readFirst > 0
@@ -283,11 +316,10 @@ public void testIO_356_Loop_UTF8() throws Exception {
         testIO_356_Loop(charset.displayName(), (int) ReaderInputStream.minBufferSize(charset.newEncoder()));
     }
 
-    @Test
-    public void testLargeBufferedRead_RequiredCharsets() throws IOException {
-        for (final String csName : getRequiredCharsetNames()) {
-            testBufferedRead(LARGE_TEST_STRING, csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testLargeBufferedRead_RequiredCharsets(final String csName) throws IOException {
+        testBufferedRead(LARGE_TEST_STRING, csName);
     }
 
     @Test
@@ -295,11 +327,10 @@ public void testLargeBufferedRead_UTF8() throws IOException {
         testBufferedRead(LARGE_TEST_STRING, UTF_8);
     }
 
-    @Test
-    public void testLargeSingleByteRead_RequiredCharsets() throws IOException {
-        for (final String csName : getRequiredCharsetNames()) {
-            testSingleByteRead(LARGE_TEST_STRING, csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testLargeSingleByteRead_RequiredCharsets(final String csName) throws IOException {
+        testSingleByteRead(LARGE_TEST_STRING, csName);
     }
 
     @Test
@@ -307,7 +338,8 @@ public void testLargeSingleByteRead_UTF8() throws IOException {
         testSingleByteRead(LARGE_TEST_STRING, UTF_8);
     }
 
-    // This test is broken for charsets that don't create a single byte for each char
+    // This test doesn't work for charsets that don't create a single byte for each char.
+    // Use testMarkResetMultiByteChars() instead for those cases.
     private void testMarkReset(final String csName) throws Exception {
         try (InputStream r = new CharSequenceInputStream("test", csName)) {
             assertEquals(2, r.skip(2));
@@ -324,17 +356,15 @@ private void testMarkReset(final String csName) throws Exception {
         }
     }
 
-    @Test
-    @Disabled // Test broken for charsets that create multiple bytes for a single char
-    public void testMarkReset_RequiredCharsets() throws Exception {
-        for (final String csName : getRequiredCharsetNames()) {
-            testMarkReset(csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testMarkReset_RequiredCharsets(final String csName) throws Exception {
+        testMarkResetMultiByteChars(csName);
     }
 
     @Test
     public void testMarkReset_USASCII() throws Exception {
-        testMarkReset("US-ASCII");
+        testMarkReset(StandardCharsets.US_ASCII.name());
     }
 
     @Test
@@ -342,6 +372,47 @@ public void testMarkReset_UTF8() throws Exception {
         testMarkReset(UTF_8);
     }
 
+    private void testMarkResetMultiByteChars(final String csName) throws IOException {
+        // This test quietly skips Charsets that can't handle multibyte characters like ASCII.
+        final String sequenceEnglish = "Test Sequence";
+        final String sequenceCJK = "\u4e01\u4f23\u5045\u5167\u5289\u53ab"; // Kanji text
+        final String[] sequences = {sequenceEnglish, sequenceCJK};
+        for (final String testSequence : sequences) {
+            final CharsetEncoder charsetEncoder = Charset.forName(csName).newEncoder();
+            final ByteBuffer byteBuffer = ByteBuffer.allocate(testSequence.length() * 3);
+            final CharBuffer charBuffer = CharBuffer.wrap(testSequence);
+            final CoderResult result = charsetEncoder.encode(charBuffer, byteBuffer, true);
+            if (result.isUnmappable()) {
+                continue; // Skip character sets that can't handle multibyte characters.
+            }
+            final byte[] expectedBytes = byteBuffer.array();
+
+            final int bLength = byteBuffer.position();
+            final int skip = bLength - 4;
+            try (InputStream r = new CharSequenceInputStream(testSequence, csName)) {
+                assertEquals(skip, r.skip(skip));
+                r.mark(0);
+                assertEquals(expectedBytes[bLength - 4], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 3], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 2], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 1], (byte) r.read(), csName);
+                assertEquals(-1, (byte) r.read(), csName);
+                r.reset();
+                assertEquals(expectedBytes[bLength - 4], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 3], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 2], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 1], (byte) r.read(), csName);
+                assertEquals(-1, (byte) r.read(), csName);
+                r.reset();
+                assertEquals(expectedBytes[bLength - 4], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 3], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 2], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 1], (byte) r.read(), csName);
+                assertEquals(-1, (byte) r.read(), csName);
+            }
+        }
+    }
+
     @Test
     public void testMarkSupported() throws Exception {
         try (@SuppressWarnings("deprecation")
@@ -377,6 +448,16 @@ public void testNullCharsetName() throws IOException {
         }
     }
 
+    @Test
+    public void testReadAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = CharSequenceInputStream.builder().setCharSequence("Hi").get()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
     private void testReadZero(final String csName) throws Exception {
         try (InputStream r = new CharSequenceInputStream("test", csName)) {
             final byte[] bytes = new byte[30];
@@ -392,11 +473,10 @@ public void testReadZero_EmptyString() throws Exception {
         }
     }
 
-    @Test
-    public void testReadZero_RequiredCharsets() throws Exception {
-        for (final String csName : getRequiredCharsetNames()) {
-            testReadZero(csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testReadZero_RequiredCharsets(final String csName) throws Exception {
+        testReadZero(csName);
     }
 
     private void testResetBeforeEnd(final CharSequenceInputStream inputStream) throws IOException {
@@ -419,7 +499,6 @@ private void testResetBeforeEnd(final CharSequenceInputStream inputStream) throw
     }
 
     @Test
-    @Disabled("[IO-795] CharSequenceInputStream.reset() only works once")
     public void testResetBeforeEndSetCharSequence() throws IOException {
         try (final CharSequenceInputStream inputStream = CharSequenceInputStream.builder().setCharSequence("1234").get()) {
             testResetBeforeEnd(inputStream);
@@ -454,11 +533,10 @@ private void testSingleByteRead(final String testString, final String charsetNam
         }
     }
 
-    @Test
-    public void testSingleByteRead_RequiredCharsets() throws IOException {
-        for (final String csName : getRequiredCharsetNames()) {
-            testSingleByteRead(TEST_STRING, csName);
-        }
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testSingleByteRead_RequiredCharsets(final String csName) throws IOException {
+        testSingleByteRead(TEST_STRING, csName);
     }
 
     @Test
@@ -471,32 +549,14 @@ public void testSingleByteRead_UTF8() throws IOException {
         testSingleByteRead(TEST_STRING, UTF_8);
     }
 
-    // This is broken for charsets that don't map each char to a byte
-    private void testSkip(final String csName) throws Exception {
+    @ParameterizedTest
+    @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
+    public void testSkip_RequiredCharsets(final String csName) throws Exception {
         try (InputStream r = new CharSequenceInputStream("test", csName)) {
             assertEquals(1, r.skip(1));
             assertEquals(2, r.skip(2));
-            assertEquals('t', r.read(), csName);
             r.skip(100);
             assertEquals(-1, r.read(), csName);
         }
     }
-
-    @Test
-    @Disabled // test is broken for charsets that generate multiple bytes per char.
-    public void testSkip_RequiredCharsets() throws Exception {
-        for (final String csName : getRequiredCharsetNames()) {
-            testSkip(csName);
-        }
-    }
-
-    @Test
-    public void testSkip_USASCII() throws Exception {
-        testSkip("US-ASCII");
-    }
-
-    @Test
-    public void testSkip_UTF8() throws Exception {
-        testSkip(UTF_8);
-    }
 }
diff --git a/src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java b/src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java
index 6ea34fab..131e2f75 100644
--- a/src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java
@@ -47,7 +47,7 @@ private void checkArray(final char[] expected, final char[] actual) {
 
     private void checkRead(final Reader reader, final String expected) throws IOException {
         for (int i = 0; i < expected.length(); i++) {
-            assertEquals(expected.charAt(i), (char)reader.read(), "Read[" + i + "] of '" + expected + "'");
+            assertEquals(expected.charAt(i), (char) reader.read(), "Read[" + i + "] of '" + expected + "'");
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/ChecksumInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ChecksumInputStreamTest.java
new file mode 100644
index 00000000..c92d0433
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/input/ChecksumInputStreamTest.java
@@ -0,0 +1,232 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.test.CustomIOException;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link ChecksumInputStream}.
+ */
+public class ChecksumInputStreamTest {
+
+    private ChecksumInputStream createInputStream() throws IOException {
+        return ChecksumInputStream.builder().setCharSequence("Hi").setChecksum(new CRC32()).get();
+    }
+
+    @Test
+    public void testAfterReadConsumer() throws Exception {
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = ChecksumInputStream.builder()
+                .setCharSequence("Hi")
+                .setChecksum(new CRC32())
+                .setExpectedChecksumValue(1293356558)
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = ChecksumInputStream.builder()
+                .setCharSequence("Hi")
+                .setChecksum(new CRC32())
+                .setExpectedChecksumValue(1293356558)
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            assertEquals('H', in.read());
+            assertTrue(in.available() > 0);
+        }
+    }
+
+    @Test
+    public void testDefaultThresholdFailure() throws IOException {
+        final byte[] byteArray = new byte[3];
+        final Adler32 adler32 = new Adler32();
+        try (ChecksumInputStream checksum = ChecksumInputStream.builder()
+        // @formatter:off
+                .setByteArray(byteArray)
+                .setChecksum(adler32)
+                .setExpectedChecksumValue((byte) -68)
+                .get()) {
+                // @formatter:on
+            assertEquals(0, checksum.getByteCount());
+            assertEquals(-1, checksum.getRemaining());
+            // Ask to read one more byte than there is, we get the correct byte count.
+            assertEquals(byteArray.length, checksum.read(new byte[byteArray.length + 1]));
+            // Next read is at EOF
+            assertThrows(IOException.class, () -> checksum.read(new byte[1]));
+            assertEquals(byteArray.length, checksum.getByteCount());
+            assertEquals(-4, checksum.getRemaining());
+        }
+    }
+
+    @Test
+    public void testDefaultThresholdSuccess() throws IOException {
+        // sanity-check
+        final Adler32 sanityCheck = new Adler32();
+        final byte[] byteArray = new byte[3];
+        sanityCheck.update(byteArray);
+        final long expectedChecksum = sanityCheck.getValue();
+        // actual
+        final Adler32 adler32 = new Adler32();
+        try (ChecksumInputStream checksum = ChecksumInputStream.builder()
+        // @formatter:off
+                .setByteArray(byteArray)
+                .setChecksum(adler32)
+                .setExpectedChecksumValue(expectedChecksum)
+                .get()) {
+                // @formatter:on
+            assertEquals(0, checksum.getByteCount());
+            assertEquals(-1, checksum.getRemaining());
+            assertEquals(3, checksum.read(byteArray));
+            assertEquals(byteArray.length, checksum.getByteCount());
+            assertEquals(-4, checksum.getRemaining());
+            assertEquals(-1, checksum.read(byteArray));
+            assertEquals(byteArray.length, checksum.getByteCount());
+            assertEquals(-4, checksum.getRemaining());
+        }
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testReadAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
+    @Test
+    public void testReadTakingByteArrayThrowsException() throws IOException {
+        final Adler32 adler32 = new Adler32();
+        final byte[] byteArray = new byte[3];
+        final long sizeThreshold = -1859L;
+        try (ChecksumInputStream checksum = ChecksumInputStream.builder()
+        // @formatter:off
+                .setByteArray(byteArray)
+                .setChecksum(adler32)
+                .setExpectedChecksumValue((byte) -68)
+                .setCountThreshold(sizeThreshold)
+                .get()) {
+                // @formatter:on
+            assertEquals(0, checksum.getByteCount());
+            assertEquals(sizeThreshold, checksum.getRemaining());
+            // Ask to read one more byte than there is.
+            assertEquals(byteArray.length, checksum.read(new byte[byteArray.length + 1]));
+            // Next read is at EOF
+            assertThrows(IOException.class, () -> checksum.read(new byte[1]));
+            assertEquals(byteArray.length, checksum.getByteCount());
+            assertEquals(sizeThreshold - byteArray.length, checksum.getRemaining());
+        }
+    }
+
+    @Test
+    public void testReadTakingNoArgumentsThrowsException() throws IOException {
+        final CRC32 crc32 = new CRC32();
+        final byte[] byteArray = new byte[9];
+        try (ChecksumInputStream checksum = ChecksumInputStream.builder()
+        // @formatter:off
+                .setByteArray(byteArray)
+                .setChecksum(crc32)
+                .setExpectedChecksumValue((byte) 1)
+                .setCountThreshold(1)
+                .get()) {
+                // @formatter:on
+            assertEquals(0, checksum.getByteCount());
+            assertEquals(1, checksum.getRemaining());
+            assertThrows(IOException.class, () -> checksum.read());
+            assertEquals(1, checksum.getByteCount());
+            assertEquals(0, checksum.getRemaining());
+        }
+    }
+
+    @Test
+    public void testSkip() throws IOException {
+        // sanity-check
+        final CRC32 sanityCheck = new CRC32();
+        final byte[] byteArray = new byte[4];
+        sanityCheck.update(byteArray);
+        final long expectedChecksum = sanityCheck.getValue();
+        // actual
+        final CRC32 crc32 = new CRC32();
+        final InputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);
+        try (ChecksumInputStream checksum = ChecksumInputStream.builder()
+        // @formatter:off
+                .setInputStream(byteArrayInputStream)
+                .setChecksum(crc32)
+                .setExpectedChecksumValue(expectedChecksum)
+                .setCountThreshold(33)
+                .get()) {
+                // @formatter:on
+            assertEquals(0, checksum.getByteCount());
+            assertEquals(4, checksum.read(byteArray));
+            assertEquals(byteArray.length, checksum.getByteCount());
+            assertEquals(29, checksum.getRemaining());
+            final long skipReturnValue = checksum.skip((byte) 1);
+            assertEquals(byteArray.length, checksum.getByteCount());
+            assertEquals(29, checksum.getRemaining());
+            assertEquals(558161692L, crc32.getValue());
+            assertEquals(0, byteArrayInputStream.available());
+            assertArrayEquals(new byte[4], byteArray);
+            assertEquals(0L, skipReturnValue);
+            assertEquals(29, checksum.getRemaining());
+        }
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java b/src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java
index db8bb37b..0439938a 100644
--- a/src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java
@@ -19,6 +19,7 @@
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -35,9 +36,8 @@ public class CircularInputStreamTest {
     private void assertStreamOutput(final byte[] toCycle, final byte[] expected) throws IOException {
         final byte[] actual = new byte[expected.length];
 
-        try (InputStream infStream = createInputStream(toCycle, -1)) {
-            final int actualReadBytes = infStream.read(actual);
-
+        try (InputStream inputStream = createInputStream(toCycle, -1)) {
+            final int actualReadBytes = inputStream.read(actual);
             assertArrayEquals(expected, actual);
             assertEquals(expected.length, actualReadBytes);
         }
@@ -47,6 +47,29 @@ private InputStream createInputStream(final byte[] repeatContent, final long tar
         return new CircularInputStream(repeatContent, targetByteCount);
     }
 
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream(new byte[] { 1, 2 }, 4)) {
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertEquals(2, in.read());
+            assertEquals(1, in.read());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = createInputStream(new byte[] { 1, 2 }, 1)) {
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertTrue(in.available() > 0);
+        }
+    }
+
     @Test
     public void testContainsEofInputSize0() {
         assertThrows(IllegalArgumentException.class, () -> createInputStream(new byte[] { -1 }, 0));
@@ -83,7 +106,6 @@ public void testCount1InputSize1() throws IOException {
     public void testCycleBytes() throws IOException {
         final byte[] input = { 1, 2 };
         final byte[] expected = { 1, 2, 1, 2, 1 };
-
         assertStreamOutput(input, expected);
     }
 
@@ -92,6 +114,20 @@ public void testNullInputSize0() {
         assertThrows(NullPointerException.class, () -> createInputStream(null, 0));
     }
 
+    @SuppressWarnings("resource")
+    @Test
+    public void testReaderAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream(new byte[] { 1, 2 }, 4)) {
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertEquals(2, in.read());
+            assertEquals(1, in.read());
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
     @Test
     public void testWholeRangeOfBytes() throws IOException {
         final int size = Byte.MAX_VALUE - Byte.MIN_VALUE + 1;
@@ -101,9 +137,7 @@ public void testWholeRangeOfBytes() throws IOException {
             contentToCycle[i] = value == IOUtils.EOF ? 0 : value;
             value++;
         }
-
         final byte[] expectedOutput = Arrays.copyOf(contentToCycle, size);
-
         assertStreamOutput(contentToCycle, expectedOutput);
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java
index 3b341ba0..210172f6 100644
--- a/src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java
@@ -28,22 +28,22 @@
 import java.io.Serializable;
 
 import org.apache.commons.lang3.SerializationUtils;
+import org.junit.jupiter.api.Test;
 
 /**
  * Tests {@link ClassLoaderObjectInputStream}.
  */
 public class ClassLoaderObjectInputStreamTest {
 
-    /*
+    /**
      * Note: This test case tests the simplest functionality of ObjectInputStream. IF we really wanted to test
      * ClassLoaderObjectInputStream we would probably need to create a transient Class Loader. -TO
      */
-
     private enum E {
         A, B, C
     }
 
-    private static final class Test implements Serializable {
+    private static final class TestFixture implements Serializable {
         private static final long serialVersionUID = 1L;
         private final int i;
 
@@ -51,7 +51,7 @@ private static final class Test implements Serializable {
 
         private final E e;
 
-        Test(final int i, final Object o) {
+        TestFixture(final int i, final Object o) {
             this.i = i;
             this.e = E.A;
             this.o = o;
@@ -66,8 +66,8 @@ private boolean equalObject(final Object other) {
 
         @Override
         public boolean equals(final Object other) {
-            if (other instanceof Test) {
-                final Test tOther = (Test) other;
+            if (other instanceof TestFixture) {
+                final TestFixture tOther = (TestFixture) other;
                 return this.i == tOther.i & this.e == tOther.e & equalObject(tOther.o);
             }
             return false;
@@ -79,7 +79,7 @@ public int hashCode() {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testExpected() throws Exception {
         final Boolean input = Boolean.FALSE;
         final InputStream bais = new ByteArrayInputStream(SerializationUtils.serialize(input));
@@ -89,7 +89,7 @@ public void testExpected() throws Exception {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testLong() throws Exception {
         final Long input = 123L;
         final InputStream bais = new ByteArrayInputStream(SerializationUtils.serialize(input));
@@ -99,9 +99,9 @@ public void testLong() throws Exception {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testObject1() throws Exception {
-        final Test input = new Test(123, null);
+        final TestFixture input = new TestFixture(123, null);
         final InputStream bais = new ByteArrayInputStream(SerializationUtils.serialize(input));
         try (ClassLoaderObjectInputStream clois = new ClassLoaderObjectInputStream(getClass().getClassLoader(), bais)) {
             final Object result = clois.readObject();
@@ -109,9 +109,9 @@ public void testObject1() throws Exception {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testObject2() throws Exception {
-        final Test input = new Test(123, 0);
+        final TestFixture input = new TestFixture(123, 0);
         final InputStream bais = new ByteArrayInputStream(SerializationUtils.serialize(input));
         try (ClassLoaderObjectInputStream clois = new ClassLoaderObjectInputStream(getClass().getClassLoader(), bais)) {
             final Object result = clois.readObject();
@@ -119,7 +119,7 @@ public void testObject2() throws Exception {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testPrimitiveLong() throws Exception {
         final long input = 12345L;
         final ByteArrayOutputStream baos = new ByteArrayOutputStream();
@@ -133,7 +133,7 @@ public void testPrimitiveLong() throws Exception {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testResolveProxyClass() throws Exception {
         final InputStream bais = new ByteArrayInputStream(SerializationUtils.serialize(Boolean.FALSE));
         try (ClassLoaderObjectInputStream clois = new ClassLoaderObjectInputStream(getClass().getClassLoader(), bais)) {
@@ -143,7 +143,7 @@ public void testResolveProxyClass() throws Exception {
         }
     }
 
-    @org.junit.jupiter.api.Test
+    @Test
     public void testResolveProxyClassWithMultipleInterfaces() throws Exception {
         final InputStream bais = new ByteArrayInputStream(SerializationUtils.serialize(Boolean.FALSE));
         try (ClassLoaderObjectInputStream clois = new ClassLoaderObjectInputStream(getClass().getClassLoader(), bais)) {
diff --git a/src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java b/src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java
index a839242c..b954a102 100644
--- a/src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java
@@ -18,11 +18,13 @@
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.commons.io.IOUtils;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -33,7 +35,7 @@ public class CloseShieldInputStreamTest {
 
     private byte[] data;
 
-    private InputStream original;
+    private InputStream byteArrayInputStream;
 
     private InputStream shielded;
 
@@ -42,22 +44,68 @@ public class CloseShieldInputStreamTest {
     @BeforeEach
     public void setUp() {
         data = new byte[] { 'x', 'y', 'z' };
-        original = new ByteArrayInputStream(data) {
+        byteArrayInputStream = new ByteArrayInputStream(data) {
             @Override
             public void close() {
                 closed = true;
             }
         };
-        shielded = CloseShieldInputStream.wrap(original);
         closed = false;
     }
 
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = CloseShieldInputStream.wrap(byteArrayInputStream)) {
+            assertEquals(3, in.available());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = CloseShieldInputStream.wrap(byteArrayInputStream)) {
+            assertEquals(3, in.available());
+        }
+    }
+
     @Test
     public void testClose() throws IOException {
+        shielded = CloseShieldInputStream.wrap(byteArrayInputStream);
+        shielded.close();
+        assertFalse(closed, "closed");
+        assertEquals(-1, shielded.read(), "read()");
+        assertEquals(data[0], byteArrayInputStream.read(), "read()");
+    }
+
+
+    @Test
+    public void testReadAfterCose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = CloseShieldInputStream.wrap(byteArrayInputStream)) {
+            assertEquals(3, in.available());
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
+    @Test
+    public void testSystemInOnSystemInNo() throws IOException {
+        shielded = CloseShieldInputStream.systemIn(byteArrayInputStream);
+        shielded.close();
+        assertTrue(closed, "closed");
+        assertEquals(data[0], shielded.read(), "read()");
+        assertEquals(data[1], byteArrayInputStream.read(), "read()");
+    }
+
+    @Test
+    public void testSystemInOnSystemInYes() throws IOException {
+        shielded = CloseShieldInputStream.systemIn(System.in);
         shielded.close();
         assertFalse(closed, "closed");
         assertEquals(-1, shielded.read(), "read()");
-        assertEquals(data[0], original.read(), "read()");
+        assertEquals(data[0], byteArrayInputStream.read(), "read()");
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java
index a8ff62aa..e66e265d 100644
--- a/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java
@@ -16,7 +16,11 @@
  */
 package org.apache.commons.io.input;
 
+import static org.apache.commons.io.IOUtils.EOF;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertSame;
+
+import java.io.InputStream;
 
 import org.junit.jupiter.api.Test;
 
@@ -25,10 +29,84 @@
  */
 public class ClosedInputStreamTest {
 
+    private void assertEof(final ClosedInputStream cis) {
+        assertEquals(EOF, cis.read(), "read()");
+    }
+
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        assertEquals(0, ClosedInputStream.INSTANCE.available());
+        assertEquals(0, ClosedInputStream.INSTANCE.available());
+        final InputStream shadow;
+        try (InputStream in = new ClosedInputStream()) {
+            assertEquals(0, in.available());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        assertEquals(0, ClosedInputStream.INSTANCE.available());
+        assertEquals(0, ClosedInputStream.INSTANCE.available());
+        try (ClosedInputStream cis = new ClosedInputStream()) {
+            assertEquals(0, cis.available());
+        }
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testNonNull() throws Exception {
+        assertSame(ClosedInputStream.INSTANCE, ClosedInputStream.ifNull(null));
+        assertSame(ClosedInputStream.INSTANCE, ClosedInputStream.ifNull(ClosedInputStream.INSTANCE));
+        assertSame(System.in, ClosedInputStream.ifNull(System.in));
+    }
+
     @Test
     public void testRead() throws Exception {
         try (ClosedInputStream cis = new ClosedInputStream()) {
-            assertEquals(-1, cis.read(), "read()");
+            assertEof(cis);
+        }
+    }
+
+    @Test
+    public void testReadAfterCose() throws Exception {
+        assertEquals(0, ClosedInputStream.INSTANCE.available());
+        assertEquals(0, ClosedInputStream.INSTANCE.available());
+        final InputStream shadow;
+        try (InputStream in = new ClosedInputStream()) {
+            assertEquals(0, in.available());
+            shadow = in;
+        }
+        assertEquals(EOF, shadow.read());
+    }
+
+    @Test
+    public void testReadArray() throws Exception {
+        try (ClosedInputStream cis = new ClosedInputStream()) {
+            assertEquals(EOF, cis.read(new byte[4096]));
+            assertEquals(EOF, cis.read(new byte[1]));
+            assertEquals(EOF, cis.read(new byte[0]));
+        }
+    }
+
+    @Test
+    public void testReadArrayIndex() throws Exception {
+        try (ClosedInputStream cis = new ClosedInputStream()) {
+            assertEquals(EOF, cis.read(new byte[4096], 0, 1));
+            assertEquals(EOF, cis.read(new byte[1], 0, 1));
+            assertEquals(EOF, cis.read(new byte[0], 0, 0));
+        }
+    }
+
+    @Test
+    public void testSingleton() throws Exception {
+        try (@SuppressWarnings("deprecation")
+        ClosedInputStream cis = ClosedInputStream.CLOSED_INPUT_STREAM) {
+            assertEof(cis);
+        }
+        try (ClosedInputStream cis = ClosedInputStream.INSTANCE) {
+            assertEof(cis);
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java b/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java
index 9fd5dccf..3b0b8830 100644
--- a/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java
@@ -16,8 +16,13 @@
  */
 package org.apache.commons.io.input;
 
+import static org.apache.commons.io.IOUtils.EOF;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
+import java.io.IOException;
+import java.io.Reader;
+import java.nio.CharBuffer;
+
 import org.junit.jupiter.api.Test;
 
 /**
@@ -25,10 +30,61 @@
  */
 public class ClosedReaderTest {
 
+    private void assertEof(final Reader reader) throws IOException {
+        assertEquals(EOF, reader.read(), "read()");
+    }
+
+    @Test
+    public void testRead() throws IOException {
+        try (Reader reader = new ClosedReader()) {
+            assertEof(reader);
+        }
+    }
+
+    @Test
+    public void testReadArray() throws Exception {
+        try (Reader reader = new ClosedReader()) {
+            assertEquals(EOF, reader.read(new char[4096]));
+            assertEquals(EOF, reader.read(new char[1]));
+            assertEquals(EOF, reader.read(new char[0]));
+        }
+    }
+
+    @Test
+    public void testReadArrayIndex() throws Exception {
+        try (Reader reader = new ClosedReader()) {
+            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[4096])));
+            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[1])));
+            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[0])));
+        }
+    }
+
+    @Test
+    public void testReadCharBuffer() throws Exception {
+        try (Reader reader = new ClosedReader()) {
+            assertEquals(EOF, reader.read(new char[4096]));
+            assertEquals(EOF, reader.read(new char[1]));
+            assertEquals(EOF, reader.read(new char[0]));
+        }
+    }
+
+    @Test
+    public void testSingleton() throws Exception {
+        try (@SuppressWarnings("deprecation")
+        Reader reader = ClosedReader.CLOSED_READER) {
+            assertEof(reader);
+        }
+        try (Reader reader = ClosedReader.INSTANCE) {
+            assertEof(reader);
+        }
+    }
+
     @Test
-    public void testRead() throws Exception {
-        try (ClosedReader cr = new ClosedReader()) {
-            assertEquals(-1, cr.read(new char[10], 0, 10), "read(cbuf, off, len)");
+    public void testSkip() throws Exception {
+        try (Reader reader = new ClosedReader()) {
+            assertEquals(0, reader.skip(4096));
+            assertEquals(0, reader.skip(1));
+            assertEquals(0, reader.skip(0));
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java b/src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java
index ba369a9a..c9fbcd92 100644
--- a/src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java
@@ -21,15 +21,46 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 
 import org.apache.commons.io.IOUtils;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
- * Tests the CountingInputStream.
+ * Tests {@link CountingInputStream}.
  */
 public class CountingInputStreamTest {
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterClose(final int len) throws Exception {
+        final ByteArrayInputStream bais = new ByteArrayInputStream(new byte[len]);
+        final InputStream shadow;
+        try (InputStream in = CloseShieldInputStream.wrap(bais)) {
+            assertEquals(len, in.available());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterOpen(final int len) throws Exception {
+        final ByteArrayInputStream bais = new ByteArrayInputStream(new byte[len]);
+        try (InputStream in = CloseShieldInputStream.wrap(bais)) {
+            assertEquals(len, in.available());
+        }
+    }
+
+    @SuppressWarnings({ "resource", "deprecation" })
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(new CountingInputStream(new BrokenInputStream((Throwable) new IOException())));
+    }
+
     @Test
     public void testCounting() throws Exception {
         final String text = "A piece of text";
@@ -62,7 +93,6 @@ public void testCounting() throws Exception {
         }
     }
 
-
     @Test
     public void testEOF1() throws Exception {
         final ByteArrayInputStream bais = new ByteArrayInputStream(new byte[2]);
@@ -120,7 +150,7 @@ public void testLargeFiles_IO84() throws Exception {
         assertThrows(ArithmeticException.class, () -> cis.getCount());
         assertThrows(ArithmeticException.class, () -> cis.resetCount());
 
-        mock.close();
+        mock.init();
 
         // Test long methods
         IOUtils.consume(cis);
@@ -128,6 +158,19 @@ public void testLargeFiles_IO84() throws Exception {
         assertEquals(size, cis.resetByteCount(), "resetByteCount()");
     }
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testReadAfterClose(final int len) throws Exception {
+        final ByteArrayInputStream bais = new ByteArrayInputStream(new byte[len]);
+        final InputStream shadow;
+        try (InputStream in = CloseShieldInputStream.wrap(bais)) {
+            assertEquals(len, in.available());
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
     @Test
     public void testResetting() throws Exception {
         final String text = "A piece of text";
@@ -154,7 +197,7 @@ public void testSkipping() throws IOException {
             assertEquals(6, cis.skip(6));
             assertEquals(6, cis.getCount());
             final byte[] result = new byte[6];
-            cis.read(result);
+            assertEquals(result.length, cis.read(result));
 
             assertEquals("World!", new String(result));
             assertEquals(12, cis.getCount());
diff --git a/src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java b/src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java
index 67baacaa..451d289e 100644
--- a/src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java
@@ -19,6 +19,7 @@
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -34,10 +35,8 @@ public class InfiniteCircularInputStreamTest {
 
     private void assertStreamOutput(final byte[] toCycle, final byte[] expected) throws IOException {
         final byte[] actual = new byte[expected.length];
-
         try (InputStream infStream = new InfiniteCircularInputStream(toCycle)) {
             final int actualReadBytes = infStream.read(actual);
-
             assertArrayEquals(expected, actual);
             assertEquals(expected.length, actualReadBytes);
         }
@@ -47,6 +46,33 @@ private InputStream createInputStream(final byte[] repeatContent) {
         return new InfiniteCircularInputStream(repeatContent);
     }
 
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream(new byte[] { 1, 2 })) {
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertEquals(2, in.read());
+            assertEquals(1, in.read());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = createInputStream(new byte[] { 1, 2 })) {
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertTrue(in.available() > 0);
+            assertEquals(2, in.read());
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertTrue(in.available() > 0);
+        }
+    }
+
     @Test
     public void testContainsEofInputSize0() {
         assertThrows(IllegalArgumentException.class, () -> createInputStream(new byte[] { -1 }));
@@ -85,6 +111,20 @@ public void testNullInputSize0() {
         assertThrows(NullPointerException.class, () -> createInputStream(null));
     }
 
+    @SuppressWarnings("resource")
+    @Test
+    public void testReadAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream(new byte[] { 1, 2 })) {
+            assertTrue(in.available() > 0);
+            assertEquals(1, in.read());
+            assertEquals(2, in.read());
+            assertEquals(1, in.read());
+            shadow = in;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
     @Test
     public void testWholeRangeOfBytes() throws IOException {
         final int size = Byte.MAX_VALUE - Byte.MIN_VALUE + 1;
@@ -94,9 +134,7 @@ public void testWholeRangeOfBytes() throws IOException {
             contentToCycle[i] = value == IOUtils.EOF ? 0 : value;
             value++;
         }
-
         final byte[] expectedOutput = Arrays.copyOf(contentToCycle, size);
-
         assertStreamOutput(contentToCycle, expectedOutput);
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java b/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java
index ba0944ef..4ec84eb7 100644
--- a/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java
@@ -25,12 +25,17 @@
 import java.io.InputStream;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
+/**
+ * Tests {@link MarkShieldInputStream}.
+ */
 public class MarkShieldInputStreamTest {
 
     private static final class MarkTestableInputStream extends ProxyInputStream {
         int markcount;
-        int readlimit;
+        int readLimit;
 
         public MarkTestableInputStream(final InputStream in) {
             super(in);
@@ -38,46 +43,68 @@ public MarkTestableInputStream(final InputStream in) {
 
         @SuppressWarnings("sync-override")
         @Override
-        public void mark(final int readlimit) {
+        public void mark(final int readLimit) {
             // record that `mark` was called
             this.markcount++;
-            this.readlimit = readlimit;
-
+            this.readLimit = readLimit;
             // invoke on super
-            super.mark(readlimit);
+            super.mark(readLimit);
         }
     }
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterClose(final int len) throws Exception {
+        final InputStream shadow;
+        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(len, false, false));
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
+            assertEquals(len, in.available());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterOpen(final int len) throws Exception {
+        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(len, false, false));
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
+            assertEquals(len, in.available());
+        }
+    }
+
+    @SuppressWarnings("resource")
     @Test
-    public void markIsNoOpWhenUnderlyingDoesNotSupport() throws IOException {
-        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(64, false, false));
-             final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(new MarkShieldInputStream(new BrokenInputStream((Throwable) new IOException())));
+    }
 
+    @Test
+    public void testMarkIsNoOpWhenUnderlyingDoesNotSupport() throws IOException {
+        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(64, false, false));
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
             msis.mark(1024);
-
             assertEquals(0, in.markcount);
-            assertEquals(0, in.readlimit);
+            assertEquals(0, in.readLimit);
         }
     }
 
     @Test
-    public void markIsNoOpWhenUnderlyingSupports() throws IOException {
+    public void testMarkIsNoOpWhenUnderlyingSupports() throws IOException {
         try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(64, true, false));
-             final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
-
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
             msis.mark(1024);
-
             assertEquals(0, in.markcount);
-            assertEquals(0, in.readlimit);
+            assertEquals(0, in.readLimit);
         }
     }
 
     @Test
-    public void markSupportedIsFalseWhenUnderlyingFalse() throws IOException {
+    public void testMarkSupportedIsFalseWhenUnderlyingFalse() throws IOException {
         // test wrapping an underlying stream which does NOT support marking
         try (InputStream is = new NullInputStream(64, false, false)) {
             assertFalse(is.markSupported());
-
             try (MarkShieldInputStream msis = new MarkShieldInputStream(is)) {
                 assertFalse(msis.markSupported());
             }
@@ -85,31 +112,64 @@ public void markSupportedIsFalseWhenUnderlyingFalse() throws IOException {
     }
 
     @Test
-    public void markSupportedIsFalseWhenUnderlyingTrue() throws IOException {
+    public void testMarkSupportedIsFalseWhenUnderlyingTrue() throws IOException {
         // test wrapping an underlying stream which supports marking
         try (InputStream is = new NullInputStream(64, true, false)) {
             assertTrue(is.markSupported());
-
             try (MarkShieldInputStream msis = new MarkShieldInputStream(is)) {
                 assertFalse(msis.markSupported());
             }
         }
     }
 
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testReadAfterClose(final int len) throws Exception {
+        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(len, false, false));
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
+            assertEquals(len, in.available());
+            in.close();
+            assertThrows(IOException.class, in::read);
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testReadByteArrayAfterClose(final int len) throws Exception {
+        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(len, false, false));
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
+            assertEquals(len, in.available());
+            in.close();
+            assertEquals(0, in.read(new byte[0]));
+            assertThrows(IOException.class, () -> in.read(new byte[2]));
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testReadByteArrayIntIntAfterClose(final int len) throws Exception {
+        try (MarkTestableInputStream in = new MarkTestableInputStream(new NullInputStream(len, false, false));
+                final MarkShieldInputStream msis = new MarkShieldInputStream(in)) {
+            assertEquals(len, in.available());
+            in.close();
+            assertEquals(0, in.read(new byte[0], 0, 1));
+            assertEquals(0, in.read(new byte[1], 0, 0));
+            assertThrows(IOException.class, () -> in.read(new byte[2], 0, 1));
+        }
+    }
+
     @Test
-    public void resetThrowsExceptionWhenUnderlyingDoesNotSupport() throws IOException {
+    public void testResetThrowsExceptionWhenUnderlyingDoesNotSupport() throws IOException {
         // test wrapping an underlying stream which does NOT support marking
-        try (MarkShieldInputStream msis = new MarkShieldInputStream(
-                new NullInputStream(64, false, false))) {
+        try (MarkShieldInputStream msis = new MarkShieldInputStream(new NullInputStream(64, false, false))) {
             assertThrows(UnsupportedOperationException.class, msis::reset);
         }
     }
 
     @Test
-    public void resetThrowsExceptionWhenUnderlyingSupports() throws IOException {
+    public void testResetThrowsExceptionWhenUnderlyingSupports() throws IOException {
         // test wrapping an underlying stream which supports marking
-        try (MarkShieldInputStream msis = new MarkShieldInputStream(
-                new NullInputStream(64, true, false))) {
+        try (MarkShieldInputStream msis = new MarkShieldInputStream(new NullInputStream(64, true, false))) {
             assertThrows(UnsupportedOperationException.class, msis::reset);
         }
     }
diff --git a/src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java b/src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java
index a26b46a8..0687a820 100644
--- a/src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java
@@ -19,6 +19,7 @@
 import static org.apache.commons.lang3.ArrayUtils.EMPTY_BYTE_ARRAY;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,6 +34,7 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 import org.junit.jupiter.params.provider.ValueSource;
 
 /**
@@ -44,7 +46,7 @@ public class MemoryMappedFileInputStreamTest {
     Path tempDir;
 
     @AfterEach
-    void afterEach() {
+    public void afterEach() {
         // Ask to run the garbage collector to clean up memory mapped buffers,
         // otherwise the temporary files won't be able to be removed when running on
         // Windows. Calling gc() is just a hint to the VM.
@@ -62,71 +64,106 @@ private Path createTestFile(final int size) throws IOException {
         return Files.write(Files.createTempFile(tempDir, null, null), RandomUtils.nextBytes(size));
     }
 
-    private MemoryMappedFileInputStream newStream(final Path file) throws IOException {
+    private MemoryMappedFileInputStream newInputStream(final Path file) throws IOException {
         return MemoryMappedFileInputStream.builder().setPath(file).get();
     }
 
-    private MemoryMappedFileInputStream newStream(final Path file, final int bufferSize) throws IOException {
+    private MemoryMappedFileInputStream newInputStream(final Path file, final int bufferSize) throws IOException {
         return MemoryMappedFileInputStream.builder().setPath(file).setBufferSize(bufferSize).get();
     }
 
     @Test
-    void testAlternateBufferSize() throws IOException {
+    public void testAlternateBufferSize() throws IOException {
         // setup
         final Path file = createTestFile(1024 * 1024);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
-        try (InputStream inputStream = newStream(file, 1024)) {
+        try (InputStream inputStream = newInputStream(file, 1024)) {
             // verify
             assertArrayEquals(expectedData, IOUtils.toByteArray(inputStream));
         }
     }
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterClose(final int len) throws Exception {
+        final Path file = createTestFile(len);
+        final InputStream shadow;
+        try (InputStream inputStream = newInputStream(file, 1024)) {
+            // verify
+            assertEquals(0, inputStream.available());
+            shadow = inputStream;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterOpen(final int len) throws Exception {
+        final Path file = createTestFile(len);
+        try (InputStream inputStream = newInputStream(file, 1024)) {
+            // verify
+            assertEquals(0, inputStream.available());
+            inputStream.read();
+            assertEquals(Math.max(len - 1, 0), inputStream.available());
+            IOUtils.toByteArray(inputStream);
+            assertEquals(0, inputStream.available());
+        }
+    }
+
     @Test
-    void testEmptyFile() throws IOException {
+    public void testEmptyFile() throws IOException {
         // setup
         final Path file = createTestFile(0);
         // test
-        try (InputStream inputStream = newStream(file)) {
+        try (InputStream inputStream = newInputStream(file)) {
             // verify
             assertArrayEquals(EMPTY_BYTE_ARRAY, IOUtils.toByteArray(inputStream));
         }
     }
 
     @Test
-    void testLargerFile() throws IOException {
+    public void testLargerFile() throws IOException {
         // setup
         final Path file = createTestFile(1024 * 1024);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
-        try (InputStream inputStream = newStream(file)) {
+        try (InputStream inputStream = newInputStream(file)) {
             // verify
             assertArrayEquals(expectedData, IOUtils.toByteArray(inputStream));
         }
     }
 
     @Test
-    void testReadAfterClose() throws IOException {
+    public void testReadAfterClose() throws IOException {
         // setup
         final Path file = createTestFile(1 * 1024 * 1024);
-
         // test
-        try (InputStream inputStream = newStream(file, 1024)) {
+        try (InputStream inputStream = newInputStream(file, 1024)) {
             inputStream.close();
             // verify
             Assertions.assertThrows(IOException.class, () -> IOUtils.toByteArray(inputStream));
         }
     }
 
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testReadAfterClose(final int len) throws Exception {
+        final Path file = createTestFile(len);
+        try (InputStream inputStream = newInputStream(file, 1024)) {
+            inputStream.close();
+            assertThrows(IOException.class, inputStream::read);
+        }
+    }
+
     @Test
-    void testReadSingleByte() throws IOException {
+    public void testReadSingleByte() throws IOException {
         // setup
         final Path file = createTestFile(2);
         final byte[] expectedData = Files.readAllBytes(file);
         // test
-        try (InputStream inputStream = newStream(file, 1024)) {
+        try (InputStream inputStream = newInputStream(file, 1024)) {
             final int b1 = inputStream.read();
             final int b2 = inputStream.read();
             assertEquals(-1, inputStream.read());
@@ -136,13 +173,12 @@ void testReadSingleByte() throws IOException {
     }
 
     @Test
-    void testSkipAtStart() throws IOException {
+    public void testSkipAtStart() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
-        try (InputStream inputStream = newStream(file, 10)) {
+        try (InputStream inputStream = newInputStream(file, 10)) {
             assertEquals(1, inputStream.skip(1));
             final byte[] data = IOUtils.toByteArray(inputStream);
             // verify
@@ -151,11 +187,11 @@ void testSkipAtStart() throws IOException {
     }
 
     @Test
-    void testSkipEmpty() throws IOException {
+    public void testSkipEmpty() throws IOException {
         // setup
         final Path file = createTestFile(0);
         // test
-        try (InputStream inputStream = newStream(file)) {
+        try (InputStream inputStream = newInputStream(file)) {
             assertEquals(0, inputStream.skip(5));
             // verify
             assertArrayEquals(EMPTY_BYTE_ARRAY, IOUtils.toByteArray(inputStream));
@@ -163,13 +199,12 @@ void testSkipEmpty() throws IOException {
     }
 
     @Test
-    void testSkipInCurrentBuffer() throws IOException {
+    public void testSkipInCurrentBuffer() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
-        try (InputStream inputStream = newStream(file, 10)) {
+        try (InputStream inputStream = newInputStream(file, 10)) {
             IOUtils.toByteArray(inputStream, 5);
             assertEquals(3, inputStream.skip(3));
             final byte[] data = IOUtils.toByteArray(inputStream);
@@ -180,12 +215,12 @@ void testSkipInCurrentBuffer() throws IOException {
 
     @ParameterizedTest
     @ValueSource(ints = {-5, -1, 0})
-    void testSkipNoop(final int amountToSkip) throws IOException {
+    public void testSkipNoop(final int amountToSkip) throws IOException {
         // setup
         final Path file = createTestFile(10);
         final byte[] expectedData = Files.readAllBytes(file);
         // test
-        try (InputStream inputStream = newStream(file)) {
+        try (InputStream inputStream = newInputStream(file)) {
             assertEquals(0, inputStream.skip(amountToSkip));
             // verify
             assertArrayEquals(expectedData, IOUtils.toByteArray(inputStream));
@@ -193,13 +228,12 @@ void testSkipNoop(final int amountToSkip) throws IOException {
     }
 
     @Test
-    void testSkipOutOfCurrentBuffer() throws IOException {
+    public void testSkipOutOfCurrentBuffer() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
-        try (InputStream inputStream = newStream(file, 10)) {
+        try (InputStream inputStream = newInputStream(file, 10)) {
             IOUtils.toByteArray(inputStream, 5);
             assertEquals(6, inputStream.skip(6));
             final byte[] data = IOUtils.toByteArray(inputStream);
@@ -209,12 +243,11 @@ void testSkipOutOfCurrentBuffer() throws IOException {
     }
 
     @Test
-    void testSkipPastEof() throws IOException {
+    public void testSkipPastEof() throws IOException {
         // setup
         final Path file = createTestFile(100);
-
         // test
-        try (InputStream inputStream = newStream(file, 10)) {
+        try (InputStream inputStream = newInputStream(file, 10)) {
             IOUtils.toByteArray(inputStream, 5);
             assertEquals(95, inputStream.skip(96));
             // verify
@@ -223,13 +256,13 @@ void testSkipPastEof() throws IOException {
     }
 
     @Test
-    void testSkipToEndOfCurrentBuffer() throws IOException {
+    public void testSkipToEndOfCurrentBuffer() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
 
         // test
-        try (InputStream inputStream = newStream(file, 10)) {
+        try (InputStream inputStream = newInputStream(file, 10)) {
             IOUtils.toByteArray(inputStream, 5);
             assertEquals(5, inputStream.skip(5));
             final byte[] data = IOUtils.toByteArray(inputStream);
@@ -239,11 +272,10 @@ void testSkipToEndOfCurrentBuffer() throws IOException {
     }
 
     @Test
-    void testSkipToEndOfCurrentBufferBuilder() throws IOException {
+    public void testSkipToEndOfCurrentBufferBuilder() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
         try (MemoryMappedFileInputStream inputStream = MemoryMappedFileInputStream.builder().setPath(file).setBufferSize(10).get()) {
             assertEquals(10, inputStream.getBufferSize());
@@ -256,11 +288,10 @@ void testSkipToEndOfCurrentBufferBuilder() throws IOException {
     }
 
     @Test
-    void testSmallFileBuilder() throws IOException {
+    public void testSmallFileBuilder() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
         try (InputStream inputStream = MemoryMappedFileInputStream.builder().setFile(file.toFile()).get()) {
             // verify
@@ -269,24 +300,23 @@ void testSmallFileBuilder() throws IOException {
     }
 
     @Test
-    void testSmallPath() throws IOException {
+    public void testSmallPath() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
 
         // test
-        try (InputStream inputStream = newStream(file)) {
+        try (InputStream inputStream = newInputStream(file)) {
             // verify
             assertArrayEquals(expectedData, IOUtils.toByteArray(inputStream));
         }
     }
 
     @Test
-    void testSmallPathBuilder() throws IOException {
+    public void testSmallPathBuilder() throws IOException {
         // setup
         final Path file = createTestFile(100);
         final byte[] expectedData = Files.readAllBytes(file);
-
         // test
         try (InputStream inputStream = MemoryMappedFileInputStream.builder().setPath(file).get()) {
             // verify
diff --git a/src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java b/src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java
index 9123c41f..5226980f 100644
--- a/src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java
@@ -17,13 +17,26 @@
 package org.apache.commons.io.input;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.security.MessageDigest;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.commons.codec.digest.DigestUtils;
 import org.apache.commons.codec.digest.MessageDigestAlgorithms;
+import org.apache.commons.io.IOExceptionList;
+import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.input.MessageDigestCalculatingInputStream.Builder;
+import org.apache.commons.io.test.CustomIOException;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -32,9 +45,69 @@
 @SuppressWarnings("deprecation")
 public class MessageDigestCalculatingInputStreamTest {
 
+    private InputStream createInputStream() throws IOException {
+        final ByteArrayInputStream origin = new ByteArrayInputStream(MessageDigestInputStreamTest.generateRandomByteStream(256));
+        return createInputStream(origin);
+    }
+
+    private MessageDigestCalculatingInputStream createInputStream(final InputStream origin) throws IOException {
+        return MessageDigestCalculatingInputStream.builder().setInputStream(origin).get();
+    }
+
+    @Test
+    public void testAfterReadConsumer() throws Exception {
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = MessageDigestCalculatingInputStream.builder()
+                .setCharSequence("Hi")
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = MessageDigestCalculatingInputStream.builder()
+                .setCharSequence("Hi")
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertTrue(assertThrowsExactly(IOExceptionList.class, () -> IOUtils.consume(bounded)).getMessage().contains(message));
+        }
+        // @formatter:on
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            assertNotEquals(IOUtils.EOF, in.read());
+            assertTrue(in.available() > 0);
+        }
+    }
+
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(MessageDigestCalculatingInputStream.builder());
+    }
+
     @Test
     public void testNormalUse() throws Exception {
-        for (int i = 256; i < 8192; i = i * 2) {
+        for (int i = 256; i < 8192; i *= 2) {
             final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(i);
             final MessageDigest defaultMessageDigest = MessageDigestCalculatingInputStream.getDefaultMessageDigest();
             final byte[] defaultExpect = defaultMessageDigest.digest(buffer);
@@ -75,4 +148,23 @@ public void testNormalUse() throws Exception {
         }
     }
 
+    @Test
+    public void testReadAfterClose_ByteArrayInputStream() throws Exception {
+        try (InputStream in = createInputStream()) {
+            in.close();
+            // ByteArrayInputStream does not throw on a closed stream.
+            assertNotEquals(IOUtils.EOF, in.read());
+        }
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testReadAfterClose_ChannelInputStream() throws Exception {
+        try (InputStream in = createInputStream(Files.newInputStream(Paths.get("src/test/resources/org/apache/commons/io/abitmorethan16k.txt")))) {
+            in.close();
+            // ChannelInputStream throws when closed
+            assertThrows(IOException.class, in::read);
+        }
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/MessageDigestInputStreamTest.java b/src/test/java/org/apache/commons/io/input/MessageDigestInputStreamTest.java
index d41da0b7..94ca431a 100644
--- a/src/test/java/org/apache/commons/io/input/MessageDigestInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/MessageDigestInputStreamTest.java
@@ -17,13 +17,27 @@
 package org.apache.commons.io.input;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.Random;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.commons.codec.digest.DigestUtils;
 import org.apache.commons.codec.digest.MessageDigestAlgorithms;
+import org.apache.commons.io.IOExceptionList;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.test.CustomIOException;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -38,15 +52,78 @@ static byte[] generateRandomByteStream(final int pSize) {
         return buffer;
     }
 
+    private InputStream createInputStream() throws IOException, NoSuchAlgorithmException {
+        return createInputStream(new ByteArrayInputStream(MessageDigestInputStreamTest.generateRandomByteStream(256)));
+    }
+
+    private InputStream createInputStream(final InputStream origin) throws IOException, NoSuchAlgorithmException {
+        // @formatter:off
+        return MessageDigestInputStream.builder()
+                .setMessageDigest(MessageDigest.getInstance(MessageDigestAlgorithms.SHA_512))
+                .setInputStream(origin)
+                .get();
+        // @formatter:on
+    }
+
+    @Test
+    public void testAfterReadConsumer() throws Exception {
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = MessageDigestInputStream.builder()
+                .setMessageDigest(MessageDigest.getInstance(MessageDigestAlgorithms.SHA_512))
+                .setCharSequence("Hi")
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = MessageDigestInputStream.builder()
+                .setMessageDigest(MessageDigest.getInstance(MessageDigestAlgorithms.SHA_512))
+                .setCharSequence("Hi")
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertTrue(assertThrowsExactly(IOExceptionList.class, () -> IOUtils.consume(bounded)).getMessage().contains(message));
+        }
+        // @formatter:on
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            assertNotEquals(IOUtils.EOF, in.read());
+            assertTrue(in.available() > 0);
+        }
+    }
+
     @Test
     public void testNoDefault() throws Exception {
-        assertThrows(IllegalStateException.class, () -> MessageDigestInputStream.builder().get());
+        // No default by design, call MUST set a message digest
+        // Fail-fast, no need to try to process any input origin
+        assertThrows(NullPointerException.class, () -> MessageDigestInputStream.builder().get());
         assertThrows(NullPointerException.class, () -> MessageDigestInputStream.builder().setInputStream(new ByteArrayInputStream(new byte[] { 1 })).get());
     }
 
     @Test
     public void testNormalUse() throws Exception {
-        for (int i = 256; i < 8192; i = i * 2) {
+        for (int i = 256; i < 8192; i *= 2) {
             final byte[] buffer = generateRandomByteStream(i);
             final byte[] expect = DigestUtils.sha512(buffer);
             try (MessageDigestInputStream messageDigestInputStream = MessageDigestInputStream.builder().setMessageDigest(MessageDigestAlgorithms.SHA_512)
@@ -62,4 +139,22 @@ public void testNormalUse() throws Exception {
         }
     }
 
+    @Test
+    public void testReadAfterClose_ByteArrayInputStream() throws Exception {
+        try (InputStream in = createInputStream()) {
+            in.close();
+            assertNotEquals(IOUtils.EOF, in.read());
+        }
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testReadAfterClose_ChannelInputStream() throws Exception {
+        try (InputStream in = createInputStream(Files.newInputStream(Paths.get("src/test/resources/org/apache/commons/io/abitmorethan16k.txt")))) {
+            in.close();
+            // ChannelInputStream throws when closed
+            assertThrows(IOException.class, in::read);
+        }
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java b/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java
index 219c5308..2f196cb2 100644
--- a/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java
@@ -18,6 +18,7 @@
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -26,6 +27,9 @@
 import java.io.InputStream;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.junit.platform.commons.util.StringUtils;
 
 /**
  * Tests {@link NullInputStream}.
@@ -33,29 +37,59 @@
 public class NullInputStreamTest {
 
     private static final class TestNullInputStream extends NullInputStream {
+
         public TestNullInputStream(final int size) {
             super(size);
         }
+
         public TestNullInputStream(final int size, final boolean markSupported, final boolean throwEofException) {
             super(size, markSupported, throwEofException);
         }
+
         @Override
         protected int processByte() {
-            return (int)getPosition() - 1;
+            return (int) getPosition() - 1;
         }
+
         @Override
         protected void processBytes(final byte[] bytes, final int offset, final int length) {
-            final int startPos = (int)getPosition() - length;
+            final int startPos = (int) getPosition() - length;
             for (int i = offset; i < length; i++) {
-                bytes[i] = (byte)(startPos + i);
+                bytes[i] = (byte) (startPos + i);
             }
         }
 
     }
 
-    // Use the same message as in java.io.InputStream.reset() in OpenJDK 8.0.275-1.
+    /** Use the same message as in java.io.InputStream.reset() in OpenJDK 8.0.275-1. */
     private static final String MARK_RESET_NOT_SUPPORTED = "mark/reset not supported";
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterClose(final int len) throws Exception {
+        final InputStream shadow;
+        try (InputStream in = new TestNullInputStream(len, false, false)) {
+            assertEquals(len, in.available());
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testAvailableAfterOpen(final int len) throws Exception {
+        try (InputStream in = new TestNullInputStream(len, false, false)) {
+            assertEquals(len, in.available());
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    @Test
+    public void testDeprecatedSingleton() throws Exception {
+        assertNotNull(NullInputStream.INSTANCE);
+    }
+
     @Test
     public void testEOFException() throws Exception {
         try (InputStream input = new TestNullInputStream(2, false, true)) {
@@ -68,7 +102,7 @@ public void testEOFException() throws Exception {
     @Test
     public void testMarkAndReset() throws Exception {
         int position = 0;
-        final int readlimit = 10;
+        final int readLimit = 10;
         try (InputStream input = new TestNullInputStream(100, true, false)) {
 
             assertTrue(input.markSupported(), "Mark Should be Supported");
@@ -82,7 +116,7 @@ public void testMarkAndReset() throws Exception {
             }
 
             // Mark
-            input.mark(readlimit);
+            input.mark(readLimit);
 
             // Read further
             for (int i = 0; i < 3; i++) {
@@ -93,105 +127,226 @@ public void testMarkAndReset() throws Exception {
             input.reset();
 
             // Read From marked position
-            for (int i = 0; i < readlimit + 1; i++) {
+            for (int i = 0; i < readLimit + 1; i++) {
                 assertEquals(position + i, input.read(), "Read After Reset [" + i + "]");
             }
 
             // Reset after read limit passed
             final IOException resetException = assertThrows(IOException.class, input::reset, "Read limit exceeded, expected IOException");
-            assertEquals("Marked position [" + position + "] is no longer valid - passed the read limit [" + readlimit + "]", resetException.getMessage(),
+            assertEquals("Marked position [" + position + "] is no longer valid - passed the read limit [" + readLimit + "]", resetException.getMessage(),
                     "Read limit IOException message");
         }
     }
 
     @Test
     public void testMarkNotSupported() throws Exception {
-        final InputStream input = new TestNullInputStream(100, false, true);
-        assertFalse(input.markSupported(), "Mark Should NOT be Supported");
+        try (InputStream input = new TestNullInputStream(100, false, true)) {
+            assertFalse(input.markSupported(), "Mark Should NOT be Supported");
 
-        final UnsupportedOperationException markException = assertThrows(UnsupportedOperationException.class, () -> input.mark(5));
-        assertEquals(MARK_RESET_NOT_SUPPORTED, markException.getMessage(), "mark() error message");
+            final UnsupportedOperationException markException = assertThrows(UnsupportedOperationException.class, () -> input.mark(5));
+            assertEquals(MARK_RESET_NOT_SUPPORTED, markException.getMessage(), "mark() error message");
 
-        final UnsupportedOperationException resetException = assertThrows(UnsupportedOperationException.class, input::reset);
-        assertEquals(MARK_RESET_NOT_SUPPORTED, resetException.getMessage(), "reset() error message");
-        input.close();
+            final UnsupportedOperationException resetException = assertThrows(UnsupportedOperationException.class, input::reset);
+            assertEquals(MARK_RESET_NOT_SUPPORTED, resetException.getMessage(), "reset() error message");
+        }
     }
 
     @Test
     public void testRead() throws Exception {
         final int size = 5;
-        final InputStream input = new TestNullInputStream(size);
-        for (int i = 0; i < size; i++) {
-            assertEquals(size - i, input.available(), "Check Size [" + i + "]");
-            assertEquals(i, input.read(), "Check Value [" + i + "]");
-        }
-        assertEquals(0, input.available(), "Available after contents all read");
+        try (InputStream input = new TestNullInputStream(size)) {
+            for (int i = 0; i < size; i++) {
+                assertEquals(size - i, input.available(), "Check Size [" + i + "]");
+                assertEquals(i, input.read(), "Check Value [" + i + "]");
+            }
+            assertEquals(0, input.available(), "Available after contents all read");
 
-        // Check available is zero after End of file
-        assertEquals(-1, input.read(), "End of File");
-        assertEquals(0, input.available(), "Available after End of File");
+            // Check available is zero after End of file
+            assertEquals(-1, input.read(), "End of File");
+            assertEquals(0, input.available(), "Available after End of File");
 
-        // Test reading after the end of file
-        final IOException e = assertThrows(IOException.class, input::read);
-        assertEquals("Read after end of file", e.getMessage());
+            // Test reading after the end of file
+            assertEquals(-1, input.read(), "End of File");
 
-        // Close - should reset
-        input.close();
-        assertEquals(size, input.available(), "Available after close");
+            // Close
+            input.close();
+            assertEquals(0, input.available(), "Available after close");
+        }
+    }
+
+    @Test
+    public void testReadAfterClose() throws Exception {
+        try (InputStream in = new NullInputStream()) {
+            assertEquals(0, in.available());
+            in.close();
+            assertThrows(IOException.class, in::read);
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(AbstractInputStreamTest.ARRAY_LENGTHS_NAME)
+    public void testReadAfterClose(final int len) throws Exception {
+        try (InputStream in = new TestNullInputStream(len, false, false)) {
+            assertEquals(len, in.available());
+            in.close();
+            assertThrows(IOException.class, in::read);
+        }
     }
 
     @Test
     public void testReadByteArray() throws Exception {
         final byte[] bytes = new byte[10];
-        final InputStream input = new TestNullInputStream(15);
+        try (NullInputStream input = new TestNullInputStream(15)) {
+
+            // Read into array
+            final int count1 = input.read(bytes);
+            assertEquals(bytes.length, count1, "Read 1");
+            for (int i = 0; i < count1; i++) {
+                assertEquals(i, bytes[i], "Check Bytes 1");
+            }
+
+            // Read into array
+            final int count2 = input.read(bytes);
+            assertEquals(5, count2, "Read 2");
+            for (int i = 0; i < count2; i++) {
+                assertEquals(count1 + i, bytes[i], "Check Bytes 2");
+            }
+
+            // End of File
+            final int count3 = input.read(bytes);
+            assertEquals(-1, count3, "Read 3 (EOF)");
 
-        // Read into array
-        final int count1 = input.read(bytes);
-        assertEquals(bytes.length, count1, "Read 1");
-        for (int i = 0; i < count1; i++) {
-            assertEquals(i, bytes[i], "Check Bytes 1");
+            // Test reading after the end of file
+            final int count4 = input.read(bytes);
+            assertEquals(-1, count4, "Read 4 (EOF)");
+
+            // re-init
+            input.init();
+
+            // Read into array using offset & length
+            final int offset = 2;
+            final int len = 4;
+            final int count5 = input.read(bytes, offset, len);
+            assertEquals(len, count5, "Read 5");
+            for (int i = offset; i < len; i++) {
+                assertEquals(i, bytes[i], "Check Bytes 2");
+            }
         }
+    }
 
-        // Read into array
-        final int count2 = input.read(bytes);
-        assertEquals(5, count2, "Read 2");
-        for (int i = 0; i < count2; i++) {
-            assertEquals(count1 + i, bytes[i], "Check Bytes 2");
+    @Test
+    public void testReadByteArrayAfterClose() throws Exception {
+        try (InputStream in = new NullInputStream()) {
+            assertEquals(0, in.available());
+            in.close();
+            assertEquals(0, in.read(new byte[0]));
+            assertThrows(IOException.class, () -> in.read(new byte[2]));
+        }
+    }
+
+    @Test
+    public void testReadByteArrayIntIntAfterClose() throws Exception {
+        try (InputStream in = new NullInputStream()) {
+            assertEquals(0, in.available());
+            in.close();
+            assertEquals(0, in.read(new byte[0], 0, 1));
+            assertEquals(0, in.read(new byte[1], 0, 0));
+            assertThrows(IOException.class, () -> in.read(new byte[2], 0, 1));
+        }
+    }
+
+    @Test
+    public void testReadByteArrayThrowAtEof() throws Exception {
+        final byte[] bytes = new byte[10];
+        try (NullInputStream input = new TestNullInputStream(15, true, true)) {
+
+            // Read into array
+            final int count1 = input.read(bytes);
+            assertEquals(bytes.length, count1, "Read 1");
+            for (int i = 0; i < count1; i++) {
+                assertEquals(i, bytes[i], "Check Bytes 1");
+            }
+
+            // Read into array
+            final int count2 = input.read(bytes);
+            assertEquals(5, count2, "Read 2");
+            for (int i = 0; i < count2; i++) {
+                assertEquals(count1 + i, bytes[i], "Check Bytes 2");
+            }
+
+            // End of File
+            final IOException e1 = assertThrows(EOFException.class, () -> input.read(bytes));
+            assertTrue(StringUtils.isNotBlank(e1.getMessage()));
+
+            // Test reading after the end of file
+            final IOException e2 = assertThrows(EOFException.class, () -> input.read(bytes));
+            assertTrue(StringUtils.isNotBlank(e2.getMessage()));
+
+            // reset by closing
+            input.init();
+
+            // Read into array using offset & length
+            final int offset = 2;
+            final int len = 4;
+            final int count5 = input.read(bytes, offset, len);
+            assertEquals(len, count5, "Read 5");
+            for (int i = offset; i < len; i++) {
+                assertEquals(i, bytes[i], "Check Bytes 2");
+            }
         }
+    }
 
-        // End of File
-        final int count3 = input.read(bytes);
-        assertEquals(-1, count3, "Read 3 (EOF)");
+    @Test
+    public void testReadThrowAtEof() throws Exception {
+        final int size = 5;
+        try (InputStream input = new TestNullInputStream(size, true, true)) {
+            for (int i = 0; i < size; i++) {
+                assertEquals(size - i, input.available(), "Check Size [" + i + "]");
+                assertEquals(i, input.read(), "Check Value [" + i + "]");
+            }
+            assertEquals(0, input.available(), "Available after contents all read");
 
-        // Test reading after the end of file
-        final IOException e = assertThrows(IOException.class, () -> input.read(bytes));
-        assertEquals("Read after end of file", e.getMessage());
+            // Check available is zero after End of file
+            final IOException e1 = assertThrows(EOFException.class, input::read);
+            assertTrue(StringUtils.isNotBlank(e1.getMessage()));
 
-        // reset by closing
-        input.close();
+            // Test reading after the end of file
+            final IOException e2 = assertThrows(EOFException.class, input::read);
+            assertTrue(StringUtils.isNotBlank(e2.getMessage()));
 
-        // Read into array using offset & length
-        final int offset = 2;
-        final int lth    = 4;
-        final int count5 = input.read(bytes, offset, lth);
-        assertEquals(lth, count5, "Read 5");
-        for (int i = offset; i < lth; i++) {
-            assertEquals(i, bytes[i], "Check Bytes 2");
+            // Close
+            input.close();
+            assertEquals(0, input.available(), "Available after close");
         }
     }
 
     @Test
     public void testSkip() throws Exception {
-        final InputStream input = new TestNullInputStream(10, true, false);
-        assertEquals(0, input.read(), "Read 1");
-        assertEquals(1, input.read(), "Read 2");
-        assertEquals(5, input.skip(5), "Skip 1");
-        assertEquals(7, input.read(), "Read 3");
-        assertEquals(2, input.skip(5), "Skip 2"); // only 2 left to skip
-        assertEquals(-1, input.skip(5), "Skip 3 (EOF)"); // End of file
-
-        final IOException e = assertThrows(IOException.class, () -> input.skip(5), "Expected IOException for skipping after end of file");
-        assertEquals("Skip after end of file", e.getMessage(), "Skip after EOF IOException message");
-        input.close();
+        try (InputStream input = new TestNullInputStream(10, true, false)) {
+            assertEquals(0, input.read(), "Read 1");
+            assertEquals(1, input.read(), "Read 2");
+            assertEquals(5, input.skip(5), "Skip 1");
+            assertEquals(7, input.read(), "Read 3");
+            assertEquals(2, input.skip(5), "Skip 2"); // only 2 left to skip
+            assertEquals(-1, input.skip(5), "Skip 3 (EOF)"); // End of file
+            assertEquals(-1, input.skip(5), "Skip 3 (EOF)"); // End of file
+        }
+    }
+
+    @Test
+    public void testSkipThrowAtEof() throws Exception {
+        try (InputStream input = new TestNullInputStream(10, true, true)) {
+            assertEquals(0, input.read(), "Read 1");
+            assertEquals(1, input.read(), "Read 2");
+            assertEquals(5, input.skip(5), "Skip 1");
+            assertEquals(7, input.read(), "Read 3");
+            assertEquals(2, input.skip(5), "Skip 2"); // only 2 left to skip
+            // End of File
+            final IOException e1 = assertThrows(EOFException.class, () -> input.skip(5), "Skip 3 (EOF)");
+            assertTrue(StringUtils.isNotBlank(e1.getMessage()));
+
+            final IOException e2 = assertThrows(IOException.class, () -> input.skip(5), "Expected IOException for skipping after end of file");
+            assertTrue(StringUtils.isNotBlank(e2.getMessage()));
+        }
     }
 }
diff --git a/src/test/java/org/apache/commons/io/input/NullReaderTest.java b/src/test/java/org/apache/commons/io/input/NullReaderTest.java
index 236a0f95..08a80325 100644
--- a/src/test/java/org/apache/commons/io/input/NullReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/NullReaderTest.java
@@ -37,18 +37,21 @@ private static final class TestNullReader extends NullReader {
         public TestNullReader(final int size) {
             super(size);
         }
+
         public TestNullReader(final int size, final boolean markSupported, final boolean throwEofException) {
             super(size, markSupported, throwEofException);
         }
+
         @Override
         protected int processChar() {
-            return (int)getPosition() - 1;
+            return (int) getPosition() - 1;
         }
+
         @Override
         protected void processChars(final char[] chars, final int offset, final int length) {
-            final int startPos = (int)getPosition() - length;
+            final int startPos = (int) getPosition() - length;
             for (int i = offset; i < length; i++) {
-                chars[i] = (char)(startPos + i);
+                chars[i] = (char) (startPos + i);
             }
         }
 
@@ -69,7 +72,7 @@ public void testEOFException() throws Exception {
     @Test
     public void testMarkAndReset() throws Exception {
         int position = 0;
-        final int readlimit = 10;
+        final int readLimit = 10;
         try (Reader reader = new TestNullReader(100, true, false)) {
 
             assertTrue(reader.markSupported(), "Mark Should be Supported");
@@ -83,7 +86,7 @@ public void testMarkAndReset() throws Exception {
             }
 
             // Mark
-            reader.mark(readlimit);
+            reader.mark(readLimit);
 
             // Read further
             for (int i = 0; i < 3; i++) {
@@ -94,13 +97,13 @@ public void testMarkAndReset() throws Exception {
             reader.reset();
 
             // Read From marked position
-            for (int i = 0; i < readlimit + 1; i++) {
+            for (int i = 0; i < readLimit + 1; i++) {
                 assertEquals(position + i, reader.read(), "Read After Reset [" + i + "]");
             }
 
             // Reset after read limit passed
             final IOException e = assertThrows(IOException.class, reader::reset);
-            assertEquals("Marked position [" + position + "] is no longer valid - passed the read limit [" + readlimit + "]", e.getMessage(),
+            assertEquals("Marked position [" + position + "] is no longer valid - passed the read limit [" + readLimit + "]", e.getMessage(),
                     "Read limit IOException message");
         }
     }
diff --git a/src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java
index 8c099ade..d5bb39dd 100644
--- a/src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java
@@ -20,14 +20,20 @@
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.input.ObservableInputStream.Observer;
 import org.apache.commons.io.output.NullOutputStream;
+import org.apache.commons.io.test.CustomIOException;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -127,23 +133,82 @@ public long getFinishedCount() {
 
     }
 
+    private ObservableInputStream brokenObservableInputStream() {
+        return new ObservableInputStream(BrokenInputStream.INSTANCE);
+    }
+
+    private InputStream createInputStream() {
+        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);
+        return createInputStream(new ByteArrayInputStream(buffer));
+    }
+
+    private ObservableInputStream createInputStream(final InputStream origin) {
+        return new ObservableInputStream(origin);
+    }
+
+    @Test
+    public void testAfterReadConsumer() throws Exception {
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = new ObservableInputStream.Builder()
+                .setCharSequence("Hi")
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = new ObservableInputStream.Builder()
+                .setCharSequence("Hi")
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws Exception {
+        final InputStream shadow;
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            shadow = in;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws Exception {
+        try (InputStream in = createInputStream()) {
+            assertTrue(in.available() > 0);
+            assertNotEquals(IOUtils.EOF, in.read());
+            assertTrue(in.available() > 0);
+        }
+    }
+
     @Test
     public void testBrokenInputStreamRead() throws IOException {
-        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {
+        try (ObservableInputStream ois = brokenObservableInputStream()) {
             assertThrows(IOException.class, ois::read);
         }
     }
 
     @Test
     public void testBrokenInputStreamReadBuffer() throws IOException {
-        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {
+        try (ObservableInputStream ois = brokenObservableInputStream()) {
             assertThrows(IOException.class, () -> ois.read(new byte[1]));
         }
     }
 
     @Test
     public void testBrokenInputStreamReadSubBuffer() throws IOException {
-        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {
+        try (ObservableInputStream ois = brokenObservableInputStream()) {
             assertThrows(IOException.class, () -> ois.read(new byte[2], 0, 1));
         }
     }
@@ -216,7 +281,7 @@ public void testDataByteCalled_ctor() throws Exception {
     public void testDataBytesCalled() throws Exception {
         final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);
         try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);
-                final ObservableInputStream ois = new ObservableInputStream(bais)) {
+                final ObservableInputStream ois = createInputStream(bais)) {
             final DataViewObserver observer = new DataViewObserver();
             final byte[] readBuffer = new byte[23];
             assertNull(observer.buffer);
@@ -250,7 +315,7 @@ public void testDataBytesCalled() throws Exception {
 
     @Test
     public void testGetObservers0() throws IOException {
-        try (ObservableInputStream ois = new ObservableInputStream(NullInputStream.INSTANCE)) {
+        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream())) {
             assertTrue(ois.getObservers().isEmpty());
         }
     }
@@ -258,7 +323,7 @@ public void testGetObservers0() throws IOException {
     @Test
     public void testGetObservers1() throws IOException {
         final DataViewObserver observer0 = new DataViewObserver();
-        try (ObservableInputStream ois = new ObservableInputStream(NullInputStream.INSTANCE, observer0)) {
+        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0)) {
             assertEquals(observer0, ois.getObservers().get(0));
         }
     }
@@ -267,7 +332,7 @@ public void testGetObservers1() throws IOException {
     public void testGetObserversOrder() throws IOException {
         final DataViewObserver observer0 = new DataViewObserver();
         final DataViewObserver observer1 = new DataViewObserver();
-        try (ObservableInputStream ois = new ObservableInputStream(NullInputStream.INSTANCE, observer0, observer1)) {
+        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0, observer1)) {
             assertEquals(observer0, ois.getObservers().get(0));
             assertEquals(observer1, ois.getObservers().get(1));
         }
@@ -277,10 +342,8 @@ private void testNotificationCallbacks(final int bufferSize) throws IOException
         final byte[] buffer = IOUtils.byteArray();
         final LengthObserver lengthObserver = new LengthObserver();
         final MethodCountObserver methodCountObserver = new MethodCountObserver();
-        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer),
-            lengthObserver, methodCountObserver)) {
-            assertEquals(IOUtils.DEFAULT_BUFFER_SIZE,
-                IOUtils.copy(ois, NullOutputStream.INSTANCE, bufferSize));
+        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer), lengthObserver, methodCountObserver)) {
+            assertEquals(IOUtils.DEFAULT_BUFFER_SIZE, IOUtils.copy(ois, NullOutputStream.INSTANCE, bufferSize));
         }
         assertEquals(IOUtils.DEFAULT_BUFFER_SIZE, lengthObserver.getTotal());
         assertEquals(1, methodCountObserver.getClosedCount());
@@ -304,4 +367,23 @@ public void testNotificationCallbacksBufferSize2() throws Exception {
     public void testNotificationCallbacksBufferSizeDefault() throws Exception {
         testNotificationCallbacks(IOUtils.DEFAULT_BUFFER_SIZE);
     }
+
+    @Test
+    public void testReadAfterClose_ByteArrayInputStream() throws Exception {
+        try (InputStream in = createInputStream()) {
+            in.close();
+            assertNotEquals(IOUtils.EOF, in.read());
+        }
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testReadAfterClose_ChannelInputStream() throws Exception {
+        try (InputStream in = createInputStream(Files.newInputStream(Paths.get("src/test/resources/org/apache/commons/io/abitmorethan16k.txt")))) {
+            in.close();
+            // ChannelInputStream throws when closed
+            assertThrows(IOException.class, in::read);
+        }
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/ProxyInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ProxyInputStreamTest.java
new file mode 100644
index 00000000..2b5ba176
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/input/ProxyInputStreamTest.java
@@ -0,0 +1,358 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUProxyInputStreamFixture WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.build.AbstractStreamBuilder;
+import org.apache.commons.io.test.CustomIOException;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link ProxyInputStream}.
+ *
+ * @param <T> The actual type tested.
+ */
+public class ProxyInputStreamTest<T extends ProxyInputStream> {
+
+    private static final class ProxyInputStreamFixture extends ProxyInputStream {
+
+        static class Builder extends ProxyInputStream.AbstractBuilder<ProxyInputStreamFixture, Builder> {
+
+            @Override
+            public ProxyInputStreamFixture get() throws IOException {
+                return new ProxyInputStreamFixture(this);
+            }
+
+        }
+
+        static Builder builder() {
+            return new Builder();
+        }
+
+        ProxyInputStreamFixture(final Builder builder) throws IOException {
+            super(builder);
+        }
+
+        ProxyInputStreamFixture(final InputStream proxy) {
+            super(proxy);
+        }
+    }
+
+    @SuppressWarnings("resource")
+    static <T, B extends AbstractStreamBuilder<T, B>> void testCloseHandleIOException(final AbstractStreamBuilder<T, B> builder) throws IOException {
+        final IOException exception = new IOException();
+        testCloseHandleIOException((ProxyInputStream) builder.setInputStream(new BrokenInputStream(() -> exception)).get());
+    }
+
+    @SuppressWarnings("resource")
+    static void testCloseHandleIOException(final ProxyInputStream inputStream) throws IOException {
+        assertFalse(inputStream.isClosed(), "closed");
+        final ProxyInputStream spy = spy(inputStream);
+        assertThrows(IOException.class, spy::close);
+        final BrokenInputStream unwrap = (BrokenInputStream) inputStream.unwrap();
+        verify(spy).handleIOException((IOException) unwrap.getThrowable());
+        assertFalse(spy.isClosed(), "closed");
+    }
+
+    /**
+     * Asserts that a ProxyInputStream's markSupported() equals the proxied value.
+     *
+     * @param inputStream The stream to test.
+     */
+    @SuppressWarnings("resource") // unwrap() is a getter
+    protected void assertMarkSupportedEquals(final ProxyInputStream inputStream) {
+        assertNotNull(inputStream, "inputStream");
+        assertEquals(inputStream.unwrap().markSupported(), inputStream.markSupported());
+    }
+
+    @SuppressWarnings({ "resource", "unused", "unchecked" }) // For subclasses
+    protected T createFixture() throws IOException {
+        return (T) new ProxyInputStreamFixture(createOriginInputStream());
+    }
+
+    @SuppressWarnings("unchecked")
+    protected T createFixture(final InputStream proxy) {
+        return (T) new ProxyInputStreamFixture(proxy);
+    }
+
+    protected InputStream createOriginInputStream() {
+        return CharSequenceInputStream.builder().setCharSequence("abc").get();
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testAvailableAfterClose() throws IOException {
+        final T shadow;
+        try (T inputStream = createFixture()) {
+            shadow = inputStream;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws IOException {
+        try (T inputStream = createFixture()) {
+            assertEquals(3, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableAll() throws IOException {
+        try (T inputStream = createFixture()) {
+            assertEquals(3, inputStream.available());
+            IOUtils.toByteArray(inputStream);
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableNull() throws IOException {
+        try (T inputStream = createFixture(null)) {
+            assertEquals(0, inputStream.available());
+            inputStream.setIn(createFixture());
+            assertEquals(3, inputStream.available());
+            IOUtils.toByteArray(inputStream);
+            assertEquals(0, inputStream.available());
+            inputStream.setIn(null);
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    protected void testEos(final T inputStream) {
+        // empty
+    }
+
+    //@Test
+    public void testMarkOnNull() throws IOException {
+        try (T inputStream = createFixture(null)) {
+            inputStream.mark(1);
+            inputStream.setIn(createFixture());
+            inputStream.mark(1);
+            IOUtils.toByteArray(inputStream);
+            inputStream.mark(1);
+            inputStream.setIn(null);
+            inputStream.mark(1);
+        }
+    }
+
+    @Test
+    public void testMarkSupported() throws IOException {
+        try (T inputStream = createFixture()) {
+            assertMarkSupportedEquals(inputStream);
+        }
+    }
+
+    @SuppressWarnings("resource")
+    @Test
+    public void testMarkSupportedAfterClose() throws IOException {
+        final T shadow;
+        try (T inputStream = createFixture()) {
+            shadow = inputStream;
+        }
+        assertMarkSupportedEquals(shadow);
+    }
+
+    @Test
+    public void testMarkSupportedOnNull() throws IOException {
+        try (ProxyInputStream fixture = createFixture()) {
+            assertMarkSupportedEquals(fixture);
+            fixture.setIn(null);
+            assertFalse(fixture.markSupported());
+        }
+    }
+
+    @Test
+    public void testRead() throws IOException {
+        try (T inputStream = createFixture()) {
+            int found = inputStream.read();
+            assertEquals('a', found);
+            found = inputStream.read();
+            assertEquals('b', found);
+            found = inputStream.read();
+            assertEquals('c', found);
+            found = inputStream.read();
+            assertEquals(-1, found);
+            testEos(inputStream);
+        }
+    }
+
+    @Test
+    public void testReadAfterClose_ByteArrayInputStream() throws IOException {
+        try (InputStream inputStream = new ProxyInputStreamFixture(new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8)))) {
+            inputStream.close();
+            // ByteArrayInputStream does not throw on a closed stream.
+            assertNotEquals(IOUtils.EOF, inputStream.read());
+        }
+    }
+
+    @Test
+    public void testReadAfterClose_ChannelInputStream() throws IOException {
+        try (InputStream inputStream = new ProxyInputStreamFixture(
+                Files.newInputStream(Paths.get("src/test/resources/org/apache/commons/io/abitmorethan16k.txt")))) {
+            inputStream.close();
+            // ChannelInputStream throws when closed
+            assertThrows(IOException.class, inputStream::read);
+        }
+    }
+
+    @Test
+    public void testReadAfterClose_CharSequenceInputStream() throws IOException {
+        try (InputStream inputStream = createFixture()) {
+            inputStream.close();
+            // CharSequenceInputStream (like ByteArrayInputStream) does not throw on a closed stream.
+            assertEquals(IOUtils.EOF, inputStream.read());
+        }
+    }
+
+    @Test
+    public void testReadArrayAtMiddleFully() throws IOException {
+        try (T inputStream = createFixture()) {
+            final byte[] dest = new byte[5];
+            int found = inputStream.read(dest, 2, 3);
+            assertEquals(3, found);
+            assertArrayEquals(new byte[] { 0, 0, 'a', 'b', 'c' }, dest);
+            found = inputStream.read(dest, 2, 3);
+            assertEquals(-1, found);
+            testEos(inputStream);
+        }
+    }
+
+    @Test
+    public void testReadArrayAtStartFully() throws IOException {
+        try (T inputStream = createFixture()) {
+            final byte[] dest = new byte[5];
+            int found = inputStream.read(dest, 0, 5);
+            assertEquals(3, found);
+            assertArrayEquals(new byte[] { 'a', 'b', 'c', 0, 0 }, dest);
+            found = inputStream.read(dest, 0, 5);
+            assertEquals(-1, found);
+            testEos(inputStream);
+        }
+    }
+
+    @Test
+    public void testReadArrayAtStartPartial() throws IOException {
+        try (T inputStream = createFixture()) {
+            final byte[] dest = new byte[5];
+            int found = inputStream.read(dest, 0, 2);
+            assertEquals(2, found);
+            assertArrayEquals(new byte[] { 'a', 'b', 0, 0, 0 }, dest);
+            Arrays.fill(dest, (byte) 0);
+            found = inputStream.read(dest, 0, 2);
+            assertEquals(1, found);
+            assertArrayEquals(new byte[] { 'c', 0, 0, 0, 0 }, dest);
+            found = inputStream.read(dest, 0, 2);
+            assertEquals(-1, found);
+            testEos(inputStream);
+        }
+    }
+
+    @Test
+    public void testReadArrayFully() throws IOException {
+        try (T inputStream = createFixture()) {
+            final byte[] dest = new byte[5];
+            int found = inputStream.read(dest);
+            assertEquals(3, found);
+            assertArrayEquals(new byte[] { 'a', 'b', 'c', 0, 0 }, dest);
+            found = inputStream.read(dest);
+            assertEquals(-1, found);
+            testEos(inputStream);
+        }
+    }
+
+    @Test
+    public void testReadArrayPartial() throws IOException {
+        try (T inputStream = createFixture()) {
+            final byte[] dest = new byte[2];
+            int found = inputStream.read(dest);
+            assertEquals(2, found);
+            assertArrayEquals(new byte[] { 'a', 'b' }, dest);
+            Arrays.fill(dest, (byte) 0);
+            found = inputStream.read(dest);
+            assertEquals(1, found);
+            assertArrayEquals(new byte[] { 'c', 0 }, dest);
+            found = inputStream.read(dest);
+            assertEquals(-1, found);
+            testEos(inputStream);
+        }
+    }
+
+    @Test
+    public void testReadEof() throws Exception {
+        final ByteArrayInputStream proxy = new ByteArrayInputStream(new byte[2]);
+        try (ProxyInputStream inputStream = new ProxyInputStreamFixture(proxy)) {
+            assertSame(proxy, inputStream.unwrap());
+            int found = inputStream.read();
+            assertEquals(0, found);
+            found = inputStream.read();
+            assertEquals(0, found);
+            found = inputStream.read();
+            assertEquals(-1, found);
+        }
+    }
+
+    @Test
+    public void testSubclassAfterReadConsumer() throws Exception {
+        final byte[] hello = "Hello".getBytes(StandardCharsets.UTF_8);
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (ProxyInputStreamFixture bounded = ProxyInputStreamFixture.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setAfterRead(null) // should not blow up
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (ProxyInputStreamFixture bounded = ProxyInputStreamFixture.builder()
+                .setInputStream(new ByteArrayInputStream(hello))
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java b/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java
index dcb90cbc..10fa4960 100644
--- a/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java
@@ -95,6 +95,30 @@ private String readUnbuffered(final InputStream inputStream, final int maxBytes)
         return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());
     }
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest(name = "inputData={0}")
+    @MethodSource("inputData")
+    public void testAvailableAfterClose(final String inputData) throws IOException {
+        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
+        final InputStream shadow;
+        try (InputStream inputStream = new QueueInputStream(queue)) {
+            shadow = inputStream;
+        }
+        assertEquals(0, shadow.available());
+    }
+
+    @ParameterizedTest(name = "inputData={0}")
+    @MethodSource("inputData")
+    public void testAvailableAfterOpen(final String inputData) throws IOException {
+        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
+        try (InputStream inputStream = new QueueInputStream(queue)) {
+            // Always 0 because read() blocks.
+            assertEquals(0, inputStream.available());
+            IOUtils.toString(inputStream, StandardCharsets.UTF_8);
+            assertEquals(0, inputStream.available());
+        }
+    }
+
     @ParameterizedTest(name = "inputData={0}")
     @MethodSource("inputData")
     public void testBufferedReads(final String inputData) throws IOException {
@@ -139,6 +163,18 @@ public void testInvalidArguments() {
         assertThrows(IllegalArgumentException.class, () -> QueueInputStream.builder().setTimeout(Duration.ofMillis(-1)).get(), "waitTime must not be negative");
     }
 
+    @SuppressWarnings("resource")
+    @ParameterizedTest(name = "inputData={0}")
+    @MethodSource("inputData")
+    public void testReadAfterClose(final String inputData) throws IOException {
+        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
+        final InputStream shadow;
+        try (InputStream inputStream = new QueueInputStream(queue)) {
+            shadow = inputStream;
+        }
+        assertEquals(IOUtils.EOF, shadow.read());
+    }
+
     @Test
     public void testResetArguments() throws IOException {
         try (QueueInputStream queueInputStream = QueueInputStream.builder().setTimeout(null).get()) {
diff --git a/src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java b/src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java
index 80137c9d..cd01563a 100644
--- a/src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java
@@ -36,6 +36,9 @@
 import org.apache.commons.io.RandomAccessFileMode;
 import org.junit.jupiter.api.Test;
 
+/**
+ * Tests {@link RandomAccessFileInputStream}.
+ */
 public class RandomAccessFileInputStreamTest {
 
     private static final String DATA_FILE_NAME = "src/test/resources/org/apache/commons/io/test-file-iso8859-1.bin";
@@ -46,18 +49,34 @@ private RandomAccessFile createRandomAccessFile() throws FileNotFoundException {
         return RandomAccessFileMode.READ_ONLY.create(DATA_FILE_NAME);
     }
 
+    @SuppressWarnings("resource")
     @Test
-    public void testAvailable() throws IOException {
-        try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(createRandomAccessFile(),
-            true)) {
+    public void testAvailableAfterClose() throws IOException {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
+            inputStream.close();
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws IOException {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
             assertEquals(DATA_FILE_LEN, inputStream.available());
         }
     }
 
     @Test
     public void testAvailableLong() throws IOException {
-        try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(createRandomAccessFile(),
-            true)) {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
             assertEquals(DATA_FILE_LEN, inputStream.availableLong());
         }
     }
@@ -74,6 +93,12 @@ public void testBuilderFile() throws IOException {
         }
     }
 
+    @Test
+    public void testBuilderGet() {
+        // java.lang.IllegalStateException: origin == null
+        assertThrows(IllegalStateException.class, () -> RandomAccessFileInputStream.builder().get());
+    }
+
     @SuppressWarnings("resource") // instance variable access
     @Test
     public void testBuilderPath() throws IOException {
@@ -115,7 +140,9 @@ public void testBuilderRandomAccessFile() throws IOException {
     @Test
     public void testConstructorCloseOnCloseFalse() throws IOException {
         try (RandomAccessFile file = createRandomAccessFile()) {
-            try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(file, false)) {
+            try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                    .setRandomAccessFile(createRandomAccessFile())
+                    .get()) {
                 assertFalse(inputStream.isCloseOnClose());
                 assertNotEquals(-1, inputStream.getRandomAccessFile().read());
             }
@@ -125,7 +152,7 @@ public void testConstructorCloseOnCloseFalse() throws IOException {
 
     @SuppressWarnings("resource") // instance variable access
     @Test
-    public void testConstructorCloseOnCloseTrue() throws IOException {
+    public void testDeprecatedConstructorCloseOnCloseTrue() throws IOException {
         try (RandomAccessFile file = createRandomAccessFile()) {
             try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(file, true)) {
                 assertTrue(inputStream.isCloseOnClose());
@@ -137,7 +164,7 @@ public void testConstructorCloseOnCloseTrue() throws IOException {
 
     @SuppressWarnings("resource") // instance variable access
     @Test
-    public void testConstructorRandomAccessFile() throws IOException {
+    public void testDeprecatedConstructorRandomAccessFile() throws IOException {
         try (RandomAccessFile file = createRandomAccessFile()) {
             try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(file)) {
                 assertFalse(inputStream.isCloseOnClose());
@@ -147,15 +174,40 @@ public void testConstructorRandomAccessFile() throws IOException {
         }
     }
 
+    @SuppressWarnings("deprecation")
+    @Test
+    public void testDeprecatedConstructors() throws IOException {
+        try (RandomAccessFile randomAccessFile = createRandomAccessFile()) {
+            try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(randomAccessFile)) {
+                assertFalse(inputStream.isCloseOnClose());
+                assertEquals(randomAccessFile, inputStream.getRandomAccessFile());
+            }
+            try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(randomAccessFile, true)) {
+                assertTrue(inputStream.isCloseOnClose());
+                assertEquals(randomAccessFile, inputStream.getRandomAccessFile());
+            }
+            try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(randomAccessFile, false)) {
+                assertFalse(inputStream.isCloseOnClose());
+                assertEquals(randomAccessFile, inputStream.getRandomAccessFile());
+            }
+        }
+    }
+
+    @SuppressWarnings("deprecation")
     @Test
-    public void testConstructorRandomAccessFileNull() {
+    public void testDeprecatedConstructorsNull() {
         assertThrows(NullPointerException.class, () -> new RandomAccessFileInputStream(null));
+        assertThrows(NullPointerException.class, () -> new RandomAccessFileInputStream(null, true));
+        assertThrows(NullPointerException.class, () -> new RandomAccessFileInputStream(null, false));
     }
 
     @Test
     public void testGetters() throws IOException {
         try (RandomAccessFile file = createRandomAccessFile()) {
-            try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(file, true)) {
+            try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                    .setRandomAccessFile(file)
+                    .setCloseOnClose(true)
+                    .get()) {
                 assertEquals(file, inputStream.getRandomAccessFile());
                 assertTrue(inputStream.isCloseOnClose());
             }
@@ -164,8 +216,10 @@ public void testGetters() throws IOException {
 
     @Test
     public void testRead() throws IOException {
-        try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(createRandomAccessFile(),
-            true)) {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
             // A Test Line.
             assertEquals('A', inputStream.read());
             assertEquals(' ', inputStream.read());
@@ -184,10 +238,23 @@ public void testRead() throws IOException {
         }
     }
 
+    @Test
+    public void testReadAfterClose() throws IOException {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
+            inputStream.close();
+            assertThrows(IOException.class, inputStream::read);
+        }
+    }
+
     @Test
     public void testReadByteArray() throws IOException {
-        try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(createRandomAccessFile(),
-            true)) {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
             // A Test Line.
             final int dataLen = 12;
             final byte[] buffer = new byte[dataLen];
@@ -201,8 +268,10 @@ public void testReadByteArray() throws IOException {
 
     @Test
     public void testReadByteArrayBounds() throws IOException {
-        try (RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(createRandomAccessFile(),
-            true)) {
+        try (RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                .setRandomAccessFile(createRandomAccessFile())
+                .setCloseOnClose(true)
+                .get()) {
             // A Test Line.
             final int dataLen = 12;
             final byte[] buffer = new byte[dataLen];
@@ -218,7 +287,9 @@ public void testReadByteArrayBounds() throws IOException {
     public void testSkip() throws IOException {
 
         try (RandomAccessFile file = createRandomAccessFile();
-            final RandomAccessFileInputStream inputStream = new RandomAccessFileInputStream(file, false)) {
+            final RandomAccessFileInputStream inputStream = RandomAccessFileInputStream.builder()
+                    .setRandomAccessFile(file)
+                    .get()) {
             assertEquals(0, inputStream.skip(-1));
             assertEquals(0, inputStream.skip(Integer.MIN_VALUE));
             assertEquals(0, inputStream.skip(0));
diff --git a/src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java
index 959932cb..26ae19ce 100644
--- a/src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java
@@ -58,4 +58,5 @@ public void setUp() throws IOException {
                 ReadAheadInputStream.builder().setInputStream(new BufferedFileChannelInputStream(inputFile, 123)).setBufferSize(321).get(),
                 ReadAheadInputStream.builder().setPath(inputFile).setOpenOptions(StandardOpenOption.READ).get() };
     }
+
 }
diff --git a/src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java
index 7aaaa3d9..b4322a36 100644
--- a/src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java
@@ -73,6 +73,34 @@ static Stream<Arguments> charsetData() {
 
     private final Random random = new Random();
 
+    private ReaderInputStream createInputStream() throws IOException {
+        // @formatter:off
+        return ReaderInputStream.builder()
+                .setReader(new StringReader(TEST_STRING))
+                .setCharset(StandardCharsets.ISO_8859_1)
+                .get();
+        // @formatter:on
+    }
+
+    @Test
+    public void testAvailableAfterClose() throws IOException {
+        try (InputStream inputStream = createInputStream()) {
+            inputStream.close();
+            assertEquals(0, inputStream.available());
+        }
+    }
+
+    @Test
+    public void testAvailableAfterOpen() throws IOException {
+        try (InputStream inputStream = createInputStream()) {
+            // Nothing read, may block
+            assertEquals(0, inputStream.available());
+            // Read/block
+            inputStream.read();
+            assertEquals(TEST_STRING.length() - 1, inputStream.available());
+        }
+    }
+
     @Test
     @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)
     public void testBufferSmallest() throws IOException {
@@ -229,6 +257,14 @@ public void testLargeUTF8WithSingleByteRead() throws IOException {
         testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);
     }
 
+    @Test
+    public void testReadAfterClose() throws IOException {
+        try (InputStream inputStream = createInputStream()) {
+            inputStream.close();
+            assertThrows(IOException.class, inputStream::read);
+        }
+    }
+
     @Test
     public void testReadEofTwice() throws IOException {
         try (ReaderInputStream reader = ReaderInputStream.builder().setCharset(StandardCharsets.UTF_8).setReader(new StringReader("123")).get()) {
diff --git a/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java b/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderParamBlockSizeTest.java
similarity index 99%
rename from src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java
rename to src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderParamBlockSizeTest.java
index d3023ee1..c1d3c0b5 100644
--- a/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java
+++ b/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderParamBlockSizeTest.java
@@ -36,7 +36,7 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
-public class ReversedLinesFileReaderTestParamBlockSize {
+public class ReversedLinesFileReaderParamBlockSizeTest {
 
     private static final String UTF_8 = StandardCharsets.UTF_8.name();
     private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();
@@ -77,7 +77,6 @@ static void assertEqualsAndNoLineBreaks(final String msg, final String expected,
         assertEquals(expected, actual, msg);
     }
 
-
     // small and uneven block sizes are not used in reality but are good to show that the algorithm is solid
     public static IntStream blockSizes() {
         return IntStream.of(1, 3, 8, 256, 4096);
diff --git a/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java b/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderParamFileTest.java
similarity index 99%
rename from src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java
rename to src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderParamFileTest.java
index 71795e09..9c035fd1 100644
--- a/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java
+++ b/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderParamFileTest.java
@@ -45,7 +45,7 @@
 /**
  * Test checks symmetric behavior with BufferedReader.
  */
-public class ReversedLinesFileReaderTestParamFile {
+public class ReversedLinesFileReaderParamFileTest {
 
     private static final String UTF_16BE = StandardCharsets.ISO_8859_1.name();
     private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();
diff --git a/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java b/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderSimpleTest.java
similarity index 94%
rename from src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java
rename to src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderSimpleTest.java
index 00e2100d..a3e1db80 100644
--- a/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java
+++ b/src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderSimpleTest.java
@@ -16,7 +16,7 @@
  */
 package org.apache.commons.io.input;
 
-import static org.apache.commons.io.input.ReversedLinesFileReaderTestParamBlockSize.assertEqualsAndNoLineBreaks;
+import static org.apache.commons.io.input.ReversedLinesFileReaderParamBlockSizeTest.assertEqualsAndNoLineBreaks;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
@@ -32,14 +32,14 @@
 import org.apache.commons.io.TestResources;
 import org.junit.jupiter.api.Test;
 
-public class ReversedLinesFileReaderTestSimple {
+public class ReversedLinesFileReaderSimpleTest {
 
     @Test
     public void testFileSizeIsExactMultipleOfBlockSize() throws URISyntaxException, IOException {
         final int blockSize = 10;
         final File testFile20Bytes = TestResources.getFile("/test-file-20byteslength.bin");
         try (ReversedLinesFileReader reversedLinesFileReader = new ReversedLinesFileReader(testFile20Bytes, blockSize,
-            "ISO-8859-1")) {
+                StandardCharsets.ISO_8859_1.name())) {
             assertEqualsAndNoLineBreaks("987654321", reversedLinesFileReader.readLine());
             assertEqualsAndNoLineBreaks("123456789", reversedLinesFileReader.readLine());
         }
@@ -50,7 +50,7 @@ public void testLineCount() throws URISyntaxException, IOException {
         final int blockSize = 10;
         final File testFile20Bytes = TestResources.getFile("/test-file-20byteslength.bin");
         try (ReversedLinesFileReader reversedLinesFileReader = new ReversedLinesFileReader(testFile20Bytes, blockSize,
-            "ISO-8859-1")) {
+                StandardCharsets.ISO_8859_1.name())) {
             assertThrows(IllegalArgumentException.class, () -> reversedLinesFileReader.readLines(-1));
             assertTrue(reversedLinesFileReader.readLines(0).isEmpty());
             final List<String> lines = reversedLinesFileReader.readLines(2);
@@ -66,7 +66,7 @@ public void testToString() throws URISyntaxException, IOException {
         final int blockSize = 10;
         final File testFile20Bytes = TestResources.getFile("/test-file-20byteslength.bin");
         try (ReversedLinesFileReader reversedLinesFileReader = new ReversedLinesFileReader(testFile20Bytes, blockSize,
-            "ISO-8859-1")) {
+                StandardCharsets.ISO_8859_1.name())) {
             assertThrows(IllegalArgumentException.class, () -> reversedLinesFileReader.toString(-1));
             assertTrue(reversedLinesFileReader.readLines(0).isEmpty());
             final String lines = reversedLinesFileReader.toString(2);
diff --git a/src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java b/src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java
index 7695f7ee..ee8a2ae7 100644
--- a/src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java
@@ -16,7 +16,6 @@
  */
 package org.apache.commons.io.input;
 
-
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -29,7 +28,6 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-
 /**
  * Test for the SwappedDataInputStream. This also
  * effectively tests the underlying EndianUtils Stream methods.
@@ -53,7 +51,7 @@ public void setUp() {
             0x08
         };
         final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
-        this.sdis = new SwappedDataInputStream( bais );
+        this.sdis = new SwappedDataInputStream(bais);
     }
 
     @AfterEach
@@ -61,9 +59,15 @@ public void tearDown() {
         this.sdis = null;
     }
 
+    @SuppressWarnings({ "resource" })
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(new SwappedDataInputStream(new BrokenInputStream((Throwable) new IOException())));
+    }
+
     @Test
     public void testReadBoolean() throws IOException {
-        bytes = new byte[] {0x00, 0x01, 0x02,};
+        bytes = new byte[] { 0x00, 0x01, 0x02, };
         try (
             final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
             final SwappedDataInputStream sdis = new SwappedDataInputStream(bais)
@@ -98,8 +102,8 @@ public void testReadFloat() throws IOException {
     public void testReadFully() throws IOException {
         final byte[] bytesIn = new byte[8];
         this.sdis.readFully(bytesIn);
-        for( int i=0; i<8; i++) {
-            assertEquals( bytes[i], bytesIn[i] );
+        for (int i = 0; i < 8; i++) {
+            assertEquals(bytes[i], bytesIn[i]);
         }
     }
 
@@ -110,8 +114,7 @@ public void testReadInt() throws IOException {
 
     @Test
     public void testReadLine() {
-        assertThrows(UnsupportedOperationException.class, () ->  this.sdis.readLine(),
-                "readLine should be unsupported. ");
+        assertThrows(UnsupportedOperationException.class, () -> this.sdis.readLine(), "readLine should be unsupported.");
     }
 
     @Test
@@ -136,8 +139,7 @@ public void testReadUnsignedShort() throws IOException {
 
     @Test
     public void testReadUTF() {
-        assertThrows(UnsupportedOperationException.class, () ->  this.sdis.readUTF(),
-                "readUTF should be unsupported. ");
+        assertThrows(UnsupportedOperationException.class, () -> this.sdis.readUTF(), "readUTF should be unsupported.");
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java b/src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java
index a61c0fc8..560d3621 100644
--- a/src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java
@@ -59,6 +59,12 @@ public void testBrokenStream() {
         assertEquals(exception, exceptionCloseCause);
     }
 
+    @SuppressWarnings({ "resource" })
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(new TaggedInputStream(new BrokenInputStream((Throwable) new IOException())));
+    }
+
     @Test
     public void testEmptyStream() throws IOException {
         try (InputStream stream = new TaggedInputStream(ClosedInputStream.INSTANCE)) {
diff --git a/src/test/java/org/apache/commons/io/input/TailerTest.java b/src/test/java/org/apache/commons/io/input/TailerTest.java
index 783e1718..7dc72e1c 100644
--- a/src/test/java/org/apache/commons/io/input/TailerTest.java
+++ b/src/test/java/org/apache/commons/io/input/TailerTest.java
@@ -52,6 +52,7 @@
 import org.apache.commons.io.RandomAccessFileMode;
 import org.apache.commons.io.TestResources;
 import org.apache.commons.io.test.TestUtils;
+import org.apache.commons.lang3.SystemProperties;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 
@@ -416,7 +417,7 @@ public void testMultiByteBreak() throws Exception {
         final File file = new File(temporaryFolder, "testMultiByteBreak.txt");
         createFile(file, 0);
         final TestTailerListener listener = new TestTailerListener();
-        final String osname = System.getProperty("os.name");
+        final String osname = SystemProperties.getOsName();
         final boolean isWindows = osname.startsWith("Windows");
         // Need to use UTF-8 to read & write the file otherwise it can be corrupted (depending on the default charset)
         final Charset charsetUTF8 = StandardCharsets.UTF_8;
@@ -583,7 +584,7 @@ public void testTailer() throws Exception {
         final File file = new File(temporaryFolder, "tailer1-test.txt");
         createFile(file, 0);
         final TestTailerListener listener = new TestTailerListener();
-        final String osname = System.getProperty("os.name");
+        final String osname = SystemProperties.getOsName();
         final boolean isWindows = osname.startsWith("Windows");
         try (Tailer tailer = new Tailer(file, listener, delayMillis, false, isWindows)) {
             final Thread thread = new Thread(tailer);
@@ -651,7 +652,7 @@ public void testTailerEndOfFileReached() throws Exception {
         final File file = new File(temporaryFolder, "tailer-eof-test.txt");
         createFile(file, 0);
         final TestTailerListener listener = new TestTailerListener();
-        final String osname = System.getProperty("os.name");
+        final String osname = SystemProperties.getOsName();
         final boolean isWindows = osname.startsWith("Windows");
         try (Tailer tailer = new Tailer(file, listener, delayMillis, false, isWindows)) {
             final Thread thread = new Thread(tailer);
diff --git a/src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java b/src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java
index 49527a92..18d9326e 100644
--- a/src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java
@@ -71,6 +71,15 @@ public void testCloseBranchIOException() throws Exception {
         verify(goodIs, times(2)).close();
     }
 
+    @SuppressWarnings({ "resource" })
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest
+                .testCloseHandleIOException(new TeeInputStream(new BrokenInputStream((Throwable) new IOException()), new ByteArrayOutputStream(), false));
+        ProxyInputStreamTest
+                .testCloseHandleIOException(new TeeInputStream(new BrokenInputStream((Throwable) new IOException()), new ByteArrayOutputStream(), true));
+    }
+
     /**
      * Tests that the branch {@code OutputStream} is closed when closing the main {@code InputStream} throws an
      * exception on {@link TeeInputStream#close()}, if specified to do so.
diff --git a/src/test/java/org/apache/commons/io/input/TeeReaderTest.java b/src/test/java/org/apache/commons/io/input/TeeReaderTest.java
index c4945258..515ea859 100644
--- a/src/test/java/org/apache/commons/io/input/TeeReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/TeeReaderTest.java
@@ -66,7 +66,7 @@ public void testCloseBranchIOException() throws Exception {
         verify(goodR).close();
 
         final TeeReader closingTr = new TeeReader(goodR, badW, true);
-        final IOException e = assertThrows(IOException.class, closingTr::close);
+        assertThrows(IOException.class, closingTr::close);
         verify(goodR, times(2)).close();
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/ThrottledInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ThrottledInputStreamTest.java
new file mode 100644
index 00000000..a072329e
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/input/ThrottledInputStreamTest.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.time.Duration;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.test.CustomIOException;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link ThrottledInputStream}.
+ */
+public class ThrottledInputStreamTest extends ProxyInputStreamTest<ThrottledInputStream> {
+
+    @Override
+    @SuppressWarnings({ "resource" })
+    protected ThrottledInputStream createFixture() throws IOException {
+        return ThrottledInputStream.builder().setInputStream(createOriginInputStream()).get();
+    }
+
+    @Test
+    public void testAfterReadConsumer() throws Exception {
+        final AtomicBoolean boolRef = new AtomicBoolean();
+        // @formatter:off
+        try (InputStream bounded = ThrottledInputStream.builder()
+                .setCharSequence("Hi")
+                .setAfterRead(i -> boolRef.set(true))
+                .get()) {
+            IOUtils.consume(bounded);
+        }
+        // @formatter:on
+        assertTrue(boolRef.get());
+        // Throwing
+        final String message = "test exception message";
+        // @formatter:off
+        try (InputStream bounded = ThrottledInputStream.builder()
+                .setCharSequence("Hi")
+                .setAfterRead(i -> {
+                    throw new CustomIOException(message);
+                })
+                .get()) {
+            assertEquals(message, assertThrowsExactly(CustomIOException.class, () -> IOUtils.consume(bounded)).getMessage());
+        }
+        // @formatter:on
+    }
+
+    @Test
+    public void testCalSleepTimeMs() {
+        // case 0: initial - no read, no sleep
+        assertEquals(0, ThrottledInputStream.toSleepMillis(0, 10_000, 1_000));
+
+        // case 1: no threshold
+        assertEquals(0, ThrottledInputStream.toSleepMillis(Long.MAX_VALUE, 0, 1_000));
+        assertEquals(0, ThrottledInputStream.toSleepMillis(Long.MAX_VALUE, -1, 1_000));
+
+        // case 2: too fast
+        assertEquals(1500, ThrottledInputStream.toSleepMillis(5, 2, 1_000));
+        assertEquals(500, ThrottledInputStream.toSleepMillis(5, 2, 2_000));
+        assertEquals(6500, ThrottledInputStream.toSleepMillis(15, 2, 1_000));
+
+        // case 3: too slow
+        assertEquals(0, ThrottledInputStream.toSleepMillis(1, 2, 1_000));
+        assertEquals(0, ThrottledInputStream.toSleepMillis(2, 2, 2_000));
+        assertEquals(0, ThrottledInputStream.toSleepMillis(1, 2, 1_000));
+    }
+
+    @Test
+    public void testCloseHandleIOException() throws IOException {
+        ProxyInputStreamTest.testCloseHandleIOException(ThrottledInputStream.builder());
+    }
+
+    @Override
+    protected void testEos(final ThrottledInputStream inputStream) {
+        assertEquals(3, inputStream.getByteCount());
+    }
+
+    @Test
+    public void testGet() throws IOException {
+        try (ThrottledInputStream inputStream = createFixture()) {
+            inputStream.read();
+            assertEquals(Duration.ZERO, inputStream.getTotalSleepDuration());
+        }
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java b/src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java
index 66f06964..cd799faa 100644
--- a/src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java
@@ -26,56 +26,86 @@
 
 public class UnixLineEndingInputStreamTest {
 
+    private String roundtrip(final String msg) throws IOException {
+        return roundtrip(msg, true, 0);
+    }
+
+    private String roundtrip(final String msg, final boolean ensureLineFeedAtEndOfFile, final int minBufferLen) throws IOException {
+        final String string;
+        // read(byte[])
+        try (final ByteArrayInputStream baos = new ByteArrayInputStream(msg.getBytes(StandardCharsets.UTF_8));
+                final UnixLineEndingInputStream in = new UnixLineEndingInputStream(baos, ensureLineFeedAtEndOfFile)) {
+            // read into a buffer larger than the fixture.
+            final byte[] buf = new byte[minBufferLen + msg.length() * 10];
+            string = new String(buf, 0, in.read(buf), StandardCharsets.UTF_8);
+        }
+        // read(byte[], int, int)
+        try (final ByteArrayInputStream baos = new ByteArrayInputStream(msg.getBytes(StandardCharsets.UTF_8));
+                final UnixLineEndingInputStream in = new UnixLineEndingInputStream(baos, ensureLineFeedAtEndOfFile)) {
+            // read into a buffer larger than the fixture.
+            final byte[] buf = new byte[minBufferLen + msg.length() * 10];
+            assertEquals(string, new String(buf, 0, in.read(buf, 0, buf.length), StandardCharsets.UTF_8));
+        }
+        // read
+        try (final ByteArrayInputStream baos = new ByteArrayInputStream(msg.getBytes(StandardCharsets.UTF_8));
+                final UnixLineEndingInputStream in = new UnixLineEndingInputStream(baos, ensureLineFeedAtEndOfFile)) {
+            // read into a buffer larger than the fixture.
+            final int[] buf = new int[minBufferLen + msg.length() * 10];
+            if (buf.length > 0) {
+                int b;
+                int i = 0;
+                while ((b = in.read()) != -1) {
+                    buf[i++] = b;
+                }
+                assertEquals(string, new String(buf, 0, i));
+            }
+        }
+        return string;
+    }
+
     @Test
-    public void crAtEnd() throws Exception {
+    public void testCrAtEnd() throws Exception {
         assertEquals("a\n", roundtrip("a\r"));
     }
 
     @Test
-    public void crOnlyEnsureAtEof() throws Exception {
+    public void testCrOnlyEnsureAtEof() throws Exception {
         assertEquals("a\nb\n", roundtrip("a\rb"));
     }
 
     @Test
-    public void crOnlyNotAtEof() throws Exception {
-        assertEquals("a\nb", roundtrip("a\rb", false));
+    public void testCrOnlyNotAtEof() throws Exception {
+        assertEquals("a\nb", roundtrip("a\rb", false, 0));
     }
 
     @Test
-    public void inTheMiddleOfTheLine() throws Exception {
-        assertEquals("a\nbc\n", roundtrip("a\r\nbc"));
+    public void testEmpty() throws Exception {
+        assertEquals("", roundtrip(""));
     }
 
     @Test
-    public void multipleBlankLines() throws Exception {
-        assertEquals("a\n\nbc\n", roundtrip("a\r\n\r\nbc"));
+    public void testInTheMiddleOfTheLine() throws Exception {
+        assertEquals("a\nbc\n", roundtrip("a\r\nbc"));
     }
 
     @Test
-    public void retainLineFeed() throws Exception {
-        assertEquals("a\n\n", roundtrip("a\r\n\r\n", false));
-        assertEquals("a", roundtrip("a", false));
-    }
-
-    private String roundtrip(final String msg) throws IOException {
-        return roundtrip(msg, true);
+    public void testMultipleBlankLines() throws Exception {
+        assertEquals("a\n\nbc\n", roundtrip("a\r\n\r\nbc"));
     }
 
-    private String roundtrip(final String msg, final boolean ensure) throws IOException {
-        try (final ByteArrayInputStream baos = new ByteArrayInputStream(msg.getBytes(StandardCharsets.UTF_8));
-            final UnixLineEndingInputStream lf = new UnixLineEndingInputStream(baos, ensure)) {
-            final byte[] buf = new byte[100];
-            return new String(buf, 0, lf.read(buf), StandardCharsets.UTF_8);
-        }
+    @Test
+    public void testRetainLineFeed() throws Exception {
+        assertEquals("a\n\n", roundtrip("a\r\n\r\n", false, 0));
+        assertEquals("a", roundtrip("a", false, 0));
     }
 
     @Test
-    public void simpleString() throws Exception {
+    public void testSimpleString() throws Exception {
         assertEquals("abc\n", roundtrip("abc"));
     }
 
     @Test
-    public void twoLinesAtEnd() throws Exception {
+    public void testTwoLinesAtEnd() throws Exception {
         assertEquals("a\n\n", roundtrip("a\r\n\r\n"));
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java b/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java
new file mode 100644
index 00000000..6f6ed3fd
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java
@@ -0,0 +1,590 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.ByteArrayInputStream;
+import java.io.CharArrayReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PipedReader;
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.function.Supplier;
+
+import org.apache.commons.io.IOUtils;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link UnsynchronizedBufferedReader}.
+ * <p>
+ * Provenance: Apache Harmony {@code BufferedReaderTest}, copied, and modified.
+ * </p>
+ */
+public class UnsynchronizedBufferedReaderTest {
+
+    private UnsynchronizedBufferedReader br;
+
+    private final String testString = "Test_All_Tests\nTest_java_io_BufferedInputStream\nTest_java_io_BufferedOutputStream\nTest_java_io_ByteArrayInputStream\n"
+            + "Test_java_io_ByteArrayOutputStream\nTest_java_io_DataInputStream\nTest_java_io_File\nTest_java_io_FileDescriptor\nTest_java_io_FileInputStream\n"
+            + "Test_java_io_FileNotFoundException\nTest_java_io_FileOutputStream\nTest_java_io_FilterInputStream\nTest_java_io_FilterOutputStream\n"
+            + "Test_java_io_InputStream\nTest_java_io_IOException\nTest_java_io_OutputStream\nTest_java_io_PrintStream\nTest_java_io_RandomAccessFile\n"
+            + "Test_java_io_SyncFailedException\nTest_java_lang_AbstractMethodError\nTest_java_lang_ArithmeticException\n"
+            + "Test_java_lang_ArrayIndexOutOfBoundsException\nTest_java_lang_ArrayStoreException\nTest_java_lang_Boolean\nTest_java_lang_Byte\n"
+            + "Test_java_lang_Character\nTest_java_lang_Class\nTest_java_lang_ClassCastException\nTest_java_lang_ClassCircularityError\n"
+            + "Test_java_lang_ClassFormatError\nTest_java_lang_ClassLoader\nTest_java_lang_ClassNotFoundException\nTest_java_lang_CloneNotSupportedException\n"
+            + "Test_java_lang_Double\nTest_java_lang_Error\nTest_java_lang_Exception\nTest_java_lang_ExceptionInInitializerError\nTest_java_lang_Float\n"
+            + "Test_java_lang_IllegalAccessError\nTest_java_lang_IllegalAccessException\nTest_java_lang_IllegalArgumentException\n"
+            + "Test_java_lang_IllegalMonitorStateException\nTest_java_lang_IllegalThreadStateException\nTest_java_lang_IncompatibleClassChangeError\n"
+            + "Test_java_lang_IndexOutOfBoundsException\nTest_java_lang_InstantiationError\nTest_java_lang_InstantiationException\nTest_java_lang_Integer\n"
+            + "Test_java_lang_InternalError\nTest_java_lang_InterruptedException\nTest_java_lang_LinkageError\nTest_java_lang_Long\nTest_java_lang_Math\n"
+            + "Test_java_lang_NegativeArraySizeException\nTest_java_lang_NoClassDefFoundError\nTest_java_lang_NoSuchFieldError\n"
+            + "Test_java_lang_NoSuchMethodError\nTest_java_lang_NullPointerException\nTest_java_lang_Number\nTest_java_lang_NumberFormatException\n"
+            + "Test_java_lang_Object\nTest_java_lang_OutOfMemoryError\nTest_java_lang_RuntimeException\nTest_java_lang_SecurityManager\nTest_java_lang_Short\n"
+            + "Test_java_lang_StackOverflowError\nTest_java_lang_String\nTest_java_lang_StringBuffer\nTest_java_lang_StringIndexOutOfBoundsException\n"
+            + "Test_java_lang_System\nTest_java_lang_Thread\nTest_java_lang_ThreadDeath\nTest_java_lang_ThreadGroup\nTest_java_lang_Throwable\n"
+            + "Test_java_lang_UnknownError\nTest_java_lang_UnsatisfiedLinkError\nTest_java_lang_VerifyError\nTest_java_lang_VirtualMachineError\n"
+            + "Test_java_lang_vm_Image\nTest_java_lang_vm_MemorySegment\nTest_java_lang_vm_ROMStoreException\nTest_java_lang_vm_VM\nTest_java_lang_Void\n"
+            + "Test_java_net_BindException\nTest_java_net_ConnectException\nTest_java_net_DatagramPacket\nTest_java_net_DatagramSocket\n"
+            + "Test_java_net_DatagramSocketImpl\nTest_java_net_InetAddress\nTest_java_net_NoRouteToHostException\nTest_java_net_PlainDatagramSocketImpl\n"
+            + "Test_java_net_PlainSocketImpl\nTest_java_net_Socket\nTest_java_net_SocketException\nTest_java_net_SocketImpl\nTest_java_net_SocketInputStream\n"
+            + "Test_java_net_SocketOutputStream\nTest_java_net_UnknownHostException\nTest_java_util_ArrayEnumerator\nTest_java_util_Date\n"
+            + "Test_java_util_EventObject\nTest_java_util_HashEnumerator\nTest_java_util_Hashtable\nTest_java_util_Properties\nTest_java_util_ResourceBundle\n"
+            + "Test_java_util_tm\nTest_java_util_Vector\n";
+
+    /**
+     * Tears down the fixture, for example, close a network connection. This method is called after a test is executed.
+     */
+    @AfterEach
+    protected void afterEach() {
+        IOUtils.closeQuietly(br);
+    }
+
+    private void assertLines(final String input, final String... lines) throws IOException {
+        assertReadLines(input, lines);
+        assertPeek(input, lines);
+    }
+
+    private void assertPeek(final String input, final String... lines) throws IOException {
+        try (UnsynchronizedBufferedReader bufferedReader = new UnsynchronizedBufferedReader(new StringReader(input))) {
+            for (final String line : lines) {
+                // all
+                final char[] bufAFull = new char[line.length()];
+                assertEquals(bufAFull.length, bufferedReader.peek(bufAFull));
+                assertArrayEquals(line.toCharArray(), bufAFull);
+                if (!line.isEmpty()) {
+                    // one
+                    assertEquals(line.charAt(0), bufferedReader.peek());
+                    // array
+                    for (int peekLen = 0; peekLen < line.length(); peekLen++) {
+                        assertPeekArray(bufferedReader, peekLen, line);
+                    }
+                }
+                // move test to the next fixture
+                assertEquals(line, bufferedReader.readLine());
+            }
+            assertNull(bufferedReader.readLine());
+        }
+    }
+
+    private void assertPeekArray(final UnsynchronizedBufferedReader bufferedReader, final int peekLen, final String line) throws IOException {
+        final char[] expectedBuf = new char[peekLen];
+        final int srcPeekLen = Math.min(peekLen, line.length());
+        line.getChars(0, srcPeekLen, expectedBuf, 0);
+        final char[] actualBuf = new char[peekLen];
+        final Supplier<String> msg = () -> String.format("len=%,d, line='%s'", peekLen, line);
+        assertEquals(actualBuf.length, bufferedReader.peek(actualBuf), msg);
+        assertArrayEquals(expectedBuf, actualBuf, msg);
+    }
+
+    private void assertReadLines(final String input, final String... lines) throws IOException {
+        try (UnsynchronizedBufferedReader bufferedReader = new UnsynchronizedBufferedReader(new StringReader(input))) {
+            for (final String line : lines) {
+                assertEquals(line, bufferedReader.readLine());
+            }
+            assertNull(bufferedReader.readLine());
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#close()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testClose() throws IOException {
+        // Test for method void UnsynchronizedBufferedReader.close()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        br.close();
+        assertThrows(IOException.class, br::read);
+    }
+
+    @Test
+    public void testEmptyInput() throws Exception {
+        try (final UnsynchronizedBufferedReader br = new UnsynchronizedBufferedReader(new StringReader(""))) {
+            assertEquals(EOF, br.read());
+            assertEquals(EOF, br.peek());
+            assertNull(br.readLine());
+            assertEquals(0, br.read(new char[10], 0, 0));
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#mark(int)}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testMark() throws IOException {
+        // Test for method void UnsynchronizedBufferedReader.mark(int)
+        char[] buf = null;
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        br.skip(500);
+        br.mark(1000);
+        br.skip(250);
+        br.reset();
+        buf = new char[testString.length()];
+        br.read(buf, 0, 500);
+        assertTrue(testString.substring(500, 1000).equals(new String(buf, 0, 500)));
+
+        br = new UnsynchronizedBufferedReader(new StringReader(testString), 800);
+        br.skip(500);
+        br.mark(250);
+        br.read(buf, 0, 1000);
+        assertThrows(IOException.class, br::reset);
+
+        final char[] chars = new char[256];
+        for (int i = 0; i < 256; i++) {
+            chars[i] = (char) i;
+        }
+
+        try (Reader in = new UnsynchronizedBufferedReader(new StringReader(new String(chars)), 12)) {
+            in.skip(6);
+            in.mark(14);
+            in.read(new char[14], 0, 14);
+            in.reset();
+            assertTrue(in.read() == (char) 6 && in.read() == (char) 7);
+        }
+        try (Reader in = new UnsynchronizedBufferedReader(new StringReader(new String(chars)), 12)) {
+            in.skip(6);
+            in.mark(8);
+            in.skip(7);
+            in.reset();
+            assertTrue(in.read() == (char) 6 && in.read() == (char) 7);
+        }
+        try (UnsynchronizedBufferedReader br = new UnsynchronizedBufferedReader(new StringReader("01234"), 2)) {
+            br.mark(3);
+            final char[] carray = new char[3];
+            final int result = br.read(carray);
+            assertEquals(3, result);
+            assertEquals('0', carray[0]);
+            assertEquals('1', carray[1]);
+            assertEquals('2', carray[2]);
+            assertEquals('3', br.read());
+        }
+        try (UnsynchronizedBufferedReader br = new UnsynchronizedBufferedReader(new StringReader("01234"), 2)) {
+            br.mark(3);
+            final char[] carray = new char[4];
+            final int result = br.read(carray);
+            assertEquals(4, result);
+            assertEquals('0', carray[0]);
+            assertEquals('1', carray[1]);
+            assertEquals('2', carray[2]);
+            assertEquals('3', carray[3]);
+            assertEquals('4', br.read());
+            assertEquals(-1, br.read());
+        }
+        try (UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new StringReader("01234"))) {
+            reader.mark(Integer.MAX_VALUE);
+            reader.read();
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#markSupported()}.
+     */
+    @Test
+    public void testMarkSupported() {
+        // Test for method boolean UnsynchronizedBufferedReader.markSupported()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        assertTrue(br.markSupported());
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#peek()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testPeek() throws IOException {
+        // Test for method int UnsynchronizedBufferedReader.read()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        final int p = br.peek();
+        assertEquals(testString.charAt(0), p);
+        final int r = br.read();
+        assertEquals(testString.charAt(0), r);
+        br = new UnsynchronizedBufferedReader(new StringReader(new String(new char[] { '\u8765' })));
+        assertEquals(br.peek(), '\u8765');
+        assertEquals(br.read(), '\u8765');
+        // chars '\0'...'\255'
+        final char[] chars = new char[256];
+        for (int i = 0; i < 256; i++) {
+            chars[i] = (char) i;
+        }
+        try (UnsynchronizedBufferedReader in = new UnsynchronizedBufferedReader(new StringReader(new String(chars)), 12)) {
+            assertEquals(0, in.peek()); // Fill the buffer
+            assertEquals(0, in.read()); // Fill the buffer
+            final char[] buf = new char[14];
+            in.read(buf, 0, 14); // Read greater than the buffer
+            assertTrue(new String(buf).equals(new String(chars, 1, 14)));
+            assertEquals(15, in.peek()); // Check next byte
+            assertEquals(15, in.read()); // Check next byte
+        }
+        //
+        // regression test for HARMONY-841
+        try (UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new CharArrayReader(new char[5], 1, 0), 2)) {
+            assertEquals(reader.peek(), -1);
+            assertEquals(reader.read(), -1);
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#peek()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testPeekArray() throws IOException {
+        // Test for method int UnsynchronizedBufferedReader.read()
+        final char[] peekBuf1 = new char[1];
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        assertEquals(peekBuf1.length, br.peek(peekBuf1));
+        assertEquals(testString.charAt(0), peekBuf1[0]);
+        final int r = br.read();
+        assertEquals(testString.charAt(0), r);
+        br = new UnsynchronizedBufferedReader(new StringReader(new String(new char[] { '\u8765' })));
+        assertEquals(peekBuf1.length, br.peek(peekBuf1));
+        assertEquals(peekBuf1[0], '\u8765');
+        assertEquals(br.read(), '\u8765');
+        // chars '\0'...'\255'
+        final char[] chars = new char[256];
+        for (int i = 0; i < 256; i++) {
+            chars[i] = (char) i;
+        }
+        try (UnsynchronizedBufferedReader in = new UnsynchronizedBufferedReader(new StringReader(new String(chars)), 12)) {
+            assertEquals(peekBuf1.length, in.peek(peekBuf1)); // Fill the buffer
+            assertEquals(peekBuf1[0], 0);
+            assertEquals(0, in.read()); // Fill the buffer
+            final char[] peekBuf14 = new char[14];
+            assertEquals(peekBuf14.length, in.peek(peekBuf14)); // Peek greater than the buffer
+            assertTrue(new String(peekBuf14).equals(new String(chars, 1, 14)));
+            final char[] buf = new char[14];
+            in.read(buf, 0, 14); // Read greater than the buffer
+            assertTrue(new String(buf).equals(new String(chars, 1, 14)));
+            assertEquals(peekBuf1.length, in.peek(peekBuf1)); // Check next byte
+            assertEquals(15, peekBuf1[0]);
+            assertEquals(15, in.read()); // Check next byte
+        }
+        //
+        // regression test for HARMONY-841
+        try (UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new CharArrayReader(new char[5], 1, 0), 2)) {
+            assertEquals(reader.peek(), -1);
+            assertEquals(reader.read(), -1);
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#read()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testRead() throws IOException {
+        // Test for method int UnsynchronizedBufferedReader.read()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        final int r = br.read();
+        assertEquals(testString.charAt(0), r);
+        br = new UnsynchronizedBufferedReader(new StringReader(new String(new char[] { '\u8765' })));
+        assertEquals(br.read(), '\u8765');
+        //
+        final char[] chars = new char[256];
+        for (int i = 0; i < 256; i++) {
+            chars[i] = (char) i;
+        }
+        try (Reader in = new UnsynchronizedBufferedReader(new StringReader(new String(chars)), 12)) {
+            assertEquals(0, in.read()); // Fill the buffer
+            final char[] buf = new char[14];
+            in.read(buf, 0, 14); // Read greater than the buffer
+            assertTrue(new String(buf).equals(new String(chars, 1, 14)));
+            assertEquals(15, in.read()); // Check next byte
+        }
+        //
+        // regression test for HARMONY-841
+        try (Reader reader = new UnsynchronizedBufferedReader(new CharArrayReader(new char[5], 1, 0), 2)) {
+            assertEquals(reader.read(), -1);
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#read(char[], int, int)}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testReadArray() throws IOException {
+        final char[] ca = new char[2];
+        try (UnsynchronizedBufferedReader toRet = new UnsynchronizedBufferedReader(new InputStreamReader(new ByteArrayInputStream(new byte[0])))) {
+            /* Null buffer should throw NPE even when len == 0 */
+            assertThrows(NullPointerException.class, () -> toRet.read(null, 1, 0));
+            toRet.close();
+            assertThrows(IOException.class, () -> toRet.read(null, 1, 0));
+            /* Closed reader should throw IOException reading zero bytes */
+            assertThrows(IOException.class, () -> toRet.read(ca, 0, 0));
+            /*
+             * Closed reader should throw IOException in preference to index out of bounds
+             */
+            // Read should throw IOException before
+            // ArrayIndexOutOfBoundException
+            assertThrows(IOException.class, () -> toRet.read(ca, 1, 5));
+        }
+        // Test to ensure that a drained stream returns 0 at EOF
+        try (UnsynchronizedBufferedReader toRet2 = new UnsynchronizedBufferedReader(new InputStreamReader(new ByteArrayInputStream(new byte[2])))) {
+            assertEquals(2, toRet2.read(ca, 0, 2));
+            assertEquals(-1, toRet2.read(ca, 0, 2));
+            assertEquals(0, toRet2.read(ca, 0, 0));
+        }
+
+        // Test for method int UnsynchronizedBufferedReader.read(char [], int, int)
+        final char[] buf = new char[testString.length()];
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        br.read(buf, 50, 500);
+        assertTrue(new String(buf, 50, 500).equals(testString.substring(0, 500)));
+
+        try (UnsynchronizedBufferedReader bufin = new UnsynchronizedBufferedReader(new Reader() {
+            int size = 2, pos = 0;
+
+            char[] contents = new char[size];
+
+            @Override
+            public void close() throws IOException {
+                // Empty
+            }
+
+            @Override
+            public int read() throws IOException {
+                if (pos >= size) {
+                    throw new IOException("Read past end of data");
+                }
+                return contents[pos++];
+            }
+
+            @Override
+            public int read(final char[] buf, final int off, final int len) throws IOException {
+                if (pos >= size) {
+                    throw new IOException("Read past end of data");
+                }
+                int toRead = len;
+                if (toRead > size - pos) {
+                    toRead = size - pos;
+                }
+                System.arraycopy(contents, pos, buf, off, toRead);
+                pos += toRead;
+                return toRead;
+            }
+
+            @Override
+            public boolean ready() throws IOException {
+                return size - pos > 0;
+            }
+        })) {
+            bufin.read();
+            final int result = bufin.read(new char[2], 0, 2);
+            assertEquals(result, 1);
+        }
+        // regression for HARMONY-831
+        try (Reader reader = new UnsynchronizedBufferedReader(new PipedReader(), 9)) {
+            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(new char[] {}, 7, 0));
+        }
+
+        // Regression for HARMONY-54
+        final char[] ch = {};
+        @SuppressWarnings("resource")
+        final UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new CharArrayReader(ch));
+        // Check exception thrown when the reader is open.
+        assertThrows(NullPointerException.class, () -> reader.read(null, 1, 0));
+
+        // Now check IOException is thrown in preference to
+        // NullPointerexception when the reader is closed.
+        reader.close();
+        assertThrows(IOException.class, () -> reader.read(null, 1, 0));
+
+        // And check that the IOException is thrown before
+        // ArrayIndexOutOfBoundException
+        assertThrows(IOException.class, () -> reader.read(ch, 0, 42));
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#read(char[], int, int)}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testReadArrayException() throws IOException {
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        final char[] nullCharArray = null;
+        final char[] charArray = testString.toCharArray();
+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(nullCharArray, -1, -1));
+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(nullCharArray, -1, 0));
+        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 0, -1));
+        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 0, 0));
+        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 0, 1));
+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, -1, -1));
+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, -1, 0));
+
+        br.read(charArray, 0, 0);
+        br.read(charArray, 0, charArray.length);
+        br.read(charArray, charArray.length, 0);
+
+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, charArray.length + 1, 0));
+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, charArray.length + 1, 1));
+
+        br.close();
+
+        assertThrows(IOException.class, () -> br.read(nullCharArray, -1, -1));
+        assertThrows(IOException.class, () -> br.read(charArray, -1, 0));
+        assertThrows(IOException.class, () -> br.read(charArray, 0, -1));
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#readLine()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testReadLine() throws IOException {
+        // Test for method java.lang.String UnsynchronizedBufferedReader.readLine()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        final String r = br.readLine();
+        assertEquals("Test_All_Tests", r);
+    }
+
+    /**
+     * The spec says that BufferedReader.readLine() considers only "\r", "\n" and "\r\n" to be line separators. We must not permit additional separator
+     * characters.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testReadLineIgnoresEbcdic85Characters() throws IOException {
+        assertLines("A\u0085B", "A\u0085B");
+    }
+
+    @Test
+    public void testReadLineSeparators() throws IOException {
+        assertLines("A\nB\nC", "A", "B", "C");
+        assertLines("A\rB\rC", "A", "B", "C");
+        assertLines("A\r\nB\r\nC", "A", "B", "C");
+        assertLines("A\n\rB\n\rC", "A", "", "B", "", "C");
+        assertLines("A\n\nB\n\nC", "A", "", "B", "", "C");
+        assertLines("A\r\rB\r\rC", "A", "", "B", "", "C");
+        assertLines("A\n\n", "A", "");
+        assertLines("A\n\r", "A", "");
+        assertLines("A\r\r", "A", "");
+        assertLines("A\r\n", "A");
+        assertLines("A\r\n\r\n", "A", "");
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#ready()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testReady() throws IOException {
+        // Test for method boolean UnsynchronizedBufferedReader.ready()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        assertTrue(br.ready());
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#reset()}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testReset() throws IOException {
+        // Test for method void UnsynchronizedBufferedReader.reset()
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        br.skip(500);
+        br.mark(900);
+        br.skip(500);
+        br.reset();
+        final char[] buf = new char[testString.length()];
+        br.read(buf, 0, 500);
+        assertTrue(testString.substring(500, 1000).equals(new String(buf, 0, 500)));
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        br.skip(500);
+        assertThrows(IOException.class, br::reset);
+    }
+
+    @Test
+    public void testReset_IOException() throws Exception {
+        final int[] expected = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', -1 };
+        br = new UnsynchronizedBufferedReader(new StringReader("1234567890"), 9);
+        br.mark(9);
+        for (int i = 0; i < 11; i++) {
+            assertEquals(expected[i], br.read());
+        }
+        assertThrows(IOException.class, br::reset);
+        for (int i = 0; i < 11; i++) {
+            assertEquals(-1, br.read());
+        }
+
+        br = new UnsynchronizedBufferedReader(new StringReader("1234567890"));
+        br.mark(10);
+        for (int i = 0; i < 10; i++) {
+            assertEquals(expected[i], br.read());
+        }
+        br.reset();
+        for (int i = 0; i < 11; i++) {
+            assertEquals(expected[i], br.read());
+        }
+    }
+
+    /**
+     * Tests {@link UnsynchronizedBufferedReader#skip(long)}.
+     *
+     * @throws IOException test failure.
+     */
+    @Test
+    public void testSkip() throws IOException {
+        // Test for method long UnsynchronizedBufferedReader.skip(long)
+        br = new UnsynchronizedBufferedReader(new StringReader(testString));
+        br.skip(500);
+        final char[] buf = new char[testString.length()];
+        br.read(buf, 0, 500);
+        assertTrue(testString.substring(500, 1000).equals(new String(buf, 0, 500)));
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java b/src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java
index 866c833b..a436f8f8 100644
--- a/src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java
@@ -36,7 +36,7 @@ public class UnsynchronizedByteArrayInputStreamTest {
     private UnsynchronizedByteArrayInputStream newStream(final byte[] buffer) {
         try {
             return UnsynchronizedByteArrayInputStream.builder().setByteArray(buffer).get();
-        } catch (IOException e) {
+        } catch (final IOException e) {
             fail("Should never happen because no conversion is needed.", e);
             return null;
         }
@@ -45,7 +45,7 @@ private UnsynchronizedByteArrayInputStream newStream(final byte[] buffer) {
     private UnsynchronizedByteArrayInputStream newStream(final byte[] buffer, final int offset) {
         try {
             return UnsynchronizedByteArrayInputStream.builder().setByteArray(buffer).setOffset(offset).get();
-        } catch (IOException e) {
+        } catch (final IOException e) {
             fail("Should never happen because no conversion is needed.", e);
             return null;
         }
@@ -54,7 +54,7 @@ private UnsynchronizedByteArrayInputStream newStream(final byte[] buffer, final
     private UnsynchronizedByteArrayInputStream newStream(final byte[] buffer, final int offset, final int length) {
         try {
             return UnsynchronizedByteArrayInputStream.builder().setByteArray(buffer).setOffset(offset).setLength(length).get();
-        } catch (IOException e) {
+        } catch (final IOException e) {
             fail("Should never happen because no conversion is needed.", e);
             return null;
         }
diff --git a/src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java b/src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java
index e09745a1..dd1f8ac8 100644
--- a/src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java
@@ -1,26 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package org.apache.commons.io.input;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.StandardCharsets;
@@ -129,8 +129,8 @@ public void test_read() throws IOException {
     @Test
     public void test_read$B() throws IOException {
         final byte[] buf1 = new byte[100];
-        is.read(buf1);
-        assertTrue(new String(buf1, 0, buf1.length, "UTF-8").equals(DATA.substring(0, 100)), "Failed to read correct data");
+        assertEquals(buf1.length, is.read(buf1));
+        assertTrue(new String(buf1, 0, buf1.length, StandardCharsets.UTF_8).equals(DATA.substring(0, 100)), "Failed to read correct data");
     }
 
     /**
@@ -144,7 +144,7 @@ public void test_read() throws IOException {
         is.skip(3000);
         is.mark(1000);
         is.read(buf1, 0, buf1.length);
-        assertTrue(new String(buf1, 0, buf1.length, "UTF-8").equals(DATA.substring(3000, 3100)), "Failed to read correct data");
+        assertTrue(new String(buf1, 0, buf1.length, StandardCharsets.UTF_8).equals(DATA.substring(3000, 3100)), "Failed to read correct data");
     }
 
     /**
@@ -166,6 +166,6 @@ public void test_skipJ() throws IOException {
         final byte[] buf1 = new byte[10];
         is.skip(1000);
         is.read(buf1, 0, buf1.length);
-        assertTrue(new String(buf1, 0, buf1.length, "UTF-8").equals(DATA.substring(1000, 1010)), "Failed to skip to correct position");
+        assertTrue(new String(buf1, 0, buf1.length, StandardCharsets.UTF_8).equals(DATA.substring(1000, 1010)), "Failed to skip to correct position");
     }
 }
diff --git a/src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java b/src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java
index 81d17fa1..62096ee5 100644
--- a/src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java
@@ -17,60 +17,185 @@
 package org.apache.commons.io.input;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 
 public class WindowsLineEndingInputStreamTest {
+
+    private String roundtripReadByte(final String msg) throws IOException {
+        return roundtripReadByte(msg, true);
+    }
+
+    private String roundtripReadByte(final String msg, final boolean ensure) throws IOException {
+        // read(byte[])
+        try (WindowsLineEndingInputStream lf = new WindowsLineEndingInputStream(
+                CharSequenceInputStream.builder().setCharSequence(msg).setCharset(StandardCharsets.UTF_8).get(), ensure)) {
+            final byte[] buf = new byte[100];
+            int i = 0;
+            while (i < buf.length) {
+                final int read = lf.read();
+                if (read < 0) {
+                    break;
+                }
+                buf[i++] = (byte) read;
+            }
+            return new String(buf, 0, i, StandardCharsets.UTF_8);
+        }
+    }
+
+    private String roundtripReadByteArray(final String msg) throws IOException {
+        return roundtripReadByteArray(msg, true);
+    }
+
+    private String roundtripReadByteArray(final String msg, final boolean ensure) throws IOException {
+        // read(byte[])
+        try (WindowsLineEndingInputStream lf = new WindowsLineEndingInputStream(
+                CharSequenceInputStream.builder().setCharSequence(msg).setCharset(StandardCharsets.UTF_8).get(), ensure)) {
+            final byte[] buf = new byte[100];
+            final int read = lf.read(buf);
+            return new String(buf, 0, read, StandardCharsets.UTF_8);
+        }
+    }
+
+    private String roundtripReadByteArrayIndex(final String msg) throws IOException {
+        return roundtripReadByteArrayIndex(msg, true);
+    }
+
+    private String roundtripReadByteArrayIndex(final String msg, final boolean ensure) throws IOException {
+        // read(byte[])
+        try (WindowsLineEndingInputStream lf = new WindowsLineEndingInputStream(
+                CharSequenceInputStream.builder().setCharSequence(msg).setCharset(StandardCharsets.UTF_8).get(), ensure)) {
+            final byte[] buf = new byte[100];
+            final int read = lf.read(buf, 0, 100);
+            return new String(buf, 0, read, StandardCharsets.UTF_8);
+        }
+    }
+
     @Test
-    public void inTheMiddleOfTheLine() throws Exception {
-        assertEquals("a\r\nbc\r\n", roundtrip("a\r\nbc"));
+    public void testInTheMiddleOfTheLine_Byte() throws Exception {
+        assertEquals("a\r\nbc\r\n", roundtripReadByte("a\r\nbc"));
     }
 
     @Test
-    public void linuxLineFeeds() throws Exception {
-        final String roundtrip = roundtrip("ab\nc", false);
-        assertEquals("ab\r\nc", roundtrip);
+    public void testInTheMiddleOfTheLine_ByteArray() throws Exception {
+        assertEquals("a\r\nbc\r\n", roundtripReadByteArray("a\r\nbc"));
     }
 
     @Test
-    public void malformed() throws Exception {
-        assertEquals("a\rbc", roundtrip("a\rbc", false));
+    public void testInTheMiddleOfTheLine_ByteArrayIndex() throws Exception {
+        assertEquals("a\r\nbc\r\n", roundtripReadByteArrayIndex("a\r\nbc"));
     }
 
     @Test
-    public void multipleBlankLines() throws Exception {
-        assertEquals("a\r\n\r\nbc\r\n", roundtrip("a\r\n\r\nbc"));
+    public void testLinuxLineFeeds_Byte() throws Exception {
+        assertEquals("ab\r\nc", roundtripReadByte("ab\nc", false));
     }
 
     @Test
-    public void retainLineFeed() throws Exception {
-        assertEquals("a\r\n\r\n", roundtrip("a\r\n\r\n", false));
-        assertEquals("a", roundtrip("a", false));
+    public void testLinuxLineFeeds_ByteArray() throws Exception {
+        assertEquals("ab\r\nc", roundtripReadByteArray("ab\nc", false));
     }
 
-    private String roundtrip(final String msg) throws IOException {
-        return roundtrip(msg, true);
+    @Test
+    public void testLinuxLineFeeds_ByteArrayIndex() throws Exception {
+        assertEquals("ab\r\nc", roundtripReadByteArrayIndex("ab\nc", false));
     }
 
-    private String roundtrip(final String msg, final boolean ensure) throws IOException {
-        try (WindowsLineEndingInputStream lf = new WindowsLineEndingInputStream(
-                CharSequenceInputStream.builder().setCharSequence(msg).setCharset(StandardCharsets.UTF_8).get(), ensure)) {
-            final byte[] buf = new byte[100];
-            final int read = lf.read(buf);
-            return new String(buf, 0, read, StandardCharsets.UTF_8);
-        }
+    @Test
+    public void testMalformed_Byte() throws Exception {
+        assertEquals("a\rbc", roundtripReadByte("a\rbc", false));
+    }
+
+    @Test
+    public void testMalformed_ByteArray() throws Exception {
+        assertEquals("a\rbc", roundtripReadByteArray("a\rbc", false));
+    }
+
+    @Test
+    public void testMalformed_ByteArrayIndex() throws Exception {
+        assertEquals("a\rbc", roundtripReadByteArrayIndex("a\rbc", false));
+    }
+
+    @ParameterizedTest
+    @ValueSource(booleans = { false, true })
+    public void testMark(final boolean ensureLineFeedAtEndOfFile) {
+        assertThrows(UnsupportedOperationException.class, () -> new WindowsLineEndingInputStream(new NullInputStream(), true).mark(1));
+    }
+
+    @SuppressWarnings("resource")
+    @ParameterizedTest
+    @ValueSource(booleans = { false, true })
+    public void testMarkSupported(final boolean ensureLineFeedAtEndOfFile) {
+        assertFalse(new WindowsLineEndingInputStream(new NullInputStream(), true).markSupported());
+    }
+
+    @Test
+    public void testMultipleBlankLines_Byte() throws Exception {
+        assertEquals("a\r\n\r\nbc\r\n", roundtripReadByte("a\r\n\r\nbc"));
+    }
+
+    @Test
+    public void testMultipleBlankLines_ByteArray() throws Exception {
+        assertEquals("a\r\n\r\nbc\r\n", roundtripReadByteArray("a\r\n\r\nbc"));
+    }
+
+    @Test
+    public void testMultipleBlankLines_ByteArrayIndex() throws Exception {
+        assertEquals("a\r\n\r\nbc\r\n", roundtripReadByteArrayIndex("a\r\n\r\nbc"));
+    }
+
+    @Test
+    public void testRetainLineFeed_Byte() throws Exception {
+        assertEquals("a\r\n\r\n", roundtripReadByte("a\r\n\r\n", false));
+        assertEquals("a", roundtripReadByte("a", false));
+    }
+
+    @Test
+    public void testRetainLineFeed_ByteArray() throws Exception {
+        assertEquals("a\r\n\r\n", roundtripReadByteArray("a\r\n\r\n", false));
+        assertEquals("a", roundtripReadByteArray("a", false));
+    }
+
+    @Test
+    public void testRetainLineFeed_ByteArrayIndex() throws Exception {
+        assertEquals("a\r\n\r\n", roundtripReadByteArray("a\r\n\r\n", false));
+        assertEquals("a", roundtripReadByteArrayIndex("a", false));
+    }
+
+    @Test
+    public void testSimpleString_Byte() throws Exception {
+        assertEquals("abc\r\n", roundtripReadByte("abc"));
+    }
+
+    @Test
+    public void testSimpleString_ByteArray() throws Exception {
+        assertEquals("abc\r\n", roundtripReadByteArray("abc"));
+    }
+
+    @Test
+    public void testSimpleString_ByteArrayIndex() throws Exception {
+        assertEquals("abc\r\n", roundtripReadByteArrayIndex("abc"));
+    }
+
+    @Test
+    public void testTwoLinesAtEnd_Byte() throws Exception {
+        assertEquals("a\r\n\r\n", roundtripReadByte("a\r\n\r\n"));
     }
 
     @Test
-    public void simpleString() throws Exception {
-        assertEquals("abc\r\n", roundtrip("abc"));
+    public void testTwoLinesAtEnd_ByteArray() throws Exception {
+        assertEquals("a\r\n\r\n", roundtripReadByteArray("a\r\n\r\n"));
     }
 
     @Test
-    public void twoLinesAtEnd() throws Exception {
-        assertEquals("a\r\n\r\n", roundtrip("a\r\n\r\n"));
+    public void testTwoLinesAtEnd_ByteArrayIndex() throws Exception {
+        assertEquals("a\r\n\r\n", roundtripReadByteArrayIndex("a\r\n\r\n"));
     }
 }
diff --git a/src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java b/src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java
index 63d587a8..385a12b7 100644
--- a/src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java
+++ b/src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java
@@ -49,6 +49,9 @@
 import org.junit.jupiter.params.provider.MethodSource;
 import org.junitpioneer.jupiter.DefaultLocale;
 
+/**
+ * Tests {@link XmlStreamReader}.
+ */
 public class XmlStreamReaderTest {
 
     private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();
@@ -60,6 +63,9 @@ public class XmlStreamReaderTest {
     private static final String UTF_32LE = "UTF-32LE";
     private static final String UTF_32BE = "UTF-32BE";
     private static final String UTF_8 = StandardCharsets.UTF_8.name();
+
+    private static final String XML7 = "xml-prolog-encoding-no-version";
+    private static final String XML6 = "xml-prolog-encoding-new-line";
     private static final String XML5 = "xml-prolog-encoding-spaced-single-quotes";
     private static final String XML4 = "xml-prolog-encoding-single-quotes";
     private static final String XML3 = "xml-prolog-encoding-double-quotes";
@@ -103,6 +109,12 @@ public class XmlStreamReaderTest {
     private static final MessageFormat XML_WITH_PROLOG = new MessageFormat(
             "<?xml version=\"1.0\"?>\n<root>{2}</root>");
 
+    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_NEW_LINES = new MessageFormat(
+            "<?xml\nversion\n=\n\"1.0\"\nencoding\n=\n\"{1}\"\n?>\n<root>{2}</root>");
+
+    private static final MessageFormat XML_EXTERNAL_PARSED_ENTITY_NO_VERSION = new MessageFormat(
+            "<?xml\nencoding\n=\n\"{1}\"\n?>\n<root>{2}</root>");
+
     private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES = new MessageFormat(
             "<?xml version=\"1.0\" encoding=\"{1}\"?>\n<root>{2}</root>");
 
@@ -123,6 +135,8 @@ public class XmlStreamReaderTest {
         XMLs.put(XML3, XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES);
         XMLs.put(XML4, XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES);
         XMLs.put(XML5, XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES);
+        XMLs.put(XML6, XML_WITH_PROLOG_AND_ENCODING_NEW_LINES);
+        XMLs.put(XML7, XML_EXTERNAL_PARSED_ENTITY_NO_VERSION);
     }
 
     /**
@@ -198,7 +212,7 @@ public void testAlternateDefaultEncoding(final String contentType, final String
     private void testAlternateDefaultEncoding(final String streamEnc, final String alternateEnc, final XmlStreamReader xmlReader) {
         assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);
         if (!streamEnc.equals(UTF_16)) {
-            // we can not assert things here because UTF-8, US-ASCII and
+            // we cannot assert things here because UTF-8, US-ASCII and
             // ISO-8859-1 look alike for the chars used for detection
             // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)
             final String enc = alternateEnc != null ? alternateEnc : streamEnc;
@@ -435,7 +449,7 @@ public void testHttpValid(final String cT, final String bomEnc, final String str
         try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);
             XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false)) {
             if (!streamEnc.equals(UTF_16)) {
-                // we can not assert things here because UTF-8, US-ASCII and
+                // we cannot assert things here because UTF-8, US-ASCII and
                 // ISO-8859-1 look alike for the chars used for detection
                 // (niallp 2010-10-06 - I re-instated the check below and removed the 2 tests that failed)
                 assertEquals(xmlReader.getEncoding(), streamEnc);
@@ -624,5 +638,15 @@ protected void testRawNoBomValid(final String encoding) throws Exception {
         xmlReader = new XmlStreamReader(is);
         assertEquals(xmlReader.getEncoding(), encoding);
         xmlReader.close();
-    }
+
+        is = getXmlInputStream("no-bom", XML6, encoding, encoding);
+        xmlReader = new XmlStreamReader(is);
+        assertEquals(xmlReader.getEncoding(), encoding);
+        xmlReader.close();
+
+        is = getXmlInputStream("no-bom", XML7, encoding, encoding);
+        xmlReader = new XmlStreamReader(is);
+        assertEquals(xmlReader.getEncoding(), encoding);
+        xmlReader.close();
+}
 }
diff --git a/src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java b/src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java
index 821df8a6..6be9e47b 100644
--- a/src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java
+++ b/src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java
@@ -56,7 +56,7 @@ private static final class MockXmlStreamReader extends XmlStreamReader {
     protected String calculateHttpEncoding(final String httpContentType, final String bomEnc, final String xmlGuessEnc,
         final String xmlEnc, final boolean lenient, final String defaultEncoding) throws IOException {
         try (MockXmlStreamReader mock = new MockXmlStreamReader(defaultEncoding)) {
-            return mock.calculateHttpEncoding(httpContentType, bomEnc, xmlGuessEnc, xmlEnc, lenient);
+            return mock.calculateHttpEncoding(bomEnc, xmlGuessEnc, xmlEnc, lenient, httpContentType);
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java b/src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java
index a08405e4..f80b10c8 100644
--- a/src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java
@@ -17,7 +17,9 @@
 package org.apache.commons.io.input.buffer;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -25,16 +27,26 @@
 
 import org.junit.jupiter.api.Test;
 
+/**
+ * Tests {@link CircularBufferInputStream}.
+ */
 public class CircularBufferInputStreamTest {
-    private final Random rnd = new Random(1530960934483L); // System.currentTimeMillis(), when this test was written.
-                                                           // Always using the same seed should ensure a reproducible test.
+
+    /**
+     * System.currentTimeMillis(), when this test was written. Always using the same seed should ensure a reproducible test.
+     */
+    private final Random random = new Random(1530960934483L);
+
+    void asssertNotEof(final int offset, final int res) {
+        assertNotEquals(-1, res, () -> "Unexpected EOF at offset " + offset);
+    }
 
     /**
      * Create a large, but random input buffer.
      */
     private byte[] newInputBuffer() {
-        final byte[] buffer = new byte[16 * 512 + rnd.nextInt(512)];
-        rnd.nextBytes(buffer);
+        final byte[] buffer = new byte[16 * 512 + random.nextInt(512)];
+        random.nextBytes(buffer);
         return buffer;
     }
 
@@ -62,36 +74,27 @@ public void testRandomRead() throws Exception {
         int offset = 0;
         final byte[] readBuffer = new byte[256];
         while (offset < bufferCopy.length) {
-            switch (rnd.nextInt(2)) {
+            switch (random.nextInt(2)) {
             case 0: {
                 final int res = cbis.read();
-                if (res == -1) {
-                    throw new IllegalStateException("Unexpected EOF at offset " + offset);
-                }
-                if (inputBuffer[offset] != (byte) res) { // compare as bytes
-                    throw new IllegalStateException("Expected " + inputBuffer[offset] + " at offset " + offset + ", got " + res);
-                }
+                asssertNotEof(offset, res);
+                // MUST compare bytes
+                assertEquals(inputBuffer[offset], (byte) res, "Expected " + inputBuffer[offset] + " at offset " + offset + ", got " + res);
                 ++offset;
                 break;
             }
             case 1: {
-                final int res = cbis.read(readBuffer, 0, rnd.nextInt(readBuffer.length + 1));
-                if (res == -1) {
-                    throw new IllegalStateException("Unexpected EOF at offset " + offset);
-                }
-                if (res == 0) {
-                    throw new IllegalStateException("Unexpected zero-byte-result at offset " + offset);
-                }
+                final int res = cbis.read(readBuffer, 0, random.nextInt(readBuffer.length + 1));
+                asssertNotEof(offset, res);
+                assertNotEquals(0, res, "Unexpected zero-byte-result at offset " + offset);
                 for (int i = 0; i < res; i++) {
-                    if (inputBuffer[offset] != readBuffer[i]) {
-                        throw new IllegalStateException("Expected " + inputBuffer[offset] + " at offset " + offset + ", got " + readBuffer[i]);
-                    }
+                    assertEquals(inputBuffer[offset], readBuffer[i], "Expected " + inputBuffer[offset] + " at offset " + offset + ", got " + readBuffer[i]);
                     ++offset;
                 }
                 break;
             }
             default:
-                throw new IllegalStateException("Unexpected random choice value");
+                fail("Unexpected random choice value");
             }
         }
         assertTrue(true, "Test finished OK");
diff --git a/src/test/java/org/apache/commons/io/input/buffer/CircularByteBufferTest.java b/src/test/java/org/apache/commons/io/input/buffer/CircularByteBufferTest.java
new file mode 100644
index 00000000..da92e1de
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/input/buffer/CircularByteBufferTest.java
@@ -0,0 +1,165 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input.buffer;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.nio.charset.StandardCharsets;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link CircularByteBuffer}.
+ */
+public class CircularByteBufferTest {
+
+    @Test
+    public void testAddByteSmallestBuffer() {
+        final CircularByteBuffer cbb = new CircularByteBuffer(1);
+        cbb.add((byte) 1);
+        assertEquals(1, cbb.read());
+        cbb.add((byte) 2);
+        assertEquals(2, cbb.read());
+    }
+
+    @Test
+    public void testAddInvalidOffset() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        assertThrows(IllegalArgumentException.class, () -> cbb.add(new byte[] { 1, 2, 3 }, -1, 3));
+    }
+
+    @Test
+    public void testAddNegativeLength() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        final byte[] targetBuffer = { 1, 2, 3 };
+        assertThrows(IllegalArgumentException.class, () -> cbb.add(targetBuffer, 0, -1));
+    }
+
+    @Test
+    public void testAddNullBuffer() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        assertThrows(NullPointerException.class, () -> cbb.add(null, 0, 3));
+    }
+
+    /**
+     * Tests for add function with 3 arguments of type byte[], int and int.
+     */
+    @Test
+    public void testAddValidData() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        final int length = 3;
+        cbb.add(new byte[] { 3, 6, 9 }, 0, length);
+        assertEquals(length, cbb.getCurrentNumberOfBytes());
+    }
+
+    @Test
+    public void testClear() {
+       final byte[] data = { 1, 2, 3 };
+       final CircularByteBuffer buffer = new CircularByteBuffer(10);
+       assertEquals(0, buffer.getCurrentNumberOfBytes());
+       assertFalse(buffer.hasBytes());
+
+       buffer.add(data, 0, data.length);
+       assertEquals(3, buffer.getCurrentNumberOfBytes());
+       assertEquals(7, buffer.getSpace());
+       assertTrue(buffer.hasBytes());
+       assertTrue(buffer.hasSpace());
+
+       buffer.clear();
+       assertEquals(0, buffer.getCurrentNumberOfBytes());
+       assertEquals(10, buffer.getSpace());
+       assertFalse(buffer.hasBytes());
+       assertTrue(buffer.hasSpace());
+    }
+
+    @Test
+    public void testHasSpace() {
+        final CircularByteBuffer cbb = new CircularByteBuffer(1);
+        assertTrue(cbb.hasSpace());
+        cbb.add((byte) 1);
+        assertFalse(cbb.hasSpace());
+        assertEquals(1, cbb.read());
+        assertTrue(cbb.hasSpace());
+        cbb.add((byte) 2);
+        assertFalse(cbb.hasSpace());
+        assertEquals(2, cbb.read());
+        assertTrue(cbb.hasSpace());
+    }
+
+    @Test
+    public void testHasSpaceInt() {
+        final CircularByteBuffer cbb = new CircularByteBuffer(1);
+        assertTrue(cbb.hasSpace(1));
+        cbb.add((byte) 1);
+        assertFalse(cbb.hasSpace(1));
+        assertEquals(1, cbb.read());
+        assertTrue(cbb.hasSpace(1));
+        cbb.add((byte) 2);
+        assertFalse(cbb.hasSpace(1));
+        assertEquals(2, cbb.read());
+        assertTrue(cbb.hasSpace(1));
+    }
+
+    @Test
+    public void testPeekWithExcessiveLength() {
+        assertFalse(new CircularByteBuffer().peek(new byte[] { 1, 3, 5, 7, 9 }, 0, 6));
+    }
+
+    @Test
+    public void testPeekWithInvalidOffset() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> cbb.peek(new byte[] { 2, 4, 6, 8, 10 }, -1, 5));
+        assertEquals("Illegal offset: -1", e.getMessage());
+    }
+
+    @Test
+    public void testPeekWithNegativeLength() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> cbb.peek(new byte[] { 1, 4, 3 }, 0, -1));
+        assertEquals("Illegal length: -1", e.getMessage());
+    }
+
+    // Tests for peek function
+    @Test
+    public void testPeekWithValidArguments() {
+        assertFalse(new CircularByteBuffer().peek(new byte[] { 5, 10, 15, 20, 25 }, 0, 5));
+    }
+
+    @Test
+    public void testReadByteArray() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        final String string = "0123456789";
+        final byte[] bytesIn = string.getBytes(StandardCharsets.UTF_8);
+        cbb.add(bytesIn, 0, 10);
+        final byte[] bytesOut = new byte[10];
+        cbb.read(bytesOut, 0, 10);
+        assertEquals(string, new String(bytesOut, StandardCharsets.UTF_8));
+    }
+
+    @Test
+    public void testReadByteArrayIllegalArgumentException() {
+        final CircularByteBuffer cbb = new CircularByteBuffer();
+        final byte[] bytesOut = new byte[10];
+        // targetOffset < 0
+        assertThrows(IllegalArgumentException.class, () -> cbb.read(bytesOut, -1, 10));
+        // targetOffset >= targetBuffer.length
+        assertThrows(IllegalArgumentException.class, () -> cbb.read(bytesOut, 0, bytesOut.length + 1));
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/input/buffer/PeekableInputStreamTest.java b/src/test/java/org/apache/commons/io/input/buffer/PeekableInputStreamTest.java
new file mode 100644
index 00000000..b79ba8bf
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/input/buffer/PeekableInputStreamTest.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input.buffer;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.Random;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests {@link PeekableInputStream}.
+ */
+public class PeekableInputStreamTest {
+
+    /**
+     * System.currentTimeMillis(), when this test was written. Always using the same seed should ensure a reproducible test.
+     */
+    private final Random random = new Random(1530960934483L);
+
+    void asssertNotEof(final int offset, final int res) {
+        assertNotEquals(-1, res, () -> "Unexpected EOF at offset " + offset);
+    }
+
+    /**
+     * Create a large, but random input buffer.
+     */
+    private byte[] newInputBuffer() {
+        final byte[] buffer = new byte[16 * 512 + random.nextInt(512)];
+        random.nextBytes(buffer);
+        return buffer;
+    }
+
+    @Test
+    public void testIO683() throws IOException {
+        final byte[] buffer = {0, 1, -2, -2, -1, 4};
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer); final PeekableInputStream cbis = new PeekableInputStream(bais)) {
+            int b;
+            int i = 0;
+            while ((b = cbis.read()) != -1) {
+                assertEquals(buffer[i] & 0xFF, b, "byte at index " + i + " should be equal");
+                i++;
+            }
+            assertEquals(buffer.length, i, "Should have read all the bytes");
+        }
+    }
+
+    @Test
+    public void testRandomRead() throws Exception {
+        final byte[] inputBuffer = newInputBuffer();
+        final byte[] bufferCopy = new byte[inputBuffer.length];
+        final ByteArrayInputStream bais = new ByteArrayInputStream(inputBuffer);
+        @SuppressWarnings("resource")
+        final PeekableInputStream cbis = new PeekableInputStream(bais, 253);
+        int offset = 0;
+        final byte[] readBuffer = new byte[256];
+        while (offset < bufferCopy.length) {
+            switch (random.nextInt(2)) {
+            case 0: {
+                final int res = cbis.read();
+                asssertNotEof(offset, res);
+                // MUST compare bytes
+                assertEquals(inputBuffer[offset], (byte) res, "Expected " + inputBuffer[offset] + " at offset " + offset + ", got " + res);
+                ++offset;
+                break;
+            }
+            case 1: {
+                final int res = cbis.read(readBuffer, 0, random.nextInt(readBuffer.length + 1));
+                asssertNotEof(offset, res);
+                assertNotEquals(0, res, "Unexpected zero-byte-result at offset " + offset);
+                for (int i = 0; i < res; i++) {
+                    assertEquals(inputBuffer[offset], readBuffer[i], "Expected " + inputBuffer[offset] + " at offset " + offset + ", got " + readBuffer[i]);
+                    ++offset;
+                }
+                break;
+            }
+            default:
+                fail("Unexpected random choice value");
+            }
+        }
+        assertTrue(true, "Test finished OK");
+    }
+}
diff --git a/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java b/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java
index a8299dc7..f1d7526b 100644
--- a/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java
+++ b/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java
@@ -58,11 +58,11 @@
  * By default the charset encoding detection is lenient, the constructor with
  * the lenient flag can be used for a script (following HTTP MIME and XML
  * specifications). All this is nicely explained by Mark Pilgrim in his blog, <a
- * href="http://diveintomark.org/archives/2004/02/13/xml-media-types">
+ * href="https://diveintomark.org/archives/2004/02/13/xml-media-types">
  * Determining the character encoding of a feed</a>.
  * </p>
  * <p>
- * Originally developed for <a href="http://rome.dev.java.net">ROME</a> under
+ * Originally developed for <a href="https://rome.dev.java.net">ROME</a> under
  * Apache License 2.0.
  * </p>
  *
diff --git a/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java b/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java
index 97e377b3..3391423e 100644
--- a/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java
+++ b/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java
@@ -20,7 +20,7 @@
 
 /**
  * The XmlStreamReaderException is thrown by the XmlStreamReader constructors if
- * the charset encoding can not be determined according to the XML 1.0
+ * the charset encoding cannot be determined according to the XML 1.0
  * specification and RFC 3023.
  * <p>
  * The exception returns the unconsumed InputStream to allow the application to
diff --git a/src/test/java/org/apache/commons/io/jmh/PathUtilsContentEqualsBenchmark.java b/src/test/java/org/apache/commons/io/jmh/PathUtilsContentEqualsBenchmark.java
index 20e49e71..5a63f5ed 100644
--- a/src/test/java/org/apache/commons/io/jmh/PathUtilsContentEqualsBenchmark.java
+++ b/src/test/java/org/apache/commons/io/jmh/PathUtilsContentEqualsBenchmark.java
@@ -72,7 +72,7 @@ public class PathUtilsContentEqualsBenchmark {
             Arrays.fill(bytes1, (byte) 1);
             Files.write(bigFile1, bytes1);
             Files.copy(bigFile1, bigFile2, StandardCopyOption.REPLACE_EXISTING);
-        } catch (IOException e) {
+        } catch (final IOException e) {
             throw new UncheckedIOException(e);
         }
     }
diff --git a/src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java b/src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java
index 6f076d09..d807179f 100644
--- a/src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java
+++ b/src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java
@@ -98,7 +98,7 @@ protected void checkCollectionSizes(String label,
      * @param fileFilter The file filter to apply
      */
     protected void createObserver(final File file, final FileFilter fileFilter) {
-        observer = new FileAlterationObserver(file, fileFilter);
+        observer = FileAlterationObserver.builder().setFile(file).setFileFilter(fileFilter).getUnchecked();
         observer.addListener(listener);
         observer.addListener(new FileAlterationListenerAdaptor());
         try {
diff --git a/src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java b/src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java
index 81922268..a187790d 100644
--- a/src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java
+++ b/src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java
@@ -58,7 +58,7 @@ public void clear() {
     }
 
     /**
-     * Return the set of changed directories.
+     * Gets the set of changed directories.
      *
      * @return Directories which have changed
      */
@@ -67,7 +67,7 @@ public Collection<File> getChangedDirectories() {
     }
 
     /**
-     * Return the set of changed files.
+     * Gets the set of changed files.
      *
      * @return Files which have changed
      */
@@ -76,7 +76,7 @@ public Collection<File> getChangedFiles() {
     }
 
     /**
-     * Return the set of created directories.
+     * Gets the set of created directories.
      *
      * @return Directories which have been created
      */
@@ -85,7 +85,7 @@ public Collection<File> getCreatedDirectories() {
     }
 
     /**
-     * Return the set of created files.
+     * Gets the set of created files.
      *
      * @return Files which have been created
      */
@@ -94,7 +94,7 @@ public Collection<File> getCreatedFiles() {
     }
 
     /**
-     * Return the set of deleted directories.
+     * Gets the set of deleted directories.
      *
      * @return Directories which been deleted
      */
@@ -103,7 +103,7 @@ public Collection<File> getDeletedDirectories() {
     }
 
     /**
-     * Return the set of deleted files.
+     * Gets the set of deleted files.
      *
      * @return Files which been deleted
      */
diff --git a/src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java b/src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java
index 9399bf17..f1fb99df 100644
--- a/src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java
+++ b/src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java
@@ -41,8 +41,7 @@
 public class FileAlterationMonitorTest extends AbstractMonitorTest {
 
     /**
-     * Construct a new test case.
-     *
+     * Constructs a new test case.
      */
     public FileAlterationMonitorTest() {
         listener = new CollectionFileListener(false);
diff --git a/src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java b/src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java
index 5edc6bb5..29db41d5 100644
--- a/src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java
+++ b/src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java
@@ -26,8 +26,12 @@
 import java.util.Iterator;
 
 import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.FilenameUtils;
+import org.apache.commons.io.IOCase;
+import org.apache.commons.io.comparator.NameFileComparator;
 import org.apache.commons.io.filefilter.CanReadFileFilter;
 import org.apache.commons.io.filefilter.FileFilterUtils;
+import org.apache.commons.io.monitor.FileAlterationObserver.Builder;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -35,9 +39,10 @@
  */
 public class FileAlterationObserverTest extends AbstractMonitorTest {
 
+    private static final String PATH_STRING_FIXTURE = "/foo";
+
     /**
-     * Construct a new test case.
-     *
+     * Constructs a new instance.
      */
     public FileAlterationObserverTest() {
         listener = new CollectionFileListener(true);
@@ -50,12 +55,16 @@ protected void checkAndNotify() {
         observer.checkAndNotify();
     }
 
+    private String directoryToUnixString(final FileAlterationObserver observer) {
+        return FilenameUtils.separatorsToUnix(observer.getDirectory().toString());
+    }
+
     /**
      * Test add/remove listeners.
      */
     @Test
     public void testAddRemoveListeners() {
-        final FileAlterationObserver observer = new FileAlterationObserver("/foo");
+        final FileAlterationObserver observer = FileAlterationObserver.builder().setFile(PATH_STRING_FIXTURE).getUnchecked();
         // Null Listener
         observer.addListener(null);
         assertFalse(observer.getListeners().iterator().hasNext(), "Listeners[1]");
@@ -75,9 +84,134 @@ public void testAddRemoveListeners() {
         assertFalse(observer.getListeners().iterator().hasNext(), "Listeners[5]");
     }
 
+    @Test
+    public void testBuilder_File() {
+        final File file = new File(PATH_STRING_FIXTURE);
+        final FileAlterationObserver observer = FileAlterationObserver.builder().setFile(file).getUnchecked();
+        assertEquals(file, observer.getDirectory());
+    }
+
+    @Test
+    public void testBuilder_File_FileFilter() {
+        final File file = new File(PATH_STRING_FIXTURE);
+        // @formatter:off
+        final FileAlterationObserver observer = FileAlterationObserver.builder()
+                .setFile(file)
+                .setFileFilter(CanReadFileFilter.CAN_READ)
+                .getUnchecked();
+        // @formatter:on
+        assertEquals(file, observer.getDirectory());
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+    }
+
+    @Test
+    public void testBuilder_File_FileFilter_IOCase() {
+        final File file = new File(PATH_STRING_FIXTURE);
+        // @formatter:off
+        final FileAlterationObserver observer = FileAlterationObserver.builder()
+                .setFile(file)
+                .setFileFilter(CanReadFileFilter.CAN_READ)
+                .setIOCase(IOCase.INSENSITIVE)
+                .getUnchecked();
+        // @formatter:on
+        assertEquals(file, observer.getDirectory());
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+        assertEquals(NameFileComparator.NAME_INSENSITIVE_COMPARATOR, observer.getComparator());
+    }
+
+    @Test
+    public void testBuilder_String() {
+        final String file = PATH_STRING_FIXTURE;
+        final FileAlterationObserver observer = FileAlterationObserver.builder().setFile(file).getUnchecked();
+        assertEquals(file, directoryToUnixString(observer));
+    }
+
+    @Test
+    public void testBuilder_String_FileFilter() {
+        final String file = PATH_STRING_FIXTURE;
+        // @formatter:off
+        final FileAlterationObserver observer = FileAlterationObserver.builder()
+                .setFile(file)
+                .setFileFilter(CanReadFileFilter.CAN_READ)
+                .getUnchecked();
+        // @formatter:on
+        assertEquals(file, directoryToUnixString(observer));
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+    }
+
+    @Test
+    public void testBuilder_String_FileFilter_IOCase() {
+        final String file = PATH_STRING_FIXTURE;
+        // @formatter:off
+        final FileAlterationObserver observer = FileAlterationObserver.builder()
+                .setFile(file)
+                .setFileFilter(CanReadFileFilter.CAN_READ)
+                .setIOCase(IOCase.INSENSITIVE)
+                .getUnchecked();
+        // @formatter:on
+        assertEquals(file, directoryToUnixString(observer));
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+        assertEquals(NameFileComparator.NAME_INSENSITIVE_COMPARATOR, observer.getComparator());
+    }
+
+    @Test
+    public void testConstructor_File() {
+        final File file = new File(PATH_STRING_FIXTURE);
+        @SuppressWarnings("deprecation")
+        final FileAlterationObserver observer = new FileAlterationObserver(file);
+        assertEquals(file, observer.getDirectory());
+    }
+
+    @Test
+    public void testConstructor_File_FileFilter() {
+        final File file = new File(PATH_STRING_FIXTURE);
+        @SuppressWarnings("deprecation")
+        final FileAlterationObserver observer = new FileAlterationObserver(file, CanReadFileFilter.CAN_READ);
+        assertEquals(file, observer.getDirectory());
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+    }
+
+    @Test
+    public void testConstructor_File_FileFilter_IOCase() {
+        final File file = new File(PATH_STRING_FIXTURE);
+        @SuppressWarnings("deprecation")
+        final FileAlterationObserver observer = new FileAlterationObserver(file, CanReadFileFilter.CAN_READ, IOCase.INSENSITIVE);
+        assertEquals(file, observer.getDirectory());
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+        assertEquals(NameFileComparator.NAME_INSENSITIVE_COMPARATOR, observer.getComparator());
+    }
+
+    @Test
+    public void testConstructor_String() {
+        final String file = PATH_STRING_FIXTURE;
+        @SuppressWarnings("deprecation")
+        final FileAlterationObserver observer = new FileAlterationObserver(file);
+        assertEquals(file, directoryToUnixString(observer));
+    }
+
+    @Test
+    public void testConstructor_String_FileFilter() {
+        final String file = PATH_STRING_FIXTURE;
+        @SuppressWarnings("deprecation")
+        final FileAlterationObserver observer = new FileAlterationObserver(file, CanReadFileFilter.CAN_READ);
+        assertEquals(file, directoryToUnixString(observer));
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+    }
+
+    @Test
+    public void testConstructor_String_FileFilter_IOCase() {
+        final String file = PATH_STRING_FIXTURE;
+        @SuppressWarnings("deprecation")
+        final FileAlterationObserver observer = new FileAlterationObserver(file, CanReadFileFilter.CAN_READ, IOCase.INSENSITIVE);
+        assertEquals(file, directoryToUnixString(observer));
+        assertEquals(CanReadFileFilter.CAN_READ, observer.getFileFilter());
+        assertEquals(NameFileComparator.NAME_INSENSITIVE_COMPARATOR, observer.getComparator());
+    }
+
     /**
-     * Test checkAndNotify() method
-     * @throws Exception
+     * Tests checkAndNotify() method
+     *
+     * @throws Exception Thrown on test failure.
      */
     @Test
     public void testDirectory() throws Exception {
@@ -136,6 +270,7 @@ public void testDirectory() throws Exception {
 
     /**
      * Test checkAndNotify() creating
+     *
      * @throws IOException if an I/O error occurs.
      */
     @Test
@@ -144,13 +279,13 @@ public void testFileCreate() throws IOException {
         checkCollectionsEmpty("A");
         File testDirA = new File(testDir, "test-dir-A");
         testDirA.mkdir();
-        testDir  = touch(testDir);
+        testDir = touch(testDir);
         testDirA = touch(testDirA);
-        File testDirAFile1 =       new File(testDirA, "A-file1.java");
+        File testDirAFile1 = new File(testDirA, "A-file1.java");
         final File testDirAFile2 = touch(new File(testDirA, "A-file2.java"));
-        File testDirAFile3 =       new File(testDirA, "A-file3.java");
+        File testDirAFile3 = new File(testDirA, "A-file3.java");
         final File testDirAFile4 = touch(new File(testDirA, "A-file4.java"));
-        File testDirAFile5 =       new File(testDirA, "A-file5.java");
+        File testDirAFile5 = new File(testDirA, "A-file5.java");
 
         checkAndNotify();
         checkCollectionSizes("B", 1, 0, 0, 2, 0, 0);
@@ -171,7 +306,7 @@ public void testFileCreate() throws IOException {
 
         // Create file with name < first entry
         testDirAFile1 = touch(testDirAFile1);
-        testDirA      = touch(testDirA);
+        testDirA = touch(testDirA);
         checkAndNotify();
         checkCollectionSizes("D", 0, 1, 0, 1, 0, 0);
         assertTrue(testDirAFile1.exists(), "D testDirAFile1 exists");
@@ -179,7 +314,7 @@ public void testFileCreate() throws IOException {
 
         // Create file with name between 2 entries
         testDirAFile3 = touch(testDirAFile3);
-        testDirA      = touch(testDirA);
+        testDirA = touch(testDirA);
         checkAndNotify();
         checkCollectionSizes("E", 0, 1, 0, 1, 0, 0);
         assertTrue(testDirAFile3.exists(), "E testDirAFile3 exists");
@@ -187,7 +322,7 @@ public void testFileCreate() throws IOException {
 
         // Create file with name > last entry
         testDirAFile5 = touch(testDirAFile5);
-        testDirA      = touch(testDirA);
+        testDirA = touch(testDirA);
         checkAndNotify();
         checkCollectionSizes("F", 0, 1, 0, 1, 0, 0);
         assertTrue(testDirAFile5.exists(), "F testDirAFile5 exists");
@@ -196,6 +331,7 @@ public void testFileCreate() throws IOException {
 
     /**
      * Test checkAndNotify() deleting
+     *
      * @throws IOException if an I/O error occurs.
      */
     @Test
@@ -204,7 +340,7 @@ public void testFileDelete() throws IOException {
         checkCollectionsEmpty("A");
         File testDirA = new File(testDir, "test-dir-A");
         testDirA.mkdir();
-        testDir  = touch(testDir);
+        testDir = touch(testDir);
         testDirA = touch(testDirA);
         final File testDirAFile1 = touch(new File(testDirA, "A-file1.java"));
         final File testDirAFile2 = touch(new File(testDirA, "A-file2.java"));
@@ -256,6 +392,7 @@ public void testFileDelete() throws IOException {
 
     /**
      * Test checkAndNotify() creating
+     *
      * @throws IOException if an I/O error occurs.
      */
     @Test
@@ -264,7 +401,7 @@ public void testFileUpdate() throws IOException {
         checkCollectionsEmpty("A");
         File testDirA = new File(testDir, "test-dir-A");
         testDirA.mkdir();
-        testDir  = touch(testDir);
+        testDir = touch(testDir);
         testDirA = touch(testDirA);
         File testDirAFile1 = touch(new File(testDirA, "A-file1.java"));
         final File testDirAFile2 = touch(new File(testDirA, "A-file2.java"));
@@ -291,21 +428,21 @@ public void testFileUpdate() throws IOException {
 
         // Update first entry
         testDirAFile1 = touch(testDirAFile1);
-        testDirA      = touch(testDirA);
+        testDirA = touch(testDirA);
         checkAndNotify();
         checkCollectionSizes("D", 0, 1, 0, 0, 1, 0);
         assertTrue(listener.getChangedFiles().contains(testDirAFile1), "D testDirAFile1");
 
         // Update file with name between 2 entries
         testDirAFile3 = touch(testDirAFile3);
-        testDirA      = touch(testDirA);
+        testDirA = touch(testDirA);
         checkAndNotify();
         checkCollectionSizes("E", 0, 1, 0, 0, 1, 0);
         assertTrue(listener.getChangedFiles().contains(testDirAFile3), "E testDirAFile3");
 
         // Update last entry
         testDirAFile5 = touch(testDirAFile5);
-        testDirA      = touch(testDirA);
+        testDirA = touch(testDirA);
         checkAndNotify();
         checkCollectionSizes("F", 0, 1, 0, 0, 1, 0);
         assertTrue(listener.getChangedFiles().contains(testDirAFile5), "F testDirAFile5");
@@ -313,6 +450,7 @@ public void testFileUpdate() throws IOException {
 
     /**
      * Test checkAndNotify() method
+     *
      * @throws IOException if an I/O error occurs.
      */
     @Test
@@ -329,7 +467,7 @@ public void testObserveSingleFile() throws IOException {
 
         // Create
         testDirAFile1 = touch(testDirAFile1);
-        File testDirAFile2 = touch(new File(testDirA, "A-file2.txt"));  /* filter should ignore */
+        File testDirAFile2 = touch(new File(testDirA, "A-file2.txt")); /* filter should ignore */
         File testDirAFile3 = touch(new File(testDirA, "A-file3.java")); /* filter should ignore */
         assertTrue(testDirAFile1.exists(), "B testDirAFile1 exists");
         assertTrue(testDirAFile2.exists(), "B testDirAFile2 exists");
@@ -369,16 +507,12 @@ public void testObserveSingleFile() throws IOException {
      */
     @Test
     public void testToString() {
-        final File file = new File("/foo");
-
-        FileAlterationObserver observer = new FileAlterationObserver(file);
-        assertEquals("FileAlterationObserver[file='" + file.getPath() +  "', listeners=0]",
-                observer.toString());
-
-        observer = new FileAlterationObserver(file, CanReadFileFilter.CAN_READ);
-        assertEquals("FileAlterationObserver[file='" + file.getPath() +  "', CanReadFileFilter, listeners=0]",
-                observer.toString());
-
+        final File file = new File(PATH_STRING_FIXTURE);
+        final Builder builder = FileAlterationObserver.builder();
+        FileAlterationObserver observer = builder.setFile(file).getUnchecked();
+        assertEquals("FileAlterationObserver[file='" + file.getPath() + "', true, listeners=0]", observer.toString());
+        observer = builder.setFileFilter(CanReadFileFilter.CAN_READ).getUnchecked();
+        assertEquals("FileAlterationObserver[file='" + file.getPath() + "', CanReadFileFilter, listeners=0]", observer.toString());
         assertEquals(file, observer.getDirectory());
-  }
+    }
 }
diff --git a/src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java
index c392514f..a3a127ba 100644
--- a/src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java
@@ -17,37 +17,49 @@
 package org.apache.commons.io.output;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
 import java.io.OutputStream;
 
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests {@link BrokenOutputStream}.
  */
 public class BrokenOutputStreamTest {
 
-    private IOException exception;
-
-    private OutputStream stream;
+    private static BrokenOutputStream createBrokenOutputStream(final Throwable exception) {
+        if (exception instanceof IOException) {
+            return new BrokenOutputStream((IOException) exception);
+        }
+        return new BrokenOutputStream(exception);
+    }
 
-    @BeforeEach
-    public void setUp() {
-        exception = new IOException("test exception");
-        stream = new BrokenOutputStream(exception);
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testClose(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenOutputStream stream = createBrokenOutputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.close()));
     }
 
-    @Test
-    public void testClose() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.close()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testFlush(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenOutputStream stream = createBrokenOutputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.flush()));
     }
 
     @Test
-    public void testFlush() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.flush()));
+    public void testInstance() {
+        assertNotNull(BrokenOutputStream.INSTANCE);
     }
 
     @Test
@@ -65,19 +77,31 @@ public void testTryWithResources() {
         assertEquals("Broken output stream", suppressed[0].getMessage());
     }
 
-    @Test
-    public void testWriteByteArray() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.write(new byte[1])));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteByteArray(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenOutputStream stream = createBrokenOutputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.write(new byte[1])));
     }
 
-    @Test
-    public void testWriteByteArrayIndexed() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.write(new byte[1], 0, 1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteByteArrayIndexed(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenOutputStream stream = createBrokenOutputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.write(new byte[1], 0, 1)));
     }
 
-    @Test
-    public void testWriteInt() {
-        assertEquals(exception, assertThrows(IOException.class, () -> stream.write(1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteInt(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenOutputStream stream = createBrokenOutputStream(exception);
+        assertEquals(exception, assertThrows(clazz, () -> stream.write(1)));
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java b/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java
index af2c4212..f9e83e08 100644
--- a/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java
+++ b/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java
@@ -17,71 +17,76 @@
 package org.apache.commons.io.output;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
 import java.io.Writer;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests {@link BrokenWriter}.
  */
 public class BrokenWriterTest {
 
-    private IOException exception;
-
-    private Writer brokenWriter;
-
-    @BeforeEach
-    public void setUp() {
-        exception = new IOException("test exception");
-        brokenWriter = new BrokenWriter(exception);
-    }
-
-    @Test
-    public void testAppendChar() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.append('1')));
+    private static BrokenWriter createBrokenWriter(final Throwable exception) {
+        if (exception instanceof IOException) {
+            return new BrokenWriter((IOException) exception);
+        }
+        return new BrokenWriter(exception);
     }
 
-    @Test
-    public void testAppendCharSequence() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.append("01")));
-    }
-
-    @Test
-    public void testAppendCharSequenceIndexed() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.append("01", 0, 1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testAppendChar(final Class<Exception> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append('1')));
     }
 
-    @Test
-    public void testClose() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.close()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testAppendCharSequence(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append("01")));
     }
 
-    @Test
-    @Disabled("What should happen here?")
-    public void testEquals() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.equals(null)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testAppendCharSequenceIndexed(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append("01", 0, 1)));
     }
 
-    @Test
-    public void testFlush() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.flush()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testClose(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.close()));
     }
 
-    @Test
-    @Disabled("What should happen here?")
-    public void testHashCode() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.hashCode()));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testFlush(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.flush()));
     }
 
     @Test
-    @Disabled("What should happen here?")
-    public void testToString() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.toString()));
+    public void testInstance() {
+        assertNotNull(BrokenWriter.INSTANCE);
     }
 
     @Test
@@ -99,29 +104,49 @@ public void testTryWithResources() {
         assertEquals("Broken writer", suppressed[0].getMessage());
     }
 
-    @Test
-    public void testWriteCharArray() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.write(new char[1])));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteCharArray(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(new char[1])));
     }
 
-    @Test
-    public void testWriteCharArrayIndexed() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.write(new char[1], 0, 1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteCharArrayIndexed(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(new char[1], 0, 1)));
     }
 
-    @Test
-    public void testWriteInt() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.write(1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteInt(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(1)));
     }
 
-    @Test
-    public void testWriteString() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.write("01")));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteString(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write("01")));
     }
 
-    @Test
-    public void testWriteStringIndexed() {
-        assertEquals(exception, assertThrows(IOException.class, () -> brokenWriter.write("01", 0, 1)));
+    @ParameterizedTest
+    @MethodSource("org.apache.commons.io.BrokenTestFactories#parameters")
+    public void testWriteStringIndexed(final Class<Throwable> clazz) throws Exception {
+        final Throwable exception = clazz.newInstance();
+        @SuppressWarnings("resource")
+        final BrokenWriter brokenWriter = createBrokenWriter(exception);
+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write("01", 0, 1)));
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java
index a65961d0..9e9e4cfb 100644
--- a/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java
@@ -18,6 +18,7 @@
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
@@ -299,7 +300,7 @@ public void testToInputStreamEmpty(final String baosName, final BAOSFactory<?> b
             // Get data before more writes
             final InputStream in = baout.toInputStream()) {
             assertEquals(0, in.available());
-            assertTrue(in instanceof ClosedInputStream);
+            assertInstanceOf(ClosedInputStream.class, in);
         }
     }
 
diff --git a/src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java
index ff503754..4e879a32 100644
--- a/src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java
@@ -16,13 +16,18 @@
  */
 package org.apache.commons.io.output;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.file.TempFile;
+import org.apache.commons.lang3.ArrayFill;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -40,8 +45,13 @@ public void write(final byte[] b, final int off, final int len) {
         };
     }
 
+    /**
+     * Tests the default chunk size with a ByteArrayOutputStream.
+     *
+     * @throws IOException
+     */
     @Test
-    public void testDefaultBuilder() throws IOException {
+    public void testBuildSetByteArrayOutputStream() throws IOException {
         final AtomicInteger numWrites = new AtomicInteger();
         try (ByteArrayOutputStream baos = newByteArrayOutputStream(numWrites);
                 final ChunkedOutputStream chunked = ChunkedOutputStream.builder().setOutputStream(baos).get()) {
@@ -51,6 +61,23 @@ public void testDefaultBuilder() throws IOException {
         assertThrows(IllegalStateException.class, () -> ChunkedOutputStream.builder().get());
     }
 
+    /**
+     * Tests the default chunk size with a Path.
+     *
+     * @throws IOException
+     */
+    @Test
+    public void testBuildSetPath() throws IOException {
+        try (TempFile tempFile = TempFile.create("test-", ".txt")) {
+            final byte[] fill = ArrayFill.fill(new byte[IOUtils.DEFAULT_BUFFER_SIZE + 1], (byte) 'a');
+            final Path tempPath = tempFile.get();
+            try (ChunkedOutputStream chunked = ChunkedOutputStream.builder().setPath(tempPath).get()) {
+                chunked.write(fill);
+            }
+            assertArrayEquals(fill, Files.readAllBytes(tempPath));
+        }
+    }
+
     @Test
     public void testDefaultConstructor() throws IOException {
         final AtomicInteger numWrites = new AtomicInteger();
diff --git a/src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java b/src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java
index 534030d6..60445e7e 100644
--- a/src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java
+++ b/src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java
@@ -44,13 +44,13 @@ public void write(final char[] cbuf, final int off, final int len) throws IOExce
     }
 
     @Test
-    public void negative_chunkSize_not_permitted() {
+    public void testNegative_chunkSize_not_permitted() {
         assertThrows(IllegalArgumentException.class,
                () -> new ChunkedWriter(new OutputStreamWriter(new ByteArrayOutputStream()), 0));
     }
 
     @Test
-    public void write_four_chunks() throws Exception {
+    public void testWrite_four_chunks() throws Exception {
         final AtomicInteger numWrites = new AtomicInteger();
         try (OutputStreamWriter osw = getOutputStreamWriter(numWrites)) {
             try (ChunkedWriter chunked = new ChunkedWriter(osw, 10)) {
@@ -62,7 +62,7 @@ public void write_four_chunks() throws Exception {
     }
 
     @Test
-    public void write_two_chunks_default_constructor() throws Exception {
+    public void testWrite_two_chunks_default_constructor() throws Exception {
         final AtomicInteger numWrites = new AtomicInteger();
         try (OutputStreamWriter osw = getOutputStreamWriter(numWrites)) {
             try (ChunkedWriter chunked = new ChunkedWriter(osw)) {
diff --git a/src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java
index b1968e89..97abd563 100644
--- a/src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java
@@ -33,7 +33,18 @@ public class ClosedOutputStreamTest {
     @Test
     public void testFlush() throws IOException {
         try (ClosedOutputStream cos = new ClosedOutputStream()) {
-            assertThrows(IOException.class, () -> cos.flush());
+            assertThrows(IOException.class, cos::flush);
+        }
+    }
+
+    @Test
+    public void testSingleton() throws IOException {
+        try (@SuppressWarnings("deprecation")
+        ClosedOutputStream cos = ClosedOutputStream.CLOSED_OUTPUT_STREAM) {
+            assertThrows(IOException.class, cos::flush);
+        }
+        try (ClosedOutputStream cos = ClosedOutputStream.INSTANCE) {
+            assertThrows(IOException.class, cos::flush);
         }
     }
 
@@ -47,4 +58,20 @@ public void testWrite() throws IOException {
         }
     }
 
+    @Test
+    public void testWriteArray() throws IOException {
+        try (ClosedOutputStream cos = new ClosedOutputStream()) {
+            assertThrows(IOException.class, () -> cos.write(new byte[0]));
+            assertThrows(IOException.class, () -> cos.write(new byte[10]));
+        }
+    }
+
+    @Test
+    public void testWriteArrayIndex() throws IOException {
+        try (ClosedOutputStream cos = new ClosedOutputStream()) {
+            assertThrows(IOException.class, () -> cos.write(new byte[0], 0, 0));
+            assertThrows(IOException.class, () -> cos.write(new byte[10], 0, 1));
+        }
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java
index 97758449..df62718a 100644
--- a/src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java
@@ -89,7 +89,7 @@ public void testLargeFiles_IO84() throws Exception {
         assertThrows(ArithmeticException.class, () -> cos.getCount());
         assertThrows(ArithmeticException.class, () -> cos.resetCount());
 
-        mock.close();
+        mock.init();
 
         // Test long methods
         IOUtils.copyLarge(mock, cos);
diff --git a/src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java
index e23a40c0..865d4a1f 100644
--- a/src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java
@@ -29,11 +29,10 @@
 import java.io.InputStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.stream.IntStream;
 
-import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.file.AbstractTempDirTest;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.params.ParameterizedTest;
@@ -42,7 +41,7 @@
 /**
  * Tests {@code DeferredFileOutputStream}.
  */
-public class DeferredFileOutputStreamTest {
+public class DeferredFileOutputStreamTest extends AbstractTempDirTest {
 
     public static IntStream data() {
         return IntStream.of(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096);
@@ -65,28 +64,19 @@ public static IntStream data() {
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testAboveThreshold(final int initialBufferSize) throws IOException {
-        final File testFile = new File("testAboveThreshold.dat");
-
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
-
-        // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        final File testFile = Files.createTempFile(tempDirPath, "testAboveThreshold", "dat").toFile();
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
                 .setThreshold(testBytes.length - 5)
                 .setBufferSize(initialBufferSize)
                 .setOutputFile(testFile)
-                .get();
-        // @formatter:on
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertFalse(dfos.isInMemory());
-        assertNull(dfos.getData());
-        assertEquals(testFile.length(), dfos.getByteCount());
-
-        verifyResultFile(testFile);
-
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
+                .get()) {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertFalse(dfos.isInMemory());
+            assertNull(dfos.getData());
+            assertEquals(testFile.length(), dfos.getByteCount());
+            verifyResultFile(testFile);
+        }
     }
 
     /**
@@ -97,48 +87,44 @@ public void testAboveThreshold(final int initialBufferSize) throws IOException {
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testAboveThresholdGetInputStream(final int initialBufferSize, final @TempDir Path tempDir) throws IOException {
-        final File testFile = tempDir.resolve("testAboveThreshold.dat").toFile();
-
-        // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        final File testFile = Files.createTempFile(tempDirPath, "testAboveThreshold", "dat").toFile();
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
                 .setThreshold(testBytes.length - 5)
                 .setBufferSize(initialBufferSize)
                 .setOutputFile(testFile)
-                .get();
-        // @formatter:on
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertFalse(dfos.isInMemory());
-        assertEquals(testFile.length(), dfos.getByteCount());
-
-        try (InputStream is = dfos.toInputStream()) {
-            assertArrayEquals(testBytes, IOUtils.toByteArray(is));
+                .get()) {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertFalse(dfos.isInMemory());
+            assertEquals(testFile.length(), dfos.getByteCount());
+            try (InputStream is = dfos.toInputStream()) {
+                assertArrayEquals(testBytes, IOUtils.toByteArray(is));
+            }
+            verifyResultFile(testFile);
         }
-
-        verifyResultFile(testFile);
     }
 
     /**
      * Tests the case where the amount of data is exactly the same as the threshold. The behavior should be the same as
-     * that for the amount of data being below (i.e. not exceeding) the threshold.
+     * that for the amount of data being below (not exceeding) the threshold.
      */
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testAtThreshold(final int initialBufferSize) throws IOException {
-        // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+            // @formatter:off
                 .setThreshold(testBytes.length)
                 .setBufferSize(initialBufferSize)
-                .get();
-        // @formatter:on
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertTrue(dfos.isInMemory());
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        final byte[] resultBytes = dfos.getData();
-        assertEquals(testBytes.length, resultBytes.length);
-        assertArrayEquals(resultBytes, testBytes);
+                .get()) {
+            // @formatter:on
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertTrue(dfos.isInMemory());
+            assertEquals(testBytes.length, dfos.getByteCount());
+            final byte[] resultBytes = dfos.getData();
+            assertEquals(testBytes.length, resultBytes.length);
+            assertArrayEquals(resultBytes, testBytes);
+        }
     }
 
     /**
@@ -148,20 +134,20 @@ public void testAtThreshold(final int initialBufferSize) throws IOException {
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testBelowThreshold(final int initialBufferSize) throws IOException {
-        // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+            // @formatter:off
                 .setThreshold(testBytes.length + 42)
                 .setBufferSize(initialBufferSize)
-                .get();
-        // @formatter:on
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertTrue(dfos.isInMemory());
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        final byte[] resultBytes = dfos.getData();
-        assertEquals(testBytes.length, resultBytes.length);
-        assertArrayEquals(resultBytes, testBytes);
+                .get()) {
+            // @formatter:on
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertTrue(dfos.isInMemory());
+            assertEquals(testBytes.length, dfos.getByteCount());
+            final byte[] resultBytes = dfos.getData();
+            assertEquals(testBytes.length, resultBytes.length);
+            assertArrayEquals(resultBytes, testBytes);
+        }
     }
 
     /**
@@ -172,18 +158,18 @@ public void testBelowThreshold(final int initialBufferSize) throws IOException {
     @MethodSource("data")
     public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
         // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
                 .setThreshold(testBytes.length + 42)
                 .setBufferSize(initialBufferSize)
-                .get();
+                .get()) {
         // @formatter:on
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertTrue(dfos.isInMemory());
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        try (InputStream is = dfos.toInputStream()) {
-            assertArrayEquals(testBytes, IOUtils.toByteArray(is));
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertTrue(dfos.isInMemory());
+            assertEquals(testBytes.length, dfos.getByteCount());
+            try (InputStream is = dfos.toInputStream()) {
+                assertArrayEquals(testBytes, IOUtils.toByteArray(is));
+            }
         }
     }
 
@@ -193,37 +179,32 @@ public void testBelowThresholdGetInputStream(final int initialBufferSize) throws
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testTempFileAboveThreshold(final int initialBufferSize) throws IOException {
-
         final String prefix = "commons-io-test";
         final String suffix = ".out";
-        final Path tempDir = Paths.get("target");
         // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
                 .setThreshold(testBytes.length - 5)
                 .setBufferSize(initialBufferSize)
                 .setPrefix(prefix)
                 .setSuffix(suffix)
-                .setDirectory(tempDir)
-                .setDirectory(tempDir.toFile())
-                .get();
+                .setDirectory(tempDirFile)
+                .setDirectory(tempDirPath.toFile())
+                .get()) {
         // @formatter:on
-        assertNull(dfos.getFile(), "Check File is null-A");
-        assertNull(dfos.getPath(), "Check Path is null-A");
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertFalse(dfos.isInMemory());
-        assertEquals(testBytes.length, dfos.getByteCount());
-        assertNull(dfos.getData());
-        assertNotNull(dfos.getFile(), "Check file not null");
-        assertTrue(dfos.getFile().exists(), "Check file exists");
-        assertTrue(dfos.getFile().getName().startsWith(prefix), "Check prefix");
-        assertTrue(dfos.getFile().getName().endsWith(suffix), "Check suffix");
-        assertEquals(tempDir, dfos.getPath().getParent(), "Check dir");
-
-        verifyResultFile(dfos.getFile());
-
-        // Delete the temporary file.
-        dfos.getFile().delete();
+            assertNull(dfos.getFile(), "Check File is null-A");
+            assertNull(dfos.getPath(), "Check Path is null-A");
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertFalse(dfos.isInMemory());
+            assertEquals(testBytes.length, dfos.getByteCount());
+            assertNull(dfos.getData());
+            assertNotNull(dfos.getFile(), "Check file not null");
+            assertTrue(dfos.getFile().exists(), "Check file exists");
+            assertTrue(dfos.getFile().getName().startsWith(prefix), "Check prefix");
+            assertTrue(dfos.getFile().getName().endsWith(suffix), "Check suffix");
+            assertEquals(tempDirPath, dfos.getPath().getParent(), "Check dir");
+            verifyResultFile(dfos.getFile());
+        }
     }
 
     /**
@@ -233,35 +214,35 @@ public void testTempFileAboveThreshold(final int initialBufferSize) throws IOExc
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testTempFileAboveThresholdPrefixOnly(final int initialBufferSize) throws IOException {
-
         final String prefix = "commons-io-test";
         final String suffix = null;
-        final Path tempDir = null;
-        // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        try (final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+            // @formatter:off
                 .setThreshold(testBytes.length - 5)
                 .setBufferSize(initialBufferSize)
                 .setPrefix(prefix)
                 .setSuffix(suffix)
-                .setDirectory(tempDir)
-                .get();
-        // @formatter:on
-        assertNull(dfos.getFile(), "Check File is null-A");
-        assertNull(dfos.getPath(), "Check Path is null-A");
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertFalse(dfos.isInMemory());
-        assertNull(dfos.getData());
-        assertEquals(testBytes.length, dfos.getByteCount());
-        assertNotNull(dfos.getFile(), "Check file not null");
-        assertTrue(dfos.getFile().exists(), "Check file exists");
-        assertTrue(dfos.getFile().getName().startsWith(prefix), "Check prefix");
-        assertTrue(dfos.getFile().getName().endsWith(".tmp"), "Check suffix"); // ".tmp" is default
-
-        verifyResultFile(dfos.getFile());
-
-        // Delete the temporary file.
-        dfos.getFile().delete();
+                .setDirectory((Path) null)
+                .get()) {
+            // @formatter:on
+            try {
+                assertNull(dfos.getFile(), "Check File is null-A");
+                assertNull(dfos.getPath(), "Check Path is null-A");
+                dfos.write(testBytes, 0, testBytes.length);
+                dfos.close();
+                assertFalse(dfos.isInMemory());
+                assertNull(dfos.getData());
+                assertEquals(testBytes.length, dfos.getByteCount());
+                assertNotNull(dfos.getFile(), "Check file not null");
+                assertTrue(dfos.getFile().exists(), "Check file exists");
+                assertTrue(dfos.getFile().getName().startsWith(prefix), "Check prefix");
+                assertTrue(dfos.getFile().getName().endsWith(".tmp"), "Check suffix"); // ".tmp" is default
+                verifyResultFile(dfos.getFile());
+            } finally {
+                // Delete the temporary file.
+                dfos.getFile().delete();
+            }
+        }
     }
 
     /**
@@ -271,18 +252,17 @@ public void testTempFileAboveThresholdPrefixOnly(final int initialBufferSize) th
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testTempFileBelowThreshold(final int initialBufferSize) throws IOException {
-
         final String prefix = "commons-io-test";
         final String suffix = ".out";
-        final File tempDir = FileUtils.current();
-        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize, prefix, suffix, tempDir);
-        assertNull(dfos.getFile(), "Check File is null-A");
-        assertNull(dfos.getPath(), "Check Path is null-A");
-        dfos.write(testBytes, 0, testBytes.length);
-        dfos.close();
-        assertTrue(dfos.isInMemory());
-        assertEquals(testBytes.length, dfos.getByteCount());
-        assertNull(dfos.getFile(), "Check file is null-B");
+        try (final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize, prefix, suffix, tempDirFile)) {
+            assertNull(dfos.getFile(), "Check File is null-A");
+            assertNull(dfos.getPath(), "Check Path is null-A");
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertTrue(dfos.isInMemory());
+            assertEquals(testBytes.length, dfos.getByteCount());
+            assertNull(dfos.getFile(), "Check file is null-B");
+        }
     }
 
     /**
@@ -294,8 +274,29 @@ public void testTempFileBelowThreshold(final int initialBufferSize) throws IOExc
     public void testTempFileError() throws Exception {
         final String prefix = null;
         final String suffix = ".out";
-        final File tempDir = FileUtils.current();
-        assertThrows(NullPointerException.class, () -> new DeferredFileOutputStream(testBytes.length - 5, prefix, suffix, tempDir));
+        assertThrows(NullPointerException.class, () -> new DeferredFileOutputStream(testBytes.length - 5, prefix, suffix, tempDirFile));
+    }
+
+    /**
+     * Tests the case where the threshold is negative, and therefore the data is always written to disk. The actual data
+     * written to disk is verified, as is the file itself.
+     */
+    @ParameterizedTest(name = "initialBufferSize = {0}")
+    @MethodSource("data")
+    public void testThresholdNegative(final int initialBufferSize) throws IOException {
+        final File testFile = Files.createTempFile(tempDirPath, "testThresholdNegative", "dat").toFile();
+        try (DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+                .setThreshold(-1)
+                .setBufferSize(initialBufferSize)
+                .setOutputFile(testFile)
+                .get()) {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+            assertFalse(dfos.isInMemory());
+            assertNull(dfos.getData());
+            assertEquals(testFile.length(), dfos.getByteCount());
+            verifyResultFile(testFile);
+        }
     }
 
     /**
@@ -306,31 +307,24 @@ public void testTempFileError() throws Exception {
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testThresholdReached(final int initialBufferSize) throws IOException {
-        final File testFile = new File("testThresholdReached.dat");
-
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
-
-        // @formatter:off
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+        final File testFile = Files.createTempFile(tempDirPath, "testThresholdReached", "dat").toFile();
+        try (final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder()
+            // @formatter:off
                 .setThreshold(testBytes.length /2)
                 .setBufferSize(initialBufferSize)
                 .setOutputFile(testFile)
-                .get();
-        // @formatter:on
-        final int chunkSize = testBytes.length / 3;
-        dfos.write(testBytes, 0, chunkSize);
-        dfos.write(testBytes, chunkSize, chunkSize);
-        dfos.write(testBytes, chunkSize * 2, testBytes.length - chunkSize * 2);
-        dfos.close();
-        assertFalse(dfos.isInMemory());
-        assertNull(dfos.getData());
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        verifyResultFile(testFile);
-
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
+                .get()) {
+            // @formatter:on
+            final int chunkSize = testBytes.length / 3;
+            dfos.write(testBytes, 0, chunkSize);
+            dfos.write(testBytes, chunkSize, chunkSize);
+            dfos.write(testBytes, chunkSize * 2, testBytes.length - chunkSize * 2);
+            dfos.close();
+            assertFalse(dfos.isInMemory());
+            assertNull(dfos.getData());
+            assertEquals(testBytes.length, dfos.getByteCount());
+            verifyResultFile(testFile);
+        }
     }
 
     /**
@@ -339,26 +333,23 @@ public void testThresholdReached(final int initialBufferSize) throws IOException
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testWriteToLarge(final int initialBufferSize) throws IOException {
-        final File testFile = new File("testWriteToFile.dat");
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream(initialBufferSize);
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
-
-        final DeferredFileOutputStream dfos = DeferredFileOutputStream.builder().setThreshold(testBytes.length / 2).setOutputFile(testFile).get();
-        dfos.write(testBytes);
-
-        assertTrue(testFile.exists());
-        assertFalse(dfos.isInMemory());
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        assertThrows(IOException.class, () -> dfos.writeTo(baos));
-
-        dfos.close();
-        dfos.writeTo(baos);
-        final byte[] copiedBytes = baos.toByteArray();
-        assertArrayEquals(testBytes, copiedBytes);
-        verifyResultFile(testFile);
-        testFile.delete();
+        final File testFile = Files.createTempFile(tempDirPath, "testWriteToFile", "dat").toFile();
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream(initialBufferSize);
+                DeferredFileOutputStream dfos = DeferredFileOutputStream.builder().setThreshold(testBytes.length / 2).setOutputFile(testFile).get()) {
+            dfos.write(testBytes);
+
+            assertTrue(testFile.exists());
+            assertFalse(dfos.isInMemory());
+            assertEquals(testBytes.length, dfos.getByteCount());
+
+            assertThrows(IOException.class, () -> dfos.writeTo(baos));
+
+            dfos.close();
+            dfos.writeTo(baos);
+            final byte[] copiedBytes = baos.toByteArray();
+            assertArrayEquals(testBytes, copiedBytes);
+            verifyResultFile(testFile);
+        }
     }
 
     /**
@@ -367,26 +358,23 @@ public void testWriteToLarge(final int initialBufferSize) throws IOException {
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testWriteToLargeCtor(final int initialBufferSize) throws IOException {
-        final File testFile = new File("testWriteToFile.dat");
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream(initialBufferSize);
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
-
-        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length / 2, testFile);
-        dfos.write(testBytes);
-
-        assertTrue(testFile.exists());
-        assertFalse(dfos.isInMemory());
-
-        assertThrows(IOException.class, () -> dfos.writeTo(baos));
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        dfos.close();
-        dfos.writeTo(baos);
-        final byte[] copiedBytes = baos.toByteArray();
-        assertArrayEquals(testBytes, copiedBytes);
-        verifyResultFile(testFile);
-        testFile.delete();
+        final File testFile = Files.createTempFile(tempDirPath, "testWriteToFile", "dat").toFile();
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream(initialBufferSize);
+                DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length / 2, testFile)) {
+            dfos.write(testBytes);
+
+            assertTrue(testFile.exists());
+            assertFalse(dfos.isInMemory());
+
+            assertThrows(IOException.class, () -> dfos.writeTo(baos));
+            assertEquals(testBytes.length, dfos.getByteCount());
+
+            dfos.close();
+            dfos.writeTo(baos);
+            final byte[] copiedBytes = baos.toByteArray();
+            assertArrayEquals(testBytes, copiedBytes);
+            verifyResultFile(testFile);
+        }
     }
 
     /**
@@ -396,26 +384,21 @@ public void testWriteToLargeCtor(final int initialBufferSize) throws IOException
     @ParameterizedTest(name = "initialBufferSize = {0}")
     @MethodSource("data")
     public void testWriteToSmall(final int initialBufferSize) throws IOException {
-        final File testFile = new File("testWriteToMem.dat");
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream(initialBufferSize);
-        // Ensure that the test starts from a clean base.
-        testFile.delete();
+        final File testFile = Files.createTempFile(tempDirPath, "testWriteToMem", "dat").toFile();
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream(initialBufferSize);
+                final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length * 2, initialBufferSize, testFile)) {
+            dfos.write(testBytes);
 
-        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length * 2, initialBufferSize, testFile);
-        dfos.write(testBytes);
+            assertTrue(dfos.isInMemory());
 
-        assertFalse(testFile.exists());
-        assertTrue(dfos.isInMemory());
+            assertThrows(IOException.class, () -> dfos.writeTo(baos));
+            assertEquals(testBytes.length, dfos.getByteCount());
 
-        assertThrows(IOException.class, () -> dfos.writeTo(baos));
-        assertEquals(testBytes.length, dfos.getByteCount());
-
-        dfos.close();
-        dfos.writeTo(baos);
-        final byte[] copiedBytes = baos.toByteArray();
-        assertArrayEquals(testBytes, copiedBytes);
-
-        testFile.delete();
+            dfos.close();
+            dfos.writeTo(baos);
+            final byte[] copiedBytes = baos.toByteArray();
+            assertArrayEquals(testBytes, copiedBytes);
+        }
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java b/src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java
index b6a009fb..12f6222e 100644
--- a/src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java
+++ b/src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java
@@ -51,8 +51,34 @@ public class FileWriterWithEncodingTest {
     private String textContent;
     private final char[] anotherTestContent = {'f', 'z', 'x'};
 
+    @BeforeEach
+    public void setUp() throws Exception {
+        final File encodingFinder = new File(temporaryFolder, "finder.txt");
+        try (OutputStreamWriter out = new OutputStreamWriter(Files.newOutputStream(encodingFinder.toPath()))) {
+            defaultEncoding = out.getEncoding();
+        }
+        file1 = new File(temporaryFolder, "testfile1.txt");
+        file2 = new File(temporaryFolder, "testfile2.txt");
+        final char[] arr = new char[1024];
+        final char[] chars = "ABCDEFGHIJKLMNOPQabcdefgihklmnopq".toCharArray();
+        for (int i = 0; i < arr.length; i++) {
+            arr[i] = chars[i % chars.length];
+        }
+        textContent = new String(arr);
+    }
+
+    private void successfulRun(final FileWriterWithEncoding fw21) throws Exception {
+        try (FileWriter fw1 = new FileWriter(file1); // default encoding
+            FileWriterWithEncoding fw2 = fw21) {
+            writeTestPayload(fw1, fw2);
+            checkFile(file1, file2);
+        }
+        assertTrue(file1.exists());
+        assertTrue(file2.exists());
+    }
+
     @Test
-    public void constructor_File_directory() {
+    public void testConstructor_File_directory() {
         assertThrows(IOException.class, () -> {
             try (Writer writer = new FileWriterWithEncoding(temporaryFolder, defaultEncoding)) {
                 // empty
@@ -68,7 +94,7 @@ public void constructor_File_directory() {
     }
 
     @Test
-    public void constructor_File_encoding_badEncoding() {
+    public void testConstructor_File_encoding_badEncoding() {
         assertThrows(IOException.class, () -> {
             try (Writer writer = new FileWriterWithEncoding(file1, "BAD-ENCODE")) {
                 // empty
@@ -78,7 +104,7 @@ public void constructor_File_encoding_badEncoding() {
     }
 
     @Test
-    public void constructor_File_existingFile_withContent() throws Exception {
+    public void testConstructor_File_existingFile_withContent() throws Exception {
         try (FileWriter fw1 = new FileWriter(file1);) {
             fw1.write(textContent);
             fw1.write(65);
@@ -99,7 +125,7 @@ public void constructor_File_existingFile_withContent() throws Exception {
     }
 
     @Test
-    public void constructor_File_nullFile() {
+    public void testConstructor_File_nullFile() {
         assertThrows(NullPointerException.class, () -> {
             try (Writer writer = new FileWriterWithEncoding((File) null, defaultEncoding)) {
                 // empty
@@ -109,7 +135,7 @@ public void constructor_File_nullFile() {
     }
 
     @Test
-    public void constructor_fileName_nullFile() {
+    public void testConstructor_fileName_nullFile() {
         assertThrows(NullPointerException.class, () -> {
             try (Writer writer = new FileWriterWithEncoding((String) null, defaultEncoding)) {
                 // empty
@@ -119,7 +145,7 @@ public void constructor_fileName_nullFile() {
     }
 
     @Test
-    public void constructorAppend_File_existingFile_withContent() throws Exception {
+    public void testConstructorAppend_File_existingFile_withContent() throws Exception {
         try (FileWriter fw1 = new FileWriter(file1)) {
             fw1.write("ABcd");
         }
@@ -145,7 +171,41 @@ public void constructorAppend_File_existingFile_withContent() throws Exception {
     }
 
     @Test
-    public void sameEncoding_Charset_constructor() throws Exception {
+    public void testDifferentEncoding() throws Exception {
+        if (Charset.isSupported(StandardCharsets.UTF_16BE.name())) {
+            try (FileWriter fw1 = new FileWriter(file1); // default encoding
+                FileWriterWithEncoding fw2 = new FileWriterWithEncoding(file2, defaultEncoding)) {
+                writeTestPayload(fw1, fw2);
+                try {
+                    checkFile(file1, file2);
+                    fail();
+                } catch (final AssertionError ex) {
+                    // success
+                }
+
+            }
+            assertTrue(file1.exists());
+            assertTrue(file2.exists());
+        }
+        if (Charset.isSupported(StandardCharsets.UTF_16LE.name())) {
+            try (FileWriter fw1 = new FileWriter(file1); // default encoding
+                FileWriterWithEncoding fw2 = new FileWriterWithEncoding(file2, defaultEncoding)) {
+                writeTestPayload(fw1, fw2);
+                try {
+                    checkFile(file1, file2);
+                    fail();
+                } catch (final AssertionError ex) {
+                    // success
+                }
+
+            }
+            assertTrue(file1.exists());
+            assertTrue(file2.exists());
+        }
+    }
+
+    @Test
+    public void testSameEncoding_Charset_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2, Charset.defaultCharset())) {
             successfulRun(writer);
         }
@@ -160,7 +220,7 @@ public void sameEncoding_Charset_constructor() throws Exception {
     }
 
     @Test
-    public void sameEncoding_CharsetEncoder_constructor() throws Exception {
+    public void testSameEncoding_CharsetEncoder_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2, Charset.defaultCharset().newEncoder())) {
             successfulRun(writer);
         }
@@ -175,14 +235,14 @@ public void sameEncoding_CharsetEncoder_constructor() throws Exception {
     }
 
     @Test
-    public void sameEncoding_null_Charset_constructor() throws Exception {
+    public void testSameEncoding_null_Charset_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2, (Charset) null)) {
             successfulRun(writer);
         }
     }
 
     @Test
-    public void sameEncoding_null_CharsetEncoder_constructor() throws Exception {
+    public void testSameEncoding_null_CharsetEncoder_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2.getPath(), (CharsetEncoder) null)) {
             successfulRun(writer);
         }
@@ -195,14 +255,14 @@ public void sameEncoding_null_CharsetEncoder_constructor() throws Exception {
     }
 
     @Test
-    public void sameEncoding_null_CharsetName_constructor() throws Exception {
+    public void testSameEncoding_null_CharsetName_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2.getPath(), (String) null)) {
             successfulRun(writer);
         }
     }
 
     @Test
-    public void sameEncoding_string_Charset_constructor() throws Exception {
+    public void testSameEncoding_string_Charset_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2.getPath(), Charset.defaultCharset())) {
             successfulRun(writer);
         }
@@ -217,21 +277,21 @@ public void sameEncoding_string_Charset_constructor() throws Exception {
     }
 
     @Test
-    public void sameEncoding_string_CharsetEncoder_constructor() throws Exception {
+    public void testSameEncoding_string_CharsetEncoder_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2.getPath(), Charset.defaultCharset().newEncoder())) {
             successfulRun(writer);
         }
     }
 
     @Test
-    public void sameEncoding_string_constructor() throws Exception {
+    public void testSameEncoding_string_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2, defaultEncoding)) {
             successfulRun(writer);
         }
     }
 
     @Test
-    public void sameEncoding_string_string_constructor() throws Exception {
+    public void testSameEncoding_string_string_constructor() throws Exception {
         try (FileWriterWithEncoding writer = new FileWriterWithEncoding(file2.getPath(), defaultEncoding)) {
             successfulRun(writer);
         }
@@ -245,66 +305,6 @@ public void sameEncoding_string_string_constructor() throws Exception {
         // @formatter:on
     }
 
-    @BeforeEach
-    public void setUp() throws Exception {
-        final File encodingFinder = new File(temporaryFolder, "finder.txt");
-        try (OutputStreamWriter out = new OutputStreamWriter(Files.newOutputStream(encodingFinder.toPath()))) {
-            defaultEncoding = out.getEncoding();
-        }
-        file1 = new File(temporaryFolder, "testfile1.txt");
-        file2 = new File(temporaryFolder, "testfile2.txt");
-        final char[] arr = new char[1024];
-        final char[] chars = "ABCDEFGHIJKLMNOPQabcdefgihklmnopq".toCharArray();
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = chars[i % chars.length];
-        }
-        textContent = new String(arr);
-    }
-
-    private void successfulRun(final FileWriterWithEncoding fw21) throws Exception {
-        try (FileWriter fw1 = new FileWriter(file1); // default encoding
-            FileWriterWithEncoding fw2 = fw21) {
-            writeTestPayload(fw1, fw2);
-            checkFile(file1, file2);
-        }
-        assertTrue(file1.exists());
-        assertTrue(file2.exists());
-    }
-
-    @Test
-    public void testDifferentEncoding() throws Exception {
-        if (Charset.isSupported(StandardCharsets.UTF_16BE.name())) {
-            try (FileWriter fw1 = new FileWriter(file1); // default encoding
-                FileWriterWithEncoding fw2 = new FileWriterWithEncoding(file2, defaultEncoding)) {
-                writeTestPayload(fw1, fw2);
-                try {
-                    checkFile(file1, file2);
-                    fail();
-                } catch (final AssertionError ex) {
-                    // success
-                }
-
-            }
-            assertTrue(file1.exists());
-            assertTrue(file2.exists());
-        }
-        if (Charset.isSupported(StandardCharsets.UTF_16LE.name())) {
-            try (FileWriter fw1 = new FileWriter(file1); // default encoding
-                FileWriterWithEncoding fw2 = new FileWriterWithEncoding(file2, defaultEncoding)) {
-                writeTestPayload(fw1, fw2);
-                try {
-                    checkFile(file1, file2);
-                    fail();
-                } catch (final AssertionError ex) {
-                    // success
-                }
-
-            }
-            assertTrue(file1.exists());
-            assertTrue(file2.exists());
-        }
-    }
-
     private void writeTestPayload(final FileWriter fw1, final FileWriterWithEncoding fw2) throws IOException {
         assertTrue(file1.exists());
         assertTrue(file2.exists());
diff --git a/src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java b/src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java
index 88c117da..c124d718 100644
--- a/src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java
+++ b/src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java
@@ -89,10 +89,10 @@ private void testAlternateLockDir(final LockableFileWriter lfw1) {
 
         // try to open a second writer
         try (LockableFileWriter lfw2 = new LockableFileWriter(file, StandardCharsets.UTF_8, true, altLockDir.getAbsolutePath())) {
-            fail("Somehow able to open a locked file. ");
+            fail("Somehow able to open a locked file.");
         } catch (final IOException ioe) {
             final String msg = ioe.getMessage();
-            assertTrue(msg.startsWith("Can't write file, lock "), "Exception message does not start correctly. ");
+            assertTrue(msg.startsWith("Can't write file, lock "), "Exception message does not start correctly.");
             assertTrue(file.exists());
             assertTrue(altLockFile.exists());
         }
@@ -163,20 +163,20 @@ public void testFileLocked() throws IOException {
 
             // try to open a second writer
             try (LockableFileWriter lfw2 = new LockableFileWriter(file)) {
-                fail("Somehow able to open a locked file. ");
+                fail("Somehow able to open a locked file.");
             } catch (final IOException ioe) {
                 final String msg = ioe.getMessage();
-                assertTrue(msg.startsWith("Can't write file, lock "), "Exception message does not start correctly. ");
+                assertTrue(msg.startsWith("Can't write file, lock "), "Exception message does not start correctly.");
                 assertTrue(file.exists());
                 assertTrue(lockFile.exists());
             }
 
             // try to open a third writer
             try (LockableFileWriter lfw3 = new LockableFileWriter(file)) {
-                fail("Somehow able to open a locked file. ");
+                fail("Somehow able to open a locked file.");
             } catch (final IOException ioe) {
                 final String msg = ioe.getMessage();
-                assertTrue(msg.startsWith("Can't write file, lock "), "Exception message does not start correctly. ");
+                assertTrue(msg.startsWith("Can't write file, lock "), "Exception message does not start correctly.");
                 assertTrue(file.exists());
                 assertTrue(lockFile.exists());
             }
diff --git a/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java b/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java
index 0bcee12a..a69d4d54 100644
--- a/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java
+++ b/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java
@@ -32,7 +32,7 @@
 public class ProxyWriterTest {
 
     @Test
-    public void appendChar() throws Exception {
+    public void testAppendChar() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.append('c');
@@ -41,7 +41,7 @@ public void appendChar() throws Exception {
     }
 
     @Test
-    public void appendCharSequence() throws Exception {
+    public void testAppendCharSequence() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.append("ABC");
@@ -50,7 +50,7 @@ public void appendCharSequence() throws Exception {
     }
 
     @Test
-    public void appendCharSequence_with_offset() throws Exception {
+    public void testAppendCharSequence_with_offset() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.append("ABC", 1, 3);
@@ -60,7 +60,7 @@ public void appendCharSequence_with_offset() throws Exception {
     }
 
     @Test
-    public void exceptions_in_append_char() throws IOException {
+    public void testExceptions_in_append_char() throws IOException {
         try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 final OutputStreamWriter osw = new OutputStreamWriter(baos) {
                     @Override
@@ -75,7 +75,7 @@ public void write(final int c) throws IOException {
     }
 
     @Test
-    public void exceptions_in_append_charSequence() throws IOException {
+    public void testExceptions_in_append_charSequence() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public Writer append(final CharSequence csq) throws IOException {
@@ -89,7 +89,7 @@ public Writer append(final CharSequence csq) throws IOException {
     }
 
     @Test
-    public void exceptions_in_append_charSequence_offset() throws IOException {
+    public void testExceptions_in_append_charSequence_offset() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public Writer append(final CharSequence csq, final int start, final int end) throws IOException {
@@ -103,7 +103,7 @@ public Writer append(final CharSequence csq, final int start, final int end) thr
     }
 
     @Test
-    public void exceptions_in_close() {
+    public void testExceptions_in_close() {
         assertThrows(UnsupportedEncodingException.class, () -> {
             try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
                 @Override
@@ -119,7 +119,7 @@ public void close() throws IOException {
     }
 
     @Test
-    public void exceptions_in_flush() throws IOException {
+    public void testExceptions_in_flush() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public void flush() throws IOException {
@@ -133,7 +133,7 @@ public void flush() throws IOException {
     }
 
     @Test
-    public void exceptions_in_write_char_array() throws IOException {
+    public void testExceptions_in_write_char_array() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public void write(final char[] cbuf) throws IOException {
@@ -147,7 +147,7 @@ public void write(final char[] cbuf) throws IOException {
     }
 
     @Test
-    public void exceptions_in_write_int() throws IOException {
+    public void testExceptions_in_write_int() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public void write(final int c) throws IOException {
@@ -161,7 +161,7 @@ public void write(final int c) throws IOException {
     }
 
     @Test
-    public void exceptions_in_write_offset_char_array() throws IOException {
+    public void testExceptions_in_write_offset_char_array() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public void write(final char[] cbuf, final int off, final int len) throws IOException {
@@ -175,7 +175,7 @@ public void write(final char[] cbuf, final int off, final int len) throws IOExce
     }
 
     @Test
-    public void exceptions_in_write_string() throws IOException {
+    public void testExceptions_in_write_string() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public void write(final String str) throws IOException {
@@ -189,7 +189,7 @@ public void write(final String str) throws IOException {
     }
 
     @Test
-    public void exceptions_in_write_string_offset() throws IOException {
+    public void testExceptions_in_write_string_offset() throws IOException {
         try (OutputStreamWriter osw = new OutputStreamWriter(new ByteArrayOutputStream()) {
             @Override
             public void write(final String str, final int off, final int len) throws IOException {
@@ -203,7 +203,7 @@ public void write(final String str, final int off, final int len) throws IOExcep
     }
 
     @Test
-    public void nullCharArray() throws Exception {
+    public void testNullCharArray() throws Exception {
         try (ProxyWriter proxy = new ProxyWriter(NullWriter.INSTANCE)) {
             proxy.write((char[]) null);
             proxy.write((char[]) null, 0, 0);
@@ -211,14 +211,14 @@ public void nullCharArray() throws Exception {
     }
 
     @Test
-    public void nullCharSequence() throws Exception {
+    public void testNullCharSequence() throws Exception {
         try (ProxyWriter proxy = new ProxyWriter(NullWriter.INSTANCE)) {
             proxy.append(null);
         }
     }
 
     @Test
-    public void nullString() throws Exception {
+    public void testNullString() throws Exception {
         try (ProxyWriter proxy = new ProxyWriter(NullWriter.INSTANCE)) {
             proxy.write((String) null);
             proxy.write((String) null, 0, 0);
@@ -226,7 +226,7 @@ public void nullString() throws Exception {
     }
 
     @Test
-    public void writeCharArray() throws Exception {
+    public void testWriteCharArray() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.write(new char[] { 'A', 'B', 'C' });
@@ -235,7 +235,7 @@ public void writeCharArray() throws Exception {
     }
 
     @Test
-    public void writeCharArrayPartial() throws Exception {
+    public void testWriteCharArrayPartial() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.write(new char[] { 'A', 'B', 'C' }, 1, 2);
@@ -244,7 +244,7 @@ public void writeCharArrayPartial() throws Exception {
     }
 
     @Test
-    public void writeInt() throws Exception {
+    public void testWriteInt() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.write(65);
@@ -253,7 +253,7 @@ public void writeInt() throws Exception {
     }
 
     @Test
-    public void writeString() throws Exception {
+    public void testWriteString() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.write("ABC");
@@ -262,7 +262,7 @@ public void writeString() throws Exception {
     }
 
     @Test
-    public void writeStringPartial() throws Exception {
+    public void testWriteStringPartial() throws Exception {
         try (StringBuilderWriter writer = new StringBuilderWriter();
                 final ProxyWriter proxy = new ProxyWriter(writer)) {
             proxy.write("ABC", 1, 2);
diff --git a/src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java
index 8502e05b..4ac19419 100644
--- a/src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java
@@ -66,7 +66,7 @@ public void testNullArgument() {
     }
 
     @Test
-    public void writeInterrupted() throws Exception {
+    public void testWriteInterrupted() throws Exception {
         try (QueueOutputStream outputStream = new QueueOutputStream(new LinkedBlockingQueue<>(1));
                 final QueueInputStream inputStream = outputStream.newQueueInputStream()) {
 
@@ -97,7 +97,7 @@ public void writeInterrupted() throws Exception {
     }
 
     @Test
-    public void writeString() throws Exception {
+    public void testWriteString() throws Exception {
         try (QueueOutputStream outputStream = new QueueOutputStream();
                 final QueueInputStream inputStream = outputStream.newQueueInputStream()) {
             outputStream.write("ABC".getBytes(UTF_8));
@@ -107,7 +107,7 @@ public void writeString() throws Exception {
     }
 
     @Test
-    public void writeStringMultiThread() throws Exception {
+    public void testWriteStringMultiThread() throws Exception {
         try (QueueOutputStream outputStream = callInThrowAwayThread(QueueOutputStream::new);
                 final QueueInputStream inputStream = callInThrowAwayThread(outputStream::newQueueInputStream)) {
             callInThrowAwayThread(() -> {
diff --git a/src/test/java/org/apache/commons/io/output/RandomAccessFileOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/RandomAccessFileOutputStreamTest.java
new file mode 100644
index 00000000..5984a0d8
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/output/RandomAccessFileOutputStreamTest.java
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.output;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+
+/**
+ * Tests {@link RandomAccessFileOutputStream}.
+ */
+public class RandomAccessFileOutputStreamTest {
+
+    private static final String EXPECTED = "Put the message in the box";
+
+    /** A temporary folder. */
+    @TempDir
+    public Path temporaryFolder;
+
+    @Test
+    public void testClose() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteInt.txt");
+        final Charset charset = StandardCharsets.US_ASCII;
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .setOpenOptions(StandardOpenOption.WRITE)
+                .get()) {
+            os.write(EXPECTED.getBytes(charset));
+            os.close();
+        }
+        assertEquals(EXPECTED, new String(Files.readAllBytes(fixturePath), charset));
+        // @formatter:on
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder().setPath(fixturePath).get()) {
+        }
+    }
+
+    @Test
+    public void testFlush() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteInt.txt");
+        final Charset charset = StandardCharsets.US_ASCII;
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .setOpenOptions(StandardOpenOption.WRITE)
+                .get()) {
+            final byte[] bytes = EXPECTED.getBytes(charset);
+            for (final byte element : bytes) {
+                os.write(element);
+                os.flush();
+            }
+        }
+        assertEquals(EXPECTED, new String(Files.readAllBytes(fixturePath), charset));
+        // @formatter:on
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder().setPath(fixturePath).get()) {
+        }
+    }
+
+    @Test
+    public void testWriteByteArray() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteInt.txt");
+        final Charset charset = StandardCharsets.US_ASCII;
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .setOpenOptions(StandardOpenOption.WRITE)
+                .get()) {
+            os.write(EXPECTED.getBytes(charset));
+        }
+        assertEquals(EXPECTED, new String(Files.readAllBytes(fixturePath), charset));
+        // @formatter:on
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder().setPath(fixturePath).get()) {
+        }
+    }
+
+    @Test
+    public void testWriteByteArrayAt() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteInt.txt");
+        final Charset charset = StandardCharsets.US_ASCII;
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .setOpenOptions(StandardOpenOption.WRITE)
+                .get()) {
+            os.write(EXPECTED.getBytes(charset), 1, EXPECTED.length() - 2);
+        }
+        assertEquals(EXPECTED.subSequence(1, EXPECTED.length() - 1), new String(Files.readAllBytes(fixturePath), charset));
+        // @formatter:on
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder().setPath(fixturePath).get()) {
+        }
+    }
+
+    @Test
+    public void testWriteGet() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteGet.txt");
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .setOpenOptions(StandardOpenOption.WRITE)
+                .get()) {
+            // doNothing
+        }
+        // @formatter:on
+    }
+
+    @Test
+    public void testWriteGetDefault() throws IOException {
+        assertThrows(IllegalStateException.class, () -> {
+            try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder().get()) {
+                // doNothing
+            }
+        });
+    }
+
+    /**
+     * Tests that the default OpenOption is WRITE.
+     *
+     * @throws IOException Thrown when the test fails.
+     */
+    @Test
+    public void testWriteGetPathOnly() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteGet.txt");
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .get()) {
+            // doNothing
+        }
+        // @formatter:on
+    }
+
+    @Test
+    public void testWriteInt() throws IOException {
+        final Path fixturePath = temporaryFolder.resolve("testWriteInt.txt");
+        final Charset charset = StandardCharsets.US_ASCII;
+        // @formatter:off
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder()
+                .setPath(fixturePath)
+                .setOpenOptions(StandardOpenOption.WRITE)
+                .get()) {
+            final byte[] bytes = EXPECTED.getBytes(charset);
+            for (final byte element : bytes) {
+                os.write(element);
+            }
+        }
+        assertEquals(EXPECTED, new String(Files.readAllBytes(fixturePath), charset));
+        // @formatter:on
+        try (RandomAccessFileOutputStream os = RandomAccessFileOutputStream.builder().setPath(fixturePath).get()) {
+        }
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java b/src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java
index 3c1cdf30..cb043f72 100644
--- a/src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java
+++ b/src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java
@@ -30,7 +30,6 @@
 public class StringBuilderWriterTest {
     private static final char[] FOOBAR_CHARS = {'F', 'o', 'o', 'B', 'a', 'r'};
 
-
     @Test
     public void testAppendChar() throws IOException {
         try (Writer writer = new StringBuilderWriter()) {
diff --git a/src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java
index 080a4927..bf94520f 100644
--- a/src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java
@@ -34,7 +34,7 @@ public class ThresholdingOutputStreamTest {
 
     @Test
     public void testSetByteCount_OutputStream() throws Exception {
-        final AtomicBoolean reached = new AtomicBoolean(false);
+        final AtomicBoolean reached = new AtomicBoolean();
         try (ThresholdingOutputStream tos = new ThresholdingOutputStream(3) {
             {
                 setByteCount(2);
@@ -59,7 +59,7 @@ protected void thresholdReached() throws IOException {
 
     @Test
     public void testSetByteCount_Stream() throws Exception {
-        final AtomicBoolean reached = new AtomicBoolean(false);
+        final AtomicBoolean reached = new AtomicBoolean();
         try (ThresholdingOutputStream tos = new ThresholdingOutputStream(3) {
             {
                 setByteCount(2);
@@ -132,4 +132,61 @@ public void testThresholdIOConsumerUncheckedException() throws Exception {
             assertThrows(IllegalStateException.class, () -> tos.write('a'));
         }
     }
+
+    /**
+     * Tests the case where the threshold is negative.
+     * The threshold is not reached until something is written to the stream.
+     */
+    @Test
+    public void testThresholdLessThanZero() throws IOException {
+        final AtomicBoolean reached = new AtomicBoolean();
+        try (final ThresholdingOutputStream out = new ThresholdingOutputStream(-1) {
+            @Override
+            protected void thresholdReached() throws IOException {
+                reached.set(true);
+            }
+        }) {
+            assertFalse(reached.get());
+            out.write(89);
+            assertTrue(reached.get());
+            assertTrue(out.isThresholdExceeded());
+        }
+    }
+
+    @Test
+    public void testThresholdZero() throws IOException {
+        final AtomicBoolean reached = new AtomicBoolean();
+        try (final ThresholdingOutputStream out = new ThresholdingOutputStream(0) {
+            @Override
+            protected void thresholdReached() throws IOException {
+                reached.set(true);
+            }
+        }) {
+            assertFalse(out.isThresholdExceeded());
+            out.write(89);
+            assertTrue(reached.get());
+            assertTrue(out.isThresholdExceeded());
+        }
+    }
+
+    /**
+     * Tests the case where no bytes are written.
+     * The threshold is not reached until something is written to the stream.
+     */
+    @Test
+    public void testThresholdZeroWrite() throws IOException {
+        final AtomicBoolean reached = new AtomicBoolean();
+        try (final ThresholdingOutputStream out = new ThresholdingOutputStream(7) {
+            @Override
+            protected void thresholdReached() throws IOException {
+                reached.set(true);
+            }
+        }) {
+            assertFalse(out.isThresholdExceeded());
+            assertFalse(reached.get());
+            out.write(new byte[0]);
+            assertFalse(out.isThresholdExceeded());
+            assertFalse(reached.get());
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java
index 61355907..9a1d68df 100644
--- a/src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java
@@ -29,6 +29,7 @@
 
 import org.apache.commons.io.Charsets;
 import org.apache.commons.io.charset.CharsetDecoders;
+import org.apache.commons.lang3.SystemProperties;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -124,7 +125,7 @@ public void testUTF16WithBufferedWrite() throws IOException {
         try {
             testWithBufferedWrite(TEST_STRING, UTF_16);
         } catch (final UnsupportedOperationException e) {
-            if (!System.getProperty("java.vendor").contains("IBM")) {
+            if (!SystemProperties.getJavaVendor().contains("IBM")) {
                 fail("This test should only throw UOE on IBM JDKs with broken UTF-16");
             }
         }
@@ -135,7 +136,7 @@ public void testUTF16WithSingleByteWrite() throws IOException {
         try {
             testWithSingleByteWrite(TEST_STRING, UTF_16);
         } catch (final UnsupportedOperationException e){
-            if (!System.getProperty("java.vendor").contains("IBM")){
+            if (!SystemProperties.getJavaVendor().contains("IBM")){
                 fail("This test should only throw UOE on IBM JDKs with broken UTF-16");
             }
         }
@@ -165,7 +166,6 @@ private void testWithBufferedWrite(final String testString, final String charset
         assertEquals(testString, writer.toString());
     }
 
-
     private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {
         final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));
         StringWriter writer = new StringWriter();
diff --git a/src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java b/src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java
index 71bfbd27..92509f22 100644
--- a/src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java
+++ b/src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java
@@ -32,11 +32,6 @@
 public abstract class AbstractCloseableListTest {
     private final List<Closeable> closeableList = new ArrayList<>();
 
-    @AfterEach
-    public void cleanup() {
-        IOUtils.closeQuietly(closeableList);
-    }
-
     /**
      * Adds a Closeable to close after each test.
      *
@@ -44,13 +39,18 @@ public void cleanup() {
      * @param t The Closeable.
      * @return The Closeable.
      */
-    protected <T extends Closeable> T closeAfterEachTest(final T t) {
+    protected <T extends Closeable> T addCloseable(final T t) {
         closeableList.add(t);
         return t;
     }
 
+    @AfterEach
+    public void cleanup() {
+        IOUtils.closeQuietly(closeableList);
+    }
+
     @BeforeEach
-    public void setup() {
+    public void clearCloseable() {
         closeableList.clear();
     }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java b/src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java
index f92d6052..eaad14bd 100644
--- a/src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java
+++ b/src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java
@@ -31,13 +31,13 @@ public class FullClassNameMatcherTest {
     private static final String [] NAMES_ARRAY = { Integer.class.getName(), Long.class.getName() };
 
     @Test
-    public void noNames() {
+    public void testNoNames() {
         final FullClassNameMatcher m = new FullClassNameMatcher();
         assertFalse(m.matches(Integer.class.getName()));
     }
 
     @Test
-    public void withNames() {
+    public void testWithNames() {
         final FullClassNameMatcher m = new FullClassNameMatcher(NAMES_ARRAY);
         assertTrue(m.matches(Integer.class.getName()));
         assertFalse(m.matches(String.class.getName()));
diff --git a/src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java b/src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java
index 8e0cb826..942aff86 100644
--- a/src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java
+++ b/src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java
@@ -20,7 +20,11 @@
 
 import java.io.Serializable;
 
+/**
+ * Test fixture for {@link ValidatingObjectInputStreamTest}.
+ */
 public class MockSerializedClass implements Serializable {
+
     private static final long serialVersionUID = 2139985988735372175L;
 
     private final String str;
@@ -34,7 +38,7 @@ public boolean equals(final Object obj) {
         if (!(obj instanceof MockSerializedClass)) {
             return false;
         }
-        return str.equals(((MockSerializedClass)obj).str);
+        return str.equals(((MockSerializedClass) obj).str);
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java b/src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java
index 201b52df..1e0a4997 100644
--- a/src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java
+++ b/src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java
@@ -25,9 +25,8 @@
 import java.util.Random;
 import java.util.UUID;
 
-/** A test class that uses various java.* member objects,
- *  to show which settings are necessary to deserialize
- *  those.
+/**
+ * A test class that uses various java.* member objects, to show which settings are necessary to deserialize those.
  */
 public class MoreComplexObject implements Serializable {
     private static final long serialVersionUID = -5187124661539240729L;
@@ -37,11 +36,11 @@ public class MoreComplexObject implements Serializable {
     private final Integer integer = random.nextInt();
     private final int pInt = random.nextInt();
     private final long pLong = random.nextLong();
-    private final Integer [] intArray = { random.nextInt(), random.nextInt() };
+    private final Integer[] intArray = { random.nextInt(), random.nextInt() };
     private final List<Boolean> boolList = new ArrayList<>();
 
     MoreComplexObject() {
-        for(int i=0 ; i < 5; i++) {
+        for (int i = 0; i < 5; i++) {
             boolList.add(random.nextBoolean());
         }
     }
diff --git a/src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java b/src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java
index 82729508..aef6d421 100644
--- a/src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java
+++ b/src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java
@@ -50,55 +50,66 @@ private void assertSerialization(final ObjectInputStream ois) throws ClassNotFou
     @BeforeEach
     public void setupMoreComplexObject() throws IOException {
         original = new MoreComplexObject();
-        final ByteArrayOutputStream bos = closeAfterEachTest(new ByteArrayOutputStream());
-        final ObjectOutputStream oos = closeAfterEachTest(new ObjectOutputStream(bos));
+        final ByteArrayOutputStream bos = addCloseable(new ByteArrayOutputStream());
+        final ObjectOutputStream oos = addCloseable(new ObjectOutputStream(bos));
         oos.writeObject(original);
-        inputStream = closeAfterEachTest(new ByteArrayInputStream(bos.toByteArray()));
+        inputStream = addCloseable(new ByteArrayInputStream(bos.toByteArray()));
     }
 
-    /** Trusting java.* is probably reasonable and avoids having to be too
-     *  detailed in the accepts.
+    /**
+     * Trusting java.* is probably reasonable and avoids having to be too detailed in the accepts.
      */
     @Test
-    public void trustJavaIncludingArrays() throws IOException, ClassNotFoundException {
-        assertSerialization(closeAfterEachTest(
-                new ValidatingObjectInputStream(inputStream)
+    public void testTrustJavaIncludingArrays() throws IOException, ClassNotFoundException {
+        // @formatter:off
+        assertSerialization(addCloseable(
+                ValidatingObjectInputStream.builder()
+                .setInputStream(inputStream)
                 .accept(MoreComplexObject.class)
-                .accept("java.*","[Ljava.*")
+                .accept("java.*", "[Ljava.*")
+                .get()
         ));
+        // @formatter:on
     }
 
-    /** Trusting java.lang.* and the array variants of that means we have
-     *  to define a number of accept classes explicitly. Quite safe but
-     *  might become a bit verbose.
+    /**
+     * Trusting java.lang.* and the array variants of that means we have to define a number of accept classes explicitly. Quite safe but might become a bit
+     * verbose.
      */
     @Test
-    public void trustJavaLang() throws IOException, ClassNotFoundException {
-        assertSerialization(closeAfterEachTest(
-                new ValidatingObjectInputStream(inputStream)
+    public void testTrustJavaLang() throws IOException, ClassNotFoundException {
+        // @formatter:off
+        assertSerialization(addCloseable(
+                ValidatingObjectInputStream.builder()
+                .setInputStream(inputStream)
                 .accept(MoreComplexObject.class, ArrayList.class, Random.class)
-                .accept("java.lang.*","[Ljava.lang.*")
+                .accept("java.lang.*", "[Ljava.lang.*")
+                .get()
         ));
+        // @formatter:on
     }
 
-    /** Here we accept everything but reject specific classes, using a pure
-     *  blacklist mode.
+    /**
+     * Here we accept everything but reject specific classes, using a pure blacklist mode.
      *
-     *  That's not as safe as it's hard to get an exhaustive blacklist, but
-     *  might be ok in controlled environments.
+     * That's not as safe as it's hard to get an exhaustive blacklist, but might be ok in controlled environments.
      */
     @Test
-    public void useBlacklist() throws IOException, ClassNotFoundException {
+    public void testUseBlacklist() throws IOException, ClassNotFoundException {
         final String [] blacklist = {
                 "org.apache.commons.collections.functors.InvokerTransformer",
                 "org.codehaus.groovy.runtime.ConvertedClosure",
                 "org.codehaus.groovy.runtime.MethodClosure",
                 "org.springframework.beans.factory.ObjectFactory"
         };
-        assertSerialization(closeAfterEachTest(
-                new ValidatingObjectInputStream(inputStream)
+        // @formatter:off
+        assertSerialization(addCloseable(
+                ValidatingObjectInputStream.builder()
+                .setInputStream(inputStream)
                 .accept("*")
                 .reject(blacklist)
+                .get()
         ));
+        // @formatter:on
     }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java b/src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java
index ad33d846..36173d99 100644
--- a/src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java
@@ -21,7 +21,6 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -30,9 +29,12 @@
 import java.io.InvalidClassException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.util.HashMap;
 import java.util.UUID;
 import java.util.regex.Pattern;
 
+import org.apache.commons.io.serialization.ValidatingObjectInputStream.Builder;
+import org.apache.commons.lang3.SerializationUtils;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -40,43 +42,95 @@
  * Tests {@link ValidatingObjectInputStream}.
  */
 public class ValidatingObjectInputStreamTest extends AbstractCloseableListTest {
+
     private static final ClassNameMatcher ALWAYS_TRUE = className -> true;
     private MockSerializedClass testObject;
 
     private InputStream testStream;
 
+    private void assertSerialization(final ObjectInputStream ois) throws ClassNotFoundException, IOException {
+        final MockSerializedClass result = (MockSerializedClass) ois.readObject();
+        assertEquals(testObject, result);
+    }
+
+    private Builder newBuilder() {
+        return ValidatingObjectInputStream.builder().setInputStream(testStream);
+    }
+
+    private ValidatingObjectInputStream newFixture() throws IOException {
+        return newBuilder().get();
+    }
+
+    @BeforeEach
+    public void setupMockSerializedClass() throws IOException {
+        testObject = new MockSerializedClass(UUID.randomUUID().toString());
+        final ByteArrayOutputStream bos = addCloseable(new ByteArrayOutputStream());
+        final ObjectOutputStream oos = addCloseable(new ObjectOutputStream(bos));
+        oos.writeObject(testObject);
+        testStream = addCloseable(new ByteArrayInputStream(bos.toByteArray()));
+    }
+
     @Test
-    public void acceptCustomMatcher() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(ALWAYS_TRUE)
-        );
+    public void testAcceptCustomMatcherBuilder() throws Exception {
+        assertSerialization(addCloseable(newBuilder().accept(ALWAYS_TRUE).get()));
     }
 
     @Test
-    public void acceptPattern() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(Pattern.compile(".*MockSerializedClass.*"))
-        );
+    public void testAcceptCustomMatcherInstance() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(ALWAYS_TRUE));
     }
 
     @Test
-    public void acceptWildcard() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept("org.apache.commons.io.*")
-        );
+    public void testAcceptOneFail() throws Exception {
+        assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture()).accept(Integer.class)));
     }
 
-    private void assertSerialization(final ObjectInputStream ois) throws ClassNotFoundException, IOException {
-        final MockSerializedClass result = (MockSerializedClass) ois.readObject();
-        assertEquals(testObject, result);
+    @Test
+    public void testAcceptOnePassBuilder() throws Exception {
+        assertSerialization(addCloseable(newBuilder().accept(MockSerializedClass.class).get()));
+    }
+
+    @Test
+    public void testAcceptOnePassInstance() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class));
+    }
+
+    @Test
+    public void testAcceptPatternBuilder() throws Exception {
+        assertSerialization(addCloseable(newBuilder().accept(Pattern.compile(".*MockSerializedClass.*")).get()));
+    }
+
+    @Test
+    public void testAcceptPatternInstance() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(Pattern.compile(".*MockSerializedClass.*")));
+    }
+
+    @Test
+    public void testAcceptWildcardBuilder() throws Exception {
+        assertSerialization(addCloseable(newBuilder().accept("org.apache.commons.io.*").get()));
     }
 
     @Test
-    public void customInvalidMethod() {
-        class CustomVOIS extends ValidatingObjectInputStream {
+    public void testAcceptWildcardInstance() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept("org.apache.commons.io.*"));
+    }
+
+    @Test
+    public void testBuildDefault() throws Exception {
+        final byte[] serialized = SerializationUtils.serialize("");
+        try (InputStream is = newBuilder().setInputStream(new ByteArrayInputStream(serialized)).get()) {
+            // empty
+        }
+    }
+
+    @Test
+    public void testConstructor() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(ALWAYS_TRUE));
+    }
+
+    @Test
+    public void testCustomInvalidMethod() {
+        final class CustomVOIS extends ValidatingObjectInputStream {
             CustomVOIS(final InputStream is) throws IOException {
                 super(is);
             }
@@ -87,145 +141,187 @@ protected void invalidClassNameFound(final String className) throws InvalidClass
             }
         }
 
-        assertThrows(RuntimeException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new CustomVOIS(testStream))
-                .reject(Integer.class)
-        ));
+        assertThrows(RuntimeException.class, () -> assertSerialization(addCloseable(new CustomVOIS(testStream)).reject(Integer.class)));
+    }
+
+    @Test
+    public void testExceptionIncludesClassName() throws Exception {
+        final InvalidClassException ice = assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture())));
+        final String name = MockSerializedClass.class.getName();
+        assertTrue(ice.getMessage().contains(name), "Expecting message to contain " + name);
     }
 
+    /**
+     * Javadoc example.
+     */
+    @SuppressWarnings({ "unchecked" })
     @Test
-    public void exceptionIncludesClassName() throws Exception {
-        try {
-            assertSerialization(
-                    closeAfterEachTest(new ValidatingObjectInputStream(testStream)));
-            fail("Expected an InvalidClassException");
-        } catch(final InvalidClassException ice) {
-            final String name = MockSerializedClass.class.getName();
-            assertTrue(ice.getMessage().contains(name), "Expecting message to contain " + name);
+    public void testJavadocExample() throws Exception {
+        // @formatter:off
+        // Defining Object fixture
+        final HashMap<String, Integer> map1 = new HashMap<>();
+        map1.put("1", 1);
+        // Writing serialized fixture
+        final byte[] byteArray;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                final ObjectOutputStream oos = new ObjectOutputStream(baos)) {
+            oos.writeObject(map1);
+            oos.flush();
+            byteArray = baos.toByteArray();
         }
+        // Reading
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()
+                        .accept(HashMap.class, Number.class, Integer.class)
+                        .setInputStream(bais)
+                        .get()) {
+            // String.class is automatically accepted
+            final HashMap<String, Integer> map2 = (HashMap<String, Integer>) vois.readObject();
+            assertEquals(map1, map2);
+        }
+        // Reusing a configuration
+        final ObjectStreamClassPredicate predicate = new ObjectStreamClassPredicate()
+                .accept(HashMap.class, Number.class, Integer.class);
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()
+                        .setPredicate(predicate)
+                        .setInputStream(bais)
+                        .get()) {
+            // String.class is automatically accepted
+            final HashMap<String, Integer> map2 = (HashMap<String, Integer>) vois.readObject();
+            assertEquals(map1, map2);
+        }
+        // @formatter:on
     }
 
     @Test
-    public void noAccept() {
-        assertThrows(InvalidClassException.class, () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))));
+    public void testNoAccept() {
+        assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture())));
     }
 
     @Test
-    public void ourTestClassAcceptedFirst() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(MockSerializedClass.class, Integer.class)
-        );
+    public void testOurTestClassAcceptedFirst() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class, Integer.class));
     }
 
     @Test
-    public void ourTestClassAcceptedFirstWildcard() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept("*MockSerializedClass","*Integer")
-        );
+    public void testOurTestClassAcceptedFirstWildcard() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept("*MockSerializedClass", "*Integer"));
     }
 
     @Test
-    public void ourTestClassAcceptedSecond() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(Integer.class, MockSerializedClass.class)
-        );
+    public void testOurTestClassAcceptedSecond() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(Integer.class, MockSerializedClass.class));
     }
 
     @Test
-    public void ourTestClassAcceptedSecondWildcard() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept("*Integer","*MockSerializedClass")
-        );
+    public void testOurTestClassAcceptedSecondWildcard() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept("*Integer", "*MockSerializedClass"));
     }
 
     @Test
-    public void ourTestClassNotAccepted() {
-        assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(Integer.class)
-        ));
+    public void testOurTestClassNotAccepted() {
+        assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture()).accept(Integer.class)));
     }
 
     @Test
-    public void ourTestClassOnlyAccepted() throws Exception {
-        assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(MockSerializedClass.class)
-        );
+    public void testOurTestClassOnlyAccepted() throws Exception {
+        assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class));
     }
 
     @Test
-    public void reject() {
+    public void testRejectBuilder() {
         assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(Long.class)
-                .reject(MockSerializedClass.class, Integer.class)
-        ));
+                () -> assertSerialization(addCloseable(newBuilder().accept(Long.class).reject(MockSerializedClass.class, Integer.class).get())));
     }
 
     @Test
-    public void rejectCustomMatcher() {
+    public void testRejectCustomMatcherBuilder() {
         assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(MockSerializedClass.class)
-                .reject(ALWAYS_TRUE)
-        ));
+                () -> assertSerialization(addCloseable(newBuilder().accept(MockSerializedClass.class).reject(ALWAYS_TRUE).get())));
     }
 
     @Test
-    public void rejectOnly() {
+    public void testRejectCustomMatcherInstance() {
+        assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class).reject(ALWAYS_TRUE)));
+    }
+
+    @Test
+    public void testRejectInstance() {
         assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .reject(Integer.class)
-        ));
+                () -> assertSerialization(addCloseable(newFixture()).accept(Long.class).reject(MockSerializedClass.class, Integer.class)));
+    }
+
+    @Test
+    public void testRejectOnly() {
+        assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture()).reject(Integer.class)));
     }
 
     @Test
-    public void rejectPattern() {
+    public void testRejectPattern() {
         assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(MockSerializedClass.class)
-                .reject(Pattern.compile("org.*"))
-        ));
+                () -> assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class).reject(Pattern.compile("org.*"))));
     }
 
     @Test
-    public void rejectPrecedence() {
+    public void testRejectPrecedenceBuilder() {
         assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(MockSerializedClass.class)
-                .reject(MockSerializedClass.class, Integer.class)
-        ));
+                () -> assertSerialization(addCloseable(newBuilder().accept(MockSerializedClass.class).reject(MockSerializedClass.class, Integer.class).get())));
     }
 
     @Test
-    public void rejectWildcard() {
+    public void testRejectPrecedenceInstance() {
         assertThrows(InvalidClassException.class,
-                () -> assertSerialization(
-                closeAfterEachTest(new ValidatingObjectInputStream(testStream))
-                .accept(MockSerializedClass.class)
-                .reject("org.*")
-        ));
+                () -> assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class).reject(MockSerializedClass.class, Integer.class)));
     }
 
-    @BeforeEach
-    public void setupMockSerializedClass() throws IOException {
-        testObject = new MockSerializedClass(UUID.randomUUID().toString());
-        final ByteArrayOutputStream bos = closeAfterEachTest(new ByteArrayOutputStream());
-        final ObjectOutputStream oos = closeAfterEachTest(new ObjectOutputStream(bos));
-        oos.writeObject(testObject);
-        testStream = closeAfterEachTest(new ByteArrayInputStream(bos.toByteArray()));
+    @Test
+    public void testRejectWildcardBuilder() {
+        assertThrows(InvalidClassException.class,
+                () -> assertSerialization(addCloseable(newBuilder().accept(MockSerializedClass.class).reject("org.*").get())));
+    }
+
+    @Test
+    public void testRejectWildcardInstance() {
+        assertThrows(InvalidClassException.class, () -> assertSerialization(addCloseable(newFixture()).accept(MockSerializedClass.class).reject("org.*")));
+    }
+
+    @Test
+    public void testReuseConfiguration() throws Exception {
+        // Defining Object fixture
+        final HashMap<String, Integer> map1 = new HashMap<>();
+        map1.put("1", 1);
+        // Writing serialized fixture
+        final byte[] byteArray;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                final ObjectOutputStream oos = new ObjectOutputStream(baos)) {
+            oos.writeObject(map1);
+            oos.flush();
+            byteArray = baos.toByteArray();
+        }
+        // Reusing a configuration: ObjectStreamClassPredicate
+        final ObjectStreamClassPredicate predicate = new ObjectStreamClassPredicate().accept(HashMap.class, Number.class, Integer.class);
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder().setPredicate(predicate).setInputStream(bais).get()) {
+            // String.class is automatically accepted
+            assertEquals(map1, vois.readObjectCast());
+        }
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder().setPredicate(predicate).setInputStream(bais).get()) {
+            // String.class is automatically accepted
+            assertEquals(map1, vois.readObjectCast());
+        }
+        // Reusing a configuration: Builder and ObjectStreamClassPredicate
+        final Builder builder = ValidatingObjectInputStream.builder().setPredicate(predicate);
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = builder.setInputStream(bais).get()) {
+            // String.class is automatically accepted
+            assertEquals(map1, vois.readObjectCast());
+        }
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
+                ValidatingObjectInputStream vois = builder.setInputStream(bais).get()) {
+            // String.class is automatically accepted
+            assertEquals(map1, vois.readObjectCast());
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java b/src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java
index 6da59cce..c793247f 100644
--- a/src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java
+++ b/src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java
@@ -29,7 +29,7 @@
 public class WildcardClassNameMatcherTest {
 
     @Test
-    public void noPattern() {
+    public void testNoPattern() {
         final ClassNameMatcher ca = new WildcardClassNameMatcher("org.foo");
         assertTrue(ca.matches("org.foo"));
         assertFalse(ca.matches("org.foo.and.more"));
@@ -37,14 +37,14 @@ public void noPattern() {
     }
 
     @Test
-    public void star() {
+    public void testStar() {
         final ClassNameMatcher ca = new WildcardClassNameMatcher("org*");
         assertTrue(ca.matches("org.foo.should.match"));
         assertFalse(ca.matches("bar.should.not.match"));
     }
 
     @Test
-    public void starAndQuestionMark() {
+    public void testStarAndQuestionMark() {
         final ClassNameMatcher ca = new WildcardClassNameMatcher("org?apache?something*");
         assertTrue(ca.matches("org.apache_something.more"));
         assertFalse(ca.matches("org..apache_something.more"));
diff --git a/src/test/java/org/apache/commons/io/test/CustomIOException.java b/src/test/java/org/apache/commons/io/test/CustomIOException.java
new file mode 100644
index 00000000..dcd4f7cf
--- /dev/null
+++ b/src/test/java/org/apache/commons/io/test/CustomIOException.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.test;
+
+import java.io.IOException;
+
+/**
+ * A custom IOException for testing that an exact IOException is thrown.
+ */
+public class CustomIOException extends IOException {
+
+    private static final long serialVersionUID = 1L;
+
+    public CustomIOException() {
+    }
+
+    public CustomIOException(final String message) {
+        super(message);
+    }
+
+    public CustomIOException(final String message, final Throwable cause) {
+        super(message, cause);
+    }
+
+    public CustomIOException(final Throwable cause) {
+        super(cause);
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java b/src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java
index 5a123796..5dd9fb16 100644
--- a/src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java
+++ b/src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java
@@ -28,20 +28,26 @@
 public class ThrowOnCloseInputStream extends ProxyInputStream {
 
     /**
-     * Default constructor.
+     * Constructs a new instance.
      */
     public ThrowOnCloseInputStream() {
-        super(NullInputStream.INSTANCE);
+        super(new NullInputStream());
     }
 
     /**
+     * Constructs a new instance.
+     *
      * @param proxy InputStream to delegate to.
      */
     public ThrowOnCloseInputStream(final InputStream proxy) {
         super(proxy);
     }
 
-    /** @see java.io.InputStream#close() */
+    /**
+     * Always throws IOException.
+     *
+     * @see java.io.InputStream#close()
+     */
     @Override
     public void close() throws IOException {
         throw new IOException(getClass().getSimpleName() + ".close() called.");
diff --git a/src/test/resources/org/apache/commons/io/bla-copy.zip b/src/test/resources/org/apache/commons/io/bla-copy.zip
new file mode 100644
index 00000000..160eedc6
Binary files /dev/null and b/src/test/resources/org/apache/commons/io/bla-copy.zip differ
diff --git a/src/test/resources/org/apache/commons/io/bla.zip b/src/test/resources/org/apache/commons/io/bla.zip
new file mode 100644
index 00000000..160eedc6
Binary files /dev/null and b/src/test/resources/org/apache/commons/io/bla.zip differ
diff --git a/src/test/resources/org/apache/commons/io/moby.zip b/src/test/resources/org/apache/commons/io/moby.zip
new file mode 100644
index 00000000..ae3f9ee6
Binary files /dev/null and b/src/test/resources/org/apache/commons/io/moby.zip differ
diff --git a/src/test/resources/org/apache/commons/io/test-same-size-diff-contents.zip b/src/test/resources/org/apache/commons/io/test-same-size-diff-contents.zip
new file mode 100644
index 00000000..4e49eb3d
Binary files /dev/null and b/src/test/resources/org/apache/commons/io/test-same-size-diff-contents.zip differ
```

