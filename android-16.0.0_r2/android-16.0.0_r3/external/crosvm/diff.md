```diff
diff --git a/.cargo/config.toml b/.cargo/config.toml
index 455cc2d71..a41446e94 100644
--- a/.cargo/config.toml
+++ b/.cargo/config.toml
@@ -11,21 +11,20 @@ rustflags = [
     "-Aclippy::collapsible_if",
     "-Aclippy::enum_variant_names",
     "-Aclippy::identity_op",
-    "-Aclippy::match_bool",
-    "-Aclippy::match_wild_err_arm",
     "-Aclippy::needless_bool",
     "-Aclippy::new-ret-no-self",
-    "-Aclippy::or_fun_call",
     "-Aclippy::result_large_err",
     "-Aclippy::result-unit-err",
-    "-Aclippy::should_implement_trait",
-    "-Aclippy::single_char_pattern",
     "-Aclippy::single-range-in-vec-init",
     "-Aclippy::too_many_arguments",
-    "-Aclippy::trivially_copy_pass_by_ref",
     "-Aclippy::type_complexity",
     "-Aclippy::unreadable_literal",
-    "-Aclippy::useless_let_if_seq",
     "-Aclippy::useless_transmute",
     "-Dclippy::undocumented_unsafe_blocks",
 ]
+
+[env]
+
+# The downstream can use these environment variables to set the gfxstream libraries search path.
+GFXSTREAM_PATH_DEBUG = ""
+GFXSTREAM_PATH_RELEASE = ""
diff --git a/Android.bp b/Android.bp
index fa970c8d7..3846967be 100644
--- a/Android.bp
+++ b/Android.bp
@@ -69,12 +69,12 @@ rust_binary {
         "virgl_renderer",
     ],
     rustlibs: [
+        "libaarch64_sys_reg",
         "libacpi_tables",
         "libandroid_audio",
         "libanyhow",
         "libarch",
         "libargh",
-        "libaudio_streams",
         "libbase_rust",
         "libbit_field_crosvm",
         "libbroker_ipc",
@@ -99,7 +99,6 @@ rust_binary {
         "libmetrics_events",
         "libminijail_rust",
         "libnet_util",
-        "libonce_cell",
         "libp9",
         "libresources",
         "librutabaga_gfx",
@@ -212,12 +211,12 @@ rust_test {
         "virgl_renderer",
     ],
     rustlibs: [
+        "libaarch64_sys_reg",
         "libacpi_tables",
         "libandroid_audio",
         "libanyhow",
         "libarch",
         "libargh",
-        "libaudio_streams",
         "libbase_rust",
         "libbit_field_crosvm",
         "libbroker_ipc",
@@ -242,9 +241,8 @@ rust_test {
         "libmetrics_events",
         "libminijail_rust",
         "libnet_util",
-        "libonce_cell",
         "libp9",
-        "librand",
+        "librand-0.8",
         "libresources",
         "librutabaga_gfx",
         "libserde",
diff --git a/Cargo.lock b/Cargo.lock
index fbcaed68c..4001aeec2 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -6,6 +6,7 @@ version = 3
 name = "aarch64"
 version = "0.1.0"
 dependencies = [
+ "aarch64_sys_reg",
  "anyhow",
  "arch",
  "base",
@@ -29,6 +30,14 @@ dependencies = [
  "vm_memory",
 ]
 
+[[package]]
+name = "aarch64_sys_reg"
+version = "0.1.0"
+dependencies = [
+ "serde",
+ "thiserror",
+]
+
 [[package]]
 name = "acpi_tables"
 version = "0.1.0"
@@ -295,7 +304,6 @@ dependencies = [
  "futures",
  "libc",
  "log",
- "once_cell",
  "protobuf",
  "rand",
  "remain",
@@ -563,6 +571,33 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "ciborium"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42e69ffd6f0917f5c029256a24d0161db17cea3997d185db0d35926308770f0e"
+dependencies = [
+ "ciborium-io",
+ "ciborium-ll",
+ "serde",
+]
+
+[[package]]
+name = "ciborium-io"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05afea1e0a06c9be33d539b876f1ce3692f4afea2cb41f740e7743225ed1c757"
+
+[[package]]
+name = "ciborium-ll"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57663b653d948a338bfb3eeba9bb2fd5fcfaecb9e199e87e1eda4d9e8b240fd9"
+dependencies = [
+ "ciborium-io",
+ "half",
+]
+
 [[package]]
 name = "clang-sys"
 version = "1.4.0"
@@ -726,7 +761,6 @@ dependencies = [
  "intrusive-collections",
  "io_uring",
  "libc",
- "once_cell",
  "paste",
  "pin-utils",
  "remain",
@@ -828,6 +862,7 @@ name = "crosvm"
 version = "0.1.0"
 dependencies = [
  "aarch64",
+ "aarch64_sys_reg",
  "acpi_tables",
  "android_audio",
  "anti_tamper",
@@ -835,7 +870,6 @@ dependencies = [
  "arch",
  "argh",
  "argh_helpers",
- "audio_streams",
  "base",
  "bit_field",
  "broker_ipc",
@@ -869,7 +903,6 @@ dependencies = [
  "metrics_events",
  "minijail",
  "net_util",
- "once_cell",
  "p9",
  "protobuf",
  "protos",
@@ -1030,6 +1063,7 @@ dependencies = [
 name = "devices"
 version = "0.1.0"
 dependencies = [
+ "aarch64_sys_reg",
  "acpi_tables",
  "android_audio",
  "anyhow",
@@ -1045,6 +1079,7 @@ dependencies = [
  "bytes",
  "cfg-if",
  "chrono",
+ "ciborium",
  "crc32fast",
  "cros-codecs",
  "cros_async",
@@ -1074,7 +1109,6 @@ dependencies = [
  "net_sys",
  "net_util",
  "num-traits",
- "once_cell",
  "p9",
  "power_monitor",
  "protobuf",
@@ -1504,11 +1538,12 @@ dependencies = [
 
 [[package]]
 name = "half"
-version = "2.1.0"
+version = "2.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ad6a9459c9c30b177b925162351f97e7d967c7ea8bab3b8352805327daf45554"
+checksum = "6dd08c532ae367adf81c312a4580bc67f1d0fe8bc9c460520283f4c0ff277888"
 dependencies = [
  "bytemuck",
+ "cfg-if",
  "crunchy",
 ]
 
@@ -1549,6 +1584,7 @@ checksum = "fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286"
 name = "hypervisor"
 version = "0.1.0"
 dependencies = [
+ "aarch64_sys_reg",
  "anyhow",
  "base",
  "bit_field",
@@ -1561,7 +1597,6 @@ dependencies = [
  "hypervisor_test_macro",
  "kvm_sys",
  "libc",
- "once_cell",
  "serde",
  "serde_json",
  "snapshot",
@@ -1693,7 +1728,6 @@ dependencies = [
  "libtest-mimic",
  "log",
  "minijail",
- "once_cell",
  "rayon",
  "serde",
  "serde_keyvalue",
@@ -2428,9 +2462,9 @@ dependencies = [
 
 [[package]]
 name = "protobuf"
-version = "3.6.0"
+version = "3.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3018844a02746180074f621e847703737d27d89d7f0721a7a4da317f88b16385"
+checksum = "d65a1d4ddae7d8b5de68153b48f6aa3bba8cb002b243dbdbc55a5afbc98f99f4"
 dependencies = [
  "once_cell",
  "protobuf-support",
@@ -2439,9 +2473,9 @@ dependencies = [
 
 [[package]]
 name = "protobuf-codegen"
-version = "3.6.0"
+version = "3.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "411c15a212b4de05eb8bc989fd066a74c86bd3c04e27d6e86bd7703b806d7734"
+checksum = "5d3976825c0014bbd2f3b34f0001876604fe87e0c86cd8fa54251530f1544ace"
 dependencies = [
  "anyhow",
  "once_cell",
@@ -2454,9 +2488,9 @@ dependencies = [
 
 [[package]]
 name = "protobuf-parse"
-version = "3.6.0"
+version = "3.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "06f45f16b522d92336e839b5e40680095a045e36a1e7f742ba682ddc85236772"
+checksum = "b4aeaa1f2460f1d348eeaeed86aea999ce98c1bded6f089ff8514c9d9dbdc973"
 dependencies = [
  "anyhow",
  "indexmap 2.6.0",
@@ -2470,9 +2504,9 @@ dependencies = [
 
 [[package]]
 name = "protobuf-support"
-version = "3.6.0"
+version = "3.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "faf96d872914fcda2b66d66ea3fff2be7c66865d31c7bb2790cff32c0e714880"
+checksum = "3e36c2f31e0a47f9280fb347ef5e461ffcd2c52dd520d8e216b52f93b0b0d7d6"
 dependencies = [
  "thiserror",
 ]
@@ -2638,6 +2672,7 @@ dependencies = [
  "rand",
  "remain",
  "resources",
+ "swap",
  "sync",
  "thiserror",
  "vm_control",
@@ -2672,7 +2707,7 @@ dependencies = [
 
 [[package]]
 name = "rutabaga_gfx"
-version = "0.1.3"
+version = "0.1.6"
 dependencies = [
  "anyhow",
  "cfg-if",
@@ -2835,6 +2870,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "base",
+ "ciborium",
  "crypto_generic",
  "serde",
  "serde_json",
@@ -2875,7 +2911,6 @@ dependencies = [
  "libtest-mimic",
  "metrics",
  "num_cpus",
- "once_cell",
  "remain",
  "serde",
  "serde_json",
@@ -3293,7 +3328,6 @@ dependencies = [
  "libc",
  "metrics",
  "metrics_events",
- "once_cell",
  "protos",
  "remain",
  "resources",
@@ -3470,7 +3504,6 @@ dependencies = [
  "cros_async",
  "libc",
  "metrics",
- "once_cell",
  "prebuilts",
  "sync",
  "thiserror",
@@ -3486,7 +3519,7 @@ dependencies = [
  "anyhow",
  "enumn",
  "libc",
- "once_cell",
+ "log",
  "serde",
  "winapi",
  "windows",
@@ -3751,7 +3784,6 @@ dependencies = [
  "kernel_loader",
  "libc",
  "minijail",
- "once_cell",
  "rand",
  "remain",
  "resources",
diff --git a/Cargo.toml b/Cargo.toml
index ab37f0435..44804d479 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -38,6 +38,7 @@ codegen-units = 1
 # by dependencies.
 members = [
     "aarch64",
+    "aarch64_sys_reg",
     "acpi_tables",
     "android_audio",
     "arch",
@@ -68,6 +69,7 @@ members = [
     "hypervisor",
     "hypervisor/hypervisor_test_macro",
     "io_uring",
+    "jail",
     "kernel_cmdline",
     "kernel_loader",
     "kvm_sys",
@@ -84,6 +86,7 @@ members = [
     "protos",
     "proto_build_tools",
     "resources",
+    "riscv64",
     "rutabaga_gfx",
     "serde_keyvalue",
     "snapshot",
@@ -91,6 +94,7 @@ members = [
     "system_api",
     "third_party/vmm_vhost",
     "tools/impl/catapult_converter",
+    "tube_transporter",
     "usb_sys",
     "usb_util",
     "vendor/generic/anti_tamper",
@@ -101,6 +105,8 @@ members = [
     "virtio_sys",
     "vm_control",
     "vm_memory",
+    "win_audio",
+    "win_util",
     "x86_64",
 ]
 
@@ -117,8 +123,95 @@ exclude = [
 ]
 
 [workspace.dependencies]
-tokio = { version = "1.29.1", features = ["net", "rt-multi-thread", "time", "sync", "macros"] }
+# Workspace members
+aarch64 = { path = "aarch64" }
+aarch64_sys_reg = { path = "aarch64_sys_reg" }
+acpi_tables = { path = "acpi_tables" }
+android_audio = { path = "android_audio" }
+anti_tamper = { path = "vendor/generic/anti_tamper" }
+arch = { path = "arch" }
+argh_helpers = { path = "argh_helpers" }
+audio_streams = { path = "common/audio_streams" }
+audio_streams_conformance_test = { path = "audio_streams_conformance_test" }
+audio_util = { path = "audio_util" }
+balloon_control = { path = "common/balloon_control" }
+base = { path = "base" }
+base_tokio = { path = "base_tokio" }
+bit_field = { path = "bit_field" }
+broker_ipc = { path = "broker_ipc" }
+catapult_converter = { path = "tools/impl/catapult_converter" }
+crash_report = { path = "vendor/generic/crash_report" }
+cros_async = { path = "cros_async" }
+cros_fdt = { path = "cros_fdt" }
+cros_tracing = { path = "cros_tracing" }
+crosvm_cli = { path = "crosvm_cli" }
+crosvm_control = { path = "crosvm_control" }
+crosvm_plugin = { path = "crosvm_plugin" }
+crypto = { path = "vendor/generic/crypto", package = "crypto_generic" }
+data_model = { path = "common/data_model" }
+devices = { path = "devices" }
+disk = { path = "disk" }
+e2e_tests = { path = "e2e_tests" }
+ext2 = { path = "ext2" }
+ffmpeg = { path = "media/ffmpeg" }
+fuse = { path = "fuse" }
+fuzz = { path = "fuzz" }
+gpu_display = { path = "gpu_display" }
+hypervisor = { path = "hypervisor" }
+hypervisor_test_macro = { path = "hypervisor/hypervisor_test_macro" }
+io_uring = { path = "io_uring" }
+jail = { path = "jail" }
+kernel_cmdline = { path = "kernel_cmdline" }
+kernel_loader = { path = "kernel_loader" }
+kvm = { path = "kvm" }
+kvm_sys = { path = "kvm_sys" }
+libcras_stub = { path = "libcras_stub" }
+linux_input_sys = { path = "linux_input_sys" }
+metrics = { path = "metrics" }
+metrics_events = { path = "metrics_events" }
+net_sys = { path = "net_sys" }
+net_util = { path = "net_util" }
+power_monitor = { path = "power_monitor" }
+prebuilts = { path = "prebuilts" }
+proto_build_tools = { path = "proto_build_tools" }
+protos = { path = "protos" }
+resources = { path = "resources" }
+riscv64 = { path = "riscv64" }
+rutabaga_gfx = { path = "rutabaga_gfx" }
+sandbox = { path = "sandbox" }
+serde_keyvalue = { path = "serde_keyvalue" }
 snapshot = { path = "snapshot" }
+swap = { path = "swap" }
+sync = { path = "common/sync" }
+system_api = { path = "system_api" }
+tube_transporter = { path = "tube_transporter" }
+usb_sys = { path = "usb_sys" }
+usb_util = { path = "usb_util" }
+vfio_sys = { path = "vfio_sys" }
+vhost = { path = "vhost" }
+virtio_sys = { path = "virtio_sys" }
+vm_control = { path = "vm_control" }
+vm_memory = { path = "vm_memory" }
+vmm_vhost = { path = "third_party/vmm_vhost" }
+win_audio = { path = "win_audio" }
+win_util = { path = "win_util" }
+x86_64 = { path = "x86_64" }
+
+# External dependencies
+anyhow = "1"
+argh = "0.1.10"
+cfg-if = "1.0.0"
+ciborium = "0.2.2"
+enumn = "0.1.0"
+gdbstub = "0.7.0"
+gdbstub_arch = "0.3.0"
+libc = "0.2.153"
+rand = "0.8.5"
+remain = "0.2"
+serde = "1.0"
+serde_json = "1"
+thiserror = "1.0.23"
+tokio = { version = "1.29.1", features = ["net", "rt-multi-thread", "time", "sync", "macros"] }
 
 [features]
 ## Default features of crosvm. This selection is somewhat arbitrary for historical reasons.
@@ -425,6 +518,7 @@ all-aarch64 = [
 ## All features that are compiled and tested for riscv64
 all-riscv64 = [
     "gdb",
+    "default",
 ]
 
 ## All features that are compiled and tested for x86_64
@@ -489,101 +583,96 @@ all-android = [
 ]
 
 [dependencies]
-anyhow = "1"
-arch = { path = "arch" }
-argh = "0.1.10"
-argh_helpers = { path = "argh_helpers" }
-audio_streams = "*"
-base = { path = "base" }
-bit_field = { path = "bit_field" }
-broker_ipc = { path = "broker_ipc" }
-cfg-if = "1.0.0"
-crash_report = { path = "vendor/generic/crash_report", optional = true }
-cros_async = { path = "cros_async" }
-cros_tracing = { path = "cros_tracing" }
-crosvm_cli = { path = "crosvm_cli" }
-crosvm_plugin = { path = "crosvm_plugin", optional = true }
-devices = { path = "devices" }
-disk = { path = "disk" }
+anyhow = { workspace = true }
+arch = { workspace = true }
+argh = { workspace = true }
+argh_helpers = { workspace = true }
+aarch64_sys_reg = { workspace = true }
+base = { workspace = true }
+bit_field = { workspace = true }
+broker_ipc = { workspace = true }
+cfg-if = { workspace = true }
+crash_report = { workspace = true, optional = true }
+cros_async = { workspace = true }
+cros_tracing = { workspace = true }
+crosvm_cli = { workspace = true }
+crosvm_plugin = { workspace = true, optional = true }
+devices = { workspace = true }
+disk = { workspace = true }
 document-features = { version = "0.2", optional = true }
-enumn = "0.1.0"
-ext2 = { path = "ext2" }
-gdbstub = { version = "0.7.0", optional = true }
-gdbstub_arch = { version = "0.3.0", optional = true }
-rutabaga_gfx = { path = "rutabaga_gfx"}
-hypervisor = { path = "hypervisor" }
-jail = { path = "jail" }
-kernel_cmdline = { path = "kernel_cmdline" }
-kernel_loader = { path = "kernel_loader" }
-kvm = { path = "kvm", optional = true }
-kvm_sys = { path = "kvm_sys", optional = true }
-libc = "0.2.153"
+enumn = { workspace = true }
+ext2 = { workspace = true }
+gdbstub = { workspace = true, optional = true }
+gdbstub_arch = { workspace = true, optional = true }
+rutabaga_gfx = { workspace = true }
+hypervisor = { workspace = true }
+jail = { workspace = true }
+kernel_cmdline = { workspace = true }
+kernel_loader = { workspace = true }
+kvm = { workspace = true, optional = true }
+kvm_sys = { workspace = true, optional = true }
+libc = { workspace = true }
 libcras = "*"
 # Compile out trace statements in release builds
 log = { version = "0", features = ["release_max_level_debug"]}
 merge = "0.1.0"
-metrics = { path = "metrics" }
-metrics_events = { path = "metrics_events" }
-net_util = { path = "net_util" }
-once_cell = "1.7"
+metrics = { workspace = true }
+metrics_events = { workspace = true }
+net_util = { workspace = true }
 protobuf = { version = "3.2", optional = true }
-protos = { path = "protos", optional = true }
-remain = "0.2"
-resources = { path = "resources" }
+protos = { workspace = true, optional = true }
+remain = { workspace = true }
+resources = { workspace = true }
 scudo = { version = "0.1", optional = true }
-serde = { version = "1", features = ["rc"] }
-serde_json = "1"
-serde_keyvalue = { path = "serde_keyvalue", features = ["argh_derive"] }
+serde = { workspace = true, features = ["rc"] }
+serde_json = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
 snapshot = { workspace = true }
 smallvec = "1.6.1"
 static_assertions = "1.1"
-swap = { path = "swap" }
-sync = { path = "common/sync" }
-thiserror = { version = "1.0.20" }
-vm_control = { path = "vm_control" }
-acpi_tables = { path = "acpi_tables" }
-vm_memory = { path = "vm_memory" }
-vmm_vhost = { path = "third_party/vmm_vhost" }
+swap = { workspace = true }
+sync = { workspace = true }
+thiserror = { workspace = true }
+vm_control = { workspace = true }
+acpi_tables = { workspace = true }
+vm_memory = { workspace = true }
+vmm_vhost = { workspace = true }
 uuid = { version = "1", features = ["v4"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [target.'cfg(target_arch = "riscv64")'.dependencies]
-riscv64 = { path = "riscv64" }
+riscv64 = { workspace = true }
 
 [target.'cfg(target_arch = "x86_64")'.dependencies]
-x86_64 = { path = "x86_64" }
+x86_64 = { workspace = true }
 
 [target.'cfg(any(target_arch = "aarch64", target_arch = "arm"))'.dependencies]
-aarch64 = { path = "aarch64" }
+aarch64 = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
 minijail = "*" # provided by ebuild
 p9 = "0.3.1"
-vhost = { path = "vhost" }
-android_audio = { path = "android_audio"}
+vhost = { workspace = true }
+android_audio = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
-anti_tamper = { path = "vendor/generic/anti_tamper" }
-cros_async = { path = "cros_async" }
+anti_tamper = { workspace = true }
 ctrlc = "3"
 futures = "0.3"
-gpu_display = { path = "gpu_display", optional = true }
-rand = "0.8"
-sandbox = { path = "sandbox" }
-cros_tracing = { path = "cros_tracing" }
-tube_transporter = { path = "tube_transporter" }
+gpu_display = { workspace = true, optional = true }
+rand = { workspace = true }
+sandbox = { workspace = true }
+cros_tracing = { workspace = true }
+tube_transporter = { workspace = true }
 winapi = "0.3"
-win_audio = { path = "win_audio" }
-win_util = { path = "win_util" }
+win_audio = { workspace = true }
+win_util = { workspace = true }
 
 [dev-dependencies]
-rand = "0.8"
+rand = { workspace = true }
 tempfile = "3"
 
 [patch.crates-io]
 audio_streams = { path = "common/audio_streams" }
-cros_async = { path = "cros_async" }
-data_model = { path = "common/data_model" }
 libcras = { path = "libcras_stub" } # ignored by ebuild
-sync = { path = "common/sync" }
 minijail = { path = "third_party/minijail/rust/minijail" } # ignored by ebuild
diff --git a/OWNERS b/OWNERS
index 3cd468967..3f95e10a2 100644
--- a/OWNERS
+++ b/OWNERS
@@ -6,7 +6,6 @@ crosvm-reviews@google.com
 # they won't be suggested by gerrit.
 
 # ChromeOS Team
-denniskempin@google.com #{LAST_RESORT_SUGGESTION}
 dtor@chromium.org #{LAST_RESORT_SUGGESTION}
 dverkamp@chromium.org #{LAST_RESORT_SUGGESTION}
 keiichiw@chromium.org #{LAST_RESORT_SUGGESTION}
diff --git a/OWNERS_COUNCIL b/OWNERS_COUNCIL
index e4ae61066..57031947d 100644
--- a/OWNERS_COUNCIL
+++ b/OWNERS_COUNCIL
@@ -1,5 +1,5 @@
 # Crosvm Council Members
-denniskempin@google.com
+drmasquatch@google.com
 dverkamp@chromium.org
 fmayle@google.com
 khei@google.com
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 0054a6ab0..1a54459a8 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -2,7 +2,7 @@
   // New tests are temporarily added to postsubmit first, see go/test-mapping-slo-guide.
   "postsubmit": [
     {"name": "base_test_tests_syslog"},
-    {"name": "bit_field_derive_test_bit_field_derive"},
+    {"name": "bit_field_derive_test_src_bit_field_derive"},
     {"name": "cros_async_test_tests_executor"},
     {"name": "hypervisor_test_src_lib"},
     {"name": "jail_test_src_lib"},
diff --git a/aarch64/Android.bp b/aarch64/Android.bp
index 8411649a1..a8b98c13e 100644
--- a/aarch64/Android.bp
+++ b/aarch64/Android.bp
@@ -27,6 +27,7 @@ rust_library {
         "gdbstub_arch",
     ],
     rustlibs: [
+        "libaarch64_sys_reg",
         "libanyhow",
         "libarch",
         "libbase_rust",
@@ -40,7 +41,7 @@ rust_library {
         "libkernel_loader",
         "liblibc",
         "libminijail_rust",
-        "librand",
+        "librand-0.8",
         "libresources",
         "libswap",
         "libsync_rust",
diff --git a/aarch64/Cargo.toml b/aarch64/Cargo.toml
index 074cda6ab..c3c70a893 100644
--- a/aarch64/Cargo.toml
+++ b/aarch64/Cargo.toml
@@ -9,26 +9,27 @@ gdb = ["gdbstub", "gdbstub_arch", "arch/gdb"]
 swap = ["swap/enable"]
 
 [dependencies]
-anyhow = "1"
-arch = { path = "../arch" }
-cros_fdt = { path = "../cros_fdt" }
-devices = { path = "../devices" }
-gdbstub = { version = "0.7.0", optional = true }
-gdbstub_arch = { version = "0.3.0", optional = true }
-hypervisor = { path = "../hypervisor" }
-jail = { path = "../jail" }
-kernel_cmdline = { path = "../kernel_cmdline" }
-kernel_loader = { path = "../kernel_loader" }
-libc = "0.2"
-rand = "0.8"
-remain = "0.2"
-resources = { path = "../resources" }
-swap = { path = "../swap" }
-sync = { path = "../common/sync" }
-base = { path = "../base" }
-thiserror = "1"
-vm_control = { path = "../vm_control" }
-vm_memory = { path = "../vm_memory" }
+aarch64_sys_reg = { workspace = true }
+anyhow = { workspace = true }
+arch = { workspace = true }
+cros_fdt = { workspace = true }
+devices = { workspace = true }
+gdbstub = { workspace = true, optional = true }
+gdbstub_arch = { workspace = true, optional = true }
+hypervisor = { workspace = true }
+jail = { workspace = true }
+kernel_cmdline = { workspace = true }
+kernel_loader = { workspace = true }
+libc = { workspace = true }
+rand = { workspace = true }
+remain = { workspace = true }
+resources = { workspace = true }
+swap = { workspace = true }
+sync = { workspace = true }
+base = { workspace = true }
+thiserror = { workspace = true }
+vm_control = { workspace = true }
+vm_memory = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
 minijail = "*"
diff --git a/aarch64/src/fdt.rs b/aarch64/src/fdt.rs
index cb7258bff..6b6d2e5a0 100644
--- a/aarch64/src/fdt.rs
+++ b/aarch64/src/fdt.rs
@@ -10,6 +10,10 @@ use std::io::Write;
 use std::path::PathBuf;
 
 use arch::apply_device_tree_overlays;
+use arch::fdt::create_memory_node;
+use arch::fdt::create_reserved_memory_node;
+use arch::fdt::reserved_memory_regions_from_guest_mem;
+use arch::fdt::ReservedMemoryRegion;
 use arch::serial::SerialDeviceInfo;
 use arch::CpuSet;
 use arch::DtbOverlay;
@@ -42,7 +46,6 @@ use crate::AARCH64_GIC_DIST_BASE;
 use crate::AARCH64_GIC_DIST_SIZE;
 use crate::AARCH64_GIC_REDIST_SIZE;
 use crate::AARCH64_PMU_IRQ;
-use crate::AARCH64_PROTECTED_VM_FW_START;
 // These are RTC related constants
 use crate::AARCH64_RTC_ADDR;
 use crate::AARCH64_RTC_IRQ;
@@ -78,64 +81,6 @@ const IRQ_TYPE_EDGE_RISING: u32 = 0x00000001;
 const IRQ_TYPE_LEVEL_HIGH: u32 = 0x00000004;
 const IRQ_TYPE_LEVEL_LOW: u32 = 0x00000008;
 
-fn create_memory_node(fdt: &mut Fdt, guest_mem: &GuestMemory) -> Result<()> {
-    let mut mem_reg_prop = Vec::new();
-    let mut previous_memory_region_end = None;
-    let mut regions = guest_mem.guest_memory_regions();
-    regions.sort();
-    for region in regions {
-        if region.0.offset() == AARCH64_PROTECTED_VM_FW_START {
-            continue;
-        }
-        // Merge with the previous region if possible.
-        if let Some(previous_end) = previous_memory_region_end {
-            if region.0 == previous_end {
-                *mem_reg_prop.last_mut().unwrap() += region.1 as u64;
-                previous_memory_region_end =
-                    Some(previous_end.checked_add(region.1 as u64).unwrap());
-                continue;
-            }
-            assert!(region.0 > previous_end, "Memory regions overlap");
-        }
-
-        mem_reg_prop.push(region.0.offset());
-        mem_reg_prop.push(region.1 as u64);
-        previous_memory_region_end = Some(region.0.checked_add(region.1 as u64).unwrap());
-    }
-
-    let memory_node = fdt.root_mut().subnode_mut("memory")?;
-    memory_node.set_prop("device_type", "memory")?;
-    memory_node.set_prop("reg", mem_reg_prop)?;
-    Ok(())
-}
-
-fn create_resv_memory_node(
-    fdt: &mut Fdt,
-    resv_addr_and_size: (Option<GuestAddress>, u64),
-) -> Result<u32> {
-    let (resv_addr, resv_size) = resv_addr_and_size;
-
-    let resv_memory_node = fdt.root_mut().subnode_mut("reserved-memory")?;
-    resv_memory_node.set_prop("#address-cells", 0x2u32)?;
-    resv_memory_node.set_prop("#size-cells", 0x2u32)?;
-    resv_memory_node.set_prop("ranges", ())?;
-
-    let restricted_dma_pool_node = if let Some(resv_addr) = resv_addr {
-        let node =
-            resv_memory_node.subnode_mut(&format!("restricted_dma_reserved@{:x}", resv_addr.0))?;
-        node.set_prop("reg", &[resv_addr.0, resv_size])?;
-        node
-    } else {
-        let node = resv_memory_node.subnode_mut("restricted_dma_reserved")?;
-        node.set_prop("size", resv_size)?;
-        node
-    };
-    restricted_dma_pool_node.set_prop("phandle", PHANDLE_RESTRICTED_DMA_POOL)?;
-    restricted_dma_pool_node.set_prop("compatible", "restricted-dma-pool")?;
-    restricted_dma_pool_node.set_prop("alignment", base::pagesize() as u64)?;
-    Ok(PHANDLE_RESTRICTED_DMA_POOL)
-}
-
 fn create_cpu_nodes(
     fdt: &mut Fdt,
     num_cpus: u32,
@@ -502,7 +447,6 @@ fn create_pci_nodes(
     let reg = [cfg.base, cfg.size];
 
     let mut interrupts: Vec<u32> = Vec::new();
-    let mut masks: Vec<u32> = Vec::new();
 
     for (address, irq_num, irq_pin) in pci_irqs.iter() {
         // PCI_DEVICE(3)
@@ -522,15 +466,15 @@ fn create_pci_nodes(
         interrupts.push(GIC_FDT_IRQ_TYPE_SPI);
         interrupts.push(*irq_num);
         interrupts.push(IRQ_TYPE_LEVEL_HIGH);
+    }
 
+    let mask: &[u32] = &[
         // PCI_DEVICE(3)
-        masks.push(0xf800); // bits 11..15 (device)
-        masks.push(0);
-        masks.push(0);
-
+        0xf800, // bits 11..15 (device)
+        0, 0, // mask off other unit address cells
         // INT#(1)
-        masks.push(0x7); // allow INTA#-INTD# (1 | 2 | 3 | 4)
-    }
+        0x7, // allow INTA#-INTD# (1 | 2 | 3 | 4)
+    ];
 
     let pci_node = fdt.root_mut().subnode_mut("pci")?;
     pci_node.set_prop("compatible", "pci-host-cam-generic")?;
@@ -542,7 +486,7 @@ fn create_pci_nodes(
     pci_node.set_prop("reg", &reg)?;
     pci_node.set_prop("#interrupt-cells", 1u32)?;
     pci_node.set_prop("interrupt-map", interrupts)?;
-    pci_node.set_prop("interrupt-map-mask", masks)?;
+    pci_node.set_prop("interrupt-map-mask", mask)?;
     pci_node.set_prop("dma-coherent", ())?;
     if let Some(dma_pool_phandle) = dma_pool_phandle {
         pci_node.set_prop("memory-region", dma_pool_phandle)?;
@@ -686,6 +630,7 @@ pub fn create_fdt(
     let mut fdt = Fdt::new(&[]);
     let mut phandles_key_cache = Vec::new();
     let mut phandles = BTreeMap::new();
+    let mut reserved_memory_regions = reserved_memory_regions_from_guest_mem(guest_mem);
 
     // The whole thing is put into one giant node with some top level properties
     let root_node = fdt.root_mut();
@@ -703,14 +648,26 @@ pub fn create_fdt(
     create_chosen_node(&mut fdt, cmdline, initrd, stdout_path.as_deref())?;
     create_config_node(&mut fdt, kernel_region)?;
     create_memory_node(&mut fdt, guest_mem)?;
-    let dma_pool_phandle = match swiotlb {
-        Some(x) => {
-            let phandle = create_resv_memory_node(&mut fdt, x)?;
-            phandles.insert("restricted_dma_reserved", phandle);
-            Some(phandle)
-        }
-        None => None,
+
+    let dma_pool_phandle = if let Some((swiotlb_addr, swiotlb_size)) = swiotlb {
+        let phandle = PHANDLE_RESTRICTED_DMA_POOL;
+        reserved_memory_regions.push(ReservedMemoryRegion {
+            address: swiotlb_addr,
+            size: swiotlb_size,
+            phandle: Some(phandle),
+            name: "restricted_dma_reserved",
+            compatible: Some("restricted-dma-pool"),
+            alignment: Some(base::pagesize() as u64),
+            no_map: false,
+        });
+        phandles.insert("restricted_dma_reserved", phandle);
+        Some(phandle)
+    } else {
+        None
     };
+
+    create_reserved_memory_node(&mut fdt, &reserved_memory_regions)?;
+
     create_cpu_nodes(
         &mut fdt,
         num_cpus,
diff --git a/aarch64/src/lib.rs b/aarch64/src/lib.rs
index f11d5b6f5..06956f17c 100644
--- a/aarch64/src/lib.rs
+++ b/aarch64/src/lib.rs
@@ -14,6 +14,8 @@ use std::sync::atomic::AtomicU32;
 use std::sync::mpsc;
 use std::sync::Arc;
 
+#[cfg(feature = "gdb")]
+use aarch64_sys_reg::AArch64SysRegId;
 use arch::get_serial_cmdline;
 use arch::CpuSet;
 use arch::DtbOverlay;
@@ -48,14 +50,13 @@ use devices::Serial;
 use devices::VirtCpufreq;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use devices::VirtCpufreqV2;
+use fdt::PciAddressSpace;
 #[cfg(feature = "gdb")]
 use gdbstub::arch::Arch;
 #[cfg(feature = "gdb")]
 use gdbstub_arch::aarch64::reg::id::AArch64RegId;
 #[cfg(feature = "gdb")]
 use gdbstub_arch::aarch64::AArch64 as GdbArch;
-#[cfg(feature = "gdb")]
-use hypervisor::AArch64SysRegId;
 use hypervisor::CpuConfigAArch64;
 use hypervisor::DeviceKind;
 use hypervisor::Hypervisor;
@@ -299,7 +300,7 @@ pub enum Error {
     #[error("initrd could not be loaded: {0}")]
     InitrdLoadFailure(arch::LoadImageError),
     #[error("failed to initialize virtual machine {0}")]
-    InitVmError(base::Error),
+    InitVmError(anyhow::Error),
     #[error("kernel could not be loaded: {0}")]
     KernelLoadFailure(kernel_loader::Error),
     #[error("error loading Kernel from Elf image: {0}")]
@@ -547,6 +548,27 @@ impl arch::LinuxArch for AArch64 {
 
         let main_memory_size = main_memory_size(&components, vm.get_hypervisor());
 
+        // Load pvmfw early because it tells the hypervisor this is a pVM which affects
+        // the behavior of calls like Hypervisor::check_capability
+        if components.hv_cfg.protection_type.needs_firmware_loaded() {
+            arch::load_image(
+                &mem,
+                &mut components
+                    .pvm_fw
+                    .expect("pvmfw must be available if ProtectionType loads it"),
+                GuestAddress(AARCH64_PROTECTED_VM_FW_START),
+                AARCH64_PROTECTED_VM_FW_MAX_SIZE,
+            )
+            .map_err(Error::CustomPvmFwLoadFailure)?;
+        } else if components.hv_cfg.protection_type.runs_firmware() {
+            // Tell the hypervisor to load the pVM firmware.
+            vm.load_protected_vm_firmware(
+                GuestAddress(AARCH64_PROTECTED_VM_FW_START),
+                AARCH64_PROTECTED_VM_FW_MAX_SIZE,
+            )
+            .map_err(Error::PvmFwLoadFailure)?;
+        }
+
         let fdt_position = fdt_position.unwrap_or(if has_bios {
             FdtPosition::Start
         } else {
@@ -622,9 +644,7 @@ impl arch::LinuxArch for AArch64 {
                 .expect("Not enough memory for FDT"),
         };
 
-        let mut use_pmu = vm
-            .get_hypervisor()
-            .check_capability(HypervisorCap::ArmPmuV3);
+        let mut use_pmu = vm.check_capability(VmCap::ArmPmuV3);
         use_pmu &= !no_pmu;
         let vcpu_count = components.vcpu_count;
         let mut has_pvtime = true;
@@ -684,25 +704,6 @@ impl arch::LinuxArch for AArch64 {
             .map_err(Error::MapPvtimeError)?;
         }
 
-        if components.hv_cfg.protection_type.needs_firmware_loaded() {
-            arch::load_image(
-                &mem,
-                &mut components
-                    .pvm_fw
-                    .expect("pvmfw must be available if ProtectionType loads it"),
-                GuestAddress(AARCH64_PROTECTED_VM_FW_START),
-                AARCH64_PROTECTED_VM_FW_MAX_SIZE,
-            )
-            .map_err(Error::CustomPvmFwLoadFailure)?;
-        } else if components.hv_cfg.protection_type.runs_firmware() {
-            // Tell the hypervisor to load the pVM firmware.
-            vm.load_protected_vm_firmware(
-                GuestAddress(AARCH64_PROTECTED_VM_FW_START),
-                AARCH64_PROTECTED_VM_FW_MAX_SIZE,
-            )
-            .map_err(Error::PvmFwLoadFailure)?;
-        }
-
         for (vcpu_id, vcpu) in vcpus.iter().enumerate() {
             use_pmu &= vcpu.init_pmu(AARCH64_PMU_IRQ as u64 + 16).is_ok();
             if has_pvtime {
@@ -908,18 +909,27 @@ impl arch::LinuxArch for AArch64 {
 
         let mut pci_ranges: Vec<fdt::PciRange> = Vec::new();
 
-        let mut add_pci_ranges = |alloc: &AddressAllocator, prefetchable: bool| {
-            pci_ranges.extend(alloc.pools().iter().map(|range| fdt::PciRange {
-                space: fdt::PciAddressSpace::Memory64,
-                bus_address: range.start,
-                cpu_physical_address: range.start,
-                size: range.len().unwrap(),
-                prefetchable,
-            }));
-        };
+        let mut add_pci_ranges =
+            |alloc: &AddressAllocator, space: PciAddressSpace, prefetchable: bool| {
+                pci_ranges.extend(alloc.pools().iter().map(|range| fdt::PciRange {
+                    space,
+                    bus_address: range.start,
+                    cpu_physical_address: range.start,
+                    size: range.len().unwrap(),
+                    prefetchable,
+                }));
+            };
 
-        add_pci_ranges(system_allocator.mmio_allocator(MmioType::Low), false);
-        add_pci_ranges(system_allocator.mmio_allocator(MmioType::High), true);
+        add_pci_ranges(
+            system_allocator.mmio_allocator(MmioType::Low),
+            PciAddressSpace::Memory,
+            false, // prefetchable
+        );
+        add_pci_ranges(
+            system_allocator.mmio_allocator(MmioType::High),
+            PciAddressSpace::Memory64,
+            true, // prefetchable
+        );
 
         let (bat_control, bat_mmio_base_and_irq) = match bat_type {
             Some(BatteryType::Goldfish) => {
@@ -1164,10 +1174,10 @@ impl<T: VcpuAArch64> arch::GdbOps<T> for AArch64 {
             *reg = vcpu.get_vector_reg(n).map_err(Error::ReadReg)?;
         }
         regs.fpcr = vcpu
-            .get_one_reg(VcpuRegAArch64::System(AArch64SysRegId::FPCR))
+            .get_one_reg(VcpuRegAArch64::System(aarch64_sys_reg::FPCR))
             .map_err(Error::ReadReg)? as u32;
         regs.fpsr = vcpu
-            .get_one_reg(VcpuRegAArch64::System(AArch64SysRegId::FPSR))
+            .get_one_reg(VcpuRegAArch64::System(aarch64_sys_reg::FPSR))
             .map_err(Error::ReadReg)? as u32;
 
         Ok(regs)
@@ -1199,12 +1209,12 @@ impl<T: VcpuAArch64> arch::GdbOps<T> for AArch64 {
             vcpu.set_vector_reg(n, *reg).map_err(Error::WriteReg)?;
         }
         vcpu.set_one_reg(
-            VcpuRegAArch64::System(AArch64SysRegId::FPCR),
+            VcpuRegAArch64::System(aarch64_sys_reg::FPCR),
             u64::from(regs.fpcr),
         )
         .map_err(Error::WriteReg)?;
         vcpu.set_one_reg(
-            VcpuRegAArch64::System(AArch64SysRegId::FPSR),
+            VcpuRegAArch64::System(aarch64_sys_reg::FPSR),
             u64::from(regs.fpsr),
         )
         .map_err(Error::WriteReg)?;
@@ -1467,6 +1477,7 @@ mod tests {
             address_range: AddressRange::from_start_and_size(0x8080_0000, 0x1000).unwrap(),
             size: 0x1000,
             entry: GuestAddress(0x8080_0000),
+            class: kernel_loader::ElfClass::ElfClass64,
         });
         assert_eq!(
             payload.address_range(),
@@ -1518,6 +1529,7 @@ mod tests {
             address_range: AddressRange::from_start_and_size(0x8080_0000, 0x1000).unwrap(),
             size: 0x1000,
             entry: GuestAddress(0x8080_0000),
+            class: kernel_loader::ElfClass::ElfClass64,
         });
         assert_eq!(
             payload.address_range(),
diff --git a/aarch64_sys_reg/Android.bp b/aarch64_sys_reg/Android.bp
new file mode 100644
index 000000000..482eb91db
--- /dev/null
+++ b/aarch64_sys_reg/Android.bp
@@ -0,0 +1,49 @@
+// This file is generated by cargo_embargo.
+// Do not modify this file after the first "rust_*" or "genrule" module
+// because the changes will be overridden on upgrade.
+// Content before the first "rust_*" or "genrule" module is preserved.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "external_crosvm_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-BSD
+    default_applicable_licenses: ["external_crosvm_license"],
+}
+
+rust_test {
+    name: "aarch64_sys_reg_test_src_lib",
+    defaults: ["crosvm_defaults"],
+    host_supported: true,
+    crate_name: "aarch64_sys_reg",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2021",
+    rustlibs: [
+        "libserde",
+        "libthiserror",
+    ],
+}
+
+rust_library {
+    name: "libaarch64_sys_reg",
+    defaults: ["crosvm_defaults"],
+    host_supported: true,
+    crate_name: "aarch64_sys_reg",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    edition: "2021",
+    rustlibs: [
+        "libserde",
+        "libthiserror",
+    ],
+    apex_available: ["com.android.virt"],
+}
diff --git a/aarch64_sys_reg/Cargo.toml b/aarch64_sys_reg/Cargo.toml
new file mode 100644
index 000000000..665cf28af
--- /dev/null
+++ b/aarch64_sys_reg/Cargo.toml
@@ -0,0 +1,13 @@
+[package]
+name = "aarch64_sys_reg"
+version = "0.1.0"
+authors = ["The ChromiumOS Authors"]
+edition = "2021"
+
+[lib]
+
+[features]
+
+[dependencies]
+serde = { workspace = true, features = ["derive"] }
+thiserror = { workspace = true }
diff --git a/aarch64_sys_reg/gen.sh b/aarch64_sys_reg/gen.sh
new file mode 100755
index 000000000..950a11a1b
--- /dev/null
+++ b/aarch64_sys_reg/gen.sh
@@ -0,0 +1,59 @@
+#!/usr/bin/env bash
+# Copyright 2025 The ChromiumOS Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# Regenerate AArch64 system register constants.
+# This is the WRONG WAY to parse XML - don't try this at home.
+
+cd "$(dirname "$0")"
+
+echo >special.txt
+for reg in SysReg_xml_A_profile-2024-12/AArch64-*.xml; do
+    data="$(grep -T -E -A13 'accessor="(MRS|MSR)' $reg; echo --)"
+
+    while IFS= read -r -d '--' reg; do
+        if [[ -z "$reg" ]]; then
+            continue
+        fi
+
+        reg_name="$(echo $reg | grep access_mechanism | awk '{ print $3 }' | tr -d '"')"
+
+        if [[ -z "$reg_name" ]]; then
+            continue
+        fi
+
+        op0="$(echo $reg | grep -E -o 'n="op0" v="0b[01]+' | awk '{ print $2 }' | sed -e 's/v="//')"
+        op1="$(echo $reg | grep -E -o 'n="op1" v="0b[01]+' | awk '{ print $2 }' | sed -e 's/v="//')"
+        crn="$(echo $reg | grep -E -o 'n="CRn" v="0b[01]+' | awk '{ print $2 }' | sed -e 's/v="//')"
+        crm="$(echo $reg | grep -E -o 'n="CRm" v="0b[01]+' | awk '{ print $2 }' | sed -e 's/v="//')"
+        op2="$(echo $reg | grep -E -o 'n="op2" v="0b[01]+' | awk '{ print $2 }' | sed -e 's/v="//')"
+
+        # skip parameterized regs
+        if [[ ${#op0} -ne 4 || ${#op1} -ne 5 || ${#crn} -ne 6 || ${#crm} -ne 6 || ${#op2} -ne 5 ]]; then
+            echo $reg_name >> special.txt
+            continue
+        fi
+
+        # prefix with the numeric value for sorting
+        printf "${op0}${op1}${crn}${crm}${op2}\tpub const %-19s : AArch64SysRegId = AArch64SysRegId::new_unchecked(${op0}, ${op1}, ${crn}, ${crm}, ${op2});\n" "${reg_name}"
+    done <<< "$data"
+done > gen-unsorted.rs
+
+cat >src/gen.rs <<EOF
+/* automatically generated by gen.sh - do not manually edit */
+
+#![cfg_attr(rustfmt, rustfmt_skip)]
+#![allow(non_upper_case_globals)]
+
+use crate::AArch64SysRegId;
+
+//                                                                                Op0    Op1     CRn     CRm    Op2
+EOF
+
+# Sort numerically, remove duplicates, and trim the sorting prefix.
+sort gen-unsorted.rs | uniq | cut -f2- -d$'\t' >> src/gen.rs
+rm gen-unsorted.rs
+
+echo "These registers may require special handling:"
+sort special.txt | uniq | sed -e 's/&lt;/</g' -e 's/&gt;/>/g'
diff --git a/aarch64_sys_reg/src/consts.rs b/aarch64_sys_reg/src/consts.rs
new file mode 100644
index 000000000..bd55a0e47
--- /dev/null
+++ b/aarch64_sys_reg/src/consts.rs
@@ -0,0 +1,589 @@
+// Copyright 2025 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+//! AArch64 system register range constants.
+
+#![cfg_attr(rustfmt, rustfmt_skip)]
+#![allow(non_snake_case, non_upper_case_globals)]
+
+use crate::AArch64SysRegId;
+use crate::funcs::*;
+
+pub const AMEVCNTR00_EL0: AArch64SysRegId = AMEVCNTR0n_EL0(0);
+pub const AMEVCNTR01_EL0: AArch64SysRegId = AMEVCNTR0n_EL0(1);
+pub const AMEVCNTR02_EL0: AArch64SysRegId = AMEVCNTR0n_EL0(2);
+pub const AMEVCNTR03_EL0: AArch64SysRegId = AMEVCNTR0n_EL0(3);
+
+pub const AMEVCNTR10_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(0);
+pub const AMEVCNTR11_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(1);
+pub const AMEVCNTR12_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(2);
+pub const AMEVCNTR13_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(3);
+pub const AMEVCNTR14_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(4);
+pub const AMEVCNTR15_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(5);
+pub const AMEVCNTR16_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(6);
+pub const AMEVCNTR17_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(7);
+pub const AMEVCNTR18_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(8);
+pub const AMEVCNTR19_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(9);
+pub const AMEVCNTR1A_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(10);
+pub const AMEVCNTR1B_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(11);
+pub const AMEVCNTR1C_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(12);
+pub const AMEVCNTR1D_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(13);
+pub const AMEVCNTR1E_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(14);
+pub const AMEVCNTR1F_EL0: AArch64SysRegId = AMEVCNTR1n_EL0(15);
+
+pub const AMEVCNTVOFF00_EL2: AArch64SysRegId = AMEVCNTVOFF0n_EL2(0);
+pub const AMEVCNTVOFF02_EL2: AArch64SysRegId = AMEVCNTVOFF0n_EL2(2);
+pub const AMEVCNTVOFF03_EL2: AArch64SysRegId = AMEVCNTVOFF0n_EL2(3);
+
+pub const AMEVCNTVOFF10_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(0);
+pub const AMEVCNTVOFF11_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(1);
+pub const AMEVCNTVOFF12_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(2);
+pub const AMEVCNTVOFF13_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(3);
+pub const AMEVCNTVOFF14_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(4);
+pub const AMEVCNTVOFF15_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(5);
+pub const AMEVCNTVOFF16_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(6);
+pub const AMEVCNTVOFF17_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(7);
+pub const AMEVCNTVOFF18_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(8);
+pub const AMEVCNTVOFF19_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(9);
+pub const AMEVCNTVOFF1A_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(10);
+pub const AMEVCNTVOFF1B_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(11);
+pub const AMEVCNTVOFF1C_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(12);
+pub const AMEVCNTVOFF1D_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(13);
+pub const AMEVCNTVOFF1E_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(14);
+pub const AMEVCNTVOFF1F_EL2: AArch64SysRegId = AMEVCNTVOFF1n_EL2(15);
+
+pub const AMEVTYPER00_EL0: AArch64SysRegId = AMEVTYPER0n_EL0(0);
+pub const AMEVTYPER01_EL0: AArch64SysRegId = AMEVTYPER0n_EL0(1);
+pub const AMEVTYPER02_EL0: AArch64SysRegId = AMEVTYPER0n_EL0(2);
+pub const AMEVTYPER03_EL0: AArch64SysRegId = AMEVTYPER0n_EL0(3);
+
+pub const AMEVTYPER10_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(0);
+pub const AMEVTYPER11_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(1);
+pub const AMEVTYPER12_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(2);
+pub const AMEVTYPER13_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(3);
+pub const AMEVTYPER14_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(4);
+pub const AMEVTYPER15_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(5);
+pub const AMEVTYPER16_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(6);
+pub const AMEVTYPER17_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(7);
+pub const AMEVTYPER18_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(8);
+pub const AMEVTYPER19_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(9);
+pub const AMEVTYPER1A_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(10);
+pub const AMEVTYPER1B_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(11);
+pub const AMEVTYPER1C_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(12);
+pub const AMEVTYPER1D_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(13);
+pub const AMEVTYPER1E_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(14);
+pub const AMEVTYPER1F_EL0: AArch64SysRegId = AMEVTYPER1n_EL0(15);
+
+pub const BRBINF0_EL1: AArch64SysRegId = BRBINFn_EL1(0);
+pub const BRBINF1_EL1: AArch64SysRegId = BRBINFn_EL1(1);
+pub const BRBINF2_EL1: AArch64SysRegId = BRBINFn_EL1(2);
+pub const BRBINF3_EL1: AArch64SysRegId = BRBINFn_EL1(3);
+pub const BRBINF4_EL1: AArch64SysRegId = BRBINFn_EL1(4);
+pub const BRBINF5_EL1: AArch64SysRegId = BRBINFn_EL1(5);
+pub const BRBINF6_EL1: AArch64SysRegId = BRBINFn_EL1(6);
+pub const BRBINF7_EL1: AArch64SysRegId = BRBINFn_EL1(7);
+pub const BRBINF8_EL1: AArch64SysRegId = BRBINFn_EL1(8);
+pub const BRBINF9_EL1: AArch64SysRegId = BRBINFn_EL1(9);
+pub const BRBINF10_EL1: AArch64SysRegId = BRBINFn_EL1(10);
+pub const BRBINF11_EL1: AArch64SysRegId = BRBINFn_EL1(11);
+pub const BRBINF12_EL1: AArch64SysRegId = BRBINFn_EL1(12);
+pub const BRBINF13_EL1: AArch64SysRegId = BRBINFn_EL1(13);
+pub const BRBINF14_EL1: AArch64SysRegId = BRBINFn_EL1(14);
+pub const BRBINF15_EL1: AArch64SysRegId = BRBINFn_EL1(15);
+pub const BRBINF16_EL1: AArch64SysRegId = BRBINFn_EL1(16);
+pub const BRBINF17_EL1: AArch64SysRegId = BRBINFn_EL1(17);
+pub const BRBINF18_EL1: AArch64SysRegId = BRBINFn_EL1(18);
+pub const BRBINF19_EL1: AArch64SysRegId = BRBINFn_EL1(19);
+pub const BRBINF20_EL1: AArch64SysRegId = BRBINFn_EL1(20);
+pub const BRBINF21_EL1: AArch64SysRegId = BRBINFn_EL1(21);
+pub const BRBINF22_EL1: AArch64SysRegId = BRBINFn_EL1(22);
+pub const BRBINF23_EL1: AArch64SysRegId = BRBINFn_EL1(23);
+pub const BRBINF24_EL1: AArch64SysRegId = BRBINFn_EL1(24);
+pub const BRBINF25_EL1: AArch64SysRegId = BRBINFn_EL1(25);
+pub const BRBINF26_EL1: AArch64SysRegId = BRBINFn_EL1(26);
+pub const BRBINF27_EL1: AArch64SysRegId = BRBINFn_EL1(27);
+pub const BRBINF28_EL1: AArch64SysRegId = BRBINFn_EL1(28);
+pub const BRBINF29_EL1: AArch64SysRegId = BRBINFn_EL1(29);
+pub const BRBINF30_EL1: AArch64SysRegId = BRBINFn_EL1(30);
+pub const BRBINF31_EL1: AArch64SysRegId = BRBINFn_EL1(31);
+
+pub const BRBSRC0_EL1: AArch64SysRegId = BRBSRCn_EL1(0);
+pub const BRBSRC1_EL1: AArch64SysRegId = BRBSRCn_EL1(1);
+pub const BRBSRC2_EL1: AArch64SysRegId = BRBSRCn_EL1(2);
+pub const BRBSRC3_EL1: AArch64SysRegId = BRBSRCn_EL1(3);
+pub const BRBSRC4_EL1: AArch64SysRegId = BRBSRCn_EL1(4);
+pub const BRBSRC5_EL1: AArch64SysRegId = BRBSRCn_EL1(5);
+pub const BRBSRC6_EL1: AArch64SysRegId = BRBSRCn_EL1(6);
+pub const BRBSRC7_EL1: AArch64SysRegId = BRBSRCn_EL1(7);
+pub const BRBSRC8_EL1: AArch64SysRegId = BRBSRCn_EL1(8);
+pub const BRBSRC9_EL1: AArch64SysRegId = BRBSRCn_EL1(9);
+pub const BRBSRC10_EL1: AArch64SysRegId = BRBSRCn_EL1(10);
+pub const BRBSRC11_EL1: AArch64SysRegId = BRBSRCn_EL1(11);
+pub const BRBSRC12_EL1: AArch64SysRegId = BRBSRCn_EL1(12);
+pub const BRBSRC13_EL1: AArch64SysRegId = BRBSRCn_EL1(13);
+pub const BRBSRC14_EL1: AArch64SysRegId = BRBSRCn_EL1(14);
+pub const BRBSRC15_EL1: AArch64SysRegId = BRBSRCn_EL1(15);
+pub const BRBSRC16_EL1: AArch64SysRegId = BRBSRCn_EL1(16);
+pub const BRBSRC17_EL1: AArch64SysRegId = BRBSRCn_EL1(17);
+pub const BRBSRC18_EL1: AArch64SysRegId = BRBSRCn_EL1(18);
+pub const BRBSRC19_EL1: AArch64SysRegId = BRBSRCn_EL1(19);
+pub const BRBSRC20_EL1: AArch64SysRegId = BRBSRCn_EL1(20);
+pub const BRBSRC21_EL1: AArch64SysRegId = BRBSRCn_EL1(21);
+pub const BRBSRC22_EL1: AArch64SysRegId = BRBSRCn_EL1(22);
+pub const BRBSRC23_EL1: AArch64SysRegId = BRBSRCn_EL1(23);
+pub const BRBSRC24_EL1: AArch64SysRegId = BRBSRCn_EL1(24);
+pub const BRBSRC25_EL1: AArch64SysRegId = BRBSRCn_EL1(25);
+pub const BRBSRC26_EL1: AArch64SysRegId = BRBSRCn_EL1(26);
+pub const BRBSRC27_EL1: AArch64SysRegId = BRBSRCn_EL1(27);
+pub const BRBSRC28_EL1: AArch64SysRegId = BRBSRCn_EL1(28);
+pub const BRBSRC29_EL1: AArch64SysRegId = BRBSRCn_EL1(29);
+pub const BRBSRC30_EL1: AArch64SysRegId = BRBSRCn_EL1(30);
+pub const BRBSRC31_EL1: AArch64SysRegId = BRBSRCn_EL1(31);
+
+pub const BRBTGT0_EL1: AArch64SysRegId = BRBTGTn_EL1(0);
+pub const BRBTGT1_EL1: AArch64SysRegId = BRBTGTn_EL1(1);
+pub const BRBTGT2_EL1: AArch64SysRegId = BRBTGTn_EL1(2);
+pub const BRBTGT3_EL1: AArch64SysRegId = BRBTGTn_EL1(3);
+pub const BRBTGT4_EL1: AArch64SysRegId = BRBTGTn_EL1(4);
+pub const BRBTGT5_EL1: AArch64SysRegId = BRBTGTn_EL1(5);
+pub const BRBTGT6_EL1: AArch64SysRegId = BRBTGTn_EL1(6);
+pub const BRBTGT7_EL1: AArch64SysRegId = BRBTGTn_EL1(7);
+pub const BRBTGT8_EL1: AArch64SysRegId = BRBTGTn_EL1(8);
+pub const BRBTGT9_EL1: AArch64SysRegId = BRBTGTn_EL1(9);
+pub const BRBTGT10_EL1: AArch64SysRegId = BRBTGTn_EL1(10);
+pub const BRBTGT11_EL1: AArch64SysRegId = BRBTGTn_EL1(11);
+pub const BRBTGT12_EL1: AArch64SysRegId = BRBTGTn_EL1(12);
+pub const BRBTGT13_EL1: AArch64SysRegId = BRBTGTn_EL1(13);
+pub const BRBTGT14_EL1: AArch64SysRegId = BRBTGTn_EL1(14);
+pub const BRBTGT15_EL1: AArch64SysRegId = BRBTGTn_EL1(15);
+pub const BRBTGT16_EL1: AArch64SysRegId = BRBTGTn_EL1(16);
+pub const BRBTGT17_EL1: AArch64SysRegId = BRBTGTn_EL1(17);
+pub const BRBTGT18_EL1: AArch64SysRegId = BRBTGTn_EL1(18);
+pub const BRBTGT19_EL1: AArch64SysRegId = BRBTGTn_EL1(19);
+pub const BRBTGT20_EL1: AArch64SysRegId = BRBTGTn_EL1(20);
+pub const BRBTGT21_EL1: AArch64SysRegId = BRBTGTn_EL1(21);
+pub const BRBTGT22_EL1: AArch64SysRegId = BRBTGTn_EL1(22);
+pub const BRBTGT23_EL1: AArch64SysRegId = BRBTGTn_EL1(23);
+pub const BRBTGT24_EL1: AArch64SysRegId = BRBTGTn_EL1(24);
+pub const BRBTGT25_EL1: AArch64SysRegId = BRBTGTn_EL1(25);
+pub const BRBTGT26_EL1: AArch64SysRegId = BRBTGTn_EL1(26);
+pub const BRBTGT27_EL1: AArch64SysRegId = BRBTGTn_EL1(27);
+pub const BRBTGT28_EL1: AArch64SysRegId = BRBTGTn_EL1(28);
+pub const BRBTGT29_EL1: AArch64SysRegId = BRBTGTn_EL1(29);
+pub const BRBTGT30_EL1: AArch64SysRegId = BRBTGTn_EL1(30);
+pub const BRBTGT31_EL1: AArch64SysRegId = BRBTGTn_EL1(31);
+
+pub const DBGBCR0_EL1: AArch64SysRegId = DBGBCRn_EL1(0);
+pub const DBGBCR1_EL1: AArch64SysRegId = DBGBCRn_EL1(1);
+pub const DBGBCR2_EL1: AArch64SysRegId = DBGBCRn_EL1(2);
+pub const DBGBCR3_EL1: AArch64SysRegId = DBGBCRn_EL1(3);
+pub const DBGBCR4_EL1: AArch64SysRegId = DBGBCRn_EL1(4);
+pub const DBGBCR5_EL1: AArch64SysRegId = DBGBCRn_EL1(5);
+pub const DBGBCR6_EL1: AArch64SysRegId = DBGBCRn_EL1(6);
+pub const DBGBCR7_EL1: AArch64SysRegId = DBGBCRn_EL1(7);
+pub const DBGBCR8_EL1: AArch64SysRegId = DBGBCRn_EL1(8);
+pub const DBGBCR9_EL1: AArch64SysRegId = DBGBCRn_EL1(9);
+pub const DBGBCRA_EL1: AArch64SysRegId = DBGBCRn_EL1(10);
+pub const DBGBCRB_EL1: AArch64SysRegId = DBGBCRn_EL1(11);
+pub const DBGBCRC_EL1: AArch64SysRegId = DBGBCRn_EL1(12);
+pub const DBGBCRD_EL1: AArch64SysRegId = DBGBCRn_EL1(13);
+pub const DBGBCRE_EL1: AArch64SysRegId = DBGBCRn_EL1(14);
+pub const DBGBCRF_EL1: AArch64SysRegId = DBGBCRn_EL1(15);
+
+pub const DBGBVR0_EL1: AArch64SysRegId = DBGBVRn_EL1(0);
+pub const DBGBVR1_EL1: AArch64SysRegId = DBGBVRn_EL1(1);
+pub const DBGBVR2_EL1: AArch64SysRegId = DBGBVRn_EL1(2);
+pub const DBGBVR3_EL1: AArch64SysRegId = DBGBVRn_EL1(3);
+pub const DBGBVR4_EL1: AArch64SysRegId = DBGBVRn_EL1(4);
+pub const DBGBVR5_EL1: AArch64SysRegId = DBGBVRn_EL1(5);
+pub const DBGBVR6_EL1: AArch64SysRegId = DBGBVRn_EL1(6);
+pub const DBGBVR7_EL1: AArch64SysRegId = DBGBVRn_EL1(7);
+pub const DBGBVR8_EL1: AArch64SysRegId = DBGBVRn_EL1(8);
+pub const DBGBVR9_EL1: AArch64SysRegId = DBGBVRn_EL1(9);
+pub const DBGBVRA_EL1: AArch64SysRegId = DBGBVRn_EL1(10);
+pub const DBGBVRB_EL1: AArch64SysRegId = DBGBVRn_EL1(11);
+pub const DBGBVRC_EL1: AArch64SysRegId = DBGBVRn_EL1(12);
+pub const DBGBVRD_EL1: AArch64SysRegId = DBGBVRn_EL1(13);
+pub const DBGBVRE_EL1: AArch64SysRegId = DBGBVRn_EL1(14);
+pub const DBGBVRF_EL1: AArch64SysRegId = DBGBVRn_EL1(15);
+
+pub const DBGWCR0_EL1: AArch64SysRegId = DBGWCRn_EL1(0);
+pub const DBGWCR1_EL1: AArch64SysRegId = DBGWCRn_EL1(1);
+pub const DBGWCR2_EL1: AArch64SysRegId = DBGWCRn_EL1(2);
+pub const DBGWCR3_EL1: AArch64SysRegId = DBGWCRn_EL1(3);
+pub const DBGWCR4_EL1: AArch64SysRegId = DBGWCRn_EL1(4);
+pub const DBGWCR5_EL1: AArch64SysRegId = DBGWCRn_EL1(5);
+pub const DBGWCR6_EL1: AArch64SysRegId = DBGWCRn_EL1(6);
+pub const DBGWCR7_EL1: AArch64SysRegId = DBGWCRn_EL1(7);
+pub const DBGWCR8_EL1: AArch64SysRegId = DBGWCRn_EL1(8);
+pub const DBGWCR9_EL1: AArch64SysRegId = DBGWCRn_EL1(9);
+pub const DBGWCRA_EL1: AArch64SysRegId = DBGWCRn_EL1(10);
+pub const DBGWCRB_EL1: AArch64SysRegId = DBGWCRn_EL1(11);
+pub const DBGWCRC_EL1: AArch64SysRegId = DBGWCRn_EL1(12);
+pub const DBGWCRD_EL1: AArch64SysRegId = DBGWCRn_EL1(13);
+pub const DBGWCRE_EL1: AArch64SysRegId = DBGWCRn_EL1(14);
+pub const DBGWCRF_EL1: AArch64SysRegId = DBGWCRn_EL1(15);
+
+pub const DBGWVR0_EL1: AArch64SysRegId = DBGWVRn_EL1(0);
+pub const DBGWVR1_EL1: AArch64SysRegId = DBGWVRn_EL1(1);
+pub const DBGWVR2_EL1: AArch64SysRegId = DBGWVRn_EL1(2);
+pub const DBGWVR3_EL1: AArch64SysRegId = DBGWVRn_EL1(3);
+pub const DBGWVR4_EL1: AArch64SysRegId = DBGWVRn_EL1(4);
+pub const DBGWVR5_EL1: AArch64SysRegId = DBGWVRn_EL1(5);
+pub const DBGWVR6_EL1: AArch64SysRegId = DBGWVRn_EL1(6);
+pub const DBGWVR7_EL1: AArch64SysRegId = DBGWVRn_EL1(7);
+pub const DBGWVR8_EL1: AArch64SysRegId = DBGWVRn_EL1(8);
+pub const DBGWVR9_EL1: AArch64SysRegId = DBGWVRn_EL1(9);
+pub const DBGWVRA_EL1: AArch64SysRegId = DBGWVRn_EL1(10);
+pub const DBGWVRB_EL1: AArch64SysRegId = DBGWVRn_EL1(11);
+pub const DBGWVRC_EL1: AArch64SysRegId = DBGWVRn_EL1(12);
+pub const DBGWVRD_EL1: AArch64SysRegId = DBGWVRn_EL1(13);
+pub const DBGWVRE_EL1: AArch64SysRegId = DBGWVRn_EL1(14);
+pub const DBGWVRF_EL1: AArch64SysRegId = DBGWVRn_EL1(15);
+
+pub const ICC_AP0R0_EL1: AArch64SysRegId = ICC_AP0Rn_EL1(0);
+pub const ICC_AP0R1_EL1: AArch64SysRegId = ICC_AP0Rn_EL1(1);
+pub const ICC_AP0R2_EL1: AArch64SysRegId = ICC_AP0Rn_EL1(2);
+pub const ICC_AP0R3_EL1: AArch64SysRegId = ICC_AP0Rn_EL1(3);
+
+pub const ICC_AP1R0_EL1: AArch64SysRegId = ICC_AP1Rn_EL1(0);
+pub const ICC_AP1R1_EL1: AArch64SysRegId = ICC_AP1Rn_EL1(1);
+pub const ICC_AP1R2_EL1: AArch64SysRegId = ICC_AP1Rn_EL1(2);
+pub const ICC_AP1R3_EL1: AArch64SysRegId = ICC_AP1Rn_EL1(3);
+
+pub const ICH_AP0R0_EL2: AArch64SysRegId = ICH_AP0Rn_EL2(0);
+pub const ICH_AP0R1_EL2: AArch64SysRegId = ICH_AP0Rn_EL2(1);
+pub const ICH_AP0R2_EL2: AArch64SysRegId = ICH_AP0Rn_EL2(2);
+pub const ICH_AP0R3_EL2: AArch64SysRegId = ICH_AP0Rn_EL2(3);
+
+pub const ICH_AP1R0_EL2: AArch64SysRegId = ICH_AP1Rn_EL2(0);
+pub const ICH_AP1R1_EL2: AArch64SysRegId = ICH_AP1Rn_EL2(1);
+pub const ICH_AP1R2_EL2: AArch64SysRegId = ICH_AP1Rn_EL2(2);
+pub const ICH_AP1R3_EL2: AArch64SysRegId = ICH_AP1Rn_EL2(3);
+
+pub const ICH_LR0_EL2: AArch64SysRegId = ICH_LRn_EL2(0);
+pub const ICH_LR1_EL2: AArch64SysRegId = ICH_LRn_EL2(1);
+pub const ICH_LR2_EL2: AArch64SysRegId = ICH_LRn_EL2(2);
+pub const ICH_LR3_EL2: AArch64SysRegId = ICH_LRn_EL2(3);
+pub const ICH_LR4_EL2: AArch64SysRegId = ICH_LRn_EL2(4);
+pub const ICH_LR5_EL2: AArch64SysRegId = ICH_LRn_EL2(5);
+pub const ICH_LR6_EL2: AArch64SysRegId = ICH_LRn_EL2(6);
+pub const ICH_LR7_EL2: AArch64SysRegId = ICH_LRn_EL2(7);
+pub const ICH_LR8_EL2: AArch64SysRegId = ICH_LRn_EL2(8);
+pub const ICH_LR9_EL2: AArch64SysRegId = ICH_LRn_EL2(9);
+pub const ICH_LRA_EL2: AArch64SysRegId = ICH_LRn_EL2(10);
+pub const ICH_LRB_EL2: AArch64SysRegId = ICH_LRn_EL2(11);
+pub const ICH_LRC_EL2: AArch64SysRegId = ICH_LRn_EL2(12);
+pub const ICH_LRD_EL2: AArch64SysRegId = ICH_LRn_EL2(13);
+pub const ICH_LRE_EL2: AArch64SysRegId = ICH_LRn_EL2(14);
+pub const ICH_LRF_EL2: AArch64SysRegId = ICH_LRn_EL2(15);
+
+pub const PMEVCNTR0_EL0: AArch64SysRegId = PMEVCNTRn_EL0(0);
+pub const PMEVCNTR1_EL0: AArch64SysRegId = PMEVCNTRn_EL0(1);
+pub const PMEVCNTR2_EL0: AArch64SysRegId = PMEVCNTRn_EL0(2);
+pub const PMEVCNTR3_EL0: AArch64SysRegId = PMEVCNTRn_EL0(3);
+pub const PMEVCNTR4_EL0: AArch64SysRegId = PMEVCNTRn_EL0(4);
+pub const PMEVCNTR5_EL0: AArch64SysRegId = PMEVCNTRn_EL0(5);
+pub const PMEVCNTR6_EL0: AArch64SysRegId = PMEVCNTRn_EL0(6);
+pub const PMEVCNTR7_EL0: AArch64SysRegId = PMEVCNTRn_EL0(7);
+pub const PMEVCNTR8_EL0: AArch64SysRegId = PMEVCNTRn_EL0(8);
+pub const PMEVCNTR9_EL0: AArch64SysRegId = PMEVCNTRn_EL0(9);
+pub const PMEVCNTR10_EL0: AArch64SysRegId = PMEVCNTRn_EL0(10);
+pub const PMEVCNTR11_EL0: AArch64SysRegId = PMEVCNTRn_EL0(11);
+pub const PMEVCNTR12_EL0: AArch64SysRegId = PMEVCNTRn_EL0(12);
+pub const PMEVCNTR13_EL0: AArch64SysRegId = PMEVCNTRn_EL0(13);
+pub const PMEVCNTR14_EL0: AArch64SysRegId = PMEVCNTRn_EL0(14);
+pub const PMEVCNTR15_EL0: AArch64SysRegId = PMEVCNTRn_EL0(15);
+pub const PMEVCNTR16_EL0: AArch64SysRegId = PMEVCNTRn_EL0(16);
+pub const PMEVCNTR17_EL0: AArch64SysRegId = PMEVCNTRn_EL0(17);
+pub const PMEVCNTR18_EL0: AArch64SysRegId = PMEVCNTRn_EL0(18);
+pub const PMEVCNTR19_EL0: AArch64SysRegId = PMEVCNTRn_EL0(19);
+pub const PMEVCNTR20_EL0: AArch64SysRegId = PMEVCNTRn_EL0(20);
+pub const PMEVCNTR21_EL0: AArch64SysRegId = PMEVCNTRn_EL0(21);
+pub const PMEVCNTR22_EL0: AArch64SysRegId = PMEVCNTRn_EL0(22);
+pub const PMEVCNTR23_EL0: AArch64SysRegId = PMEVCNTRn_EL0(23);
+pub const PMEVCNTR24_EL0: AArch64SysRegId = PMEVCNTRn_EL0(24);
+pub const PMEVCNTR25_EL0: AArch64SysRegId = PMEVCNTRn_EL0(25);
+pub const PMEVCNTR26_EL0: AArch64SysRegId = PMEVCNTRn_EL0(26);
+pub const PMEVCNTR27_EL0: AArch64SysRegId = PMEVCNTRn_EL0(27);
+pub const PMEVCNTR28_EL0: AArch64SysRegId = PMEVCNTRn_EL0(28);
+pub const PMEVCNTR29_EL0: AArch64SysRegId = PMEVCNTRn_EL0(29);
+pub const PMEVCNTR30_EL0: AArch64SysRegId = PMEVCNTRn_EL0(30);
+
+pub const PMEVCNTSVR0_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(0);
+pub const PMEVCNTSVR1_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(1);
+pub const PMEVCNTSVR2_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(2);
+pub const PMEVCNTSVR3_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(3);
+pub const PMEVCNTSVR4_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(4);
+pub const PMEVCNTSVR5_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(5);
+pub const PMEVCNTSVR6_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(6);
+pub const PMEVCNTSVR7_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(7);
+pub const PMEVCNTSVR8_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(8);
+pub const PMEVCNTSVR9_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(9);
+pub const PMEVCNTSVR10_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(10);
+pub const PMEVCNTSVR11_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(11);
+pub const PMEVCNTSVR12_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(12);
+pub const PMEVCNTSVR13_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(13);
+pub const PMEVCNTSVR14_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(14);
+pub const PMEVCNTSVR15_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(15);
+pub const PMEVCNTSVR16_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(16);
+pub const PMEVCNTSVR17_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(17);
+pub const PMEVCNTSVR18_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(18);
+pub const PMEVCNTSVR19_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(19);
+pub const PMEVCNTSVR20_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(20);
+pub const PMEVCNTSVR21_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(21);
+pub const PMEVCNTSVR22_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(22);
+pub const PMEVCNTSVR23_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(23);
+pub const PMEVCNTSVR24_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(24);
+pub const PMEVCNTSVR25_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(25);
+pub const PMEVCNTSVR26_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(26);
+pub const PMEVCNTSVR27_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(27);
+pub const PMEVCNTSVR28_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(28);
+pub const PMEVCNTSVR29_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(29);
+pub const PMEVCNTSVR30_EL1: AArch64SysRegId = PMEVCNTSVRn_EL1(30);
+
+pub const PMEVTYPER0_EL0: AArch64SysRegId = PMEVTYPERn_EL0(0);
+pub const PMEVTYPER1_EL0: AArch64SysRegId = PMEVTYPERn_EL0(1);
+pub const PMEVTYPER2_EL0: AArch64SysRegId = PMEVTYPERn_EL0(2);
+pub const PMEVTYPER3_EL0: AArch64SysRegId = PMEVTYPERn_EL0(3);
+pub const PMEVTYPER4_EL0: AArch64SysRegId = PMEVTYPERn_EL0(4);
+pub const PMEVTYPER5_EL0: AArch64SysRegId = PMEVTYPERn_EL0(5);
+pub const PMEVTYPER6_EL0: AArch64SysRegId = PMEVTYPERn_EL0(6);
+pub const PMEVTYPER7_EL0: AArch64SysRegId = PMEVTYPERn_EL0(7);
+pub const PMEVTYPER8_EL0: AArch64SysRegId = PMEVTYPERn_EL0(8);
+pub const PMEVTYPER9_EL0: AArch64SysRegId = PMEVTYPERn_EL0(9);
+pub const PMEVTYPER10_EL0: AArch64SysRegId = PMEVTYPERn_EL0(10);
+pub const PMEVTYPER11_EL0: AArch64SysRegId = PMEVTYPERn_EL0(11);
+pub const PMEVTYPER12_EL0: AArch64SysRegId = PMEVTYPERn_EL0(12);
+pub const PMEVTYPER13_EL0: AArch64SysRegId = PMEVTYPERn_EL0(13);
+pub const PMEVTYPER14_EL0: AArch64SysRegId = PMEVTYPERn_EL0(14);
+pub const PMEVTYPER15_EL0: AArch64SysRegId = PMEVTYPERn_EL0(15);
+pub const PMEVTYPER16_EL0: AArch64SysRegId = PMEVTYPERn_EL0(16);
+pub const PMEVTYPER17_EL0: AArch64SysRegId = PMEVTYPERn_EL0(17);
+pub const PMEVTYPER18_EL0: AArch64SysRegId = PMEVTYPERn_EL0(18);
+pub const PMEVTYPER19_EL0: AArch64SysRegId = PMEVTYPERn_EL0(19);
+pub const PMEVTYPER20_EL0: AArch64SysRegId = PMEVTYPERn_EL0(20);
+pub const PMEVTYPER21_EL0: AArch64SysRegId = PMEVTYPERn_EL0(21);
+pub const PMEVTYPER22_EL0: AArch64SysRegId = PMEVTYPERn_EL0(22);
+pub const PMEVTYPER23_EL0: AArch64SysRegId = PMEVTYPERn_EL0(23);
+pub const PMEVTYPER24_EL0: AArch64SysRegId = PMEVTYPERn_EL0(24);
+pub const PMEVTYPER25_EL0: AArch64SysRegId = PMEVTYPERn_EL0(25);
+pub const PMEVTYPER26_EL0: AArch64SysRegId = PMEVTYPERn_EL0(26);
+pub const PMEVTYPER27_EL0: AArch64SysRegId = PMEVTYPERn_EL0(27);
+pub const PMEVTYPER28_EL0: AArch64SysRegId = PMEVTYPERn_EL0(28);
+pub const PMEVTYPER29_EL0: AArch64SysRegId = PMEVTYPERn_EL0(29);
+pub const PMEVTYPER30_EL0: AArch64SysRegId = PMEVTYPERn_EL0(30);
+
+pub const SPMCGCR0_EL1: AArch64SysRegId = SPMCGCRn_EL1(0);
+pub const SPMCGCR1_EL1: AArch64SysRegId = SPMCGCRn_EL1(1);
+
+pub const SPMEVCNTR0_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(0);
+pub const SPMEVCNTR1_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(1);
+pub const SPMEVCNTR2_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(2);
+pub const SPMEVCNTR3_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(3);
+pub const SPMEVCNTR4_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(4);
+pub const SPMEVCNTR5_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(5);
+pub const SPMEVCNTR6_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(6);
+pub const SPMEVCNTR7_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(7);
+pub const SPMEVCNTR8_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(8);
+pub const SPMEVCNTR9_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(9);
+pub const SPMEVCNTRA_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(10);
+pub const SPMEVCNTRB_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(11);
+pub const SPMEVCNTRC_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(12);
+pub const SPMEVCNTRD_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(13);
+pub const SPMEVCNTRE_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(14);
+pub const SPMEVCNTRF_EL0: AArch64SysRegId = SPMEVCNTRn_EL0(15);
+
+pub const SPMEVFILT2R0_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(0);
+pub const SPMEVFILT2R1_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(1);
+pub const SPMEVFILT2R2_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(2);
+pub const SPMEVFILT2R3_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(3);
+pub const SPMEVFILT2R4_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(4);
+pub const SPMEVFILT2R5_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(5);
+pub const SPMEVFILT2R6_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(6);
+pub const SPMEVFILT2R7_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(7);
+pub const SPMEVFILT2R8_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(8);
+pub const SPMEVFILT2R9_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(9);
+pub const SPMEVFILT2RA_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(10);
+pub const SPMEVFILT2RB_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(11);
+pub const SPMEVFILT2RC_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(12);
+pub const SPMEVFILT2RD_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(13);
+pub const SPMEVFILT2RE_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(14);
+pub const SPMEVFILT2RF_EL0: AArch64SysRegId = SPMEVFILT2Rn_EL0(15);
+
+pub const SPMEVFILTR0_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(0);
+pub const SPMEVFILTR1_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(1);
+pub const SPMEVFILTR2_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(2);
+pub const SPMEVFILTR3_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(3);
+pub const SPMEVFILTR4_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(4);
+pub const SPMEVFILTR5_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(5);
+pub const SPMEVFILTR6_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(6);
+pub const SPMEVFILTR7_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(7);
+pub const SPMEVFILTR8_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(8);
+pub const SPMEVFILTR9_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(9);
+pub const SPMEVFILTRA_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(10);
+pub const SPMEVFILTRB_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(11);
+pub const SPMEVFILTRC_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(12);
+pub const SPMEVFILTRD_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(13);
+pub const SPMEVFILTRE_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(14);
+pub const SPMEVFILTRF_EL0: AArch64SysRegId = SPMEVFILTRn_EL0(15);
+
+pub const SPMEVTYPER0_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(0);
+pub const SPMEVTYPER1_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(1);
+pub const SPMEVTYPER2_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(2);
+pub const SPMEVTYPER3_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(3);
+pub const SPMEVTYPER4_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(4);
+pub const SPMEVTYPER5_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(5);
+pub const SPMEVTYPER6_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(6);
+pub const SPMEVTYPER7_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(7);
+pub const SPMEVTYPER8_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(8);
+pub const SPMEVTYPER9_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(9);
+pub const SPMEVTYPERA_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(10);
+pub const SPMEVTYPERB_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(11);
+pub const SPMEVTYPERC_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(12);
+pub const SPMEVTYPERD_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(13);
+pub const SPMEVTYPERE_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(14);
+pub const SPMEVTYPERF_EL0: AArch64SysRegId = SPMEVTYPERn_EL0(15);
+
+pub const TRCACATR0: AArch64SysRegId = TRCACATRn(0);
+pub const TRCACATR1: AArch64SysRegId = TRCACATRn(1);
+pub const TRCACATR2: AArch64SysRegId = TRCACATRn(2);
+pub const TRCACATR3: AArch64SysRegId = TRCACATRn(3);
+pub const TRCACATR4: AArch64SysRegId = TRCACATRn(4);
+pub const TRCACATR5: AArch64SysRegId = TRCACATRn(5);
+pub const TRCACATR6: AArch64SysRegId = TRCACATRn(6);
+pub const TRCACATR7: AArch64SysRegId = TRCACATRn(7);
+pub const TRCACATR8: AArch64SysRegId = TRCACATRn(8);
+pub const TRCACATR9: AArch64SysRegId = TRCACATRn(9);
+pub const TRCACATRA: AArch64SysRegId = TRCACATRn(10);
+pub const TRCACATRB: AArch64SysRegId = TRCACATRn(11);
+pub const TRCACATRC: AArch64SysRegId = TRCACATRn(12);
+pub const TRCACATRD: AArch64SysRegId = TRCACATRn(13);
+pub const TRCACATRE: AArch64SysRegId = TRCACATRn(14);
+pub const TRCACATRF: AArch64SysRegId = TRCACATRn(15);
+
+pub const TRCACVR0: AArch64SysRegId = TRCACVRn(0);
+pub const TRCACVR1: AArch64SysRegId = TRCACVRn(1);
+pub const TRCACVR2: AArch64SysRegId = TRCACVRn(2);
+pub const TRCACVR3: AArch64SysRegId = TRCACVRn(3);
+pub const TRCACVR4: AArch64SysRegId = TRCACVRn(4);
+pub const TRCACVR5: AArch64SysRegId = TRCACVRn(5);
+pub const TRCACVR6: AArch64SysRegId = TRCACVRn(6);
+pub const TRCACVR7: AArch64SysRegId = TRCACVRn(7);
+pub const TRCACVR8: AArch64SysRegId = TRCACVRn(8);
+pub const TRCACVR9: AArch64SysRegId = TRCACVRn(9);
+pub const TRCACVRA: AArch64SysRegId = TRCACVRn(10);
+pub const TRCACVRB: AArch64SysRegId = TRCACVRn(11);
+pub const TRCACVRC: AArch64SysRegId = TRCACVRn(12);
+pub const TRCACVRD: AArch64SysRegId = TRCACVRn(13);
+pub const TRCACVRE: AArch64SysRegId = TRCACVRn(14);
+pub const TRCACVRF: AArch64SysRegId = TRCACVRn(15);
+
+pub const TRCCIDCVR0: AArch64SysRegId = TRCCIDCVRn(0);
+pub const TRCCIDCVR1: AArch64SysRegId = TRCCIDCVRn(1);
+pub const TRCCIDCVR2: AArch64SysRegId = TRCCIDCVRn(2);
+pub const TRCCIDCVR3: AArch64SysRegId = TRCCIDCVRn(3);
+pub const TRCCIDCVR4: AArch64SysRegId = TRCCIDCVRn(4);
+pub const TRCCIDCVR5: AArch64SysRegId = TRCCIDCVRn(5);
+pub const TRCCIDCVR6: AArch64SysRegId = TRCCIDCVRn(6);
+pub const TRCCIDCVR7: AArch64SysRegId = TRCCIDCVRn(7);
+
+pub const TRCCNTCTLR0: AArch64SysRegId = TRCCNTCTLRn(0);
+pub const TRCCNTCTLR1: AArch64SysRegId = TRCCNTCTLRn(1);
+pub const TRCCNTCTLR2: AArch64SysRegId = TRCCNTCTLRn(2);
+pub const TRCCNTCTLR3: AArch64SysRegId = TRCCNTCTLRn(3);
+
+pub const TRCCNTRLDVR0: AArch64SysRegId = TRCCNTRLDVRn(0);
+pub const TRCCNTRLDVR1: AArch64SysRegId = TRCCNTRLDVRn(1);
+pub const TRCCNTRLDVR2: AArch64SysRegId = TRCCNTRLDVRn(2);
+pub const TRCCNTRLDVR3: AArch64SysRegId = TRCCNTRLDVRn(3);
+
+pub const TRCCNTVR0: AArch64SysRegId = TRCCNTVRn(0);
+pub const TRCCNTVR1: AArch64SysRegId = TRCCNTVRn(1);
+pub const TRCCNTVR2: AArch64SysRegId = TRCCNTVRn(2);
+pub const TRCCNTVR3: AArch64SysRegId = TRCCNTVRn(3);
+
+pub const TRCEXTINSELR0: AArch64SysRegId = TRCEXTINSELRn(0);
+pub const TRCEXTINSELR1: AArch64SysRegId = TRCEXTINSELRn(1);
+pub const TRCEXTINSELR2: AArch64SysRegId = TRCEXTINSELRn(2);
+pub const TRCEXTINSELR3: AArch64SysRegId = TRCEXTINSELRn(3);
+
+pub const TRCIMSPEC1: AArch64SysRegId = TRCIMSPECn(1);
+pub const TRCIMSPEC2: AArch64SysRegId = TRCIMSPECn(2);
+pub const TRCIMSPEC3: AArch64SysRegId = TRCIMSPECn(3);
+pub const TRCIMSPEC4: AArch64SysRegId = TRCIMSPECn(4);
+pub const TRCIMSPEC5: AArch64SysRegId = TRCIMSPECn(5);
+pub const TRCIMSPEC6: AArch64SysRegId = TRCIMSPECn(6);
+pub const TRCIMSPEC7: AArch64SysRegId = TRCIMSPECn(7);
+
+pub const TRCRSCTLR2: AArch64SysRegId = TRCRSCTLRn(2);
+pub const TRCRSCTLR3: AArch64SysRegId = TRCRSCTLRn(3);
+pub const TRCRSCTLR4: AArch64SysRegId = TRCRSCTLRn(4);
+pub const TRCRSCTLR5: AArch64SysRegId = TRCRSCTLRn(5);
+pub const TRCRSCTLR6: AArch64SysRegId = TRCRSCTLRn(6);
+pub const TRCRSCTLR7: AArch64SysRegId = TRCRSCTLRn(7);
+pub const TRCRSCTLR8: AArch64SysRegId = TRCRSCTLRn(8);
+pub const TRCRSCTLR9: AArch64SysRegId = TRCRSCTLRn(9);
+pub const TRCRSCTLR10: AArch64SysRegId = TRCRSCTLRn(10);
+pub const TRCRSCTLR11: AArch64SysRegId = TRCRSCTLRn(11);
+pub const TRCRSCTLR12: AArch64SysRegId = TRCRSCTLRn(12);
+pub const TRCRSCTLR13: AArch64SysRegId = TRCRSCTLRn(13);
+pub const TRCRSCTLR14: AArch64SysRegId = TRCRSCTLRn(14);
+pub const TRCRSCTLR15: AArch64SysRegId = TRCRSCTLRn(15);
+pub const TRCRSCTLR16: AArch64SysRegId = TRCRSCTLRn(16);
+pub const TRCRSCTLR17: AArch64SysRegId = TRCRSCTLRn(17);
+pub const TRCRSCTLR18: AArch64SysRegId = TRCRSCTLRn(18);
+pub const TRCRSCTLR19: AArch64SysRegId = TRCRSCTLRn(19);
+pub const TRCRSCTLR20: AArch64SysRegId = TRCRSCTLRn(20);
+pub const TRCRSCTLR21: AArch64SysRegId = TRCRSCTLRn(21);
+pub const TRCRSCTLR22: AArch64SysRegId = TRCRSCTLRn(22);
+pub const TRCRSCTLR23: AArch64SysRegId = TRCRSCTLRn(23);
+pub const TRCRSCTLR24: AArch64SysRegId = TRCRSCTLRn(24);
+pub const TRCRSCTLR25: AArch64SysRegId = TRCRSCTLRn(25);
+pub const TRCRSCTLR26: AArch64SysRegId = TRCRSCTLRn(26);
+pub const TRCRSCTLR27: AArch64SysRegId = TRCRSCTLRn(27);
+pub const TRCRSCTLR28: AArch64SysRegId = TRCRSCTLRn(28);
+pub const TRCRSCTLR29: AArch64SysRegId = TRCRSCTLRn(29);
+pub const TRCRSCTLR30: AArch64SysRegId = TRCRSCTLRn(30);
+pub const TRCRSCTLR31: AArch64SysRegId = TRCRSCTLRn(31);
+
+pub const TRCSEQEVR0: AArch64SysRegId = TRCSEQEVRn(0);
+pub const TRCSEQEVR1: AArch64SysRegId = TRCSEQEVRn(1);
+pub const TRCSEQEVR2: AArch64SysRegId = TRCSEQEVRn(2);
+
+pub const TRCSSCCR0: AArch64SysRegId = TRCSSCCRn(0);
+pub const TRCSSCCR1: AArch64SysRegId = TRCSSCCRn(1);
+pub const TRCSSCCR2: AArch64SysRegId = TRCSSCCRn(2);
+pub const TRCSSCCR3: AArch64SysRegId = TRCSSCCRn(3);
+pub const TRCSSCCR4: AArch64SysRegId = TRCSSCCRn(4);
+pub const TRCSSCCR5: AArch64SysRegId = TRCSSCCRn(5);
+pub const TRCSSCCR6: AArch64SysRegId = TRCSSCCRn(6);
+pub const TRCSSCCR7: AArch64SysRegId = TRCSSCCRn(7);
+
+pub const TRCSSCSR0: AArch64SysRegId = TRCSSCSRn(0);
+pub const TRCSSCSR1: AArch64SysRegId = TRCSSCSRn(1);
+pub const TRCSSCSR2: AArch64SysRegId = TRCSSCSRn(2);
+pub const TRCSSCSR3: AArch64SysRegId = TRCSSCSRn(3);
+pub const TRCSSCSR4: AArch64SysRegId = TRCSSCSRn(4);
+pub const TRCSSCSR5: AArch64SysRegId = TRCSSCSRn(5);
+pub const TRCSSCSR6: AArch64SysRegId = TRCSSCSRn(6);
+pub const TRCSSCSR7: AArch64SysRegId = TRCSSCSRn(7);
+
+pub const TRCSSPCICR0: AArch64SysRegId = TRCSSPCICRn(0);
+pub const TRCSSPCICR1: AArch64SysRegId = TRCSSPCICRn(1);
+pub const TRCSSPCICR2: AArch64SysRegId = TRCSSPCICRn(2);
+pub const TRCSSPCICR3: AArch64SysRegId = TRCSSPCICRn(3);
+pub const TRCSSPCICR4: AArch64SysRegId = TRCSSPCICRn(4);
+pub const TRCSSPCICR5: AArch64SysRegId = TRCSSPCICRn(5);
+pub const TRCSSPCICR6: AArch64SysRegId = TRCSSPCICRn(6);
+pub const TRCSSPCICR7: AArch64SysRegId = TRCSSPCICRn(7);
+
+pub const TRCVMIDCVR0: AArch64SysRegId = TRCVMIDCVRn(0);
+pub const TRCVMIDCVR1: AArch64SysRegId = TRCVMIDCVRn(1);
+pub const TRCVMIDCVR2: AArch64SysRegId = TRCVMIDCVRn(2);
+pub const TRCVMIDCVR3: AArch64SysRegId = TRCVMIDCVRn(3);
+pub const TRCVMIDCVR4: AArch64SysRegId = TRCVMIDCVRn(4);
+pub const TRCVMIDCVR5: AArch64SysRegId = TRCVMIDCVRn(5);
+pub const TRCVMIDCVR6: AArch64SysRegId = TRCVMIDCVRn(6);
+pub const TRCVMIDCVR7: AArch64SysRegId = TRCVMIDCVRn(7);
diff --git a/aarch64_sys_reg/src/funcs.rs b/aarch64_sys_reg/src/funcs.rs
new file mode 100644
index 000000000..5b5514312
--- /dev/null
+++ b/aarch64_sys_reg/src/funcs.rs
@@ -0,0 +1,281 @@
+// Copyright 2025 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+//! AArch64 system register range functions.
+//!
+//! This file consists of manually written functions to generate registers that cannot be handled
+//! automatically by the code generator.
+
+#![allow(non_snake_case, non_upper_case_globals)]
+
+use crate::AArch64SysRegId;
+
+const fn bit(val: u8, bit_index: u32) -> u8 {
+    (val >> bit_index) & 1
+}
+
+const fn bits(val: u8, hi_index: u32, lo_index: u32) -> u8 {
+    let mask = 1u8.wrapping_shl(hi_index - lo_index + 1).wrapping_sub(1);
+    (val >> lo_index) & mask
+}
+
+pub const fn AMEVCNTR0n_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let crm = (0b010 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, crm, op2)
+}
+
+pub const fn AMEVCNTR1n_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b110 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, crm, op2)
+}
+
+pub const fn AMEVCNTVOFF0n_EL2(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b100 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1101, crm, op2)
+}
+
+pub const fn AMEVCNTVOFF1n_EL2(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b101 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1101, crm, op2)
+}
+
+pub const fn AMEVTYPER0n_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let crm = (0b011 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, crm, op2)
+}
+
+pub const fn AMEVTYPER1n_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b111 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, crm, op2)
+}
+
+pub const fn BRBINFn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 31);
+    let crm = bits(m, 3, 0);
+    let op2 = (bit(m, 4) << 2) | 0b00;
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1000, crm, op2)
+}
+
+pub const fn BRBSRCn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 31);
+    let crm = bits(m, 3, 0);
+    let op2 = (bit(m, 4) << 2) | 0b01;
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1000, crm, op2)
+}
+
+pub const fn BRBTGTn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 31);
+    let crm = bits(m, 3, 0);
+    let op2 = (bit(m, 4) << 2) | 0b10;
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1000, crm, op2)
+}
+
+pub const fn DBGBCRn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = bits(m, 3, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, crm, 0b101)
+}
+
+pub const fn DBGBVRn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = bits(m, 3, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, crm, 0b100)
+}
+
+pub const fn DBGWCRn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = bits(m, 3, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, crm, 0b111)
+}
+
+pub const fn DBGWVRn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = bits(m, 3, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, crm, 0b110)
+}
+
+pub const fn ICC_AP0Rn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let op2 = (0b1 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, op2)
+}
+
+pub const fn ICC_AP1Rn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let op2 = (0b0 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, op2)
+}
+
+pub const fn ICH_AP0Rn_EL2(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let op2 = (0b0 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1000, op2)
+}
+
+pub const fn ICH_AP1Rn_EL2(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let op2 = (0b0 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1001, op2)
+}
+
+pub const fn ICH_LRn_EL2(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b110 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, crm, op2)
+}
+
+pub const fn PMEVCNTRn_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 30);
+    let crm = (0b10 << 2) | bits(m, 4, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, crm, op2)
+}
+
+pub const fn PMEVCNTSVRn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 30);
+    let crm = (0b10 << 2) | bits(m, 4, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1110, crm, op2)
+}
+
+pub const fn PMEVTYPERn_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 30);
+    let crm = (0b11 << 2) | bits(m, 4, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, crm, op2)
+}
+
+pub const fn SPMCGCRn_EL1(m: u8) -> AArch64SysRegId {
+    assert!(m <= 1);
+    let op2 = (0b00 << 1) | bit(m, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1101, op2)
+}
+
+pub const fn SPMEVCNTRn_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b000 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1110, crm, op2)
+}
+
+pub const fn SPMEVFILT2Rn_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b011 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1110, crm, op2)
+}
+
+pub const fn SPMEVFILTRn_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b010 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1110, crm, op2)
+}
+
+pub const fn SPMEVTYPERn_EL0(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (0b001 << 1) | bit(m, 3);
+    let op2 = bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1110, crm, op2)
+}
+
+pub const fn TRCACATRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (bits(m, 2, 0) << 1) | 0b0;
+    let op2 = (0b01 << 1) | bit(m, 3);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0010, crm, op2)
+}
+
+pub const fn TRCACVRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 15);
+    let crm = (bits(m, 2, 0) << 1) | 0b0;
+    let op2 = (0b00 << 1) | bit(m, 3);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0010, crm, op2)
+}
+
+pub const fn TRCCIDCVRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 7);
+    let crm = (bits(m, 2, 0) << 1) | 0b0;
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0011, crm, 0b000)
+}
+
+pub const fn TRCCNTCTLRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let crm = (0b01 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, crm, 0b101)
+}
+
+pub const fn TRCCNTRLDVRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let crm = (0b00 << 1) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, crm, 0b101)
+}
+
+pub const fn TRCCNTVRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let crm = (0b10 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, crm, 0b101)
+}
+
+pub const fn TRCEXTINSELRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 3);
+    let crm = (0b10 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, crm, 0b100)
+}
+
+pub const fn TRCIMSPECn(m: u8) -> AArch64SysRegId {
+    assert!(m >= 1 && m <= 7);
+    let crm = (0b0 << 3) | bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, crm, 0b111)
+}
+
+pub const fn TRCRSCTLRn(m: u8) -> AArch64SysRegId {
+    assert!(m >= 2 && m <= 31);
+    let crm = bits(m, 3, 0);
+    let op2 = (0b00 << 1) | bit(m, 4);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0001, crm, op2)
+}
+
+pub const fn TRCSEQEVRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 2);
+    let crm = (0b00 << 2) | bits(m, 1, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, crm, 0b100)
+}
+
+pub const fn TRCSSCCRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 7);
+    let crm = (0b0 << 3) | bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0001, crm, 0b010)
+}
+
+pub const fn TRCSSCSRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 7);
+    let crm = (0b1 << 3) | bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0001, crm, 0b010)
+}
+
+pub const fn TRCSSPCICRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 7);
+    let crm = (0b0 << 3) | bits(m, 2, 0);
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0001, crm, 0b011)
+}
+
+pub const fn TRCVMIDCVRn(m: u8) -> AArch64SysRegId {
+    assert!(m <= 7);
+    let crm = (bits(m, 2, 0) << 1) | 0b0;
+    AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0011, crm, 0b001)
+}
diff --git a/aarch64_sys_reg/src/gen.rs b/aarch64_sys_reg/src/gen.rs
new file mode 100644
index 000000000..9829ead11
--- /dev/null
+++ b/aarch64_sys_reg/src/gen.rs
@@ -0,0 +1,593 @@
+/* automatically generated by gen.sh - do not manually edit */
+
+#![cfg_attr(rustfmt, rustfmt_skip)]
+#![allow(non_upper_case_globals)]
+
+use crate::AArch64SysRegId;
+
+//                                                                                Op0    Op1     CRn     CRm    Op2
+pub const OSDTRRX_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0000, 0b010);
+pub const MDCCINT_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0010, 0b000);
+pub const MDSCR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0010, 0b010);
+pub const OSDTRTX_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0011, 0b010);
+pub const MDSELR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0100, 0b010);
+pub const MDSTEPOP_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0101, 0b010);
+pub const OSECCR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0000, 0b0110, 0b010);
+pub const MDRAR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0001, 0b0000, 0b000);
+pub const OSLAR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0001, 0b0000, 0b100);
+pub const OSLSR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0001, 0b0001, 0b100);
+pub const OSDLR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0001, 0b0011, 0b100);
+pub const DBGPRCR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0001, 0b0100, 0b100);
+pub const DBGCLAIMSET_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0111, 0b1000, 0b110);
+pub const DBGCLAIMCLR_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0111, 0b1001, 0b110);
+pub const DBGAUTHSTATUS_EL1   : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b0111, 0b1110, 0b110);
+pub const SPMACCESSR_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1101, 0b011);
+pub const SPMIIDR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1101, 0b100);
+pub const SPMDEVARCH_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1101, 0b101);
+pub const SPMDEVAFF_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1101, 0b110);
+pub const SPMCFGR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1101, 0b111);
+pub const SPMINTENSET_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1110, 0b001);
+pub const SPMINTENCLR_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1001, 0b1110, 0b010);
+pub const PMCCNTSVR_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1110, 0b1011, 0b111);
+pub const PMICNTSVR_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b000, 0b1110, 0b1100, 0b000);
+pub const TRCTRACEIDR         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0000, 0b001);
+pub const TRCVICTLR           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0000, 0b010);
+pub const TRCIDR8             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0000, 0b110);
+pub const TRCIMSPEC0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0000, 0b111);
+pub const TRCPRGCTLR          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0001, 0b000);
+pub const TRCQCTLR            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0001, 0b001);
+pub const TRCVIIECTLR         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0001, 0b010);
+pub const TRCIDR9             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0001, 0b110);
+pub const TRCITEEDCR          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0010, 0b001);
+pub const TRCVISSCTLR         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0010, 0b010);
+pub const TRCIDR10            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0010, 0b110);
+pub const TRCSTATR            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0011, 0b000);
+pub const TRCVIPCSSCTLR       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0011, 0b010);
+pub const TRCIDR11            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0011, 0b110);
+pub const TRCCONFIGR          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0100, 0b000);
+pub const TRCIDR12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0100, 0b110);
+pub const TRCIDR13            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0101, 0b110);
+pub const TRCAUXCTLR          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0110, 0b000);
+pub const TRCSEQRSTEVR        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0110, 0b100);
+pub const TRCSEQSTR           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b0111, 0b100);
+pub const TRCEVENTCTL0R       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1000, 0b000);
+pub const TRCIDR0             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1000, 0b111);
+pub const TRCEVENTCTL1R       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1001, 0b000);
+pub const TRCIDR1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1001, 0b111);
+pub const TRCRSR              : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1010, 0b000);
+pub const TRCIDR2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1010, 0b111);
+pub const TRCSTALLCTLR        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1011, 0b000);
+pub const TRCIDR3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1011, 0b111);
+pub const TRCTSCTLR           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1100, 0b000);
+pub const TRCIDR4             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1100, 0b111);
+pub const TRCSYNCPR           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1101, 0b000);
+pub const TRCIDR5             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1101, 0b111);
+pub const TRCCCCTLR           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1110, 0b000);
+pub const TRCIDR6             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1110, 0b111);
+pub const TRCBBCTLR           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1111, 0b000);
+pub const TRCIDR7             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0000, 0b1111, 0b111);
+pub const TRCOSLSR            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0001, 0b0001, 0b100);
+pub const TRCCIDCCTLR0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0011, 0b0000, 0b010);
+pub const TRCCIDCCTLR1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0011, 0b0001, 0b010);
+pub const TRCVMIDCCTLR0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0011, 0b0010, 0b010);
+pub const TRCVMIDCCTLR1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0011, 0b0011, 0b010);
+pub const TRCDEVID            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0111, 0b0010, 0b111);
+pub const TRCCLAIMSET         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0111, 0b1000, 0b110);
+pub const TRCCLAIMCLR         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0111, 0b1001, 0b110);
+pub const TRCAUTHSTATUS       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0111, 0b1110, 0b110);
+pub const TRCDEVARCH          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b0111, 0b1111, 0b110);
+pub const BRBCR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0000, 0b000);
+pub const BRBFCR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0000, 0b001);
+pub const BRBTS_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0000, 0b010);
+pub const BRBINFINJ_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0001, 0b000);
+pub const BRBSRCINJ_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0001, 0b001);
+pub const BRBTGTINJ_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0001, 0b010);
+pub const BRBIDR0_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b001, 0b1001, 0b0010, 0b000);
+pub const MDCCSR_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b0000, 0b0001, 0b000);
+pub const DBGDTR_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b0000, 0b0100, 0b000);
+pub const DBGDTRRX_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b0000, 0b0101, 0b000);
+pub const DBGDTRTX_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b0000, 0b0101, 0b000);
+pub const SPMCR_EL0           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1100, 0b000);
+pub const SPMCNTENSET_EL0     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1100, 0b001);
+pub const SPMCNTENCLR_EL0     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1100, 0b010);
+pub const SPMOVSCLR_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1100, 0b011);
+pub const SPMZR_EL0           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1100, 0b100);
+pub const SPMSELR_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1100, 0b101);
+pub const SPMOVSSET_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b011, 0b1001, 0b1110, 0b011);
+pub const DBGVCR32_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b100, 0b0000, 0b0111, 0b000);
+pub const BRBCR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b100, 0b1001, 0b0000, 0b000);
+pub const SPMACCESSR_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b100, 0b1001, 0b1101, 0b011);
+pub const BRBCR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b101, 0b1001, 0b0000, 0b000);
+pub const SPMACCESSR_EL12     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b101, 0b1001, 0b1101, 0b011);
+pub const SPMACCESSR_EL3      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b110, 0b1001, 0b1101, 0b011);
+pub const SPMROOTCR_EL3       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b110, 0b1001, 0b1110, 0b111);
+pub const SPMSCR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b10, 0b111, 0b1001, 0b1110, 0b111);
+pub const MIDR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0000, 0b000);
+pub const MPIDR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0000, 0b101);
+pub const REVIDR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0000, 0b110);
+pub const ID_PFR0_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b000);
+pub const ID_PFR1_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b001);
+pub const ID_DFR0_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b010);
+pub const ID_AFR0_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b011);
+pub const ID_MMFR0_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b100);
+pub const ID_MMFR1_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b101);
+pub const ID_MMFR2_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b110);
+pub const ID_MMFR3_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0001, 0b111);
+pub const ID_ISAR0_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b000);
+pub const ID_ISAR1_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b001);
+pub const ID_ISAR2_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b010);
+pub const ID_ISAR3_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b011);
+pub const ID_ISAR4_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b100);
+pub const ID_ISAR5_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b101);
+pub const ID_MMFR4_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b110);
+pub const ID_ISAR6_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0010, 0b111);
+pub const MVFR0_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0011, 0b000);
+pub const MVFR1_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0011, 0b001);
+pub const MVFR2_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0011, 0b010);
+pub const ID_PFR2_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0011, 0b100);
+pub const ID_DFR1_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0011, 0b101);
+pub const ID_MMFR5_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0011, 0b110);
+pub const ID_AA64PFR0_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0100, 0b000);
+pub const ID_AA64PFR1_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0100, 0b001);
+pub const ID_AA64PFR2_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0100, 0b010);
+pub const ID_AA64ZFR0_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0100, 0b100);
+pub const ID_AA64SMFR0_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0100, 0b101);
+pub const ID_AA64FPFR0_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0100, 0b111);
+pub const ID_AA64DFR0_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0101, 0b000);
+pub const ID_AA64DFR1_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0101, 0b001);
+pub const ID_AA64DFR2_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0101, 0b010);
+pub const ID_AA64AFR0_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0101, 0b100);
+pub const ID_AA64AFR1_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0101, 0b101);
+pub const ID_AA64ISAR0_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0110, 0b000);
+pub const ID_AA64ISAR1_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0110, 0b001);
+pub const ID_AA64ISAR2_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0110, 0b010);
+pub const ID_AA64ISAR3_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0110, 0b011);
+pub const ID_AA64MMFR0_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0111, 0b000);
+pub const ID_AA64MMFR1_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0111, 0b001);
+pub const ID_AA64MMFR2_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0111, 0b010);
+pub const ID_AA64MMFR3_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0111, 0b011);
+pub const ID_AA64MMFR4_EL1    : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0000, 0b0111, 0b100);
+pub const SCTLR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0000, 0b000);
+pub const ACTLR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0000, 0b001);
+pub const CPACR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0000, 0b010);
+pub const SCTLR2_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0000, 0b011);
+pub const RGSR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0000, 0b101);
+pub const GCR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0000, 0b110);
+pub const ZCR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0010, 0b000);
+pub const TRFCR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0010, 0b001);
+pub const TRCITECR_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0010, 0b011);
+pub const SMPRI_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0010, 0b100);
+pub const SMCR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0010, 0b110);
+pub const SCTLRMASK_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b000);
+pub const ACTLRMASK_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b001);
+pub const CPACRMASK_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b010);
+pub const SCTLR2MASK_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b011);
+pub const CPACRALIAS_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b100);
+pub const ACTLRALIAS_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b101);
+pub const SCTLRALIAS_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b110);
+pub const SCTLR2ALIAS_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0001, 0b0100, 0b111);
+pub const TTBR0_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0000, 0b000);
+pub const TTBR1_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0000, 0b001);
+pub const TCR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0000, 0b010);
+pub const TCR2_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0000, 0b011);
+pub const APIAKeyLo_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0001, 0b000);
+pub const APIAKeyHi_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0001, 0b001);
+pub const APIBKeyLo_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0001, 0b010);
+pub const APIBKeyHi_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0001, 0b011);
+pub const APDAKeyLo_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0010, 0b000);
+pub const APDAKeyHi_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0010, 0b001);
+pub const APDBKeyLo_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0010, 0b010);
+pub const APDBKeyHi_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0010, 0b011);
+pub const APGAKeyLo_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0011, 0b000);
+pub const APGAKeyHi_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0011, 0b001);
+pub const GCSCR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0101, 0b000);
+pub const GCSPR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0101, 0b001);
+pub const GCSCRE0_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0101, 0b010);
+pub const TCRMASK_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0111, 0b010);
+pub const TCR2MASK_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0111, 0b011);
+pub const TCRALIAS_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0111, 0b110);
+pub const TCR2ALIAS_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0010, 0b0111, 0b111);
+pub const SPSR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0000, 0b000);
+pub const ELR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0000, 0b001);
+pub const SP_EL0              : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0001, 0b000);
+pub const SPSel               : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0010, 0b000);
+pub const CurrentEL           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0010, 0b010);
+pub const PAN                 : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0010, 0b011);
+pub const UAO                 : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0010, 0b100);
+pub const ALLINT              : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0011, 0b000);
+pub const PM                  : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0011, 0b001);
+pub const ICC_PMR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0100, 0b0110, 0b000);
+pub const AFSR0_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0001, 0b000);
+pub const AFSR1_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0001, 0b001);
+pub const ESR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0010, 0b000);
+pub const ERRIDR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0011, 0b000);
+pub const ERRSELR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0011, 0b001);
+pub const ERXGSR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0011, 0b010);
+pub const ERXFR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b000);
+pub const ERXCTLR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b001);
+pub const ERXSTATUS_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b010);
+pub const ERXADDR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b011);
+pub const ERXPFGF_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b100);
+pub const ERXPFGCTL_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b101);
+pub const ERXPFGCDN_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0100, 0b110);
+pub const ERXMISC0_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0101, 0b000);
+pub const ERXMISC1_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0101, 0b001);
+pub const ERXMISC2_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0101, 0b010);
+pub const ERXMISC3_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0101, 0b011);
+pub const TFSR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0110, 0b000);
+pub const TFSRE0_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0101, 0b0110, 0b001);
+pub const FAR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0110, 0b0000, 0b000);
+pub const PFAR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0110, 0b0000, 0b101);
+pub const PAR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b0111, 0b0100, 0b000);
+pub const PMSCR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b000);
+pub const PMSNEVFR_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b001);
+pub const PMSICR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b010);
+pub const PMSIRR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b011);
+pub const PMSFCR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b100);
+pub const PMSEVFR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b101);
+pub const PMSLATFR_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b110);
+pub const PMSIDR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1001, 0b111);
+pub const PMBLIMITR_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1010, 0b000);
+pub const PMBPTR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1010, 0b001);
+pub const PMBSR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1010, 0b011);
+pub const PMSDSFR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1010, 0b100);
+pub const PMBMAR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1010, 0b101);
+pub const PMBIDR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1010, 0b111);
+pub const TRBLIMITR_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b000);
+pub const TRBPTR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b001);
+pub const TRBBASER_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b010);
+pub const TRBSR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b011);
+pub const TRBMAR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b100);
+pub const TRBMPAM_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b101);
+pub const TRBTRG_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b110);
+pub const TRBIDR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1011, 0b111);
+pub const PMSSCR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1101, 0b011);
+pub const PMINTENSET_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1110, 0b001);
+pub const PMINTENCLR_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1110, 0b010);
+pub const PMUACR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1110, 0b100);
+pub const PMECR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1110, 0b101);
+pub const PMMIR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1110, 0b110);
+pub const PMIAR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1001, 0b1110, 0b111);
+pub const MAIR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0010, 0b000);
+pub const MAIR2_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0010, 0b001);
+pub const PIRE0_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0010, 0b010);
+pub const PIR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0010, 0b011);
+pub const POR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0010, 0b100);
+pub const S2POR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0010, 0b101);
+pub const AMAIR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0011, 0b000);
+pub const AMAIR2_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0011, 0b001);
+pub const LORSA_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b000);
+pub const LOREA_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b001);
+pub const LORN_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b010);
+pub const LORC_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b011);
+pub const MPAMIDR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b100);
+pub const MPAMBWIDR_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b101);
+pub const LORID_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0100, 0b111);
+pub const MPAM1_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0101, 0b000);
+pub const MPAM0_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0101, 0b001);
+pub const MPAMSM_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0101, 0b011);
+pub const MPAMBW1_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0101, 0b100);
+pub const MPAMBW0_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0101, 0b101);
+pub const MPAMBWSM_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1010, 0b0101, 0b111);
+pub const VBAR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b0000, 0b000);
+pub const RVBAR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b0000, 0b001);
+pub const RMR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b0000, 0b010);
+pub const ISR_EL1             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b0001, 0b000);
+pub const DISR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b0001, 0b001);
+pub const ICC_IAR0_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b000);
+pub const ICC_EOIR0_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b001);
+pub const ICC_HPPIR0_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b010);
+pub const ICC_BPR0_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b011);
+pub const ICC_NMIAR1_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b101);
+pub const ICC_DIR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1011, 0b001);
+pub const ICC_RPR_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1011, 0b011);
+pub const ICC_SGI1R_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1011, 0b101);
+pub const ICC_ASGI1R_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1011, 0b110);
+pub const ICC_SGI0R_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1011, 0b111);
+pub const ICC_IAR1_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b000);
+pub const ICC_EOIR1_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b001);
+pub const ICC_HPPIR1_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b010);
+pub const ICC_BPR1_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b011);
+pub const ICC_CTLR_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b100);
+pub const ICC_SRE_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b101);
+pub const ICC_IGRPEN0_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b110);
+pub const ICC_IGRPEN1_EL1     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1100, 0b111);
+pub const CONTEXTIDR_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1101, 0b0000, 0b001);
+pub const RCWSMASK_EL1        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1101, 0b0000, 0b011);
+pub const TPIDR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1101, 0b0000, 0b100);
+pub const ACCDATA_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1101, 0b0000, 0b101);
+pub const RCWMASK_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1101, 0b0000, 0b110);
+pub const SCXTNUM_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1101, 0b0000, 0b111);
+pub const CNTKCTL_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1110, 0b0001, 0b000);
+pub const CCSIDR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b000);
+pub const CLIDR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b001);
+pub const CCSIDR2_EL1         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b010);
+pub const GMID_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b100);
+pub const SMIDR_EL1           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b110);
+pub const AIDR_EL1            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b111);
+pub const CSSELR_EL1          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b010, 0b0000, 0b0000, 0b000);
+pub const CTR_EL0             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0000, 0b0000, 0b001);
+pub const DCZID_EL0           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0000, 0b0000, 0b111);
+pub const RNDR                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0010, 0b0100, 0b000);
+pub const RNDRRS              : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0010, 0b0100, 0b001);
+pub const GCSPR_EL0           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0010, 0b0101, 0b001);
+pub const NZCV                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0010, 0b000);
+pub const DAIF                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0010, 0b001);
+pub const SVCR                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0010, 0b010);
+pub const DIT                 : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0010, 0b101);
+pub const SSBS                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0010, 0b110);
+pub const TCO                 : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0010, 0b111);
+pub const FPCR                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0100, 0b000);
+pub const FPSR                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0100, 0b001);
+pub const FPMR                : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0100, 0b010);
+pub const DSPSR_EL0           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0101, 0b000);
+pub const DLR_EL0             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b0100, 0b0101, 0b001);
+pub const PMICNTR_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b0100, 0b000);
+pub const PMICFILTR_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b0110, 0b000);
+pub const PMCR_EL0            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b000);
+pub const PMCNTENSET_EL0      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b001);
+pub const PMCNTENCLR_EL0      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b010);
+pub const PMOVSCLR_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b011);
+pub const PMSWINC_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b100);
+pub const PMSELR_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b101);
+pub const PMCEID0_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b110);
+pub const PMCEID1_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1100, 0b111);
+pub const PMCCNTR_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1101, 0b000);
+pub const PMXEVTYPER_EL0      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1101, 0b001);
+pub const PMXEVCNTR_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1101, 0b010);
+pub const PMZR_EL0            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1101, 0b100);
+pub const PMUSERENR_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1110, 0b000);
+pub const PMOVSSET_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1001, 0b1110, 0b011);
+pub const POR_EL0             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1010, 0b0010, 0b100);
+pub const TPIDR_EL0           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0000, 0b010);
+pub const TPIDRRO_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0000, 0b011);
+pub const TPIDR2_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0000, 0b101);
+pub const SCXTNUM_EL0         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0000, 0b111);
+pub const AMCR_EL0            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b000);
+pub const AMCFGR_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b001);
+pub const AMCGCR_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b010);
+pub const AMUSERENR_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b011);
+pub const AMCNTENCLR0_EL0     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b100);
+pub const AMCNTENSET0_EL0     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b101);
+pub const AMCG1IDR_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0010, 0b110);
+pub const AMCNTENCLR1_EL0     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0011, 0b000);
+pub const AMCNTENSET1_EL0     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1101, 0b0011, 0b001);
+pub const CNTFRQ_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0000, 0b000);
+pub const CNTPCT_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0000, 0b001);
+pub const CNTVCT_EL0          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0000, 0b010);
+pub const CNTPCTSS_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0000, 0b101);
+pub const CNTVCTSS_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0000, 0b110);
+pub const CNTP_TVAL_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0010, 0b000);
+pub const CNTP_CTL_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0010, 0b001);
+pub const CNTP_CVAL_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0010, 0b010);
+pub const CNTV_TVAL_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0011, 0b000);
+pub const CNTV_CTL_EL0        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0011, 0b001);
+pub const CNTV_CVAL_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b0011, 0b010);
+pub const PMCCFILTR_EL0       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b011, 0b1110, 0b1111, 0b111);
+pub const VPIDR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0000, 0b0000, 0b000);
+pub const VMPIDR_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0000, 0b0000, 0b101);
+pub const SCTLR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0000, 0b000);
+pub const ACTLR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0000, 0b001);
+pub const SCTLR2_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0000, 0b011);
+pub const HCR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b000);
+pub const MDCR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b001);
+pub const CPTR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b010);
+pub const HSTR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b011);
+pub const HFGRTR_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b100);
+pub const HFGWTR_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b101);
+pub const HFGITR_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b110);
+pub const HACR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0001, 0b111);
+pub const ZCR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0010, 0b000);
+pub const TRFCR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0010, 0b001);
+pub const HCRX_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0010, 0b010);
+pub const TRCITECR_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0010, 0b011);
+pub const SMPRIMAP_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0010, 0b101);
+pub const SMCR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0010, 0b110);
+pub const SDER32_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0011, 0b001);
+pub const SCTLRMASK_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0100, 0b000);
+pub const ACTLRMASK_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0100, 0b001);
+pub const CPTRMASK_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0100, 0b010);
+pub const SCTLR2MASK_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0001, 0b0100, 0b011);
+pub const TTBR0_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0000, 0b000);
+pub const TTBR1_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0000, 0b001);
+pub const TCR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0000, 0b010);
+pub const TCR2_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0000, 0b011);
+pub const VTTBR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0001, 0b000);
+pub const VTCR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0001, 0b010);
+pub const VNCR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0010, 0b000);
+pub const HDBSSBR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0011, 0b010);
+pub const HDBSSPROD_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0011, 0b011);
+pub const HACDBSBR_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0011, 0b100);
+pub const HACDBSCONS_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0011, 0b101);
+pub const GCSCR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0101, 0b000);
+pub const GCSPR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0101, 0b001);
+pub const VSTTBR_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0110, 0b000);
+pub const VSTCR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0110, 0b010);
+pub const TCRMASK_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0111, 0b010);
+pub const TCR2MASK_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0010, 0b0111, 0b011);
+pub const DACR32_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0000, 0b000);
+pub const HDFGRTR2_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b000);
+pub const HDFGWTR2_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b001);
+pub const HFGRTR2_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b010);
+pub const HFGWTR2_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b011);
+pub const HDFGRTR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b100);
+pub const HDFGWTR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b101);
+pub const HAFGRTR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b110);
+pub const HFGITR2_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0011, 0b0001, 0b111);
+pub const SPSR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0000, 0b000);
+pub const ELR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0000, 0b001);
+pub const SP_EL1              : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0001, 0b000);
+pub const SPSR_irq            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b000);
+pub const SPSR_abt            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b001);
+pub const SPSR_und            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b010);
+pub const SPSR_fiq            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b011);
+pub const IFSR32_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0000, 0b001);
+pub const AFSR0_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0001, 0b000);
+pub const AFSR1_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0001, 0b001);
+pub const ESR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0010, 0b000);
+pub const VSESR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0010, 0b011);
+pub const FPEXC32_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0011, 0b000);
+pub const TFSR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0101, 0b0110, 0b000);
+pub const FAR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0110, 0b0000, 0b000);
+pub const HPFAR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0110, 0b0000, 0b100);
+pub const PFAR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b0110, 0b0000, 0b101);
+pub const PMSCR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1001, 0b1001, 0b000);
+pub const PMBSR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1001, 0b1010, 0b011);
+pub const TRBSR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1001, 0b1011, 0b011);
+pub const MAIR2_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0001, 0b001);
+pub const MAIR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0010, 0b000);
+pub const PIRE0_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0010, 0b010);
+pub const PIR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0010, 0b011);
+pub const POR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0010, 0b100);
+pub const S2PIR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0010, 0b101);
+pub const AMAIR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0011, 0b000);
+pub const AMAIR2_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0011, 0b001);
+pub const MPAMHCR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0100, 0b000);
+pub const MPAMVPMV_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0100, 0b001);
+pub const MPAM2_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0101, 0b000);
+pub const MPAMBW2_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0101, 0b100);
+pub const MPAMBWCAP_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0101, 0b110);
+pub const MPAMVPM0_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b000);
+pub const MPAMVPM1_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b001);
+pub const MPAMVPM2_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b010);
+pub const MPAMVPM3_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b011);
+pub const MPAMVPM4_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b100);
+pub const MPAMVPM5_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b101);
+pub const MPAMVPM6_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b110);
+pub const MPAMVPM7_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b0110, 0b111);
+pub const MECID_P0_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1000, 0b000);
+pub const MECID_A0_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1000, 0b001);
+pub const MECID_P1_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1000, 0b010);
+pub const MECID_A1_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1000, 0b011);
+pub const MECIDR_EL2          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1000, 0b111);
+pub const VMECID_P_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1001, 0b000);
+pub const VMECID_A_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1010, 0b1001, 0b001);
+pub const VBAR_EL2            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b0000, 0b000);
+pub const RVBAR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b0000, 0b001);
+pub const RMR_EL2             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b0000, 0b010);
+pub const VDISR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b0001, 0b001);
+pub const ICC_SRE_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1001, 0b101);
+pub const ICH_HCR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1011, 0b000);
+pub const ICH_VTR_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1011, 0b001);
+pub const ICH_MISR_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1011, 0b010);
+pub const ICH_EISR_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1011, 0b011);
+pub const ICH_ELRSR_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1011, 0b101);
+pub const ICH_VMCR_EL2        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1100, 0b1011, 0b111);
+pub const CONTEXTIDR_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1101, 0b0000, 0b001);
+pub const TPIDR_EL2           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1101, 0b0000, 0b010);
+pub const SCXTNUM_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1101, 0b0000, 0b111);
+pub const CNTVOFF_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0000, 0b011);
+pub const CNTPOFF_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0000, 0b110);
+pub const CNTHCTL_EL2         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0001, 0b000);
+pub const CNTHP_TVAL_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0010, 0b000);
+pub const CNTHP_CTL_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0010, 0b001);
+pub const CNTHP_CVAL_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0010, 0b010);
+pub const CNTHV_TVAL_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0011, 0b000);
+pub const CNTHV_CTL_EL2       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0011, 0b001);
+pub const CNTHV_CVAL_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0011, 0b010);
+pub const CNTHVS_TVAL_EL2     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0100, 0b000);
+pub const CNTHVS_CTL_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0100, 0b001);
+pub const CNTHVS_CVAL_EL2     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0100, 0b010);
+pub const CNTHPS_TVAL_EL2     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0101, 0b000);
+pub const CNTHPS_CTL_EL2      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0101, 0b001);
+pub const CNTHPS_CVAL_EL2     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b100, 0b1110, 0b0101, 0b010);
+pub const SCTLR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0000, 0b000);
+pub const ACTLR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0000, 0b001);
+pub const CPACR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0000, 0b010);
+pub const SCTLR2_EL12         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0000, 0b011);
+pub const ZCR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0010, 0b000);
+pub const TRFCR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0010, 0b001);
+pub const TRCITECR_EL12       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0010, 0b011);
+pub const SMCR_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0010, 0b110);
+pub const SCTLRMASK_EL12      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0100, 0b000);
+pub const ACTLRMASK_EL12      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0100, 0b001);
+pub const CPACRMASK_EL12      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0100, 0b010);
+pub const SCTLR2MASK_EL12     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0001, 0b0100, 0b011);
+pub const TTBR0_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0000, 0b000);
+pub const TTBR1_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0000, 0b001);
+pub const TCR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0000, 0b010);
+pub const TCR2_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0000, 0b011);
+pub const GCSCR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0101, 0b000);
+pub const GCSPR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0101, 0b001);
+pub const TCRMASK_EL12        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0111, 0b010);
+pub const TCR2MASK_EL12       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0010, 0b0111, 0b011);
+pub const SPSR_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0100, 0b0000, 0b000);
+pub const ELR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0100, 0b0000, 0b001);
+pub const AFSR0_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0101, 0b0001, 0b000);
+pub const AFSR1_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0101, 0b0001, 0b001);
+pub const ESR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0101, 0b0010, 0b000);
+pub const TFSR_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0101, 0b0110, 0b000);
+pub const FAR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0110, 0b0000, 0b000);
+pub const PFAR_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b0110, 0b0000, 0b101);
+pub const PMSCR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1001, 0b1001, 0b000);
+pub const PMBSR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1001, 0b1010, 0b011);
+pub const TRBSR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1001, 0b1011, 0b011);
+pub const MAIR_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0010, 0b000);
+pub const MAIR2_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0010, 0b001);
+pub const PIRE0_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0010, 0b010);
+pub const PIR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0010, 0b011);
+pub const POR_EL12            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0010, 0b100);
+pub const AMAIR_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0011, 0b000);
+pub const AMAIR2_EL12         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0011, 0b001);
+pub const MPAM1_EL12          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0101, 0b000);
+pub const MPAMBW1_EL12        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1010, 0b0101, 0b100);
+pub const VBAR_EL12           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1100, 0b0000, 0b000);
+pub const CONTEXTIDR_EL12     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1101, 0b0000, 0b001);
+pub const SCXTNUM_EL12        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1101, 0b0000, 0b111);
+pub const CNTKCTL_EL12        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0001, 0b000);
+pub const CNTP_TVAL_EL02      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0010, 0b000);
+pub const CNTP_CTL_EL02       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0010, 0b001);
+pub const CNTP_CVAL_EL02      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0010, 0b010);
+pub const CNTV_TVAL_EL02      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0011, 0b000);
+pub const CNTV_CTL_EL02       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0011, 0b001);
+pub const CNTV_CVAL_EL02      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b101, 0b1110, 0b0011, 0b010);
+pub const SCTLR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0000, 0b000);
+pub const ACTLR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0000, 0b001);
+pub const SCTLR2_EL3          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0000, 0b011);
+pub const SCR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0001, 0b000);
+pub const SDER32_EL3          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0001, 0b001);
+pub const CPTR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0001, 0b010);
+pub const FGWTE3_EL3          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0001, 0b101);
+pub const ZCR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0010, 0b000);
+pub const SMCR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0010, 0b110);
+pub const MDCR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0001, 0b0011, 0b001);
+pub const TTBR0_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0000, 0b000);
+pub const TCR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0000, 0b010);
+pub const GPTBR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0001, 0b100);
+pub const GPCBW_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0001, 0b101);
+pub const GPCCR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0001, 0b110);
+pub const GCSCR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0101, 0b000);
+pub const GCSPR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0010, 0b0101, 0b001);
+pub const SPSR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0100, 0b0000, 0b000);
+pub const ELR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0100, 0b0000, 0b001);
+pub const SP_EL2              : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0100, 0b0001, 0b000);
+pub const AFSR0_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0101, 0b0001, 0b000);
+pub const AFSR1_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0101, 0b0001, 0b001);
+pub const ESR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0101, 0b0010, 0b000);
+pub const VSESR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0101, 0b0010, 0b011);
+pub const TFSR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0101, 0b0110, 0b000);
+pub const FAR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0110, 0b0000, 0b000);
+pub const MFAR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b0110, 0b0000, 0b101);
+pub const PMBSR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1001, 0b1010, 0b011);
+pub const TRBSR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1001, 0b1011, 0b011);
+pub const MAIR2_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0001, 0b001);
+pub const MAIR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0010, 0b000);
+pub const PIR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0010, 0b011);
+pub const POR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0010, 0b100);
+pub const AMAIR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0011, 0b000);
+pub const AMAIR2_EL3          : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0011, 0b001);
+pub const MPAM3_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0101, 0b000);
+pub const MPAMBW3_EL3         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b0101, 0b100);
+pub const MECID_RL_A_EL3      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1010, 0b1010, 0b001);
+pub const VBAR_EL3            : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b0000, 0b000);
+pub const RVBAR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b0000, 0b001);
+pub const RMR_EL3             : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b0000, 0b010);
+pub const VDISR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b0001, 0b001);
+pub const ICC_CTLR_EL3        : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b1100, 0b100);
+pub const ICC_SRE_EL3         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b1100, 0b101);
+pub const ICC_IGRPEN1_EL3     : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1100, 0b1100, 0b111);
+pub const TPIDR_EL3           : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1101, 0b0000, 0b010);
+pub const SCXTNUM_EL3         : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b110, 0b1101, 0b0000, 0b111);
+pub const CNTPS_TVAL_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b111, 0b1110, 0b0010, 0b000);
+pub const CNTPS_CTL_EL1       : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b111, 0b1110, 0b0010, 0b001);
+pub const CNTPS_CVAL_EL1      : AArch64SysRegId = AArch64SysRegId::new_unchecked(0b11, 0b111, 0b1110, 0b0010, 0b010);
diff --git a/aarch64_sys_reg/src/lib.rs b/aarch64_sys_reg/src/lib.rs
new file mode 100644
index 000000000..4fc00f955
--- /dev/null
+++ b/aarch64_sys_reg/src/lib.rs
@@ -0,0 +1,126 @@
+// Copyright 2025 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+//! AArch64 system register names and encoding.
+
+mod consts;
+mod funcs;
+mod gen;
+
+#[cfg(test)]
+mod tests;
+
+pub use consts::*;
+pub use funcs::*;
+pub use gen::*;
+use serde::Deserialize;
+use serde::Serialize;
+use thiserror::Error;
+
+#[derive(Error, Debug)]
+pub enum Error {
+    #[error("invalid CRm {0}")]
+    InvalidCrm(u8),
+    #[error("invalid CRn {0}")]
+    InvalidCrn(u8),
+    #[error("invalid Op0 {0}")]
+    InvalidOp0(u8),
+    #[error("invalid Op1 {0}")]
+    InvalidOp1(u8),
+    #[error("invalid Op2 {0}")]
+    InvalidOp2(u8),
+}
+
+pub type Result<T> = std::result::Result<T, Error>;
+
+/// AArch64 system register as used in MSR/MRS instructions.
+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct AArch64SysRegId(u16);
+
+impl AArch64SysRegId {
+    /// Construct a system register ID from Op0, Op1, CRn, CRm, Op2.
+    ///
+    /// The meanings of the arguments are described in the ARMv8 Architecture Reference Manual
+    /// "System instruction class encoding overview" section.
+    pub fn new(op0: u8, op1: u8, crn: u8, crm: u8, op2: u8) -> Result<Self> {
+        if op0 > 0b11 {
+            return Err(Error::InvalidOp0(op0));
+        }
+        if op1 > 0b111 {
+            return Err(Error::InvalidOp1(op1));
+        }
+        if crn > 0b1111 {
+            return Err(Error::InvalidCrn(crn));
+        }
+        if crm > 0b1111 {
+            return Err(Error::InvalidCrm(crm));
+        }
+        if op2 > 0b111 {
+            return Err(Error::InvalidOp2(op2));
+        }
+
+        Ok(Self::new_unchecked(op0, op1, crn, crm, op2))
+    }
+
+    /// Construct a system register ID from Op0, Op1, CRn, CRm, Op2.
+    ///
+    /// Out-of-range values will be silently truncated.
+    pub const fn new_unchecked(op0: u8, op1: u8, crn: u8, crm: u8, op2: u8) -> Self {
+        let op0 = (op0 as u16 & 0b11) << 14;
+        let op1 = (op1 as u16 & 0b111) << 11;
+        let crn = (crn as u16 & 0b1111) << 7;
+        let crm = (crm as u16 & 0b1111) << 3;
+        let op2 = op2 as u16 & 0b111;
+        Self(op0 | op1 | crn | crm | op2)
+    }
+
+    #[inline]
+    pub fn from_encoded(v: u16) -> Self {
+        Self(v)
+    }
+
+    #[inline]
+    pub const fn op0(&self) -> u8 {
+        ((self.0 >> 14) & 0b11) as u8
+    }
+
+    #[inline]
+    pub const fn op1(&self) -> u8 {
+        ((self.0 >> 11) & 0b111) as u8
+    }
+
+    #[inline]
+    pub const fn crn(&self) -> u8 {
+        ((self.0 >> 7) & 0b1111) as u8
+    }
+
+    #[inline]
+    pub const fn crm(&self) -> u8 {
+        ((self.0 >> 3) & 0b1111) as u8
+    }
+
+    #[inline]
+    pub const fn op2(&self) -> u8 {
+        (self.0 & 0b111) as u8
+    }
+
+    /// Returns the system register as encoded in bits 5-20 of MRS and MSR instructions.
+    #[inline]
+    pub const fn encoded(&self) -> u16 {
+        self.0
+    }
+}
+
+impl std::fmt::Debug for AArch64SysRegId {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("AArch64SysRegId")
+            .field("Op0", &self.op0())
+            .field("Op1", &self.op1())
+            .field("CRn", &self.crn())
+            .field("CRm", &self.crm())
+            .field("Op2", &self.op2())
+            .finish()
+    }
+}
diff --git a/aarch64_sys_reg/src/tests.rs b/aarch64_sys_reg/src/tests.rs
new file mode 100644
index 000000000..4dea3ecdb
--- /dev/null
+++ b/aarch64_sys_reg/src/tests.rs
@@ -0,0 +1,604 @@
+// Copyright 2025 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#![cfg_attr(rustfmt, rustfmt_skip)]
+#![allow(non_snake_case, non_upper_case_globals)]
+
+use crate::*;
+
+#[test]
+fn sysreg_new() {
+    let sysreg = AArch64SysRegId::new(1, 2, 3, 4, 5).unwrap();
+    assert_eq!(sysreg.op0(), 1);
+    assert_eq!(sysreg.op1(), 2);
+    assert_eq!(sysreg.crn(), 3);
+    assert_eq!(sysreg.crm(), 4);
+    assert_eq!(sysreg.op2(), 5);
+    assert_eq!(sysreg.encoded(), 0x51A5);
+}
+
+#[test]
+fn sysreg_new_max() {
+    let sysreg = AArch64SysRegId::new(0b11, 0b111, 0b1111, 0b1111, 0b111).unwrap();
+    assert_eq!(sysreg.op0(), 3);
+    assert_eq!(sysreg.op1(), 7);
+    assert_eq!(sysreg.crn(), 15);
+    assert_eq!(sysreg.crm(), 15);
+    assert_eq!(sysreg.op2(), 7);
+    assert_eq!(sysreg.encoded(), 0xFFFF);
+}
+
+#[test]
+fn sysreg_new_out_of_range() {
+    AArch64SysRegId::new(4, 0, 0, 0, 0).expect_err("invalid Op0");
+    AArch64SysRegId::new(0, 8, 0, 0, 0).expect_err("invalid Op1");
+    AArch64SysRegId::new(0, 0, 16, 0, 0).expect_err("invalid CRn");
+    AArch64SysRegId::new(0, 0, 0, 16, 0).expect_err("invalid CRm");
+    AArch64SysRegId::new(0, 0, 0, 0, 8).expect_err("invalid Op2");
+}
+
+#[test]
+fn sysreg_encoding_mpidr_el1() {
+    assert_eq!(MPIDR_EL1.op0(), 3);
+    assert_eq!(MPIDR_EL1.op1(), 0);
+    assert_eq!(MPIDR_EL1.crn(), 0);
+    assert_eq!(MPIDR_EL1.crm(), 0);
+    assert_eq!(MPIDR_EL1.op2(), 5);
+    assert_eq!(MPIDR_EL1.encoded(), 0xC005);
+    assert_eq!(MPIDR_EL1, AArch64SysRegId::new(3, 0, 0, 0, 5).unwrap());
+}
+
+#[test]
+fn sysreg_encoding_cntvct_el0() {
+    assert_eq!(CNTVCT_EL0.op0(), 3);
+    assert_eq!(CNTVCT_EL0.op1(), 3);
+    assert_eq!(CNTVCT_EL0.crn(), 14);
+    assert_eq!(CNTVCT_EL0.crm(), 0);
+    assert_eq!(CNTVCT_EL0.op2(), 2);
+    assert_eq!(CNTVCT_EL0.encoded(), 0xDF02);
+    assert_eq!(CNTVCT_EL0, AArch64SysRegId::new(3, 3, 14, 0, 2).unwrap());
+}
+
+#[test]
+fn sysreg_encoding_cntv_cval_el0() {
+    assert_eq!(CNTV_CVAL_EL0.op0(), 3);
+    assert_eq!(CNTV_CVAL_EL0.op1(), 3);
+    assert_eq!(CNTV_CVAL_EL0.crn(), 14);
+    assert_eq!(CNTV_CVAL_EL0.crm(), 3);
+    assert_eq!(CNTV_CVAL_EL0.op2(), 2);
+    assert_eq!(CNTV_CVAL_EL0.encoded(), 0xDF1A);
+    assert_eq!(CNTV_CVAL_EL0, AArch64SysRegId::new(3, 3, 14, 3, 2).unwrap()
+    );
+}
+
+#[test]
+fn sysreg_debug() {
+    assert_eq!(
+        format!("{:?}", MPIDR_EL1),
+        "AArch64SysRegId { Op0: 3, Op1: 0, CRn: 0, CRm: 0, Op2: 5 }"
+    );
+}
+
+fn sysreg(op0: u8, op1: u8, crn: u8, crm: u8, op2: u8) -> AArch64SysRegId {
+    AArch64SysRegId::new(op0, op1, crn, crm, op2).expect("invalid encoding")
+}
+
+#[test]
+fn test_AMEVCNTR0n_EL0() {
+    assert_eq!(AMEVCNTR00_EL0, sysreg(0b11, 0b011, 0b1101, 0b0100, 0b000));
+    assert_eq!(AMEVCNTR01_EL0, sysreg(0b11, 0b011, 0b1101, 0b0100, 0b001));
+    assert_eq!(AMEVCNTR02_EL0, sysreg(0b11, 0b011, 0b1101, 0b0100, 0b010));
+    assert_eq!(AMEVCNTR03_EL0, sysreg(0b11, 0b011, 0b1101, 0b0100, 0b011));
+}
+
+#[test]
+fn test_AMEVCNTR1n_EL0() {
+    assert_eq!(AMEVCNTR10_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b000));
+    assert_eq!(AMEVCNTR11_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b001));
+    assert_eq!(AMEVCNTR12_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b010));
+    assert_eq!(AMEVCNTR13_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b011));
+    assert_eq!(AMEVCNTR14_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b100));
+    assert_eq!(AMEVCNTR15_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b101));
+    assert_eq!(AMEVCNTR16_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b110));
+    assert_eq!(AMEVCNTR17_EL0, sysreg(0b11, 0b011, 0b1101, 0b1100, 0b111));
+    assert_eq!(AMEVCNTR18_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b000));
+    assert_eq!(AMEVCNTR19_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b001));
+    assert_eq!(AMEVCNTR1A_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b010));
+    assert_eq!(AMEVCNTR1B_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b011));
+    assert_eq!(AMEVCNTR1C_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b100));
+    assert_eq!(AMEVCNTR1D_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b101));
+    assert_eq!(AMEVCNTR1E_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b110));
+    assert_eq!(AMEVCNTR1F_EL0, sysreg(0b11, 0b011, 0b1101, 0b1101, 0b111));
+}
+
+#[test]
+fn test_AMEVCNTVOFF0n_EL2() {
+    assert_eq!(AMEVCNTVOFF00_EL2, sysreg(0b11, 0b100, 0b1101, 0b1000, 0b000));
+    assert_eq!(AMEVCNTVOFF02_EL2, sysreg(0b11, 0b100, 0b1101, 0b1000, 0b010));
+    assert_eq!(AMEVCNTVOFF03_EL2, sysreg(0b11, 0b100, 0b1101, 0b1000, 0b011));
+}
+
+#[test]
+fn test_AMEVCNTVOFF1n_EL2() {
+    assert_eq!(AMEVCNTVOFF10_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b000));
+    assert_eq!(AMEVCNTVOFF11_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b001));
+    assert_eq!(AMEVCNTVOFF12_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b010));
+    assert_eq!(AMEVCNTVOFF13_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b011));
+    assert_eq!(AMEVCNTVOFF14_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b100));
+    assert_eq!(AMEVCNTVOFF15_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b101));
+    assert_eq!(AMEVCNTVOFF16_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b110));
+    assert_eq!(AMEVCNTVOFF17_EL2, sysreg(0b11, 0b100, 0b1101, 0b1010, 0b111));
+    assert_eq!(AMEVCNTVOFF18_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b000));
+    assert_eq!(AMEVCNTVOFF19_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b001));
+    assert_eq!(AMEVCNTVOFF1A_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b010));
+    assert_eq!(AMEVCNTVOFF1B_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b011));
+    assert_eq!(AMEVCNTVOFF1C_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b100));
+    assert_eq!(AMEVCNTVOFF1D_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b101));
+    assert_eq!(AMEVCNTVOFF1E_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b110));
+    assert_eq!(AMEVCNTVOFF1F_EL2, sysreg(0b11, 0b100, 0b1101, 0b1011, 0b111));
+}
+
+#[test]
+fn test_AMEVTYPER0n_EL0() {
+    assert_eq!(AMEVTYPER00_EL0, sysreg(0b11, 0b011, 0b1101, 0b0110, 0b000));
+    assert_eq!(AMEVTYPER01_EL0, sysreg(0b11, 0b011, 0b1101, 0b0110, 0b001));
+    assert_eq!(AMEVTYPER02_EL0, sysreg(0b11, 0b011, 0b1101, 0b0110, 0b010));
+    assert_eq!(AMEVTYPER03_EL0, sysreg(0b11, 0b011, 0b1101, 0b0110, 0b011));
+}
+
+#[test]
+fn test_AMEVTYPER1n_EL0() {
+    assert_eq!(AMEVTYPER10_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b000));
+    assert_eq!(AMEVTYPER11_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b001));
+    assert_eq!(AMEVTYPER12_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b010));
+    assert_eq!(AMEVTYPER13_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b011));
+    assert_eq!(AMEVTYPER14_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b100));
+    assert_eq!(AMEVTYPER15_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b101));
+    assert_eq!(AMEVTYPER16_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b110));
+    assert_eq!(AMEVTYPER17_EL0, sysreg(0b11, 0b011, 0b1101, 0b1110, 0b111));
+    assert_eq!(AMEVTYPER18_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b000));
+    assert_eq!(AMEVTYPER19_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b001));
+    assert_eq!(AMEVTYPER1A_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b010));
+    assert_eq!(AMEVTYPER1B_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b011));
+    assert_eq!(AMEVTYPER1C_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b100));
+    assert_eq!(AMEVTYPER1D_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b101));
+    assert_eq!(AMEVTYPER1E_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b110));
+    assert_eq!(AMEVTYPER1F_EL0, sysreg(0b11, 0b011, 0b1101, 0b1111, 0b111));
+}
+
+#[test]
+fn test_BRBINFn_EL1() {
+    assert_eq!(BRBINF0_EL1,  sysreg(0b10, 0b001, 0b1000, 0b0000, 0b000));
+    assert_eq!(BRBINF1_EL1,  sysreg(0b10, 0b001, 0b1000, 0b0001, 0b000));
+    assert_eq!(BRBINF15_EL1, sysreg(0b10, 0b001, 0b1000, 0b1111, 0b000));
+    assert_eq!(BRBINF16_EL1, sysreg(0b10, 0b001, 0b1000, 0b0000, 0b100));
+    assert_eq!(BRBINF31_EL1, sysreg(0b10, 0b001, 0b1000, 0b1111, 0b100));
+}
+
+#[test]
+fn test_BRBSRCn_EL1() {
+    assert_eq!(BRBSRC0_EL1,  sysreg(0b10, 0b001, 0b1000, 0b0000, 0b001));
+    assert_eq!(BRBSRC1_EL1,  sysreg(0b10, 0b001, 0b1000, 0b0001, 0b001));
+    assert_eq!(BRBSRC15_EL1, sysreg(0b10, 0b001, 0b1000, 0b1111, 0b001));
+    assert_eq!(BRBSRC16_EL1, sysreg(0b10, 0b001, 0b1000, 0b0000, 0b101));
+    assert_eq!(BRBSRC31_EL1, sysreg(0b10, 0b001, 0b1000, 0b1111, 0b101));
+}
+
+#[test]
+fn test_BRBTGTn_EL1() {
+    assert_eq!(BRBTGT0_EL1,  sysreg(0b10, 0b001, 0b1000, 0b0000, 0b010));
+    assert_eq!(BRBTGT1_EL1,  sysreg(0b10, 0b001, 0b1000, 0b0001, 0b010));
+    assert_eq!(BRBTGT15_EL1, sysreg(0b10, 0b001, 0b1000, 0b1111, 0b010));
+    assert_eq!(BRBTGT16_EL1, sysreg(0b10, 0b001, 0b1000, 0b0000, 0b110));
+    assert_eq!(BRBTGT31_EL1, sysreg(0b10, 0b001, 0b1000, 0b1111, 0b110));
+}
+
+#[test]
+fn test_DBGBCRn_EL1() {
+    assert_eq!(DBGBCR0_EL1, sysreg(0b10, 0b000, 0b0000, 0b0000, 0b101));
+    assert_eq!(DBGBCR1_EL1, sysreg(0b10, 0b000, 0b0000, 0b0001, 0b101));
+    assert_eq!(DBGBCR2_EL1, sysreg(0b10, 0b000, 0b0000, 0b0010, 0b101));
+    assert_eq!(DBGBCR3_EL1, sysreg(0b10, 0b000, 0b0000, 0b0011, 0b101));
+    assert_eq!(DBGBCR4_EL1, sysreg(0b10, 0b000, 0b0000, 0b0100, 0b101));
+    assert_eq!(DBGBCR5_EL1, sysreg(0b10, 0b000, 0b0000, 0b0101, 0b101));
+    assert_eq!(DBGBCR6_EL1, sysreg(0b10, 0b000, 0b0000, 0b0110, 0b101));
+    assert_eq!(DBGBCR7_EL1, sysreg(0b10, 0b000, 0b0000, 0b0111, 0b101));
+    assert_eq!(DBGBCR8_EL1, sysreg(0b10, 0b000, 0b0000, 0b1000, 0b101));
+    assert_eq!(DBGBCR9_EL1, sysreg(0b10, 0b000, 0b0000, 0b1001, 0b101));
+    assert_eq!(DBGBCRA_EL1, sysreg(0b10, 0b000, 0b0000, 0b1010, 0b101));
+    assert_eq!(DBGBCRB_EL1, sysreg(0b10, 0b000, 0b0000, 0b1011, 0b101));
+    assert_eq!(DBGBCRC_EL1, sysreg(0b10, 0b000, 0b0000, 0b1100, 0b101));
+    assert_eq!(DBGBCRD_EL1, sysreg(0b10, 0b000, 0b0000, 0b1101, 0b101));
+    assert_eq!(DBGBCRE_EL1, sysreg(0b10, 0b000, 0b0000, 0b1110, 0b101));
+    assert_eq!(DBGBCRF_EL1, sysreg(0b10, 0b000, 0b0000, 0b1111, 0b101));
+}
+
+#[test]
+fn test_DBGBVRn_EL1() {
+    assert_eq!(DBGBVR0_EL1, sysreg(0b10, 0b000, 0b0000, 0b0000, 0b100));
+    assert_eq!(DBGBVR1_EL1, sysreg(0b10, 0b000, 0b0000, 0b0001, 0b100));
+    assert_eq!(DBGBVR2_EL1, sysreg(0b10, 0b000, 0b0000, 0b0010, 0b100));
+    assert_eq!(DBGBVR3_EL1, sysreg(0b10, 0b000, 0b0000, 0b0011, 0b100));
+    assert_eq!(DBGBVR4_EL1, sysreg(0b10, 0b000, 0b0000, 0b0100, 0b100));
+    assert_eq!(DBGBVR5_EL1, sysreg(0b10, 0b000, 0b0000, 0b0101, 0b100));
+    assert_eq!(DBGBVR6_EL1, sysreg(0b10, 0b000, 0b0000, 0b0110, 0b100));
+    assert_eq!(DBGBVR7_EL1, sysreg(0b10, 0b000, 0b0000, 0b0111, 0b100));
+    assert_eq!(DBGBVR8_EL1, sysreg(0b10, 0b000, 0b0000, 0b1000, 0b100));
+    assert_eq!(DBGBVR9_EL1, sysreg(0b10, 0b000, 0b0000, 0b1001, 0b100));
+    assert_eq!(DBGBVRA_EL1, sysreg(0b10, 0b000, 0b0000, 0b1010, 0b100));
+    assert_eq!(DBGBVRB_EL1, sysreg(0b10, 0b000, 0b0000, 0b1011, 0b100));
+    assert_eq!(DBGBVRC_EL1, sysreg(0b10, 0b000, 0b0000, 0b1100, 0b100));
+    assert_eq!(DBGBVRD_EL1, sysreg(0b10, 0b000, 0b0000, 0b1101, 0b100));
+    assert_eq!(DBGBVRE_EL1, sysreg(0b10, 0b000, 0b0000, 0b1110, 0b100));
+    assert_eq!(DBGBVRF_EL1, sysreg(0b10, 0b000, 0b0000, 0b1111, 0b100));
+}
+
+#[test]
+fn test_DBGWCRn_EL1() {
+    assert_eq!(DBGWCR0_EL1, sysreg(0b10, 0b000, 0b0000, 0b0000, 0b111));
+    assert_eq!(DBGWCR1_EL1, sysreg(0b10, 0b000, 0b0000, 0b0001, 0b111));
+    assert_eq!(DBGWCR2_EL1, sysreg(0b10, 0b000, 0b0000, 0b0010, 0b111));
+    assert_eq!(DBGWCR3_EL1, sysreg(0b10, 0b000, 0b0000, 0b0011, 0b111));
+    assert_eq!(DBGWCR4_EL1, sysreg(0b10, 0b000, 0b0000, 0b0100, 0b111));
+    assert_eq!(DBGWCR5_EL1, sysreg(0b10, 0b000, 0b0000, 0b0101, 0b111));
+    assert_eq!(DBGWCR6_EL1, sysreg(0b10, 0b000, 0b0000, 0b0110, 0b111));
+    assert_eq!(DBGWCR7_EL1, sysreg(0b10, 0b000, 0b0000, 0b0111, 0b111));
+    assert_eq!(DBGWCR8_EL1, sysreg(0b10, 0b000, 0b0000, 0b1000, 0b111));
+    assert_eq!(DBGWCR9_EL1, sysreg(0b10, 0b000, 0b0000, 0b1001, 0b111));
+    assert_eq!(DBGWCRA_EL1, sysreg(0b10, 0b000, 0b0000, 0b1010, 0b111));
+    assert_eq!(DBGWCRB_EL1, sysreg(0b10, 0b000, 0b0000, 0b1011, 0b111));
+    assert_eq!(DBGWCRC_EL1, sysreg(0b10, 0b000, 0b0000, 0b1100, 0b111));
+    assert_eq!(DBGWCRD_EL1, sysreg(0b10, 0b000, 0b0000, 0b1101, 0b111));
+    assert_eq!(DBGWCRE_EL1, sysreg(0b10, 0b000, 0b0000, 0b1110, 0b111));
+    assert_eq!(DBGWCRF_EL1, sysreg(0b10, 0b000, 0b0000, 0b1111, 0b111));
+}
+
+#[test]
+fn test_DBGWVRn_EL1() {
+    assert_eq!(DBGWVR0_EL1, sysreg(0b10, 0b000, 0b0000, 0b0000, 0b110));
+    assert_eq!(DBGWVR1_EL1, sysreg(0b10, 0b000, 0b0000, 0b0001, 0b110));
+    assert_eq!(DBGWVR2_EL1, sysreg(0b10, 0b000, 0b0000, 0b0010, 0b110));
+    assert_eq!(DBGWVR3_EL1, sysreg(0b10, 0b000, 0b0000, 0b0011, 0b110));
+    assert_eq!(DBGWVR4_EL1, sysreg(0b10, 0b000, 0b0000, 0b0100, 0b110));
+    assert_eq!(DBGWVR5_EL1, sysreg(0b10, 0b000, 0b0000, 0b0101, 0b110));
+    assert_eq!(DBGWVR6_EL1, sysreg(0b10, 0b000, 0b0000, 0b0110, 0b110));
+    assert_eq!(DBGWVR7_EL1, sysreg(0b10, 0b000, 0b0000, 0b0111, 0b110));
+    assert_eq!(DBGWVR8_EL1, sysreg(0b10, 0b000, 0b0000, 0b1000, 0b110));
+    assert_eq!(DBGWVR9_EL1, sysreg(0b10, 0b000, 0b0000, 0b1001, 0b110));
+    assert_eq!(DBGWVRA_EL1, sysreg(0b10, 0b000, 0b0000, 0b1010, 0b110));
+    assert_eq!(DBGWVRB_EL1, sysreg(0b10, 0b000, 0b0000, 0b1011, 0b110));
+    assert_eq!(DBGWVRC_EL1, sysreg(0b10, 0b000, 0b0000, 0b1100, 0b110));
+    assert_eq!(DBGWVRD_EL1, sysreg(0b10, 0b000, 0b0000, 0b1101, 0b110));
+    assert_eq!(DBGWVRE_EL1, sysreg(0b10, 0b000, 0b0000, 0b1110, 0b110));
+    assert_eq!(DBGWVRF_EL1, sysreg(0b10, 0b000, 0b0000, 0b1111, 0b110));
+}
+
+#[test]
+fn test_ICC_AP0Rn_EL1() {
+    assert_eq!(ICC_AP0R0_EL1, sysreg(0b11, 0b000, 0b1100, 0b1000, 0b100));
+    assert_eq!(ICC_AP0R1_EL1, sysreg(0b11, 0b000, 0b1100, 0b1000, 0b101));
+    assert_eq!(ICC_AP0R2_EL1, sysreg(0b11, 0b000, 0b1100, 0b1000, 0b110));
+    assert_eq!(ICC_AP0R3_EL1, sysreg(0b11, 0b000, 0b1100, 0b1000, 0b111));
+}
+
+#[test]
+fn test_ICC_AP1Rn_EL1() {
+    assert_eq!(ICC_AP1R0_EL1, sysreg(0b11, 0b000, 0b1100, 0b1001, 0b000));
+    assert_eq!(ICC_AP1R1_EL1, sysreg(0b11, 0b000, 0b1100, 0b1001, 0b001));
+    assert_eq!(ICC_AP1R2_EL1, sysreg(0b11, 0b000, 0b1100, 0b1001, 0b010));
+    assert_eq!(ICC_AP1R3_EL1, sysreg(0b11, 0b000, 0b1100, 0b1001, 0b011));
+}
+
+#[test]
+fn test_ICH_AP0Rn_EL2() {
+    assert_eq!(ICH_AP0R0_EL2, sysreg(0b11, 0b100, 0b1100, 0b1000, 0b000));
+    assert_eq!(ICH_AP0R1_EL2, sysreg(0b11, 0b100, 0b1100, 0b1000, 0b001));
+    assert_eq!(ICH_AP0R2_EL2, sysreg(0b11, 0b100, 0b1100, 0b1000, 0b010));
+    assert_eq!(ICH_AP0R3_EL2, sysreg(0b11, 0b100, 0b1100, 0b1000, 0b011));
+}
+
+#[test]
+fn test_ICH_AP1Rn_EL2() {
+    assert_eq!(ICH_AP1R0_EL2, sysreg(0b11, 0b100, 0b1100, 0b1001, 0b000));
+    assert_eq!(ICH_AP1R1_EL2, sysreg(0b11, 0b100, 0b1100, 0b1001, 0b001));
+    assert_eq!(ICH_AP1R2_EL2, sysreg(0b11, 0b100, 0b1100, 0b1001, 0b010));
+    assert_eq!(ICH_AP1R3_EL2, sysreg(0b11, 0b100, 0b1100, 0b1001, 0b011));
+}
+
+#[test]
+fn test_PMEVCNTRn_EL0() {
+    assert_eq!(PMEVCNTR0_EL0, sysreg(0b11, 0b011, 0b1110, 0b1000, 0b000));
+    assert_eq!(PMEVCNTR7_EL0, sysreg(0b11, 0b011, 0b1110, 0b1000, 0b111));
+    assert_eq!(PMEVCNTR8_EL0, sysreg(0b11, 0b011, 0b1110, 0b1001, 0b000));
+    assert_eq!(PMEVCNTR15_EL0, sysreg(0b11, 0b011, 0b1110, 0b1001, 0b111));
+    assert_eq!(PMEVCNTR30_EL0, sysreg(0b11, 0b011, 0b1110, 0b1011, 0b110));
+}
+
+#[test]
+fn test_PMEVCNTSVRn_EL1() {
+    assert_eq!(PMEVCNTSVR0_EL1,  sysreg(0b10, 0b000, 0b1110, 0b1000, 0b000));
+    assert_eq!(PMEVCNTSVR7_EL1,  sysreg(0b10, 0b000, 0b1110, 0b1000, 0b111));
+    assert_eq!(PMEVCNTSVR8_EL1,  sysreg(0b10, 0b000, 0b1110, 0b1001, 0b000));
+    assert_eq!(PMEVCNTSVR15_EL1, sysreg(0b10, 0b000, 0b1110, 0b1001, 0b111));
+    assert_eq!(PMEVCNTSVR30_EL1, sysreg(0b10, 0b000, 0b1110, 0b1011, 0b110));
+}
+
+#[test]
+fn test_PMEVTYPERn_EL0() {
+    assert_eq!(PMEVTYPER0_EL0,  sysreg(0b11, 0b011, 0b1110, 0b1100, 0b000));
+    assert_eq!(PMEVTYPER7_EL0,  sysreg(0b11, 0b011, 0b1110, 0b1100, 0b111));
+    assert_eq!(PMEVTYPER8_EL0,  sysreg(0b11, 0b011, 0b1110, 0b1101, 0b000));
+    assert_eq!(PMEVTYPER15_EL0, sysreg(0b11, 0b011, 0b1110, 0b1101, 0b111));
+    assert_eq!(PMEVTYPER30_EL0, sysreg(0b11, 0b011, 0b1110, 0b1111, 0b110));
+}
+
+#[test]
+fn test_SPMCGCRn_EL1() {
+    assert_eq!(SPMCGCR0_EL1, sysreg(0b10, 0b000, 0b1001, 0b1101, 0b000));
+    assert_eq!(SPMCGCR1_EL1, sysreg(0b10, 0b000, 0b1001, 0b1101, 0b001));
+}
+
+#[test]
+fn test_SPMEVCNTRn_EL0() {
+    assert_eq!(SPMEVCNTR0_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b000));
+    assert_eq!(SPMEVCNTR1_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b001));
+    assert_eq!(SPMEVCNTR2_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b010));
+    assert_eq!(SPMEVCNTR3_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b011));
+    assert_eq!(SPMEVCNTR4_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b100));
+    assert_eq!(SPMEVCNTR5_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b101));
+    assert_eq!(SPMEVCNTR6_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b110));
+    assert_eq!(SPMEVCNTR7_EL0, sysreg(0b10, 0b011, 0b1110, 0b0000, 0b111));
+    assert_eq!(SPMEVCNTR8_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b000));
+    assert_eq!(SPMEVCNTR9_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b001));
+    assert_eq!(SPMEVCNTRA_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b010));
+    assert_eq!(SPMEVCNTRB_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b011));
+    assert_eq!(SPMEVCNTRC_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b100));
+    assert_eq!(SPMEVCNTRD_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b101));
+    assert_eq!(SPMEVCNTRE_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b110));
+    assert_eq!(SPMEVCNTRF_EL0, sysreg(0b10, 0b011, 0b1110, 0b0001, 0b111));
+}
+
+#[test]
+fn test_SPMEVFILT2Rn_EL0() {
+    assert_eq!(SPMEVFILT2R0_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b000));
+    assert_eq!(SPMEVFILT2R1_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b001));
+    assert_eq!(SPMEVFILT2R2_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b010));
+    assert_eq!(SPMEVFILT2R3_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b011));
+    assert_eq!(SPMEVFILT2R4_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b100));
+    assert_eq!(SPMEVFILT2R5_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b101));
+    assert_eq!(SPMEVFILT2R6_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b110));
+    assert_eq!(SPMEVFILT2R7_EL0, sysreg(0b10, 0b011, 0b1110, 0b0110, 0b111));
+    assert_eq!(SPMEVFILT2R8_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b000));
+    assert_eq!(SPMEVFILT2R9_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b001));
+    assert_eq!(SPMEVFILT2RA_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b010));
+    assert_eq!(SPMEVFILT2RB_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b011));
+    assert_eq!(SPMEVFILT2RC_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b100));
+    assert_eq!(SPMEVFILT2RD_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b101));
+    assert_eq!(SPMEVFILT2RE_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b110));
+    assert_eq!(SPMEVFILT2RF_EL0, sysreg(0b10, 0b011, 0b1110, 0b0111, 0b111));
+}
+
+#[test]
+fn test_SPMEVFILTRn_EL0() {
+    assert_eq!(SPMEVFILTR0_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b000));
+    assert_eq!(SPMEVFILTR1_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b001));
+    assert_eq!(SPMEVFILTR2_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b010));
+    assert_eq!(SPMEVFILTR3_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b011));
+    assert_eq!(SPMEVFILTR4_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b100));
+    assert_eq!(SPMEVFILTR5_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b101));
+    assert_eq!(SPMEVFILTR6_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b110));
+    assert_eq!(SPMEVFILTR7_EL0, sysreg(0b10, 0b011, 0b1110, 0b0100, 0b111));
+    assert_eq!(SPMEVFILTR8_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b000));
+    assert_eq!(SPMEVFILTR9_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b001));
+    assert_eq!(SPMEVFILTRA_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b010));
+    assert_eq!(SPMEVFILTRB_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b011));
+    assert_eq!(SPMEVFILTRC_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b100));
+    assert_eq!(SPMEVFILTRD_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b101));
+    assert_eq!(SPMEVFILTRE_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b110));
+    assert_eq!(SPMEVFILTRF_EL0, sysreg(0b10, 0b011, 0b1110, 0b0101, 0b111));
+}
+
+#[test]
+fn test_SPMEVTYPERn_EL0() {
+    assert_eq!(SPMEVTYPER0_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b000));
+    assert_eq!(SPMEVTYPER1_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b001));
+    assert_eq!(SPMEVTYPER2_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b010));
+    assert_eq!(SPMEVTYPER3_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b011));
+    assert_eq!(SPMEVTYPER4_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b100));
+    assert_eq!(SPMEVTYPER5_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b101));
+    assert_eq!(SPMEVTYPER6_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b110));
+    assert_eq!(SPMEVTYPER7_EL0, sysreg(0b10, 0b011, 0b1110, 0b0010, 0b111));
+    assert_eq!(SPMEVTYPER8_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b000));
+    assert_eq!(SPMEVTYPER9_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b001));
+    assert_eq!(SPMEVTYPERA_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b010));
+    assert_eq!(SPMEVTYPERB_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b011));
+    assert_eq!(SPMEVTYPERC_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b100));
+    assert_eq!(SPMEVTYPERD_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b101));
+    assert_eq!(SPMEVTYPERE_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b110));
+    assert_eq!(SPMEVTYPERF_EL0, sysreg(0b10, 0b011, 0b1110, 0b0011, 0b111));
+}
+
+#[test]
+fn test_TRCACATRn() {
+    assert_eq!(TRCACATR0, sysreg(0b10, 0b001, 0b0010, 0b0000, 0b010));
+    assert_eq!(TRCACATR1, sysreg(0b10, 0b001, 0b0010, 0b0010, 0b010));
+    assert_eq!(TRCACATR2, sysreg(0b10, 0b001, 0b0010, 0b0100, 0b010));
+    assert_eq!(TRCACATR3, sysreg(0b10, 0b001, 0b0010, 0b0110, 0b010));
+    assert_eq!(TRCACATR4, sysreg(0b10, 0b001, 0b0010, 0b1000, 0b010));
+    assert_eq!(TRCACATR5, sysreg(0b10, 0b001, 0b0010, 0b1010, 0b010));
+    assert_eq!(TRCACATR6, sysreg(0b10, 0b001, 0b0010, 0b1100, 0b010));
+    assert_eq!(TRCACATR7, sysreg(0b10, 0b001, 0b0010, 0b1110, 0b010));
+    assert_eq!(TRCACATR8, sysreg(0b10, 0b001, 0b0010, 0b0000, 0b011));
+    assert_eq!(TRCACATR9, sysreg(0b10, 0b001, 0b0010, 0b0010, 0b011));
+    assert_eq!(TRCACATRA, sysreg(0b10, 0b001, 0b0010, 0b0100, 0b011));
+    assert_eq!(TRCACATRB, sysreg(0b10, 0b001, 0b0010, 0b0110, 0b011));
+    assert_eq!(TRCACATRC, sysreg(0b10, 0b001, 0b0010, 0b1000, 0b011));
+    assert_eq!(TRCACATRD, sysreg(0b10, 0b001, 0b0010, 0b1010, 0b011));
+    assert_eq!(TRCACATRE, sysreg(0b10, 0b001, 0b0010, 0b1100, 0b011));
+    assert_eq!(TRCACATRF, sysreg(0b10, 0b001, 0b0010, 0b1110, 0b011));
+}
+
+#[test]
+fn test_TRCACVRn() {
+    assert_eq!(TRCACVR0, sysreg(0b10, 0b001, 0b0010, 0b0000, 0b000));
+    assert_eq!(TRCACVR1, sysreg(0b10, 0b001, 0b0010, 0b0010, 0b000));
+    assert_eq!(TRCACVR2, sysreg(0b10, 0b001, 0b0010, 0b0100, 0b000));
+    assert_eq!(TRCACVR3, sysreg(0b10, 0b001, 0b0010, 0b0110, 0b000));
+    assert_eq!(TRCACVR4, sysreg(0b10, 0b001, 0b0010, 0b1000, 0b000));
+    assert_eq!(TRCACVR5, sysreg(0b10, 0b001, 0b0010, 0b1010, 0b000));
+    assert_eq!(TRCACVR6, sysreg(0b10, 0b001, 0b0010, 0b1100, 0b000));
+    assert_eq!(TRCACVR7, sysreg(0b10, 0b001, 0b0010, 0b1110, 0b000));
+    assert_eq!(TRCACVR8, sysreg(0b10, 0b001, 0b0010, 0b0000, 0b001));
+    assert_eq!(TRCACVR9, sysreg(0b10, 0b001, 0b0010, 0b0010, 0b001));
+    assert_eq!(TRCACVRA, sysreg(0b10, 0b001, 0b0010, 0b0100, 0b001));
+    assert_eq!(TRCACVRB, sysreg(0b10, 0b001, 0b0010, 0b0110, 0b001));
+    assert_eq!(TRCACVRC, sysreg(0b10, 0b001, 0b0010, 0b1000, 0b001));
+    assert_eq!(TRCACVRD, sysreg(0b10, 0b001, 0b0010, 0b1010, 0b001));
+    assert_eq!(TRCACVRE, sysreg(0b10, 0b001, 0b0010, 0b1100, 0b001));
+    assert_eq!(TRCACVRF, sysreg(0b10, 0b001, 0b0010, 0b1110, 0b001));
+}
+
+#[test]
+fn test_TRCCIDCVRn() {
+    assert_eq!(TRCCIDCVR0, sysreg(0b10, 0b001, 0b0011, 0b0000, 0b000));
+    assert_eq!(TRCCIDCVR1, sysreg(0b10, 0b001, 0b0011, 0b0010, 0b000));
+    assert_eq!(TRCCIDCVR2, sysreg(0b10, 0b001, 0b0011, 0b0100, 0b000));
+    assert_eq!(TRCCIDCVR3, sysreg(0b10, 0b001, 0b0011, 0b0110, 0b000));
+    assert_eq!(TRCCIDCVR4, sysreg(0b10, 0b001, 0b0011, 0b1000, 0b000));
+    assert_eq!(TRCCIDCVR5, sysreg(0b10, 0b001, 0b0011, 0b1010, 0b000));
+    assert_eq!(TRCCIDCVR6, sysreg(0b10, 0b001, 0b0011, 0b1100, 0b000));
+    assert_eq!(TRCCIDCVR7, sysreg(0b10, 0b001, 0b0011, 0b1110, 0b000));
+}
+
+#[test]
+fn test_TRCCNTCTLRn() {
+    assert_eq!(TRCCNTCTLR0, sysreg(0b10, 0b001, 0b0000, 0b0100, 0b101));
+    assert_eq!(TRCCNTCTLR1, sysreg(0b10, 0b001, 0b0000, 0b0101, 0b101));
+    assert_eq!(TRCCNTCTLR2, sysreg(0b10, 0b001, 0b0000, 0b0110, 0b101));
+    assert_eq!(TRCCNTCTLR3, sysreg(0b10, 0b001, 0b0000, 0b0111, 0b101));
+}
+
+#[test]
+fn test_TRCCNTRLDVRn() {
+    assert_eq!(TRCCNTRLDVR0, sysreg(0b10, 0b001, 0b0000, 0b0000, 0b101));
+    assert_eq!(TRCCNTRLDVR1, sysreg(0b10, 0b001, 0b0000, 0b0001, 0b101));
+    assert_eq!(TRCCNTRLDVR2, sysreg(0b10, 0b001, 0b0000, 0b0010, 0b101));
+    assert_eq!(TRCCNTRLDVR3, sysreg(0b10, 0b001, 0b0000, 0b0011, 0b101));
+}
+
+#[test]
+fn test_TRCCNTVRn() {
+    assert_eq!(TRCCNTVR0, sysreg(0b10, 0b001, 0b0000, 0b1000, 0b101));
+    assert_eq!(TRCCNTVR1, sysreg(0b10, 0b001, 0b0000, 0b1001, 0b101));
+    assert_eq!(TRCCNTVR2, sysreg(0b10, 0b001, 0b0000, 0b1010, 0b101));
+    assert_eq!(TRCCNTVR3, sysreg(0b10, 0b001, 0b0000, 0b1011, 0b101));
+}
+
+#[test]
+fn test_TRCEXTINSELRn() {
+    assert_eq!(TRCEXTINSELR0, sysreg(0b10, 0b001, 0b0000, 0b1000, 0b100));
+    assert_eq!(TRCEXTINSELR1, sysreg(0b10, 0b001, 0b0000, 0b1001, 0b100));
+    assert_eq!(TRCEXTINSELR2, sysreg(0b10, 0b001, 0b0000, 0b1010, 0b100));
+    assert_eq!(TRCEXTINSELR3, sysreg(0b10, 0b001, 0b0000, 0b1011, 0b100));
+}
+
+#[test]
+fn test_TRCIMSPECn() {
+    assert_eq!(TRCIMSPEC1, sysreg(0b10, 0b001, 0b0000, 0b0001, 0b111));
+    assert_eq!(TRCIMSPEC2, sysreg(0b10, 0b001, 0b0000, 0b0010, 0b111));
+    assert_eq!(TRCIMSPEC3, sysreg(0b10, 0b001, 0b0000, 0b0011, 0b111));
+    assert_eq!(TRCIMSPEC4, sysreg(0b10, 0b001, 0b0000, 0b0100, 0b111));
+    assert_eq!(TRCIMSPEC5, sysreg(0b10, 0b001, 0b0000, 0b0101, 0b111));
+    assert_eq!(TRCIMSPEC6, sysreg(0b10, 0b001, 0b0000, 0b0110, 0b111));
+    assert_eq!(TRCIMSPEC7, sysreg(0b10, 0b001, 0b0000, 0b0111, 0b111));
+}
+
+#[test]
+fn test_TRCRSCTLRn() {
+    assert_eq!(TRCRSCTLR2,  sysreg(0b10, 0b001, 0b0001, 0b0010, 0b000));
+    assert_eq!(TRCRSCTLR3,  sysreg(0b10, 0b001, 0b0001, 0b0011, 0b000));
+    assert_eq!(TRCRSCTLR4,  sysreg(0b10, 0b001, 0b0001, 0b0100, 0b000));
+    assert_eq!(TRCRSCTLR5,  sysreg(0b10, 0b001, 0b0001, 0b0101, 0b000));
+    assert_eq!(TRCRSCTLR6,  sysreg(0b10, 0b001, 0b0001, 0b0110, 0b000));
+    assert_eq!(TRCRSCTLR7,  sysreg(0b10, 0b001, 0b0001, 0b0111, 0b000));
+    assert_eq!(TRCRSCTLR8,  sysreg(0b10, 0b001, 0b0001, 0b1000, 0b000));
+    assert_eq!(TRCRSCTLR9,  sysreg(0b10, 0b001, 0b0001, 0b1001, 0b000));
+    assert_eq!(TRCRSCTLR10, sysreg(0b10, 0b001, 0b0001, 0b1010, 0b000));
+    assert_eq!(TRCRSCTLR11, sysreg(0b10, 0b001, 0b0001, 0b1011, 0b000));
+    assert_eq!(TRCRSCTLR12, sysreg(0b10, 0b001, 0b0001, 0b1100, 0b000));
+    assert_eq!(TRCRSCTLR13, sysreg(0b10, 0b001, 0b0001, 0b1101, 0b000));
+    assert_eq!(TRCRSCTLR14, sysreg(0b10, 0b001, 0b0001, 0b1110, 0b000));
+    assert_eq!(TRCRSCTLR15, sysreg(0b10, 0b001, 0b0001, 0b1111, 0b000));
+    assert_eq!(TRCRSCTLR16, sysreg(0b10, 0b001, 0b0001, 0b0000, 0b001));
+    assert_eq!(TRCRSCTLR17, sysreg(0b10, 0b001, 0b0001, 0b0001, 0b001));
+    assert_eq!(TRCRSCTLR18, sysreg(0b10, 0b001, 0b0001, 0b0010, 0b001));
+    assert_eq!(TRCRSCTLR19, sysreg(0b10, 0b001, 0b0001, 0b0011, 0b001));
+    assert_eq!(TRCRSCTLR20, sysreg(0b10, 0b001, 0b0001, 0b0100, 0b001));
+    assert_eq!(TRCRSCTLR21, sysreg(0b10, 0b001, 0b0001, 0b0101, 0b001));
+    assert_eq!(TRCRSCTLR22, sysreg(0b10, 0b001, 0b0001, 0b0110, 0b001));
+    assert_eq!(TRCRSCTLR23, sysreg(0b10, 0b001, 0b0001, 0b0111, 0b001));
+    assert_eq!(TRCRSCTLR24, sysreg(0b10, 0b001, 0b0001, 0b1000, 0b001));
+    assert_eq!(TRCRSCTLR25, sysreg(0b10, 0b001, 0b0001, 0b1001, 0b001));
+    assert_eq!(TRCRSCTLR26, sysreg(0b10, 0b001, 0b0001, 0b1010, 0b001));
+    assert_eq!(TRCRSCTLR27, sysreg(0b10, 0b001, 0b0001, 0b1011, 0b001));
+    assert_eq!(TRCRSCTLR28, sysreg(0b10, 0b001, 0b0001, 0b1100, 0b001));
+    assert_eq!(TRCRSCTLR29, sysreg(0b10, 0b001, 0b0001, 0b1101, 0b001));
+    assert_eq!(TRCRSCTLR30, sysreg(0b10, 0b001, 0b0001, 0b1110, 0b001));
+    assert_eq!(TRCRSCTLR31, sysreg(0b10, 0b001, 0b0001, 0b1111, 0b001));
+}
+
+#[test]
+fn test_TRCSEQEVRn() {
+    assert_eq!(TRCSEQEVR0, sysreg(0b10, 0b001, 0b0000, 0b0000, 0b100));
+    assert_eq!(TRCSEQEVR1, sysreg(0b10, 0b001, 0b0000, 0b0001, 0b100));
+    assert_eq!(TRCSEQEVR2, sysreg(0b10, 0b001, 0b0000, 0b0010, 0b100));
+}
+
+#[test]
+fn test_TRCSSCCRn() {
+    assert_eq!(TRCSSCCR0, sysreg(0b10, 0b001, 0b0001, 0b0000, 0b010));
+    assert_eq!(TRCSSCCR1, sysreg(0b10, 0b001, 0b0001, 0b0001, 0b010));
+    assert_eq!(TRCSSCCR2, sysreg(0b10, 0b001, 0b0001, 0b0010, 0b010));
+    assert_eq!(TRCSSCCR3, sysreg(0b10, 0b001, 0b0001, 0b0011, 0b010));
+    assert_eq!(TRCSSCCR4, sysreg(0b10, 0b001, 0b0001, 0b0100, 0b010));
+    assert_eq!(TRCSSCCR5, sysreg(0b10, 0b001, 0b0001, 0b0101, 0b010));
+    assert_eq!(TRCSSCCR6, sysreg(0b10, 0b001, 0b0001, 0b0110, 0b010));
+    assert_eq!(TRCSSCCR7, sysreg(0b10, 0b001, 0b0001, 0b0111, 0b010));
+}
+
+#[test]
+fn test_TRCSSCSRn() {
+    assert_eq!(TRCSSCSR0, sysreg(0b10, 0b001, 0b0001, 0b1000, 0b010));
+    assert_eq!(TRCSSCSR1, sysreg(0b10, 0b001, 0b0001, 0b1001, 0b010));
+    assert_eq!(TRCSSCSR2, sysreg(0b10, 0b001, 0b0001, 0b1010, 0b010));
+    assert_eq!(TRCSSCSR3, sysreg(0b10, 0b001, 0b0001, 0b1011, 0b010));
+    assert_eq!(TRCSSCSR4, sysreg(0b10, 0b001, 0b0001, 0b1100, 0b010));
+    assert_eq!(TRCSSCSR5, sysreg(0b10, 0b001, 0b0001, 0b1101, 0b010));
+    assert_eq!(TRCSSCSR6, sysreg(0b10, 0b001, 0b0001, 0b1110, 0b010));
+    assert_eq!(TRCSSCSR7, sysreg(0b10, 0b001, 0b0001, 0b1111, 0b010));
+}
+
+#[test]
+fn test_TRCSSPCICRn() {
+    assert_eq!(TRCSSPCICR0, sysreg(0b10, 0b001, 0b0001, 0b0000, 0b011));
+    assert_eq!(TRCSSPCICR1, sysreg(0b10, 0b001, 0b0001, 0b0001, 0b011));
+    assert_eq!(TRCSSPCICR2, sysreg(0b10, 0b001, 0b0001, 0b0010, 0b011));
+    assert_eq!(TRCSSPCICR3, sysreg(0b10, 0b001, 0b0001, 0b0011, 0b011));
+    assert_eq!(TRCSSPCICR4, sysreg(0b10, 0b001, 0b0001, 0b0100, 0b011));
+    assert_eq!(TRCSSPCICR5, sysreg(0b10, 0b001, 0b0001, 0b0101, 0b011));
+    assert_eq!(TRCSSPCICR6, sysreg(0b10, 0b001, 0b0001, 0b0110, 0b011));
+    assert_eq!(TRCSSPCICR7, sysreg(0b10, 0b001, 0b0001, 0b0111, 0b011));
+}
+
+#[test]
+fn test_TRCVMIDCVRn() {
+    assert_eq!(TRCVMIDCVR0, sysreg(0b10, 0b001, 0b0011, 0b0000, 0b001));
+    assert_eq!(TRCVMIDCVR1, sysreg(0b10, 0b001, 0b0011, 0b0010, 0b001));
+    assert_eq!(TRCVMIDCVR2, sysreg(0b10, 0b001, 0b0011, 0b0100, 0b001));
+    assert_eq!(TRCVMIDCVR3, sysreg(0b10, 0b001, 0b0011, 0b0110, 0b001));
+    assert_eq!(TRCVMIDCVR4, sysreg(0b10, 0b001, 0b0011, 0b1000, 0b001));
+    assert_eq!(TRCVMIDCVR5, sysreg(0b10, 0b001, 0b0011, 0b1010, 0b001));
+    assert_eq!(TRCVMIDCVR6, sysreg(0b10, 0b001, 0b0011, 0b1100, 0b001));
+    assert_eq!(TRCVMIDCVR7, sysreg(0b10, 0b001, 0b0011, 0b1110, 0b001));
+}
diff --git a/android-fork-stats.sh b/android-fork-stats.sh
index ce57c1e26..073cbcd00 100755
--- a/android-fork-stats.sh
+++ b/android-fork-stats.sh
@@ -4,7 +4,7 @@
 function infocho() { printf "\033[100m$@\033[0m\n"; }
 infocho "============================"
 infocho "OUR VERSION OF CROSVM IS THIS MUCH FORKED:"
-UPSTREAM_COMMIT=$(git merge-base HEAD aosp/upstream-main)
+UPSTREAM_COMMIT=$(git merge-base HEAD goog/upstream-main)
 
 git diff HEAD..$UPSTREAM_COMMIT --stat -- $(find . -name "*.rs" -o -name "*.toml")
 
diff --git a/android-merge-1-setup.sh b/android-merge-1-setup.sh
index 2c5adc2f6..279b0c58f 100755
--- a/android-merge-1-setup.sh
+++ b/android-merge-1-setup.sh
@@ -55,7 +55,7 @@ rustup update
 if [ "$sync" = "sync" ]
 then
   repo sync -c -j96
-  git fetch aosp upstream-main
+  git fetch goog upstream-main
 fi
 
 source $ANDROID_BUILD_TOP/build/envsetup.sh
@@ -66,7 +66,7 @@ if [ ! "$branch" = "branch" ];
     repo start merge;
 fi
 
-git merge --log aosp/upstream-main --no-edit
+git merge --log goog/upstream-main --no-edit
 OLD_MSG=$(git log --format=%B -n1)
 git commit --amend -m "$OLD_MSG
 Bug: $bug_number
diff --git a/android-merge-2-cargo-embargo.sh b/android-merge-2-cargo-embargo.sh
index bd2819fc5..b4c5102a4 100755
--- a/android-merge-2-cargo-embargo.sh
+++ b/android-merge-2-cargo-embargo.sh
@@ -49,7 +49,7 @@ done
 #
 # TODO: Consider using android's prebuilt rust binaries. Currently doesn't work
 # because they try to incorrectly use system clang and llvm.
-RUST_TOOLCHAIN="1.77.2"
+RUST_TOOLCHAIN="1.81.0"
 rustup which --toolchain $RUST_TOOLCHAIN cargo || \
   rustup toolchain install $RUST_TOOLCHAIN
 CARGO_BIN="$(dirname $(rustup which --toolchain $RUST_TOOLCHAIN cargo))"
diff --git a/android_audio/Cargo.toml b/android_audio/Cargo.toml
index 76b0e4366..376349a86 100644
--- a/android_audio/Cargo.toml
+++ b/android_audio/Cargo.toml
@@ -11,7 +11,7 @@ libaaudio_stub = []
 path = "src/lib.rs"
 
 [dependencies]
-audio_streams = { path = "../common/audio_streams"}
+audio_streams = { workspace = true }
 async-trait = "0.1.36"
-base = { path = "../base" }
-thiserror = "1.0.20"
+base = { workspace = true }
+thiserror = { workspace = true }
diff --git a/arch/Cargo.toml b/arch/Cargo.toml
index 376093990..bd99de135 100644
--- a/arch/Cargo.toml
+++ b/arch/Cargo.toml
@@ -12,39 +12,39 @@ seccomp_trace = []
 swap = ["swap/enable"]
 
 [dependencies]
-acpi_tables = { path = "../acpi_tables" }
-anyhow = "1"
-base = { path = "../base" }
-cfg-if = "1.0.0"
-cros_fdt = { path = "../cros_fdt" }
-cros_tracing = { path = "../cros_tracing" }
-devices = { path = "../devices" }
-gdbstub = { version = "0.7.0", optional = true }
-gdbstub_arch = { version = "0.3.0", optional = true }
-hypervisor = { path = "../hypervisor" }
-jail = { path = "../jail" }
-kernel_cmdline = { path = "../kernel_cmdline" }
-libc = "0.2"
-metrics = { path = "../metrics" }
-resources = { path = "../resources" }
-remain = "0.2"
-serde = { version = "1", features = [ "derive"] }
-serde_json = { version = "1" }
-serde_keyvalue = { path = "../serde_keyvalue", features = ["argh_derive"] }
-swap = { path = "../swap" }
-sync = { path = "../common/sync" }
-thiserror = "1.0.20"
+acpi_tables = { workspace = true }
+anyhow = { workspace = true }
+base = { workspace = true }
+cfg-if = { workspace = true }
+cros_fdt = { workspace = true }
+cros_tracing = { workspace = true }
+devices = { workspace = true }
+gdbstub = { workspace = true, optional = true }
+gdbstub_arch = { workspace = true, optional = true }
+hypervisor = { workspace = true }
+jail = { workspace = true }
+kernel_cmdline = { workspace = true }
+libc = { workspace = true }
+metrics = { workspace = true }
+resources = { workspace = true }
+remain = { workspace = true }
+serde = { workspace = true, features = [ "derive"] }
+serde_json = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
+swap = { workspace = true }
+sync = { workspace = true }
+thiserror = { workspace = true }
 uuid = { version = "1", features = ["v4", "serde"] }
-vm_control = { path = "../vm_control" }
-vm_memory = { path = "../vm_memory" }
+vm_control = { workspace = true }
+vm_memory = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-minijail = "*" # provided by ebuild
-power_monitor = { path = "../power_monitor" }
+minijail = "*"
+power_monitor = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
 winapi = "0.3"
 
 [dev-dependencies]
-serde_json = "1"
+serde_json = { workspace = true }
 tempfile = "3"
diff --git a/arch/src/fdt.rs b/arch/src/fdt.rs
index db2afc201..b0c8d6fe0 100644
--- a/arch/src/fdt.rs
+++ b/arch/src/fdt.rs
@@ -15,6 +15,10 @@ use cros_fdt::Path;
 use cros_fdt::Result;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use devices::IommuDevType;
+use vm_memory::GuestAddress;
+use vm_memory::GuestMemory;
+use vm_memory::MemoryRegionInformation;
+use vm_memory::MemoryRegionPurpose;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use crate::sys::linux::PlatformBusResources;
@@ -163,3 +167,116 @@ pub fn apply_device_tree_overlays(
         )))
     }
 }
+
+/// Create a "/memory" node describing all guest memory regions.
+pub fn create_memory_node(fdt: &mut Fdt, guest_mem: &GuestMemory) -> Result<()> {
+    let mut mem_reg_prop = Vec::new();
+    let mut previous_memory_region_end = None;
+    let mut regions: Vec<MemoryRegionInformation> = guest_mem
+        .regions()
+        .filter(|region| match region.options.purpose {
+            MemoryRegionPurpose::Bios => false,
+            MemoryRegionPurpose::GuestMemoryRegion => true,
+            MemoryRegionPurpose::ProtectedFirmwareRegion => false,
+            MemoryRegionPurpose::ReservedMemory => true,
+            #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
+            MemoryRegionPurpose::StaticSwiotlbRegion => true,
+        })
+        .collect();
+    regions.sort_by(|a, b| a.guest_addr.cmp(&b.guest_addr));
+    for region in regions {
+        // Merge with the previous region if possible.
+        if let Some(previous_end) = previous_memory_region_end {
+            if region.guest_addr == previous_end {
+                *mem_reg_prop.last_mut().unwrap() += region.size as u64;
+                previous_memory_region_end =
+                    Some(previous_end.checked_add(region.size as u64).unwrap());
+                continue;
+            }
+            assert!(region.guest_addr > previous_end, "Memory regions overlap");
+        }
+
+        mem_reg_prop.push(region.guest_addr.offset());
+        mem_reg_prop.push(region.size as u64);
+        previous_memory_region_end =
+            Some(region.guest_addr.checked_add(region.size as u64).unwrap());
+    }
+
+    let memory_node = fdt.root_mut().subnode_mut("memory")?;
+    memory_node.set_prop("device_type", "memory")?;
+    memory_node.set_prop("reg", mem_reg_prop)?;
+    Ok(())
+}
+
+pub struct ReservedMemoryRegion<'a> {
+    pub name: &'a str,
+    pub address: Option<GuestAddress>,
+    pub size: u64,
+    pub phandle: Option<u32>,
+    pub compatible: Option<&'a str>,
+    pub alignment: Option<u64>,
+    pub no_map: bool,
+}
+
+/// Create a "/reserved-memory" node with child nodes for `reserved_regions`.
+pub fn create_reserved_memory_node(
+    fdt: &mut Fdt,
+    reserved_regions: &[ReservedMemoryRegion],
+) -> Result<()> {
+    if reserved_regions.is_empty() {
+        return Ok(());
+    }
+
+    let resv_memory_node = fdt.root_mut().subnode_mut("reserved-memory")?;
+    resv_memory_node.set_prop("#address-cells", 0x2u32)?;
+    resv_memory_node.set_prop("#size-cells", 0x2u32)?;
+    resv_memory_node.set_prop("ranges", ())?;
+
+    for region in reserved_regions {
+        let child_node = if let Some(resv_addr) = region.address {
+            let node =
+                resv_memory_node.subnode_mut(&format!("{}@{:x}", region.name, resv_addr.0))?;
+            node.set_prop("reg", &[resv_addr.0, region.size])?;
+            node
+        } else {
+            let node = resv_memory_node.subnode_mut(region.name)?;
+            node.set_prop("size", region.size)?;
+            node
+        };
+
+        if let Some(phandle) = region.phandle {
+            child_node.set_prop("phandle", phandle)?;
+        }
+        if let Some(compatible) = region.compatible {
+            child_node.set_prop("compatible", compatible)?;
+        }
+        if let Some(alignment) = region.alignment {
+            child_node.set_prop("alignment", alignment)?;
+        }
+        if region.no_map {
+            child_node.set_prop("no-map", ())?;
+        }
+    }
+
+    Ok(())
+}
+
+/// Collect a list of `ReservedMemoryRegion`s for any `MemoryRegionPurpose::ReservedMemory` regions
+/// in `GuestMemory`.
+pub fn reserved_memory_regions_from_guest_mem(
+    guest_mem: &GuestMemory,
+) -> Vec<ReservedMemoryRegion> {
+    guest_mem
+        .regions()
+        .filter(|region| region.options.purpose == MemoryRegionPurpose::ReservedMemory)
+        .map(|region| ReservedMemoryRegion {
+            address: Some(region.guest_addr),
+            size: region.size.try_into().unwrap(),
+            name: "reserved",
+            phandle: None,
+            compatible: None,
+            alignment: None,
+            no_map: true,
+        })
+        .collect()
+}
diff --git a/arch/src/lib.rs b/arch/src/lib.rs
index 0d7b85eb1..a38e03565 100644
--- a/arch/src/lib.rs
+++ b/arch/src/lib.rs
@@ -181,6 +181,18 @@ pub struct SveConfig {
     pub auto: bool,
 }
 
+/// FFA config
+// For now this is limited to android, will be opened to other aarch64 based pVMs after
+// corresponding kernel APIs are upstreamed.
+#[cfg(all(target_os = "android", target_arch = "aarch64"))]
+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Deserialize, Serialize, FromKeyValues)]
+#[serde(deny_unknown_fields, rename_all = "kebab-case")]
+pub struct FfaConfig {
+    /// Just enable FFA, don't care about the negotiated version.
+    #[serde(default)]
+    pub auto: bool,
+}
+
 fn parse_cpu_range(s: &str, cpuset: &mut Vec<usize>) -> Result<(), String> {
     fn parse_cpu(s: &str) -> Result<usize, String> {
         s.parse().map_err(|_| {
diff --git a/audio_streams_conformance_test/Cargo.toml b/audio_streams_conformance_test/Cargo.toml
index d8d067d7f..3d81ef7e9 100644
--- a/audio_streams_conformance_test/Cargo.toml
+++ b/audio_streams_conformance_test/Cargo.toml
@@ -9,12 +9,12 @@ audio_cras = ["dep:libcras"]
 chromeos = ["audio_cras"]
 
 [dependencies]
-argh = "0.1"
-audio_streams = { path = "../common/audio_streams" }
-cfg-if = "1.0.0"
-cros_async = { path = "../cros_async" }
+argh = { workspace = true }
+audio_streams = { workspace = true }
+cfg-if = { workspace = true }
+cros_async = { workspace = true }
 libcras = { version = "*", optional = true }
-remain = "0.2"
-serde = { version = "1.0", features = ["derive"] }
-serde_json = "1"
-thiserror = "1.0.20"
+remain = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+serde_json = { workspace = true }
+thiserror = { workspace = true }
diff --git a/audio_util/Cargo.toml b/audio_util/Cargo.toml
index 9b2f897b6..f4288ab39 100644
--- a/audio_util/Cargo.toml
+++ b/audio_util/Cargo.toml
@@ -5,7 +5,7 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-audio_streams = "*"
+audio_streams = { workspace = true }
 async-trait = "0.1.36"
-base = { path = "../base" }
-thiserror = "1.0.20"
+base = { workspace = true }
+thiserror = { workspace = true }
diff --git a/base/Android.bp b/base/Android.bp
index 72a7293b2..4aa2a29e9 100644
--- a/base/Android.bp
+++ b/base/Android.bp
@@ -33,7 +33,6 @@ rust_test {
         "libenv_logger",
         "liblibc",
         "liblog_rust",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsmallvec",
@@ -90,7 +89,6 @@ rust_test {
         "libenv_logger",
         "liblibc",
         "liblog_rust",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsmallvec",
@@ -128,7 +126,6 @@ rust_test {
         "libenv_logger",
         "liblibc",
         "liblog_rust",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsmallvec",
@@ -166,7 +163,6 @@ rust_test {
         "libenv_logger",
         "liblibc",
         "liblog_rust",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsmallvec",
@@ -217,7 +213,6 @@ rust_library {
         "libenv_logger",
         "liblibc",
         "liblog_rust",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsmallvec",
diff --git a/base/Cargo.toml b/base/Cargo.toml
index c1c3076e4..29434cfc8 100644
--- a/base/Cargo.toml
+++ b/base/Cargo.toml
@@ -9,34 +9,33 @@ proto_tube = ["protobuf"]
 seccomp_trace = []
 
 [dependencies]
-audio_streams = { path = "../common/audio_streams" } # provided by ebuild
+audio_streams = { workspace = true }
 base_event_token_derive = { path = "base_event_token_derive" }
-sync = { path = "../common/sync" } # provided by ebuild
+sync = { workspace = true }
 
-cfg-if = "1"
+cfg-if = { workspace = true }
 chrono = { version = "0.4.34", features = ["now"], default-features = false }
 env_logger = { version = "0.9.0", default-features = false }
-libc = "0.2"
+libc = { workspace = true }
 log = "0.4"
-once_cell = "1.7"
 protobuf = { version = "3.2", optional = true }
-remain = "0.2"
-serde = { version = "1", features = [ "derive" ] }
-serde_json = "1"
+remain = { workspace = true }
+serde = { workspace = true, features = [ "derive" ] }
+serde_json = { workspace = true }
 smallvec = "1.6.1"
-thiserror = "1.0.20"
+thiserror = { workspace = true }
 uuid = { version = "1", features = ["v4"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [dev-dependencies]
 # ANDROID: uncomment when protos is fixed to work with cargo.
-# protos = { path = "../protos", features = ["composite-disk"] }
+# protos = { worksapce = true, features = ["composite-disk"] }
 tempfile = "3"
 
 [target.'cfg(windows)'.dependencies]
 futures = { version = "0.3" }
 protobuf = "3.2"
-rand = "0.8"
+rand = { workspace = true }
 winapi = "0.3"
 win_util = { path = "../win_util"}
 
diff --git a/base/src/sys/linux/android/syslog.rs b/base/src/sys/linux/android/syslog.rs
index 6db5e7923..e565b8162 100644
--- a/base/src/sys/linux/android/syslog.rs
+++ b/base/src/sys/linux/android/syslog.rs
@@ -29,7 +29,7 @@ impl Syslog for PlatformSyslog {
     fn new(
         proc_name: String,
         _facility: Facility,
-    ) -> Result<(Option<Box<dyn Log + Send>>, Option<RawDescriptor>), Error> {
+    ) -> Result<(Option<Box<dyn Log + Send>>, Option<RawDescriptor>), &'static Error> {
         Ok((Some(Box::new(Self { proc_name })), None))
     }
 }
@@ -83,10 +83,7 @@ fn android_log(
     // SAFETY: `tag` is guaranteed to be valid for duration of the call
     if unsafe { __android_log_is_loggable(priority as i32, tag.as_ptr(), default_pri as i32) } != 0
     {
-        let c_file_name = match file {
-            Some(file_name) => CString::new(file_name)?.as_ptr(),
-            None => std::ptr::null(),
-        };
+        let file = file.map(CString::new).transpose()?;
         let line = line.unwrap_or(0);
         let message = CString::new(message)?;
         let mut log_message = __android_log_message {
@@ -94,7 +91,7 @@ fn android_log(
             buffer_id: buffer_id as i32,
             priority: priority as i32,
             tag: tag.as_ptr(),
-            file: c_file_name,
+            file: file.map_or(std::ptr::null(), |v| v.as_ptr()),
             line,
             message: message.as_ptr(),
         };
diff --git a/base/src/sys/linux/linux/syslog.rs b/base/src/sys/linux/linux/syslog.rs
index a6b9b840b..09652e0ce 100644
--- a/base/src/sys/linux/linux/syslog.rs
+++ b/base/src/sys/linux/linux/syslog.rs
@@ -11,6 +11,7 @@ use std::os::unix::io::AsRawFd;
 use std::os::unix::io::FromRawFd;
 use std::os::unix::net::UnixDatagram;
 use std::ptr::null;
+use std::sync::OnceLock;
 
 use libc::closelog;
 use libc::fcntl;
@@ -24,7 +25,6 @@ use libc::LOG_NDELAY;
 use libc::LOG_PERROR;
 use libc::LOG_PID;
 use libc::LOG_USER;
-use once_cell::sync::OnceCell;
 
 use super::super::getpid;
 use crate::syslog::Error;
@@ -35,7 +35,7 @@ use crate::RawDescriptor;
 
 /// Global syslog socket derived from the fd opened by `openlog()`.
 /// This is initialized in `PlatformSyslog::new()`.
-static SYSLOG_SOCKET: OnceCell<UnixDatagram> = OnceCell::new();
+static SYSLOG_SOCKET: OnceLock<Result<UnixDatagram, Error>> = OnceLock::new();
 
 pub struct PlatformSyslog {}
 
@@ -43,7 +43,7 @@ struct SyslogSocket {}
 
 impl Write for SyslogSocket {
     fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
-        if let Some(socket) = SYSLOG_SOCKET.get() {
+        if let Some(Ok(socket)) = SYSLOG_SOCKET.get() {
             // If `send()` fails, there is nothing we can do about it, so just ignore the result.
             let _ = socket.send(buf);
         }
@@ -61,13 +61,13 @@ impl Syslog for PlatformSyslog {
     fn new(
         proc_name: String,
         facility: Facility,
-    ) -> Result<(Option<Box<dyn log::Log + Send>>, Option<RawDescriptor>), Error> {
+    ) -> Result<(Option<Box<dyn log::Log + Send>>, Option<RawDescriptor>), &'static Error> {
         // Calling openlog_and_get_socket() more than once will cause the previous syslogger FD to
-        // be closed, invalidating the log::Log object in an unsafe manner. The OnceCell
-        // get_or_try_init() ensures we only call it once.
+        // be closed, invalidating the log::Log object in an unsafe manner. The OnceLock
+        // get_or_init() ensures we only call it once.
         //
         // b/238923791 is tracking fixing this problem.
-        let socket = SYSLOG_SOCKET.get_or_try_init(openlog_and_get_socket)?;
+        let socket = SYSLOG_SOCKET.get_or_init(openlog_and_get_socket).as_ref()?;
         let mut builder = env_logger::Builder::new();
 
         // Everything is filtered layer above
diff --git a/base/src/sys/linux/mmap.rs b/base/src/sys/linux/mmap.rs
index 6285f5467..35e269246 100644
--- a/base/src/sys/linux/mmap.rs
+++ b/base/src/sys/linux/mmap.rs
@@ -478,6 +478,28 @@ impl MemoryMapping {
         }
     }
 
+    /// Uses madvise to tell the kernel to remove the specified range. Works even on locked ranges.
+    pub fn dontneed_locked_range(&self, mem_offset: usize, count: usize) -> Result<()> {
+        self.range_end(mem_offset, count)
+            .map_err(|_| Error::InvalidRange(mem_offset, count, self.size()))?;
+        // SAFETY: Safe because all the args to madvise are valid and the return
+        // value is checked.
+        let ret = unsafe {
+            // madvising away the region is the same as the guest changing it.
+            // Next time it is read, it may return zero pages.
+            libc::madvise(
+                (self.addr as usize + mem_offset) as *mut _,
+                count,
+                libc::MADV_DONTNEED_LOCKED,
+            )
+        };
+        if ret < 0 {
+            Err(Error::SystemCallFailed(super::Error::last()))
+        } else {
+            Ok(())
+        }
+    }
+
     /// Tell the kernel to readahead the range.
     ///
     /// This does not block the thread by I/O wait from reading the backed file. This does not
@@ -872,6 +894,8 @@ impl CrateMemoryMapping {
 pub trait MemoryMappingUnix {
     /// Remove the specified range from the mapping.
     fn remove_range(&self, mem_offset: usize, count: usize) -> Result<()>;
+    /// Remove the specified range from the mapping. Works even on locked ranges.
+    fn dontneed_locked_range(&self, mem_offset: usize, count: usize) -> Result<()>;
     /// Tell the kernel to readahead the range.
     fn async_prefetch(&self, mem_offset: usize, count: usize) -> Result<()>;
     /// Tell the kernel to drop the page cache.
@@ -888,6 +912,9 @@ impl MemoryMappingUnix for CrateMemoryMapping {
     fn remove_range(&self, mem_offset: usize, count: usize) -> Result<()> {
         self.mapping.remove_range(mem_offset, count)
     }
+    fn dontneed_locked_range(&self, mem_offset: usize, count: usize) -> Result<()> {
+        self.mapping.dontneed_locked_range(mem_offset, count)
+    }
     fn async_prefetch(&self, mem_offset: usize, count: usize) -> Result<()> {
         self.mapping.async_prefetch(mem_offset, count)
     }
diff --git a/base/src/sys/linux/mod.rs b/base/src/sys/linux/mod.rs
index 77463a9a9..50d230f2e 100644
--- a/base/src/sys/linux/mod.rs
+++ b/base/src/sys/linux/mod.rs
@@ -56,6 +56,7 @@ use std::path::Path;
 use std::path::PathBuf;
 use std::process::ExitStatus;
 use std::ptr;
+use std::sync::OnceLock;
 use std::time::Duration;
 
 pub use acpi_event::*;
@@ -87,7 +88,6 @@ pub(in crate::sys) use net::sockaddr_un;
 pub(in crate::sys) use net::sockaddrv4_to_lib_c;
 pub(in crate::sys) use net::sockaddrv6_to_lib_c;
 pub use netlink::*;
-use once_cell::sync::OnceCell;
 pub use poll::EventContext;
 pub use priority::*;
 pub use sched::*;
@@ -665,20 +665,20 @@ fn parse_sysfs_cpu_info(cpu_id: usize, property: &str) -> Result<u32> {
 
 /// Returns the capacity (measure of performance) of a given logical core.
 pub fn logical_core_capacity(cpu_id: usize) -> Result<u32> {
-    static CPU_MAX_FREQS: OnceCell<Vec<u32>> = OnceCell::new();
+    static CPU_MAX_FREQS: OnceLock<Option<Vec<u32>>> = OnceLock::new();
 
     let cpu_capacity = parse_sysfs_cpu_info(cpu_id, "cpu_capacity")?;
 
     // Collect and cache the maximum frequencies of all cores. We need to know
     // the largest maximum frequency between all cores to reverse normalization,
     // so collect all the values once on the first call to this function.
-    let cpu_max_freqs = CPU_MAX_FREQS.get_or_try_init(|| {
-        (0..number_of_logical_cores()?)
-            .map(logical_core_max_freq_khz)
+    let cpu_max_freqs = CPU_MAX_FREQS.get_or_init(|| {
+        (0..number_of_logical_cores().ok()?)
+            .map(|cpu_id| logical_core_max_freq_khz(cpu_id).ok())
             .collect()
     });
 
-    if let Ok(cpu_max_freqs) = cpu_max_freqs {
+    if let Some(cpu_max_freqs) = cpu_max_freqs {
         let largest_max_freq = *cpu_max_freqs.iter().max().ok_or(Error::new(EINVAL))?;
         let cpu_max_freq = *cpu_max_freqs.get(cpu_id).ok_or(Error::new(EINVAL))?;
         let normalized_cpu_capacity = (u64::from(cpu_capacity) * u64::from(largest_max_freq))
@@ -721,8 +721,8 @@ pub struct sched_attr {
     pub sched_util_max: u32,
 }
 
-impl sched_attr {
-    pub fn default() -> Self {
+impl Default for sched_attr {
+    fn default() -> Self {
         Self {
             size: std::mem::size_of::<sched_attr>() as u32,
             sched_policy: 0,
diff --git a/base/src/sys/linux/shm.rs b/base/src/sys/linux/shm.rs
index ac4b63a6b..8c79d0b0c 100644
--- a/base/src/sys/linux/shm.rs
+++ b/base/src/sys/linux/shm.rs
@@ -6,6 +6,7 @@ use std::ffi::CStr;
 use std::fs::File;
 use std::io::Seek;
 use std::io::SeekFrom;
+use std::sync::LazyLock;
 
 use libc::c_char;
 use libc::c_int;
@@ -25,7 +26,6 @@ use libc::F_SEAL_SEAL;
 use libc::F_SEAL_SHRINK;
 use libc::F_SEAL_WRITE;
 use libc::MFD_ALLOW_SEALING;
-use once_cell::sync::Lazy;
 
 use crate::errno_result;
 use crate::shm::PlatformSharedMemory;
@@ -126,7 +126,7 @@ impl MemfdSeals {
     }
 }
 
-static MFD_NOEXEC_SEAL_SUPPORTED: Lazy<bool> = Lazy::new(|| {
+static MFD_NOEXEC_SEAL_SUPPORTED: LazyLock<bool> = LazyLock::new(|| {
     // SAFETY: We pass a valid zero-terminated C string and check the result.
     let fd = unsafe {
         // The memfd name used here does not need to be unique, since duplicates are allowed and
diff --git a/base/src/sys/windows/descriptor.rs b/base/src/sys/windows/descriptor.rs
index d15cb08a3..11cc48e49 100644
--- a/base/src/sys/windows/descriptor.rs
+++ b/base/src/sys/windows/descriptor.rs
@@ -3,29 +3,27 @@
 // found in the LICENSE file.
 
 use std::convert::TryFrom;
-use std::ffi::CString;
 use std::fs::File;
 use std::io::Stderr;
 use std::io::Stdin;
 use std::io::Stdout;
 use std::marker::Send;
 use std::marker::Sync;
-use std::mem::MaybeUninit;
 use std::ops::Drop;
 use std::os::windows::io::AsRawHandle;
 use std::os::windows::io::FromRawHandle;
 use std::os::windows::io::IntoRawHandle;
 use std::os::windows::io::RawHandle;
-use std::sync::Once;
+use std::sync::OnceLock;
 
 use win_util::duplicate_handle;
 use win_util::win32_wide_string;
 use winapi::shared::minwindef::BOOL;
-use winapi::shared::minwindef::HMODULE;
 use winapi::shared::minwindef::TRUE;
 use winapi::um::handleapi::CloseHandle;
 use winapi::um::handleapi::INVALID_HANDLE_VALUE;
-use winapi::um::libloaderapi;
+use winapi::um::libloaderapi::GetProcAddress;
+use winapi::um::libloaderapi::LoadLibraryW;
 
 use super::Result;
 use crate::descriptor::AsRawDescriptor;
@@ -57,38 +55,38 @@ impl AsRawHandle for SafeDescriptor {
     }
 }
 
-static KERNELBASE_INIT: Once = Once::new();
-static mut KERNELBASE_LIBRARY: MaybeUninit<HMODULE> = MaybeUninit::uninit();
+type CompareObjectHandlesFn = extern "system" fn(RawHandle, RawHandle) -> BOOL;
 
-fn compare_object_handles(first: RawHandle, second: RawHandle) -> bool {
-    KERNELBASE_INIT.call_once(|| {
-        // SAFETY: trivially safe
-        unsafe {
-            *KERNELBASE_LIBRARY.as_mut_ptr() =
-                libloaderapi::LoadLibraryW(win32_wide_string("Kernelbase").as_ptr());
-        };
-    });
+static COMPARE_OBJECT_HANDLES: OnceLock<CompareObjectHandlesFn> = OnceLock::new();
+
+fn init_compare_object_handles() -> CompareObjectHandlesFn {
     // SAFETY: the return value is checked.
-    let handle = unsafe { KERNELBASE_LIBRARY.assume_init() };
+    let handle = unsafe { LoadLibraryW(win32_wide_string("Kernelbase").as_ptr()) };
     if handle.is_null() {
-        return first == second;
+        return compare_object_handles_fallback;
     }
 
-    let addr = CString::new("CompareObjectHandles").unwrap();
-    let addr_ptr = addr.as_ptr();
     // SAFETY: the return value is checked.
-    let symbol = unsafe { libloaderapi::GetProcAddress(handle, addr_ptr) };
+    let symbol = unsafe { GetProcAddress(handle, c"CompareObjectHandles".as_ptr()) };
     if symbol.is_null() {
-        return first == second;
+        return compare_object_handles_fallback;
     }
 
     // SAFETY: trivially safe
-    let func = unsafe {
-        std::mem::transmute::<
-            *mut winapi::shared::minwindef::__some_function,
-            extern "system" fn(RawHandle, RawHandle) -> BOOL,
-        >(symbol)
-    };
+    unsafe {
+        std::mem::transmute::<*mut winapi::shared::minwindef::__some_function, CompareObjectHandlesFn>(
+            symbol,
+        )
+    }
+}
+
+// This function is only used if CompareObjectHandles() is not available.
+extern "system" fn compare_object_handles_fallback(first: RawHandle, second: RawHandle) -> BOOL {
+    (first == second).into()
+}
+
+fn compare_object_handles(first: RawHandle, second: RawHandle) -> bool {
+    let func = COMPARE_OBJECT_HANDLES.get_or_init(init_compare_object_handles);
     let ret = func(first, second);
     ret == TRUE
 }
diff --git a/base/src/sys/windows/platform_timer_utils.rs b/base/src/sys/windows/platform_timer_utils.rs
index c29160504..c50a836c6 100644
--- a/base/src/sys/windows/platform_timer_utils.rs
+++ b/base/src/sys/windows/platform_timer_utils.rs
@@ -3,22 +3,20 @@
 // found in the LICENSE file.
 
 use std::io;
-use std::mem::MaybeUninit;
-use std::sync::Once;
+use std::sync::OnceLock;
 use std::thread::sleep;
 use std::time::Duration;
 use std::time::Instant;
 
-use win_util::win32_string;
 use win_util::win32_wide_string;
 use winapi::shared::minwindef;
-use winapi::shared::minwindef::HINSTANCE;
-use winapi::shared::minwindef::HMODULE;
 use winapi::shared::minwindef::PULONG;
 use winapi::shared::ntdef::NTSTATUS;
 use winapi::shared::ntdef::ULONG;
+use winapi::shared::ntstatus::STATUS_NOT_IMPLEMENTED;
 use winapi::shared::ntstatus::STATUS_SUCCESS;
-use winapi::um::libloaderapi;
+use winapi::um::libloaderapi::GetProcAddress;
+use winapi::um::libloaderapi::LoadLibraryW;
 use winapi::um::mmsystem::TIMERR_NOERROR;
 use winapi::um::timeapi::timeBeginPeriod;
 use winapi::um::timeapi::timeEndPeriod;
@@ -28,61 +26,73 @@ use crate::warn;
 use crate::Error;
 use crate::Result;
 
-static NT_INIT: Once = Once::new();
-static mut NT_LIBRARY: MaybeUninit<HMODULE> = MaybeUninit::uninit();
+type NtQueryTimerResolutionFn = extern "system" fn(PULONG, PULONG, PULONG) -> NTSTATUS;
+type NtSetTimerResolutionFn = extern "system" fn(ULONG, BOOLEAN, PULONG) -> NTSTATUS;
 
-#[inline]
-fn init_ntdll() -> Result<HINSTANCE> {
-    NT_INIT.call_once(|| {
-        // SAFETY: return value is checked.
-        unsafe {
-            *NT_LIBRARY.as_mut_ptr() =
-                libloaderapi::LoadLibraryW(win32_wide_string("ntdll").as_ptr());
+struct NtTimerFuncs {
+    nt_query_timer_resolution: NtQueryTimerResolutionFn,
+    nt_set_timer_resolution: NtSetTimerResolutionFn,
+}
 
-            if NT_LIBRARY.assume_init().is_null() {
-                warn!("Failed to load ntdll: {}", Error::last());
-            }
-        };
-    });
+static NT_TIMER_FUNCS: OnceLock<NtTimerFuncs> = OnceLock::new();
 
-    // SAFETY: NT_LIBRARY initialized above.
-    let handle = unsafe { NT_LIBRARY.assume_init() };
+fn init_nt_timer_funcs() -> NtTimerFuncs {
+    // SAFETY: return value is checked.
+    let handle = unsafe { LoadLibraryW(win32_wide_string("ntdll").as_ptr()) };
     if handle.is_null() {
-        Err(Error::from(io::Error::new(
-            io::ErrorKind::NotFound,
-            "ntdll failed to load",
-        )))
-    } else {
-        Ok(handle)
+        warn!("Failed to load ntdll: {}", Error::last());
+        return NtTimerFuncs {
+            nt_query_timer_resolution: nt_query_timer_resolution_fallback,
+            nt_set_timer_resolution: nt_set_timer_resolution_fallback,
+        };
     }
-}
 
-fn get_symbol(handle: HMODULE, proc_name: &str) -> Result<*mut minwindef::__some_function> {
     // SAFETY: return value is checked.
-    let symbol = unsafe { libloaderapi::GetProcAddress(handle, win32_string(proc_name).as_ptr()) };
-    if symbol.is_null() {
-        Err(Error::last())
+    let query = unsafe { GetProcAddress(handle, c"NtQueryTimerResolution".as_ptr()) };
+    let nt_query_timer_resolution = if query.is_null() {
+        nt_query_timer_resolution_fallback
     } else {
-        Ok(symbol)
+        // SAFETY: the function signature matches.
+        unsafe {
+            std::mem::transmute::<*mut minwindef::__some_function, NtQueryTimerResolutionFn>(query)
+        }
+    };
+
+    // SAFETY: return value is checked.
+    let set = unsafe { GetProcAddress(handle, c"NtSetTimerResolution".as_ptr()) };
+    let nt_set_timer_resolution = if set.is_null() {
+        nt_set_timer_resolution_fallback
+    } else {
+        // SAFETY: the function signature matches.
+        unsafe {
+            std::mem::transmute::<*mut minwindef::__some_function, NtSetTimerResolutionFn>(set)
+        }
+    };
+
+    NtTimerFuncs {
+        nt_query_timer_resolution,
+        nt_set_timer_resolution,
     }
 }
 
+// This function is only used if NtQueryTimerResolution() is not available.
+extern "system" fn nt_query_timer_resolution_fallback(_: PULONG, _: PULONG, _: PULONG) -> NTSTATUS {
+    STATUS_NOT_IMPLEMENTED
+}
+
+// This function is only used if NtSetTimerResolution() is not available.
+extern "system" fn nt_set_timer_resolution_fallback(_: ULONG, _: BOOLEAN, _: PULONG) -> NTSTATUS {
+    STATUS_NOT_IMPLEMENTED
+}
+
 /// Returns the resolution of timers on the host (current_res, max_res).
 pub fn nt_query_timer_resolution() -> Result<(Duration, Duration)> {
-    let handle = init_ntdll()?;
-
-    // SAFETY: trivially safe
-    let func = unsafe {
-        std::mem::transmute::<
-            *mut minwindef::__some_function,
-            extern "system" fn(PULONG, PULONG, PULONG) -> NTSTATUS,
-        >(get_symbol(handle, "NtQueryTimerResolution")?)
-    };
+    let funcs = NT_TIMER_FUNCS.get_or_init(init_nt_timer_funcs);
 
     let mut min_res: u32 = 0;
     let mut max_res: u32 = 0;
     let mut current_res: u32 = 0;
-    let ret = func(
+    let ret = (funcs.nt_query_timer_resolution)(
         &mut min_res as *mut u32,
         &mut max_res as *mut u32,
         &mut current_res as *mut u32,
@@ -102,18 +112,11 @@ pub fn nt_query_timer_resolution() -> Result<(Duration, Duration)> {
 }
 
 pub fn nt_set_timer_resolution(resolution: Duration) -> Result<()> {
-    let handle = init_ntdll()?;
-    // SAFETY: trivially safe
-    let func = unsafe {
-        std::mem::transmute::<
-            *mut minwindef::__some_function,
-            extern "system" fn(ULONG, BOOLEAN, PULONG) -> NTSTATUS,
-        >(get_symbol(handle, "NtSetTimerResolution")?)
-    };
+    let funcs = NT_TIMER_FUNCS.get_or_init(init_nt_timer_funcs);
 
     let requested_res: u32 = (resolution.as_nanos() / 100) as u32;
     let mut current_res: u32 = 0;
-    let ret = func(
+    let ret = (funcs.nt_set_timer_resolution)(
         requested_res,
         1, /* true */
         &mut current_res as *mut u32,
diff --git a/base/src/sys/windows/syslog.rs b/base/src/sys/windows/syslog.rs
index 349353aa8..181b9ec86 100644
--- a/base/src/sys/windows/syslog.rs
+++ b/base/src/sys/windows/syslog.rs
@@ -38,7 +38,7 @@ impl Syslog for PlatformSyslog {
     fn new(
         _proc_name: String,
         _facility: Facility,
-    ) -> Result<(Option<Box<dyn Log + Send>>, Option<RawDescriptor>), Error> {
+    ) -> Result<(Option<Box<dyn Log + Send>>, Option<RawDescriptor>), &'static Error> {
         Ok((None, None))
     }
 }
diff --git a/base/src/sys/windows/system_info.rs b/base/src/sys/windows/system_info.rs
index 019b9282a..4c7700585 100644
--- a/base/src/sys/windows/system_info.rs
+++ b/base/src/sys/windows/system_info.rs
@@ -3,8 +3,8 @@
 // found in the LICENSE file.
 
 use std::mem::MaybeUninit;
+use std::sync::LazyLock;
 
-use once_cell::sync::Lazy;
 use winapi::um::processthreadsapi::GetCurrentProcessId;
 use winapi::um::sysinfoapi::GetNativeSystemInfo;
 use winapi::um::sysinfoapi::SYSTEM_INFO;
@@ -18,7 +18,7 @@ struct SystemInfo {
     allocation_granularity: u64,
 }
 
-static SYSTEM_INFO: Lazy<SystemInfo> = Lazy::new(|| {
+static SYSTEM_INFO: LazyLock<SystemInfo> = LazyLock::new(|| {
     // SAFETY:
     // Safe because this is a universally available call on modern Windows systems.
     let sysinfo = unsafe {
diff --git a/base/src/syslog.rs b/base/src/syslog.rs
index afeb48285..1e2a62bd8 100644
--- a/base/src/syslog.rs
+++ b/base/src/syslog.rs
@@ -43,13 +43,13 @@
 use std::fmt::Display;
 use std::io;
 use std::io::Write;
+use std::sync::LazyLock;
 use std::sync::MutexGuard;
 
 use chrono::Utc;
 pub use env_logger::fmt;
 pub use env_logger::{self};
 pub use log::*;
-use once_cell::sync::Lazy;
 use remain::sorted;
 use serde::Deserialize;
 use serde::Serialize;
@@ -175,7 +175,7 @@ pub(crate) trait Syslog {
     fn new(
         proc_name: String,
         facility: Facility,
-    ) -> Result<(Option<Box<dyn Log + Send>>, Option<RawDescriptor>), Error>;
+    ) -> Result<(Option<Box<dyn Log + Send>>, Option<RawDescriptor>), &'static Error>;
 }
 
 pub struct State {
@@ -336,7 +336,7 @@ impl Default for State {
     }
 }
 
-static STATE: Lazy<Mutex<State>> = Lazy::new(|| {
+static STATE: LazyLock<Mutex<State>> = LazyLock::new(|| {
     let mut state = State::new(LogConfig::default()).expect("failed to configure minimal logging");
     state.early_init = true;
     Mutex::new(state)
diff --git a/base_tokio/Cargo.toml b/base_tokio/Cargo.toml
index 04be8ee0c..9472cc3b0 100644
--- a/base_tokio/Cargo.toml
+++ b/base_tokio/Cargo.toml
@@ -5,15 +5,15 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-cfg-if = "1.0.0"
+anyhow = { workspace = true }
+cfg-if = { workspace = true }
 futures = { version = "0.3" }
-libc = "*"
-serde = { version = "1" }
+libc = { workspace = true }
+serde = { workspace = true }
 tokio = { workspace = true }
 
-base = { path = "../base" }
-sync = { path = "../common/sync" }
+base = { workspace = true }
+sync = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
 winapi = "*"
diff --git a/bit_field/bit_field_derive/Android.bp b/bit_field/bit_field_derive/Android.bp
index effad049f..252fc402e 100644
--- a/bit_field/bit_field_derive/Android.bp
+++ b/bit_field/bit_field_derive/Android.bp
@@ -13,13 +13,13 @@ package {
 }
 
 rust_test_host {
-    name: "bit_field_derive_test_bit_field_derive",
+    name: "bit_field_derive_test_src_bit_field_derive",
     defaults: ["crosvm_defaults"],
     host_cross_supported: false,
     crate_name: "bit_field_derive",
     cargo_env_compat: true,
     cargo_pkg_version: "0.1.0",
-    crate_root: "bit_field_derive.rs",
+    crate_root: "src/bit_field_derive.rs",
     test_suites: ["general-tests"],
     auto_gen_config: true,
     test_options: {
@@ -39,7 +39,7 @@ rust_proc_macro {
     crate_name: "bit_field_derive",
     cargo_env_compat: true,
     cargo_pkg_version: "0.1.0",
-    crate_root: "bit_field_derive.rs",
+    crate_root: "src/bit_field_derive.rs",
     edition: "2021",
     rustlibs: [
         "libproc_macro2",
diff --git a/bit_field/bit_field_derive/Cargo.toml b/bit_field/bit_field_derive/Cargo.toml
index cf59cfa4a..119cba285 100644
--- a/bit_field/bit_field_derive/Cargo.toml
+++ b/bit_field/bit_field_derive/Cargo.toml
@@ -11,4 +11,4 @@ syn = { version = "2", features = ["full"] }
 
 [lib]
 proc-macro = true
-path = "bit_field_derive.rs"
+path = "src/bit_field_derive.rs"
diff --git a/bit_field/bit_field_derive/bit_field_derive.rs b/bit_field/bit_field_derive/src/bit_field_derive.rs
similarity index 100%
rename from bit_field/bit_field_derive/bit_field_derive.rs
rename to bit_field/bit_field_derive/src/bit_field_derive.rs
diff --git a/broker_ipc/Cargo.toml b/broker_ipc/Cargo.toml
index c05f2e232..0a671682f 100644
--- a/broker_ipc/Cargo.toml
+++ b/broker_ipc/Cargo.toml
@@ -9,9 +9,9 @@ crash-report = ["crash_report", "broker_ipc_product/crash-report"]
 process-invariants = ["broker_ipc_product/process-invariants"]
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base" }
-crash_report = { path = "../vendor/generic/crash_report", optional = true }
-serde = { version = "1", features = ["derive"] }
-metrics = { path = "../metrics" }
+anyhow = { workspace = true }
+base = { workspace = true }
+crash_report = { workspace = true, optional = true }
+serde = { workspace = true, features = ["derive"] }
+metrics = { workspace = true }
 broker_ipc_product = { path = "../vendor/generic/broker_ipc/" }
diff --git a/broker_ipc/src/lib.rs b/broker_ipc/src/lib.rs
index 71a7313ee..878881da2 100644
--- a/broker_ipc/src/lib.rs
+++ b/broker_ipc/src/lib.rs
@@ -25,6 +25,7 @@ use broker_ipc_product::product_child_setup;
 #[cfg(feature = "process-invariants")]
 pub use broker_ipc_product::EmulatorProcessInvariants;
 use broker_ipc_product::ProductAttributes;
+use broker_ipc_product::ProductProcessState;
 use serde::Deserialize;
 use serde::Serialize;
 
@@ -57,6 +58,7 @@ impl CommonChildStartupArgs {
 
 pub struct ChildLifecycleCleanup {
     _timer_resolution: Box<dyn EnabledHighResTimer>,
+    _product_state: ProductProcessState,
 }
 
 /// Initializes crash reporting, metrics, logging, and product specific features
@@ -85,7 +87,7 @@ pub fn common_child_setup(args: CommonChildStartupArgs) -> anyhow::Result<ChildL
     init_child_crash_reporting(&args.product_attrs);
 
     // Initialize anything product specific.
-    product_child_setup(&args.product_attrs)?;
+    let product_proc_state = product_child_setup(&args.product_attrs)?;
 
     if let Some(metrics_tube) = args.metrics_tube {
         metrics::initialize(metrics_tube);
@@ -95,6 +97,7 @@ pub fn common_child_setup(args: CommonChildStartupArgs) -> anyhow::Result<ChildL
 
     Ok(ChildLifecycleCleanup {
         _timer_resolution: timer_resolution,
+        _product_state: product_proc_state,
     })
 }
 
diff --git a/cargo_embargo.json b/cargo_embargo.json
index dc01d3bc8..094a71c24 100644
--- a/cargo_embargo.json
+++ b/cargo_embargo.json
@@ -75,6 +75,7 @@
     "libfuse": "libfuse_rust",
     "liblog": "liblog_rust",
     "libminijail": "libminijail_rust",
+    "librand": "librand-0.8",
     "libsnapshot": "libsnapshot_crosvm",
     "libsync": "libsync_rust",
     "libx86_64": "libx86_64_rust"
@@ -151,6 +152,7 @@
     },
     "devices": {
       "no_presubmit": true,
+      "add_module_block": "devices/Android.bp.extra",
       "dep_blocklist": [
         // See the comment for base's "dep_blocklist" above (in this case
         // "devices_test_tests_passthroughfs_main" is the culprit).
@@ -165,7 +167,8 @@
       "patch": "gpu_display/patches/Android.bp.patch"
     },
     "hypervisor": {
-      "no_presubmit": true
+      "no_presubmit": true,
+      "add_module_block": "hypervisor/Android.bp.extra"
     },
     "io_uring": {
       "no_presubmit": true
diff --git a/common/audio_streams/Cargo.toml b/common/audio_streams/Cargo.toml
index cce7db7a2..a7f221028 100644
--- a/common/audio_streams/Cargo.toml
+++ b/common/audio_streams/Cargo.toml
@@ -9,7 +9,7 @@ path = "src/audio_streams.rs"
 
 [dependencies]
 async-trait = "0.1.36"
-remain = "0.2"
-thiserror = "1.0.20"
+remain = { workspace = true }
+thiserror = { workspace = true }
 futures = "0.3"
-serde = { version = "1.0", features = ["derive"] }
+serde = { workspace = true, features = ["derive"] }
diff --git a/common/balloon_control/Cargo.toml b/common/balloon_control/Cargo.toml
index f3a58f9b4..d3d7315f5 100644
--- a/common/balloon_control/Cargo.toml
+++ b/common/balloon_control/Cargo.toml
@@ -5,4 +5,4 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-serde = { version = "1", features = [ "derive" ] }
+serde = { workspace = true, features = [ "derive" ] }
diff --git a/common/data_model/Cargo.toml b/common/data_model/Cargo.toml
index 664a94f31..a35759c0b 100644
--- a/common/data_model/Cargo.toml
+++ b/common/data_model/Cargo.toml
@@ -8,5 +8,5 @@ description = "[highly unstable] data model for virtualization"
 license-file = "LICENSE"
 
 [dependencies]
-serde = { version = "1", features = ["derive"] }
+serde = { workspace = true, features = ["derive"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/cros_async/Android.bp b/cros_async/Android.bp
index a9fa4fc15..05c31f01c 100644
--- a/cros_async/Android.bp
+++ b/cros_async/Android.bp
@@ -38,7 +38,6 @@ rust_test {
         "libintrusive_collections",
         "libio_uring",
         "liblibc",
-        "libonce_cell",
         "libpin_utils",
         "libserde",
         "libserde_keyvalue",
@@ -82,7 +81,6 @@ rust_test {
         "libintrusive_collections",
         "libio_uring",
         "liblibc",
-        "libonce_cell",
         "libpin_utils",
         "libserde",
         "libserde_keyvalue",
@@ -118,7 +116,6 @@ rust_library {
         "libintrusive_collections",
         "libio_uring",
         "liblibc",
-        "libonce_cell",
         "libpin_utils",
         "libserde",
         "libserde_keyvalue",
diff --git a/cros_async/Cargo.toml b/cros_async/Cargo.toml
index 17d64c315..04d2ac6c9 100644
--- a/cros_async/Cargo.toml
+++ b/cros_async/Cargo.toml
@@ -10,26 +10,25 @@ tokio = ["dep:tokio"]
 [dependencies]
 async-trait = "0.1.36"
 async-task = "4"
-cfg-if = "1.0.0"
+cfg-if = { workspace = true }
 intrusive-collections = "0.9"
-libc = "0.2"
-once_cell = "1.7.2"
+libc = { workspace = true }
 paste = "1.0"
 pin-utils = "0.1.0-alpha.4"
-remain = "0.2"
+remain = { workspace = true }
 slab = "0.4"
-sync = { path = "../common/sync" } # provided by ebuild
-base = { path = "../base" } # provided by ebuild
-thiserror = "1.0.20"
-audio_streams = { path = "../common/audio_streams" } # provided by ebuild
-anyhow = "1"
-serde = "1"
-serde_keyvalue = { path = "../serde_keyvalue", features = ["argh_derive"] } # provided by ebuild
+sync = { workspace = true }
+base = { workspace = true }
+thiserror = { workspace = true }
+audio_streams = { workspace = true }
+anyhow = { workspace = true }
+serde = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
 static_assertions = "1.1"
 tokio = { workspace = true, optional = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-io_uring = { path = "../io_uring" } # provided by ebuild
+io_uring = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
 winapi = "0.3"
diff --git a/cros_async/src/blocking/cancellable_pool.rs b/cros_async/src/blocking/cancellable_pool.rs
index 663b7f709..ef152767a 100644
--- a/cros_async/src/blocking/cancellable_pool.rs
+++ b/cros_async/src/blocking/cancellable_pool.rs
@@ -7,10 +7,10 @@
 use std::collections::HashMap;
 use std::future::Future;
 use std::sync::Arc;
+use std::sync::LazyLock;
 use std::time::Duration;
 use std::time::Instant;
 
-use once_cell::sync::Lazy;
 use sync::Condvar;
 use sync::Mutex;
 use thiserror::Error as ThisError;
@@ -24,8 +24,8 @@ use crate::BlockingPool;
 /// + The call site can assume that executor will never shutdown.
 /// + Provides similar functionality as async_task with a few improvements around ability to cancel.
 /// - Globals are harder to reason about.
-static EXECUTOR: Lazy<CancellableBlockingPool> =
-    Lazy::new(|| CancellableBlockingPool::new(256, Duration::from_secs(10)));
+static EXECUTOR: LazyLock<CancellableBlockingPool> =
+    LazyLock::new(|| CancellableBlockingPool::new(256, Duration::from_secs(10)));
 
 const DEFAULT_SHUTDOWN_TIMEOUT: Duration = Duration::from_secs(5);
 
diff --git a/cros_async/src/executor.rs b/cros_async/src/executor.rs
index 25ec7ff8a..188075b7e 100644
--- a/cros_async/src/executor.rs
+++ b/cros_async/src/executor.rs
@@ -5,6 +5,7 @@
 use std::future::Future;
 use std::pin::Pin;
 use std::sync::Arc;
+use std::sync::OnceLock;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use base::warn;
@@ -12,7 +13,6 @@ use base::warn;
 use base::AsRawDescriptors;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use base::RawDescriptor;
-use once_cell::sync::OnceCell;
 use serde::Deserialize;
 use serde_keyvalue::argh::FromArgValue;
 use serde_keyvalue::ErrorKind;
@@ -52,7 +52,7 @@ impl From<ExecutorKindSys> for ExecutorKind {
 /// If set, [`ExecutorKind::default()`] returns the value of `DEFAULT_EXECUTOR_KIND`.
 /// If not set, [`ExecutorKind::default()`] returns a statically-chosen default value, and
 /// [`ExecutorKind::default()`] initializes `DEFAULT_EXECUTOR_KIND` with that value.
-static DEFAULT_EXECUTOR_KIND: OnceCell<ExecutorKind> = OnceCell::new();
+static DEFAULT_EXECUTOR_KIND: OnceLock<ExecutorKind> = OnceLock::new();
 
 impl Default for ExecutorKind {
     fn default() -> Self {
diff --git a/cros_async/src/sys/linux/uring_executor.rs b/cros_async/src/sys/linux/uring_executor.rs
index bc720f8d7..d72faf0d8 100644
--- a/cros_async/src/sys/linux/uring_executor.rs
+++ b/cros_async/src/sys/linux/uring_executor.rs
@@ -54,6 +54,7 @@ use std::os::unix::io::FromRawFd;
 use std::os::unix::io::RawFd;
 use std::pin::Pin;
 use std::sync::Arc;
+use std::sync::LazyLock;
 use std::sync::Weak;
 use std::task::Context;
 use std::task::Poll;
@@ -70,7 +71,6 @@ use base::RawDescriptor;
 use io_uring::URingAllowlist;
 use io_uring::URingContext;
 use io_uring::URingOperation;
-use once_cell::sync::Lazy;
 use remain::sorted;
 use slab::Slab;
 use sync::Mutex;
@@ -160,7 +160,7 @@ impl From<Error> for AsyncError {
     }
 }
 
-static IS_URING_STABLE: Lazy<bool> = Lazy::new(|| {
+static IS_URING_STABLE: LazyLock<bool> = LazyLock::new(|| {
     let mut utsname = MaybeUninit::zeroed();
 
     // SAFETY:
diff --git a/cros_fdt/Cargo.toml b/cros_fdt/Cargo.toml
index 6ba39ba38..76ba9fc03 100644
--- a/cros_fdt/Cargo.toml
+++ b/cros_fdt/Cargo.toml
@@ -5,7 +5,7 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
+anyhow = { workspace = true }
 indexmap = "1"
-remain = "0.2"
-thiserror = "1.0.20"
+remain = { workspace = true }
+thiserror = { workspace = true }
diff --git a/cros_tracing/Cargo.toml b/cros_tracing/Cargo.toml
index 591171b06..c30ac9ac9 100644
--- a/cros_tracing/Cargo.toml
+++ b/cros_tracing/Cargo.toml
@@ -17,12 +17,12 @@ trace_marker = []
 perfetto = ["dep:perfetto"]
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base" }
-cfg-if = "1.0.0"
+anyhow = { workspace = true }
+base = { workspace = true }
+cfg-if = { workspace = true }
 cros_tracing_types = { path = "../cros_tracing_types" }
 perfetto = { path = "../perfetto", optional = true }
-sync = { path = "../common/sync" }
+sync = { workspace = true }
 
 [dev-dependencies]
 libtest-mimic = "0.6"
diff --git a/cros_tracing_types/Cargo.toml b/cros_tracing_types/Cargo.toml
index 9888279c6..573118e03 100644
--- a/cros_tracing_types/Cargo.toml
+++ b/cros_tracing_types/Cargo.toml
@@ -5,5 +5,5 @@ authors = ["The Chromium OS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-sync = { path = "../common/sync" }
+anyhow = { workspace = true }
+sync = { workspace = true }
diff --git a/crosvm_cli/Cargo.toml b/crosvm_cli/Cargo.toml
index 456183a91..919544dd4 100644
--- a/crosvm_cli/Cargo.toml
+++ b/crosvm_cli/Cargo.toml
@@ -7,8 +7,8 @@ edition = "2021"
 [features]
 
 [dependencies]
-anyhow = "1"
-cfg-if = "1.0.0"
+anyhow = { workspace = true }
+cfg-if = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
 win_util = { path = "../win_util" }
diff --git a/crosvm_control/Cargo.toml b/crosvm_control/Cargo.toml
index 7bfe0f3a1..cd78fef08 100644
--- a/crosvm_control/Cargo.toml
+++ b/crosvm_control/Cargo.toml
@@ -13,14 +13,14 @@ registered_events = ["vm_control/registered_events"]
 crate-type = ["cdylib", "staticlib"]
 
 [dependencies]
-balloon_control = { path = "../common/balloon_control" }
-base = { path = "../base" }
-libc = "0.2.65"
+balloon_control = { workspace = true }
+base = { workspace = true }
+libc = { workspace = true }
 swap = { path = "../swap", default-features = false }
-vm_control = { path = "../vm_control", features = [ "balloon" ] }
+vm_control = { workspace = true, features = [ "balloon" ] }
 
 [build-dependencies]
-anyhow = "1"
+anyhow = { workspace = true }
 cbindgen = "0.24.3"
 cc = "1"
 tempfile = "3"
diff --git a/crosvm_control/src/lib.rs b/crosvm_control/src/lib.rs
index c68f5fc26..b385a1edc 100644
--- a/crosvm_control/src/lib.rs
+++ b/crosvm_control/src/lib.rs
@@ -80,9 +80,8 @@ unsafe fn validate_socket_path(socket_path: *const c_char) -> Option<PathBuf> {
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_stop_vm(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -101,9 +100,8 @@ pub unsafe extern "C" fn crosvm_client_stop_vm(socket_path: *const c_char) -> bo
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_suspend_vm(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -125,9 +123,8 @@ pub unsafe extern "C" fn crosvm_client_suspend_vm(socket_path: *const c_char) ->
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_resume_vm(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -148,9 +145,8 @@ pub unsafe extern "C" fn crosvm_client_resume_vm(socket_path: *const c_char) ->
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_resume_vm_full(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -169,9 +165,8 @@ pub unsafe extern "C" fn crosvm_client_resume_vm_full(socket_path: *const c_char
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_make_rt_vm(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -191,9 +186,8 @@ pub unsafe extern "C" fn crosvm_client_make_rt_vm(socket_path: *const c_char) ->
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_balloon_vms(
     socket_path: *const c_char,
@@ -217,9 +211,8 @@ pub unsafe extern "C" fn crosvm_client_balloon_vms(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_balloon_vms_wait_with_timeout(
     socket_path: *const c_char,
@@ -277,9 +270,8 @@ pub unsafe extern "C" fn crosvm_client_snd_mute_all(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_swap_enable_vm(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -299,9 +291,8 @@ pub unsafe extern "C" fn crosvm_client_swap_enable_vm(socket_path: *const c_char
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_swap_swapout_vm(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -318,9 +309,9 @@ pub unsafe extern "C" fn crosvm_client_swap_swapout_vm(socket_path: *const c_cha
 #[repr(C)]
 pub struct SwapDisableArgs {
     /// The path of the control socket to target.
-    socket_path: *const c_char,
+    pub socket_path: *const c_char,
     /// Whether or not the swap file should be cleaned up in the background.
-    slow_file_cleanup: bool,
+    pub slow_file_cleanup: bool,
 }
 
 /// Disable vmm swap according to `args`.
@@ -329,9 +320,9 @@ pub struct SwapDisableArgs {
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// `SwapDisableArgs` instance valid for writes that is not externally modified for the duration of
+/// this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_swap_disable_vm(args: *mut SwapDisableArgs) -> bool {
     catch_unwind(|| {
@@ -359,9 +350,8 @@ pub unsafe extern "C" fn crosvm_client_swap_disable_vm(args: *mut SwapDisableArg
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_swap_trim(socket_path: *const c_char) -> bool {
     catch_unwind(|| {
@@ -383,9 +373,10 @@ pub unsafe extern "C" fn crosvm_client_swap_trim(socket_path: *const c_char) ->
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid for reads and not modified for the duration of the call, and that `status`
+/// is a non-null pointer to a `SwapStatus` valid for writes that is not externally modified for
+/// the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_swap_status(
     socket_path: *const c_char,
@@ -416,11 +407,11 @@ pub unsafe extern "C" fn crosvm_client_swap_status(
 #[repr(C)]
 pub struct UsbDeviceEntry {
     /// Internal port index used for identifying this individual device.
-    port: u8,
+    pub port: u8,
     /// USB vendor ID
-    vendor_id: u16,
+    pub vendor_id: u16,
     /// USB product ID
-    product_id: u16,
+    pub product_id: u16,
 }
 
 impl From<&UsbControlAttachedDevice> for UsbDeviceEntry {
@@ -455,9 +446,10 @@ pub extern "C" fn crosvm_client_max_usb_devices() -> usize {
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid and for reads and not modified for the duration of the call. `entries`
+/// should be a valid pointer to an array of `UsbDeviceEntry` valid for writes that contains at
+/// least `entries_length` elements and is not externally modified for the duration of this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_usb_list(
     socket_path: *const c_char,
@@ -614,9 +606,8 @@ pub unsafe extern "C" fn crosvm_client_security_key_attach(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_usb_detach(socket_path: *const c_char, port: u8) -> bool {
     catch_unwind(|| {
@@ -841,9 +832,8 @@ pub unsafe extern "C" fn crosvm_client_cancel_fake_power(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a
+/// C string that is valid for reads and not modified for the duration of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_resize_disk(
     socket_path: *const c_char,
@@ -872,18 +862,18 @@ pub unsafe extern "C" fn crosvm_client_resize_disk(
 /// `Option<u64>`. `None` (or values bigger than `i64::max`) will be encoded as -1.
 #[repr(C)]
 pub struct BalloonStatsFfi {
-    swap_in: i64,
-    swap_out: i64,
-    major_faults: i64,
-    minor_faults: i64,
-    free_memory: i64,
-    total_memory: i64,
-    available_memory: i64,
-    disk_caches: i64,
-    hugetlb_allocations: i64,
-    hugetlb_failures: i64,
-    shared_memory: i64,
-    unevictable_memory: i64,
+    pub swap_in: i64,
+    pub swap_out: i64,
+    pub major_faults: i64,
+    pub minor_faults: i64,
+    pub free_memory: i64,
+    pub total_memory: i64,
+    pub available_memory: i64,
+    pub disk_caches: i64,
+    pub hugetlb_allocations: i64,
+    pub hugetlb_failures: i64,
+    pub shared_memory: i64,
+    pub unevictable_memory: i64,
 }
 
 impl From<&BalloonStats> for BalloonStatsFfi {
@@ -919,9 +909,11 @@ impl From<&BalloonStats> for BalloonStatsFfi {
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid for reads and not modified for the duration of the call. `stats` should be
+/// a pointer to a `BalloonStatsFfi` valid for writes that is not modified for the duration of this
+/// call, and `actual` should be a pointer to a `u64` valid for writes that is not modified for the
+/// duration of this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_balloon_stats(
     socket_path: *const c_char,
@@ -935,9 +927,11 @@ pub unsafe extern "C" fn crosvm_client_balloon_stats(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid for reads and not modified for the duration of the call. `stats` should be
+/// a pointer to a `BalloonStatsFfi` valid for writes is not modified for the duration of this
+/// call, and `actual` should be a pointer to a `u64` valid for writes that is not modified for the
+/// duration of this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_balloon_stats_with_timeout(
     socket_path: *const c_char,
@@ -956,7 +950,9 @@ pub unsafe extern "C" fn crosvm_client_balloon_stats_with_timeout(
 /// # Safety
 ///
 /// This function is safe when the caller ensures the socket_path raw pointer can be safely passed
-/// to `CStr::from_ptr()`.
+/// to `CStr::from_ptr()`. `stats` should be a pointer to a `BalloonStatsFfi` valid for writes that
+/// is not modified for the duration of this call, and `actual` should be a pointer to a `u64`
+/// valid for writes that is not modified for the duration of this call.
 unsafe fn crosvm_client_balloon_stats_impl(
     socket_path: *const c_char,
     timeout_ms: Option<Duration>,
@@ -1000,8 +996,8 @@ unsafe fn crosvm_client_balloon_stats_impl(
 #[derive(Clone, Copy, Debug)]
 #[repr(C)]
 pub struct WorkingSetBucketFfi {
-    age: u64,
-    bytes: [u64; 2],
+    pub age: u64,
+    pub bytes: [u64; 2],
 }
 
 impl WorkingSetBucketFfi {
@@ -1025,9 +1021,9 @@ impl From<WSBucket> for WorkingSetBucketFfi {
 #[repr(C)]
 #[derive(Debug)]
 pub struct BalloonWSFfi {
-    ws: [WorkingSetBucketFfi; VIRTIO_BALLOON_WS_MAX_NUM_BINS],
-    num_bins: u8,
-    _reserved: [u8; 7],
+    pub ws: [WorkingSetBucketFfi; VIRTIO_BALLOON_WS_MAX_NUM_BINS],
+    pub num_bins: u8,
+    pub _reserved: [u8; 7],
 }
 
 impl TryFrom<&BalloonWS> for BalloonWSFfi {
@@ -1068,11 +1064,11 @@ impl Default for BalloonWSFfi {
 
 #[repr(C)]
 pub struct BalloonWSRConfigFfi {
-    intervals: [u64; VIRTIO_BALLOON_WS_MAX_NUM_INTERVALS],
-    num_intervals: u8,
-    _reserved: [u8; 7],
-    refresh_threshold: u64,
-    report_threshold: u64,
+    pub intervals: [u64; VIRTIO_BALLOON_WS_MAX_NUM_INTERVALS],
+    pub num_intervals: u8,
+    pub _reserved: [u8; 7],
+    pub refresh_threshold: u64,
+    pub report_threshold: u64,
 }
 
 /// Returns balloon working set of the crosvm instance whose control socket is listening on
@@ -1082,9 +1078,10 @@ pub struct BalloonWSRConfigFfi {
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid for reads and not modified for the duration of the call. `ws` and `actual`
+/// should be pointers to a `BalloonStatsFfi` and `u64` respectively that are valid for writes and
+/// not modified for the duration of this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_balloon_working_set(
     socket_path: *const c_char,
@@ -1155,9 +1152,9 @@ impl TryFrom<RegisteredEventFfi> for RegisteredEvent {
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` and `listening_socket_path` should
+/// be a non-null pointers to C strings that are valid for reads and not modified for the duration
+/// of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_register_events_listener(
     socket_path: *const c_char,
@@ -1192,9 +1189,9 @@ pub unsafe extern "C" fn crosvm_client_register_events_listener(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` and `listening_socket_path` should
+/// be a non-null pointers to C strings that are valid for reads and not modified for the duration
+/// of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_unregister_events_listener(
     socket_path: *const c_char,
@@ -1229,9 +1226,9 @@ pub unsafe extern "C" fn crosvm_client_unregister_events_listener(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` and `listening_socket_path` should
+/// be a non-null pointers to C strings that are valid for reads and not modified for the duration
+/// of the call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_unregister_listener(
     socket_path: *const c_char,
@@ -1260,9 +1257,10 @@ pub unsafe extern "C" fn crosvm_client_unregister_listener(
 ///
 /// # Safety
 ///
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid for reads and not modified for the duration of the call. `config` should
+/// be a pointer to a `BalloonWSRConfigFfi` valid for reads that is not modified for the duration
+/// of this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_client_balloon_wsr_config(
     socket_path: *const c_char,
@@ -1340,8 +1338,8 @@ pub union HypervisorSpecificVmDescriptorFfi {
 /// A unique identifier of a VM.
 #[repr(C)]
 pub struct VmDescriptorFfi {
-    hypervisor: HypervisorFfi,
-    descriptor: HypervisorSpecificVmDescriptorFfi,
+    pub hypervisor: HypervisorFfi,
+    pub descriptor: HypervisorSpecificVmDescriptorFfi,
 }
 
 /// Get a descriptor representing a running VM.
@@ -1349,9 +1347,11 @@ pub struct VmDescriptorFfi {
 /// The function returns true on success or false if an error occurred.
 ///
 /// # Safety
-/// Function is unsafe due to raw pointer usage - a null pointer could be passed in. Usage of
-/// !raw_pointer.is_null() checks should prevent unsafe behavior but the caller should ensure no
-/// null pointers are passed.
+///
+/// Function is unsafe due to raw pointer usage - `socket_path` should be a non-null pointer to a C
+/// string that is valid for reads and not modified for the duration of the call. `vm_desc_out`
+/// should be a pointer to a `VmDescriptorFfi` valid for writes that is not externally modified for
+/// the duration of this call.
 #[no_mangle]
 pub unsafe extern "C" fn crosvm_get_vm_descriptor(
     socket_path: *const c_char,
diff --git a/crosvm_plugin/Cargo.toml b/crosvm_plugin/Cargo.toml
index 143eb45e8..0d7003213 100644
--- a/crosvm_plugin/Cargo.toml
+++ b/crosvm_plugin/Cargo.toml
@@ -11,9 +11,9 @@ stats = []
 crate-type = ["cdylib"]
 
 [dependencies]
-kvm = { path = "../kvm" }
-kvm_sys = { path = "../kvm_sys" }
-libc = "0.2"
+kvm = { workspace = true }
+kvm_sys = { workspace = true }
+libc = { workspace = true }
 protobuf = "3.2"
-protos = { path = "../protos", features = ["plugin"] }
-base = { path = "../base" }
+protos = { workspace = true, features = ["plugin"] }
+base = { workspace = true }
diff --git a/devices/Android.bp b/devices/Android.bp
index 6fa9b56b7..1c17d25f9 100644
--- a/devices/Android.bp
+++ b/devices/Android.bp
@@ -59,6 +59,7 @@ rust_test {
         "libbytes",
         "libcfg_if",
         "libchrono",
+        "libciborium",
         "libcrc32fast",
         "libcros_async",
         "libcros_tracing",
@@ -81,10 +82,9 @@ rust_test {
         "libnet_sys",
         "libnet_util",
         "libnum_traits",
-        "libonce_cell",
         "libp9",
         "libpower_monitor",
-        "librand",
+        "librand-0.8",
         "libresources",
         "librutabaga_gfx",
         "libserde",
@@ -112,6 +112,12 @@ rust_test {
         "libenumn",
         "libremain",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -161,6 +167,7 @@ rust_test {
         "libbytes",
         "libcfg_if",
         "libchrono",
+        "libciborium",
         "libcrc32fast",
         "libcros_async",
         "libcros_tracing",
@@ -184,10 +191,9 @@ rust_test {
         "libnet_sys",
         "libnet_util",
         "libnum_traits",
-        "libonce_cell",
         "libp9",
         "libpower_monitor",
-        "librand",
+        "librand-0.8",
         "libresources",
         "librutabaga_gfx",
         "libserde",
@@ -215,6 +221,12 @@ rust_test {
         "libenumn",
         "libremain",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_library {
@@ -258,6 +270,7 @@ rust_library {
         "libbit_field_crosvm",
         "libcfg_if",
         "libchrono",
+        "libciborium",
         "libcros_async",
         "libcros_tracing",
         "libcrosvm_cli",
@@ -278,10 +291,9 @@ rust_library {
         "libnet_sys",
         "libnet_util",
         "libnum_traits",
-        "libonce_cell",
         "libp9",
         "libpower_monitor",
-        "librand",
+        "librand-0.8",
         "libresources",
         "librutabaga_gfx",
         "libserde",
@@ -310,4 +322,10 @@ rust_library {
         "libremain",
     ],
     apex_available: ["com.android.virt"],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
diff --git a/devices/Android.bp.extra b/devices/Android.bp.extra
new file mode 100644
index 000000000..35989537b
--- /dev/null
+++ b/devices/Android.bp.extra
@@ -0,0 +1,5 @@
+arch: {
+    arm64: {
+        rustlibs: ["libaarch64_sys_reg"],
+    }
+}
diff --git a/devices/Cargo.toml b/devices/Cargo.toml
index 748dbd912..44a5a6652 100644
--- a/devices/Cargo.toml
+++ b/devices/Cargo.toml
@@ -45,79 +45,82 @@ pci-hotplug = []
 noncoherent-dma = []
 
 [dependencies]
-argh = "0.1.7"
+argh = { workspace = true }
 async-task = "4"
-acpi_tables = {path = "../acpi_tables" }
-anyhow = "1"
+acpi_tables = { workspace = true }
+anyhow = { workspace = true }
 async-trait = "0.1.36"
-audio_streams = "*"
-audio_util = { path = "../audio_util" }
-balloon_control = { path = "../common/balloon_control" }
-base = { path = "../base" }
-bit_field = { path = "../bit_field" }
-cfg-if = "1.0.0"
+audio_streams = { workspace = true }
+audio_util = { workspace = true }
+balloon_control = { workspace = true }
+base = { workspace = true }
+bit_field = { workspace = true }
+cfg-if = { workspace = true }
 chrono = { version = "0.4.34", features = [ "serde", "now" ], default-features = false }
 crc32fast = { version = "1.2.1", optional = true }
-cros_async = { path = "../cros_async" }
+cros_async = { workspace = true }
 cros-codecs = { version = "0.0.4", optional = true }
-crosvm_cli = { path = "../crosvm_cli" }
-data_model = { path = "../common/data_model" }
+crosvm_cli = { workspace = true }
+data_model = { workspace = true }
 dbus = { version = "0.9.7", features = ["stdfd"], optional = true }
-disk = { path = "../disk" }
+disk = { workspace = true }
 downcast-rs = "1.2.0"
-enumn = "0.1.0"
-ffmpeg = { path = "../media/ffmpeg", optional = true }
-gpu_display = { path = "../gpu_display", optional = true }
-rutabaga_gfx = { path = "../rutabaga_gfx" }
-hypervisor = { path = "../hypervisor" }
-kvm_sys = { path = "../kvm_sys" }
-libc = "0.2"
+enumn = { workspace = true }
+ffmpeg = { workspace = true, optional = true }
+gpu_display = { workspace = true, optional = true }
+rutabaga_gfx = { workspace = true }
+hypervisor = { workspace = true }
+kvm_sys = { workspace = true }
+libc = { workspace = true }
 libvda = { path = "../media/libvda", optional = true }
-linux_input_sys = { path = "../linux_input_sys" }
-metrics = { path = "../metrics" }
-metrics_events = { path = "../metrics_events" }
-net_util = { path = "../net_util" }
+linux_input_sys = { workspace = true }
+metrics = { workspace = true }
+metrics_events = { workspace = true }
+net_util = { workspace = true }
 num-traits = "0.2"
-once_cell = "1.7.2"
-power_monitor = { path = "../power_monitor" }
+power_monitor = { workspace = true }
 protobuf = { version = "3.2", optional = true }
-protos = { path = "../protos", optional = true }
-rand = "0.8"
-remain = "0.2"
-resources = { path = "../resources" }
-serde = { version = "1", features = [ "derive", "rc" ] }
-serde_json = "1"
-serde_keyvalue = { path = "../serde_keyvalue", features = ["argh_derive"] }
+protos = { workspace = true, optional = true }
+rand = { workspace = true }
+remain = { workspace = true }
+resources = { workspace = true }
+serde = { workspace = true, features = [ "derive", "rc" ] }
+serde_json = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
 smallvec = "1.6.1"
 snapshot = { workspace = true }
 static_assertions = "1.1"
-sync = { path = "../common/sync" }
-system_api = { path = "../system_api", optional = true }
+sync = { workspace = true }
+system_api = { workspace = true, optional = true }
 tempfile = "3"
-thiserror = "1.0.20"
-cros_tracing = { path = "../cros_tracing" }
-swap = { path = "../swap" }
-vmm_vhost = { path = "../third_party/vmm_vhost" }
-virtio_sys = { path = "../virtio_sys" }
+thiserror = { workspace = true }
+cros_tracing = { workspace = true }
+swap = { workspace = true }
+vmm_vhost = { workspace = true }
+virtio_sys = { workspace = true }
 virtio-media = { version = "0.0.7", optional = true }
-vm_control = { path = "../vm_control" }
-vm_memory = { path = "../vm_memory" }
+vm_control = { workspace = true }
+vm_memory = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
+ciborium = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-android_audio = { path = "../android_audio" }
-fuse = {path = "../fuse" }
+android_audio = { workspace = true }
+fuse = { workspace = true }
 jail = { path = "../jail" }
 libcras = { version = "*", optional = true }
 minijail = "*"
-net_sys = { path = "../net_sys" }
+net_sys = { workspace = true }
 p9 = "0.3.1"
-usb_util = { path = "../usb_util" }
-vfio_sys = { path = "../vfio_sys" }
-vhost = { path = "../vhost" }
+usb_util = { workspace = true }
+vfio_sys = { workspace = true }
+vhost = { workspace = true }
+
+[target.'cfg(any(target_arch = "arm", target_arch = "aarch64"))'.dependencies]
+aarch64_sys_reg = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
-broker_ipc = { path = "../broker_ipc" }
+broker_ipc = { workspace = true }
 tube_transporter = { path = "../tube_transporter" }
 win_audio = { path = "../win_audio"}
 win_util = { path = "../win_util"}
diff --git a/devices/src/bat.rs b/devices/src/bat.rs
index bf4322c74..c8bb48262 100644
--- a/devices/src/bat.rs
+++ b/devices/src/bat.rs
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+use std::ops::DerefMut;
 use std::sync::Arc;
 use std::time::Duration;
 use std::time::SystemTime;
@@ -22,6 +23,7 @@ use base::WorkerThread;
 use power_monitor::BatteryStatus;
 use power_monitor::CreatePowerClientFn;
 use power_monitor::CreatePowerMonitorFn;
+use power_monitor::PowerClient;
 use remain::sorted;
 use serde::Deserialize;
 use serde::Serialize;
@@ -82,7 +84,6 @@ struct GoldfishBatteryState {
     current: u32,
     charge_counter: u32,
     charge_full: u32,
-    initialized: bool,
     // bat_config is used for goldfish battery to report fake battery to the guest.
     bat_config: BatConfig,
 }
@@ -136,6 +137,12 @@ impl GoldfishBatteryState {
     create_battery_func!(set_bat_config, bat_config, BatConfig, BATTERY_INT_MASK);
 }
 
+enum BatInitializationState {
+    NotYet,
+    Pending(Box<dyn PowerClient>),
+    Done,
+}
+
 /// GoldFish Battery state
 pub struct GoldfishBattery {
     state: Arc<Mutex<GoldfishBatteryState>>,
@@ -147,6 +154,7 @@ pub struct GoldfishBattery {
     tube: Option<Tube>,
     create_power_monitor: Option<Box<dyn CreatePowerMonitorFn>>,
     create_powerd_client: Option<Box<dyn CreatePowerClientFn>>,
+    init_state: Arc<Mutex<BatInitializationState>>,
 }
 
 #[derive(Serialize, Deserialize)]
@@ -206,6 +214,7 @@ fn command_monitor(
     kill_evt: Event,
     state: Arc<Mutex<GoldfishBatteryState>>,
     create_power_monitor: Option<Box<dyn CreatePowerMonitorFn>>,
+    init_state: Arc<Mutex<BatInitializationState>>,
 ) {
     let wait_ctx: WaitContext<Token> = match WaitContext::build_with(&[
         (&tube, Token::Commands),
@@ -329,6 +338,7 @@ fn command_monitor(
                             inject_irq |= bat_state.set_present(0);
                         }
                     }
+                    *init_state.lock() = BatInitializationState::Done;
 
                     if inject_irq {
                         let _ = irq_evt.trigger();
@@ -348,11 +358,6 @@ fn command_monitor(
     }
 }
 
-enum InitResult {
-    Done,
-    RetryNeeded,
-}
-
 impl GoldfishBattery {
     /// The interval in milli seconds between DBus requests to powerd.  This is used to rate-limit
     /// requests to avoid overwhelming the power daemon.
@@ -389,7 +394,6 @@ impl GoldfishBattery {
             current: 0,
             charge_counter: 0,
             charge_full: 0,
-            initialized: false,
             bat_config: BatConfig::Real,
         }));
 
@@ -403,6 +407,7 @@ impl GoldfishBattery {
             tube: Some(tube),
             create_power_monitor,
             create_powerd_client,
+            init_state: Arc::new(Mutex::new(BatInitializationState::NotYet)),
         })
     }
 
@@ -430,23 +435,45 @@ impl GoldfishBattery {
             let irq_evt = self.irq_evt.try_clone().unwrap();
             let bat_state = self.state.clone();
             let create_monitor_fn = self.create_power_monitor.take();
+            let init_state = self.init_state.clone();
             self.monitor_thread = Some(WorkerThread::start(self.debug_label(), move |kill_evt| {
-                command_monitor(tube, irq_evt, kill_evt, bat_state, create_monitor_fn)
+                command_monitor(
+                    tube,
+                    irq_evt,
+                    kill_evt,
+                    bat_state,
+                    create_monitor_fn,
+                    init_state,
+                )
             }));
             self.activated = true;
         }
     }
 
-    fn initialize_battery_state(&mut self) -> anyhow::Result<InitResult> {
-        let mut power_client = match &self.create_powerd_client {
-            Some(f) => match f() {
-                Ok(c) => c,
-                Err(e) => bail!("failed to connect to the powerd: {:#}", e),
-            },
-            None => {
+    fn initialize_battery_state(&mut self) -> anyhow::Result<()> {
+        let mut init_state = self.init_state.lock();
+        let power_client = match (init_state.deref_mut(), &self.create_powerd_client) {
+            (BatInitializationState::NotYet, None) => {
                 // No need to initialize the state via DBus.
-                return Ok(InitResult::Done);
+                return Ok(());
             }
+            (BatInitializationState::NotYet, Some(f)) => {
+                // Initialize power_client
+                let client = match f() {
+                    Ok(c) => c,
+                    Err(e) => bail!("failed to connect to the powerd: {:#}", e),
+                };
+                // Save power_client to init_state
+                *init_state = BatInitializationState::Pending(client);
+
+                let power_client = match init_state.deref_mut() {
+                    BatInitializationState::Pending(ref mut power_client) => power_client.as_mut(),
+                    _ => unreachable!("init_state should be Pending"),
+                };
+                power_client
+            }
+            (BatInitializationState::Pending(ref mut power_client), _) => power_client.as_mut(),
+            (BatInitializationState::Done, _) => bail!("battery status already intialized"),
         };
 
         if let Some(prev_call) = power_client.last_request_timestamp() {
@@ -456,7 +483,7 @@ impl GoldfishBattery {
                 .duration_since(prev_call)
                 .context("failed to calculate time for dbus request")?;
             if duration < Duration::from_millis(Self::POWERD_REQ_INTERVAL_MS) {
-                return Ok(InitResult::RetryNeeded);
+                return Ok(());
             }
         }
 
@@ -489,7 +516,13 @@ impl GoldfishBattery {
                 bail!("failed to get response from powerd: {:#}", e);
             }
         };
-        Ok(InitResult::Done)
+        // Release powerd_client if the initialization data is obtained.
+        *init_state = BatInitializationState::Done;
+        Ok(())
+    }
+
+    fn battery_init_done(&self) -> bool {
+        matches!(*self.init_state.lock(), BatInitializationState::Done)
     }
 }
 
@@ -521,20 +554,14 @@ impl BusDevice for GoldfishBattery {
         }
 
         // Before first read, we try to ask powerd the actual power data to initialize `self.state`.
-        if !self.state.lock().initialized {
-            match self.initialize_battery_state() {
-                Ok(InitResult::Done) => self.state.lock().initialized = true,
-                Ok(InitResult::RetryNeeded) => {
-                    // Do nothing. Will be tried next time.
-                }
-                Err(e) => {
-                    error!(
-                        "{}: failed to initialize bettery state (info={:?}): {:#}",
-                        self.debug_label(),
-                        info,
-                        e
-                    );
-                }
+        if !self.battery_init_done() {
+            if let Err(e) = self.initialize_battery_state() {
+                error!(
+                    "{}: failed to initialize bettery state (info={:?}): {:#}",
+                    self.debug_label(),
+                    info,
+                    e
+                );
             }
         }
 
@@ -759,14 +786,15 @@ mod tests {
         )
         .unwrap();
 
-        // First call should return RetryNeeded due to rate limiting.
+        assert!(matches!(battery.initialize_battery_state(), Ok(())));
+
+        // First initialization status should be pending due to rate limiting
         assert!(matches!(
-            battery.initialize_battery_state(),
-            Ok(InitResult::RetryNeeded)
+            *battery.init_state.lock(),
+            BatInitializationState::Pending(_)
         ));
-        // initialized should still be false
-        assert!(!battery.state.lock().initialized);
 
+        *battery.init_state.lock() = BatInitializationState::NotYet;
         let old_time = now - Duration::from_millis(GoldfishBattery::POWERD_REQ_INTERVAL_MS + 500);
         // Replace the factory function to simulate an older last_request_time
         battery.create_powerd_client = Some(Box::new(move || {
@@ -774,9 +802,11 @@ mod tests {
         }));
 
         // Second call with old time should succeed.
+        assert!(matches!(battery.initialize_battery_state(), Ok(())));
+
         assert!(matches!(
-            battery.initialize_battery_state(),
-            Ok(InitResult::Done)
+            *battery.init_state.lock(),
+            BatInitializationState::Done,
         ));
 
         // Check if values are correctly updated.
@@ -795,9 +825,10 @@ mod tests {
         let mut battery =
             GoldfishBattery::new(mmio_base, irq_num, irq_evt, tube, None, None).unwrap();
 
+        assert!(matches!(battery.initialize_battery_state(), Ok(())));
         assert!(matches!(
-            battery.initialize_battery_state(),
-            Ok(InitResult::Done)
+            *battery.init_state.lock(),
+            BatInitializationState::NotYet,
         ));
     }
 }
diff --git a/devices/src/irqchip/aarch64.rs b/devices/src/irqchip/aarch64.rs
index f56e6d661..3bff5b344 100644
--- a/devices/src/irqchip/aarch64.rs
+++ b/devices/src/irqchip/aarch64.rs
@@ -2,6 +2,21 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+use aarch64_sys_reg::AArch64SysRegId;
+use aarch64_sys_reg::ICC_AP0R0_EL1;
+use aarch64_sys_reg::ICC_AP0R1_EL1;
+use aarch64_sys_reg::ICC_AP0R2_EL1;
+use aarch64_sys_reg::ICC_AP0R3_EL1;
+use aarch64_sys_reg::ICC_AP1R0_EL1;
+use aarch64_sys_reg::ICC_AP1R1_EL1;
+use aarch64_sys_reg::ICC_AP1R2_EL1;
+use aarch64_sys_reg::ICC_AP1R3_EL1;
+use aarch64_sys_reg::ICC_BPR0_EL1;
+use aarch64_sys_reg::ICC_BPR1_EL1;
+use aarch64_sys_reg::ICC_IGRPEN0_EL1;
+use aarch64_sys_reg::ICC_IGRPEN1_EL1;
+use aarch64_sys_reg::ICC_PMR_EL1;
+use aarch64_sys_reg::ICC_SRE_EL1;
 use anyhow::anyhow;
 use base::Result;
 use hypervisor::DeviceKind;
@@ -35,3 +50,185 @@ pub trait IrqChipAArch64: IrqChip {
         Err(anyhow!("Restore not yet implemented for AArch64"))
     }
 }
+
+// List of registers taken from https://web.git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kvm/vgic-sys-reg-v3.c?h=v6.13.5#n300
+pub fn icc_regs(prio_bits: u8) -> anyhow::Result<Vec<AArch64SysRegId>> {
+    let mut regs = vec![
+        ICC_PMR_EL1,
+        ICC_BPR0_EL1,
+        ICC_BPR1_EL1,
+        ICC_SRE_EL1,
+        ICC_IGRPEN0_EL1,
+        ICC_IGRPEN1_EL1,
+    ];
+    icc_ap0r_regs(&mut regs, prio_bits)?;
+    icc_ap1r_regs(&mut regs, prio_bits)?;
+    Ok(regs)
+}
+
+fn icc_ap0r_regs(regs: &mut Vec<AArch64SysRegId>, prio_bits: u8) -> anyhow::Result<()> {
+    if prio_bits > 8 || prio_bits == 0 {
+        return Err(anyhow!("Invalid number of priroity bits: {prio_bits}"));
+    }
+    regs.push(ICC_AP0R0_EL1);
+    if prio_bits >= 6 {
+        regs.push(ICC_AP0R1_EL1);
+    }
+    if prio_bits >= 7 {
+        regs.push(ICC_AP0R2_EL1);
+        regs.push(ICC_AP0R3_EL1);
+    }
+    Ok(())
+}
+
+fn icc_ap1r_regs(regs: &mut Vec<AArch64SysRegId>, prio_bits: u8) -> anyhow::Result<()> {
+    if prio_bits > 8 || prio_bits == 0 {
+        return Err(anyhow!("Invalid number of priroity bits: {prio_bits}"));
+    }
+    regs.push(ICC_AP1R0_EL1);
+    if prio_bits >= 6 {
+        regs.push(ICC_AP1R1_EL1);
+    }
+    if prio_bits >= 7 {
+        regs.push(ICC_AP1R2_EL1);
+        regs.push(ICC_AP1R3_EL1);
+    }
+    Ok(())
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn icc_ap0r_1() {
+        let mut regs = Vec::new();
+        icc_ap0r_regs(&mut regs, 4).unwrap();
+        assert_eq!(
+            regs,
+            vec![AArch64SysRegId::new_unchecked(
+                0b11, 0b000, 0b1100, 0b1000, 0b100
+            ),]
+        );
+    }
+
+    #[test]
+    fn icc_ap0r_2() {
+        let mut regs = Vec::new();
+        icc_ap0r_regs(&mut regs, 6).unwrap();
+        assert_eq!(
+            regs,
+            vec![
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b100),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b101),
+            ]
+        );
+    }
+
+    #[test]
+    fn icc_ap0r_4() {
+        let mut regs = Vec::new();
+        icc_ap0r_regs(&mut regs, 7).unwrap();
+        assert_eq!(
+            regs,
+            vec![
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b100),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b101),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b110),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1000, 0b111),
+            ]
+        );
+    }
+
+    #[test]
+    #[should_panic]
+    fn icc_ap0r_invalid_0() {
+        let mut regs = Vec::new();
+        icc_ap0r_regs(&mut regs, 0).unwrap();
+    }
+
+    #[test]
+    #[should_panic]
+    fn icc_ap0r_invalid_5() {
+        let mut regs = Vec::new();
+        icc_ap0r_regs(&mut regs, 9).unwrap();
+    }
+
+    #[test]
+    fn icc_ap1r_1() {
+        let mut regs = Vec::new();
+        icc_ap1r_regs(&mut regs, 5).unwrap();
+        assert_eq!(
+            regs,
+            vec![AArch64SysRegId::new_unchecked(
+                0b11, 0b000, 0b1100, 0b1001, 0b000
+            ),]
+        );
+    }
+
+    #[test]
+    fn icc_ap1r_2() {
+        let mut regs = Vec::new();
+        icc_ap1r_regs(&mut regs, 6).unwrap();
+        assert_eq!(
+            regs,
+            vec![
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b000),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b001),
+            ]
+        );
+    }
+
+    #[test]
+    fn icc_ap1r_4() {
+        let mut regs = Vec::new();
+        icc_ap1r_regs(&mut regs, 8).unwrap();
+        assert_eq!(
+            regs,
+            vec![
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b000),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b001),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b010),
+                AArch64SysRegId::new_unchecked(0b11, 0b000, 0b1100, 0b1001, 0b011),
+            ]
+        );
+    }
+
+    #[test]
+    #[should_panic]
+    fn icc_ap1r_invalid_0() {
+        let mut regs = Vec::new();
+        icc_ap1r_regs(&mut regs, 0).unwrap();
+    }
+
+    #[test]
+    #[should_panic]
+    fn icc_ap1r_invalid_5() {
+        let mut regs = Vec::new();
+        icc_ap1r_regs(&mut regs, 9).unwrap();
+    }
+
+    #[test]
+    fn icc_regs_pribits_8() {
+        let regs = icc_regs(8).unwrap();
+        assert_eq!(
+            regs,
+            [
+                ICC_PMR_EL1,
+                ICC_BPR0_EL1,
+                ICC_BPR1_EL1,
+                ICC_SRE_EL1,
+                ICC_IGRPEN0_EL1,
+                ICC_IGRPEN1_EL1,
+                ICC_AP0R0_EL1,
+                ICC_AP0R1_EL1,
+                ICC_AP0R2_EL1,
+                ICC_AP0R3_EL1,
+                ICC_AP1R0_EL1,
+                ICC_AP1R1_EL1,
+                ICC_AP1R2_EL1,
+                ICC_AP1R3_EL1,
+            ]
+        );
+    }
+}
diff --git a/devices/src/irqchip/geniezone/mod.rs b/devices/src/irqchip/geniezone/mod.rs
index 77124a7f7..972b8a13d 100644
--- a/devices/src/irqchip/geniezone/mod.rs
+++ b/devices/src/irqchip/geniezone/mod.rs
@@ -9,7 +9,6 @@ use base::Error;
 use base::Event;
 use base::Result;
 use hypervisor::geniezone::geniezone_sys::*;
-use hypervisor::geniezone::GeniezoneVcpu;
 use hypervisor::geniezone::GeniezoneVm;
 use hypervisor::DeviceKind;
 use hypervisor::IrqRoute;
@@ -45,7 +44,6 @@ fn default_irq_routing_table() -> Vec<IrqRoute> {
 /// This implementation will use the GZVM API to create and configure the in-kernel irqchip.
 pub struct GeniezoneKernelIrqChip {
     pub(super) vm: GeniezoneVm,
-    pub(super) vcpus: Arc<Mutex<Vec<Option<GeniezoneVcpu>>>>,
     device_kind: DeviceKind,
     pub(super) routes: Arc<Mutex<Vec<IrqRoute>>>,
 }
@@ -110,7 +108,6 @@ impl GeniezoneKernelIrqChip {
 
         Ok(GeniezoneKernelIrqChip {
             vm,
-            vcpus: Arc::new(Mutex::new((0..num_vcpus).map(|_| None).collect())),
             device_kind,
             routes: Arc::new(Mutex::new(default_irq_routing_table())),
         })
@@ -119,7 +116,6 @@ impl GeniezoneKernelIrqChip {
     pub(super) fn arch_try_clone(&self) -> Result<Self> {
         Ok(GeniezoneKernelIrqChip {
             vm: self.vm.try_clone()?,
-            vcpus: self.vcpus.clone(),
             device_kind: self.device_kind,
             routes: self.routes.clone(),
         })
@@ -151,11 +147,7 @@ impl IrqChipAArch64 for GeniezoneKernelIrqChip {
 /// This IrqChip only works with Geniezone so we only implement it for GeniezoneVcpu.
 impl IrqChip for GeniezoneKernelIrqChip {
     /// Add a vcpu to the irq chip.
-    fn add_vcpu(&mut self, vcpu_id: usize, vcpu: &dyn Vcpu) -> Result<()> {
-        let vcpu: &GeniezoneVcpu = vcpu
-            .downcast_ref()
-            .expect("GeniezoneKernelIrqChip::add_vcpu called with non-GeniezoneVcpu");
-        self.vcpus.lock()[vcpu_id] = Some(vcpu.try_clone()?);
+    fn add_vcpu(&mut self, _vcpu_id: usize, _vcpu: &dyn Vcpu) -> Result<()> {
         Ok(())
     }
 
diff --git a/devices/src/irqchip/kvm/aarch64.rs b/devices/src/irqchip/kvm/aarch64.rs
index 179c96631..e10684fcc 100644
--- a/devices/src/irqchip/kvm/aarch64.rs
+++ b/devices/src/irqchip/kvm/aarch64.rs
@@ -2,8 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+use std::collections::BTreeMap;
 use std::sync::Arc;
 
+use aarch64_sys_reg::ICC_CTLR_EL1;
+use anyhow::anyhow;
 use anyhow::Context;
 use base::errno_result;
 use base::ioctl_with_ref;
@@ -13,11 +16,16 @@ use hypervisor::kvm::KvmVcpu;
 use hypervisor::kvm::KvmVm;
 use hypervisor::DeviceKind;
 use hypervisor::IrqRoute;
+use hypervisor::MPState;
+use hypervisor::VcpuAArch64;
 use hypervisor::Vm;
 use kvm_sys::*;
+use serde::Deserialize;
+use serde::Serialize;
 use snapshot::AnySnapshot;
 use sync::Mutex;
 
+use crate::icc_regs;
 use crate::IrqChip;
 use crate::IrqChipAArch64;
 
@@ -189,14 +197,67 @@ impl IrqChipAArch64 for KvmKernelIrqChip {
                 return errno_result()
                     .context("ioctl KVM_SET_DEVICE_ATTR for save_gic_attr failed.")?;
             }
+            let mut cpu_specific: BTreeMap<u64, CpuSpecificState> = BTreeMap::new();
+            let vcpus = self.vcpus.lock();
+            for vcpu in vcpus.iter().flatten() {
+                let mut cpu_sys_regs: BTreeMap<u16, u64> = BTreeMap::new();
+                let mut redist_regs: Vec<u32> = Vec::new();
+                let mpidr = mpidr_concat_aff(vcpu.get_mpidr()?);
+                // SAFETY:
+                // Safe because we are specifying CPU SYSREGS, which is 64 bits.
+                // https://docs.kernel.org/virt/kvm/devices/arm-vgic-v3.html
+                let ctlr = unsafe {
+                    get_kvm_device_attr_u64(
+                        &self.vgic,
+                        KVM_DEV_ARM_VGIC_GRP_CPU_SYSREGS,
+                        mpidr | ICC_CTLR_EL1.encoded() as u64,
+                    )?
+                };
+                // The reported number of priority bits is missing 1, as per ARM documentation.
+                // See register ICC_CTLR_EL1 for more information. Add the missing 1.
+                let prio_bits = (((ctlr & 0x700) >> 8) + 1) as u8;
+                cpu_sys_regs.insert(ICC_CTLR_EL1.encoded(), ctlr);
+                get_cpu_vgic_regs(&self.vgic, &mut cpu_sys_regs, mpidr, prio_bits)?;
+                redist_regs.append(&mut get_redist_regs(&self.vgic, mpidr)?);
+                cpu_specific.insert(
+                    mpidr,
+                    CpuSpecificState {
+                        cpu_sys_regs,
+                        redist_regs,
+                        mp_state: MPState::from(&vcpu.get_mp_state()?),
+                    },
+                );
+            }
+            AnySnapshot::to_any(VgicSnapshot {
+                cpu_specific,
+                dist_regs: get_dist_regs(&self.vgic)?,
+            })
+        } else {
+            Err(anyhow!("Unsupported VGIC version for snapshot"))
         }
-        AnySnapshot::to_any(())
     }
 
-    fn restore(&mut self, _data: AnySnapshot, _vcpus_num: usize) -> anyhow::Result<()> {
-        // SAVE_PENDING_TABLES operation wrote the pending tables into guest memory.
-        // Assumption is that no work is necessary on restore of IrqChip.
-        Ok(())
+    fn restore(&mut self, data: AnySnapshot, _vcpus_num: usize) -> anyhow::Result<()> {
+        if self.device_kind == DeviceKind::ArmVgicV3 {
+            // SAVE_PENDING_TABLES operation wrote the pending tables into guest memory.
+            let deser: VgicSnapshot =
+                AnySnapshot::from_any(data).context("Failed to deserialize vgic data")?;
+            let vcpus = self.vcpus.lock();
+            for vcpu in vcpus.iter().flatten() {
+                let mpidr = mpidr_concat_aff(vcpu.get_mpidr()?);
+                let mpidr_data = deser
+                    .cpu_specific
+                    .get(&mpidr)
+                    .with_context(|| format!("CPU with MPIDR {} does not exist", mpidr))?;
+                set_cpu_vgic_regs(&self.vgic, mpidr, &mpidr_data.cpu_sys_regs)?;
+                set_redist_regs(&self.vgic, mpidr, &mpidr_data.redist_regs)?;
+                vcpu.set_mp_state(&kvm_mp_state::from(&mpidr_data.mp_state))?;
+            }
+            set_dist_regs(&self.vgic, &deser.dist_regs)?;
+            Ok(())
+        } else {
+            Err(anyhow!("Unsupported VGIC version for restore"))
+        }
     }
 
     fn finalize(&self) -> Result<()> {
@@ -216,3 +277,249 @@ impl IrqChipAArch64 for KvmKernelIrqChip {
         Ok(())
     }
 }
+
+#[derive(Serialize, Deserialize)]
+struct VgicSnapshot {
+    cpu_specific: BTreeMap<u64, CpuSpecificState>,
+    dist_regs: Vec<u32>,
+}
+
+#[derive(Serialize, Deserialize)]
+struct CpuSpecificState {
+    // Key: Register ID.
+    cpu_sys_regs: BTreeMap<u16, u64>,
+    redist_regs: Vec<u32>,
+    mp_state: MPState,
+}
+
+// # Safety
+// Unsafe if incorrect group or attr (offset) provided.
+// The caller must ensure the group is 32 bits and attr is for a 32 bit value
+unsafe fn get_kvm_device_attr_u32(
+    vgic: &SafeDescriptor,
+    group: u32,
+    attr: u64,
+) -> anyhow::Result<u32> {
+    let mut val: u32 = 0;
+    let device_attr = kvm_device_attr {
+        group,
+        attr,
+        addr: (&mut val as *mut u32) as u64,
+        flags: 0,
+    };
+    // SAFETY:
+    // Unsafe if wrong group is provided, which could lead to trying to read from a 64 bit register
+    // to a 32 bit register.
+    // Unsafe if wrong attr (offset) is provided
+    let ret = unsafe { ioctl_with_ref(vgic, KVM_GET_DEVICE_ATTR, &device_attr) };
+    if ret != 0 {
+        errno_result().with_context(|| {
+            format!(
+                "ioctl KVM_GET_DEVICE_ATTR_u32 for attr:{} failed.",
+                device_attr.attr
+            )
+        })
+    } else {
+        Ok(val)
+    }
+}
+
+// # Safety
+// Unsafe if incorrect group or attr (offset) provided.
+// The caller must ensure the group is 32 bits and attr is for a 64 bit value
+unsafe fn get_kvm_device_attr_u64(
+    vgic: &SafeDescriptor,
+    group: u32,
+    attr: u64,
+) -> anyhow::Result<u64> {
+    let mut val: u64 = 0;
+    let device_attr = kvm_device_attr {
+        group,
+        attr,
+        addr: (&mut val as *mut u64) as u64,
+        flags: 0,
+    };
+    // SAFETY:
+    // Unsafe  if wrong group is passed, which could lead to trying to read from a 32 bit register
+    // to a 64 bit register. The read will succeed but the attr (offset) would need to be correct,
+    // otherwise data could be skipped.
+    // Unsafe if wrong attr (offset) is provided
+    let ret = unsafe { ioctl_with_ref(vgic, KVM_GET_DEVICE_ATTR, &device_attr) };
+    if ret != 0 {
+        errno_result().with_context(|| {
+            format!(
+                "ioctl KVM_GET_DEVICE_ATTR_u64 for attr:{} failed.",
+                device_attr.attr
+            )
+        })
+    } else {
+        Ok(val)
+    }
+}
+
+// # Safety
+// Unsafe if incorrect group or attr (offset) provided.
+// The caller must ensure the group is 32 bits and attr is for a 32 bit value
+unsafe fn set_kvm_device_attr_u32(
+    vgic: &SafeDescriptor,
+    group: u32,
+    attr: u64,
+    val: &u32,
+) -> anyhow::Result<()> {
+    let device_attr = kvm_device_attr {
+        group,
+        attr,
+        addr: (val as *const u32) as u64,
+        flags: 0,
+    };
+    // SAFETY:
+    // Unsafe if the group provided is incorrect, 64 bits may be written to a 32 bit range
+    // Unsafe if the wrong offset is provided
+    let ret = unsafe { ioctl_with_ref(vgic, KVM_SET_DEVICE_ATTR, &device_attr) };
+    if ret != 0 {
+        errno_result().with_context(|| {
+            format!(
+                "ioctl KVM_SET_DEVICE_ATTR_u32 for attr:{} failed.",
+                device_attr.attr
+            )
+        })
+    } else {
+        Ok(())
+    }
+}
+
+// # Safety
+// Unsafe if incorrect group or attr (offset) provided.
+// The caller must ensure the group is 32 bits and attr is for a 64 bit value
+unsafe fn set_kvm_device_attr_u64(
+    vgic: &SafeDescriptor,
+    group: u32,
+    attr: u64,
+    val: &u64,
+) -> anyhow::Result<()> {
+    let device_attr = kvm_device_attr {
+        group,
+        attr,
+        addr: (val as *const u64) as u64,
+        flags: 0,
+    };
+    // SAFETY:
+    // Unsafe if the wrong group, 32 bits may be written to a 64 bit range,
+    // potentially overwriting other the higher 32 bits of a 64 bit register
+    // Unsafe if the wrong offset is provided
+    let ret = unsafe { ioctl_with_ref(vgic, KVM_SET_DEVICE_ATTR, &device_attr) };
+    if ret != 0 {
+        errno_result().with_context(|| {
+            format!(
+                "ioctl KVM_SET_DEVICE_ATTR_u64 for attr:{} failed.",
+                device_attr.attr
+            )
+        })
+    } else {
+        Ok(())
+    }
+}
+
+fn get_cpu_vgic_regs(
+    vgic: &SafeDescriptor,
+    vgic_data: &mut BTreeMap<u16, u64>,
+    mpidr: u64,
+    prio_bits: u8,
+) -> anyhow::Result<()> {
+    for reg in icc_regs(prio_bits)? {
+        let offset = reg.encoded();
+        // SAFETY:
+        // Safe because we are specifying CPU SYSREGS, which is 64 bits.
+        let val = unsafe {
+            get_kvm_device_attr_u64(
+                vgic,
+                KVM_DEV_ARM_VGIC_GRP_CPU_SYSREGS,
+                mpidr | offset as u64,
+            )?
+        };
+        vgic_data.insert(offset, val);
+    }
+    Ok(())
+}
+
+fn get_redist_regs(vgic: &SafeDescriptor, mpidr: u64) -> anyhow::Result<Vec<u32>> {
+    let mut vgic_data: Vec<u32> = Vec::new();
+    for offset in (0..AARCH64_GIC_REDIST_SIZE).step_by(4) {
+        // SAFETY:
+        // Safe because we are specifying REDIST REGS, which is 32 bits.
+        let val = unsafe {
+            get_kvm_device_attr_u32(vgic, KVM_DEV_ARM_VGIC_GRP_REDIST_REGS, mpidr | offset)?
+        };
+        vgic_data.push(val);
+    }
+    Ok(vgic_data)
+}
+
+fn get_dist_regs(vgic: &SafeDescriptor) -> anyhow::Result<Vec<u32>> {
+    let mut vgic_data: Vec<u32> = Vec::new();
+    for offset in (0..AARCH64_GIC_DIST_SIZE).step_by(4) {
+        // SAFETY:
+        // Safe because we are specifying DIST REGS, which is 32 bits.
+        let val = unsafe { get_kvm_device_attr_u32(vgic, KVM_DEV_ARM_VGIC_GRP_DIST_REGS, offset)? };
+        vgic_data.push(val);
+    }
+    Ok(vgic_data)
+}
+
+fn set_cpu_vgic_regs(
+    vgic: &SafeDescriptor,
+    mpidr: u64,
+    data: &BTreeMap<u16, u64>,
+) -> anyhow::Result<()> {
+    for (offset, val) in data.iter() {
+        // SAFETY:
+        // Safe because we are specifying CPU SYSREGS, which is 64 bits.
+        unsafe {
+            set_kvm_device_attr_u64(
+                vgic,
+                KVM_DEV_ARM_VGIC_GRP_CPU_SYSREGS,
+                mpidr | *offset as u64,
+                val,
+            )?
+        };
+    }
+    Ok(())
+}
+
+fn set_redist_regs(vgic: &SafeDescriptor, mpidr: u64, data: &[u32]) -> anyhow::Result<()> {
+    let mut offset = 0;
+    for val in data.iter() {
+        // SAFETY:
+        // Safe because we are specifying REDIST REGS, which is 32 bits.
+        unsafe {
+            set_kvm_device_attr_u32(vgic, KVM_DEV_ARM_VGIC_GRP_REDIST_REGS, mpidr | offset, val)?
+        };
+        // Step by 4 for offset
+        offset += 4;
+    }
+    Ok(())
+}
+
+fn set_dist_regs(vgic: &SafeDescriptor, data: &[u32]) -> anyhow::Result<()> {
+    let mut offset = 0;
+    for val in data.iter() {
+        // SAFETY:
+        // Safe because we are specifying DIST REGS, which is 32 bits.
+        unsafe { set_kvm_device_attr_u32(vgic, KVM_DEV_ARM_VGIC_GRP_DIST_REGS, offset, val)? };
+        // Step by 4 for offset
+        offset += 4;
+    }
+    Ok(())
+}
+
+fn mpidr_concat_aff(mpidr: u64) -> u64 {
+    // https://docs.kernel.org/virt/kvm/devices/arm-vgic-v3.html
+    // MPIDR described as Aff3 | Aff2 | Aff1 | Aff0. (32 bits).
+    // The structure of the returned value of MPIDR in Arm is a bit different:
+    // https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/MPIDR-EL1--Multiprocessor-Affinity-Register
+    // RES0 | Aff3 | RES1 | U | RES0 | MT | Aff2 | Aff1 | Aff0
+    // 63-40| 39-32|  31  | 30|  29  | 24 | 23-16| 15-8 | 7-0
+    let mpidr_aff_concat: u32 = ((mpidr & 0xFF << 32) >> 8) as u32 | mpidr as u32 & 0x00FFFFFF;
+    ((mpidr_aff_concat as u64) << KVM_DEV_ARM_VGIC_V3_MPIDR_SHIFT)
+        & KVM_DEV_ARM_VGIC_V3_MPIDR_MASK as u64
+}
diff --git a/devices/src/irqchip/kvm/mod.rs b/devices/src/irqchip/kvm/mod.rs
index 70e7d9394..78240416c 100644
--- a/devices/src/irqchip/kvm/mod.rs
+++ b/devices/src/irqchip/kvm/mod.rs
@@ -6,17 +6,12 @@ use base::error;
 use base::Error;
 use base::Event;
 use base::Result;
+#[cfg(target_arch = "x86_64")]
+use hypervisor::kvm::KvmCap;
 use hypervisor::kvm::KvmVcpu;
-use hypervisor::HypervisorCap;
 use hypervisor::IrqRoute;
 use hypervisor::MPState;
 use hypervisor::Vcpu;
-#[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
-use hypervisor::VmAArch64;
-#[cfg(target_arch = "riscv64")]
-use hypervisor::VmRiscv64;
-#[cfg(target_arch = "x86_64")]
-use hypervisor::VmX86_64;
 use kvm_sys::kvm_mp_state;
 use resources::SystemAllocator;
 
@@ -212,10 +207,9 @@ impl IrqChip for KvmKernelIrqChip {
 
     fn check_capability(&self, c: IrqChipCap) -> bool {
         match c {
-            IrqChipCap::TscDeadlineTimer => self
-                .vm
-                .get_hypervisor()
-                .check_capability(HypervisorCap::TscDeadlineTimer),
+            #[cfg(target_arch = "x86_64")]
+            IrqChipCap::TscDeadlineTimer => self.vm.check_raw_capability(KvmCap::TscDeadlineTimer),
+            #[cfg(target_arch = "x86_64")]
             IrqChipCap::X2Apic => true,
             IrqChipCap::MpStateGetSet => true,
         }
diff --git a/devices/src/irqchip/kvm/riscv64.rs b/devices/src/irqchip/kvm/riscv64.rs
index 56a0a2163..586772a13 100644
--- a/devices/src/irqchip/kvm/riscv64.rs
+++ b/devices/src/irqchip/kvm/riscv64.rs
@@ -79,8 +79,8 @@ impl AiaDescriptor {
             flags: 0,
         };
 
-        // Safe because we allocated the struct that's being passed in, and raw_aia_mode is pointing
-        // to a uniquely owned local, mutable variable.
+        // SAFETY: Safe because we allocated the struct that's being passed in, and raw_aia_mode is
+        // pointing to a uniquely owned local, mutable variable.
         let ret = unsafe { ioctl_with_ref(self, KVM_SET_DEVICE_ATTR, &init_attr) };
         if ret != 0 {
             return errno_result();
@@ -99,8 +99,8 @@ impl AiaDescriptor {
             flags: 0,
         };
 
-        // Safe because we allocated the struct that's being passed in, and raw_num_ids is pointing
-        // to a uniquely owned local, mutable variable.
+        // SAFETY: Safe because we allocated the struct that's being passed in, and raw_num_ids is
+        // pointing to a uniquely owned local, mutable variable.
         let ret = unsafe { ioctl_with_ref(self, KVM_GET_DEVICE_ATTR, &aia_num_ids_attr) };
         if ret != 0 {
             return errno_result();
@@ -117,8 +117,8 @@ impl AiaDescriptor {
             addr: raw_aia_mode as u64,
             flags: 0,
         };
-        // Safe because we allocated the struct that's being passed in, and raw_aia_mode is pointing
-        // to a uniquely owned local, mutable variable.
+        // SAFETY: Safe because we allocated the struct that's being passed in, and raw_aia_mode is
+        // pointing to a uniquely owned local, mutable variable.
         let ret = unsafe { ioctl_with_ref(self, KVM_GET_DEVICE_ATTR, &aia_mode_attr) };
         if ret != 0 {
             return errno_result();
@@ -134,8 +134,8 @@ impl AiaDescriptor {
             addr: raw_num_sources as u64,
             flags: 0,
         };
-        // Safe because we allocated the struct that's being passed in, and raw_aia_mode is pointing
-        // to a uniquely owned local, mutable variable.
+        // SAFETY: Safe because we allocated the struct that's being passed in, and raw_aia_mode is
+        // pointing to a uniquely owned local, mutable variable.
         let ret = unsafe { ioctl_with_ref(self, KVM_SET_DEVICE_ATTR, &kvm_attr) };
         if ret != 0 {
             return errno_result();
@@ -151,8 +151,8 @@ impl AiaDescriptor {
             addr: raw_hart_bits as u64,
             flags: 0,
         };
-        // Safe because we allocated the struct that's being passed in, and raw_aia_mode is pointing
-        // to a uniquely owned local, mutable variable.
+        // SAFETY: Safe because we allocated the struct that's being passed in, and raw_aia_mode is
+        // pointing to a uniquely owned local, mutable variable.
         let ret = unsafe { ioctl_with_ref(self, KVM_SET_DEVICE_ATTR, &kvm_attr) };
         if ret != 0 {
             return errno_result();
@@ -170,8 +170,8 @@ impl AiaDescriptor {
             addr: raw_aplic_addr as u64,
             flags: 0,
         };
-        // Safe because we allocated the struct that's being passed in, and raw_aplic_addr is
-        // pointing to a uniquely owned local, mutable variable.
+        // SAFETY: Safe because we allocated the struct that's being passed in, and raw_aplic_addr
+        // is pointing to a uniquely owned local, mutable variable.
         let ret = unsafe { ioctl_with_ref(self, KVM_SET_DEVICE_ATTR, &kvm_attr) };
         if ret != 0 {
             return errno_result();
@@ -185,8 +185,8 @@ impl AiaDescriptor {
                 addr: raw_imsic_addr as u64,
                 flags: 0,
             };
-            // Safe because we allocated the struct that's being passed in, and raw_imsic_addr is
-            // pointing to a uniquely owned local, mutable variable.
+            // SAFETY: Safe because we allocated the struct that's being passed in, and
+            // raw_imsic_addr is pointing to a uniquely owned local, mutable variable.
             let ret = unsafe { ioctl_with_ref(self, KVM_SET_DEVICE_ATTR, &kvm_attr) };
             if ret != 0 {
                 return errno_result();
diff --git a/devices/src/irqchip/kvm/x86_64.rs b/devices/src/irqchip/kvm/x86_64.rs
index 903b80a12..b788b2f49 100644
--- a/devices/src/irqchip/kvm/x86_64.rs
+++ b/devices/src/irqchip/kvm/x86_64.rs
@@ -15,9 +15,9 @@ use base::Event;
 use base::FakeClock as Clock;
 use base::Result;
 use base::Tube;
+use hypervisor::kvm::KvmCap;
 use hypervisor::kvm::KvmVcpu;
 use hypervisor::kvm::KvmVm;
-use hypervisor::HypervisorCap;
 use hypervisor::IoapicState;
 use hypervisor::IrqRoute;
 use hypervisor::IrqSource;
@@ -30,7 +30,6 @@ use hypervisor::PitState;
 use hypervisor::Vcpu;
 use hypervisor::VcpuX86_64;
 use hypervisor::Vm;
-use hypervisor::VmX86_64;
 use kvm_sys::*;
 use resources::SystemAllocator;
 use serde::Deserialize;
@@ -767,10 +766,7 @@ impl IrqChip for KvmSplitIrqChip {
 
     fn check_capability(&self, c: IrqChipCap) -> bool {
         match c {
-            IrqChipCap::TscDeadlineTimer => self
-                .vm
-                .get_hypervisor()
-                .check_capability(HypervisorCap::TscDeadlineTimer),
+            IrqChipCap::TscDeadlineTimer => self.vm.check_raw_capability(KvmCap::TscDeadlineTimer),
             IrqChipCap::X2Apic => true,
             IrqChipCap::MpStateGetSet => true,
         }
diff --git a/devices/src/irqchip/mod.rs b/devices/src/irqchip/mod.rs
index 30d05951d..33136e3c3 100644
--- a/devices/src/irqchip/mod.rs
+++ b/devices/src/irqchip/mod.rs
@@ -262,8 +262,10 @@ pub trait IrqChip: Send {
 #[derive(Clone, Copy, Debug, PartialEq, Eq)]
 pub enum IrqChipCap {
     /// APIC TSC-deadline timer mode.
+    #[cfg(target_arch = "x86_64")]
     TscDeadlineTimer,
     /// Extended xAPIC (x2APIC) standard.
+    #[cfg(target_arch = "x86_64")]
     X2Apic,
     /// Irqchip exposes mp_state_get/set methods. Calling these methods on chips
     /// without this capability will result in undefined behavior.
diff --git a/devices/src/lib.rs b/devices/src/lib.rs
index e72afad90..1375aa3eb 100644
--- a/devices/src/lib.rs
+++ b/devices/src/lib.rs
@@ -44,7 +44,6 @@ cfg_if::cfg_if! {
 }
 
 use std::sync::Arc;
-use std::time::Instant;
 
 use anyhow::anyhow;
 use anyhow::Context;
@@ -60,7 +59,6 @@ use serde::Serialize;
 use vm_control::DeviceControlCommand;
 use vm_control::DevicesState;
 use vm_control::VmResponse;
-use vm_memory::GuestMemory;
 
 pub use self::acpi::ACPIPMFixedEvent;
 pub use self::acpi::ACPIPMResource;
@@ -210,7 +208,6 @@ pub enum IommuDevType {
 // Thread that handles commands sent to devices - such as snapshot, sleep, suspend
 // Created when the VM is first created, and re-created on resumption of the VM.
 pub fn create_devices_worker_thread(
-    guest_memory: GuestMemory,
     io_bus: Arc<Bus>,
     mmio_bus: Arc<Bus>,
     device_ctrl_resp: Tube,
@@ -221,9 +218,9 @@ pub fn create_devices_worker_thread(
             let ex = Executor::new().expect("Failed to create an executor");
 
             let async_control = AsyncTube::new(&ex, device_ctrl_resp).unwrap();
-            match ex.run_until(async move {
-                handle_command_tube(async_control, guest_memory, io_bus, mmio_bus).await
-            }) {
+            match ex.run_until(
+                async move { handle_command_tube(async_control, io_bus, mmio_bus).await },
+            ) {
                 Ok(_) => {}
                 Err(e) => {
                     error!("Device control thread exited with error: {}", e);
@@ -256,41 +253,10 @@ fn wake_buses(buses: &[&Bus]) {
     }
 }
 
-// Use 64MB chunks when writing the memory snapshot (if encryption is used).
-const MEMORY_SNAP_ENCRYPTED_CHUNK_SIZE_BYTES: usize = 1024 * 1024 * 64;
-
 async fn snapshot_handler(
     snapshot_writer: snapshot::SnapshotWriter,
-    guest_memory: &GuestMemory,
     buses: &[&Bus],
-    compress_memory: bool,
 ) -> anyhow::Result<()> {
-    let mem_snap_start = Instant::now();
-    // SAFETY:
-    // VM & devices are stopped.
-    let guest_memory_metadata = unsafe {
-        guest_memory
-            .snapshot(
-                &mut snapshot_writer
-                    .raw_fragment_with_chunk_size("mem", MEMORY_SNAP_ENCRYPTED_CHUNK_SIZE_BYTES)?,
-                compress_memory,
-            )
-            .context("failed to snapshot memory")?
-    };
-    snapshot_writer.write_fragment("mem_metadata", &guest_memory_metadata)?;
-
-    let mem_snap_duration_ms = mem_snap_start.elapsed().as_millis();
-    info!(
-        "snapshot: memory snapshotted {}MB in {}ms",
-        guest_memory.memory_size() / 1024 / 1024,
-        mem_snap_duration_ms
-    );
-    metrics::log_metric_with_details(
-        metrics::MetricEventType::SnapshotSaveMemoryLatency,
-        mem_snap_duration_ms as i64,
-        &metrics_events::RecordDetails {},
-    );
-
     for (i, bus) in buses.iter().enumerate() {
         bus.snapshot_devices(&snapshot_writer.add_namespace(&format!("bus{i}"))?)
             .context("failed to snapshot bus devices")?;
@@ -302,33 +268,10 @@ async fn snapshot_handler(
     Ok(())
 }
 
-async fn restore_handler(
+async fn restore_devices(
     snapshot_reader: snapshot::SnapshotReader,
-    guest_memory: &GuestMemory,
     buses: &[&Bus],
 ) -> anyhow::Result<()> {
-    let mem_restore_start = Instant::now();
-    let guest_memory_metadata = snapshot_reader.read_fragment("mem_metadata")?;
-    // SAFETY:
-    // VM & devices are stopped.
-    unsafe {
-        guest_memory.restore(
-            guest_memory_metadata,
-            &mut snapshot_reader.raw_fragment("mem")?,
-        )?
-    };
-    let mem_restore_duration_ms = mem_restore_start.elapsed().as_millis();
-    info!(
-        "snapshot: memory restored {}MB in {}ms",
-        guest_memory.memory_size() / 1024 / 1024,
-        mem_restore_duration_ms
-    );
-    metrics::log_metric_with_details(
-        metrics::MetricEventType::SnapshotRestoreMemoryLatency,
-        mem_restore_duration_ms as i64,
-        &metrics_events::RecordDetails {},
-    );
-
     for (i, bus) in buses.iter().enumerate() {
         bus.restore_devices(&snapshot_reader.namespace(&format!("bus{i}"))?)
             .context("failed to restore bus devices")?;
@@ -342,7 +285,6 @@ async fn restore_handler(
 
 async fn handle_command_tube(
     command_tube: AsyncTube,
-    guest_memory: GuestMemory,
     io_bus: Arc<Bus>,
     mmio_bus: Arc<Bus>,
 ) -> anyhow::Result<()> {
@@ -393,18 +335,12 @@ async fn handle_command_tube(
                             .await
                             .context("failed to reply to wake devices request")?;
                     }
-                    DeviceControlCommand::SnapshotDevices {
-                        snapshot_writer,
-                        compress_memory,
-                    } => {
+                    DeviceControlCommand::SnapshotDevices { snapshot_writer } => {
                         assert!(
                             matches!(devices_state, DevicesState::Sleep),
                             "devices must be sleeping to snapshot"
                         );
-                        if let Err(e) =
-                            snapshot_handler(snapshot_writer, &guest_memory, buses, compress_memory)
-                                .await
-                        {
+                        if let Err(e) = snapshot_handler(snapshot_writer, buses).await {
                             error!("failed to snapshot: {:#}", e);
                             command_tube
                                 .send(VmResponse::ErrString(e.to_string()))
@@ -423,8 +359,7 @@ async fn handle_command_tube(
                             "devices must be sleeping to restore"
                         );
                         if let Err(e) =
-                            restore_handler(snapshot_reader, &guest_memory, &[&*io_bus, &*mmio_bus])
-                                .await
+                            restore_devices(snapshot_reader, &[&*io_bus, &*mmio_bus]).await
                         {
                             error!("failed to restore: {:#}", e);
                             command_tube
diff --git a/devices/src/pci/pci_device.rs b/devices/src/pci/pci_device.rs
index e527d97a8..786926f93 100644
--- a/devices/src/pci/pci_device.rs
+++ b/devices/src/pci/pci_device.rs
@@ -440,8 +440,9 @@ pub trait PciDevice: Send + Suspendable {
     fn on_device_sandboxed(&mut self) {}
 
     #[cfg(target_arch = "x86_64")]
-    fn generate_acpi(&mut self, sdts: &mut Vec<SDT>) {
+    fn generate_acpi(&mut self, sdts: &mut Vec<SDT>) -> anyhow::Result<()> {
         let _ = sdts;
+        Ok(())
     }
 
     /// Construct customized acpi method, and return the AML code and
@@ -802,7 +803,7 @@ impl<T: PciDevice + ?Sized> PciDevice for Box<T> {
     }
 
     #[cfg(target_arch = "x86_64")]
-    fn generate_acpi(&mut self, sdts: &mut Vec<SDT>) {
+    fn generate_acpi(&mut self, sdts: &mut Vec<SDT>) -> anyhow::Result<()> {
         (**self).generate_acpi(sdts)
     }
 
diff --git a/devices/src/pci/vfio_pci.rs b/devices/src/pci/vfio_pci.rs
index 0a7be28e6..f9bc3739c 100644
--- a/devices/src/pci/vfio_pci.rs
+++ b/devices/src/pci/vfio_pci.rs
@@ -403,6 +403,18 @@ impl VfioMsixCap {
     }
 }
 
+impl AsRawDescriptors for VfioMsixCap {
+    fn as_raw_descriptors(&self) -> Vec<RawDescriptor> {
+        let mut rds = vec![self.config.as_raw_descriptor()];
+        rds.extend(
+            self.msix_interrupt_evt
+                .iter()
+                .map(|evt| evt.as_raw_descriptor()),
+        );
+        rds
+    }
+}
+
 struct VfioResourceAllocator {
     // The region that is not allocated yet.
     regions: BTreeSet<AddressRange>,
@@ -1654,7 +1666,7 @@ impl PciDevice for VfioPciDevice {
             rds.push(msi_cap.config.get_msi_socket());
         }
         if let Some(msix_cap) = &self.msix_cap {
-            rds.push(msix_cap.lock().config.as_raw_descriptor());
+            rds.extend(msix_cap.lock().as_raw_descriptors());
         }
         rds
     }
diff --git a/devices/src/proxy.rs b/devices/src/proxy.rs
index 9257e65c2..4bf8f8f31 100644
--- a/devices/src/proxy.rs
+++ b/devices/src/proxy.rs
@@ -82,12 +82,8 @@ impl SnapshotFile {
     }
 
     fn read(&mut self) -> anyhow::Result<AnySnapshot> {
-        let data: AnySnapshot = {
-            let mut reader = BufReader::new(&self.file);
-
-            serde_json::from_reader(&mut reader)
-                .context("failed to read snapshot data from snapshot temp file")?
-        };
+        let data: AnySnapshot = ciborium::from_reader(&mut BufReader::new(&self.file))
+            .context("failed to read snapshot data from snapshot temp file")?;
 
         self.file
             .rewind()
@@ -100,7 +96,7 @@ impl SnapshotFile {
         {
             let mut writer = BufWriter::new(&self.file);
 
-            serde_json::to_writer(&mut writer, &data)
+            ciborium::into_writer(&data, &mut writer)
                 .context("failed to write data to snasphot temp file")?;
 
             writer
diff --git a/devices/src/serial_device.rs b/devices/src/serial_device.rs
index e8db88c3d..43bea4f73 100644
--- a/devices/src/serial_device.rs
+++ b/devices/src/serial_device.rs
@@ -181,6 +181,7 @@ pub struct SerialParameters {
     )]
     pub debugcon_port: u16,
     pub pci_address: Option<PciAddress>,
+    pub max_queue_sizes: Option<Vec<u16>>,
 }
 
 /// Temporary structure containing the parameters of a serial port for easy passing to
@@ -191,6 +192,7 @@ pub struct SerialOptions {
     pub out_timestamp: bool,
     pub console: bool,
     pub pci_address: Option<PciAddress>,
+    pub max_queue_sizes: Option<Vec<u16>>,
 }
 
 impl SerialParameters {
@@ -300,6 +302,7 @@ impl SerialParameters {
                 out_timestamp: self.out_timestamp,
                 console: self.console,
                 pci_address: self.pci_address,
+                max_queue_sizes: self.max_queue_sizes.clone(),
             },
             keep_rds.to_vec(),
         ))
@@ -337,6 +340,7 @@ mod tests {
                 out_timestamp: false,
                 debugcon_port: 0x402,
                 pci_address: None,
+                max_queue_sizes: None,
             }
         );
 
@@ -449,7 +453,7 @@ mod tests {
         assert_eq!(params.debugcon_port, 1026);
 
         // all together
-        let params = from_serial_arg("type=stdout,path=/some/path,hardware=virtio-console,num=5,earlycon,console,stdin,input=/some/input,out_timestamp,debugcon_port=12,pci-address=00:0e.0").unwrap();
+        let params = from_serial_arg("type=stdout,path=/some/path,hardware=virtio-console,num=5,earlycon,console,stdin,input=/some/input,out_timestamp,debugcon_port=12,pci-address=00:0e.0,max-queue-sizes=[1,2]").unwrap();
         assert_eq!(
             params,
             SerialParameters {
@@ -471,6 +475,7 @@ mod tests {
                     dev: 14,
                     func: 0
                 }),
+                max_queue_sizes: Some(vec![1, 2]),
             }
         );
 
diff --git a/devices/src/sys/linux/serial_device.rs b/devices/src/sys/linux/serial_device.rs
index 460692955..726d85cee 100644
--- a/devices/src/sys/linux/serial_device.rs
+++ b/devices/src/sys/linux/serial_device.rs
@@ -257,6 +257,7 @@ pub(crate) fn create_unix_stream_serial_device<T: SerialDevice>(
             out_timestamp: param.out_timestamp,
             console: param.console,
             pci_address: param.pci_address,
+            max_queue_sizes: param.max_queue_sizes.clone(),
         },
         keep_rds.to_vec(),
     ))
diff --git a/devices/src/tsc.rs b/devices/src/tsc.rs
index ec253e955..4668c0397 100644
--- a/devices/src/tsc.rs
+++ b/devices/src/tsc.rs
@@ -8,12 +8,12 @@
 #![allow(dead_code)]
 
 use std::arch::x86_64::_rdtsc;
+use std::sync::LazyLock;
 
 use anyhow::anyhow;
 use anyhow::Result;
 use base::debug;
 use base::error;
-use once_cell::sync::Lazy;
 
 mod calibrate;
 mod cpuid;
@@ -29,7 +29,7 @@ fn rdtsc_safe() -> u64 {
 }
 
 // Singleton for getting the state of the host TSCs, to avoid calibrating multiple times.
-static TSC_STATE: Lazy<Option<TscState>> = Lazy::new(|| match calibrate_tsc_state() {
+static TSC_STATE: LazyLock<Option<TscState>> = LazyLock::new(|| match calibrate_tsc_state() {
     Ok(tsc_state) => {
         debug!("Using calibrated tsc frequency: {} Hz", tsc_state.frequency);
         for (core, offset) in tsc_state.offsets.iter().enumerate() {
diff --git a/devices/src/vfio.rs b/devices/src/vfio.rs
index 2115ce29f..c86423302 100644
--- a/devices/src/vfio.rs
+++ b/devices/src/vfio.rs
@@ -16,6 +16,7 @@ use std::path::PathBuf;
 use std::ptr::addr_of_mut;
 use std::slice;
 use std::sync::Arc;
+use std::sync::OnceLock;
 
 use base::error;
 use base::ioctl;
@@ -35,7 +36,6 @@ use cfg_if::cfg_if;
 use data_model::vec_with_array_field;
 use hypervisor::DeviceKind;
 use hypervisor::Vm;
-use once_cell::sync::OnceCell;
 use rand::seq::index::sample;
 use rand::thread_rng;
 use remain::sorted;
@@ -61,8 +61,8 @@ pub enum VfioError {
     ContainerDupError,
     #[error("failed to set container's IOMMU driver type as {0:?}: {1}")]
     ContainerSetIOMMU(IommuType, Error),
-    #[error("failed to create KVM vfio device: {0}")]
-    CreateVfioKvmDevice(Error),
+    #[error("failed to create KVM vfio device")]
+    CreateVfioKvmDevice,
     #[error("failed to get Group Status: {0}")]
     GetGroupStatus(Error),
     #[error("failed to get vfio device fd: {0}")]
@@ -139,7 +139,20 @@ fn get_error() -> Error {
     Error::last()
 }
 
-static KVM_VFIO_FILE: OnceCell<SafeDescriptor> = OnceCell::new();
+static KVM_VFIO_FILE: OnceLock<Option<SafeDescriptor>> = OnceLock::new();
+
+fn create_kvm_vfio_file(vm: &impl Vm) -> Option<&'static SafeDescriptor> {
+    KVM_VFIO_FILE
+        .get_or_init(|| vm.create_device(DeviceKind::Vfio).ok())
+        .as_ref()
+}
+
+fn kvm_vfio_file() -> Option<&'static SafeDescriptor> {
+    match KVM_VFIO_FILE.get() {
+        Some(Some(v)) => Some(v),
+        _ => None,
+    }
+}
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum VfioDeviceType {
@@ -206,9 +219,7 @@ impl KvmVfioPviommu {
 
     #[cfg(all(target_os = "android", target_arch = "aarch64"))]
     fn ioctl_kvm_dev_vfio_pviommu_attach(vm: &impl Vm) -> Result<File> {
-        let kvm_vfio_file = KVM_VFIO_FILE
-            .get_or_try_init(|| vm.create_device(DeviceKind::Vfio))
-            .map_err(VfioError::CreateVfioKvmDevice)?;
+        let kvm_vfio_file = create_kvm_vfio_file(vm).ok_or(VfioError::CreateVfioKvmDevice)?;
 
         let vfio_dev_attr = kvm_sys::kvm_device_attr {
             flags: 0,
@@ -260,9 +271,7 @@ impl KvmVfioPviommu {
         vm: &impl Vm,
         device: &T,
     ) -> Result<kvm_sys::kvm_vfio_iommu_info> {
-        let kvm_vfio_file = KVM_VFIO_FILE
-            .get_or_try_init(|| vm.create_device(DeviceKind::Vfio))
-            .map_err(VfioError::CreateVfioKvmDevice)?;
+        let kvm_vfio_file = create_kvm_vfio_file(vm).ok_or(VfioError::CreateVfioKvmDevice)?;
 
         let mut info = kvm_sys::kvm_vfio_iommu_info {
             device_fd: device.as_raw_descriptor(),
@@ -637,9 +646,7 @@ impl VfioContainer {
             }
         }
 
-        let kvm_vfio_file = KVM_VFIO_FILE
-            .get_or_try_init(|| vm.create_device(DeviceKind::Vfio))
-            .map_err(VfioError::CreateVfioKvmDevice)?;
+        let kvm_vfio_file = create_kvm_vfio_file(vm).ok_or(VfioError::CreateVfioKvmDevice)?;
         group
             .lock()
             .kvm_device_set_group(kvm_vfio_file, KvmVfioGroupOps::Add)?;
@@ -674,7 +681,7 @@ impl VfioContainer {
                 group.lock().reduce_device_num();
             }
             if group.lock().device_num() == 0 {
-                let kvm_vfio_file = KVM_VFIO_FILE.get().expect("kvm vfio file isn't created");
+                let kvm_vfio_file = kvm_vfio_file().expect("kvm vfio file isn't created");
                 if group
                     .lock()
                     .kvm_device_set_group(kvm_vfio_file, KvmVfioGroupOps::Delete)
diff --git a/devices/src/virtcpufreq_v2.rs b/devices/src/virtcpufreq_v2.rs
index 713d8bb3d..26169de56 100644
--- a/devices/src/virtcpufreq_v2.rs
+++ b/devices/src/virtcpufreq_v2.rs
@@ -289,12 +289,14 @@ impl BusDevice for VirtCpufreqV2 {
                         warn!("Error setting uclamp_min: {:#}", e);
                     }
                 } else {
-                    let mut sched_attr = sched_attr::default();
-                    sched_attr.sched_flags = SCHED_FLAG_KEEP_ALL
-                        | SCHED_FLAG_UTIL_CLAMP_MIN
-                        | SCHED_FLAG_UTIL_CLAMP_MAX
-                        | SCHED_FLAG_RESET_ON_FORK;
-                    sched_attr.sched_util_min = util;
+                    let mut sched_attr = sched_attr {
+                        sched_flags: SCHED_FLAG_KEEP_ALL
+                            | SCHED_FLAG_UTIL_CLAMP_MIN
+                            | SCHED_FLAG_UTIL_CLAMP_MAX
+                            | SCHED_FLAG_RESET_ON_FORK,
+                        sched_util_min: util,
+                        ..Default::default()
+                    };
 
                     if self.vcpu_fmax != self.pcpu_fmax {
                         sched_attr.sched_util_max = util;
@@ -307,6 +309,12 @@ impl BusDevice for VirtCpufreqV2 {
                     }
                 }
 
+                // Return early if vcpu_fmax matches pcpu_fmax as that denotes no vCPU throttling
+                // is required.
+                if self.vcpu_fmax == self.pcpu_fmax {
+                    return;
+                }
+
                 self.shared_domain_perf.store(util_raw, Ordering::SeqCst);
                 let timer = self.timer.clone();
                 if self.worker.is_none() {
@@ -381,13 +389,15 @@ pub fn vcpufreq_worker_thread(
     let cpu_set: Vec<usize> = vec![cpu_affinity];
     set_cpu_affinity(cpu_set)?;
 
-    let mut sched_attr = sched_attr::default();
-    sched_attr.sched_flags = SCHED_FLAG_KEEP_ALL
-        | SCHED_FLAG_UTIL_CLAMP_MIN
-        | SCHED_FLAG_UTIL_CLAMP_MAX
-        | SCHED_FLAG_RESET_ON_FORK;
-    sched_attr.sched_util_min = SCHED_CAPACITY_SCALE;
-    sched_attr.sched_util_max = SCHED_CAPACITY_SCALE;
+    let mut sched_attr = sched_attr {
+        sched_flags: SCHED_FLAG_KEEP_ALL
+            | SCHED_FLAG_UTIL_CLAMP_MIN
+            | SCHED_FLAG_UTIL_CLAMP_MAX
+            | SCHED_FLAG_RESET_ON_FORK,
+        sched_util_min: SCHED_CAPACITY_SCALE,
+        sched_util_max: SCHED_CAPACITY_SCALE,
+        ..Default::default()
+    };
     if let Err(e) = sched_setattr(0, &mut sched_attr, 0) {
         warn!("Error setting util value: {}", e);
     }
diff --git a/devices/src/virtio/balloon.rs b/devices/src/virtio/balloon.rs
index c619990b2..60b9b39d8 100644
--- a/devices/src/virtio/balloon.rs
+++ b/devices/src/virtio/balloon.rs
@@ -101,18 +101,11 @@ pub enum BalloonError {
 }
 pub type Result<T> = std::result::Result<T, BalloonError>;
 
-// Balloon implements five virt IO queues: Inflate, Deflate, Stats, WsData, WsCmd.
 const QUEUE_SIZE: u16 = 128;
-const QUEUE_SIZES: &[u16] = &[QUEUE_SIZE, QUEUE_SIZE, QUEUE_SIZE, QUEUE_SIZE, QUEUE_SIZE];
 
-// Virtqueue indexes
+// Virtqueue indexes that do not depend on advertised features
 const INFLATEQ: usize = 0;
 const DEFLATEQ: usize = 1;
-const STATSQ: usize = 2;
-const _FREE_PAGE_VQ: usize = 3;
-const REPORTING_VQ: usize = 4;
-const WS_DATA_VQ: usize = 5;
-const WS_OP_VQ: usize = 6;
 
 const VIRTIO_BALLOON_PFN_SHIFT: u32 = 12;
 const VIRTIO_BALLOON_PF_SIZE: u64 = 1 << VIRTIO_BALLOON_PFN_SHIFT;
@@ -372,7 +365,7 @@ where
         {
             error!("balloon: failed to process inflate addresses: {}", e);
         }
-        queue.add_used(avail_desc, 0);
+        queue.add_used(avail_desc);
         queue.trigger_interrupt();
     }
 }
@@ -423,7 +416,7 @@ where
         {
             error!("balloon: failed to process reported buffer: {}", e);
         }
-        queue.add_used(avail_desc, 0);
+        queue.add_used(avail_desc);
         queue.trigger_interrupt();
     }
 }
@@ -485,7 +478,7 @@ async fn handle_stats_queue(
         };
 
         // Request a new stats_desc to the guest.
-        queue.add_used(avail_desc, 0);
+        queue.add_used(avail_desc);
         queue.trigger_interrupt();
 
         avail_desc = match queue.next_async(&mut queue_event).await {
@@ -600,8 +593,7 @@ async fn handle_ws_op_queue(
             }
         }
 
-        let len = writer.bytes_written() as u32;
-        queue.add_used(avail_desc, len);
+        queue.add_used(avail_desc);
         queue.trigger_interrupt();
     }
 
@@ -678,7 +670,7 @@ async fn handle_ws_data_queue(
             }
         }
 
-        queue.add_used(avail_desc, 0);
+        queue.add_used(avail_desc);
         queue.trigger_interrupt();
     }
 }
@@ -858,7 +850,7 @@ fn free_memory(
     // When `--lock-guest-memory` is used, it is not possible to free the memory from the main
     // process, so we free it from the sandboxed balloon process directly.
     #[cfg(any(target_os = "android", target_os = "linux"))]
-    if mem.locked() {
+    if mem.locked() && !mem.use_dontneed_locked() {
         for (guest_address, len) in ranges {
             if let Err(e) = mem.remove_range(guest_address, len) {
                 warn!("Marking pages unused failed: {}, addr={}", e, guest_address);
@@ -1179,6 +1171,7 @@ pub struct Balloon {
     registered_evt_q: Option<SendTube>,
     ws_num_bins: u8,
     target_reached_evt: Option<Event>,
+    queue_sizes: Vec<u16>,
 }
 
 /// Snapshot of the [Balloon] state.
@@ -1212,6 +1205,20 @@ impl Balloon {
             | 1 << VIRTIO_BALLOON_F_DEFLATE_ON_OOM
             | enabled_features;
 
+        let mut queue_sizes = Vec::new();
+        queue_sizes.push(QUEUE_SIZE); // inflateq
+        queue_sizes.push(QUEUE_SIZE); // deflateq
+        if features & (1 << VIRTIO_BALLOON_F_STATS_VQ) != 0 {
+            queue_sizes.push(QUEUE_SIZE); // statsq
+        }
+        if features & (1 << VIRTIO_BALLOON_F_PAGE_REPORTING) != 0 {
+            queue_sizes.push(QUEUE_SIZE); // reporting_vq
+        }
+        if features & (1 << VIRTIO_BALLOON_F_WS_REPORTING) != 0 {
+            queue_sizes.push(QUEUE_SIZE); // ws_data
+            queue_sizes.push(QUEUE_SIZE); // ws_cmd
+        }
+
         Ok(Balloon {
             command_tube: Some(command_tube),
             vm_memory_client: Some(vm_memory_client),
@@ -1231,6 +1238,7 @@ impl Balloon {
             registered_evt_q,
             ws_num_bins,
             target_reached_evt: None,
+            queue_sizes,
         })
     }
 
@@ -1278,40 +1286,44 @@ impl Balloon {
         &self,
         mut queues: BTreeMap<usize, Queue>,
     ) -> anyhow::Result<BalloonQueues> {
-        fn pop_queue(
-            queues: &mut BTreeMap<usize, Queue>,
-            expected_index: usize,
-            name: &str,
-        ) -> anyhow::Result<Queue> {
-            let (queue_index, queue) = queues
-                .pop_first()
-                .with_context(|| format!("missing {}", name))?;
-
-            if queue_index == expected_index {
-                debug!("{name} index {queue_index}");
-            } else {
-                warn!("expected {name} index {expected_index}, got {queue_index}");
-            }
-
-            Ok(queue)
-        }
-
-        // WARNING: We use `pop_first` instead of explicitly using the indices from the virtio spec
-        // because the Linux virtio drivers only "allocates" queue indices that are used, so queues
-        // need to be removed in order of ascending virtqueue index.
-        let inflate_queue = pop_queue(&mut queues, INFLATEQ, "inflateq")?;
-        let deflate_queue = pop_queue(&mut queues, DEFLATEQ, "deflateq")?;
+        let inflate_queue = queues.remove(&INFLATEQ).context("missing inflateq")?;
+        let deflate_queue = queues.remove(&DEFLATEQ).context("missing deflateq")?;
         let mut queue_struct = BalloonQueues::new(inflate_queue, deflate_queue);
 
-        if self.acked_features & (1 << VIRTIO_BALLOON_F_STATS_VQ) != 0 {
-            queue_struct.stats = Some(pop_queue(&mut queues, STATSQ, "statsq")?);
+        // Queues whose existence depends on advertised features start at queue index 2.
+        let mut next_queue_index = 2;
+        let mut next_queue = || {
+            let idx = next_queue_index;
+            next_queue_index += 1;
+            idx
+        };
+
+        if self.features & (1 << VIRTIO_BALLOON_F_STATS_VQ) != 0 {
+            let statsq = next_queue();
+            if self.acked_features & (1 << VIRTIO_BALLOON_F_STATS_VQ) != 0 {
+                queue_struct.stats = Some(queues.remove(&statsq).context("missing statsq")?);
+            }
         }
-        if self.acked_features & (1 << VIRTIO_BALLOON_F_PAGE_REPORTING) != 0 {
-            queue_struct.reporting = Some(pop_queue(&mut queues, REPORTING_VQ, "reporting_vq")?);
+
+        if self.features & (1 << VIRTIO_BALLOON_F_PAGE_REPORTING) != 0 {
+            let reporting_vq = next_queue();
+            if self.acked_features & (1 << VIRTIO_BALLOON_F_PAGE_REPORTING) != 0 {
+                queue_struct.reporting = Some(
+                    queues
+                        .remove(&reporting_vq)
+                        .context("missing reporting_vq")?,
+                );
+            }
         }
-        if self.acked_features & (1 << VIRTIO_BALLOON_F_WS_REPORTING) != 0 {
-            queue_struct.ws_data = Some(pop_queue(&mut queues, WS_DATA_VQ, "ws_data_vq")?);
-            queue_struct.ws_op = Some(pop_queue(&mut queues, WS_OP_VQ, "ws_op_vq")?);
+
+        if self.features & (1 << VIRTIO_BALLOON_F_WS_REPORTING) != 0 {
+            let ws_data_vq = next_queue();
+            let ws_op_vq = next_queue();
+            if self.acked_features & (1 << VIRTIO_BALLOON_F_WS_REPORTING) != 0 {
+                queue_struct.ws_data =
+                    Some(queues.remove(&ws_data_vq).context("missing ws_data_vq")?);
+                queue_struct.ws_op = Some(queues.remove(&ws_op_vq).context("missing ws_op_vq")?);
+            }
         }
 
         if !queues.is_empty() {
@@ -1396,7 +1408,7 @@ impl VirtioDevice for Balloon {
     }
 
     fn queue_max_sizes(&self) -> &[u16] {
-        QUEUE_SIZES
+        &self.queue_sizes
     }
 
     fn read_config(&self, offset: u64, data: &mut [u8]) {
diff --git a/devices/src/virtio/block/asynchronous.rs b/devices/src/virtio/block/asynchronous.rs
index 6e2dbe568..a804af711 100644
--- a/devices/src/virtio/block/asynchronous.rs
+++ b/devices/src/virtio/block/asynchronous.rs
@@ -290,7 +290,7 @@ async fn process_one_chain(
     };
 
     let mut queue = queue.borrow_mut();
-    queue.add_used(avail_desc, len as u32);
+    queue.add_used_with_bytes_written(avail_desc, len as u32);
     queue.trigger_interrupt();
 }
 
diff --git a/devices/src/virtio/console.rs b/devices/src/virtio/console.rs
index 4e956c80f..abc30c6aa 100644
--- a/devices/src/virtio/console.rs
+++ b/devices/src/virtio/console.rs
@@ -36,7 +36,7 @@ const QUEUE_SIZE: u16 = 256;
 /// Virtio console device.
 pub struct Console {
     console: ConsoleDevice,
-    queue_sizes: Vec<u16>,
+    max_queue_sizes: Vec<u16>,
     pci_address: Option<PciAddress>,
 }
 
@@ -47,14 +47,23 @@ impl Console {
         output: Option<Box<dyn std::io::Write + Send>>,
         keep_rds: Vec<RawDescriptor>,
         pci_address: Option<PciAddress>,
+        max_queue_sizes: Option<Vec<u16>>,
     ) -> Console {
         let port = ConsolePort::new(input, output, None, keep_rds);
         let console = ConsoleDevice::new_single_port(protection_type, port);
-        let queue_sizes = vec![QUEUE_SIZE; console.max_queues()];
+        let max_queue_sizes =
+            max_queue_sizes.unwrap_or_else(|| vec![QUEUE_SIZE; console.max_queues()]);
+
+        // TODO: Move these checks into cmdline validation or something so it is more user
+        // friendly when it fails.
+        assert_eq!(max_queue_sizes.len(), console.max_queues());
+        for qs in &max_queue_sizes {
+            assert!(qs.is_power_of_two());
+        }
 
         Console {
             console,
-            queue_sizes,
+            max_queue_sizes,
             pci_address,
         }
     }
@@ -74,7 +83,7 @@ impl VirtioDevice for Console {
     }
 
     fn queue_max_sizes(&self) -> &[u16] {
-        &self.queue_sizes
+        &self.max_queue_sizes
     }
 
     fn read_config(&self, offset: u64, data: &mut [u8]) {
@@ -179,6 +188,7 @@ mod tests {
             Some(output),
             Vec::new(),
             None,
+            None,
         );
 
         let context = ConsoleContext {};
@@ -203,6 +213,7 @@ mod tests {
             Some(output),
             Vec::new(),
             None,
+            None,
         );
 
         let context = ConsoleContext { input_pipe_client };
diff --git a/devices/src/virtio/console/control.rs b/devices/src/virtio/console/control.rs
index cbef5a230..f0c011b8b 100644
--- a/devices/src/virtio/console/control.rs
+++ b/devices/src/virtio/console/control.rs
@@ -133,7 +133,7 @@ pub fn process_control_transmit_queue(
             error!("failed to handle control msg: {:#}", e);
         }
 
-        queue.add_used(avail_desc, 0);
+        queue.add_used(avail_desc);
         needs_interrupt = true;
     }
 
@@ -167,7 +167,7 @@ pub fn process_control_receive_queue(
             }
         };
 
-        queue.add_used(avail_desc, len);
+        queue.add_used_with_bytes_written(avail_desc, len);
         needs_interrupt = true;
     }
 
diff --git a/devices/src/virtio/console/input.rs b/devices/src/virtio/console/input.rs
index 0ee6d50bf..ca623c0cb 100644
--- a/devices/src/virtio/console/input.rs
+++ b/devices/src/virtio/console/input.rs
@@ -34,11 +34,9 @@ pub fn process_receive_queue(buffer: &mut VecDeque<u8>, receive_queue: &mut Queu
             drop(buffer.drain(..written));
         }
 
-        let bytes_written = writer.bytes_written() as u32;
-
-        if bytes_written > 0 {
+        if writer.bytes_written() > 0 {
             let desc = desc.pop();
-            receive_queue.add_used(desc, bytes_written);
+            receive_queue.add_used(desc);
             receive_queue.trigger_interrupt();
         }
     }
diff --git a/devices/src/virtio/console/output.rs b/devices/src/virtio/console/output.rs
index 142963a51..afde55449 100644
--- a/devices/src/virtio/console/output.rs
+++ b/devices/src/virtio/console/output.rs
@@ -41,7 +41,7 @@ pub fn process_transmit_queue(transmit_queue: &mut Queue, output: &mut dyn io::W
             error!("console: process_transmit_request failed: {}", e);
         }
 
-        transmit_queue.add_used(avail_desc, 0);
+        transmit_queue.add_used(avail_desc);
         needs_interrupt = true;
     }
 
diff --git a/devices/src/virtio/console/sys/linux.rs b/devices/src/virtio/console/sys/linux.rs
index 92ef89244..e2fa38572 100644
--- a/devices/src/virtio/console/sys/linux.rs
+++ b/devices/src/virtio/console/sys/linux.rs
@@ -45,6 +45,7 @@ impl SerialDevice for Console {
             output,
             keep_rds,
             options.pci_address,
+            options.max_queue_sizes,
         )
     }
 }
diff --git a/devices/src/virtio/console/sys/windows.rs b/devices/src/virtio/console/sys/windows.rs
index 4096aa838..0312ca2d1 100644
--- a/devices/src/virtio/console/sys/windows.rs
+++ b/devices/src/virtio/console/sys/windows.rs
@@ -33,7 +33,14 @@ impl SerialDevice for Console {
         options: SerialOptions,
         keep_rds: Vec<RawDescriptor>,
     ) -> Console {
-        Console::new(protection_type, None, out, keep_rds, options.pci_address)
+        Console::new(
+            protection_type,
+            None,
+            out,
+            keep_rds,
+            options.pci_address,
+            options.max_queue_sizes,
+        )
     }
 
     /// Constructs a console with named pipe as input/output connections.
@@ -51,6 +58,7 @@ impl SerialDevice for Console {
             Some(Box::new(pipe_out)),
             keep_rds,
             options.pci_address,
+            options.max_queue_sizes,
         )
     }
 }
diff --git a/devices/src/virtio/fs/config.rs b/devices/src/virtio/fs/config.rs
index 0f4aa9198..75b564ae3 100644
--- a/devices/src/virtio/fs/config.rs
+++ b/devices/src/virtio/fs/config.rs
@@ -68,7 +68,7 @@ fn deserialize_privileged_quota_uids<'de, D: Deserializer<'de>>(
 ) -> Result<Vec<libc::uid_t>, D::Error> {
     // space-separated list
     let s: &str = serde::Deserialize::deserialize(deserializer)?;
-    s.split(" ")
+    s.split(' ')
         .map(|s| {
             s.parse::<libc::uid_t>().map_err(|e| {
                 <D as Deserializer>::Error::custom(format!(
diff --git a/devices/src/virtio/fs/worker.rs b/devices/src/virtio/fs/worker.rs
index 97aab0b00..4ca52be09 100644
--- a/devices/src/virtio/fs/worker.rs
+++ b/devices/src/virtio/fs/worker.rs
@@ -155,7 +155,7 @@ fn process_fs_queue<F: FileSystem + Sync>(
         let total =
             server.handle_message(&mut avail_desc.reader, &mut avail_desc.writer, &mapper)?;
 
-        queue.add_used(avail_desc, total as u32);
+        queue.add_used_with_bytes_written(avail_desc, total as u32);
         queue.trigger_interrupt();
     }
 
diff --git a/devices/src/virtio/gpu/mod.rs b/devices/src/virtio/gpu/mod.rs
index fbe55e8a0..70e2822c4 100644
--- a/devices/src/virtio/gpu/mod.rs
+++ b/devices/src/virtio/gpu/mod.rs
@@ -212,7 +212,9 @@ impl QueueReader for LocalQueueReader {
     }
 
     fn add_used(&self, desc_chain: DescriptorChain, len: u32) {
-        self.queue.borrow_mut().add_used(desc_chain, len)
+        self.queue
+            .borrow_mut()
+            .add_used_with_bytes_written(desc_chain, len);
     }
 
     fn signal_used(&self) {
@@ -239,7 +241,9 @@ impl QueueReader for SharedQueueReader {
     }
 
     fn add_used(&self, desc_chain: DescriptorChain, len: u32) {
-        self.queue.lock().add_used(desc_chain, len)
+        self.queue
+            .lock()
+            .add_used_with_bytes_written(desc_chain, len);
     }
 
     fn signal_used(&self) {
@@ -689,7 +693,25 @@ impl Frontend {
             GpuCommand::ResourceMapBlob(info) => {
                 let resource_id = info.resource_id.to_native();
                 let offset = info.offset.to_native();
-                self.virtio_gpu.resource_map_blob(resource_id, offset)
+                self.virtio_gpu
+                    .resource_map_blob(resource_id, offset)
+                    .inspect_err(|e| {
+                        // Log the details for triage.
+                        error!(
+                            "Failed to map blob, resource id {}, offset {}, error: {:#}",
+                            resource_id, offset, e
+                        );
+                    })
+                    .map_err(|e| match e.downcast::<GpuResponse>() {
+                        Ok(response) => response,
+                        Err(e) => {
+                            warn!(
+                                "No GPU response specified for {:?}, default to ErrUnspec",
+                                e
+                            );
+                            GpuResponse::ErrUnspec
+                        }
+                    })
             }
             GpuCommand::ResourceUnmapBlob(info) => {
                 let resource_id = info.resource_id.to_native();
diff --git a/devices/src/virtio/gpu/virtio_gpu.rs b/devices/src/virtio/gpu/virtio_gpu.rs
index be5713326..892bd92d6 100644
--- a/devices/src/virtio/gpu/virtio_gpu.rs
+++ b/devices/src/virtio/gpu/virtio_gpu.rs
@@ -29,7 +29,7 @@ use rutabaga_gfx::ResourceCreateBlob;
 use rutabaga_gfx::Rutabaga;
 use rutabaga_gfx::RutabagaDescriptor;
 #[cfg(windows)]
-use rutabaga_gfx::RutabagaError;
+use rutabaga_gfx::RutabagaErrorKind;
 use rutabaga_gfx::RutabagaFence;
 use rutabaga_gfx::RutabagaFromRawDescriptor;
 use rutabaga_gfx::RutabagaHandle;
@@ -772,7 +772,7 @@ impl VirtioGpu {
         #[cfg(windows)]
         match self.rutabaga.resource_flush(resource_id) {
             Ok(_) => return Ok(OkNoData),
-            Err(RutabagaError::Unsupported) => {}
+            Err(e) if matches!(e.kind(), &RutabagaErrorKind::Unsupported) => {}
             Err(e) => return Err(ErrRutabaga(e)),
         }
 
@@ -1087,13 +1087,22 @@ impl VirtioGpu {
     /// rutabaga as ExternalMapping.
     /// When sandboxing is enabled, external_blob is set and opaque fds must be mapped in the
     /// hypervisor process by Vulkano using metadata provided by Rutabaga::vulkan_info().
-    pub fn resource_map_blob(&mut self, resource_id: u32, offset: u64) -> VirtioGpuResult {
+    pub fn resource_map_blob(
+        &mut self,
+        resource_id: u32,
+        offset: u64,
+    ) -> anyhow::Result<GpuResponse> {
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(ErrInvalidResourceId)?;
+            .with_context(|| format!("can't find the resource with id {}", resource_id))
+            .context(ErrInvalidResourceId)?;
 
-        let map_info = self.rutabaga.map_info(resource_id).map_err(|_| ErrUnspec)?;
+        let map_info = self
+            .rutabaga
+            .map_info(resource_id)
+            .context("failed to retrieve the map info for the resource")
+            .context(ErrUnspec)?;
 
         let mut source: Option<VmMemorySource> = None;
         if let Ok(export) = self.rutabaga.export_blob(resource_id) {
@@ -1118,11 +1127,18 @@ impl VirtioGpu {
         // fallback to ExternalMapping via rutabaga if sandboxing (hence external_blob) and fixed
         // mapping are both disabled as neither is currently compatible.
         if source.is_none() {
-            if self.external_blob || self.fixed_blob_mapping {
-                return Err(ErrUnspec);
-            }
+            anyhow::ensure!(
+                !self.external_blob,
+                "can't fallback to external mapping with external blob enabled"
+            );
+            anyhow::ensure!(
+                !self.fixed_blob_mapping,
+                "can't fallback to external mapping with fixed blob mapping enabled"
+            );
 
-            let mapping = self.rutabaga.map(resource_id)?;
+            let mapping = self.rutabaga.map(resource_id).map_err(|e| {
+                anyhow::anyhow!("failed to map via rutabaga").context(GpuResponse::ErrRutabaga(e))
+            })?;
             // resources mapped via rutabaga must also be marked for unmap via rutabaga.
             resource.rutabaga_external_mapping = true;
             source = Some(VmMemorySource::ExternalMapping {
@@ -1135,7 +1151,13 @@ impl VirtioGpu {
             RUTABAGA_MAP_ACCESS_READ => Protection::read(),
             RUTABAGA_MAP_ACCESS_WRITE => Protection::write(),
             RUTABAGA_MAP_ACCESS_RW => Protection::read_write(),
-            _ => return Err(ErrUnspec),
+            access_flags => {
+                return Err(anyhow::anyhow!(
+                    "unrecognized access flags {:#x}",
+                    access_flags
+                ))
+                .context(ErrUnspec)
+            }
         };
 
         let cache = if cfg!(feature = "noncoherent-dma")
@@ -1151,7 +1173,8 @@ impl VirtioGpu {
             .as_mut()
             .expect("No backend request connection found")
             .add_mapping(source.unwrap(), offset, prot, cache)
-            .map_err(|_| ErrUnspec)?;
+            .context("failed to add the memory mapping")
+            .context(ErrUnspec)?;
 
         resource.shmem_offset = Some(offset);
         // Access flags not a part of the virtio-gpu spec.
diff --git a/devices/src/virtio/input/mod.rs b/devices/src/virtio/input/mod.rs
index ca912af61..708c57c8d 100644
--- a/devices/src/virtio/input/mod.rs
+++ b/devices/src/virtio/input/mod.rs
@@ -224,6 +224,15 @@ impl virtio_input_config {
     }
 }
 
+// virtio_input_config_select is the prefix of virtio_input_config consisting of only the writable
+// fields (select and subsel), which multiplex the rest of the (read-only) config data.
+#[repr(C)]
+#[derive(Copy, Clone, Debug, FromBytes, Immutable, IntoBytes, KnownLayout)]
+struct virtio_input_config_select {
+    select: u8,
+    subsel: u8,
+}
+
 #[derive(Copy, Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
 #[repr(C)]
 pub struct virtio_input_bitmap {
@@ -271,10 +280,8 @@ impl virtio_input_bitmap {
     }
 }
 
-#[derive(Debug, Serialize, Deserialize, Clone)]
+#[derive(Debug)]
 pub struct VirtioInputConfig {
-    select: u8,
-    subsel: u8,
     device_ids: virtio_input_device_ids,
     name: String,
     serial_name: String,
@@ -293,8 +300,6 @@ impl VirtioInputConfig {
         axis_info: BTreeMap<u16, virtio_input_absinfo>,
     ) -> VirtioInputConfig {
         VirtioInputConfig {
-            select: 0,
-            subsel: 0,
             device_ids,
             name,
             serial_name,
@@ -315,11 +320,11 @@ impl VirtioInputConfig {
         ))
     }
 
-    fn build_config_memory(&self) -> virtio_input_config {
+    fn build_config_memory(&self, select: u8, subsel: u8) -> virtio_input_config {
         let mut cfg = virtio_input_config::new();
-        cfg.select = self.select;
-        cfg.subsel = self.subsel;
-        match self.select {
+        cfg.select = select;
+        cfg.subsel = subsel;
+        match select {
             VIRTIO_INPUT_CFG_ID_NAME => {
                 cfg.set_payload_str(&self.name);
             }
@@ -330,7 +335,7 @@ impl VirtioInputConfig {
                 cfg.set_payload_bitmap(&self.properties);
             }
             VIRTIO_INPUT_CFG_EV_BITS => {
-                let ev_type = self.subsel as u16;
+                let ev_type = subsel as u16;
                 // zero is a special case: return all supported event types (just like EVIOCGBIT)
                 if ev_type == 0 {
                     let events_bm = virtio_input_bitmap::from_bits(
@@ -342,7 +347,7 @@ impl VirtioInputConfig {
                 }
             }
             VIRTIO_INPUT_CFG_ABS_INFO => {
-                let abs_axis = self.subsel as u16;
+                let abs_axis = subsel as u16;
                 if let Some(absinfo) = self.axis_info.get(&abs_axis) {
                     cfg.set_absinfo(absinfo);
                 } // else all zeroes in the payload
@@ -357,27 +362,11 @@ impl VirtioInputConfig {
                 // existing behavior of doing nothing works with the Linux virtio-input frontend.
             }
             _ => {
-                warn!("Unsuported virtio input config selection: {}", self.select);
+                warn!("Unsuported virtio input config selection: {}", select);
             }
         }
         cfg
     }
-
-    fn read(&self, offset: usize, data: &mut [u8]) {
-        copy_config(
-            data,
-            0,
-            self.build_config_memory().as_bytes(),
-            offset as u64,
-        );
-    }
-
-    fn write(&mut self, offset: usize, data: &[u8]) {
-        let mut config = self.build_config_memory();
-        copy_config(config.as_mut_bytes(), offset as u64, data, 0);
-        self.select = config.select;
-        self.subsel = config.subsel;
-    }
 }
 
 struct Worker<T: EventSource> {
@@ -427,7 +416,8 @@ impl<T: EventSource> Worker<T> {
                             }
                         };
 
-                    self.event_queue.add_used(avail_desc, bytes_written as u32);
+                    self.event_queue
+                        .add_used_with_bytes_written(avail_desc, bytes_written as u32);
                     needs_interrupt = true;
                 }
             }
@@ -436,33 +426,24 @@ impl<T: EventSource> Worker<T> {
         needs_interrupt
     }
 
-    // Sends events from the guest to the source.  Returns the number of bytes read.
-    fn read_event_virtqueue(
-        avail_desc: &mut DescriptorChain,
-        event_source: &mut T,
-    ) -> Result<usize> {
+    // Sends events from the guest to the source.
+    fn read_event_virtqueue(avail_desc: &mut DescriptorChain, event_source: &mut T) -> Result<()> {
         let reader = &mut avail_desc.reader;
         while reader.available_bytes() >= virtio_input_event::SIZE {
             let evt: virtio_input_event = reader.read_obj().map_err(InputError::ReadQueue)?;
             event_source.send_event(&evt)?;
         }
 
-        Ok(reader.bytes_read())
+        Ok(())
     }
 
     fn process_status_queue(&mut self) -> Result<bool> {
         let mut needs_interrupt = false;
         while let Some(mut avail_desc) = self.status_queue.pop() {
-            let bytes_read =
-                match Worker::read_event_virtqueue(&mut avail_desc, &mut self.event_source) {
-                    Ok(count) => count,
-                    Err(e) => {
-                        error!("Input: failed to read events from virtqueue: {}", e);
-                        return Err(e);
-                    }
-                };
+            Worker::read_event_virtqueue(&mut avail_desc, &mut self.event_source)
+                .inspect_err(|e| error!("Input: failed to read events from virtqueue: {}", e))?;
 
-            self.status_queue.add_used(avail_desc, bytes_read as u32);
+            self.status_queue.add_used(avail_desc);
             needs_interrupt = true;
         }
 
@@ -564,6 +545,9 @@ impl<T: EventSource> Worker<T> {
 pub struct Input<T: EventSource + Send + 'static> {
     worker_thread: Option<WorkerThread<Worker<T>>>,
     config: VirtioInputConfig,
+    config_select: u8,
+    config_subsel: u8,
+    config_data: virtio_input_config,
     source: Option<T>,
     virtio_features: u64,
 }
@@ -571,7 +555,8 @@ pub struct Input<T: EventSource + Send + 'static> {
 /// Snapshot of [Input]'s state.
 #[derive(Serialize, Deserialize)]
 struct InputSnapshot {
-    config: VirtioInputConfig,
+    config_select: u8,
+    config_subsel: u8,
     virtio_features: u64,
 }
 
@@ -595,11 +580,23 @@ where
     }
 
     fn read_config(&self, offset: u64, data: &mut [u8]) {
-        self.config.read(offset as usize, data);
+        copy_config(data, 0, self.config_data.as_bytes(), offset);
     }
 
     fn write_config(&mut self, offset: u64, data: &[u8]) {
-        self.config.write(offset as usize, data);
+        let mut config = virtio_input_config_select {
+            select: self.config_select,
+            subsel: self.config_subsel,
+        };
+        copy_config(config.as_mut_bytes(), offset, data, 0);
+
+        if config.select != self.config_select || config.subsel != self.config_subsel {
+            self.config_select = config.select;
+            self.config_subsel = config.subsel;
+            self.config_data = self
+                .config
+                .build_config_memory(config.select, config.subsel);
+        }
     }
 
     fn features(&self) -> u64 {
@@ -669,7 +666,8 @@ where
     fn virtio_snapshot(&mut self) -> anyhow::Result<AnySnapshot> {
         AnySnapshot::to_any(InputSnapshot {
             virtio_features: self.virtio_features,
-            config: self.config.clone(),
+            config_select: self.config_select,
+            config_subsel: self.config_subsel,
         })
         .context("failed to serialize InputSnapshot")
     }
@@ -683,22 +681,42 @@ where
                 snap.virtio_features,
             );
         }
-        self.config = snap.config;
+        self.config_select = snap.config_select;
+        self.config_subsel = snap.config_subsel;
         Ok(())
     }
 }
 
+impl<T> Input<T>
+where
+    T: EventSource + Send + 'static,
+{
+    fn new(config: VirtioInputConfig, source: Option<T>, virtio_features: u64) -> Self {
+        let config_select = 0;
+        let config_subsel = 0;
+        let config_data = config.build_config_memory(config_select, config_subsel);
+        Input {
+            worker_thread: None,
+            config,
+            config_select,
+            config_subsel,
+            config_data,
+            source,
+            virtio_features,
+        }
+    }
+}
+
 /// Creates a new virtio input device from an event device node
 pub fn new_evdev<T>(source: T, virtio_features: u64) -> Result<Input<EvdevEventSource<T>>>
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: VirtioInputConfig::from_evdev(&source)?,
-        source: Some(EvdevEventSource::new(source)),
+    Ok(Input::new(
+        VirtioInputConfig::from_evdev(&source)?,
+        Some(EvdevEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio touch device which supports single touch only.
@@ -713,12 +731,11 @@ pub fn new_single_touch<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_single_touch_config(idx, width, height, name),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_single_touch_config(idx, width, height, name),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio touch device which supports multi touch.
@@ -733,12 +750,11 @@ pub fn new_multi_touch<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_multi_touch_config(idx, width, height, name),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_multi_touch_config(idx, width, height, name),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio trackpad device which supports (single) touch, primary and secondary
@@ -754,12 +770,11 @@ pub fn new_trackpad<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_trackpad_config(idx, width, height, name),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_trackpad_config(idx, width, height, name),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio trackpad device which supports multi touch, primary and secondary
@@ -775,12 +790,11 @@ pub fn new_multitouch_trackpad<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_multitouch_trackpad_config(idx, width, height, name),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_multitouch_trackpad_config(idx, width, height, name),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio mouse which supports primary, secondary, wheel and REL events.
@@ -792,12 +806,11 @@ pub fn new_mouse<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_mouse_config(idx),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_mouse_config(idx),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio keyboard, which supports the same events as an en-us physical keyboard.
@@ -809,12 +822,11 @@ pub fn new_keyboard<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_keyboard_config(idx),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_keyboard_config(idx),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio device for switches.
@@ -826,12 +838,11 @@ pub fn new_switches<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_switches_config(idx),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_switches_config(idx),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new virtio device for rotary.
@@ -843,12 +854,11 @@ pub fn new_rotary<T>(
 where
     T: Read + Write + AsRawDescriptor + Send + 'static,
 {
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_rotary_config(idx),
-        source: Some(SocketEventSource::new(source)),
+    Ok(Input::new(
+        defaults::new_rotary_config(idx),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 /// Creates a new custom virtio input device
@@ -863,9 +873,8 @@ where
 {
     let config = parse_input_config_file(&input_config_path, idx)?;
 
-    Ok(Input {
-        worker_thread: None,
-        config: defaults::new_custom_config(
+    Ok(Input::new(
+        defaults::new_custom_config(
             idx,
             &config.name,
             &config.serial_name,
@@ -873,9 +882,9 @@ where
             config.supported_events,
             config.axis_info,
         ),
-        source: Some(SocketEventSource::new(source)),
+        Some(SocketEventSource::new(source)),
         virtio_features,
-    })
+    ))
 }
 
 #[derive(Debug, Deserialize)]
diff --git a/devices/src/virtio/interrupt.rs b/devices/src/virtio/interrupt.rs
index 839ba0703..8e09767c4 100644
--- a/devices/src/virtio/interrupt.rs
+++ b/devices/src/virtio/interrupt.rs
@@ -55,7 +55,7 @@ struct InterruptInner {
     interrupt_status: AtomicUsize,
     transport: Transport,
     async_intr_status: bool,
-    pm_state: Arc<Mutex<PmState>>,
+    pm_state: Mutex<PmState>,
 }
 
 impl InterruptInner {
@@ -410,13 +410,13 @@ struct PmState {
 impl PmState {
     fn new(
         #[cfg(target_arch = "x86_64")] wakeup_event: Option<(PmWakeupEvent, MetricEventType)>,
-    ) -> Arc<Mutex<Self>> {
-        Arc::new(Mutex::new(Self {
+    ) -> Mutex<Self> {
+        Mutex::new(Self {
             suspended: false,
             pending_signals: Vec::new(),
             #[cfg(target_arch = "x86_64")]
             wakeup_state: WakeupState::new(wakeup_event),
-        }))
+        })
     }
 
     fn handle_interrupt(&mut self, vector: u16, mask: u32) -> bool {
diff --git a/devices/src/virtio/iommu.rs b/devices/src/virtio/iommu.rs
index ca124d767..7895692a5 100644
--- a/devices/src/virtio/iommu.rs
+++ b/devices/src/virtio/iommu.rs
@@ -25,8 +25,6 @@ use anyhow::Context;
 use base::debug;
 use base::error;
 use base::pagesize;
-#[cfg(target_arch = "x86_64")]
-use base::warn;
 use base::AsRawDescriptor;
 use base::Error as SysError;
 use base::Event;
@@ -633,7 +631,7 @@ async fn request_queue(
             debug!("iommu fault resolved");
         }
 
-        queue.add_used(avail_desc, len as u32);
+        queue.add_used_with_bytes_written(avail_desc, len as u32);
         queue.trigger_interrupt();
     }
 }
@@ -868,16 +866,17 @@ impl VirtioDevice for Iommu {
     }
 
     #[cfg(target_arch = "x86_64")]
-    fn generate_acpi(&mut self, pci_address: PciAddress, sdts: &mut Vec<SDT>) {
+    fn generate_acpi(
+        &mut self,
+        pci_address: PciAddress,
+        sdts: &mut Vec<SDT>,
+    ) -> anyhow::Result<()> {
         const OEM_REVISION: u32 = 1;
         const VIOT_REVISION: u8 = 0;
 
-        for sdt in sdts.iter() {
-            // there should only be one VIOT table
-            if sdt.is_signature(b"VIOT") {
-                warn!("vIOMMU: duplicate VIOT table detected");
-                return;
-            }
+        // there should only be one VIOT table
+        if sdts.iter().any(|sdt| sdt.is_signature(b"VIOT")) {
+            return Err(anyhow!("duplicate VIOT table"));
         }
 
         let mut viot = SDT::new(
@@ -931,5 +930,6 @@ impl VirtioDevice for Iommu {
         }
 
         sdts.push(viot);
+        Ok(())
     }
 }
diff --git a/devices/src/virtio/media.rs b/devices/src/virtio/media.rs
index c588326bb..78b737670 100644
--- a/devices/src/virtio/media.rs
+++ b/devices/src/virtio/media.rs
@@ -95,8 +95,7 @@ impl VirtioMediaEventQueue for EventQueue {
             error!("failed to write event: {}", e);
         }
 
-        let written = desc.writer.bytes_written() as u32;
-        self.0.add_used(desc, written);
+        self.0.add_used(desc);
         self.0.trigger_interrupt();
     }
 }
@@ -459,8 +458,7 @@ where
                             self.runner
                                 .handle_command(&mut desc.reader, &mut desc.writer);
                             // Return the descriptor to the guest.
-                            let written = desc.writer.bytes_written() as u32;
-                            self.cmd_queue.add_used(desc, written);
+                            self.cmd_queue.add_used(desc);
                             self.cmd_queue.trigger_interrupt();
                         }
                     }
diff --git a/devices/src/virtio/net.rs b/devices/src/virtio/net.rs
index dc8e3f6f3..b72a0ba71 100644
--- a/devices/src/virtio/net.rs
+++ b/devices/src/virtio/net.rs
@@ -68,10 +68,12 @@ const QUEUE_SIZE: u16 = 256;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 pub static VHOST_NET_DEFAULT_PATH: &str = "/dev/vhost-net";
 
+pub(crate) use sys::process_mrg_rx;
 pub(crate) use sys::process_rx;
 pub(crate) use sys::process_tx;
 pub(crate) use sys::validate_and_configure_tap;
 pub(crate) use sys::virtio_features_to_tap_offload;
+pub(crate) use sys::PendingBuffer;
 
 #[sorted]
 #[derive(ThisError, Debug)]
@@ -209,6 +211,8 @@ pub struct NetParameters {
     #[serde(default)]
     pub packed_queue: bool,
     pub pci_address: Option<PciAddress>,
+    #[serde(default)]
+    pub mrg_rxbuf: bool,
 }
 
 impl FromStr for NetParameters {
@@ -304,8 +308,7 @@ pub fn process_ctrl<T: TapT>(
                 .write_all(&[VIRTIO_NET_OK as u8])
                 .map_err(NetError::WriteAck)?;
         }
-        let len = desc_chain.writer.bytes_written() as u32;
-        ctrl_queue.add_used(desc_chain, len);
+        ctrl_queue.add_used(desc_chain);
     }
 
     ctrl_queue.trigger_interrupt();
@@ -393,13 +396,14 @@ where
         }
 
         let mut tap_polling_enabled = true;
+        let mut pending_buffer_for_mrg_rx = PendingBuffer::new();
         'wait: loop {
             let events = wait_ctx.wait().map_err(NetError::WaitError)?;
             for event in events.iter().filter(|e| e.is_readable) {
                 match event.token {
                     Token::RxTap => {
                         let _trace = cros_tracing::trace_event!(VirtioNet, "handle RxTap event");
-                        self.handle_rx_token(&wait_ctx)?;
+                        self.handle_rx_token(&wait_ctx, &mut pending_buffer_for_mrg_rx)?;
                         tap_polling_enabled = false;
                     }
                     Token::RxQueue => {
@@ -490,6 +494,7 @@ where
         mac_addr: Option<MacAddress>,
         use_packed_queue: bool,
         pci_address: Option<PciAddress>,
+        mrg_rxbuf: bool,
     ) -> Result<Net<T>, NetError> {
         let taps = tap.into_mq_taps(vq_pairs).map_err(NetError::TapOpen)?;
 
@@ -531,6 +536,10 @@ where
             avail_features |= 1 << virtio_net::VIRTIO_NET_F_MAC;
         }
 
+        if mrg_rxbuf {
+            avail_features |= 1 << virtio_net::VIRTIO_NET_F_MRG_RXBUF;
+        }
+
         Self::new_internal(
             taps,
             avail_features,
@@ -843,6 +852,24 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
+            }
+        );
+
+        let params = from_net_arg("tap-name=tap,mrg-rxbuf=true").unwrap();
+        assert_eq!(
+            params,
+            NetParameters {
+                #[cfg(any(target_os = "android", target_os = "linux"))]
+                vhost_net: None,
+                vq_pairs: None,
+                mode: NetParametersMode::TapName {
+                    tap_name: "tap".to_string(),
+                    mac: None
+                },
+                packed_queue: false,
+                pci_address: None,
+                mrg_rxbuf: true,
             }
         );
 
@@ -859,6 +886,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -875,6 +903,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -891,6 +920,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -911,6 +941,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -931,6 +962,7 @@ mod tests {
                     dev: 1,
                     func: 1,
                 }),
+                mrg_rxbuf: false,
             }
         );
 
@@ -968,6 +1000,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -983,6 +1016,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -998,6 +1032,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -1014,6 +1049,7 @@ mod tests {
                 },
                 packed_queue: false,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -1030,6 +1066,7 @@ mod tests {
                 },
                 packed_queue: true,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -1046,6 +1083,7 @@ mod tests {
                 },
                 packed_queue: true,
                 pci_address: None,
+                mrg_rxbuf: false,
             }
         );
 
@@ -1065,6 +1103,39 @@ mod tests {
                     dev: 1,
                     func: 1,
                 }),
+                mrg_rxbuf: false,
+            }
+        );
+
+        let params = from_net_arg("vhost-net,tap-name=crosvm_tap,mrg-rxbuf=true").unwrap();
+        assert_eq!(
+            params,
+            NetParameters {
+                vhost_net: Some(Default::default()),
+                vq_pairs: None,
+                mode: NetParametersMode::TapName {
+                    tap_name: "crosvm_tap".to_owned(),
+                    mac: None,
+                },
+                packed_queue: false,
+                pci_address: None,
+                mrg_rxbuf: true,
+            }
+        );
+
+        let params = from_net_arg("vhost-net,tap-name=crosvm_tap,mrg-rxbuf").unwrap();
+        assert_eq!(
+            params,
+            NetParameters {
+                vhost_net: Some(Default::default()),
+                vq_pairs: None,
+                mode: NetParametersMode::TapName {
+                    tap_name: "crosvm_tap".to_owned(),
+                    mac: None,
+                },
+                packed_queue: false,
+                pci_address: None,
+                mrg_rxbuf: true,
             }
         );
 
diff --git a/devices/src/virtio/net/sys.rs b/devices/src/virtio/net/sys.rs
index dc6615f85..179eaf5f0 100644
--- a/devices/src/virtio/net/sys.rs
+++ b/devices/src/virtio/net/sys.rs
@@ -12,6 +12,24 @@ cfg_if::cfg_if! {
     }
 }
 
+pub struct PendingBuffer {
+    /// According to virtio-spec, the maximum incoming packet will be to 65550 bytes long
+    /// (the maximum size of a TCP or UDP packet, plus the 14 byte ethernet header)
+    /// The 12byte struct virtio_net_hdr is prepended to this, therefore making it for 65562
+    pub buffer: Box<[u8; 65562]>,
+    pub length: u32,
+}
+
+impl PendingBuffer {
+    pub fn new() -> Self {
+        PendingBuffer {
+            buffer: Box::new([0u8; 65562]),
+            length: 0,
+        }
+    }
+}
+
+pub(crate) use platform::process_mrg_rx;
 pub(crate) use platform::process_rx;
 pub(crate) use platform::process_tx;
 pub(crate) use platform::validate_and_configure_tap;
diff --git a/devices/src/virtio/net/sys/linux.rs b/devices/src/virtio/net/sys/linux.rs
index 8f47738c0..ced92b62a 100644
--- a/devices/src/virtio/net/sys/linux.rs
+++ b/devices/src/virtio/net/sys/linux.rs
@@ -3,6 +3,8 @@
 // found in the LICENSE file.
 
 use std::io;
+use std::io::Write;
+use std::mem;
 use std::result;
 
 use base::error;
@@ -12,12 +14,15 @@ use base::ReadNotifier;
 use base::WaitContext;
 use net_util::TapT;
 use virtio_sys::virtio_net;
+use virtio_sys::virtio_net::virtio_net_hdr;
 use virtio_sys::virtio_net::virtio_net_hdr_v1;
+use zerocopy::IntoBytes;
 
 use super::super::super::net::NetError;
 use super::super::super::net::Token;
 use super::super::super::net::Worker;
 use super::super::super::Queue;
+use super::PendingBuffer;
 
 // Ensure that the tap interface has the correct flags and sets the offload and VNET header size
 // to the appropriate values.
@@ -80,6 +85,81 @@ pub fn virtio_features_to_tap_offload(features: u64) -> u32 {
     tap_offloads
 }
 
+/// If avail_feature has mrg_rxbuf, use this function to process rx flow.
+pub fn process_mrg_rx<T: TapT>(
+    rx_queue: &mut Queue,
+    tap: &mut T,
+    pending: &mut PendingBuffer,
+) -> result::Result<(), NetError> {
+    let mut needs_interrupt = false;
+    let mut exhausted_queue = false;
+
+    loop {
+        // Refill `pending` if it is empty.
+        if pending.length == 0 {
+            match tap.read(&mut *pending.buffer) {
+                Ok(length) => {
+                    pending.length = length as u32;
+                }
+                Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
+                    // No more to read from the tap.
+                    break;
+                }
+                Err(e) => {
+                    warn!("net: rx: failed to write slice: {}", e);
+                    return Err(NetError::WriteBuffer(e));
+                }
+            }
+        }
+        if pending.length == 0 {
+            break;
+        }
+        let packet_len = pending.length;
+        let Some(mut desc_list) = rx_queue.try_pop_length(packet_len as usize) else {
+            // If vq is exhausted, pending buffer should be used firstly
+            // instead of reading from tap in next loop.
+            exhausted_queue = true;
+            break;
+        };
+        let num_buffers = desc_list.len() as u16;
+
+        // Copy the num_buffers value to specified address
+        let num_buffers_offset = mem::size_of::<virtio_net_hdr>();
+        pending.buffer[num_buffers_offset..num_buffers_offset + 2]
+            .copy_from_slice(num_buffers.as_bytes());
+        let mut offset = 0;
+        let end = packet_len as usize;
+        for desc in desc_list.iter_mut() {
+            let writer = &mut desc.writer;
+            let bytes_written = match writer.write(&pending.buffer[offset..end]) {
+                Ok(n) => n,
+                Err(e) => {
+                    warn!(
+                        "net: mrg_rx: failed to write slice from pending buffer: {}",
+                        e
+                    );
+                    return Err(NetError::WriteBuffer(e));
+                }
+            };
+            offset += bytes_written;
+        }
+        rx_queue.add_used_batch(desc_list);
+
+        needs_interrupt = true;
+        pending.length = 0;
+    }
+
+    if needs_interrupt {
+        rx_queue.trigger_interrupt();
+    }
+
+    if exhausted_queue {
+        Err(NetError::RxDescriptorsExhausted)
+    } else {
+        Ok(())
+    }
+}
+
 pub fn process_rx<T: TapT>(rx_queue: &mut Queue, mut tap: &mut T) -> result::Result<(), NetError> {
     let mut needs_interrupt = false;
     let mut exhausted_queue = false;
@@ -117,7 +197,7 @@ pub fn process_rx<T: TapT>(rx_queue: &mut Queue, mut tap: &mut T) -> result::Res
 
         if bytes_written > 0 {
             let desc_chain = desc_chain.pop();
-            rx_queue.add_used(desc_chain, bytes_written);
+            rx_queue.add_used(desc_chain);
             needs_interrupt = true;
         }
     }
@@ -152,7 +232,7 @@ pub fn process_tx<T: TapT>(tx_queue: &mut Queue, mut tap: &mut T) {
             Err(e) => error!("net: tx: failed to write frame to tap: {}", e),
         }
 
-        tx_queue.add_used(desc_chain, 0);
+        tx_queue.add_used(desc_chain);
     }
 
     tx_queue.trigger_interrupt();
@@ -165,8 +245,9 @@ where
     pub(in crate::virtio) fn handle_rx_token(
         &mut self,
         wait_ctx: &WaitContext<Token>,
+        pending_buffer: &mut PendingBuffer,
     ) -> result::Result<(), NetError> {
-        match self.process_rx() {
+        match self.process_rx(pending_buffer) {
             Ok(()) => Ok(()),
             Err(NetError::RxDescriptorsExhausted) => {
                 wait_ctx
@@ -189,7 +270,14 @@ where
         }
         Ok(())
     }
-    pub(super) fn process_rx(&mut self) -> result::Result<(), NetError> {
-        process_rx(&mut self.rx_queue, &mut self.tap)
+    pub(super) fn process_rx(
+        &mut self,
+        pending_buffer: &mut PendingBuffer,
+    ) -> result::Result<(), NetError> {
+        if self.acked_features & 1 << virtio_net::VIRTIO_NET_F_MRG_RXBUF == 0 {
+            process_rx(&mut self.rx_queue, &mut self.tap)
+        } else {
+            process_mrg_rx(&mut self.rx_queue, &mut self.tap, pending_buffer)
+        }
     }
 }
diff --git a/devices/src/virtio/net/sys/windows.rs b/devices/src/virtio/net/sys/windows.rs
index 055b09d30..78dfb010d 100644
--- a/devices/src/virtio/net/sys/windows.rs
+++ b/devices/src/virtio/net/sys/windows.rs
@@ -31,6 +31,7 @@ use super::super::super::Interrupt;
 use super::super::super::ProtectionType;
 use super::super::super::Queue;
 use super::super::super::Reader;
+use super::PendingBuffer;
 
 // This file should not be included at virtio mod level if slirp is not include. In case it is,
 // throw a user friendly message.
@@ -69,13 +70,19 @@ fn rx_single_frame(rx_queue: &mut Queue, rx_buf: &mut [u8], rx_count: usize) ->
         }
     };
 
-    let bytes_written = desc_chain.writer.bytes_written() as u32;
-
-    rx_queue.add_used(desc_chain, bytes_written);
+    rx_queue.add_used(desc_chain);
 
     true
 }
 
+pub fn process_mrg_rx<T: TapT>(
+    rx_queue: &mut Queue,
+    tap: &mut T,
+    pending_buffer: &mut Option<PendingBuffer>,
+) -> result::Result<(), NetError> {
+    unimplemented!("Unimplemented on Windows")
+}
+
 pub fn process_rx<T: TapT>(
     rx_queue: &mut Queue,
     tap: &mut T,
@@ -183,7 +190,7 @@ pub fn process_tx<T: TapT>(tx_queue: &mut Queue, tap: &mut T) {
             Err(e) => error!("net: tx: failed to read frame into buffer: {}", e),
         }
 
-        tx_queue.add_used(desc_chain, 0);
+        tx_queue.add_used(desc_chain);
     }
 
     tx_queue.trigger_interrupt();
@@ -207,6 +214,7 @@ where
     pub(in crate::virtio) fn handle_rx_token(
         &mut self,
         wait_ctx: &WaitContext<Token>,
+        _pending_buffer: &mut PendingBuffer,
     ) -> result::Result<(), NetError> {
         let mut needs_interrupt = false;
         // Process a deferred frame first if available. Don't read from tap again
diff --git a/devices/src/virtio/p9.rs b/devices/src/virtio/p9.rs
index a2e982245..aa3a1126a 100644
--- a/devices/src/virtio/p9.rs
+++ b/devices/src/virtio/p9.rs
@@ -81,9 +81,7 @@ impl Worker {
                 .handle_message(&mut avail_desc.reader, &mut avail_desc.writer)
                 .map_err(P9Error::Internal)?;
 
-            let len = avail_desc.writer.bytes_written() as u32;
-
-            self.queue.add_used(avail_desc, len);
+            self.queue.add_used(avail_desc);
         }
         self.queue.trigger_interrupt();
 
diff --git a/devices/src/virtio/pmem.rs b/devices/src/virtio/pmem.rs
index 87d3d7533..44a58ee2e 100644
--- a/devices/src/virtio/pmem.rs
+++ b/devices/src/virtio/pmem.rs
@@ -291,7 +291,7 @@ async fn handle_queue(
                 0
             }
         };
-        queue.add_used(avail_desc, written as u32);
+        queue.add_used_with_bytes_written(avail_desc, written as u32);
         queue.trigger_interrupt();
     }
 }
diff --git a/devices/src/virtio/pvclock.rs b/devices/src/virtio/pvclock.rs
index 51779f64d..f185e7251 100644
--- a/devices/src/virtio/pvclock.rs
+++ b/devices/src/virtio/pvclock.rs
@@ -842,7 +842,7 @@ fn run_main_worker(
                         desc.len as u32
                     };
 
-                    set_pvclock_page_queue.add_used(desc_chain, len);
+                    set_pvclock_page_queue.add_used_with_bytes_written(desc_chain, len);
                     set_pvclock_page_queue.trigger_interrupt();
                 }
                 Token::SuspendResume => {
diff --git a/devices/src/virtio/queue.rs b/devices/src/virtio/queue.rs
index 1676793c4..8bbb8dd41 100644
--- a/devices/src/virtio/queue.rs
+++ b/devices/src/virtio/queue.rs
@@ -424,6 +424,17 @@ impl Queue {
         self.peek().map(PeekedDescriptorChain::pop)
     }
 
+    /// try to pop DescriptorChain and collect until writable descriptors' total length
+    /// bigger than request_length. If no enough descriptors, return None.
+    pub fn try_pop_length(&mut self, request_length: usize) -> Option<Vec<DescriptorChain>> {
+        match self {
+            Queue::SplitVirtQueue(q) => q.try_pop_length(request_length),
+            Queue::PackedVirtQueue(_q) => {
+                unimplemented!()
+            }
+        }
+    }
+
     /// Returns `None` if stop_rx receives a value; otherwise returns the result
     /// of waiting for the next descriptor.
     pub async fn next_async_interruptable(
@@ -530,14 +541,35 @@ impl Queue {
         &Interrupt,
     );
 
-    define_queue_method!(
-        /// Puts an available descriptor head into the used ring for use by the guest.
-        add_used,
-        (),
-        mut,
-        desc_chain: DescriptorChain,
-        len: u32
-    );
+    /// Puts an available descriptor head into the used ring for use by the guest, using the number
+    /// of bytes written to `DescriptorChain`.
+    pub fn add_used(&mut self, desc_chain: DescriptorChain) {
+        let len: u32 = desc_chain.writer.bytes_written().try_into().unwrap();
+        self.add_used_with_bytes_written(desc_chain, len);
+    }
+
+    /// Puts an available descriptor head into the used ring for use by the guest, explicitly
+    /// specifying the number of bytes written.
+    pub fn add_used_with_bytes_written(&mut self, desc_chain: DescriptorChain, len: u32) {
+        let iter = std::iter::once((desc_chain, len));
+        match self {
+            Queue::SplitVirtQueue(q) => q.add_used_with_bytes_written_batch(iter),
+            Queue::PackedVirtQueue(q) => q.add_used_with_bytes_written_batch(iter),
+        }
+    }
+
+    /// add a batch of descriptor chain into used in one time with each descriptor chain
+    /// specifying the number of bytes written with `desc_chain.writer.bytes_written()`
+    pub fn add_used_batch(&mut self, desc_chains: impl IntoIterator<Item = DescriptorChain>) {
+        let iter = desc_chains.into_iter().map(|desc_chain| {
+            let len: u32 = desc_chain.writer.bytes_written().try_into().unwrap();
+            (desc_chain, len)
+        });
+        match self {
+            Queue::SplitVirtQueue(q) => q.add_used_with_bytes_written_batch(iter),
+            Queue::PackedVirtQueue(q) => q.add_used_with_bytes_written_batch(iter),
+        }
+    }
 
     define_queue_method!(
         /// Take snapshot of queue's current status
diff --git a/devices/src/virtio/queue/packed_queue.rs b/devices/src/virtio/queue/packed_queue.rs
index c3d12ef44..d9c1b369b 100644
--- a/devices/src/virtio/queue/packed_queue.rs
+++ b/devices/src/virtio/queue/packed_queue.rs
@@ -6,6 +6,7 @@
 
 use std::num::Wrapping;
 use std::sync::atomic::fence;
+use std::sync::atomic::AtomicU16;
 use std::sync::atomic::Ordering;
 
 use anyhow::bail;
@@ -309,65 +310,59 @@ impl PackedQueue {
         }
     }
 
-    /// Write to first descriptor in descriptor chain to mark descriptor chain as used
-    pub fn add_used(&mut self, desc_chain: DescriptorChain, len: u32) {
-        let desc_index = desc_chain.index();
-        if desc_index >= self.size {
-            error!(
-                "attempted to add out of bounds descriptor to used ring: {}",
-                desc_index
-            );
-            return;
-        }
+    /// Puts multiple available descriptor heads into the used ring for use by the guest.
+    pub fn add_used_with_bytes_written_batch(
+        &mut self,
+        desc_chains: impl IntoIterator<Item = (DescriptorChain, u32)>,
+    ) {
+        // Get a `VolatileSlice` covering the descriptor table. This ensures that the raw pointers
+        // generated below point into valid `GuestMemory` regions.
+        let desc_table_size = size_of::<PackedDesc>() * usize::from(self.size);
+        let desc_table_vslice = self
+            .mem
+            .get_slice_at_addr(self.desc_table, desc_table_size)
+            .unwrap();
 
-        let chain_id = desc_chain
-            .id
-            .expect("Packed descriptor chain should have id");
+        let desc_table_ptr = desc_table_vslice.as_mut_ptr() as *mut PackedDesc;
 
-        let desc_addr = self
-            .desc_table
-            .checked_add(self.use_index.index.0 as u64 * 16)
-            .expect("Descriptor address should not overflow.");
+        for (desc_chain, len) in desc_chains {
+            debug_assert!(desc_chain.index() < self.size);
 
-        // Write to len field
-        self.mem
-            .write_obj_at_addr(
-                len,
-                desc_addr
-                    .checked_add(8)
-                    .expect("Descriptor address should not overflow."),
-            )
-            .unwrap();
+            let chain_id = desc_chain
+                .id
+                .expect("Packed descriptor chain should have id");
 
-        // Write to id field
-        self.mem
-            .write_obj_at_addr(
-                chain_id,
-                desc_addr
-                    .checked_add(12)
-                    .expect("Descriptor address should not overflow."),
-            )
-            .unwrap();
+            let wrap_counter = self.use_index.wrap_counter;
 
-        let wrap_counter = self.use_index.wrap_counter;
+            let mut flags: u16 = 0;
+            if wrap_counter {
+                flags = flags | VIRTQ_DESC_F_USED | VIRTQ_DESC_F_AVAIL;
+            }
+            if len > 0 {
+                flags |= VIRTQ_DESC_F_WRITE;
+            }
 
-        let mut flags: u16 = 0;
-        if wrap_counter {
-            flags = flags | VIRTQ_DESC_F_USED | VIRTQ_DESC_F_AVAIL;
-        }
-        if len > 0 {
-            flags |= VIRTQ_DESC_F_WRITE;
-        }
+            // SAFETY: `desc_ptr` is always a valid pointer
+            let desc_ptr = unsafe { desc_table_ptr.add(usize::from(self.use_index.index.0)) };
 
-        // Writing to flags should come at the very end to avoid showing the
-        // driver fragmented descriptor data
-        fence(Ordering::SeqCst);
+            // SAFETY: `desc_ptr` is always a valid pointer
+            unsafe {
+                std::ptr::write_volatile(std::ptr::addr_of_mut!((*desc_ptr).len), len.into());
+                std::ptr::write_volatile(std::ptr::addr_of_mut!((*desc_ptr).id), chain_id.into());
+            }
 
-        self.mem
-            .write_obj_at_addr_volatile(flags, desc_addr.unchecked_add(14))
-            .unwrap();
+            // Writing to flags should come at the very end to avoid showing the
+            // driver fragmented descriptor data
+            fence(Ordering::Release);
 
-        self.use_index.add_index(desc_chain.count, self.size());
+            // SAFETY: `desc_ptr` is always a valid pointer
+            let desc_flags_atomic = unsafe {
+                AtomicU16::from_ptr(std::ptr::addr_of_mut!((*desc_ptr).flags) as *mut u16)
+            };
+            desc_flags_atomic.store(u16::to_le(flags), Ordering::Relaxed);
+
+            self.use_index.add_index(desc_chain.count, self.size());
+        }
     }
 
     /// Returns if the queue should have an interrupt sent based on its state.
diff --git a/devices/src/virtio/queue/split_queue.rs b/devices/src/virtio/queue/split_queue.rs
index 3046f2268..6fd552f33 100644
--- a/devices/src/virtio/queue/split_queue.rs
+++ b/devices/src/virtio/queue/split_queue.rs
@@ -4,6 +4,7 @@
 
 use std::num::Wrapping;
 use std::sync::atomic::fence;
+use std::sync::atomic::AtomicU16;
 use std::sync::atomic::Ordering;
 
 use anyhow::bail;
@@ -244,23 +245,6 @@ impl SplitQueue {
         ]
     }
 
-    // Get the index of the first available descriptor chain in the available ring
-    // (the next one that the driver will fill).
-    //
-    // All available ring entries between `self.next_avail` and `get_avail_index()` are available
-    // to be processed by the device.
-    fn get_avail_index(&self) -> Wrapping<u16> {
-        fence(Ordering::SeqCst);
-
-        let avail_index_addr = self.avail_ring.unchecked_add(2);
-        let avail_index: u16 = self
-            .mem
-            .read_obj_from_addr_volatile(avail_index_addr)
-            .unwrap();
-
-        Wrapping(avail_index)
-    }
-
     // Set the `avail_event` field in the used ring.
     //
     // This allows the device to inform the driver that driver-to-device notification
@@ -309,37 +293,47 @@ impl SplitQueue {
         Wrapping(used_event)
     }
 
-    // Set the `idx` field in the used ring.
-    //
-    // This indicates to the driver that all entries up to (but not including) `used_index` have
-    // been used by the device and may be processed by the driver.
-    fn set_used_index(&mut self, used_index: Wrapping<u16>) {
-        fence(Ordering::SeqCst);
-
-        let used_index_addr = self.used_ring.unchecked_add(2);
-        self.mem
-            .write_obj_at_addr_volatile(used_index.0, used_index_addr)
-            .unwrap();
-    }
-
     /// Get the first available descriptor chain without removing it from the queue.
     /// Call `pop_peeked` to remove the returned descriptor chain from the queue.
     pub fn peek(&mut self) -> Option<DescriptorChain> {
-        let avail_index = self.get_avail_index();
-        if self.next_avail == avail_index {
+        // Get a `VolatileSlice` covering the `struct virtq_avail` fixed header (`flags` and `idx`)
+        // and variable-length `ring`. This ensures that the raw pointers generated below point into
+        // valid `GuestMemory` regions.
+        let avail_ring_size = 2 * size_of::<u16>() + (size_of::<u16>() * usize::from(self.size));
+        let avail_ring_vslice = self
+            .mem
+            .get_slice_at_addr(self.avail_ring, avail_ring_size)
+            .unwrap();
+
+        // SAFETY: offset of `virtq_avail.idx` (2) is always within the `VolatileSlice` bounds.
+        let avail_index_ptr = unsafe { avail_ring_vslice.as_mut_ptr().add(2) } as *mut u16;
+        // SAFETY: `GuestMemory::get_slice_at_addr()` returns a valid `VolatileSlice`, and
+        // `avail_index_ptr` is a valid `*mut u16` contained within that slice.
+        let avail_index_atomic = unsafe { AtomicU16::from_ptr(avail_index_ptr) };
+
+        // Check if the driver has published any new descriptors beyond `self.next_avail`. This uses
+        // a `Relaxed` load because we do not need a memory barrier if there are no new descriptors.
+        // If the ring is not empty, the `fence()` below will provide the necessary ordering,
+        // pairing with the write memory barrier in the driver.
+        let avail_index: u16 = avail_index_atomic.load(Ordering::Relaxed);
+        let next_avail = self.next_avail;
+        if next_avail.0 == avail_index {
             return None;
         }
 
         // This fence ensures that subsequent reads from the descriptor do not
         // get reordered and happen only after fetching the available_index and
         // checking that there is a slot available.
-        fence(Ordering::SeqCst);
+        fence(Ordering::Acquire);
 
-        let desc_idx_addr_offset = 4 + (u64::from(self.wrap_queue_index(self.next_avail)) * 2);
-        let desc_idx_addr = self.avail_ring.checked_add(desc_idx_addr_offset)?;
-
-        // This index is checked below in checked_new.
-        let descriptor_index: u16 = self.mem.read_obj_from_addr_volatile(desc_idx_addr).unwrap();
+        // Calculate the offset of `ring[next_avail % size]` within `struct virtq_avail`.
+        let ring_offset = 4 + (usize::from(self.wrap_queue_index(next_avail)) * 2);
+        debug_assert!(ring_offset + size_of::<u16>() <= avail_ring_size);
+        // SAFETY: The available ring index was wrapped to fall within the queue size above, so
+        // `ring_offset` is always in bounds.
+        let ring_ptr = unsafe { avail_ring_vslice.as_ptr().add(ring_offset) } as *const u16;
+        // SAFETY: `ring_ptr` is a valid `*const u16` within `avail_ring_vslice`.
+        let descriptor_index: u16 = unsafe { std::ptr::read_volatile(ring_ptr) };
 
         let chain =
             SplitDescriptorChain::new(&self.mem, self.desc_table, self.size, descriptor_index);
@@ -361,27 +355,86 @@ impl SplitQueue {
         }
     }
 
-    /// Puts an available descriptor head into the used ring for use by the guest.
-    pub fn add_used(&mut self, desc_chain: DescriptorChain, len: u32) {
-        let desc_index = desc_chain.index();
-        debug_assert!(desc_index < self.size);
+    pub(super) fn try_pop_length(&mut self, length: usize) -> Option<Vec<DescriptorChain>> {
+        let mut remain_len = length;
+        let mut descriptors = vec![];
+        while remain_len > 0 {
+            match self.peek() {
+                Some(desc) => {
+                    let available_bytes = desc.writer.available_bytes();
+                    descriptors.push(desc);
+                    self.next_avail += Wrapping(1);
+                    if available_bytes >= remain_len {
+                        if self.features & ((1u64) << VIRTIO_RING_F_EVENT_IDX) != 0 {
+                            self.set_avail_event(self.next_avail);
+                        }
+                        return Some(descriptors);
+                    } else {
+                        remain_len -= available_bytes;
+                    }
+                }
+                None => {
+                    if self.features & ((1u64) << VIRTIO_RING_F_EVENT_IDX) != 0 {
+                        self.set_avail_event(self.next_avail);
+                    }
+                    // Reverse the effect of pop
+                    self.next_avail -= Wrapping(descriptors.len() as u16);
+                    return None;
+                }
+            }
+        }
+        None
+    }
+
+    /// Puts multiple available descriptor heads into the used ring for use by the guest.
+    pub fn add_used_with_bytes_written_batch(
+        &mut self,
+        desc_chains: impl IntoIterator<Item = (DescriptorChain, u32)>,
+    ) {
+        // Get a `VolatileSlice` covering the `struct virtq_used` fixed header (`flags` and `idx`)
+        // and variable-length `ring`. This ensures that the raw pointers generated below point into
+        // valid `GuestMemory` regions.
+        let used_ring_size =
+            2 * size_of::<u16>() + (size_of::<virtq_used_elem>() * usize::from(self.size));
+        let used_ring_vslice = self
+            .mem
+            .get_slice_at_addr(self.used_ring, used_ring_size)
+            .unwrap();
 
-        let used_ring = self.used_ring;
-        let next_used = self.wrap_queue_index(self.next_used) as usize;
-        let used_elem = used_ring.unchecked_add((4 + next_used * 8) as u64);
+        // SAFETY: `elems_ptr` is always a valid pointer due to `used_ring_vslice()`.
+        let elems_ptr = unsafe { used_ring_vslice.as_mut_ptr().add(4) } as *mut virtq_used_elem;
 
-        let elem = virtq_used_elem {
-            id: Le32::from(u32::from(desc_index)),
-            len: Le32::from(len),
-        };
+        // SAFETY: `used_index_ptr` is always a valid pointer due to `used_ring_vslice()`.
+        let used_index_ptr = unsafe { used_ring_vslice.as_mut_ptr().add(2) } as *mut u16;
 
-        // This write can't fail as we are guaranteed to be within the descriptor ring.
-        self.mem
-            .write_obj_at_addr_volatile(elem, used_elem)
-            .unwrap();
+        // SAFETY: `used_index_ptr` is always a valid pointer
+        let used_index_atomic = unsafe { AtomicU16::from_ptr(used_index_ptr) };
+
+        let mut next_used = self.next_used;
+        for (desc_chain, len) in desc_chains {
+            let desc_index = desc_chain.index();
+            debug_assert!(desc_index < self.size);
+            let id = Le32::from(u32::from(desc_index));
+            let len = Le32::from(len);
+
+            let wrapped_index = usize::from(self.wrap_queue_index(next_used));
+            // SAFETY: `wrapped_index` is always in bounds due to `wrap_queue_index()`.
+            let elem_ptr = unsafe { elems_ptr.add(wrapped_index) };
 
-        self.next_used += Wrapping(1);
-        self.set_used_index(self.next_used);
+            // SAFETY: `elem_ptr` is always a valid pointer
+            unsafe {
+                std::ptr::write_volatile(std::ptr::addr_of_mut!((*elem_ptr).id), id);
+                std::ptr::write_volatile(std::ptr::addr_of_mut!((*elem_ptr).len), len);
+            };
+
+            next_used += Wrapping(1);
+        }
+
+        if next_used != self.next_used {
+            fence(Ordering::Release);
+            used_index_atomic.store(next_used.0, Ordering::Relaxed);
+            self.next_used = next_used;
+        }
     }
 
     /// Returns if the queue should have an interrupt sent based on its state.
@@ -695,7 +748,7 @@ mod tests {
         // device has handled them, so increase self.next_used to 0x100
         let mut device_generate: Wrapping<u16> = Wrapping(0x100);
         for _ in 0..device_generate.0 {
-            queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+            queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         }
 
         // At this moment driver hasn't handled any interrupts yet, so it
@@ -713,7 +766,7 @@ mod tests {
         // Assume driver submit another u16::MAX - 0x100 req to device,
         // Device has handled all of them, so increase self.next_used to u16::MAX
         for _ in device_generate.0..u16::MAX {
-            queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+            queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         }
         device_generate = Wrapping(u16::MAX);
 
@@ -731,7 +784,7 @@ mod tests {
 
         // Assume driver submit another 1 request,
         // device has handled it, so wrap self.next_used to 0
-        queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+        queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         device_generate += Wrapping(1);
 
         // At this moment driver has handled all the previous interrupts, so it
@@ -763,7 +816,7 @@ mod tests {
         // device have handled 0x100 req, so increase self.next_used to 0x100
         let mut device_generate: Wrapping<u16> = Wrapping(0x100);
         for _ in 0..device_generate.0 {
-            queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+            queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         }
 
         // At this moment driver hasn't handled any interrupts yet, so it
@@ -780,7 +833,7 @@ mod tests {
 
         // Assume driver submit another 1 request,
         // device has handled it, so increment self.next_used.
-        queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+        queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         device_generate += Wrapping(1);
 
         // At this moment driver hasn't finished last interrupt yet,
@@ -790,7 +843,7 @@ mod tests {
         // Assume driver submit another u16::MAX - 0x101 req to device,
         // Device has handled all of them, so increase self.next_used to u16::MAX
         for _ in device_generate.0..u16::MAX {
-            queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+            queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         }
         device_generate = Wrapping(u16::MAX);
 
@@ -804,7 +857,7 @@ mod tests {
 
         // Assume driver submit another 1 request,
         // device has handled it, so wrap self.next_used to 0
-        queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+        queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         device_generate += Wrapping(1);
 
         // At this moment driver has already finished the last interrupt(0x100),
@@ -813,7 +866,7 @@ mod tests {
 
         // Assume driver submit another 1 request,
         // device has handled it, so increment self.next_used to 1
-        queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+        queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         device_generate += Wrapping(1);
 
         // At this moment driver hasn't finished last interrupt((Wrapping(0)) yet,
@@ -830,7 +883,7 @@ mod tests {
 
         // Assume driver submit another 1 request,
         // device has handled it, so increase self.next_used.
-        queue.add_used(fake_desc_chain(&mem), BUFFER_LEN);
+        queue.add_used_with_bytes_written(fake_desc_chain(&mem), BUFFER_LEN);
         device_generate += Wrapping(1);
 
         // At this moment driver has finished all the previous interrupts, so it
diff --git a/devices/src/virtio/rng.rs b/devices/src/virtio/rng.rs
index 71698b7e4..f9b81f9ce 100644
--- a/devices/src/virtio/rng.rs
+++ b/devices/src/virtio/rng.rs
@@ -51,8 +51,7 @@ impl Worker {
                 }
             }
 
-            let written_size = writer.bytes_written();
-            self.queue.add_used(avail_desc, written_size as u32);
+            self.queue.add_used(avail_desc);
             needs_interrupt = true;
         }
 
diff --git a/devices/src/virtio/scsi/commands.rs b/devices/src/virtio/scsi/commands.rs
index 2aa790a34..94eb5b028 100644
--- a/devices/src/virtio/scsi/commands.rs
+++ b/devices/src/virtio/scsi/commands.rs
@@ -14,6 +14,7 @@ use zerocopy::FromBytes;
 use zerocopy::Immutable;
 use zerocopy::IntoBytes;
 use zerocopy::KnownLayout;
+use zerocopy::Unaligned;
 
 use crate::virtio::scsi::constants::INQUIRY;
 use crate::virtio::scsi::constants::MAINTENANCE_IN;
@@ -151,7 +152,17 @@ impl Command {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct TestUnitReady {
@@ -194,7 +205,17 @@ async fn read_from_disk(
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct Read6 {
@@ -237,7 +258,17 @@ impl Read6 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct Inquiry {
@@ -442,7 +473,17 @@ fn fill_mode_page(
 // According to the spec, devices that implement MODE SENSE(6) shall also implement MODE SELECT(6)
 // as well.
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct ModeSelect6 {
@@ -563,7 +604,17 @@ impl ModeSelect6 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct ModeSense6 {
@@ -714,7 +765,17 @@ impl ModeSense6 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct ReadCapacity10 {
@@ -739,7 +800,17 @@ impl ReadCapacity10 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct ReadCapacity16 {
@@ -766,7 +837,17 @@ impl ReadCapacity16 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct Read10 {
@@ -800,7 +881,17 @@ impl Read10 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct Write10 {
@@ -857,7 +948,17 @@ async fn write_to_disk(
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct SynchronizeCache10 {
@@ -916,7 +1017,17 @@ async fn write_same(
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct WriteSame10 {
@@ -973,7 +1084,17 @@ impl WriteSame10 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct Unmap {
@@ -1041,7 +1162,17 @@ impl Unmap {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct WriteSame16 {
@@ -1095,7 +1226,17 @@ impl WriteSame16 {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct ReportLuns {
@@ -1134,7 +1275,17 @@ impl ReportLuns {
 }
 
 #[derive(
-    Copy, Clone, Debug, Default, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq, Eq,
+    Copy,
+    Clone,
+    Debug,
+    Default,
+    FromBytes,
+    Immutable,
+    IntoBytes,
+    KnownLayout,
+    PartialEq,
+    Eq,
+    Unaligned,
 )]
 #[repr(C, packed)]
 pub struct ReportSupportedTMFs {
diff --git a/devices/src/virtio/scsi/device.rs b/devices/src/virtio/scsi/device.rs
index cb8356b82..6a91e5a99 100644
--- a/devices/src/virtio/scsi/device.rs
+++ b/devices/src/virtio/scsi/device.rs
@@ -787,7 +787,7 @@ async fn process_one_chain(
     let _trace = cros_tracing::trace_event!(VirtioScsi, "process_one_chain");
     let len = process_one_request(&mut avail_desc, queue_type, sense_size, cdb_size).await;
     let mut queue = queue.borrow_mut();
-    queue.add_used(avail_desc, len as u32);
+    queue.add_used_with_bytes_written(avail_desc, len as u32);
     queue.trigger_interrupt();
 }
 
diff --git a/devices/src/virtio/snd/common_backend/async_funcs.rs b/devices/src/virtio/snd/common_backend/async_funcs.rs
index 4280aed7f..f9dbdeb3b 100644
--- a/devices/src/virtio/snd/common_backend/async_funcs.rs
+++ b/devices/src/virtio/snd/common_backend/async_funcs.rs
@@ -547,8 +547,7 @@ fn send_pcm_response(
             .consume_bytes(writer.available_bytes() - std::mem::size_of::<virtio_snd_pcm_status>());
     }
     writer.write_obj(status).map_err(Error::WriteResponse)?;
-    let len = writer.bytes_written() as u32;
-    queue.add_used(desc_chain, len);
+    queue.add_used(desc_chain);
     queue.trigger_interrupt();
     Ok(())
 }
@@ -986,8 +985,7 @@ pub async fn handle_ctrl_queue(
         };
 
         handle_ctrl_msg.await?;
-        let len = writer.bytes_written() as u32;
-        queue.add_used(desc_chain, len);
+        queue.add_used(desc_chain);
         queue.trigger_interrupt();
     }
     Ok(())
@@ -1005,7 +1003,7 @@ pub async fn handle_event_queue(
             .map_err(Error::Async)?;
 
         // TODO(woodychow): Poll and forward events from cras asynchronously (API to be added)
-        queue.add_used(desc_chain, 0);
+        queue.add_used(desc_chain);
         queue.trigger_interrupt();
     }
 }
diff --git a/devices/src/virtio/snd/vios_backend/streams.rs b/devices/src/virtio/snd/vios_backend/streams.rs
index a64c4cb8e..2fa35686f 100644
--- a/devices/src/virtio/snd/vios_backend/streams.rs
+++ b/devices/src/virtio/snd/vios_backend/streams.rs
@@ -302,10 +302,9 @@ impl Stream {
                         // release the buffer if the sound server client returned too soon.
                         std::thread::sleep(self.next_buffer - elapsed);
                     }
-                    let len = writer.bytes_written() as u32;
                     {
                         let mut io_queue_lock = self.io_queue.lock();
-                        io_queue_lock.add_used(desc, len);
+                        io_queue_lock.add_used(desc);
                         io_queue_lock.trigger_interrupt();
                     }
                 }
@@ -434,10 +433,9 @@ pub fn reply_control_op_status(
             code: Le32::from(code),
         })
         .map_err(SoundError::QueueIO)?;
-    let len = writer.bytes_written() as u32;
     {
         let mut queue_lock = queue.lock();
-        queue_lock.add_used(desc, len);
+        queue_lock.add_used(desc);
         queue_lock.trigger_interrupt();
     }
     Ok(())
@@ -461,10 +459,9 @@ pub fn reply_pcm_buffer_status(
             latency_bytes: Le32::from(latency_bytes),
         })
         .map_err(SoundError::QueueIO)?;
-    let len = writer.bytes_written() as u32;
     {
         let mut queue_lock = queue.lock();
-        queue_lock.add_used(desc, len);
+        queue_lock.add_used(desc);
         queue_lock.trigger_interrupt();
     }
     Ok(())
diff --git a/devices/src/virtio/snd/vios_backend/worker.rs b/devices/src/virtio/snd/vios_backend/worker.rs
index 7fb04deda..6fb38088f 100644
--- a/devices/src/virtio/snd/vios_backend/worker.rs
+++ b/devices/src/virtio/snd/vios_backend/worker.rs
@@ -271,10 +271,9 @@ impl Worker {
                             code: Le32::from(code),
                         })
                         .map_err(SoundError::QueueIO)?;
-                    let len = writer.bytes_written() as u32;
                     {
                         let mut queue_lock = self.control_queue.lock();
-                        queue_lock.add_used(avail_desc, len);
+                        queue_lock.add_used(avail_desc);
                         queue_lock.trigger_interrupt();
                     }
                 }
@@ -373,8 +372,7 @@ impl Worker {
             if let Some(mut desc) = event_queue.pop() {
                 let writer = &mut desc.writer;
                 writer.write_obj(evt).map_err(SoundError::QueueIO)?;
-                let len = writer.bytes_written() as u32;
-                event_queue.add_used(desc, len);
+                event_queue.add_used(desc);
                 event_queue.trigger_interrupt();
             } else {
                 warn!("virtio-snd: Dropping event because there are no buffers in virtqueue");
@@ -479,10 +477,9 @@ impl Worker {
         for info in info_vec {
             writer.write_obj(info).map_err(SoundError::QueueIO)?;
         }
-        let len = writer.bytes_written() as u32;
         {
             let mut queue_lock = self.control_queue.lock();
-            queue_lock.add_used(desc, len);
+            queue_lock.add_used(desc);
             queue_lock.trigger_interrupt();
         }
         Ok(())
diff --git a/devices/src/virtio/tpm.rs b/devices/src/virtio/tpm.rs
index ee258e872..0464aa3d3 100644
--- a/devices/src/virtio/tpm.rs
+++ b/devices/src/virtio/tpm.rs
@@ -90,7 +90,7 @@ impl Worker {
                 }
             };
 
-            self.queue.add_used(avail_desc, len);
+            self.queue.add_used_with_bytes_written(avail_desc, len);
             needs_interrupt = NeedsInterrupt::Yes;
         }
 
diff --git a/devices/src/virtio/vhost/net.rs b/devices/src/virtio/vhost/net.rs
index bab260743..c8636177a 100644
--- a/devices/src/virtio/vhost/net.rs
+++ b/devices/src/virtio/vhost/net.rs
@@ -67,6 +67,7 @@ where
         mac_addr: Option<MacAddress>,
         use_packed_queue: bool,
         pci_address: Option<PciAddress>,
+        mrg_rxbuf: bool,
     ) -> Result<Net<T, U>> {
         // Set offload flags to match the virtio features below.
         tap.set_offload(
@@ -98,6 +99,10 @@ where
             avail_features |= 1 << virtio_net::VIRTIO_NET_F_MAC;
         }
 
+        if mrg_rxbuf {
+            avail_features |= 1 << virtio_net::VIRTIO_NET_F_MRG_RXBUF;
+        }
+
         let mut vhost_interrupt = Vec::new();
         for _ in 0..NUM_QUEUES {
             vhost_interrupt.push(Event::new().map_err(Error::VhostIrqCreate)?);
@@ -375,6 +380,7 @@ pub mod tests {
             Some(mac),
             false,
             None,
+            false,
         )
         .unwrap()
     }
diff --git a/devices/src/virtio/vhost/user/device/block/sys/linux.rs b/devices/src/virtio/vhost/user/device/block/sys/linux.rs
index 8569ce9f0..d90c6e4ac 100644
--- a/devices/src/virtio/vhost/user/device/block/sys/linux.rs
+++ b/devices/src/virtio/vhost/user/device/block/sys/linux.rs
@@ -39,7 +39,7 @@ pub struct Options {
 pub fn start_device(opts: Options) -> anyhow::Result<()> {
     let ex = Executor::new().context("failed to create executor")?;
 
-    let mut fileopts = opts.file.split(":").collect::<Vec<_>>();
+    let mut fileopts = opts.file.split(':').collect::<Vec<_>>();
     let filename = fileopts.remove(0);
 
     let disk = DiskOption {
diff --git a/devices/src/virtio/vhost/user/device/connection/sys/linux/stream.rs b/devices/src/virtio/vhost/user/device/connection/sys/linux/stream.rs
index f3b008562..3e7061245 100644
--- a/devices/src/virtio/vhost/user/device/connection/sys/linux/stream.rs
+++ b/devices/src/virtio/vhost/user/device/connection/sys/linux/stream.rs
@@ -9,6 +9,7 @@ use std::path::Path;
 use std::path::PathBuf;
 use std::pin::Pin;
 
+use anyhow::anyhow;
 use base::safe_descriptor_from_cmdline_fd;
 use base::AsRawDescriptor;
 use base::RawDescriptor;
@@ -17,7 +18,6 @@ use futures::Future;
 use futures::FutureExt;
 use vmm_vhost::BackendServer;
 use vmm_vhost::Connection;
-use vmm_vhost::Error::SocketFromFdError;
 
 use crate::virtio::vhost::user::device::connection::VhostUserConnectionTrait;
 use crate::virtio::vhost::user::device::handler::sys::linux::run_handler;
@@ -43,7 +43,7 @@ impl VhostUserStream {
     pub fn new_socket_from_fd(socket_fd: RawDescriptor) -> anyhow::Result<Self> {
         let path = PathBuf::from(format!("/proc/self/fd/{}", socket_fd));
         if !path_is_socket(&path) {
-            return Err(SocketFromFdError(path).into());
+            return Err(anyhow!("fd {} is not a socket", socket_fd));
         }
 
         let safe_fd = safe_descriptor_from_cmdline_fd(&socket_fd)?;
diff --git a/devices/src/virtio/vhost/user/device/gpu.rs b/devices/src/virtio/vhost/user/device/gpu.rs
index dcf4ac928..1bf447cd7 100644
--- a/devices/src/virtio/vhost/user/device/gpu.rs
+++ b/devices/src/virtio/vhost/user/device/gpu.rs
@@ -54,7 +54,9 @@ impl gpu::QueueReader for SharedReader {
     }
 
     fn add_used(&self, desc_chain: DescriptorChain, len: u32) {
-        self.queue.lock().add_used(desc_chain, len)
+        self.queue
+            .lock()
+            .add_used_with_bytes_written(desc_chain, len)
     }
 
     fn signal_used(&self) {
@@ -267,11 +269,11 @@ impl VhostUserDevice for GpuBackend {
         self.gpu.borrow().get_shared_memory_region()
     }
 
-    fn set_backend_req_connection(&mut self, conn: Arc<VhostBackendReqConnection>) {
+    fn set_backend_req_connection(&mut self, conn: VhostBackendReqConnection) {
         if self
             .shmem_mapper
             .lock()
-            .replace(conn.take_shmem_mapper().unwrap())
+            .replace(conn.shmem_mapper().unwrap())
             .is_some()
         {
             warn!("Connection already established. Overwriting shmem_mapper");
diff --git a/devices/src/virtio/vhost/user/device/handler.rs b/devices/src/virtio/vhost/user/device/handler.rs
index 0c2b87b3a..1c0a48175 100644
--- a/devices/src/virtio/vhost/user/device/handler.rs
+++ b/devices/src/virtio/vhost/user/device/handler.rs
@@ -49,6 +49,8 @@ pub(super) mod sys;
 use std::collections::BTreeMap;
 use std::convert::From;
 use std::fs::File;
+use std::io::BufReader;
+use std::io::Write;
 use std::num::Wrapping;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use std::os::unix::io::AsRawFd;
@@ -176,12 +178,9 @@ pub trait VhostUserDevice {
     /// Accepts `VhostBackendReqConnection` to conduct Vhost backend to frontend message
     /// handling.
     ///
-    /// The backend is given an `Arc` instead of full ownership so that the framework can also use
-    /// the connection.
-    ///
     /// This method will be called when `VhostUserProtocolFeatures::BACKEND_REQ` is
     /// negotiated.
-    fn set_backend_req_connection(&mut self, _conn: Arc<VhostBackendReqConnection>) {}
+    fn set_backend_req_connection(&mut self, _conn: VhostBackendReqConnection) {}
 
     /// Enter the "suspended device state" described in the vhost-user spec. See the spec for
     /// requirements.
@@ -288,14 +287,14 @@ pub struct DeviceRequestHandler<T: VhostUserDevice> {
     acked_features: u64,
     acked_protocol_features: VhostUserProtocolFeatures,
     backend: T,
-    backend_req_connection: Arc<Mutex<VhostBackendReqConnectionState>>,
+    backend_req_connection: Option<VhostBackendReqConnection>,
     // Thread processing active device state FD.
     device_state_thread: Option<DeviceStateThread>,
 }
 
 enum DeviceStateThread {
-    Save(WorkerThread<serde_json::Result<()>>),
-    Load(WorkerThread<serde_json::Result<DeviceRequestHandlerSnapshot>>),
+    Save(WorkerThread<Result<(), ciborium::ser::Error<std::io::Error>>>),
+    Load(WorkerThread<Result<DeviceRequestHandlerSnapshot, ciborium::de::Error<std::io::Error>>>),
 }
 
 #[derive(Serialize, Deserialize)]
@@ -327,9 +326,7 @@ impl<T: VhostUserDevice> DeviceRequestHandler<T> {
             acked_features: 0,
             acked_protocol_features: VhostUserProtocolFeatures::empty(),
             backend,
-            backend_req_connection: Arc::new(Mutex::new(
-                VhostBackendReqConnectionState::NoConnection,
-            )),
+            backend_req_connection: None,
             device_state_thread: None,
         }
     }
@@ -603,13 +600,12 @@ impl<T: VhostUserDevice> vmm_vhost::Backend for DeviceRequestHandler<T> {
         }
 
         let backend_req_conn = self.backend_req_connection.clone();
-        let signal_config_change_fn = Box::new(move || match &*backend_req_conn.lock() {
-            VhostBackendReqConnectionState::Connected(frontend) => {
+        let signal_config_change_fn = Box::new(move || {
+            if let Some(frontend) = backend_req_conn.as_ref() {
                 if let Err(e) = frontend.send_config_changed() {
                     error!("Failed to notify config change: {:#}", e);
                 }
-            }
-            VhostBackendReqConnectionState::NoConnection => {
+            } else {
                 error!("No Backend request connection found");
             }
         });
@@ -670,18 +666,15 @@ impl<T: VhostUserDevice> vmm_vhost::Backend for DeviceRequestHandler<T> {
     }
 
     fn set_backend_req_fd(&mut self, ep: Connection<BackendReq>) {
-        let conn = Arc::new(VhostBackendReqConnection::new(
+        let conn = VhostBackendReqConnection::new(
             FrontendClient::new(ep),
             self.backend.get_shared_memory_region().map(|r| r.id),
-        ));
+        );
 
-        {
-            let mut backend_req_conn = self.backend_req_connection.lock();
-            if let VhostBackendReqConnectionState::Connected(_) = &*backend_req_conn {
-                warn!("Backend Request Connection already established. Overwriting");
-            }
-            *backend_req_conn = VhostBackendReqConnectionState::Connected(conn.clone());
+        if self.backend_req_connection.is_some() {
+            warn!("Backend Request Connection already established. Overwriting");
         }
+        self.backend_req_connection = Some(conn.clone());
 
         self.backend.set_backend_req_connection(conn);
     }
@@ -720,7 +713,7 @@ impl<T: VhostUserDevice> vmm_vhost::Backend for DeviceRequestHandler<T> {
         &mut self,
         transfer_direction: VhostUserTransferDirection,
         migration_phase: VhostUserMigrationPhase,
-        mut fd: File,
+        fd: File,
     ) -> VhostResult<Option<File>> {
         if migration_phase != VhostUserMigrationPhase::Stopped {
             return Err(VhostError::InvalidOperation);
@@ -747,7 +740,12 @@ impl<T: VhostUserDevice> vmm_vhost::Backend for DeviceRequestHandler<T> {
                 // Spawn thread to write the serialized bytes.
                 self.device_state_thread = Some(DeviceStateThread::Save(WorkerThread::start(
                     "device_state_save",
-                    move |_kill_event| serde_json::to_writer(&mut fd, &snapshot),
+                    move |_kill_event| -> Result<(), ciborium::ser::Error<std::io::Error>> {
+                        let mut w = std::io::BufWriter::new(fd);
+                        ciborium::into_writer(&snapshot, &mut w)?;
+                        w.flush()?;
+                        Ok(())
+                    },
                 )));
                 Ok(None)
             }
@@ -756,7 +754,7 @@ impl<T: VhostUserDevice> vmm_vhost::Backend for DeviceRequestHandler<T> {
                 // `check_device_state`.
                 self.device_state_thread = Some(DeviceStateThread::Load(WorkerThread::start(
                     "device_state_load",
-                    move |_kill_event| serde_json::from_reader(&mut fd),
+                    move |_kill_event| ciborium::from_reader(&mut BufReader::new(fd)),
                 )));
                 Ok(None)
             }
@@ -808,65 +806,56 @@ impl<T: VhostUserDevice> vmm_vhost::Backend for DeviceRequestHandler<T> {
     }
 }
 
-/// Indicates the state of backend request connection
-pub enum VhostBackendReqConnectionState {
-    /// A backend request connection (`VhostBackendReqConnection`) is established
-    Connected(Arc<VhostBackendReqConnection>),
-    /// No backend request connection has been established yet
-    NoConnection,
-}
-
 /// Keeps track of Vhost user backend request connection.
+#[derive(Clone)]
 pub struct VhostBackendReqConnection {
-    conn: Arc<Mutex<FrontendClient>>,
-    shmem_info: Mutex<Option<ShmemInfo>>,
+    shared: Arc<Mutex<VhostBackendReqConnectionShared>>,
+    shmid: Option<u8>,
 }
 
-#[derive(Clone)]
-struct ShmemInfo {
-    shmid: u8,
+struct VhostBackendReqConnectionShared {
+    conn: FrontendClient,
     mapped_regions: BTreeMap<u64 /* offset */, u64 /* size */>,
 }
 
 impl VhostBackendReqConnection {
-    pub fn new(conn: FrontendClient, shmid: Option<u8>) -> Self {
-        let shmem_info = Mutex::new(shmid.map(|shmid| ShmemInfo {
-            shmid,
-            mapped_regions: BTreeMap::new(),
-        }));
+    fn new(conn: FrontendClient, shmid: Option<u8>) -> Self {
         Self {
-            conn: Arc::new(Mutex::new(conn)),
-            shmem_info,
+            shared: Arc::new(Mutex::new(VhostBackendReqConnectionShared {
+                conn,
+                mapped_regions: BTreeMap::new(),
+            })),
+            shmid,
         }
     }
 
     /// Send `VHOST_USER_CONFIG_CHANGE_MSG` to the frontend
-    pub fn send_config_changed(&self) -> anyhow::Result<()> {
-        self.conn
-            .lock()
+    fn send_config_changed(&self) -> anyhow::Result<()> {
+        let mut shared = self.shared.lock();
+        shared
+            .conn
             .handle_config_change()
             .context("Could not send config change message")?;
         Ok(())
     }
 
-    /// Create a SharedMemoryMapper trait object from the ShmemInfo.
-    pub fn take_shmem_mapper(&self) -> anyhow::Result<Box<dyn SharedMemoryMapper>> {
-        let shmem_info = self
-            .shmem_info
-            .lock()
-            .take()
-            .context("could not take shared memory mapper information")?;
-
-        Ok(Box::new(VhostShmemMapper {
-            conn: self.conn.clone(),
-            shmem_info,
-        }))
+    /// Create a SharedMemoryMapper trait object using this backend request connection.
+    pub fn shmem_mapper(&self) -> Option<Box<dyn SharedMemoryMapper>> {
+        if let Some(shmid) = self.shmid {
+            Some(Box::new(VhostShmemMapper {
+                shared: self.shared.clone(),
+                shmid,
+            }))
+        } else {
+            None
+        }
     }
 }
 
+#[derive(Clone)]
 struct VhostShmemMapper {
-    conn: Arc<Mutex<FrontendClient>>,
-    shmem_info: ShmemInfo,
+    shared: Arc<Mutex<VhostBackendReqConnectionShared>>,
+    shmid: u8,
 }
 
 impl SharedMemoryMapper for VhostShmemMapper {
@@ -877,6 +866,7 @@ impl SharedMemoryMapper for VhostShmemMapper {
         prot: Protection,
         _cache: MemCacheType,
     ) -> anyhow::Result<()> {
+        let mut shared = self.shared.lock();
         let size = match source {
             VmMemorySource::Vulkan {
                 descriptor,
@@ -887,7 +877,7 @@ impl SharedMemoryMapper for VhostShmemMapper {
                 size,
             } => {
                 let msg = VhostUserGpuMapMsg::new(
-                    self.shmem_info.shmid,
+                    self.shmid,
                     offset,
                     size,
                     memory_idx,
@@ -895,18 +885,18 @@ impl SharedMemoryMapper for VhostShmemMapper {
                     device_uuid,
                     driver_uuid,
                 );
-                self.conn
-                    .lock()
+                shared
+                    .conn
                     .gpu_map(&msg, &descriptor)
-                    .context("failed to map memory")?;
+                    .context("map GPU memory")?;
                 size
             }
             VmMemorySource::ExternalMapping { ptr, size } => {
-                let msg = VhostUserExternalMapMsg::new(self.shmem_info.shmid, offset, size, ptr);
-                self.conn
-                    .lock()
+                let msg = VhostUserExternalMapMsg::new(self.shmid, offset, size, ptr);
+                shared
+                    .conn
                     .external_map(&msg)
-                    .context("failed to map memory")?;
+                    .context("create external mapping")?;
                 size
             }
             source => {
@@ -926,36 +916,30 @@ impl SharedMemoryMapper for VhostShmemMapper {
                     _ => bail!("unsupported source"),
                 };
                 let flags = VhostUserShmemMapMsgFlags::from(prot);
-                let msg = VhostUserShmemMapMsg::new(
-                    self.shmem_info.shmid,
-                    offset,
-                    fd_offset,
-                    size,
-                    flags,
-                );
-                self.conn
-                    .lock()
+                let msg = VhostUserShmemMapMsg::new(self.shmid, offset, fd_offset, size, flags);
+                shared
+                    .conn
                     .shmem_map(&msg, &descriptor)
-                    .context("failed to map memory")?;
+                    .context("map shmem")?;
                 size
             }
         };
 
-        self.shmem_info.mapped_regions.insert(offset, size);
+        shared.mapped_regions.insert(offset, size);
         Ok(())
     }
 
     fn remove_mapping(&mut self, offset: u64) -> anyhow::Result<()> {
-        let size = self
-            .shmem_info
+        let mut shared = self.shared.lock();
+        let size = shared
             .mapped_regions
             .remove(&offset)
             .context("unknown offset")?;
-        let msg = VhostUserShmemUnmapMsg::new(self.shmem_info.shmid, offset, size);
-        self.conn
-            .lock()
+        let msg = VhostUserShmemUnmapMsg::new(self.shmid, offset, size);
+        shared
+            .conn
             .shmem_unmap(&msg)
-            .context("failed to map memory")
+            .context("unmap shmem")
             .map(|_| ())
     }
 }
@@ -1006,7 +990,7 @@ mod tests {
         acked_features: u64,
         active_queues: Vec<Option<Queue>>,
         allow_backend_req: bool,
-        backend_conn: Option<Arc<VhostBackendReqConnection>>,
+        backend_conn: Option<VhostBackendReqConnection>,
     }
 
     #[derive(Deserialize, Serialize)]
@@ -1082,7 +1066,7 @@ mod tests {
                 .ok_or(Error::WorkerNotFound)?)
         }
 
-        fn set_backend_req_connection(&mut self, conn: Arc<VhostBackendReqConnection>) {
+        fn set_backend_req_connection(&mut self, conn: VhostBackendReqConnection) {
             self.backend_conn = Some(conn);
         }
 
@@ -1216,7 +1200,6 @@ mod tests {
         // VhostUserFrontend::new()
         handle_request(&mut req_handler, FrontendReq::SET_OWNER).unwrap();
         handle_request(&mut req_handler, FrontendReq::GET_FEATURES).unwrap();
-        handle_request(&mut req_handler, FrontendReq::SET_FEATURES).unwrap();
         handle_request(&mut req_handler, FrontendReq::GET_PROTOCOL_FEATURES).unwrap();
         handle_request(&mut req_handler, FrontendReq::SET_PROTOCOL_FEATURES).unwrap();
         if allow_backend_req {
@@ -1227,6 +1210,7 @@ mod tests {
         handle_request(&mut req_handler, FrontendReq::GET_CONFIG).unwrap();
 
         // VhostUserFrontend::activate()
+        handle_request(&mut req_handler, FrontendReq::SET_FEATURES).unwrap();
         handle_request(&mut req_handler, FrontendReq::SET_MEM_TABLE).unwrap();
         for _ in 0..QUEUES_NUM {
             handle_request(&mut req_handler, FrontendReq::SET_VRING_NUM).unwrap();
@@ -1244,6 +1228,7 @@ mod tests {
         }
 
         // VhostUserFrontend::activate()
+        handle_request(&mut req_handler, FrontendReq::SET_FEATURES).unwrap();
         handle_request(&mut req_handler, FrontendReq::SET_MEM_TABLE).unwrap();
         for _ in 0..QUEUES_NUM {
             handle_request(&mut req_handler, FrontendReq::SET_VRING_NUM).unwrap();
diff --git a/devices/src/virtio/vhost/user/device/mod.rs b/devices/src/virtio/vhost/user/device/mod.rs
index 44be1f95e..0f03fa46e 100644
--- a/devices/src/virtio/vhost/user/device/mod.rs
+++ b/devices/src/virtio/vhost/user/device/mod.rs
@@ -22,7 +22,6 @@ use cros_async::Executor;
 pub use gpu::run_gpu_device;
 #[cfg(feature = "gpu")]
 pub use gpu::Options as GpuOptions;
-pub use handler::VhostBackendReqConnectionState;
 pub use handler::VhostUserDevice;
 #[cfg(feature = "net")]
 pub use net::run_net_device;
diff --git a/devices/src/virtio/vhost/user/device/net.rs b/devices/src/virtio/vhost/user/device/net.rs
index 3e207d9c8..6b6e221b0 100644
--- a/devices/src/virtio/vhost/user/device/net.rs
+++ b/devices/src/virtio/vhost/user/device/net.rs
@@ -4,6 +4,8 @@
 
 pub mod sys;
 
+use std::cell::OnceCell;
+
 use anyhow::anyhow;
 use anyhow::Context;
 use base::error;
@@ -17,7 +19,6 @@ use futures::pin_mut;
 use futures::select_biased;
 use futures::FutureExt;
 use net_util::TapT;
-use once_cell::sync::OnceCell;
 use serde::Deserialize;
 use serde::Serialize;
 use snapshot::AnySnapshot;
diff --git a/devices/src/virtio/vhost/user/device/net/sys/linux.rs b/devices/src/virtio/vhost/user/device/net/sys/linux.rs
index 0d92904f1..99fce9b71 100644
--- a/devices/src/virtio/vhost/user/device/net/sys/linux.rs
+++ b/devices/src/virtio/vhost/user/device/net/sys/linux.rs
@@ -31,9 +31,11 @@ use vm_memory::GuestMemory;
 use vmm_vhost::VHOST_USER_F_PROTOCOL_FEATURES;
 
 use crate::virtio;
+use crate::virtio::net::process_mrg_rx;
 use crate::virtio::net::process_rx;
 use crate::virtio::net::validate_and_configure_tap;
 use crate::virtio::net::NetError;
+use crate::virtio::net::PendingBuffer;
 use crate::virtio::vhost::user::device::connection::sys::VhostUserListener;
 use crate::virtio::vhost::user::device::connection::VhostUserConnectionTrait;
 use crate::virtio::vhost::user::device::handler::VhostUserDevice;
@@ -80,7 +82,7 @@ impl<T: 'static> NetBackend<T>
 where
     T: TapT + IntoAsync,
 {
-    fn new_from_config(config: &TapConfig) -> anyhow::Result<Self> {
+    fn new_from_config(config: &TapConfig, mrg_rxbuf: bool) -> anyhow::Result<Self> {
         // Create a tap device.
         let tap = T::new(true /* vnet_hdr */, false /* multi_queue */)
             .context("failed to create tap device")?;
@@ -91,29 +93,29 @@ where
         tap.set_mac_address(config.mac)
             .context("failed to set MAC address")?;
 
-        Self::new(tap)
+        Self::new(tap, mrg_rxbuf)
     }
 
-    fn new_from_name(name: &str) -> anyhow::Result<Self> {
+    fn new_from_name(name: &str, mrg_rxbuf: bool) -> anyhow::Result<Self> {
         let tap = T::new_with_name(name.as_bytes(), true, false).map_err(NetError::TapOpen)?;
-        Self::new(tap)
+        Self::new(tap, mrg_rxbuf)
     }
 
-    pub fn new_from_tap_fd(tap_fd: RawDescriptor) -> anyhow::Result<Self> {
+    pub fn new_from_tap_fd(tap_fd: RawDescriptor, mrg_rxbuf: bool) -> anyhow::Result<Self> {
         let tap_fd = validate_raw_descriptor(tap_fd).context("failed to validate tap fd")?;
         // SAFETY:
         // Safe because we ensure that we get a unique handle to the fd.
         let tap = unsafe { T::from_raw_descriptor(tap_fd).context("failed to create tap device")? };
 
-        Self::new(tap)
+        Self::new(tap, mrg_rxbuf)
     }
 
-    pub fn new(tap: T) -> anyhow::Result<Self> {
+    pub fn new(tap: T, mrg_rxbuf: bool) -> anyhow::Result<Self> {
         let vq_pairs = Self::max_vq_pairs();
         validate_and_configure_tap(&tap, vq_pairs as u16)
             .context("failed to validate and configure tap")?;
 
-        let avail_features = virtio::base_features(ProtectionType::Unprotected)
+        let mut avail_features = virtio::base_features(ProtectionType::Unprotected)
             | 1 << virtio_net::VIRTIO_NET_F_GUEST_CSUM
             | 1 << virtio_net::VIRTIO_NET_F_CSUM
             | 1 << virtio_net::VIRTIO_NET_F_CTRL_VQ
@@ -125,6 +127,10 @@ where
             | 1 << virtio_net::VIRTIO_NET_F_MTU
             | 1 << VHOST_USER_F_PROTOCOL_FEATURES;
 
+        if mrg_rxbuf {
+            avail_features |= 1 << virtio_net::VIRTIO_NET_F_MRG_RXBUF;
+        }
+
         let mtu = tap.mtu()?;
 
         Ok(Self {
@@ -142,25 +148,40 @@ async fn run_rx_queue<T: TapT>(
     mut tap: IoSource<T>,
     kick_evt: EventAsync,
     mut stop_rx: oneshot::Receiver<()>,
+    mrg_rxbuf: bool,
 ) -> Queue {
+    let mut pending_buffer = if mrg_rxbuf {
+        Some(PendingBuffer::new())
+    } else {
+        None
+    };
     loop {
-        select_biased! {
-            // `tap.wait_readable()` requires an immutable reference to `tap`, but `process_rx`
-            // requires a mutable reference to `tap`, so this future needs to be recreated on
-            // every iteration. If more arms are added that doesn't break out of the loop, then
-            // this future could be recreated too many times.
-            rx = tap.wait_readable().fuse() => {
-                if let Err(e) = rx {
-                    error!("Failed to wait for tap device to become readable: {}", e);
+        let pending_length = pending_buffer
+            .as_ref()
+            .map_or(0, |pending_buffer| pending_buffer.length);
+        if pending_length == 0 {
+            select_biased! {
+                // `tap.wait_readable()` requires an immutable reference to `tap`, but `process_rx`
+                // requires a mutable reference to `tap`, so this future needs to be recreated on
+                // every iteration. If more arms are added that doesn't break out of the loop, then
+                // this future could be recreated too many times.
+                rx = tap.wait_readable().fuse() => {
+                    if let Err(e) = rx {
+                        error!("Failed to wait for tap device to become readable: {}", e);
+                        break;
+                    }
+                }
+                _ = stop_rx => {
                     break;
                 }
             }
-            _ = stop_rx => {
-                break;
-            }
         }
+        let res = match pending_buffer.as_mut() {
+            Some(pending_buffer) => process_mrg_rx(&mut queue, tap.as_source_mut(), pending_buffer),
+            None => process_rx(&mut queue, tap.as_source_mut()),
+        };
 
-        match process_rx(&mut queue, tap.as_source_mut()) {
+        match res {
             Ok(()) => {}
             Err(NetError::RxDescriptorsExhausted) => {
                 select_biased! {
@@ -216,9 +237,11 @@ pub(in crate::virtio::vhost::user::device::net) fn start_queue<T: 'static + Into
                     .async_from(tap)
                     .context("failed to create async tap device")?;
 
+                let mrg_rxbuf =
+                    (backend.acked_features & 1 << virtio_net::VIRTIO_NET_F_MRG_RXBUF) != 0;
                 let (stop_tx, stop_rx) = futures::channel::oneshot::channel();
                 (
-                    ex.spawn_local(run_rx_queue(queue, tap, kick_evt, stop_rx)),
+                    ex.spawn_local(run_rx_queue(queue, tap, kick_evt, stop_rx, mrg_rxbuf)),
                     stop_tx,
                 )
             }
@@ -264,13 +287,19 @@ pub struct Options {
     #[argh(option, arg_name = "SOCKET_PATH,TAP_NAME")]
     /// TAP NAME with a socket path
     tap_name: Vec<String>,
+    #[argh(switch, arg_name = "MRG_RXBUF")]
+    /// whether enable MRG_RXBUF feature.
+    mrg_rxbuf: bool,
 }
 
 enum Connection {
     Socket(String),
 }
 
-fn new_backend_from_device_arg(arg: &str) -> anyhow::Result<(String, NetBackend<Tap>)> {
+fn new_backend_from_device_arg(
+    arg: &str,
+    mrg_rxbuf: bool,
+) -> anyhow::Result<(String, NetBackend<Tap>)> {
     let pos = match arg.find(',') {
         Some(p) => p,
         None => {
@@ -281,11 +310,15 @@ fn new_backend_from_device_arg(arg: &str) -> anyhow::Result<(String, NetBackend<
     let cfg = &arg[pos + 1..]
         .parse::<TapConfig>()
         .context("failed to parse tap config")?;
-    let backend = NetBackend::<Tap>::new_from_config(cfg).context("failed to create NetBackend")?;
+    let backend = NetBackend::<Tap>::new_from_config(cfg, mrg_rxbuf)
+        .context("failed to create NetBackend")?;
     Ok((conn.to_string(), backend))
 }
 
-fn new_backend_from_tap_name(arg: &str) -> anyhow::Result<(String, NetBackend<Tap>)> {
+fn new_backend_from_tap_name(
+    arg: &str,
+    mrg_rxbuf: bool,
+) -> anyhow::Result<(String, NetBackend<Tap>)> {
     let pos = match arg.find(',') {
         Some(p) => p,
         None => {
@@ -295,12 +328,15 @@ fn new_backend_from_tap_name(arg: &str) -> anyhow::Result<(String, NetBackend<Ta
     let conn = &arg[0..pos];
     let tap_name = &arg[pos + 1..];
 
-    let backend =
-        NetBackend::<Tap>::new_from_name(tap_name).context("failed to create NetBackend")?;
+    let backend = NetBackend::<Tap>::new_from_name(tap_name, mrg_rxbuf)
+        .context("failed to create NetBackend")?;
     Ok((conn.to_string(), backend))
 }
 
-fn new_backend_from_tapfd_arg(arg: &str) -> anyhow::Result<(String, NetBackend<Tap>)> {
+fn new_backend_from_tapfd_arg(
+    arg: &str,
+    mrg_rxbuf: bool,
+) -> anyhow::Result<(String, NetBackend<Tap>)> {
     let pos = match arg.find(',') {
         Some(p) => p,
         None => {
@@ -311,9 +347,8 @@ fn new_backend_from_tapfd_arg(arg: &str) -> anyhow::Result<(String, NetBackend<T
     let tap_fd = &arg[pos + 1..]
         .parse::<i32>()
         .context("failed to parse tap-fd")?;
-    let backend =
-        NetBackend::<Tap>::new_from_tap_fd(*tap_fd).context("failed to create NetBackend")?;
-
+    let backend = NetBackend::<Tap>::new_from_tap_fd(*tap_fd, mrg_rxbuf)
+        .context("failed to create NetBackend")?;
     Ok((conn.to_string(), backend))
 }
 
@@ -331,19 +366,21 @@ pub fn start_device(opts: Options) -> anyhow::Result<()> {
     // vhost-user
     for arg in opts.device.iter() {
         devices.push(
-            new_backend_from_device_arg(arg)
+            new_backend_from_device_arg(arg, opts.mrg_rxbuf)
                 .map(|(s, backend)| (Connection::Socket(s), backend))?,
         );
     }
 
     for arg in opts.tap_name.iter() {
         devices.push(
-            new_backend_from_tap_name(arg).map(|(s, backend)| (Connection::Socket(s), backend))?,
+            new_backend_from_tap_name(arg, opts.mrg_rxbuf)
+                .map(|(s, backend)| (Connection::Socket(s), backend))?,
         );
     }
     for arg in opts.tap_fd.iter() {
         devices.push(
-            new_backend_from_tapfd_arg(arg).map(|(s, backend)| (Connection::Socket(s), backend))?,
+            new_backend_from_tapfd_arg(arg, opts.mrg_rxbuf)
+                .map(|(s, backend)| (Connection::Socket(s), backend))?,
         );
     }
 
diff --git a/devices/src/virtio/vhost/user/device/wl.rs b/devices/src/virtio/vhost/user/device/wl.rs
index 15bd1ed17..6720709ef 100644
--- a/devices/src/virtio/vhost/user/device/wl.rs
+++ b/devices/src/virtio/vhost/user/device/wl.rs
@@ -6,7 +6,6 @@ use std::cell::RefCell;
 use std::collections::BTreeMap;
 use std::path::PathBuf;
 use std::rc::Rc;
-use std::sync::Arc;
 use std::thread;
 use std::time::Duration;
 use std::time::Instant;
@@ -42,7 +41,6 @@ use crate::virtio::device_constants::wl::VIRTIO_WL_F_TRANS_FLAGS;
 use crate::virtio::device_constants::wl::VIRTIO_WL_F_USE_SHMEM;
 use crate::virtio::vhost::user::device::handler::Error as DeviceError;
 use crate::virtio::vhost::user::device::handler::VhostBackendReqConnection;
-use crate::virtio::vhost::user::device::handler::VhostBackendReqConnectionState;
 use crate::virtio::vhost::user::device::handler::VhostUserDevice;
 use crate::virtio::vhost::user::device::handler::WorkerState;
 use crate::virtio::vhost::user::device::BackendConnection;
@@ -102,7 +100,7 @@ struct WlBackend {
     acked_features: u64,
     wlstate: Option<Rc<RefCell<wl::WlState>>>,
     workers: [Option<WorkerState<Rc<RefCell<Queue>>, ()>>; NUM_QUEUES],
-    backend_req_conn: VhostBackendReqConnectionState,
+    backend_req_conn: Option<VhostBackendReqConnection>,
 }
 
 impl WlBackend {
@@ -127,7 +125,7 @@ impl WlBackend {
             acked_features: 0,
             wlstate: None,
             workers: Default::default(),
-            backend_req_conn: VhostBackendReqConnectionState::NoConnection,
+            backend_req_conn: None,
         }
     }
 }
@@ -195,16 +193,12 @@ impl VhostUserDevice for WlBackend {
             .context("Failed to initailize gralloc")?;
         let wlstate = match &self.wlstate {
             None => {
-                let mapper = {
-                    match &mut self.backend_req_conn {
-                        VhostBackendReqConnectionState::Connected(request) => {
-                            request.take_shmem_mapper()?
-                        }
-                        VhostBackendReqConnectionState::NoConnection => {
-                            bail!("No backend request connection found")
-                        }
-                    }
-                };
+                let mapper = self
+                    .backend_req_conn
+                    .as_ref()
+                    .context("No backend request connection found")?
+                    .shmem_mapper()
+                    .context("Shared memory mapper not available")?;
 
                 let wlstate = Rc::new(RefCell::new(wl::WlState::new(
                     wayland_paths.take().expect("WlState already initialized"),
@@ -274,12 +268,12 @@ impl VhostUserDevice for WlBackend {
         })
     }
 
-    fn set_backend_req_connection(&mut self, conn: Arc<VhostBackendReqConnection>) {
-        if let VhostBackendReqConnectionState::Connected(_) = &self.backend_req_conn {
+    fn set_backend_req_connection(&mut self, conn: VhostBackendReqConnection) {
+        if self.backend_req_conn.is_some() {
             warn!("connection already established. Overwriting");
         }
 
-        self.backend_req_conn = VhostBackendReqConnectionState::Connected(conn);
+        self.backend_req_conn = Some(conn);
     }
 
     fn enter_suspended_state(&mut self) -> anyhow::Result<()> {
diff --git a/devices/src/virtio/vhost/vsock.rs b/devices/src/virtio/vhost/vsock.rs
index ff46d4c3a..e21eda29f 100644
--- a/devices/src/virtio/vhost/vsock.rs
+++ b/devices/src/virtio/vhost/vsock.rs
@@ -36,8 +36,7 @@ use crate::virtio::Interrupt;
 use crate::virtio::Queue;
 use crate::virtio::VirtioDevice;
 
-const QUEUE_SIZE: u16 = 256;
-const QUEUE_SIZES: &[u16] = &[QUEUE_SIZE; NUM_QUEUES];
+const DEFAULT_MAX_QUEUE_SIZE: u16 = 256;
 
 pub struct Vsock {
     worker_thread: Option<WorkerThread<Worker<VhostVsockHandle>>>,
@@ -54,6 +53,7 @@ pub struct Vsock {
     event_queue: Option<Queue>,
     // If true, we should send a TRANSPORT_RESET event to the guest at the next opportunity.
     needs_transport_reset: bool,
+    max_queue_sizes: [u16; NUM_QUEUES],
 }
 
 #[derive(Serialize, Deserialize)]
@@ -100,6 +100,9 @@ impl Vsock {
             vrings_base: None,
             event_queue: None,
             needs_transport_reset: false,
+            max_queue_sizes: vsock_config
+                .max_queue_sizes
+                .unwrap_or([DEFAULT_MAX_QUEUE_SIZE; NUM_QUEUES]),
         })
     }
 
@@ -114,6 +117,7 @@ impl Vsock {
             vrings_base: None,
             event_queue: None,
             needs_transport_reset: false,
+            max_queue_sizes: [DEFAULT_MAX_QUEUE_SIZE; NUM_QUEUES],
         }
     }
 
@@ -144,7 +148,7 @@ impl VirtioDevice for Vsock {
     }
 
     fn queue_max_sizes(&self) -> &[u16] {
-        QUEUE_SIZES
+        &self.max_queue_sizes[..]
     }
 
     fn features(&self) -> u64 {
@@ -178,12 +182,14 @@ impl VirtioDevice for Vsock {
     ) -> anyhow::Result<()> {
         if queues.len() != NUM_QUEUES {
             return Err(anyhow!(
-                "net: expected {} queues, got {}",
+                "vsock: expected {} queues, got {}",
                 NUM_QUEUES,
                 queues.len()
             ));
         }
 
+        let queue_sizes: Vec<u16> = queues.values().map(|q| q.size()).collect();
+
         let vhost_handle = self.vhost_handle.take().context("missing vhost_handle")?;
         let interrupts = self.interrupts.take().context("missing interrupts")?;
         let acked_features = self.acked_features;
@@ -212,8 +218,7 @@ impl VirtioDevice for Vsock {
                 .writer
                 .write_obj(transport_reset)
                 .expect("failed to write transport reset event");
-            let len = avail_desc.writer.bytes_written() as u32;
-            event_queue.add_used(avail_desc, len);
+            event_queue.add_used(avail_desc);
             event_queue.trigger_interrupt();
         }
         self.event_queue = Some(event_queue);
@@ -232,7 +237,7 @@ impl VirtioDevice for Vsock {
             Ok(())
         };
         worker
-            .init(mem, QUEUE_SIZES, activate_vqs, self.vrings_base.take())
+            .init(mem, &queue_sizes, activate_vqs, self.vrings_base.take())
             .context("vsock worker init exited with error")?;
 
         self.worker_thread = Some(WorkerThread::start("vhost_vsock", move |kill_evt| {
diff --git a/devices/src/virtio/vhost_user_frontend/fs.rs b/devices/src/virtio/vhost_user_frontend/fs.rs
deleted file mode 100644
index 1e3e85494..000000000
--- a/devices/src/virtio/vhost_user_frontend/fs.rs
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2021 The ChromiumOS Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-use data_model::Le32;
-use virtio_sys::virtio_fs::virtio_fs_config;
-use zerocopy::IntoBytes;
-
-use crate::virtio::device_constants::fs::FS_MAX_TAG_LEN;
-use crate::virtio::vhost_user_frontend::Error;
-use crate::virtio::vhost_user_frontend::Result;
-use crate::virtio::vhost_user_frontend::VhostUserFrontend;
-use crate::virtio::DeviceType;
-
-impl VhostUserFrontend {
-    pub fn new_fs(
-        base_features: u64,
-        connection: vmm_vhost::Connection<vmm_vhost::FrontendReq>,
-        max_queue_size: Option<u16>,
-        tag: Option<&str>,
-    ) -> Result<VhostUserFrontend> {
-        let cfg = if let Some(tag) = tag {
-            if tag.len() > FS_MAX_TAG_LEN {
-                return Err(Error::TagTooLong {
-                    len: tag.len(),
-                    max: FS_MAX_TAG_LEN,
-                });
-            }
-
-            let mut cfg_tag = [0u8; FS_MAX_TAG_LEN];
-            cfg_tag[..tag.len()].copy_from_slice(tag.as_bytes());
-
-            Some(
-                virtio_fs_config {
-                    tag: cfg_tag,
-                    // Only count the request queue, exclude the high prio queue
-                    num_request_queues: Le32::from(1),
-                }
-                .as_bytes()
-                .to_vec(),
-            )
-        } else {
-            None
-        };
-
-        VhostUserFrontend::new_internal(
-            connection,
-            DeviceType::Fs,
-            max_queue_size,
-            base_features,
-            cfg.as_deref(),
-            None, // pci_address
-        )
-    }
-}
diff --git a/devices/src/virtio/vhost_user_frontend/handler.rs b/devices/src/virtio/vhost_user_frontend/handler.rs
index da02a5812..132aae8d7 100644
--- a/devices/src/virtio/vhost_user_frontend/handler.rs
+++ b/devices/src/virtio/vhost_user_frontend/handler.rs
@@ -84,7 +84,7 @@ impl Frontend for BackendReqHandlerImpl {
             Ok(()) => Ok(0),
             Err(e) => {
                 error!("failed to create mapping {:?}", e);
-                Err(std::io::Error::from_raw_os_error(libc::EINVAL))
+                Err(std::io::Error::other(e.context("add descriptor mapping")))
             }
         }
     }
@@ -105,7 +105,9 @@ impl Frontend for BackendReqHandlerImpl {
             Ok(()) => Ok(0),
             Err(e) => {
                 error!("failed to remove mapping {:?}", e);
-                Err(std::io::Error::from_raw_os_error(libc::EINVAL))
+                Err(std::io::Error::other(
+                    e.context("remove memory mapping based on shm offset"),
+                ))
             }
         }
     }
@@ -143,7 +145,9 @@ impl Frontend for BackendReqHandlerImpl {
             Ok(()) => Ok(0),
             Err(e) => {
                 error!("failed to create mapping {:?}", e);
-                Err(std::io::Error::from_raw_os_error(libc::EINVAL))
+                Err(std::io::Error::other(
+                    e.context("add Vulkan source mapping"),
+                ))
             }
         }
     }
@@ -172,7 +176,7 @@ impl Frontend for BackendReqHandlerImpl {
             Ok(()) => Ok(0),
             Err(e) => {
                 error!("failed to create mapping {:?}", e);
-                Err(std::io::Error::from_raw_os_error(libc::EINVAL))
+                Err(std::io::Error::other(e.context("add external mapping")))
             }
         }
     }
diff --git a/devices/src/virtio/vhost_user_frontend/mod.rs b/devices/src/virtio/vhost_user_frontend/mod.rs
index 1f847409e..764a2eb5f 100644
--- a/devices/src/virtio/vhost_user_frontend/mod.rs
+++ b/devices/src/virtio/vhost_user_frontend/mod.rs
@@ -5,7 +5,6 @@
 //! VirtioDevice implementation for the VMM side of a vhost-user connection.
 
 mod error;
-mod fs;
 mod handler;
 mod sys;
 mod worker;
@@ -36,7 +35,6 @@ use vmm_vhost::VhostUserMemoryRegionInfo;
 use vmm_vhost::VringConfigData;
 use vmm_vhost::VHOST_USER_F_PROTOCOL_FEATURES;
 
-use crate::virtio::copy_config;
 use crate::virtio::device_constants::VIRTIO_DEVICE_TYPE_SPECIFIC_FEATURES_MASK;
 use crate::virtio::vhost_user_frontend::error::Error;
 use crate::virtio::vhost_user_frontend::error::Result;
@@ -59,6 +57,7 @@ pub struct VhostUserFrontend {
     backend_client: Arc<Mutex<BackendClient>>,
     avail_features: u64,
     acked_features: u64,
+    sent_set_features: bool,
     protocol_features: VhostUserProtocolFeatures,
     // `backend_req_handler` is only present if the backend supports BACKEND_REQ. `worker_thread`
     // takes ownership of `backend_req_handler` when it starts. The worker thread will always
@@ -68,7 +67,6 @@ pub struct VhostUserFrontend {
     shmem_region: RefCell<Option<Option<SharedMemoryRegion>>>,
 
     queue_sizes: Vec<u16>,
-    cfg: Option<Vec<u8>>,
     expose_shmem_descriptors_with_viommu: bool,
     pci_address: Option<PciAddress>,
 
@@ -101,37 +99,9 @@ impl VhostUserFrontend {
     /// - `max_queue_size`: maximum number of entries in each queue (default: [`Queue::MAX_SIZE`])
     pub fn new(
         device_type: DeviceType,
-        base_features: u64,
-        connection: vmm_vhost::Connection<vmm_vhost::FrontendReq>,
-        max_queue_size: Option<u16>,
-        pci_address: Option<PciAddress>,
-    ) -> Result<VhostUserFrontend> {
-        VhostUserFrontend::new_internal(
-            connection,
-            device_type,
-            max_queue_size,
-            base_features,
-            None, // cfg
-            pci_address,
-        )
-    }
-
-    /// Create a new VirtioDevice for a vhost-user device frontend.
-    ///
-    /// # Arguments
-    ///
-    /// - `connection`: connection to the device backend
-    /// - `device_type`: virtio device type
-    /// - `max_queue_size`: maximum number of entries in each queue (default: [`Queue::MAX_SIZE`])
-    /// - `base_features`: base virtio device features (e.g. `VIRTIO_F_VERSION_1`)
-    /// - `cfg`: bytes to return for the virtio configuration space (queried from device if not
-    ///   specified)
-    pub(crate) fn new_internal(
+        mut base_features: u64,
         connection: vmm_vhost::Connection<vmm_vhost::FrontendReq>,
-        device_type: DeviceType,
         max_queue_size: Option<u16>,
-        mut base_features: u64,
-        cfg: Option<&[u8]>,
         pci_address: Option<PciAddress>,
     ) -> Result<VhostUserFrontend> {
         // Don't allow packed queues even if requested. We don't handle them properly yet at the
@@ -176,10 +146,13 @@ impl VhostUserFrontend {
 
         let mut protocol_features = VhostUserProtocolFeatures::empty();
         if avail_features & 1 << VHOST_USER_F_PROTOCOL_FEATURES != 0 {
-            // The vhost-user backend supports VHOST_USER_F_PROTOCOL_FEATURES; enable it.
-            backend_client
-                .set_features(1 << VHOST_USER_F_PROTOCOL_FEATURES)
-                .map_err(Error::SetFeatures)?;
+            // The vhost-user backend supports VHOST_USER_F_PROTOCOL_FEATURES.
+            // Per the vhost-user protocol, the backend must support
+            // `VHOST_USER_GET_PROTOCOL_FEATURES` and `VHOST_USER_SET_PROTOCOL_FEATURES` even
+            // before acknowledging the feature, so we don't need to call `set_features()` yet
+            // (and doing so before driver feature negotiation may confuse some backends),
+            // but add it to `acked_features` so it will be included in any future
+            // `set_features()` calls.
             acked_features |= 1 << VHOST_USER_F_PROTOCOL_FEATURES;
 
             let avail_protocol_features = backend_client
@@ -243,11 +216,11 @@ impl VhostUserFrontend {
             backend_client: Arc::new(Mutex::new(backend_client)),
             avail_features,
             acked_features,
+            sent_set_features: false,
             protocol_features,
             backend_req_handler,
             shmem_region: RefCell::new(None),
             queue_sizes,
-            cfg: cfg.map(|cfg| cfg.to_vec()),
             expose_shmem_descriptors_with_viommu,
             pci_address,
             sent_queues: None,
@@ -414,14 +387,10 @@ impl VirtioDevice for VhostUserFrontend {
             return;
         }
         self.acked_features = features;
+        self.sent_set_features = true;
     }
 
     fn read_config(&self, offset: u64, data: &mut [u8]) {
-        if let Some(cfg) = &self.cfg {
-            copy_config(data, 0, cfg, offset);
-            return;
-        }
-
         let Ok(offset) = offset.try_into() else {
             error!("failed to read config: invalid config offset is given: {offset}");
             return;
@@ -469,6 +438,11 @@ impl VirtioDevice for VhostUserFrontend {
         interrupt: Interrupt,
         queues: BTreeMap<usize, Queue>,
     ) -> anyhow::Result<()> {
+        // Ensure at least one `VHOST_USER_SET_FEATURES` is sent before activation.
+        if !self.sent_set_features {
+            self.ack_features(self.acked_features);
+        }
+
         self.set_mem_table(&mem)?;
 
         let msix_config_opt = interrupt
@@ -506,6 +480,8 @@ impl VirtioDevice for VhostUserFrontend {
             self.backend_req_handler = w.stop();
         }
 
+        self.sent_set_features = false;
+
         Ok(())
     }
 
@@ -651,6 +627,11 @@ impl VirtioDevice for VhostUserFrontend {
     }
 
     fn virtio_restore(&mut self, data: AnySnapshot) -> anyhow::Result<()> {
+        // Ensure features are negotiated before restoring.
+        if !self.sent_set_features {
+            self.ack_features(self.acked_features);
+        }
+
         if !self
             .protocol_features
             .contains(VhostUserProtocolFeatures::DEVICE_STATE)
diff --git a/devices/src/virtio/video/resource.rs b/devices/src/virtio/video/resource.rs
index 2b062e4d0..aa909ebde 100644
--- a/devices/src/virtio/video/resource.rs
+++ b/devices/src/virtio/video/resource.rs
@@ -8,7 +8,6 @@ use std::convert::TryInto;
 use std::fmt;
 
 use base::linux::MemoryMappingBuilderUnix;
-use base::AsRawDescriptor;
 use base::FromRawDescriptor;
 use base::IntoRawDescriptor;
 use base::MemoryMappingArena;
@@ -225,11 +224,8 @@ impl GuestResource {
             Some(entry) => {
                 let addr: u64 = entry.addr.into();
 
-                let guest_region = mem
-                    .shm_region(GuestAddress(addr))
-                    .map_err(GuestMemResourceCreationError::CantGetShmRegion)?;
-                base::clone_descriptor(guest_region)
-                    .map_err(GuestMemResourceCreationError::DescriptorCloneError)?
+                mem.shm_region(GuestAddress(addr))
+                    .map_err(GuestMemResourceCreationError::CantGetShmRegion)?
             }
         };
 
@@ -254,7 +250,8 @@ impl GuestResource {
             .collect::<Result<_, _>>()?;
 
         let handle = GuestResourceHandle::GuestPages(GuestMemHandle {
-            desc: region_desc,
+            desc: base::clone_descriptor(region_desc)
+                .map_err(GuestMemResourceCreationError::DescriptorCloneError)?,
             mem_areas,
         });
 
diff --git a/devices/src/virtio/video/worker.rs b/devices/src/virtio/video/worker.rs
index 05dae0126..d5627739d 100644
--- a/devices/src/virtio/video/worker.rs
+++ b/devices/src/virtio/video/worker.rs
@@ -72,8 +72,7 @@ impl Worker {
                     response, e
                 );
             }
-            let len = desc.writer.bytes_written() as u32;
-            self.cmd_queue.add_used(desc, len);
+            self.cmd_queue.add_used(desc);
         }
         self.cmd_queue.trigger_interrupt();
         Ok(())
@@ -89,8 +88,7 @@ impl Worker {
         event
             .write(&mut desc.writer)
             .map_err(|error| Error::WriteEventFailure { event, error })?;
-        let len = desc.writer.bytes_written() as u32;
-        self.event_queue.add_used(desc, len);
+        self.event_queue.add_used(desc);
         self.event_queue.trigger_interrupt();
         Ok(())
     }
diff --git a/devices/src/virtio/virtio_device.rs b/devices/src/virtio/virtio_device.rs
index 7709b632f..4f2a441d9 100644
--- a/devices/src/virtio/virtio_device.rs
+++ b/devices/src/virtio/virtio_device.rs
@@ -161,9 +161,14 @@ pub trait VirtioDevice: Send {
     fn control_notify(&self, _behavior: MsixStatus) {}
 
     #[cfg(target_arch = "x86_64")]
-    fn generate_acpi(&mut self, pci_address: PciAddress, sdts: &mut Vec<SDT>) {
+    fn generate_acpi(
+        &mut self,
+        pci_address: PciAddress,
+        sdts: &mut Vec<SDT>,
+    ) -> anyhow::Result<()> {
         let _ = pci_address;
         let _ = sdts;
+        Ok(())
     }
 
     /// Returns the PCI address where the device will be allocated.
diff --git a/devices/src/virtio/virtio_pci_device.rs b/devices/src/virtio/virtio_pci_device.rs
index c50924e46..755ec2b82 100644
--- a/devices/src/virtio/virtio_pci_device.rs
+++ b/devices/src/virtio/virtio_pci_device.rs
@@ -998,7 +998,7 @@ impl PciDevice for VirtioPciDevice {
     }
 
     #[cfg(target_arch = "x86_64")]
-    fn generate_acpi(&mut self, sdts: &mut Vec<SDT>) {
+    fn generate_acpi(&mut self, sdts: &mut Vec<SDT>) -> anyhow::Result<()> {
         self.device.generate_acpi(
             self.pci_address.expect("pci_address must be assigned"),
             sdts,
diff --git a/devices/src/virtio/vsock/sys/linux.rs b/devices/src/virtio/vsock/sys/linux.rs
index 815acce40..3bf9124e8 100644
--- a/devices/src/virtio/vsock/sys/linux.rs
+++ b/devices/src/virtio/vsock/sys/linux.rs
@@ -16,7 +16,7 @@ fn default_vsock_path() -> PathBuf {
 }
 
 #[derive(Debug, Deserialize, Serialize, PartialEq, Eq, FromKeyValues)]
-#[serde(deny_unknown_fields)]
+#[serde(deny_unknown_fields, rename_all = "kebab-case")]
 /// Configuration for a Vsock device.
 pub struct VsockConfig {
     /// CID to be used for this vsock device.
@@ -24,6 +24,8 @@ pub struct VsockConfig {
     /// Path to the vhost-vsock device.
     #[serde(default = "default_vsock_path", rename = "device")]
     pub vhost_device: PathBuf,
+    #[serde(default)]
+    pub max_queue_sizes: Option<[u16; 3]>,
 }
 
 impl VsockConfig {
@@ -36,6 +38,7 @@ impl VsockConfig {
             vhost_device: vhost_device
                 .map(|p| PathBuf::from(p.as_ref()))
                 .unwrap_or_else(|| PathBuf::from(VHOST_VSOCK_DEFAULT_PATH)),
+            max_queue_sizes: None,
         }
     }
 }
@@ -60,6 +63,7 @@ mod tests {
             VsockConfig {
                 vhost_device: VHOST_VSOCK_DEFAULT_PATH.into(),
                 cid: 56,
+                max_queue_sizes: None,
             }
         );
 
@@ -79,6 +83,7 @@ mod tests {
                 #[cfg(any(target_os = "android", target_os = "linux"))]
                 vhost_device: VHOST_VSOCK_DEFAULT_PATH.into(),
                 cid: 78,
+                max_queue_sizes: None,
             }
         );
 
@@ -96,7 +101,8 @@ mod tests {
             from_vsock_arg("invalid=foo").unwrap_err(),
             ParseError {
                 kind: ErrorKind::SerdeError(
-                    "unknown field `invalid`, expected `cid` or `device`".into()
+                    "unknown field `invalid`, expected one of `cid`, `device`, `max-queue-sizes`"
+                        .into()
                 ),
                 pos: 0,
             }
@@ -108,6 +114,7 @@ mod tests {
             VsockConfig {
                 vhost_device: "/some/path".into(),
                 cid: 56,
+                max_queue_sizes: None,
             }
         );
 
@@ -117,6 +124,7 @@ mod tests {
             VsockConfig {
                 vhost_device: "/some/path".into(),
                 cid: 56,
+                max_queue_sizes: None,
             }
         );
 
@@ -137,5 +145,15 @@ mod tests {
                 pos: 0,
             }
         );
+
+        // Queue sizes
+        assert_eq!(
+            from_vsock_arg("cid=56,max-queue-sizes=[1,2,4]").unwrap(),
+            VsockConfig {
+                vhost_device: VHOST_VSOCK_DEFAULT_PATH.into(),
+                cid: 56,
+                max_queue_sizes: Some([1, 2, 4]),
+            }
+        );
     }
 }
diff --git a/devices/src/virtio/vsock/sys/windows/vsock.rs b/devices/src/virtio/vsock/sys/windows/vsock.rs
index d50c4f2cc..84208de18 100644
--- a/devices/src/virtio/vsock/sys/windows/vsock.rs
+++ b/devices/src/virtio/vsock/sys/windows/vsock.rs
@@ -715,7 +715,7 @@ impl Worker {
                 };
             }
 
-            queue.add_used(avail_desc, 0);
+            queue.add_used(avail_desc);
             queue.trigger_interrupt();
         }
 
@@ -1371,9 +1371,8 @@ impl Worker {
             return Err(VsockError::WriteQueue(e));
         }
 
-        let bytes_written = writer.bytes_written() as u32;
-        if bytes_written > 0 {
-            queue.add_used(desc_chain, bytes_written);
+        if writer.bytes_written() > 0 {
+            queue.add_used(desc_chain);
             queue.trigger_interrupt();
             Ok(())
         } else {
diff --git a/devices/src/virtio/wl.rs b/devices/src/virtio/wl.rs
index ede1d5ae1..c4b4f4361 100644
--- a/devices/src/virtio/wl.rs
+++ b/devices/src/virtio/wl.rs
@@ -1794,10 +1794,9 @@ pub fn process_in_queue(
                     error!("failed to encode response to descriptor chain: {}", e);
                 }
             }
-            let bytes_written = desc.writer.bytes_written() as u32;
             needs_interrupt = true;
             let desc = desc.pop();
-            in_queue.add_used(desc, bytes_written);
+            in_queue.add_used(desc);
         } else {
             break;
         }
@@ -1833,8 +1832,7 @@ pub fn process_out_queue(out_queue: &mut Queue, state: &mut WlState) {
             }
         }
 
-        let len = desc.writer.bytes_written() as u32;
-        out_queue.add_used(desc, len);
+        out_queue.add_used(desc);
         needs_interrupt = true;
     }
 
diff --git a/disk/Cargo.toml b/disk/Cargo.toml
index 26c7aedd5..e3dfc4a52 100644
--- a/disk/Cargo.toml
+++ b/disk/Cargo.toml
@@ -14,22 +14,22 @@ qcow = []
 zstd-disk = ["zstd"]
 
 [dependencies]
-anyhow = "1"
+anyhow = { workspace = true }
 async-trait = "0.1.36"
-base = { path = "../base" }
-cfg-if = "1.0.0"
+base = { workspace = true }
+cfg-if = { workspace = true }
 crc32fast = { version = "1.2.1", optional = true }
-cros_async = { path = "../cros_async" }
-data_model = { path = "../common/data_model" }
-libc = "0.2"
+cros_async = { workspace = true }
+data_model = { workspace = true }
+libc = { workspace = true }
 protobuf = { version = "3.2", optional = true }
-protos = { path = "../protos", features = ["composite-disk"], optional = true }
-remain = "0.2"
-serde = { version = "1", features = ["derive"] }
-sync = { path = "../common/sync" }
-thiserror = "1"
+protos = { workspace = true, features = ["composite-disk"], optional = true }
+remain = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+sync = { workspace = true }
+thiserror = { workspace = true }
 uuid = { version = "1", features = ["v4"], optional = true }
-vm_memory = { path = "../vm_memory" }
+vm_memory = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 zstd = { version = "0.13", optional = true }
 
diff --git a/disk/src/composite.rs b/disk/src/composite.rs
index 7b3ad38e0..9d6af135e 100644
--- a/disk/src/composite.rs
+++ b/disk/src/composite.rs
@@ -718,9 +718,9 @@ pub fn create_composite_disk(
     partitions: &[PartitionInfo],
     zero_filler_path: &Path,
     header_path: &Path,
-    header_file: &mut File,
+    header_file: &mut impl Write,
     footer_path: &Path,
-    footer_file: &mut File,
+    footer_file: &mut impl Write,
     output_composite: &mut File,
 ) -> Result<()> {
     let zero_filler_path = zero_filler_path
diff --git a/docs/book/src/appendix/memory_layout.md b/docs/book/src/appendix/memory_layout.md
index 136de285d..e022d9ea4 100644
--- a/docs/book/src/appendix/memory_layout.md
+++ b/docs/book/src/appendix/memory_layout.md
@@ -15,8 +15,8 @@ see the source. All addresses are in hexadecimal.
 | [`boot_pdpte_addr`]          | `A000`        | `B000`          | 4 KiB     | Boot page table                                                                          |
 | [`boot_pde_addr`]            | `B000`        | `F000`          | 16 KiB    | Boot page tables                                                                         |
 | [`CMDLINE_OFFSET`]           | `2_0000`      | `2_0800`        | 2 KiB     | Linux kernel command line                                                                |
-| [`SETUP_DATA_START`]         | `2_0800`      | `9_FC00`        | 509 KiB   | Linux kernel `setup_data` linked list                                                    |
-| [`MPTABLE_START`]            | `9_FC00`      | `A_0000`        | 1 KiB     | MultiProcessor Specification Configuration Table                                         |
+| [`SETUP_DATA_START`]         | `2_0800`      | `9_E800`        | 504 KiB   | Linux kernel `setup_data` linked list                                                    |
+| [`MPTABLE_RANGE`]            | `9_E800`      | `A_0000`        | 6 KiB     | MultiProcessor Specification Configuration Table                                         |
 | [`ACPI_HI_RSDP_WINDOW_BASE`] | `E_0000`      |                 |           | ACPI tables                                                                              |
 | [`mem_1m_to_4g`]             | `10_0000`     | `D000_0000`     | ~3.24 GiB | RAM (\<4G)                                                                               |
 | [`KERNEL_START_OFFSET`]      | `20_0000`     |                 |           | Linux kernel image load address                                                          |
@@ -38,7 +38,7 @@ see the source. All addresses are in hexadecimal.
 [`boot_pde_addr`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/regs.rs;l=299?q=boot_pde_addr
 [`cmdline_offset`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/lib.rs;l=373?q=CMDLINE_OFFSET
 [`setup_data_start`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/lib.rs;l=375?q=SETUP_DATA_START
-[`mptable_start`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/mptable.rs;l=72?q=MPTABLE_START
+[`mptable_range`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/mptable.rs;l=72?q=MPTABLE_RANGE
 [`acpi_hi_rsdp_window_base`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/lib.rs;l=388?q=ACPI_HI_RSDP_WINDOW_BASE
 [`kernel_start_offset`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/lib.rs;l=372?q=KERNEL_START_OFFSET
 [`initrd_start`]: https://crsrc.org/o/src/platform/crosvm/x86_64/src/lib.rs;l=1692?q=initrd_start
diff --git a/docs/book/src/appendix/rutabaga_gfx.md b/docs/book/src/appendix/rutabaga_gfx.md
index ecaa8f610..e8e6ec99c 100644
--- a/docs/book/src/appendix/rutabaga_gfx.md
+++ b/docs/book/src/appendix/rutabaga_gfx.md
@@ -110,7 +110,7 @@ Mesa provides gfxstream vulkan guest libraries.
 ```sh
 git clone https://gitlab.freedesktop.org/mesa/mesa.git
 cd mesa
-meson setup guest-build/ -Dvulkan-drivers="gfxstream-experimental" -Dgallium-drivers="" -Dopengl=false
+meson setup guest-build/ -Dvulkan-drivers="gfxstream" -Dgallium-drivers="" -Dopengl=false
 ninja -C guest-build/
 ```
 
diff --git a/docs/book/src/architecture/snapshotting.md b/docs/book/src/architecture/snapshotting.md
index 9244719c3..78c9c940c 100644
--- a/docs/book/src/architecture/snapshotting.md
+++ b/docs/book/src/architecture/snapshotting.md
@@ -1,8 +1,8 @@
 # Architecture: Snapshotting
 
-Snapshotting is a **highly experimental** `x86_64` only feature currently under development. It is
-100% **not supported** and only supports a very limited set of devices. This page roughly summarizes
-how the system works, and how device authors should think about it when writing new devices.
+Snapshotting is a **highly experimental** feature currently under development. It is 100% **not
+supported** and only supports a very limited set of devices. This page roughly summarizes how the
+system works, and how device authors should think about it when writing new devices.
 
 ## The snapshot & restore sequence
 
@@ -12,6 +12,28 @@ there is no way to fetch this state atomically, we have to freeze the guest (VCP
 backends. Similarly, on restore we must freeze in the same way to prevent partially restored state
 from being modified.
 
+## Snapshot format
+
+The snapshot format is not stable. Currently, the output is a directory, where most VM components
+are snapshotted to separate files using CBOR encoding.
+
+When debugging snapshots, you may want to inspect the CBOR files. One tool available is
+[cbor-cli](https://docs.rs/crate/cbor-cli/latest). You can run `cargo install cbor-cli`, then use it
+to view a file as JSON, e.g.
+
+```
+$ cbor export --format=json /tmp/crosvm-snapshot/irqchip | jq
+{
+  "mp_state": [
+    "Halted",
+    "Halted",
+    "Halted",
+    "Halted"
+  ],
+  "pit_state": {
+...
+```
+
 ## Snapshotting a running VM
 
 In code, this is implemented by
diff --git a/docs/book/src/building_crosvm/linux.md b/docs/book/src/building_crosvm/linux.md
index 96436bfc9..008abf1bb 100644
--- a/docs/book/src/building_crosvm/linux.md
+++ b/docs/book/src/building_crosvm/linux.md
@@ -43,6 +43,20 @@ We provide a Debian container with the required packages installed. With
 [Podman](https://podman.io/getting-started/installation) or
 [Docker](https://docs.docker.com/get-docker/) installed, it can be started with:
 
+NOTE: to use podman, you will need to install passt.
+
+```sh
+sudo apt install passt
+```
+
+KVM access on Linux systems is typically managed via supplemental user groups. To access KVM from
+inside the development container on such systems podman has to use 'crun' runtime. This runtime
+supports preserving user's supplemental groups when starting a container.
+
+```sh
+sudo apt install crun
+```
+
 ```sh
 ./tools/dev_container
 ```
diff --git a/docs/book/src/running_crosvm/advanced_usage.md b/docs/book/src/running_crosvm/advanced_usage.md
index 9e06fa433..3667c2da1 100644
--- a/docs/book/src/running_crosvm/advanced_usage.md
+++ b/docs/book/src/running_crosvm/advanced_usage.md
@@ -173,4 +173,4 @@ The available backends are:
 See the ["Hypervisors" chapter](../hypervisors.md) for more information.
 
 [gdb remote serial protocol]: https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html
-[kernel documentation]: https://www.kernel.org/doc/html/latest/dev-tools/gdb-kernel-debugging.html
+[kernel documentation]: https://docs.kernel.org/process/debugging/gdb-kernel-debugging.html
diff --git a/e2e_tests/Cargo.toml b/e2e_tests/Cargo.toml
index ffaa8f232..737f24feb 100644
--- a/e2e_tests/Cargo.toml
+++ b/e2e_tests/Cargo.toml
@@ -5,19 +5,19 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dev-dependencies]
-anyhow = "1"
+anyhow = { workspace = true }
 fixture = { path = "fixture" }
-libc = "0.2"
-net_util = {path = "../net_util"}
-rand = "0.8"
+libc = { workspace = true }
+net_util = { workspace = true }
+rand = { workspace = true }
 tempfile = "3"
-prebuilts = { path = "../prebuilts" }
-base = { path = "../base" }
-swap = { path= "../swap" }
-serde_json = "1"
+prebuilts = { workspace = true }
+base = { workspace = true }
+swap = { workspace = true }
+serde_json = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-net_sys = {path = "../net_sys"}
+net_sys = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dev-dependencies]
 readclock = { path = "./guest_under_test/rootfs/readclock" }
diff --git a/e2e_tests/fixture/Cargo.toml b/e2e_tests/fixture/Cargo.toml
index b3e026057..6cdb382cc 100644
--- a/e2e_tests/fixture/Cargo.toml
+++ b/e2e_tests/fixture/Cargo.toml
@@ -5,19 +5,19 @@ authors = ["The Chromium OS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-arch = { path = "../../arch" }
-base = { path = "../../base" }
+anyhow = { workspace = true }
+arch = { workspace = true }
+base = { workspace = true }
 crc32fast = "1.3"
-cfg-if = "1"
-libc = "0.2.65"
-rand = "0.8"
+cfg-if = { workspace = true }
+libc = { workspace = true }
+rand = { workspace = true }
 tempfile = "3"
-prebuilts = { path = "../../prebuilts" }
+prebuilts = { workspace = true }
 log = "0.4"
 shlex = "1.3"
 url = "2.3"
 delegate = {path = "../guest_under_test/rootfs/delegate"}
-serde = {version = "1", features = ["derive"]}
-serde_json = "1"
+serde = { workspace = true, features = ["derive"]}
+serde_json = { workspace = true }
 readclock = { path = "../guest_under_test/rootfs/readclock" }
diff --git a/e2e_tests/guest_under_test/kernel/common.config b/e2e_tests/guest_under_test/kernel/common.config
index 5a94707ea..65cac40aa 100644
--- a/e2e_tests/guest_under_test/kernel/common.config
+++ b/e2e_tests/guest_under_test/kernel/common.config
@@ -30,6 +30,7 @@ CONFIG_VSOCKETS=y
 CONFIG_INET=y
 CONFIG_NET=y
 CONFIG_VIRTIO_NET=y
+CONFIG_NETDEVICES=y
 
 # Sound
 CONFIG_SND_VIRTIO=y
diff --git a/e2e_tests/guest_under_test/rootfs/Dockerfile b/e2e_tests/guest_under_test/rootfs/Dockerfile
index 9c387263d..0cf26ce95 100644
--- a/e2e_tests/guest_under_test/rootfs/Dockerfile
+++ b/e2e_tests/guest_under_test/rootfs/Dockerfile
@@ -7,7 +7,7 @@ FROM ${ARCH}/debian:bookworm
 RUN --mount=type=cache,target=/var/cache/apt,sharing=private \
     --mount=type=cache,target=/var/lib/apt,sharing=private \
     apt-get update \
-    && apt-get install --yes pciutils ncat alsa-utils sox sg3-utils
+    && apt-get install --yes pciutils ncat alsa-utils sox sg3-utils iproute2 iputils-ping
 
 # Note: This docker file is run from the $(target)/rootfs directory specified in
 #       the Makefile.
diff --git a/e2e_tests/guest_under_test/rootfs/delegate/Cargo.toml b/e2e_tests/guest_under_test/rootfs/delegate/Cargo.toml
index af7ffb827..138f41c71 100644
--- a/e2e_tests/guest_under_test/rootfs/delegate/Cargo.toml
+++ b/e2e_tests/guest_under_test/rootfs/delegate/Cargo.toml
@@ -5,5 +5,5 @@ authors = ["The Chromium OS Authors"]
 edition = "2021"
 
 [dependencies]
-serde = {version = "1", features = ["derive"]}
-serde_json = "1"
+serde = { workspace = true, features = ["derive"]}
+serde_json = { workspace = true }
diff --git a/e2e_tests/guest_under_test/rootfs/readclock/Cargo.toml b/e2e_tests/guest_under_test/rootfs/readclock/Cargo.toml
index 725d5b2a5..4db2468f8 100644
--- a/e2e_tests/guest_under_test/rootfs/readclock/Cargo.toml
+++ b/e2e_tests/guest_under_test/rootfs/readclock/Cargo.toml
@@ -9,7 +9,7 @@ authors = ["The Chromium OS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-libc = "0.2"
-serde = {version = "1", features = ["derive"]}
-serde_json = "1"
+anyhow = { workspace = true }
+libc = { workspace = true }
+serde = { workspace = true, features = ["derive"]}
+serde_json = { workspace = true }
diff --git a/e2e_tests/tests/backcompat.rs b/e2e_tests/tests/backcompat.rs
index 4effbc89d..1e3e795d0 100644
--- a/e2e_tests/tests/backcompat.rs
+++ b/e2e_tests/tests/backcompat.rs
@@ -26,17 +26,13 @@ fn backcompat_test_disable_sandbox() {
 }
 
 fn backcompat_test_simple_lspci(vm: &mut TestVm) {
-    let expected = if cfg!(windows) {
-        include_str!("goldens/backcompat_test_simple_lspci_win.txt").trim()
-    } else {
-        include_str!("goldens/backcompat_test_simple_lspci.txt").trim()
-    };
+    let expected = include_str!("goldens/backcompat_test_simple_lspci.txt").trim();
     let result = vm
         .exec_in_guest("lspci -n")
         .unwrap()
         .stdout
         .trim()
-        .replace("\r", "");
+        .replace('\r', "");
     assert_eq!(
         expected,
         result,
diff --git a/e2e_tests/tests/console.rs b/e2e_tests/tests/console.rs
index 06f9b3963..c2e8fd6b3 100644
--- a/e2e_tests/tests/console.rs
+++ b/e2e_tests/tests/console.rs
@@ -36,12 +36,9 @@ fn run_vhost_user_console_multiport_test_portname(config: VmConfig) -> anyhow::R
     let vu_config = create_vu_console_multiport_config(socket.path(), file_path.clone());
     let _vu_device = VhostUserBackend::new(vu_config).unwrap();
 
-    let config = config.extra_args(vec![
-        "--mem".to_owned(),
-        "512".to_owned(),
-        "--vhost-user-console".to_string(),
-        socket.path().to_str().unwrap().to_string(),
-    ]);
+    let config = config
+        .extra_args(vec!["--mem".to_owned(), "512".to_owned()])
+        .with_vhost_user("console", socket.path());
     let mut vm = TestVm::new(config).unwrap();
 
     // mount sysfs to check details
@@ -84,12 +81,9 @@ fn run_vhost_user_console_multiport_test_output(config: VmConfig) -> anyhow::Res
     let vu_config = create_vu_console_multiport_config(socket.path(), file_path.clone());
     let _vu_device = VhostUserBackend::new(vu_config).unwrap();
 
-    let config = config.extra_args(vec![
-        "--mem".to_owned(),
-        "512".to_owned(),
-        "--vhost-user-console".to_string(),
-        socket.path().to_str().unwrap().to_string(),
-    ]);
+    let config = config
+        .extra_args(vec!["--mem".to_owned(), "512".to_owned()])
+        .with_vhost_user("console", socket.path());
     let mut vm = TestVm::new(config).unwrap();
 
     // mount sysfs to check details
@@ -217,12 +211,9 @@ fn run_vhost_user_console_multiport_test_input(config: VmConfig) -> anyhow::Resu
     let vu_config = create_vu_console_multiport_config(socket.path(), file_path.clone());
     let _vu_device = VhostUserBackend::new(vu_config).unwrap();
 
-    let config = config.extra_args(vec![
-        "--mem".to_owned(),
-        "512".to_owned(),
-        "--vhost-user-console".to_string(),
-        socket.path().to_str().unwrap().to_string(),
-    ]);
+    let config = config
+        .extra_args(vec!["--mem".to_owned(), "512".to_owned()])
+        .with_vhost_user("console", socket.path());
     let mut vm = TestVm::new(config).unwrap();
 
     // mount sysfs to check details
diff --git a/e2e_tests/tests/goldens/backcompat_test_simple_lspci_win.txt b/e2e_tests/tests/goldens/backcompat_test_simple_lspci_win.txt
deleted file mode 100644
index cff87925f..000000000
--- a/e2e_tests/tests/goldens/backcompat_test_simple_lspci_win.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-00:00.0 0600: 8086:1237
-00:01.0 0780: 1af4:1043 (rev 01)
-00:02.0 0180: 1af4:1042 (rev 01)
-00:03.0 0880: 1af4:1044 (rev 01)
-00:04.0 0880: 1af4:1045 (rev 01)
-00:05.0 0c03: 1b73:1400
-00:06.0 ffff: 1b36:0011 (rev 01)
-00:07.0 0604: 8086:3420
diff --git a/e2e_tests/tests/pmem_ext2.rs b/e2e_tests/tests/pmem_ext2.rs
index bf3779e98..976c85888 100644
--- a/e2e_tests/tests/pmem_ext2.rs
+++ b/e2e_tests/tests/pmem_ext2.rs
@@ -154,7 +154,7 @@ fn start_with_ugid_map(
     let out = result.stdout.trim();
     println!("guest ugid: {out}");
     let ids = out
-        .split(" ")
+        .split(' ')
         .map(|s| s.parse::<u32>())
         .collect::<Result<Vec<u32>, _>>()
         .unwrap();
diff --git a/e2e_tests/tests/suspend_resume.rs b/e2e_tests/tests/suspend_resume.rs
index a9a7e2197..217103777 100644
--- a/e2e_tests/tests/suspend_resume.rs
+++ b/e2e_tests/tests/suspend_resume.rs
@@ -32,7 +32,8 @@ fn compare_snapshots(a: &Path, b: &Path) -> (bool, String) {
         .arg("vcpu*")
         .arg("--exclude")
         .arg("irqchip")
-        // KVM's pvclock seems to advance some even if the vCPUs haven't started yet.
+        // KVM's pvclock seems to advance some even if the vCPUs haven't started yet. This modifies
+        // memory
         .arg("--exclude")
         .arg("pvclock")
         .arg(a)
diff --git a/ext2/Cargo.toml b/ext2/Cargo.toml
index 3e56406e7..5b0759de0 100644
--- a/ext2/Cargo.toml
+++ b/ext2/Cargo.toml
@@ -5,10 +5,10 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base/" }
-enumn = "0.1"
-libc = "0.2"
+anyhow = { workspace = true }
+base = { workspace = true }
+enumn = { workspace = true }
+libc = { workspace = true }
 uuid = { version = "1", features = ["v4"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
@@ -16,6 +16,6 @@ zerocopy = { version = "0.8.13", features = ["derive"] }
 name = "mkfs"
 
 [dev-dependencies]
-argh = "0.1"
+argh = { workspace = true }
 tempfile = "3"
 walkdir = "2.3"
diff --git a/ext2/src/xattr.rs b/ext2/src/xattr.rs
index 3d49792d8..97cedbadf 100644
--- a/ext2/src/xattr.rs
+++ b/ext2/src/xattr.rs
@@ -49,7 +49,7 @@ fn listxattr(path: &CString) -> Result<Vec<Vec<u8>>> {
 
     // While `c_char` is `i8` on x86_64, it's `u8` on ARM. So, disable the clippy for the cast.
     #[cfg_attr(
-        any(target_arch = "arm", target_arch = "aarch64"),
+        any(target_arch = "arm", target_arch = "aarch64", target_arch = "riscv64"),
         allow(clippy::unnecessary_cast)
     )]
     let keys = buf
diff --git a/fuse/Cargo.toml b/fuse/Cargo.toml
index 5e5fdf2eb..94b0aae73 100644
--- a/fuse/Cargo.toml
+++ b/fuse/Cargo.toml
@@ -8,12 +8,12 @@ edition = "2021"
 path = "src/lib.rs"
 
 [dependencies]
-base = { path = "../base" }
+base = { workspace = true }
 bitflags = "2.2.1"
 crossbeam-utils = "0.8"
-cros_tracing = { path = "../cros_tracing" }
-enumn = "0.1.0"
-libc = { version = "0.2", features = ["extra_traits"] }
-remain = "0.2"
-thiserror = "1.0.20"
+cros_tracing = { workspace = true }
+enumn = { workspace = true }
+libc = { workspace = true, features = ["extra_traits"] }
+remain = { workspace = true }
+thiserror = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/fuzz/Cargo.toml b/fuzz/Cargo.toml
index d8a6d7e37..11f76a035 100644
--- a/fuzz/Cargo.toml
+++ b/fuzz/Cargo.toml
@@ -11,20 +11,20 @@ cargo-fuzz = true
 unexpected_cfgs = { level = "warn", check-cfg = ['cfg(fuzzing)'] }
 
 [dependencies]
-devices = { path = "../devices" }
-disk = { path = "../disk" }
-fuse = { path = "../fuse" }
-hypervisor = { path = "../hypervisor" }
-kernel_loader = { path = "../kernel_loader" }
-libc = "0.2"
-rand = "0.8"
-base = { path = "../base" }
+devices = { workspace = true }
+disk = { workspace = true }
+fuse = { workspace = true }
+hypervisor = { workspace = true }
+kernel_loader = { workspace = true }
+libc = { workspace = true }
+rand = { workspace = true }
+base = { workspace = true }
 tempfile = "3"
-usb_util = { path = "../usb_util" }
-vm_memory = { path = "../vm_memory" }
+usb_util = { workspace = true }
+vm_memory = { workspace = true }
 p9 = "0.3.1"
 rand_core = {version = "0.6", features = ["std"]}
-cfg-if = "1.0"
+cfg-if = { workspace = true }
 
 [target.'cfg(fuzzing)'.dependencies]
 libfuzzer-sys = "=0.4.4"
diff --git a/fuzz/fuzz_targets/virtqueue_fuzzer.rs b/fuzz/fuzz_targets/virtqueue_fuzzer.rs
index fee987216..1147e8f11 100644
--- a/fuzz/fuzz_targets/virtqueue_fuzzer.rs
+++ b/fuzz/fuzz_targets/virtqueue_fuzzer.rs
@@ -127,8 +127,7 @@ fuzz_target!(|data: &[u8]| {
             let write_buf = vec![0u8; avail_desc.writer.available_bytes()];
             avail_desc.writer.write_all(&write_buf).unwrap();
 
-            let bytes_written = avail_desc.writer.bytes_written() as u32;
-            q.add_used(avail_desc, bytes_written);
+            q.add_used(avail_desc);
         }
     });
 });
diff --git a/fuzz/fuzz_targets/zimage_fuzzer.rs b/fuzz/fuzz_targets/zimage_fuzzer.rs
index cf06e3356..f0cc99dba 100644
--- a/fuzz/fuzz_targets/zimage_fuzzer.rs
+++ b/fuzz/fuzz_targets/zimage_fuzzer.rs
@@ -25,6 +25,5 @@ fn make_elf_bin(elf_bytes: &[u8]) -> File {
 fuzz_target!(|bytes| {
     let mut kimage = make_elf_bin(bytes);
     let mem = GuestMemory::new(&[(GuestAddress(0), MEM_SIZE)]).unwrap();
-    let _ = kernel_loader::load_elf32(&mem, GuestAddress(0), &mut kimage, 0);
-    let _ = kernel_loader::load_elf64(&mem, GuestAddress(0), &mut kimage, 0);
+    let _ = kernel_loader::load_elf(&mem, GuestAddress(0), &mut kimage, 0);
 });
diff --git a/gpu_display/Cargo.toml b/gpu_display/Cargo.toml
index 42ae39db7..5c3de699b 100644
--- a/gpu_display/Cargo.toml
+++ b/gpu_display/Cargo.toml
@@ -17,39 +17,39 @@ android_display_stub = []
 gfxstream = []
 
 [dependencies]
-anyhow = "1"
-libc = "0.2"
-base = { path = "../base" }
-linux_input_sys = { path = "../linux_input_sys" }
-remain = "0.2"
-thiserror = "1"
-cfg-if = "1"
-serde = { version = "1", features = [ "derive" ] }
-vm_control = { path = "../vm_control", features = ["gpu"] }
+anyhow = { workspace = true }
+libc = { workspace = true }
+base = { workspace = true }
+linux_input_sys = { workspace = true }
+remain = { workspace = true }
+thiserror = { workspace = true }
+cfg-if = { workspace = true }
+serde = { workspace = true, features = [ "derive" ] }
+vm_control = { workspace = true, features = ["gpu"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 vulkano = { version = "0.31.1", optional = true }
 ash = { version = "0.37.0", optional = true }
-rand = { version = "0.8.5", optional = true }
-protos = { path = "../protos", optional = true }
+rand = { workspace = true, optional = true }
+protos = { workspace = true, optional = true }
 protobuf = { version = "3.2", optional = true }
 euclid = { version = "0.22", optional = true }
 smallvec = { version = "1", optional = true }
-sync = { path = "../common/sync" }
+sync = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
-cros_tracing = { path = "../cros_tracing" }
-metrics = { path = "../metrics" }
+cros_tracing = { workspace = true }
+metrics = { workspace = true }
 num-traits = "0.2"
 winapi = "0.3"
 win_util = { path = "../win_util" }
 smallvec = "1"
-sync = { path = "../common/sync" }
+sync = { workspace = true }
 euclid = "0.22"
 
 [build-dependencies]
 cc = "1.0.25"
 pkg-config = "0.3.31"
-cfg-if = "1.0.0"
+cfg-if = { workspace = true }
 which = "4"
 
 [[example]]
diff --git a/gpu_display/protocol/xdg-shell.xml b/gpu_display/protocol/xdg-shell.xml
new file mode 100644
index 000000000..364d13015
--- /dev/null
+++ b/gpu_display/protocol/xdg-shell.xml
@@ -0,0 +1,1251 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="xdg_shell">
+
+  <copyright>
+    Copyright  2008-2013 Kristian Hgsberg
+    Copyright  2013      Rafael Antognolli
+    Copyright  2013      Jasper St. Pierre
+    Copyright  2010-2013 Intel Corporation
+    Copyright  2015-2017 Samsung Electronics Co., Ltd
+    Copyright  2015-2017 Red Hat Inc.
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <interface name="xdg_wm_base" version="3">
+    <description summary="create desktop-style surfaces">
+      The xdg_wm_base interface is exposed as a global object enabling clients
+      to turn their wl_surfaces into windows in a desktop environment. It
+      defines the basic functionality needed for clients and the compositor to
+      create windows that can be dragged, resized, maximized, etc, as well as
+      creating transient windows such as popup menus.
+    </description>
+
+    <enum name="error">
+      <entry name="role" value="0" summary="given wl_surface has another role"/>
+      <entry name="defunct_surfaces" value="1"
+	     summary="xdg_wm_base was destroyed before children"/>
+      <entry name="not_the_topmost_popup" value="2"
+	     summary="the client tried to map or destroy a non-topmost popup"/>
+      <entry name="invalid_popup_parent" value="3"
+	     summary="the client specified an invalid popup parent surface"/>
+      <entry name="invalid_surface_state" value="4"
+	     summary="the client provided an invalid surface state"/>
+      <entry name="invalid_positioner" value="5"
+	     summary="the client provided an invalid positioner"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy xdg_wm_base">
+	Destroy this xdg_wm_base object.
+
+	Destroying a bound xdg_wm_base object while there are surfaces
+	still alive created by this xdg_wm_base object instance is illegal
+	and will result in a protocol error.
+      </description>
+    </request>
+
+    <request name="create_positioner">
+      <description summary="create a positioner object">
+	Create a positioner object. A positioner object is used to position
+	surfaces relative to some parent surface. See the interface description
+	and xdg_surface.get_popup for details.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_positioner"/>
+    </request>
+
+    <request name="get_xdg_surface">
+      <description summary="create a shell surface from a surface">
+	This creates an xdg_surface for the given surface. While xdg_surface
+	itself is not a role, the corresponding surface may only be assigned
+	a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
+	illegal to create an xdg_surface for a wl_surface which already has an
+	assigned role and this will result in a protocol error.
+
+	This creates an xdg_surface for the given surface. An xdg_surface is
+	used as basis to define a role to a given surface, such as xdg_toplevel
+	or xdg_popup. It also manages functionality shared between xdg_surface
+	based surface roles.
+
+	See the documentation of xdg_surface for more details about what an
+	xdg_surface is and how it is used.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_surface"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </request>
+
+    <request name="pong">
+      <description summary="respond to a ping event">
+	A client must respond to a ping event with a pong request or
+	the client may be deemed unresponsive. See xdg_wm_base.ping.
+      </description>
+      <arg name="serial" type="uint" summary="serial of the ping event"/>
+    </request>
+
+    <event name="ping">
+      <description summary="check if the client is alive">
+	The ping event asks the client if it's still alive. Pass the
+	serial specified in the event back to the compositor by sending
+	a "pong" request back with the specified serial. See xdg_wm_base.pong.
+
+	Compositors can use this to determine if the client is still
+	alive. It's unspecified what will happen if the client doesn't
+	respond to the ping request, or in what timeframe. Clients should
+	try to respond in a reasonable amount of time.
+
+	A compositor is free to ping in any way it wants, but a client must
+	always respond to any xdg_wm_base object it created.
+      </description>
+      <arg name="serial" type="uint" summary="pass this to the pong request"/>
+    </event>
+  </interface>
+
+  <interface name="xdg_positioner" version="3">
+    <description summary="child surface positioner">
+      The xdg_positioner provides a collection of rules for the placement of a
+      child surface relative to a parent surface. Rules can be defined to ensure
+      the child surface remains within the visible area's borders, and to
+      specify how the child surface changes its position, such as sliding along
+      an axis, or flipping around a rectangle. These positioner-created rules are
+      constrained by the requirement that a child surface must intersect with or
+      be at least partially adjacent to its parent surface.
+
+      See the various requests for details about possible rules.
+
+      At the time of the request, the compositor makes a copy of the rules
+      specified by the xdg_positioner. Thus, after the request is complete the
+      xdg_positioner object can be destroyed or reused; further changes to the
+      object will have no effect on previous usages.
+
+      For an xdg_positioner object to be considered complete, it must have a
+      non-zero size set by set_size, and a non-zero anchor rectangle set by
+      set_anchor_rect. Passing an incomplete xdg_positioner object when
+      positioning a surface raises an error.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_input" value="0" summary="invalid input provided"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the xdg_positioner object">
+	Notify the compositor that the xdg_positioner will no longer be used.
+      </description>
+    </request>
+
+    <request name="set_size">
+      <description summary="set the size of the to-be positioned rectangle">
+	Set the size of the surface that is to be positioned with the positioner
+	object. The size is in surface-local coordinates and corresponds to the
+	window geometry. See xdg_surface.set_window_geometry.
+
+	If a zero or negative size is set the invalid_input error is raised.
+      </description>
+      <arg name="width" type="int" summary="width of positioned rectangle"/>
+      <arg name="height" type="int" summary="height of positioned rectangle"/>
+    </request>
+
+    <request name="set_anchor_rect">
+      <description summary="set the anchor rectangle within the parent surface">
+	Specify the anchor rectangle within the parent surface that the child
+	surface will be placed relative to. The rectangle is relative to the
+	window geometry as defined by xdg_surface.set_window_geometry of the
+	parent surface.
+
+	When the xdg_positioner object is used to position a child surface, the
+	anchor rectangle may not extend outside the window geometry of the
+	positioned child's parent surface.
+
+	If a negative size is set the invalid_input error is raised.
+      </description>
+      <arg name="x" type="int" summary="x position of anchor rectangle"/>
+      <arg name="y" type="int" summary="y position of anchor rectangle"/>
+      <arg name="width" type="int" summary="width of anchor rectangle"/>
+      <arg name="height" type="int" summary="height of anchor rectangle"/>
+    </request>
+
+    <enum name="anchor">
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="3"/>
+      <entry name="right" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="top_right" value="7"/>
+      <entry name="bottom_right" value="8"/>
+    </enum>
+
+    <request name="set_anchor">
+      <description summary="set anchor rectangle anchor">
+	Defines the anchor point for the anchor rectangle. The specified anchor
+	is used derive an anchor point that the child surface will be
+	positioned relative to. If a corner anchor is set (e.g. 'top_left' or
+	'bottom_right'), the anchor point will be at the specified corner;
+	otherwise, the derived anchor point will be centered on the specified
+	edge, or in the center of the anchor rectangle if no edge is specified.
+      </description>
+      <arg name="anchor" type="uint" enum="anchor"
+	   summary="anchor"/>
+    </request>
+
+    <enum name="gravity">
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="3"/>
+      <entry name="right" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="top_right" value="7"/>
+      <entry name="bottom_right" value="8"/>
+    </enum>
+
+    <request name="set_gravity">
+      <description summary="set child surface gravity">
+	Defines in what direction a surface should be positioned, relative to
+	the anchor point of the parent surface. If a corner gravity is
+	specified (e.g. 'bottom_right' or 'top_left'), then the child surface
+	will be placed towards the specified gravity; otherwise, the child
+	surface will be centered over the anchor point on any axis that had no
+	gravity specified.
+      </description>
+      <arg name="gravity" type="uint" enum="gravity"
+	   summary="gravity direction"/>
+    </request>
+
+    <enum name="constraint_adjustment" bitfield="true">
+      <description summary="constraint adjustments">
+	The constraint adjustment value define ways the compositor will adjust
+	the position of the surface, if the unadjusted position would result
+	in the surface being partly constrained.
+
+	Whether a surface is considered 'constrained' is left to the compositor
+	to determine. For example, the surface may be partly outside the
+	compositor's defined 'work area', thus necessitating the child surface's
+	position be adjusted until it is entirely inside the work area.
+
+	The adjustments can be combined, according to a defined precedence: 1)
+	Flip, 2) Slide, 3) Resize.
+      </description>
+      <entry name="none" value="0">
+	<description summary="don't move the child surface when constrained">
+	  Don't alter the surface position even if it is constrained on some
+	  axis, for example partially outside the edge of an output.
+	</description>
+      </entry>
+      <entry name="slide_x" value="1">
+	<description summary="move along the x axis until unconstrained">
+	  Slide the surface along the x axis until it is no longer constrained.
+
+	  First try to slide towards the direction of the gravity on the x axis
+	  until either the edge in the opposite direction of the gravity is
+	  unconstrained or the edge in the direction of the gravity is
+	  constrained.
+
+	  Then try to slide towards the opposite direction of the gravity on the
+	  x axis until either the edge in the direction of the gravity is
+	  unconstrained or the edge in the opposite direction of the gravity is
+	  constrained.
+	</description>
+      </entry>
+      <entry name="slide_y" value="2">
+	<description summary="move along the y axis until unconstrained">
+	  Slide the surface along the y axis until it is no longer constrained.
+
+	  First try to slide towards the direction of the gravity on the y axis
+	  until either the edge in the opposite direction of the gravity is
+	  unconstrained or the edge in the direction of the gravity is
+	  constrained.
+
+	  Then try to slide towards the opposite direction of the gravity on the
+	  y axis until either the edge in the direction of the gravity is
+	  unconstrained or the edge in the opposite direction of the gravity is
+	  constrained.
+	</description>
+      </entry>
+      <entry name="flip_x" value="4">
+	<description summary="invert the anchor and gravity on the x axis">
+	  Invert the anchor and gravity on the x axis if the surface is
+	  constrained on the x axis. For example, if the left edge of the
+	  surface is constrained, the gravity is 'left' and the anchor is
+	  'left', change the gravity to 'right' and the anchor to 'right'.
+
+	  If the adjusted position also ends up being constrained, the resulting
+	  position of the flip_x adjustment will be the one before the
+	  adjustment.
+	</description>
+      </entry>
+      <entry name="flip_y" value="8">
+	<description summary="invert the anchor and gravity on the y axis">
+	  Invert the anchor and gravity on the y axis if the surface is
+	  constrained on the y axis. For example, if the bottom edge of the
+	  surface is constrained, the gravity is 'bottom' and the anchor is
+	  'bottom', change the gravity to 'top' and the anchor to 'top'.
+
+	  The adjusted position is calculated given the original anchor
+	  rectangle and offset, but with the new flipped anchor and gravity
+	  values.
+
+	  If the adjusted position also ends up being constrained, the resulting
+	  position of the flip_y adjustment will be the one before the
+	  adjustment.
+	</description>
+      </entry>
+      <entry name="resize_x" value="16">
+	<description summary="horizontally resize the surface">
+	  Resize the surface horizontally so that it is completely
+	  unconstrained.
+	</description>
+      </entry>
+      <entry name="resize_y" value="32">
+	<description summary="vertically resize the surface">
+	  Resize the surface vertically so that it is completely unconstrained.
+	</description>
+      </entry>
+    </enum>
+
+    <request name="set_constraint_adjustment">
+      <description summary="set the adjustment to be done when constrained">
+	Specify how the window should be positioned if the originally intended
+	position caused the surface to be constrained, meaning at least
+	partially outside positioning boundaries set by the compositor. The
+	adjustment is set by constructing a bitmask describing the adjustment to
+	be made when the surface is constrained on that axis.
+
+	If no bit for one axis is set, the compositor will assume that the child
+	surface should not change its position on that axis when constrained.
+
+	If more than one bit for one axis is set, the order of how adjustments
+	are applied is specified in the corresponding adjustment descriptions.
+
+	The default adjustment is none.
+      </description>
+      <arg name="constraint_adjustment" type="uint"
+	   summary="bit mask of constraint adjustments"/>
+    </request>
+
+    <request name="set_offset">
+      <description summary="set surface position offset">
+	Specify the surface position offset relative to the position of the
+	anchor on the anchor rectangle and the anchor on the surface. For
+	example if the anchor of the anchor rectangle is at (x, y), the surface
+	has the gravity bottom|right, and the offset is (ox, oy), the calculated
+	surface position will be (x + ox, y + oy). The offset position of the
+	surface is the one used for constraint testing. See
+	set_constraint_adjustment.
+
+	An example use case is placing a popup menu on top of a user interface
+	element, while aligning the user interface element of the parent surface
+	with some user interface element placed somewhere in the popup surface.
+      </description>
+      <arg name="x" type="int" summary="surface position x offset"/>
+      <arg name="y" type="int" summary="surface position y offset"/>
+    </request>
+
+    <!-- Version 3 additions -->
+
+    <request name="set_reactive" since="3">
+      <description summary="continuously reconstrain the surface">
+	When set reactive, the surface is reconstrained if the conditions used
+	for constraining changed, e.g. the parent window moved.
+
+	If the conditions changed and the popup was reconstrained, an
+	xdg_popup.configure event is sent with updated geometry, followed by an
+	xdg_surface.configure event.
+      </description>
+    </request>
+
+    <request name="set_parent_size" since="3">
+      <description summary="">
+	Set the parent window geometry the compositor should use when
+	positioning the popup. The compositor may use this information to
+	determine the future state the popup should be constrained using. If
+	this doesn't match the dimension of the parent the popup is eventually
+	positioned against, the behavior is undefined.
+
+	The arguments are given in the surface-local coordinate space.
+      </description>
+      <arg name="parent_width" type="int"
+	   summary="future window geometry width of parent"/>
+      <arg name="parent_height" type="int"
+	   summary="future window geometry height of parent"/>
+    </request>
+
+    <request name="set_parent_configure" since="3">
+      <description summary="set parent configure this is a response to">
+	Set the serial of an xdg_surface.configure event this positioner will be
+	used in response to. The compositor may use this information together
+	with set_parent_size to determine what future state the popup should be
+	constrained using.
+      </description>
+      <arg name="serial" type="uint"
+	   summary="serial of parent configure event"/>
+    </request>
+  </interface>
+
+  <interface name="xdg_surface" version="3">
+    <description summary="desktop user interface surface base interface">
+      An interface that may be implemented by a wl_surface, for
+      implementations that provide a desktop-style user interface.
+
+      It provides a base set of functionality required to construct user
+      interface elements requiring management by the compositor, such as
+      toplevel windows, menus, etc. The types of functionality are split into
+      xdg_surface roles.
+
+      Creating an xdg_surface does not set the role for a wl_surface. In order
+      to map an xdg_surface, the client must create a role-specific object
+      using, e.g., get_toplevel, get_popup. The wl_surface for any given
+      xdg_surface can have at most one role, and may not be assigned any role
+      not based on xdg_surface.
+
+      A role must be assigned before any other requests are made to the
+      xdg_surface object.
+
+      The client must call wl_surface.commit on the corresponding wl_surface
+      for the xdg_surface state to take effect.
+
+      Creating an xdg_surface from a wl_surface which has a buffer attached or
+      committed is a client error, and any attempts by a client to attach or
+      manipulate a buffer prior to the first xdg_surface.configure call must
+      also be treated as errors.
+
+      After creating a role-specific object and setting it up, the client must
+      perform an initial commit without any buffer attached. The compositor
+      will reply with an xdg_surface.configure event. The client must
+      acknowledge it and is then allowed to attach a buffer to map the surface.
+
+      Mapping an xdg_surface-based role surface is defined as making it
+      possible for the surface to be shown by the compositor. Note that
+      a mapped surface is not guaranteed to be visible once it is mapped.
+
+      For an xdg_surface to be mapped by the compositor, the following
+      conditions must be met:
+      (1) the client has assigned an xdg_surface-based role to the surface
+      (2) the client has set and committed the xdg_surface state and the
+	  role-dependent state to the surface
+      (3) the client has committed a buffer to the surface
+
+      A newly-unmapped surface is considered to have met condition (1) out
+      of the 3 required conditions for mapping a surface if its role surface
+      has not been destroyed.
+    </description>
+
+    <enum name="error">
+      <entry name="not_constructed" value="1"/>
+      <entry name="already_constructed" value="2"/>
+      <entry name="unconfigured_buffer" value="3"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the xdg_surface">
+	Destroy the xdg_surface object. An xdg_surface must only be destroyed
+	after its role object has been destroyed.
+      </description>
+    </request>
+
+    <request name="get_toplevel">
+      <description summary="assign the xdg_toplevel surface role">
+	This creates an xdg_toplevel object for the given xdg_surface and gives
+	the associated wl_surface the xdg_toplevel role.
+
+	See the documentation of xdg_toplevel for more details about what an
+	xdg_toplevel is and how it is used.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_toplevel"/>
+    </request>
+
+    <request name="get_popup">
+      <description summary="assign the xdg_popup surface role">
+	This creates an xdg_popup object for the given xdg_surface and gives
+	the associated wl_surface the xdg_popup role.
+
+	If null is passed as a parent, a parent surface must be specified using
+	some other protocol, before committing the initial state.
+
+	See the documentation of xdg_popup for more details about what an
+	xdg_popup is and how it is used.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_popup"/>
+      <arg name="parent" type="object" interface="xdg_surface" allow-null="true"/>
+      <arg name="positioner" type="object" interface="xdg_positioner"/>
+    </request>
+
+    <request name="set_window_geometry">
+      <description summary="set the new window geometry">
+	The window geometry of a surface is its "visible bounds" from the
+	user's perspective. Client-side decorations often have invisible
+	portions like drop-shadows which should be ignored for the
+	purposes of aligning, placing and constraining windows.
+
+	The window geometry is double buffered, and will be applied at the
+	time wl_surface.commit of the corresponding wl_surface is called.
+
+	When maintaining a position, the compositor should treat the (x, y)
+	coordinate of the window geometry as the top left corner of the window.
+	A client changing the (x, y) window geometry coordinate should in
+	general not alter the position of the window.
+
+	Once the window geometry of the surface is set, it is not possible to
+	unset it, and it will remain the same until set_window_geometry is
+	called again, even if a new subsurface or buffer is attached.
+
+	If never set, the value is the full bounds of the surface,
+	including any subsurfaces. This updates dynamically on every
+	commit. This unset is meant for extremely simple clients.
+
+	The arguments are given in the surface-local coordinate space of
+	the wl_surface associated with this xdg_surface.
+
+	The width and height must be greater than zero. Setting an invalid size
+	will raise an error. When applied, the effective window geometry will be
+	the set window geometry clamped to the bounding rectangle of the
+	combined geometry of the surface of the xdg_surface and the associated
+	subsurfaces.
+      </description>
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </request>
+
+    <request name="ack_configure">
+      <description summary="ack a configure event">
+	When a configure event is received, if a client commits the
+	surface in response to the configure event, then the client
+	must make an ack_configure request sometime before the commit
+	request, passing along the serial of the configure event.
+
+	For instance, for toplevel surfaces the compositor might use this
+	information to move a surface to the top left only when the client has
+	drawn itself for the maximized or fullscreen state.
+
+	If the client receives multiple configure events before it
+	can respond to one, it only has to ack the last configure event.
+
+	A client is not required to commit immediately after sending
+	an ack_configure request - it may even ack_configure several times
+	before its next surface commit.
+
+	A client may send multiple ack_configure requests before committing, but
+	only the last request sent before a commit indicates which configure
+	event the client really is responding to.
+      </description>
+      <arg name="serial" type="uint" summary="the serial from the configure event"/>
+    </request>
+
+    <event name="configure">
+      <description summary="suggest a surface change">
+	The configure event marks the end of a configure sequence. A configure
+	sequence is a set of one or more events configuring the state of the
+	xdg_surface, including the final xdg_surface.configure event.
+
+	Where applicable, xdg_surface surface roles will during a configure
+	sequence extend this event as a latched state sent as events before the
+	xdg_surface.configure event. Such events should be considered to make up
+	a set of atomically applied configuration states, where the
+	xdg_surface.configure commits the accumulated state.
+
+	Clients should arrange their surface for the new states, and then send
+	an ack_configure request with the serial sent in this configure event at
+	some point before committing the new surface.
+
+	If the client receives multiple configure events before it can respond
+	to one, it is free to discard all but the last event it received.
+      </description>
+      <arg name="serial" type="uint" summary="serial of the configure event"/>
+    </event>
+
+  </interface>
+
+  <interface name="xdg_toplevel" version="3">
+    <description summary="toplevel surface">
+      This interface defines an xdg_surface role which allows a surface to,
+      among other things, set window-like properties such as maximize,
+      fullscreen, and minimize, set application-specific metadata like title and
+      id, and well as trigger user interactive operations such as interactive
+      resize and move.
+
+      Unmapping an xdg_toplevel means that the surface cannot be shown
+      by the compositor until it is explicitly mapped again.
+      All active operations (e.g., move, resize) are canceled and all
+      attributes (e.g. title, state, stacking, ...) are discarded for
+      an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
+      the state it had right after xdg_surface.get_toplevel. The client
+      can re-map the toplevel by perfoming a commit without any buffer
+      attached, waiting for a configure event and handling it as usual (see
+      xdg_surface description).
+
+      Attaching a null buffer to a toplevel unmaps the surface.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the xdg_toplevel">
+	This request destroys the role surface and unmaps the surface;
+	see "Unmapping" behavior in interface section for details.
+      </description>
+    </request>
+
+    <request name="set_parent">
+      <description summary="set the parent of this surface">
+	Set the "parent" of this surface. This surface should be stacked
+	above the parent surface and all other ancestor surfaces.
+
+	Parent windows should be set on dialogs, toolboxes, or other
+	"auxiliary" surfaces, so that the parent is raised when the dialog
+	is raised.
+
+	Setting a null parent for a child window removes any parent-child
+	relationship for the child. Setting a null parent for a window which
+	currently has no parent is a no-op.
+
+	If the parent is unmapped then its children are managed as
+	though the parent of the now-unmapped parent has become the
+	parent of this surface. If no parent exists for the now-unmapped
+	parent then the children are managed as though they have no
+	parent surface.
+      </description>
+      <arg name="parent" type="object" interface="xdg_toplevel" allow-null="true"/>
+    </request>
+
+    <request name="set_title">
+      <description summary="set surface title">
+	Set a short title for the surface.
+
+	This string may be used to identify the surface in a task bar,
+	window list, or other user interface elements provided by the
+	compositor.
+
+	The string must be encoded in UTF-8.
+      </description>
+      <arg name="title" type="string"/>
+    </request>
+
+    <request name="set_app_id">
+      <description summary="set application ID">
+	Set an application identifier for the surface.
+
+	The app ID identifies the general class of applications to which
+	the surface belongs. The compositor can use this to group multiple
+	surfaces together, or to determine how to launch a new application.
+
+	For D-Bus activatable applications, the app ID is used as the D-Bus
+	service name.
+
+	The compositor shell will try to group application surfaces together
+	by their app ID. As a best practice, it is suggested to select app
+	ID's that match the basename of the application's .desktop file.
+	For example, "org.freedesktop.FooViewer" where the .desktop file is
+	"org.freedesktop.FooViewer.desktop".
+
+	Like other properties, a set_app_id request can be sent after the
+	xdg_toplevel has been mapped to update the property.
+
+	See the desktop-entry specification [0] for more details on
+	application identifiers and how they relate to well-known D-Bus
+	names and .desktop files.
+
+	[0] http://standards.freedesktop.org/desktop-entry-spec/
+      </description>
+      <arg name="app_id" type="string"/>
+    </request>
+
+    <request name="show_window_menu">
+      <description summary="show the window menu">
+	Clients implementing client-side decorations might want to show
+	a context menu when right-clicking on the decorations, giving the
+	user a menu that they can use to maximize or minimize the window.
+
+	This request asks the compositor to pop up such a window menu at
+	the given position, relative to the local surface coordinates of
+	the parent surface. There are no guarantees as to what menu items
+	the window menu contains.
+
+	This request must be used in response to some sort of user action
+	like a button press, key press, or touch down event.
+      </description>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
+      <arg name="x" type="int" summary="the x position to pop up the window menu at"/>
+      <arg name="y" type="int" summary="the y position to pop up the window menu at"/>
+    </request>
+
+    <request name="move">
+      <description summary="start an interactive move">
+	Start an interactive, user-driven move of the surface.
+
+	This request must be used in response to some sort of user action
+	like a button press, key press, or touch down event. The passed
+	serial is used to determine the type of interactive move (touch,
+	pointer, etc).
+
+	The server may ignore move requests depending on the state of
+	the surface (e.g. fullscreen or maximized), or if the passed serial
+	is no longer valid.
+
+	If triggered, the surface will lose the focus of the device
+	(wl_pointer, wl_touch, etc) used for the move. It is up to the
+	compositor to visually indicate that the move is taking place, such as
+	updating a pointer cursor, during the move. There is no guarantee
+	that the device focus will return when the move is completed.
+      </description>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
+    </request>
+
+    <enum name="resize_edge">
+      <description summary="edge values for resizing">
+	These values are used to indicate which edge of a surface
+	is being dragged in a resize operation.
+      </description>
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="right" value="8"/>
+      <entry name="top_right" value="9"/>
+      <entry name="bottom_right" value="10"/>
+    </enum>
+
+    <request name="resize">
+      <description summary="start an interactive resize">
+	Start a user-driven, interactive resize of the surface.
+
+	This request must be used in response to some sort of user action
+	like a button press, key press, or touch down event. The passed
+	serial is used to determine the type of interactive resize (touch,
+	pointer, etc).
+
+	The server may ignore resize requests depending on the state of
+	the surface (e.g. fullscreen or maximized).
+
+	If triggered, the client will receive configure events with the
+	"resize" state enum value and the expected sizes. See the "resize"
+	enum value for more details about what is required. The client
+	must also acknowledge configure events using "ack_configure". After
+	the resize is completed, the client will receive another "configure"
+	event without the resize state.
+
+	If triggered, the surface also will lose the focus of the device
+	(wl_pointer, wl_touch, etc) used for the resize. It is up to the
+	compositor to visually indicate that the resize is taking place,
+	such as updating a pointer cursor, during the resize. There is no
+	guarantee that the device focus will return when the resize is
+	completed.
+
+	The edges parameter specifies how the surface should be resized,
+	and is one of the values of the resize_edge enum. The compositor
+	may use this information to update the surface position for
+	example when dragging the top left corner. The compositor may also
+	use this information to adapt its behavior, e.g. choose an
+	appropriate cursor image.
+      </description>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
+      <arg name="edges" type="uint" enum="resize_edge" summary="which edge or corner is being dragged"/>
+    </request>
+
+    <enum name="state">
+      <description summary="types of state on the surface">
+	The different state values used on the surface. This is designed for
+	state values like maximized, fullscreen. It is paired with the
+	configure event to ensure that both the client and the compositor
+	setting the state can be synchronized.
+
+	States set in this way are double-buffered. They will get applied on
+	the next commit.
+      </description>
+      <entry name="maximized" value="1" summary="the surface is maximized">
+	<description summary="the surface is maximized">
+	  The surface is maximized. The window geometry specified in the configure
+	  event must be obeyed by the client.
+
+	  The client should draw without shadow or other
+	  decoration outside of the window geometry.
+	</description>
+      </entry>
+      <entry name="fullscreen" value="2" summary="the surface is fullscreen">
+	<description summary="the surface is fullscreen">
+	  The surface is fullscreen. The window geometry specified in the
+	  configure event is a maximum; the client cannot resize beyond it. For
+	  a surface to cover the whole fullscreened area, the geometry
+	  dimensions must be obeyed by the client. For more details, see
+	  xdg_toplevel.set_fullscreen.
+	</description>
+      </entry>
+      <entry name="resizing" value="3" summary="the surface is being resized">
+	<description summary="the surface is being resized">
+	  The surface is being resized. The window geometry specified in the
+	  configure event is a maximum; the client cannot resize beyond it.
+	  Clients that have aspect ratio or cell sizing configuration can use
+	  a smaller size, however.
+	</description>
+      </entry>
+      <entry name="activated" value="4" summary="the surface is now activated">
+	<description summary="the surface is now activated">
+	  Client window decorations should be painted as if the window is
+	  active. Do not assume this means that the window actually has
+	  keyboard or pointer focus.
+	</description>
+      </entry>
+      <entry name="tiled_left" value="5" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the left edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_right" value="6" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the right edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_top" value="7" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the top edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_bottom" value="8" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the bottom edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+    </enum>
+
+    <request name="set_max_size">
+      <description summary="set the maximum size">
+	Set a maximum size for the window.
+
+	The client can specify a maximum size so that the compositor does
+	not try to configure the window beyond this size.
+
+	The width and height arguments are in window geometry coordinates.
+	See xdg_surface.set_window_geometry.
+
+	Values set in this way are double-buffered. They will get applied
+	on the next commit.
+
+	The compositor can use this information to allow or disallow
+	different states like maximize or fullscreen and draw accurate
+	animations.
+
+	Similarly, a tiling window manager may use this information to
+	place and resize client windows in a more effective way.
+
+	The client should not rely on the compositor to obey the maximum
+	size. The compositor may decide to ignore the values set by the
+	client and request a larger size.
+
+	If never set, or a value of zero in the request, means that the
+	client has no expected maximum size in the given dimension.
+	As a result, a client wishing to reset the maximum size
+	to an unspecified state can use zero for width and height in the
+	request.
+
+	Requesting a maximum size to be smaller than the minimum size of
+	a surface is illegal and will result in a protocol error.
+
+	The width and height must be greater than or equal to zero. Using
+	strictly negative values for width and height will result in a
+	protocol error.
+      </description>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </request>
+
+    <request name="set_min_size">
+      <description summary="set the minimum size">
+	Set a minimum size for the window.
+
+	The client can specify a minimum size so that the compositor does
+	not try to configure the window below this size.
+
+	The width and height arguments are in window geometry coordinates.
+	See xdg_surface.set_window_geometry.
+
+	Values set in this way are double-buffered. They will get applied
+	on the next commit.
+
+	The compositor can use this information to allow or disallow
+	different states like maximize or fullscreen and draw accurate
+	animations.
+
+	Similarly, a tiling window manager may use this information to
+	place and resize client windows in a more effective way.
+
+	The client should not rely on the compositor to obey the minimum
+	size. The compositor may decide to ignore the values set by the
+	client and request a smaller size.
+
+	If never set, or a value of zero in the request, means that the
+	client has no expected minimum size in the given dimension.
+	As a result, a client wishing to reset the minimum size
+	to an unspecified state can use zero for width and height in the
+	request.
+
+	Requesting a minimum size to be larger than the maximum size of
+	a surface is illegal and will result in a protocol error.
+
+	The width and height must be greater than or equal to zero. Using
+	strictly negative values for width and height will result in a
+	protocol error.
+      </description>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </request>
+
+    <request name="set_maximized">
+      <description summary="maximize the window">
+	Maximize the surface.
+
+	After requesting that the surface should be maximized, the compositor
+	will respond by emitting a configure event. Whether this configure
+	actually sets the window maximized is subject to compositor policies.
+	The client must then update its content, drawing in the configured
+	state. The client must also acknowledge the configure when committing
+	the new content (see ack_configure).
+
+	It is up to the compositor to decide how and where to maximize the
+	surface, for example which output and what region of the screen should
+	be used.
+
+	If the surface was already maximized, the compositor will still emit
+	a configure event with the "maximized" state.
+
+	If the surface is in a fullscreen state, this request has no direct
+	effect. It may alter the state the surface is returned to when
+	unmaximized unless overridden by the compositor.
+      </description>
+    </request>
+
+    <request name="unset_maximized">
+      <description summary="unmaximize the window">
+	Unmaximize the surface.
+
+	After requesting that the surface should be unmaximized, the compositor
+	will respond by emitting a configure event. Whether this actually
+	un-maximizes the window is subject to compositor policies.
+	If available and applicable, the compositor will include the window
+	geometry dimensions the window had prior to being maximized in the
+	configure event. The client must then update its content, drawing it in
+	the configured state. The client must also acknowledge the configure
+	when committing the new content (see ack_configure).
+
+	It is up to the compositor to position the surface after it was
+	unmaximized; usually the position the surface had before maximizing, if
+	applicable.
+
+	If the surface was already not maximized, the compositor will still
+	emit a configure event without the "maximized" state.
+
+	If the surface is in a fullscreen state, this request has no direct
+	effect. It may alter the state the surface is returned to when
+	unmaximized unless overridden by the compositor.
+      </description>
+    </request>
+
+    <request name="set_fullscreen">
+      <description summary="set the window as fullscreen on an output">
+	Make the surface fullscreen.
+
+	After requesting that the surface should be fullscreened, the
+	compositor will respond by emitting a configure event. Whether the
+	client is actually put into a fullscreen state is subject to compositor
+	policies. The client must also acknowledge the configure when
+	committing the new content (see ack_configure).
+
+	The output passed by the request indicates the client's preference as
+	to which display it should be set fullscreen on. If this value is NULL,
+	it's up to the compositor to choose which display will be used to map
+	this surface.
+
+	If the surface doesn't cover the whole output, the compositor will
+	position the surface in the center of the output and compensate with
+	with border fill covering the rest of the output. The content of the
+	border fill is undefined, but should be assumed to be in some way that
+	attempts to blend into the surrounding area (e.g. solid black).
+
+	If the fullscreened surface is not opaque, the compositor must make
+	sure that other screen content not part of the same surface tree (made
+	up of subsurfaces, popups or similarly coupled surfaces) are not
+	visible below the fullscreened surface.
+      </description>
+      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
+    </request>
+
+    <request name="unset_fullscreen">
+      <description summary="unset the window as fullscreen">
+	Make the surface no longer fullscreen.
+
+	After requesting that the surface should be unfullscreened, the
+	compositor will respond by emitting a configure event.
+	Whether this actually removes the fullscreen state of the client is
+	subject to compositor policies.
+
+	Making a surface unfullscreen sets states for the surface based on the following:
+	* the state(s) it may have had before becoming fullscreen
+	* any state(s) decided by the compositor
+	* any state(s) requested by the client while the surface was fullscreen
+
+	The compositor may include the previous window geometry dimensions in
+	the configure event, if applicable.
+
+	The client must also acknowledge the configure when committing the new
+	content (see ack_configure).
+      </description>
+    </request>
+
+    <request name="set_minimized">
+      <description summary="set the window as minimized">
+	Request that the compositor minimize your surface. There is no
+	way to know if the surface is currently minimized, nor is there
+	any way to unset minimization on this surface.
+
+	If you are looking to throttle redrawing when minimized, please
+	instead use the wl_surface.frame event for this, as this will
+	also work with live previews on windows in Alt-Tab, Expose or
+	similar compositor features.
+      </description>
+    </request>
+
+    <event name="configure">
+      <description summary="suggest a surface change">
+	This configure event asks the client to resize its toplevel surface or
+	to change its state. The configured state should not be applied
+	immediately. See xdg_surface.configure for details.
+
+	The width and height arguments specify a hint to the window
+	about how its surface should be resized in window geometry
+	coordinates. See set_window_geometry.
+
+	If the width or height arguments are zero, it means the client
+	should decide its own window dimension. This may happen when the
+	compositor needs to configure the state of the surface but doesn't
+	have any information about any previous or expected dimension.
+
+	The states listed in the event specify how the width/height
+	arguments should be interpreted, and possibly how it should be
+	drawn.
+
+	Clients must send an ack_configure in response to this event. See
+	xdg_surface.configure and xdg_surface.ack_configure for details.
+      </description>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="states" type="array"/>
+    </event>
+
+    <event name="close">
+      <description summary="surface wants to be closed">
+	The close event is sent by the compositor when the user
+	wants the surface to be closed. This should be equivalent to
+	the user clicking the close button in client-side decorations,
+	if your application has any.
+
+	This is only a request that the user intends to close the
+	window. The client may choose to ignore this request, or show
+	a dialog to ask the user to save their data, etc.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="xdg_popup" version="3">
+    <description summary="short-lived, popup surfaces for menus">
+      A popup surface is a short-lived, temporary surface. It can be used to
+      implement for example menus, popovers, tooltips and other similar user
+      interface concepts.
+
+      A popup can be made to take an explicit grab. See xdg_popup.grab for
+      details.
+
+      When the popup is dismissed, a popup_done event will be sent out, and at
+      the same time the surface will be unmapped. See the xdg_popup.popup_done
+      event for details.
+
+      Explicitly destroying the xdg_popup object will also dismiss the popup and
+      unmap the surface. Clients that want to dismiss the popup when another
+      surface of their own is clicked should dismiss the popup using the destroy
+      request.
+
+      A newly created xdg_popup will be stacked on top of all previously created
+      xdg_popup surfaces associated with the same xdg_toplevel.
+
+      The parent of an xdg_popup must be mapped (see the xdg_surface
+      description) before the xdg_popup itself.
+
+      The client must call wl_surface.commit on the corresponding wl_surface
+      for the xdg_popup state to take effect.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_grab" value="0"
+	     summary="tried to grab after being mapped"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="remove xdg_popup interface">
+	This destroys the popup. Explicitly destroying the xdg_popup
+	object will also dismiss the popup, and unmap the surface.
+
+	If this xdg_popup is not the "topmost" popup, a protocol error
+	will be sent.
+      </description>
+    </request>
+
+    <request name="grab">
+      <description summary="make the popup take an explicit grab">
+	This request makes the created popup take an explicit grab. An explicit
+	grab will be dismissed when the user dismisses the popup, or when the
+	client destroys the xdg_popup. This can be done by the user clicking
+	outside the surface, using the keyboard, or even locking the screen
+	through closing the lid or a timeout.
+
+	If the compositor denies the grab, the popup will be immediately
+	dismissed.
+
+	This request must be used in response to some sort of user action like a
+	button press, key press, or touch down event. The serial number of the
+	event should be passed as 'serial'.
+
+	The parent of a grabbing popup must either be an xdg_toplevel surface or
+	another xdg_popup with an explicit grab. If the parent is another
+	xdg_popup it means that the popups are nested, with this popup now being
+	the topmost popup.
+
+	Nested popups must be destroyed in the reverse order they were created
+	in, e.g. the only popup you are allowed to destroy at all times is the
+	topmost one.
+
+	When compositors choose to dismiss a popup, they may dismiss every
+	nested grabbing popup as well. When a compositor dismisses popups, it
+	will follow the same dismissing order as required from the client.
+
+	The parent of a grabbing popup must either be another xdg_popup with an
+	active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
+	explicit grabs already taken.
+
+	If the topmost grabbing popup is destroyed, the grab will be returned to
+	the parent of the popup, if that parent previously had an explicit grab.
+
+	If the parent is a grabbing popup which has already been dismissed, this
+	popup will be immediately dismissed. If the parent is a popup that did
+	not take an explicit grab, an error will be raised.
+
+	During a popup grab, the client owning the grab will receive pointer
+	and touch events for all their surfaces as normal (similar to an
+	"owner-events" grab in X11 parlance), while the top most grabbing popup
+	will always have keyboard focus.
+      </description>
+      <arg name="seat" type="object" interface="wl_seat"
+	   summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
+    </request>
+
+    <event name="configure">
+      <description summary="configure the popup surface">
+	This event asks the popup surface to configure itself given the
+	configuration. The configured state should not be applied immediately.
+	See xdg_surface.configure for details.
+
+	The x and y arguments represent the position the popup was placed at
+	given the xdg_positioner rule, relative to the upper left corner of the
+	window geometry of the parent surface.
+
+	For version 2 or older, the configure event for an xdg_popup is only
+	ever sent once for the initial configuration. Starting with version 3,
+	it may be sent again if the popup is setup with an xdg_positioner with
+	set_reactive requested, or in response to xdg_popup.reposition requests.
+      </description>
+      <arg name="x" type="int"
+	   summary="x position relative to parent surface window geometry"/>
+      <arg name="y" type="int"
+	   summary="y position relative to parent surface window geometry"/>
+      <arg name="width" type="int" summary="window geometry width"/>
+      <arg name="height" type="int" summary="window geometry height"/>
+    </event>
+
+    <event name="popup_done">
+      <description summary="popup interaction is done">
+	The popup_done event is sent out when a popup is dismissed by the
+	compositor. The client should destroy the xdg_popup object at this
+	point.
+      </description>
+    </event>
+
+    <!-- Version 3 additions -->
+
+    <request name="reposition" since="3">
+      <description summary="recalculate the popup's location">
+	Reposition an already-mapped popup. The popup will be placed given the
+	details in the passed xdg_positioner object, and a
+	xdg_popup.repositioned followed by xdg_popup.configure and
+	xdg_surface.configure will be emitted in response. Any parameters set
+	by the previous positioner will be discarded.
+
+	The passed token will be sent in the corresponding
+	xdg_popup.repositioned event. The new popup position will not take
+	effect until the corresponding configure event is acknowledged by the
+	client. See xdg_popup.repositioned for details. The token itself is
+	opaque, and has no other special meaning.
+
+	If multiple reposition requests are sent, the compositor may skip all
+	but the last one.
+
+	If the popup is repositioned in response to a configure event for its
+	parent, the client should send an xdg_positioner.set_parent_configure
+	and possibly an xdg_positioner.set_parent_size request to allow the
+	compositor to properly constrain the popup.
+
+	If the popup is repositioned together with a parent that is being
+	resized, but not in response to a configure event, the client should
+	send an xdg_positioner.set_parent_size request.
+      </description>
+      <arg name="positioner" type="object" interface="xdg_positioner"/>
+      <arg name="token" type="uint" summary="reposition request token"/>
+    </request>
+
+    <event name="repositioned" since="3">
+      <description summary="signal the completion of a repositioned request">
+	The repositioned event is sent as part of a popup configuration
+	sequence, together with xdg_popup.configure and lastly
+	xdg_surface.configure to notify the completion of a reposition request.
+
+	The repositioned event is to notify about the completion of a
+	xdg_popup.reposition request. The token argument is the token passed
+	in the xdg_popup.reposition request.
+
+	Immediately after this event is emitted, xdg_popup.configure and
+	xdg_surface.configure will be sent with the updated size and position,
+	as well as a new configure serial.
+
+	The client should optionally update the content of the popup, but must
+	acknowledge the new popup configuration for the new position to take
+	effect. See xdg_surface.ack_configure for details.
+      </description>
+      <arg name="token" type="uint" summary="reposition request token"/>
+    </event>
+
+  </interface>
+</protocol>
diff --git a/gpu_display/src/gpu_display_win/mod.rs b/gpu_display/src/gpu_display_win/mod.rs
index f88e86435..e423b45c2 100644
--- a/gpu_display/src/gpu_display_win/mod.rs
+++ b/gpu_display/src/gpu_display_win/mod.rs
@@ -49,7 +49,7 @@ pub use window_procedure_thread::WindowProcedureThreadBuilder;
 #[cfg(feature = "vulkan_display")]
 use crate::gpu_display_win::window::BasicWindow;
 #[cfg(feature = "vulkan_display")]
-use crate::vulkan::VulkanDisplay;
+use crate::vulkan::HostDisplay;
 use crate::DisplayExternalResourceImport;
 use crate::DisplayT;
 use crate::EventDevice;
@@ -68,10 +68,10 @@ pub(crate) type ObjectId = NonZeroU32;
 pub struct VirtualDisplaySpace;
 pub struct HostWindowSpace;
 
-pub enum VulkanDisplayWrapper {
+pub enum HostDisplayWrapper {
     Uninitialized,
     #[cfg(feature = "vulkan_display")]
-    Initialized(VulkanDisplay),
+    Initialized(HostDisplay),
 }
 
 pub struct DisplayWin {
@@ -82,7 +82,7 @@ pub struct DisplayWin {
     #[allow(dead_code)]
     gpu_display_wait_descriptor_ctrl: SendTube,
     event_device_wait_descriptor_requests: Vec<ModifyWaitContext>,
-    vulkan_displays: HashMap<u32, Arc<Mutex<VulkanDisplayWrapper>>>,
+    host_displays: HashMap<u32, Arc<Mutex<HostDisplayWrapper>>>,
     #[allow(dead_code)]
     vulkan_display_create_params: Option<VulkanCreateParams>,
 }
@@ -108,7 +108,7 @@ impl DisplayWin {
             is_surface_created: false,
             gpu_display_wait_descriptor_ctrl,
             event_device_wait_descriptor_requests: Vec::new(),
-            vulkan_displays: HashMap::new(),
+            host_displays: HashMap::new(),
             vulkan_display_create_params,
         })
     }
@@ -120,7 +120,7 @@ impl DisplayWin {
         surface_id: u32,
         scanout_id: u32,
         display_params: &DisplayParameters,
-    ) -> Result<Arc<Mutex<VulkanDisplayWrapper>>> {
+    ) -> Result<Arc<Mutex<HostDisplayWrapper>>> {
         let display_params_clone = display_params.clone();
         let metrics = self.win_metrics.clone();
         #[cfg(feature = "vulkan_display")]
@@ -129,7 +129,7 @@ impl DisplayWin {
         // to know if the creation succeeds. Hence, we use channels to wait to see the result.
         let (result_sender, result_receiver) = channel();
         #[allow(unused_variables)]
-        let (vulkan_display_sender, vulkan_display_receiver) = channel();
+        let (host_display_sender, host_display_receiver) = channel();
 
         // Post a message to the WndProc thread to create the surface.
         self.wndproc_thread
@@ -137,7 +137,7 @@ impl DisplayWin {
                 scanout_id,
                 function: Box::new(move |window, display_event_dispatcher| {
                     #[cfg(feature = "vulkan_display")]
-                    let vulkan_display = {
+                    let host_display = {
                         let create_display_closure =
                             |VulkanCreateParams {
                                  vulkan_library,
@@ -153,7 +153,7 @@ impl DisplayWin {
                                         .get_client_rect()
                                         .with_context(|| "retrieve window client area size")?
                                         .size;
-                                    VulkanDisplay::new(
+                                    HostDisplay::new(
                                         vulkan_library,
                                         window.handle() as _,
                                         &initial_host_viewport_size.cast_unit(),
@@ -163,26 +163,24 @@ impl DisplayWin {
                                     .with_context(|| "create vulkan display")
                                 }
                             };
-                        let vulkan_display = vulkan_create_params
+                        let host_display = vulkan_create_params
                             .map(create_display_closure)
                             .transpose()?;
-                        let vulkan_display = match vulkan_display {
-                            Some(vulkan_display) => {
-                                VulkanDisplayWrapper::Initialized(vulkan_display)
-                            }
-                            None => VulkanDisplayWrapper::Uninitialized,
+                        let host_display = match host_display {
+                            Some(host_display) => HostDisplayWrapper::Initialized(host_display),
+                            None => HostDisplayWrapper::Uninitialized,
                         };
-                        let vulkan_display = Arc::new(Mutex::new(vulkan_display));
-                        vulkan_display_sender
-                            .send(Arc::clone(&vulkan_display))
+                        let host_display = Arc::new(Mutex::new(host_display));
+                        host_display_sender
+                            .send(Arc::clone(&host_display))
                             .map_err(|_| {
                                 format_err!("Failed to send vulkan display back to caller.")
                             })?;
-                        vulkan_display
+                        host_display
                     };
 
                     #[cfg(not(feature = "vulkan_display"))]
-                    let vulkan_display = Arc::new(Mutex::new(VulkanDisplayWrapper::Uninitialized));
+                    let host_display = Arc::new(Mutex::new(HostDisplayWrapper::Uninitialized));
 
                     Surface::new(
                         surface_id,
@@ -190,7 +188,7 @@ impl DisplayWin {
                         metrics,
                         &display_params_clone,
                         display_event_dispatcher,
-                        vulkan_display,
+                        host_display,
                     )
                 }),
                 callback: Box::new(move |success| {
@@ -202,7 +200,7 @@ impl DisplayWin {
 
         // Block until the surface creation finishes and check the result.
         match result_receiver.recv() {
-            Ok(true) => vulkan_display_receiver.recv().map_err(|_| {
+            Ok(true) => host_display_receiver.recv().map_err(|_| {
                 format_err!(
                     "Failed to receive the vulkan display from the surface creation routine."
                 )
@@ -282,7 +280,7 @@ impl DisplayT for DisplayWin {
 
         // Gfxstream allows for attaching a window only once along the initialization, so we only
         // create the surface once. See details in b/179319775.
-        let vulkan_display = match self.create_surface_internal(
+        let host_display = match self.create_surface_internal(
             surface_id,
             scanout_id.expect("scanout id is required"),
             display_params,
@@ -294,8 +292,8 @@ impl DisplayT for DisplayWin {
             Ok(display) => display,
         };
         self.is_surface_created = true;
-        self.vulkan_displays
-            .insert(surface_id, Arc::clone(&vulkan_display));
+        self.host_displays
+            .insert(surface_id, Arc::clone(&host_display));
 
         // Now that the window is ready, we can start listening for inbound (guest -> host) events
         // on our event devices.
@@ -316,7 +314,7 @@ impl DisplayT for DisplayWin {
                 error!("Failed to clone close_requested_event: {}", e);
                 GpuDisplayError::Allocate
             })?,
-            vulkan_display,
+            host_display,
         }))
     }
 
@@ -326,19 +324,19 @@ impl DisplayT for DisplayWin {
         surface_id: u32,
         #[allow(unused_variables)] external_display_resource: DisplayExternalResourceImport,
     ) -> Result<()> {
-        match self.vulkan_displays.get(&surface_id) {
-            Some(vulkan_display) => match *vulkan_display.lock() {
+        match self.host_displays.get(&surface_id) {
+            Some(host_display) => match *host_display.lock() {
                 #[cfg(feature = "vulkan_display")]
-                VulkanDisplayWrapper::Initialized(ref mut vulkan_display) => {
+                HostDisplayWrapper::Initialized(ref mut host_display) => {
                     match external_display_resource {
                         DisplayExternalResourceImport::VulkanImage {
                             descriptor,
                             metadata,
                         } => {
-                            vulkan_display.import_image(import_id, descriptor, metadata)?;
+                            host_display.import_image(import_id, descriptor, metadata)?;
                         }
                         DisplayExternalResourceImport::VulkanTimelineSemaphore { descriptor } => {
-                            vulkan_display.import_semaphore(import_id, descriptor)?;
+                            host_display.import_semaphore(import_id, descriptor)?;
                         }
                         DisplayExternalResourceImport::Dmabuf { .. } => {
                             bail!("gpu_display_win does not support importing dmabufs")
@@ -346,12 +344,12 @@ impl DisplayT for DisplayWin {
                     }
                     Ok(())
                 }
-                VulkanDisplayWrapper::Uninitialized => {
-                    bail!("VulkanDisplay is not initialized for this surface")
+                HostDisplayWrapper::Uninitialized => {
+                    bail!("HostDisplay is not initialized for this surface")
                 }
             },
             None => {
-                bail!("No VulkanDisplay for surface id {}", surface_id)
+                bail!("No HostDisplay for surface id {}", surface_id)
             }
         }
     }
@@ -359,11 +357,9 @@ impl DisplayT for DisplayWin {
     #[allow(unused_variables)]
     fn release_import(&mut self, surface_id: u32, import_id: u32) {
         #[cfg(feature = "vulkan_display")]
-        if let Some(vulkan_display) = self.vulkan_displays.get(&surface_id) {
-            if let VulkanDisplayWrapper::Initialized(ref mut vulkan_display) =
-                *vulkan_display.lock()
-            {
-                vulkan_display.delete_imported_image_or_semaphore(import_id);
+        if let Some(host_display) = self.host_displays.get(&surface_id) {
+            if let HostDisplayWrapper::Initialized(ref mut host_display) = *host_display.lock() {
+                host_display.delete_imported_image_or_semaphore(import_id);
             }
         }
     }
@@ -413,7 +409,7 @@ pub(crate) struct SurfaceWin {
     wndproc_thread: std::rc::Weak<WindowProcedureThread>,
     close_requested_event: Event,
     #[allow(dead_code)]
-    vulkan_display: Arc<Mutex<VulkanDisplayWrapper>>,
+    host_display: Arc<Mutex<HostDisplayWrapper>>,
 }
 
 impl GpuDisplaySurface for SurfaceWin {
@@ -454,7 +450,7 @@ impl GpuDisplaySurface for SurfaceWin {
         _release_timepoint: Option<SemaphoreTimepoint>,
         _extra_info: Option<FlipToExtraInfo>,
     ) -> Result<Waitable> {
-        bail!("vulkan_display feature is not enabled")
+        bail!("host_display feature is not enabled")
     }
 
     #[cfg(feature = "vulkan_display")]
@@ -478,15 +474,15 @@ impl GpuDisplaySurface for SurfaceWin {
         let release_timepoint =
             release_timepoint.ok_or(anyhow::anyhow!("release timepoint must be non-None"))?;
 
-        match *self.vulkan_display.lock() {
-            VulkanDisplayWrapper::Initialized(ref mut vulkan_display) => vulkan_display.post(
+        match *self.host_display.lock() {
+            HostDisplayWrapper::Initialized(ref mut host_display) => host_display.post(
                 import_id,
                 last_layout_transition,
                 acquire_timepoint,
                 release_timepoint,
             ),
-            VulkanDisplayWrapper::Uninitialized => {
-                bail!("VulkanDisplay is not initialized for this surface")
+            HostDisplayWrapper::Uninitialized => {
+                bail!("HostDisplay is not initialized for this surface")
             }
         }
     }
diff --git a/gpu_display/src/gpu_display_win/surface.rs b/gpu_display/src/gpu_display_win/surface.rs
index 6c7491f50..d4de662cf 100644
--- a/gpu_display/src/gpu_display_win/surface.rs
+++ b/gpu_display/src/gpu_display_win/surface.rs
@@ -50,9 +50,9 @@ use super::window_message_processor::SurfaceResources;
 use super::window_message_processor::WindowMessage;
 use super::window_message_processor::WindowPosMessage;
 use super::window_message_processor::HANDLE_WINDOW_MESSAGE_TIMEOUT;
+use super::HostDisplayWrapper;
 use super::HostWindowSpace;
 use super::MouseMode;
-use super::VulkanDisplayWrapper;
 use crate::EventDeviceKind;
 
 #[cfg(feature = "gfxstream")]
@@ -71,13 +71,13 @@ extern "C" {
 
 // Updates the rectangle in the window's client area to which gfxstream renders.
 fn update_virtual_display_projection(
-    #[allow(unused)] vulkan_display: impl Deref<Target = VulkanDisplayWrapper>,
+    #[allow(unused)] host_display: impl Deref<Target = HostDisplayWrapper>,
     #[allow(unused)] window: &GuiWindow,
     #[allow(unused)] projection_box: &Box2D<i32, HostWindowSpace>,
 ) {
     #[cfg(feature = "vulkan_display")]
-    if let VulkanDisplayWrapper::Initialized(ref vulkan_display) = *vulkan_display {
-        if let Err(err) = vulkan_display
+    if let HostDisplayWrapper::Initialized(ref host_display) = *host_display {
+        if let Err(err) = host_display
             .move_window(&projection_box.cast_unit())
             .with_context(|| "move the subwindow")
         {
@@ -132,7 +132,7 @@ pub struct Surface {
     virtual_display_manager: VirtualDisplayManager,
     #[allow(dead_code)]
     gpu_main_display_tube: Option<Rc<Tube>>,
-    vulkan_display: Arc<Mutex<VulkanDisplayWrapper>>,
+    host_display: Arc<Mutex<HostDisplayWrapper>>,
 }
 
 impl Surface {
@@ -142,7 +142,7 @@ impl Surface {
         _metrics: Option<Weak<Metrics>>,
         display_params: &DisplayParameters,
         resources: SurfaceResources,
-        vulkan_display: Arc<Mutex<VulkanDisplayWrapper>>,
+        host_display: Arc<Mutex<HostDisplayWrapper>>,
     ) -> Result<Self> {
         static CONTEXT_MESSAGE: &str = "When creating Surface";
         info!(
@@ -160,7 +160,7 @@ impl Surface {
             VirtualDisplayManager::new(&initial_host_viewport_size, &virtual_display_size);
         // This will make gfxstream initialize the child window to which it will render.
         update_virtual_display_projection(
-            vulkan_display.lock(),
+            host_display.lock(),
             window,
             &virtual_display_manager.get_virtual_display_projection_box(),
         );
@@ -189,7 +189,7 @@ impl Surface {
             .context(CONTEXT_MESSAGE)?,
             virtual_display_manager,
             gpu_main_display_tube,
-            vulkan_display,
+            host_display,
         })
     }
 
@@ -236,7 +236,7 @@ impl Surface {
             .virtual_display_manager
             .get_virtual_display_projection_box();
         update_virtual_display_projection(
-            self.vulkan_display.lock(),
+            self.host_display.lock(),
             window,
             &virtual_display_projection_box,
         );
diff --git a/gpu_display/src/gpu_display_wl.rs b/gpu_display/src/gpu_display_wl.rs
index 72436423b..d7b16f63b 100644
--- a/gpu_display/src/gpu_display_wl.rs
+++ b/gpu_display/src/gpu_display_wl.rs
@@ -443,7 +443,7 @@ impl DisplayT for DisplayWl {
         _surface_id: u32,
         external_display_resource: DisplayExternalResourceImport,
     ) -> anyhow::Result<()> {
-        // This let pattern is always true if the vulkan_display feature is disabled.
+        // This let pattern is always true if the host_display feature is disabled.
         #[allow(irrefutable_let_patterns)]
         if let DisplayExternalResourceImport::Dmabuf {
             descriptor,
diff --git a/gpu_display/src/vulkan.rs b/gpu_display/src/vulkan.rs
index 41151a2d5..7fcbebddb 100644
--- a/gpu_display/src/vulkan.rs
+++ b/gpu_display/src/vulkan.rs
@@ -36,8 +36,8 @@ pub use external_image::AcquireImageMemoryBarrier;
 pub use external_image::ExternalImage;
 pub use external_image::ExternalImageAccess;
 pub use external_image::ReleaseImageMemoryBarrier;
-use post_worker::PostWorker;
 use post_worker::Timepoint;
+use post_worker::VulkanPostWorker;
 use sync::create_promise_and_waitable;
 use sync::Promise;
 use sync::Waitable;
@@ -72,7 +72,7 @@ use crate::VulkanDisplayImageImportMetadata;
 // Vulkan Safety Notes:
 // Most vulkan APIs are unsafe, but even the wrapper APIs like ash and vulkano will mark their
 // APIs as unsafe when they cannot ensure that they are 100% obeying the vulkan spec. For the
-// purposes of VulkanDisplay, however, we do not consider disobeying the vulkan spec to be unsafe
+// purposes of HostDisplay, however, we do not consider disobeying the vulkan spec to be unsafe
 // in terms of memory safety. Safety comments in these cases will say:
 // "Safe irrespective of vulkan spec conformance"
 //
@@ -93,13 +93,13 @@ pub enum UserEvent {
     },
 }
 
-pub struct VulkanState {
+pub struct HostState {
     // Post worker submits renders and posts to vulkan. It needs to be in a RefCell because
     // process_event cannot take a mutable reference to ApplicationState.
-    post_worker: RefCell<PostWorker>,
+    post_worker: RefCell<VulkanPostWorker>,
 }
 
-impl ApplicationState for VulkanState {
+impl ApplicationState for HostState {
     type UserEvent = UserEvent;
 
     /// Process events coming from the Window.
@@ -149,30 +149,30 @@ impl ApplicationState for VulkanState {
     }
 }
 
-struct VulkanStateBuilder {
+struct HostStateBuilder {
     vulkan_library: Arc<VulkanLibrary>,
     device_uuid: [u8; vk::UUID_SIZE],
     driver_uuid: [u8; vk::UUID_SIZE],
 }
 
-impl ApplicationStateBuilder for VulkanStateBuilder {
-    type Target = VulkanState;
+impl ApplicationStateBuilder for HostStateBuilder {
+    type Target = HostState;
 
-    fn build<T: Window>(self, window: Arc<T>) -> Result<VulkanState> {
-        let post_worker = PostWorker::new(
+    fn build<T: Window>(self, window: Arc<T>) -> Result<HostState> {
+        let post_worker = VulkanPostWorker::new(
             self.vulkan_library,
             &self.device_uuid,
             &self.driver_uuid,
             Arc::clone(&window) as _,
         )
         .context("creating the post worker")?;
-        Ok(VulkanState {
+        Ok(HostState {
             post_worker: RefCell::new(post_worker),
         })
     }
 }
 
-pub struct VulkanDisplayImpl<T: WindowEventLoop<VulkanState>> {
+pub struct HostDisplayImpl<T: WindowEventLoop<HostState>> {
     ash_device: ash::Device,
     device: Arc<Device>,
     window_event_loop: T,
@@ -181,7 +181,7 @@ pub struct VulkanDisplayImpl<T: WindowEventLoop<VulkanState>> {
     used_image_receivers: HashMap<ImageId, Receiver<ExternalImage>>,
 }
 
-impl<T: WindowEventLoop<VulkanState>> VulkanDisplayImpl<T> {
+impl<T: WindowEventLoop<HostState>> HostDisplayImpl<T> {
     /// # Safety
     /// The parent window must outlive the lifetime of this object.
     #[deny(unsafe_op_in_unsafe_fn)]
@@ -192,7 +192,7 @@ impl<T: WindowEventLoop<VulkanState>> VulkanDisplayImpl<T> {
         device_uuid: [u8; UUID_SIZE],
         driver_uuid: [u8; UUID_SIZE],
     ) -> Result<Self> {
-        let vulkan_state_builder = VulkanStateBuilder {
+        let vulkan_state_builder = HostStateBuilder {
             vulkan_library,
             device_uuid,
             driver_uuid,
@@ -512,4 +512,4 @@ impl<T: WindowEventLoop<VulkanState>> VulkanDisplayImpl<T> {
     }
 }
 
-pub(crate) type VulkanDisplay = VulkanDisplayImpl<PlatformWindowEventLoop<VulkanState>>;
+pub(crate) type HostDisplay = HostDisplayImpl<PlatformWindowEventLoop<HostState>>;
diff --git a/gpu_display/src/vulkan/post_worker.rs b/gpu_display/src/vulkan/post_worker.rs
index 731147c7b..3d297464a 100644
--- a/gpu_display/src/vulkan/post_worker.rs
+++ b/gpu_display/src/vulkan/post_worker.rs
@@ -527,8 +527,8 @@ impl PostResource {
     }
 }
 
-/// PostWorker owns the vulkan surface and swapchain, and can post images to it.
-pub struct PostWorker {
+/// VulkanPostWorker owns the vulkan surface and swapchain, and can post images to it.
+pub struct VulkanPostWorker {
     physical_device: Arc<PhysicalDevice>,
     ash_device: Arc<ash::Device>,
     device: Arc<Device>,
@@ -544,7 +544,7 @@ pub struct PostWorker {
     _marker: PhantomData<Rc<()>>,
 }
 
-impl PostWorker {
+impl VulkanPostWorker {
     /// Initialize the post worker which does the following:
     ///   - Create the VkInstance
     ///   - Create the VkDevice and VkQueue
@@ -939,7 +939,7 @@ impl PostWorker {
     }
 }
 
-impl Drop for PostWorker {
+impl Drop for VulkanPostWorker {
     fn drop(&mut self) {
         if let Err(err) = self.drain_queues() {
             error!(
diff --git a/hypervisor/Android.bp b/hypervisor/Android.bp
index 42ef3a8f7..5cddfc8f8 100644
--- a/hypervisor/Android.bp
+++ b/hypervisor/Android.bp
@@ -37,7 +37,6 @@ rust_test {
         "libfnv",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -49,6 +48,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -81,7 +86,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -93,6 +97,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -125,7 +135,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -137,6 +146,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -169,7 +184,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -181,6 +195,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -213,7 +233,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -225,6 +244,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -257,7 +282,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -269,6 +293,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -301,7 +331,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -313,6 +342,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -345,7 +380,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -357,6 +391,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_test {
@@ -389,7 +429,6 @@ rust_test {
         "libhypervisor",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -401,6 +440,12 @@ rust_test {
         "libenumn",
         "libhypervisor_test_macro",
     ],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
 
 rust_library {
@@ -427,7 +472,6 @@ rust_library {
         "libfnv",
         "libkvm_sys",
         "liblibc",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsnapshot_crosvm",
@@ -436,4 +480,10 @@ rust_library {
     ],
     proc_macros: ["libenumn"],
     apex_available: ["com.android.virt"],
+    arch: {
+        arm64: {
+            rustlibs: ["libaarch64_sys_reg"],
+        },
+    },
+
 }
diff --git a/hypervisor/Android.bp.extra b/hypervisor/Android.bp.extra
new file mode 100644
index 000000000..35989537b
--- /dev/null
+++ b/hypervisor/Android.bp.extra
@@ -0,0 +1,5 @@
+arch: {
+    arm64: {
+        rustlibs: ["libaarch64_sys_reg"],
+    }
+}
diff --git a/hypervisor/Cargo.toml b/hypervisor/Cargo.toml
index 474b48ece..61cf0d655 100644
--- a/hypervisor/Cargo.toml
+++ b/hypervisor/Cargo.toml
@@ -14,32 +14,34 @@ gunyah = []
 noncoherent-dma = []
 
 [dependencies]
-anyhow = "1"
-bit_field = { path = "../bit_field" }
+anyhow = { workspace = true }
+bit_field = { workspace = true }
 bitflags = "2.2.1"
-cros_fdt = { path = "../cros_fdt" }
-data_model = { path = "../common/data_model" }
+cros_fdt = { workspace = true }
+data_model = { workspace = true }
 downcast-rs = "1.2.0"
-enumn = "0.1.0"
+enumn = { workspace = true }
 fnv = "1"
-libc = "0.2"
-once_cell = "1.7"
-serde = { version = "1", features = [ "derive" ] }
-serde_json = { version = "1" }
+libc = { workspace = true }
+serde = { workspace = true, features = [ "derive" ] }
+serde_json = { workspace = true }
 snapshot = { workspace = true }
-sync = { path = "../common/sync" }
-base = { path = "../base" }
-vm_memory = { path = "../vm_memory" }
+sync = { workspace = true }
+base = { workspace = true }
+vm_memory = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-kvm_sys = { path = "../kvm_sys" }
+kvm_sys = { workspace = true }
+
+[target.'cfg(any(target_arch = "arm", target_arch = "aarch64"))'.dependencies]
+aarch64_sys_reg = { workspace = true }
 
 [target.'cfg(target_arch = "x86_64")'.dev-dependencies]
-hypervisor_test_macro = { path = "hypervisor_test_macro" }
+hypervisor_test_macro = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [target.'cfg(windows)'.dependencies]
-thiserror = "1"
+thiserror = { workspace = true }
 winapi = "0.3"
 win_util = { path = "../win_util" }
 
diff --git a/hypervisor/hypervisor_test_macro/Android.bp b/hypervisor/hypervisor_test_macro/Android.bp
index 7faadf2e6..a24a262e2 100644
--- a/hypervisor/hypervisor_test_macro/Android.bp
+++ b/hypervisor/hypervisor_test_macro/Android.bp
@@ -19,7 +19,7 @@ rust_proc_macro {
     rustlibs: [
         "libproc_macro2",
         "libquote",
-        "librand",
+        "librand-0.8",
         "libsyn",
     ],
     apex_available: ["com.android.virt"],
diff --git a/hypervisor/hypervisor_test_macro/Cargo.toml b/hypervisor/hypervisor_test_macro/Cargo.toml
index 1d6a49e3c..7382ed7a4 100644
--- a/hypervisor/hypervisor_test_macro/Cargo.toml
+++ b/hypervisor/hypervisor_test_macro/Cargo.toml
@@ -11,4 +11,4 @@ proc-macro = true
 proc-macro2 = { version = "^1", features = ["span-locations"] }
 quote = "^1"
 syn = "2"
-rand = "0.8"
+rand = { workspace = true }
diff --git a/hypervisor/src/aarch64.rs b/hypervisor/src/aarch64.rs
index 987ef96fb..1e98ca69d 100644
--- a/hypervisor/src/aarch64.rs
+++ b/hypervisor/src/aarch64.rs
@@ -6,6 +6,7 @@ use std::collections::BTreeMap;
 use std::convert::TryFrom;
 use std::fmt::Debug;
 
+use aarch64_sys_reg::AArch64SysRegId;
 use anyhow::Context;
 use base::Error;
 use base::Result;
@@ -56,103 +57,6 @@ pub const AARCH64_MAX_REG_COUNT: usize = 1024;
 pub const PSCI_0_2: PsciVersion = PsciVersion { major: 0, minor: 2 };
 pub const PSCI_1_0: PsciVersion = PsciVersion { major: 1, minor: 0 };
 
-/// AArch64 system register as used in MSR/MRS instructions.
-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Deserialize, Serialize)]
-#[serde(transparent)]
-pub struct AArch64SysRegId(u16);
-
-impl AArch64SysRegId {
-    /// Construct a system register ID from Op0, Op1, CRn, CRm, Op2.
-    ///
-    /// The meanings of the arguments are described in the ARMv8 Architecture Reference Manual
-    /// "System instruction class encoding overview" section.
-    pub fn new(op0: u8, op1: u8, crn: u8, crm: u8, op2: u8) -> Result<Self> {
-        if op0 > 0b11 || op1 > 0b111 || crn > 0b1111 || crm > 0b1111 || op2 > 0b111 {
-            return Err(Error::new(EINVAL));
-        }
-
-        Ok(Self::new_unchecked(op0, op1, crn, crm, op2))
-    }
-
-    /// Construct a system register ID from Op0, Op1, CRn, CRm, Op2.
-    ///
-    /// Out-of-range values will be silently truncated.
-    pub const fn new_unchecked(op0: u8, op1: u8, crn: u8, crm: u8, op2: u8) -> Self {
-        let op0 = (op0 as u16 & 0b11) << 14;
-        let op1 = (op1 as u16 & 0b111) << 11;
-        let crn = (crn as u16 & 0b1111) << 7;
-        let crm = (crm as u16 & 0b1111) << 3;
-        let op2 = op2 as u16 & 0b111;
-        Self(op0 | op1 | crn | crm | op2)
-    }
-
-    pub fn from_encoded(v: u16) -> Self {
-        Self(v)
-    }
-
-    #[inline]
-    pub const fn op0(&self) -> u8 {
-        ((self.0 >> 14) & 0b11) as u8
-    }
-
-    #[inline]
-    pub const fn op1(&self) -> u8 {
-        ((self.0 >> 11) & 0b111) as u8
-    }
-
-    #[inline]
-    pub const fn crn(&self) -> u8 {
-        ((self.0 >> 7) & 0b1111) as u8
-    }
-
-    #[inline]
-    pub const fn crm(&self) -> u8 {
-        ((self.0 >> 3) & 0b1111) as u8
-    }
-
-    #[inline]
-    pub const fn op2(&self) -> u8 {
-        (self.0 & 0b111) as u8
-    }
-
-    /// Returns the system register as encoded in bits 5-20 of MRS and MSR instructions.
-    pub const fn encoded(&self) -> u16 {
-        self.0
-    }
-}
-
-impl Debug for AArch64SysRegId {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("AArch64SysRegId")
-            .field("Op0", &self.op0())
-            .field("Op1", &self.op1())
-            .field("CRn", &self.crn())
-            .field("CRm", &self.crm())
-            .field("Op2", &self.op2())
-            .finish()
-    }
-}
-
-#[rustfmt::skip]
-#[allow(non_upper_case_globals)]
-impl AArch64SysRegId {
-    //                                                         Op0    Op1     CRn     CRm    Op2
-    pub const MPIDR_EL1: Self           = Self::new_unchecked(0b11, 0b000, 0b0000, 0b0000, 0b101);
-    pub const CCSIDR_EL1: Self          = Self::new_unchecked(0b11, 0b001, 0b0000, 0b0000, 0b000);
-    pub const CSSELR_EL1: Self          = Self::new_unchecked(0b11, 0b010, 0b0000, 0b0000, 0b000);
-    pub const FPCR: Self                = Self::new_unchecked(0b11, 0b011, 0b0100, 0b0100, 0b000);
-    pub const FPSR: Self                = Self::new_unchecked(0b11, 0b011, 0b0100, 0b0100, 0b001);
-    pub const SPSR_EL1: Self            = Self::new_unchecked(0b11, 0b000, 0b0100, 0b0000, 0b000);
-    pub const SPSR_irq: Self            = Self::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b000);
-    pub const SPSR_abt: Self            = Self::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b001);
-    pub const SPSR_und: Self            = Self::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b010);
-    pub const SPSR_fiq: Self            = Self::new_unchecked(0b11, 0b100, 0b0100, 0b0011, 0b011);
-    pub const ELR_EL1: Self             = Self::new_unchecked(0b11, 0b000, 0b0100, 0b0000, 0b001);
-    pub const SP_EL1: Self              = Self::new_unchecked(0b11, 0b100, 0b0100, 0b0001, 0b000);
-    pub const CNTVCT_EL0: Self          = Self::new_unchecked(0b11, 0b011, 0b1110, 0b0000, 0b010);
-    pub const CNTV_CVAL_EL0: Self       = Self::new_unchecked(0b11, 0b011, 0b1110, 0b0011, 0b010);
-}
-
 #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
 pub enum VcpuRegAArch64 {
     X(u8),
@@ -187,7 +91,7 @@ pub trait VmAArch64: Vm {
         payload_entry_address: GuestAddress,
         fdt_address: GuestAddress,
         fdt_size: usize,
-    ) -> Result<()>;
+    ) -> anyhow::Result<()>;
 
     /// Set an offset that describes a number of counter cycles that are subtracted from both
     /// virtual and physical counter views.
@@ -384,89 +288,3 @@ pub enum VcpuFeature {
     /// Scalable Vector Extension support
     Sve,
 }
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn sysreg_new() {
-        let sysreg = AArch64SysRegId::new(1, 2, 3, 4, 5).unwrap();
-        assert_eq!(sysreg.op0(), 1);
-        assert_eq!(sysreg.op1(), 2);
-        assert_eq!(sysreg.crn(), 3);
-        assert_eq!(sysreg.crm(), 4);
-        assert_eq!(sysreg.op2(), 5);
-        assert_eq!(sysreg.encoded(), 0x51A5);
-    }
-
-    #[test]
-    fn sysreg_new_max() {
-        let sysreg = AArch64SysRegId::new(0b11, 0b111, 0b1111, 0b1111, 0b111).unwrap();
-        assert_eq!(sysreg.op0(), 3);
-        assert_eq!(sysreg.op1(), 7);
-        assert_eq!(sysreg.crn(), 15);
-        assert_eq!(sysreg.crm(), 15);
-        assert_eq!(sysreg.op2(), 7);
-        assert_eq!(sysreg.encoded(), 0xFFFF);
-    }
-
-    #[test]
-    fn sysreg_new_out_of_range() {
-        AArch64SysRegId::new(4, 0, 0, 0, 0).expect_err("invalid Op0");
-        AArch64SysRegId::new(0, 8, 0, 0, 0).expect_err("invalid Op1");
-        AArch64SysRegId::new(0, 0, 16, 0, 0).expect_err("invalid CRn");
-        AArch64SysRegId::new(0, 0, 0, 16, 0).expect_err("invalid CRm");
-        AArch64SysRegId::new(0, 0, 0, 0, 8).expect_err("invalid Op2");
-    }
-
-    #[test]
-    fn sysreg_encoding_mpidr_el1() {
-        assert_eq!(AArch64SysRegId::MPIDR_EL1.op0(), 3);
-        assert_eq!(AArch64SysRegId::MPIDR_EL1.op1(), 0);
-        assert_eq!(AArch64SysRegId::MPIDR_EL1.crn(), 0);
-        assert_eq!(AArch64SysRegId::MPIDR_EL1.crm(), 0);
-        assert_eq!(AArch64SysRegId::MPIDR_EL1.op2(), 5);
-        assert_eq!(AArch64SysRegId::MPIDR_EL1.encoded(), 0xC005);
-        assert_eq!(
-            AArch64SysRegId::MPIDR_EL1,
-            AArch64SysRegId::new(3, 0, 0, 0, 5).unwrap()
-        );
-    }
-
-    #[test]
-    fn sysreg_encoding_cntvct_el0() {
-        assert_eq!(AArch64SysRegId::CNTVCT_EL0.op0(), 3);
-        assert_eq!(AArch64SysRegId::CNTVCT_EL0.op1(), 3);
-        assert_eq!(AArch64SysRegId::CNTVCT_EL0.crn(), 14);
-        assert_eq!(AArch64SysRegId::CNTVCT_EL0.crm(), 0);
-        assert_eq!(AArch64SysRegId::CNTVCT_EL0.op2(), 2);
-        assert_eq!(AArch64SysRegId::CNTVCT_EL0.encoded(), 0xDF02);
-        assert_eq!(
-            AArch64SysRegId::CNTVCT_EL0,
-            AArch64SysRegId::new(3, 3, 14, 0, 2).unwrap()
-        );
-    }
-
-    #[test]
-    fn sysreg_encoding_cntv_cval_el0() {
-        assert_eq!(AArch64SysRegId::CNTV_CVAL_EL0.op0(), 3);
-        assert_eq!(AArch64SysRegId::CNTV_CVAL_EL0.op1(), 3);
-        assert_eq!(AArch64SysRegId::CNTV_CVAL_EL0.crn(), 14);
-        assert_eq!(AArch64SysRegId::CNTV_CVAL_EL0.crm(), 3);
-        assert_eq!(AArch64SysRegId::CNTV_CVAL_EL0.op2(), 2);
-        assert_eq!(AArch64SysRegId::CNTV_CVAL_EL0.encoded(), 0xDF1A);
-        assert_eq!(
-            AArch64SysRegId::CNTV_CVAL_EL0,
-            AArch64SysRegId::new(3, 3, 14, 3, 2).unwrap()
-        );
-    }
-
-    #[test]
-    fn sysreg_debug() {
-        assert_eq!(
-            format!("{:?}", AArch64SysRegId::MPIDR_EL1),
-            "AArch64SysRegId { Op0: 3, Op1: 0, CRn: 0, CRm: 0, Op2: 5 }"
-        );
-    }
-}
diff --git a/hypervisor/src/caps.rs b/hypervisor/src/caps.rs
index 6422886dd..8c209c71d 100644
--- a/hypervisor/src/caps.rs
+++ b/hypervisor/src/caps.rs
@@ -5,10 +5,7 @@
 /// An enumeration of different hypervisor capabilities.
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
 pub enum HypervisorCap {
-    ArmPmuV3,
     ImmediateExit,
-    S390UserSigp,
-    TscDeadlineTimer,
     UserMemory,
     #[cfg(target_arch = "x86_64")]
     Xcrs,
@@ -27,8 +24,10 @@ pub enum HypervisorCap {
     // By default, when swiotlb is enabled, crosvm will only specify its size in the device tree
     // and allow the guest to decide where to allocate the buffer in guest phsyical memory.
     //
-    // If this capability is declared, then instead crosvm will allocate space for the swiotlb
-    // outside of guest physical memory and specify both the address and size in the device tree.
+    // If this capability is declared, then instead crosvm will carve out space at the end of
+    // physical memory and register it as a distinct memory region. Then, both the address and
+    // size will be specified in the device tree. This region will still be reported as part
+    // of the main memory region in the device tree.
     StaticSwiotlbAllocationRequired,
     /// Some hypervisors (presently: Gunyah) will configure initial boot-time registers
     /// for vCPUs without need for CrosVM to specify.
@@ -41,6 +40,8 @@ pub enum HypervisorCap {
 /// A capability the `Vm` can possibly expose.
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
 pub enum VmCap {
+    #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
+    ArmPmuV3,
     /// Track dirty pages
     DirtyLog,
     /// Paravirtualized clock device
diff --git a/hypervisor/src/geniezone/mod.rs b/hypervisor/src/geniezone/mod.rs
index 7b4900f4d..2fcb61ecd 100644
--- a/hypervisor/src/geniezone/mod.rs
+++ b/hypervisor/src/geniezone/mod.rs
@@ -16,6 +16,8 @@ use std::path::Path;
 use std::path::PathBuf;
 use std::sync::Arc;
 
+use aarch64_sys_reg::AArch64SysRegId;
+use anyhow::Context;
 use base::errno_result;
 use base::error;
 use base::ioctl;
@@ -54,7 +56,6 @@ use vm_memory::GuestAddress;
 use vm_memory::GuestMemory;
 use vm_memory::MemoryRegionPurpose;
 
-use crate::AArch64SysRegId;
 use crate::BalloonEvent;
 use crate::ClockState;
 use crate::Config;
@@ -189,7 +190,7 @@ impl VmAArch64 for GeniezoneVm {
         _payload_entry_address: GuestAddress,
         fdt_address: GuestAddress,
         fdt_size: usize,
-    ) -> Result<()> {
+    ) -> anyhow::Result<()> {
         let dtb_config = gzvm_dtb_config {
             dtb_addr: fdt_address.offset(),
             dtb_size: fdt_size.try_into().unwrap(),
@@ -201,7 +202,7 @@ impl VmAArch64 for GeniezoneVm {
         if ret == 0 {
             Ok(())
         } else {
-            errno_result()
+            errno_result().context("GZVM_SET_DTB_CONFIG failed")
         }
     }
 }
@@ -346,21 +347,21 @@ impl From<GeniezoneVcpuRegister> for u64 {
             GeniezoneVcpuRegister::V(n) => {
                 unreachable!("invalid GeniezoneVcpuRegister Vn index: {n}")
             }
-            GeniezoneVcpuRegister::System(AArch64SysRegId::FPSR) => {
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::FPSR) => {
                 user_fpsimd_state_reg(GZVM_REG_SIZE_U32, offset_of!(user_fpsimd_state, fpsr))
             }
-            GeniezoneVcpuRegister::System(AArch64SysRegId::FPCR) => {
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::FPCR) => {
                 user_fpsimd_state_reg(GZVM_REG_SIZE_U32, offset_of!(user_fpsimd_state, fpcr))
             }
-            GeniezoneVcpuRegister::System(AArch64SysRegId::SPSR_EL1) => spsr_reg(0),
-            GeniezoneVcpuRegister::System(AArch64SysRegId::SPSR_abt) => spsr_reg(1),
-            GeniezoneVcpuRegister::System(AArch64SysRegId::SPSR_und) => spsr_reg(2),
-            GeniezoneVcpuRegister::System(AArch64SysRegId::SPSR_irq) => spsr_reg(3),
-            GeniezoneVcpuRegister::System(AArch64SysRegId::SPSR_fiq) => spsr_reg(4),
-            GeniezoneVcpuRegister::System(AArch64SysRegId::SP_EL1) => {
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::SPSR_EL1) => spsr_reg(0),
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::SPSR_abt) => spsr_reg(1),
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::SPSR_und) => spsr_reg(2),
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::SPSR_irq) => spsr_reg(3),
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::SPSR_fiq) => spsr_reg(4),
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::SP_EL1) => {
                 gzvm_reg(offset_of!(gzvm_regs, sp_el1))
             }
-            GeniezoneVcpuRegister::System(AArch64SysRegId::ELR_EL1) => {
+            GeniezoneVcpuRegister::System(aarch64_sys_reg::ELR_EL1) => {
                 gzvm_reg(offset_of!(gzvm_regs, elr_el1))
             }
             GeniezoneVcpuRegister::System(sysreg) => {
@@ -568,11 +569,9 @@ impl Hypervisor for Geniezone {
     fn check_capability(&self, cap: HypervisorCap) -> bool {
         match cap {
             HypervisorCap::UserMemory => true,
-            HypervisorCap::ArmPmuV3 => false,
             HypervisorCap::ImmediateExit => true,
             HypervisorCap::StaticSwiotlbAllocationRequired => true,
             HypervisorCap::HypervisorInitializedBootContext => false,
-            HypervisorCap::S390UserSigp | HypervisorCap::TscDeadlineTimer => false,
         }
     }
 }
@@ -898,6 +897,7 @@ impl Vm for GeniezoneVm {
             return val;
         }
         match c {
+            VmCap::ArmPmuV3 => false,
             VmCap::DirtyLog => true,
             VmCap::PvClock => false,
             VmCap::Protected => self.check_raw_capability(GeniezoneCap::ArmProtectedVm),
diff --git a/hypervisor/src/gunyah/aarch64.rs b/hypervisor/src/gunyah/aarch64.rs
index 3d08c5382..a0fed3702 100644
--- a/hypervisor/src/gunyah/aarch64.rs
+++ b/hypervisor/src/gunyah/aarch64.rs
@@ -4,12 +4,14 @@
 
 use std::collections::BTreeMap;
 
+use aarch64_sys_reg::AArch64SysRegId;
+use anyhow::bail;
+use anyhow::Context;
 use base::error;
 use base::Error;
 use base::Result;
 use cros_fdt::Fdt;
 use cros_fdt::FdtNode;
-use libc::ENOENT;
 use libc::ENOTSUP;
 use libc::ENOTTY;
 use snapshot::AnySnapshot;
@@ -18,7 +20,6 @@ use vm_memory::MemoryRegionPurpose;
 
 use super::GunyahVcpu;
 use super::GunyahVm;
-use crate::AArch64SysRegId;
 use crate::Hypervisor;
 use crate::PsciVersion;
 use crate::VcpuAArch64;
@@ -157,7 +158,7 @@ impl VmAArch64 for GunyahVm {
         payload_entry_address: GuestAddress,
         fdt_address: GuestAddress,
         fdt_size: usize,
-    ) -> Result<()> {
+    ) -> anyhow::Result<()> {
         // The payload entry is the memory address where the kernel starts.
         // This memory region contains both the DTB and the kernel image,
         // so ensure they are located together.
@@ -165,14 +166,35 @@ impl VmAArch64 for GunyahVm {
         let (dtb_mapping, _, dtb_obj_offset) = self
             .guest_mem
             .find_region(fdt_address)
-            .map_err(|_| Error::new(ENOENT))?;
+            .context("Failed to find FDT region")?;
         let (payload_mapping, payload_offset, payload_obj_offset) = self
             .guest_mem
             .find_region(payload_entry_address)
-            .map_err(|_| Error::new(ENOENT))?;
+            .context("Failed to find payload region")?;
 
         if !std::ptr::eq(dtb_mapping, payload_mapping) || dtb_obj_offset != payload_obj_offset {
-            panic!("DTB and payload are not part of same memory region.");
+            bail!("DTB and payload are not part of same memory region.");
+        }
+
+        if self.vm_id.is_some() && self.pas_id.is_some() {
+            // Gunyah will find the metadata about the Qualcomm Trusted VM in the
+            // first few pages (decided at build time) of the primary payload region.
+            // This metadata consists of the elf header which tells Gunyah where
+            // the different elf segments (kernel/DTB/ramdisk) are. As we send the entire
+            // primary payload as a single memory parcel to Gunyah, with the offsets from
+            // the elf header, Gunyah can find the VM DTBOs.
+            // Pass on the primary payload region start address and its size for Qualcomm
+            // Trusted VMs.
+            let payload_region = self
+                .guest_mem
+                .regions()
+                .find(|region| region.guest_addr == payload_entry_address)
+                .context("Failed to find payload region")?;
+            self.set_vm_auth_type_to_qcom_trusted_vm(
+                payload_entry_address,
+                payload_region.size.try_into().unwrap(),
+            )
+            .context("Failed to set VM authentication type")?;
         }
 
         if self.vm_id.is_some() && self.pas_id.is_some() {
@@ -186,7 +208,10 @@ impl VmAArch64 for GunyahVm {
             // Trusted VMs.
             for region in self.guest_mem.regions() {
                 if region.guest_addr.offset() == payload_entry_address.offset() {
-                    self.set_vm_auth_type_to_qcom_trusted_vm(payload_entry_address, region.size.try_into().unwrap());
+                    self.set_vm_auth_type_to_qcom_trusted_vm(
+                        payload_entry_address,
+                        region.size.try_into().unwrap(),
+                    );
                     break;
                 }
             }
@@ -196,9 +221,11 @@ impl VmAArch64 for GunyahVm {
 
         // Gunyah sets the PC to the payload entry point for protected VMs without firmware.
         // It needs to be 0 as Gunyah assumes it to be kernel start.
-        if self.hv_cfg.protection_type.isolates_memory() &&
-           !self.hv_cfg.protection_type.runs_firmware() && payload_offset != 0 {
-            panic!("Payload offset must be zero");
+        if self.hv_cfg.protection_type.isolates_memory()
+            && !self.hv_cfg.protection_type.runs_firmware()
+            && payload_offset != 0
+        {
+            bail!("Payload offset must be zero");
         }
 
         if let Err(e) = self.set_boot_pc(payload_entry_address.offset()) {
@@ -206,10 +233,10 @@ impl VmAArch64 for GunyahVm {
                 // GH_VM_SET_BOOT_CONTEXT ioctl is not supported, but returning success
                 // for backward compatibility when the offset is zero.
                 if payload_offset != 0 {
-                    panic!("Payload offset must be zero");
+                    bail!("Payload offset must be zero");
                 }
             } else {
-                return Err(e);
+                return Err(e).context("set_boot_pc failed");
             }
         }
 
diff --git a/hypervisor/src/gunyah/gunyah_sys/bindings.rs b/hypervisor/src/gunyah/gunyah_sys/bindings.rs
index 19e378d9a..629224721 100644
--- a/hypervisor/src/gunyah/gunyah_sys/bindings.rs
+++ b/hypervisor/src/gunyah/gunyah_sys/bindings.rs
@@ -24,14 +24,14 @@ pub const GH_VCPU_EXIT_MMIO: u32 = 1;
 pub const GH_VCPU_EXIT_STATUS: u32 = 2;
 pub const GH_ANDROID_IOCTL_TYPE: u8 = 65u8;
 pub const GH_VM_BOOT_CONTEXT_REG_SHIFT: u32 = 8;
-pub type i8 = :: std :: os :: raw :: c_schar;
-pub type u8 = :: std :: os :: raw :: c_uchar;
-pub type i16 = :: std :: os :: raw :: c_short;
-pub type u16 = :: std :: os :: raw :: c_ushort;
-pub type i32 = :: std :: os :: raw :: c_int;
-pub type u32 = :: std :: os :: raw :: c_uint;
-pub type i64 = :: std :: os :: raw :: c_longlong;
-pub type u64 = :: std :: os :: raw :: c_ulonglong;
+pub type i8 = ::std::os::raw::c_schar;
+pub type u8 = ::std::os::raw::c_uchar;
+pub type i16 = ::std::os::raw::c_short;
+pub type u16 = ::std::os::raw::c_ushort;
+pub type i32 = ::std::os::raw::c_int;
+pub type u32 = ::std::os::raw::c_uint;
+pub type i64 = ::std::os::raw::c_longlong;
+pub type u64 = ::std::os::raw::c_ulonglong;
 pub type __s128 = i128;
 pub type __u128 = u128;
 pub type __le16 = u16;
@@ -42,24 +42,24 @@ pub type __le64 = u64;
 pub type __be64 = u64;
 pub type __sum16 = u16;
 pub type __wsum = u32;
-pub type __poll_t = :: std :: os :: raw :: c_uint;
-pub const gunyah_auth_type_GUNYAH_ANDROID_PVM_TYPE : gunyah_auth_type = 0;
-pub const gunyah_auth_type_GUNYAH_QCOM_TRUSTED_VM_TYPE : gunyah_auth_type = 1;
-pub type gunyah_auth_type = :: std :: os :: raw :: c_uint;
-#[repr (C)]
-#[derive (Debug , Default , Copy , Clone)]
+pub type __poll_t = ::std::os::raw::c_uint;
+pub const gunyah_auth_type_GUNYAH_ANDROID_PVM_TYPE: gunyah_auth_type = 0;
+pub const gunyah_auth_type_GUNYAH_QCOM_TRUSTED_VM_TYPE: gunyah_auth_type = 1;
+pub type gunyah_auth_type = ::std::os::raw::c_uint;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone)]
 pub struct gunyah_qtvm_auth_arg {
-    pub vm_id : u16,
-    pub pas_id : u32,
-    pub guest_phys_addr : u64,
-    pub size : u64,
+    pub vm_id: u16,
+    pub pas_id: u32,
+    pub guest_phys_addr: u64,
+    pub size: u64,
 }
-#[repr (C)]
-#[derive (Debug , Default , Copy , Clone)]
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone)]
 pub struct gunyah_auth_desc {
-    pub type_ : u32,
-    pub arg_size : u32,
-    pub arg : u64,
+    pub type_: u32,
+    pub arg_size: u32,
+    pub arg: u64,
 }
 #[repr(C)]
 #[derive(Debug, Default, Copy, Clone)]
@@ -198,22 +198,22 @@ pub struct gunyah_address_range {
     pub guest_phys_addr: u64,
     pub size: u64,
 }
-pub const GUNYAH_MEM_ALLOW_READ : gunyah_map_flags = 1 ;
-pub const GUNYAH_MEM_ALLOW_WRITE : gunyah_map_flags = 2 ;
-pub const GUNYAH_MEM_ALLOW_EXEC : gunyah_map_flags = 4 ;
-pub const GUNYAH_MEM_ALLOW_RWX : gunyah_map_flags = 7 ;
-pub const GUNYAH_MEM_DEFAULT_ACCESS : gunyah_map_flags = 0 ;
-pub const GUNYAH_MEM_FORCE_LEND : gunyah_map_flags = 16 ;
-pub const GUNYAH_MEM_FORCE_SHARE : gunyah_map_flags = 32 ;
-pub const GUNYAH_MEM_UNMAP : gunyah_map_flags = 256 ;
-pub type gunyah_map_flags = :: std :: os :: raw :: c_uint ;
-#[repr (C)]
-#[derive (Debug , Default , Copy , Clone)]
+pub const GUNYAH_MEM_ALLOW_READ: gunyah_map_flags = 1;
+pub const GUNYAH_MEM_ALLOW_WRITE: gunyah_map_flags = 2;
+pub const GUNYAH_MEM_ALLOW_EXEC: gunyah_map_flags = 4;
+pub const GUNYAH_MEM_ALLOW_RWX: gunyah_map_flags = 7;
+pub const GUNYAH_MEM_DEFAULT_ACCESS: gunyah_map_flags = 0;
+pub const GUNYAH_MEM_FORCE_LEND: gunyah_map_flags = 16;
+pub const GUNYAH_MEM_FORCE_SHARE: gunyah_map_flags = 32;
+pub const GUNYAH_MEM_UNMAP: gunyah_map_flags = 256;
+pub type gunyah_map_flags = ::std::os::raw::c_uint;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone)]
 pub struct gunyah_map_cma_mem_args {
     pub label: u32,
-    pub guest_addr : u64,
-    pub flags : u32,
-    pub guest_mem_fd : u32,
-    pub offset : u64,
-    pub size : u64,
+    pub guest_addr: u64,
+    pub flags: u32,
+    pub guest_mem_fd: u32,
+    pub offset: u64,
+    pub size: u64,
 }
diff --git a/hypervisor/src/gunyah/mod.rs b/hypervisor/src/gunyah/mod.rs
index 2ab6c39ff..4df7fad25 100644
--- a/hypervisor/src/gunyah/mod.rs
+++ b/hypervisor/src/gunyah/mod.rs
@@ -94,13 +94,9 @@ impl Hypervisor for Gunyah {
     fn check_capability(&self, cap: HypervisorCap) -> bool {
         match cap {
             HypervisorCap::UserMemory => true,
-            HypervisorCap::ArmPmuV3 => false,
             HypervisorCap::ImmediateExit => true,
             HypervisorCap::StaticSwiotlbAllocationRequired => true,
             HypervisorCap::HypervisorInitializedBootContext => true,
-            HypervisorCap::S390UserSigp | HypervisorCap::TscDeadlineTimer => false,
-            #[cfg(target_arch = "x86_64")]
-            HypervisorCap::Xcrs | HypervisorCap::CalibratedTscLeafRequired => false,
         }
     }
 }
@@ -189,8 +185,7 @@ fn map_cma_region(
     }
     if lend {
         flags |= GUNYAH_MEM_FORCE_LEND;
-    }
-    else {
+    } else {
         flags |= GUNYAH_MEM_FORCE_SHARE;
     }
     let region = gunyah_map_cma_mem_args {
@@ -236,7 +231,13 @@ impl AsRawDescriptor for GunyahVm {
 }
 
 impl GunyahVm {
-    pub fn new(gh: &Gunyah, vm_id: Option<u16>, pas_id: Option<u32>, guest_mem: GuestMemory, cfg: Config) -> Result<GunyahVm> {
+    pub fn new(
+        gh: &Gunyah,
+        vm_id: Option<u16>,
+        pas_id: Option<u32>,
+        guest_mem: GuestMemory,
+        cfg: Config,
+    ) -> Result<GunyahVm> {
         // SAFETY:
         // Safe because we know gunyah is a real gunyah fd as this module is the only one that can
         // make Gunyah objects.
@@ -262,16 +263,16 @@ impl GunyahVm {
             } else {
                 false
             };
-            if region.options.file_backed.is_some() {
+            if let Some(file_backed) = &region.options.file_backed {
                 map_cma_region(
-                        &vm_descriptor,
-                        region.index as MemSlot,
-                        lend,
-                        !region.options.file_backed.unwrap().writable,
-                        region.guest_addr.offset(),
-                        region.shm.as_raw_descriptor().try_into().unwrap(),
-                        region.size.try_into().unwrap(),
-                        region.shm_offset,
+                    &vm_descriptor,
+                    region.index as MemSlot,
+                    lend,
+                    !file_backed.writable,
+                    region.guest_addr.offset(),
+                    region.shm.as_raw_descriptor().try_into().unwrap(),
+                    region.size.try_into().unwrap(),
+                    region.shm_offset,
                 )?;
             } else if lend {
                 // SAFETY:
@@ -315,11 +316,16 @@ impl GunyahVm {
         })
     }
 
-    pub fn set_vm_auth_type_to_qcom_trusted_vm(&self, payload_start: GuestAddress, payload_size: u64) -> Result<()> {
+    pub fn set_vm_auth_type_to_qcom_trusted_vm(
+        &self,
+        payload_start: GuestAddress,
+        payload_size: u64,
+    ) -> Result<()> {
         let gunyah_qtvm_auth_arg = gunyah_qtvm_auth_arg {
             vm_id: self.vm_id.expect("VM ID not specified for a QTVM"),
             pas_id: self.pas_id.expect("PAS ID not specified for a QTVM"),
-            // QTVMs have the metadata needed for authentication at the start of the guest addrspace.
+            // QTVMs have the metadata needed for authentication at the start of the guest
+            // addrspace.
             guest_phys_addr: payload_start.offset(),
             size: payload_size,
         };
@@ -569,6 +575,7 @@ impl Vm for GunyahVm {
 
     fn check_capability(&self, c: VmCap) -> bool {
         match c {
+            VmCap::ArmPmuV3 => false,
             VmCap::DirtyLog => false,
             // Strictly speaking, Gunyah supports pvclock, but Gunyah takes care
             // of it and crosvm doesn't need to do anything for it
@@ -818,7 +825,7 @@ impl Vm for GunyahVm {
     fn handle_balloon_event(&mut self, event: BalloonEvent) -> Result<()> {
         match event {
             BalloonEvent::Inflate(m) => self.handle_inflate(m.guest_address, m.size),
-            BalloonEvent::Deflate(m) => Ok(()),
+            BalloonEvent::Deflate(_) => Ok(()),
             BalloonEvent::BalloonTargetReached(_) => Ok(()),
         }
     }
diff --git a/hypervisor/src/kvm/aarch64.rs b/hypervisor/src/kvm/aarch64.rs
index 097b3f2dc..a4fd06232 100644
--- a/hypervisor/src/kvm/aarch64.rs
+++ b/hypervisor/src/kvm/aarch64.rs
@@ -10,6 +10,7 @@ use std::collections::BTreeMap;
 use std::convert::TryFrom;
 use std::mem::offset_of;
 
+use aarch64_sys_reg::AArch64SysRegId;
 use anyhow::Context;
 use base::errno_result;
 use base::error;
@@ -36,7 +37,6 @@ use super::Kvm;
 use super::KvmCap;
 use super::KvmVcpu;
 use super::KvmVm;
-use crate::AArch64SysRegId;
 use crate::ClockState;
 use crate::DeviceKind;
 use crate::Hypervisor;
@@ -97,6 +97,10 @@ impl KvmVm {
             // Safe because it does not take pointer arguments.
             unsafe { self.enable_raw_capability(KvmCap::ArmMte, 0, &[0, 0, 0, 0])? }
         }
+        #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+        if cfg.ffa {
+            self.set_enable_ffa(true)?;
+        }
         #[cfg(not(target_arch = "aarch64"))]
         {
             // Suppress warning.
@@ -106,11 +110,6 @@ impl KvmVm {
         Ok(())
     }
 
-    /// Whether running under pKVM.
-    pub fn is_pkvm(&self) -> bool {
-        self.get_protected_vm_info().is_ok()
-    }
-
     /// Checks if a particular `VmCap` is available, or returns None if arch-independent
     /// Vm.check_capability() should handle the check.
     pub fn check_capability_arch(&self, _c: VmCap) -> Option<bool> {
@@ -180,6 +179,19 @@ impl KvmVm {
             )
         }
     }
+
+    #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+    fn set_enable_ffa(&self, ffa_support: bool) -> Result<()> {
+        // SAFETY:
+        // Safe because none of the args are pointers.
+        unsafe {
+            self.enable_raw_capability(
+                KvmCap::ArmProtectedVm,
+                KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FFA,
+                &[ffa_support.into(), 0, 0, 0],
+            )
+        }
+    }
 }
 
 #[repr(C)]
@@ -224,7 +236,7 @@ impl VmAArch64 for KvmVm {
         _payload_entry_address: GuestAddress,
         _fdt_address: GuestAddress,
         _fdt_size: usize,
-    ) -> Result<()> {
+    ) -> anyhow::Result<()> {
         Ok(())
     }
 
@@ -268,9 +280,9 @@ impl KvmVcpu {
             VcpuRegAArch64::Pc => Ok(KvmVcpuRegister::Pc),
             VcpuRegAArch64::Pstate => Ok(KvmVcpuRegister::Pstate),
             // Special case for multiplexed KVM registers
-            VcpuRegAArch64::System(AArch64SysRegId::CCSIDR_EL1) => {
+            VcpuRegAArch64::System(aarch64_sys_reg::CCSIDR_EL1) => {
                 let csselr =
-                    self.get_one_reg(VcpuRegAArch64::System(AArch64SysRegId::CSSELR_EL1))?;
+                    self.get_one_reg(VcpuRegAArch64::System(aarch64_sys_reg::CSSELR_EL1))?;
                 Ok(KvmVcpuRegister::Ccsidr(csselr as u8))
             }
             VcpuRegAArch64::System(sysreg) => Ok(KvmVcpuRegister::System(sysreg)),
@@ -549,31 +561,31 @@ impl From<KvmVcpuRegister> for u64 {
                 user_fpsimd_state_reg(KVM_REG_SIZE_U128, offset_of!(user_fpsimd_state, vregs) + n)
             }
             KvmVcpuRegister::V(n) => unreachable!("invalid KvmVcpuRegister Vn index: {n}"),
-            KvmVcpuRegister::System(AArch64SysRegId::FPSR) => {
+            KvmVcpuRegister::System(aarch64_sys_reg::FPSR) => {
                 user_fpsimd_state_reg(KVM_REG_SIZE_U32, offset_of!(user_fpsimd_state, fpsr))
             }
-            KvmVcpuRegister::System(AArch64SysRegId::FPCR) => {
+            KvmVcpuRegister::System(aarch64_sys_reg::FPCR) => {
                 user_fpsimd_state_reg(KVM_REG_SIZE_U32, offset_of!(user_fpsimd_state, fpcr))
             }
-            KvmVcpuRegister::System(AArch64SysRegId::SPSR_EL1) => spsr_reg(KVM_SPSR_EL1),
-            KvmVcpuRegister::System(AArch64SysRegId::SPSR_abt) => spsr_reg(KVM_SPSR_ABT),
-            KvmVcpuRegister::System(AArch64SysRegId::SPSR_und) => spsr_reg(KVM_SPSR_UND),
-            KvmVcpuRegister::System(AArch64SysRegId::SPSR_irq) => spsr_reg(KVM_SPSR_IRQ),
-            KvmVcpuRegister::System(AArch64SysRegId::SPSR_fiq) => spsr_reg(KVM_SPSR_FIQ),
-            KvmVcpuRegister::System(AArch64SysRegId::SP_EL1) => {
+            KvmVcpuRegister::System(aarch64_sys_reg::SPSR_EL1) => spsr_reg(KVM_SPSR_EL1),
+            KvmVcpuRegister::System(aarch64_sys_reg::SPSR_abt) => spsr_reg(KVM_SPSR_ABT),
+            KvmVcpuRegister::System(aarch64_sys_reg::SPSR_und) => spsr_reg(KVM_SPSR_UND),
+            KvmVcpuRegister::System(aarch64_sys_reg::SPSR_irq) => spsr_reg(KVM_SPSR_IRQ),
+            KvmVcpuRegister::System(aarch64_sys_reg::SPSR_fiq) => spsr_reg(KVM_SPSR_FIQ),
+            KvmVcpuRegister::System(aarch64_sys_reg::SP_EL1) => {
                 kvm_reg(offset_of!(kvm_regs, sp_el1))
             }
-            KvmVcpuRegister::System(AArch64SysRegId::ELR_EL1) => {
+            KvmVcpuRegister::System(aarch64_sys_reg::ELR_EL1) => {
                 kvm_reg(offset_of!(kvm_regs, elr_el1))
             }
             // The KVM API accidentally swapped CNTV_CVAL_EL0 and CNTVCT_EL0.
-            KvmVcpuRegister::System(AArch64SysRegId::CNTV_CVAL_EL0) => reg_u64(
+            KvmVcpuRegister::System(aarch64_sys_reg::CNTV_CVAL_EL0) => reg_u64(
                 KVM_REG_ARM64_SYSREG.into(),
-                AArch64SysRegId::CNTVCT_EL0.encoded().into(),
+                aarch64_sys_reg::CNTVCT_EL0.encoded().into(),
             ),
-            KvmVcpuRegister::System(AArch64SysRegId::CNTVCT_EL0) => reg_u64(
+            KvmVcpuRegister::System(aarch64_sys_reg::CNTVCT_EL0) => reg_u64(
                 KVM_REG_ARM64_SYSREG.into(),
-                AArch64SysRegId::CNTV_CVAL_EL0.encoded().into(),
+                aarch64_sys_reg::CNTV_CVAL_EL0.encoded().into(),
             ),
             KvmVcpuRegister::System(sysreg) => {
                 reg_u64(KVM_REG_ARM64_SYSREG.into(), sysreg.encoded().into())
@@ -728,7 +740,7 @@ impl VcpuAArch64 for KvmVcpu {
     }
 
     fn get_mpidr(&self) -> Result<u64> {
-        self.get_one_reg(VcpuRegAArch64::System(AArch64SysRegId::MPIDR_EL1))
+        self.get_one_reg(VcpuRegAArch64::System(aarch64_sys_reg::MPIDR_EL1))
     }
 
     fn get_psci_version(&self) -> Result<PsciVersion> {
@@ -769,15 +781,15 @@ impl VcpuAArch64 for KvmVcpu {
 
     fn get_system_regs(&self) -> Result<BTreeMap<AArch64SysRegId, u64>> {
         let reg_list = self.get_reg_list()?;
-        let cntvct_el0: u16 = AArch64SysRegId::CNTVCT_EL0.encoded();
-        let cntv_cval_el0: u16 = AArch64SysRegId::CNTV_CVAL_EL0.encoded();
+        let cntvct_el0: u16 = aarch64_sys_reg::CNTVCT_EL0.encoded();
+        let cntv_cval_el0: u16 = aarch64_sys_reg::CNTV_CVAL_EL0.encoded();
         let mut sys_regs = BTreeMap::new();
         for reg in reg_list {
             if (reg as u32) & KVM_REG_ARM_COPROC_MASK == KVM_REG_ARM64_SYSREG {
                 let r = if reg as u16 == cntvct_el0 {
-                    AArch64SysRegId::CNTV_CVAL_EL0
+                    aarch64_sys_reg::CNTV_CVAL_EL0
                 } else if reg as u16 == cntv_cval_el0 {
-                    AArch64SysRegId::CNTVCT_EL0
+                    aarch64_sys_reg::CNTVCT_EL0
                 } else {
                     AArch64SysRegId::from_encoded((reg & 0xFFFF) as u16)
                 };
@@ -789,6 +801,25 @@ impl VcpuAArch64 for KvmVcpu {
                 );
             }
         }
+
+        // The list of system registers below do not follow the convention of system registers
+        // for bits 31-16.
+        // System registers bits 31-16 == 0x0013, but not for those registers. Add them
+        // explicitly
+        let extra_sys_regs = [
+            aarch64_sys_reg::ELR_EL1,
+            aarch64_sys_reg::FPCR,
+            aarch64_sys_reg::FPSR,
+            aarch64_sys_reg::SP_EL1,
+            aarch64_sys_reg::SPSR_EL1,
+            aarch64_sys_reg::SPSR_abt,
+            aarch64_sys_reg::SPSR_und,
+            aarch64_sys_reg::SPSR_irq,
+            aarch64_sys_reg::SPSR_fiq,
+        ];
+        for reg in extra_sys_regs {
+            sys_regs.insert(reg, self.get_one_reg(VcpuRegAArch64::System(reg))?);
+        }
         Ok(sys_regs)
     }
 
@@ -927,11 +958,11 @@ mod tests {
         // values.
 
         const KVM_REG_ARM_TIMER_CVAL: u64 = 0x6030_0000_0013_DF02;
-        let cntv_cval_el0_kvm = KvmVcpuRegister::System(AArch64SysRegId::CNTV_CVAL_EL0);
+        let cntv_cval_el0_kvm = KvmVcpuRegister::System(aarch64_sys_reg::CNTV_CVAL_EL0);
         assert_eq!(u64::from(cntv_cval_el0_kvm), KVM_REG_ARM_TIMER_CVAL);
 
         const KVM_REG_ARM_TIMER_CNT: u64 = 0x6030_0000_0013_DF1A;
-        let cntvct_el0_kvm = KvmVcpuRegister::System(AArch64SysRegId::CNTVCT_EL0);
+        let cntvct_el0_kvm = KvmVcpuRegister::System(aarch64_sys_reg::CNTVCT_EL0);
         assert_eq!(u64::from(cntvct_el0_kvm), KVM_REG_ARM_TIMER_CNT);
     }
 }
diff --git a/hypervisor/src/kvm/cap.rs b/hypervisor/src/kvm/cap.rs
index 10cfa4502..35f2251a2 100644
--- a/hypervisor/src/kvm/cap.rs
+++ b/hypervisor/src/kvm/cap.rs
@@ -118,7 +118,6 @@ pub enum KvmCap {
     PpcFixupHcall = KVM_CAP_PPC_FIXUP_HCALL,
     PpcEnableHcall = KVM_CAP_PPC_ENABLE_HCALL,
     CheckExtensionVm = KVM_CAP_CHECK_EXTENSION_VM,
-    S390UserSigp = KVM_CAP_S390_USER_SIGP,
     ImmediateExit = KVM_CAP_IMMEDIATE_EXIT,
     ArmPmuV3 = KVM_CAP_ARM_PMU_V3,
     ArmProtectedVm = KVM_CAP_ARM_PROTECTED_VM,
diff --git a/hypervisor/src/kvm/mod.rs b/hypervisor/src/kvm/mod.rs
index 90ab6822b..712f49bb0 100644
--- a/hypervisor/src/kvm/mod.rs
+++ b/hypervisor/src/kvm/mod.rs
@@ -118,13 +118,14 @@ unsafe fn set_user_memory_region(
         use_2_variant = kvm.caps.user_memory_region2;
     }
 
+    let untagged_userspace_addr = untagged_addr(userspace_addr as usize);
     let ret = if use_2_variant {
         let region2 = kvm_userspace_memory_region2 {
             slot,
             flags,
             guest_phys_addr: guest_addr,
             memory_size,
-            userspace_addr: userspace_addr as u64,
+            userspace_addr: untagged_userspace_addr as u64,
             guest_memfd_offset: 0,
             guest_memfd: 0,
             ..Default::default()
@@ -136,7 +137,7 @@ unsafe fn set_user_memory_region(
             flags,
             guest_phys_addr: guest_addr,
             memory_size,
-            userspace_addr: userspace_addr as u64,
+            userspace_addr: (untagged_userspace_addr as u64),
         };
         ioctl_with_ref(&kvm.vm, KVM_SET_USER_MEMORY_REGION, &region)
     };
@@ -148,6 +149,19 @@ unsafe fn set_user_memory_region(
     }
 }
 
+// https://github.com/torvalds/linux/blob/master/Documentation/virt/kvm/api.rst
+// On architectures that support a form of address tagging, userspace_addr must be an untagged
+// address.
+#[inline]
+fn untagged_addr(addr: usize) -> usize {
+    let tag_bits_mask: u64 = if cfg!(target_arch = "aarch64") {
+        0xFF00000000000000
+    } else {
+        0
+    };
+    addr & !tag_bits_mask as usize
+}
+
 /// Helper function to determine the size in bytes of a dirty log bitmap for the given memory region
 /// size.
 ///
@@ -563,7 +577,13 @@ impl KvmVm {
     }
 
     fn handle_inflate(&mut self, guest_address: GuestAddress, size: u64) -> Result<()> {
-        match self.guest_mem.remove_range(guest_address, size) {
+        match if self.guest_mem.use_dontneed_locked() {
+            // TODO - b/413829005: upstream punch_hole_range as a new cmdline option.
+            self.guest_mem.punch_hole_range(guest_address, size)
+            // self.guest_mem.dontneed_locked_range(guest_address, size)
+        } else {
+            self.guest_mem.remove_range(guest_address, size)
+        } {
             Ok(_) => Ok(()),
             Err(vm_memory::Error::MemoryAccess(_, MmapError::SystemCallFailed(e))) => Err(e),
             Err(_) => Err(Error::new(EIO)),
@@ -601,15 +621,15 @@ impl Vm for KvmVm {
             return val;
         }
         match c {
+            #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
+            VmCap::ArmPmuV3 => self.check_raw_capability(KvmCap::ArmPmuV3),
             VmCap::DirtyLog => true,
             VmCap::PvClock => false,
             VmCap::Protected => self.check_raw_capability(KvmCap::ArmProtectedVm),
             VmCap::EarlyInitCpuid => false,
             #[cfg(target_arch = "x86_64")]
             VmCap::BusLockDetect => self.check_raw_capability(KvmCap::BusLockDetect),
-            // When pKVM is the hypervisor, read-only memslots aren't supported, even for
-            // non-protected VMs.
-            VmCap::ReadOnlyMemoryRegion => !self.is_pkvm(),
+            VmCap::ReadOnlyMemoryRegion => self.check_raw_capability(KvmCap::ReadonlyMem),
             VmCap::MemNoncoherentDma => {
                 cfg!(feature = "noncoherent-dma")
                     && self.check_raw_capability(KvmCap::MemNoncoherentDma)
@@ -1205,10 +1225,7 @@ impl TryFrom<HypervisorCap> for KvmCap {
 
     fn try_from(cap: HypervisorCap) -> Result<KvmCap> {
         match cap {
-            HypervisorCap::ArmPmuV3 => Ok(KvmCap::ArmPmuV3),
             HypervisorCap::ImmediateExit => Ok(KvmCap::ImmediateExit),
-            HypervisorCap::S390UserSigp => Ok(KvmCap::S390UserSigp),
-            HypervisorCap::TscDeadlineTimer => Ok(KvmCap::TscDeadlineTimer),
             HypervisorCap::UserMemory => Ok(KvmCap::UserMemory),
             #[cfg(target_arch = "x86_64")]
             HypervisorCap::Xcrs => Ok(KvmCap::Xcrs),
diff --git a/hypervisor/src/kvm/riscv64.rs b/hypervisor/src/kvm/riscv64.rs
index a830912d9..22ce80de9 100644
--- a/hypervisor/src/kvm/riscv64.rs
+++ b/hypervisor/src/kvm/riscv64.rs
@@ -4,7 +4,6 @@
 
 use base::errno_result;
 use base::error;
-use base::ioctl_with_mut_ref;
 use base::ioctl_with_ref;
 use base::Error;
 use base::Result;
@@ -32,11 +31,6 @@ impl KvmVm {
         Ok(())
     }
 
-    /// Whether running under pKVM.
-    pub fn is_pkvm(&self) -> bool {
-        false
-    }
-
     /// Checks if a particular `VmCap` is available, or returns None if arch-independent
     /// Vm.check_capability() should handle the check.
     pub fn check_capability_arch(&self, _c: VmCap) -> Option<bool> {
@@ -113,7 +107,9 @@ impl KvmVcpu {
             KVM_EXIT_RISCV_SBI => {
                 // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let extension_id = unsafe { run.__bindgen_anon_1.riscv_sbi.extension_id };
+                // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let function_id = unsafe { run.__bindgen_anon_1.riscv_sbi.function_id };
+                // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let args = unsafe { run.__bindgen_anon_1.riscv_sbi.args };
                 Some(VcpuExit::Sbi {
                     extension_id,
@@ -124,8 +120,11 @@ impl KvmVcpu {
             KVM_EXIT_RISCV_CSR => {
                 // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let csr_num = unsafe { run.__bindgen_anon_1.riscv_csr.csr_num };
+                // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let new_value = unsafe { run.__bindgen_anon_1.riscv_csr.new_value };
+                // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let write_mask = unsafe { run.__bindgen_anon_1.riscv_csr.write_mask };
+                // SAFETY: Safe because we trust the kernel to correctly fill in the union
                 let ret_value = unsafe { run.__bindgen_anon_1.riscv_csr.ret_value };
                 Some(VcpuExit::RiscvCsr {
                     csr_num,
@@ -146,8 +145,8 @@ impl VcpuRiscv64 for KvmVcpu {
             id: vcpu_reg_id(reg),
             addr: data_ref as u64,
         };
-        // Safe because we allocated the struct and we know the kernel will read exactly the size of
-        // the struct.
+        // SAFETY: Safe because we allocated the struct and we know the kernel will read exactly the
+        // size of the struct.
         let ret = unsafe { ioctl_with_ref(self, KVM_SET_ONE_REG, &onereg) };
         if ret == 0 {
             Ok(())
@@ -163,8 +162,8 @@ impl VcpuRiscv64 for KvmVcpu {
             addr: (&mut val as *mut u64) as u64,
         };
 
-        // Safe because we allocated the struct and we know the kernel will read exactly the size of
-        // the struct.
+        // SAFETY: Safe because we allocated the struct and we know the kernel will read exactly the
+        // size of the struct.
         let ret = unsafe { ioctl_with_ref(self, KVM_GET_ONE_REG, &onereg) };
         if ret == 0 {
             Ok(val)
diff --git a/hypervisor/src/kvm/x86_64.rs b/hypervisor/src/kvm/x86_64.rs
index e29f058a9..34287ad47 100644
--- a/hypervisor/src/kvm/x86_64.rs
+++ b/hypervisor/src/kvm/x86_64.rs
@@ -219,11 +219,6 @@ impl KvmVm {
         Ok(())
     }
 
-    /// Whether running under pKVM.
-    pub fn is_pkvm(&self) -> bool {
-        false
-    }
-
     /// Checks if a particular `VmCap` is available, or returns None if arch-independent
     /// Vm.check_capability() should handle the check.
     pub fn check_capability_arch(&self, c: VmCap) -> Option<bool> {
diff --git a/hypervisor/src/lib.rs b/hypervisor/src/lib.rs
index fa508928a..8125bcccb 100644
--- a/hypervisor/src/lib.rs
+++ b/hypervisor/src/lib.rs
@@ -629,6 +629,8 @@ pub struct Config {
     /// enable the Memory Tagging Extension in the guest
     pub mte: bool,
     pub protection_type: ProtectionType,
+    #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+    pub ffa: bool,
 }
 
 impl Default for Config {
@@ -637,6 +639,8 @@ impl Default for Config {
             #[cfg(target_arch = "aarch64")]
             mte: false,
             protection_type: ProtectionType::Unprotected,
+            #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+            ffa: false,
         }
     }
 }
diff --git a/hypervisor/src/whpx.rs b/hypervisor/src/whpx.rs
index 3343442ef..85d9fa6fb 100644
--- a/hypervisor/src/whpx.rs
+++ b/hypervisor/src/whpx.rs
@@ -6,12 +6,12 @@
 
 use core::ffi::c_void;
 use std::arch::x86_64::__cpuid_count;
+use std::sync::LazyLock;
 
 use base::error;
 use base::warn;
 use base::Error;
 use base::Result;
-use once_cell::sync::Lazy;
 use thiserror::Error as ThisError;
 use winapi::shared::winerror::S_OK;
 
@@ -154,9 +154,9 @@ impl Whpx {
     }
 
     pub fn check_whpx_feature(feature: WhpxFeature) -> WhpxResult<bool> {
-        // use Lazy to cache the results of the get_capability call
-        static FEATURES: Lazy<WhpxResult<WHV_CAPABILITY>> =
-            Lazy::new(|| Whpx::get_capability(WHV_CAPABILITY_CODE_WHvCapabilityCodeFeatures));
+        // use LazyLock to cache the results of the get_capability call
+        static FEATURES: LazyLock<WhpxResult<WHV_CAPABILITY>> =
+            LazyLock::new(|| Whpx::get_capability(WHV_CAPABILITY_CODE_WHvCapabilityCodeFeatures));
 
         Ok((unsafe { (*FEATURES)?.Features.AsUINT64 } & feature as u64) != 0)
     }
@@ -256,6 +256,5 @@ mod tests {
         assert!(whpx.check_capability(HypervisorCap::UserMemory));
         assert!(whpx.check_capability(HypervisorCap::Xcrs));
         assert!(whpx.check_capability(HypervisorCap::ImmediateExit));
-        assert!(!whpx.check_capability(HypervisorCap::S390UserSigp));
     }
 }
diff --git a/hypervisor/src/whpx/types.rs b/hypervisor/src/whpx/types.rs
index 3826a7fcf..97becb199 100644
--- a/hypervisor/src/whpx/types.rs
+++ b/hypervisor/src/whpx/types.rs
@@ -3,8 +3,8 @@
 // found in the LICENSE file.
 
 use std::collections::HashMap;
+use std::sync::LazyLock;
 
-use once_cell::sync::Lazy;
 use serde::Deserialize;
 use serde::Serialize;
 
@@ -729,7 +729,7 @@ pub(super) const MSR_PRED_CMD: u32 = 0x00000049;
 // the valid msrs for whpx, converting from the x86 efer id's to the whpx register name value.
 // https://docs.microsoft.com/en-us/virtualization/api/hypervisor-platform/funcs/whvvirtualprocessordatatypes
 #[rustfmt::skip]
-pub(super) static VALID_MSRS: Lazy<HashMap<u32, WHV_REGISTER_NAME>> = Lazy::new(|| {
+pub(super) static VALID_MSRS: LazyLock<HashMap<u32, WHV_REGISTER_NAME>> = LazyLock::new(|| {
     [
         (MSR_TSC,WHV_REGISTER_NAME_WHvX64RegisterTsc),
         (MSR_EFER,WHV_REGISTER_NAME_WHvX64RegisterEfer),
diff --git a/hypervisor/tests/kvm/main.rs b/hypervisor/tests/kvm/main.rs
index 8f2a76ab2..478d8da50 100644
--- a/hypervisor/tests/kvm/main.rs
+++ b/hypervisor/tests/kvm/main.rs
@@ -57,7 +57,7 @@ fn new() {
 fn check_capability() {
     let kvm = Kvm::new().unwrap();
     assert!(kvm.check_capability(HypervisorCap::UserMemory));
-    assert!(!kvm.check_capability(HypervisorCap::S390UserSigp));
+    assert!(!kvm.check_capability(HypervisorCap::HypervisorInitializedBootContext));
 }
 
 #[test]
@@ -93,8 +93,7 @@ fn check_vm_capability() {
     let gm = GuestMemory::new(&[(GuestAddress(0), pagesize() as u64)]).unwrap();
     let vm = KvmVm::new(&kvm, gm, Default::default()).unwrap();
     assert!(vm.check_raw_capability(KvmCap::UserMemory));
-    // I assume nobody is testing this on s390
-    assert!(!vm.check_raw_capability(KvmCap::S390UserSigp));
+    assert!(!vm.check_raw_capability(KvmCap::S390Psw))
 }
 
 #[test]
diff --git a/infra/README.recipes.md b/infra/README.recipes.md
index 5bff05b36..86ac99223 100644
--- a/infra/README.recipes.md
+++ b/infra/README.recipes.md
@@ -19,6 +19,7 @@
   * [presubmit](#recipes-presubmit)
   * [push_to_github](#recipes-push_to_github)
   * [update_chromeos_merges](#recipes-update_chromeos_merges)
+  * [uprev_baguette_image](#recipes-uprev_baguette_image) &mdash; Recipe for uploading uprevs of the baguette image.
 ## Recipe Modules
 
 ### *recipe_modules* / [crosvm](/infra/recipe_modules/crosvm)
@@ -189,21 +190,29 @@ This recipe requires ambient luci authentication. To test locally run:
 
 
 &mdash; **def [RunSteps](/infra/recipes/update_chromeos_merges.py#14)(api):**
-
-[depot_tools/recipe_modules/bot_update]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/f40ddcd8d51626fb7be3ab3c418b3f3be801623f/recipes/README.recipes.md#recipe_modules-bot_update
-[depot_tools/recipe_modules/depot_tools]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/f40ddcd8d51626fb7be3ab3c418b3f3be801623f/recipes/README.recipes.md#recipe_modules-depot_tools
-[depot_tools/recipe_modules/gclient]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/f40ddcd8d51626fb7be3ab3c418b3f3be801623f/recipes/README.recipes.md#recipe_modules-gclient
-[depot_tools/recipe_modules/git]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/f40ddcd8d51626fb7be3ab3c418b3f3be801623f/recipes/README.recipes.md#recipe_modules-git
-[depot_tools/recipe_modules/gsutil]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/f40ddcd8d51626fb7be3ab3c418b3f3be801623f/recipes/README.recipes.md#recipe_modules-gsutil
-[recipe_engine/recipe_modules/buildbucket]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-buildbucket
-[recipe_engine/recipe_modules/cipd]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-cipd
-[recipe_engine/recipe_modules/context]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-context
-[recipe_engine/recipe_modules/file]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-file
-[recipe_engine/recipe_modules/json]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-json
-[recipe_engine/recipe_modules/path]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-path
-[recipe_engine/recipe_modules/platform]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-platform
-[recipe_engine/recipe_modules/properties]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-properties
-[recipe_engine/recipe_modules/raw_io]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-raw_io
-[recipe_engine/recipe_modules/step]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-step
-[recipe_engine/recipe_modules/time]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/README.recipes.md#recipe_modules-time
-[recipe_engine/wkt/RecipeApi]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/b67985a8c735f0c61e1757be3cefd43b5d629696/recipe_engine/recipe_api.py#433
+### *recipes* / [uprev\_baguette\_image](/infra/recipes/uprev_baguette_image.py)
+
+[DEPS](/infra/recipes/uprev_baguette_image.py#21): [depot\_tools/git][depot_tools/recipe_modules/git], [recipe\_engine/buildbucket][recipe_engine/recipe_modules/buildbucket], [recipe\_engine/context][recipe_engine/recipe_modules/context], [recipe\_engine/path][recipe_engine/recipe_modules/path], [recipe\_engine/properties][recipe_engine/recipe_modules/properties], [recipe\_engine/step][recipe_engine/recipe_modules/step]
+
+
+Recipe for uploading uprevs of the baguette image.
+
+&mdash; **def [RunSteps](/infra/recipes/uprev_baguette_image.py#37)(api: RecipeApi, properties: UprevBaguetteImageProperties):**
+
+[depot_tools/recipe_modules/bot_update]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/68f0a29a64d354aefcdb1f9eb2a636b21fe96d91/recipes/README.recipes.md#recipe_modules-bot_update
+[depot_tools/recipe_modules/depot_tools]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/68f0a29a64d354aefcdb1f9eb2a636b21fe96d91/recipes/README.recipes.md#recipe_modules-depot_tools
+[depot_tools/recipe_modules/gclient]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/68f0a29a64d354aefcdb1f9eb2a636b21fe96d91/recipes/README.recipes.md#recipe_modules-gclient
+[depot_tools/recipe_modules/git]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/68f0a29a64d354aefcdb1f9eb2a636b21fe96d91/recipes/README.recipes.md#recipe_modules-git
+[depot_tools/recipe_modules/gsutil]: https://chromium.googlesource.com/chromium/tools/depot_tools.git/+/68f0a29a64d354aefcdb1f9eb2a636b21fe96d91/recipes/README.recipes.md#recipe_modules-gsutil
+[recipe_engine/recipe_modules/buildbucket]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-buildbucket
+[recipe_engine/recipe_modules/cipd]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-cipd
+[recipe_engine/recipe_modules/context]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-context
+[recipe_engine/recipe_modules/file]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-file
+[recipe_engine/recipe_modules/json]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-json
+[recipe_engine/recipe_modules/path]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-path
+[recipe_engine/recipe_modules/platform]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-platform
+[recipe_engine/recipe_modules/properties]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-properties
+[recipe_engine/recipe_modules/raw_io]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-raw_io
+[recipe_engine/recipe_modules/step]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-step
+[recipe_engine/recipe_modules/time]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/README.recipes.md#recipe_modules-time
+[recipe_engine/wkt/RecipeApi]: https://chromium.googlesource.com/infra/luci/recipes-py.git/+/e84c69f5be0b72ea7957140f6105a89cb0706dce/recipe_engine/recipe_api.py#433
diff --git a/infra/config/generated/commit-queue.cfg b/infra/config/generated/commit-queue.cfg
index 9f5a89f8f..700412065 100644
--- a/infra/config/generated/commit-queue.cfg
+++ b/infra/config/generated/commit-queue.cfg
@@ -33,10 +33,10 @@ config_groups {
         name: "crosvm/try/linux_mingw64"
       }
       builders {
-        name: "crosvm/try/linux_x86_64"
+        name: "crosvm/try/linux_riscv64"
       }
       builders {
-        name: "crosvm/try/windows"
+        name: "crosvm/try/linux_x86_64"
       }
       retry_config {
         single_quota: 1
diff --git a/infra/config/generated/cr-buildbucket.cfg b/infra/config/generated/cr-buildbucket.cfg
index 9dccde2d9..4b3d46161 100644
--- a/infra/config/generated/cr-buildbucket.cfg
+++ b/infra/config/generated/cr-buildbucket.cfg
@@ -45,6 +45,21 @@ buckets {
       }
       service_account: "crosvm-luci-ci-builder@crosvm-infra.iam.gserviceaccount.com"
     }
+    builders {
+      name: "baguette_uprev"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cpu:x86-64"
+      dimensions: "os:Ubuntu"
+      dimensions: "pool:luci.crosvm.ci"
+      recipe {
+        name: "uprev_baguette_image"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
+        cipd_version: "refs/heads/main"
+        properties_j: "bot:true"
+        properties_j: "push:true"
+      }
+      service_account: "crosvm-luci-ci-builder@crosvm-infra.iam.gserviceaccount.com"
+    }
     builders {
       name: "build_docs"
       swarming_host: "chromium-swarm.appspot.com"
@@ -147,7 +162,7 @@ buckets {
       service_account: "crosvm-luci-ci-builder@crosvm-infra.iam.gserviceaccount.com"
     }
     builders {
-      name: "linux_x86_64"
+      name: "linux_riscv64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cpu:x86-64"
       dimensions: "os:Ubuntu"
@@ -157,7 +172,7 @@ buckets {
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
         cipd_version: "refs/heads/main"
         properties_j: "profile:\"postsubmit\""
-        properties_j: "test_arch:\"x86_64\""
+        properties_j: "test_arch:\"riscv64\""
       }
       caches {
         name: "linux_builder_cache"
@@ -166,39 +181,45 @@ buckets {
       service_account: "crosvm-luci-ci-builder@crosvm-infra.iam.gserviceaccount.com"
     }
     builders {
-      name: "push_to_github"
+      name: "linux_x86_64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cpu:x86-64"
       dimensions: "os:Ubuntu"
       dimensions: "pool:luci.crosvm.ci"
       recipe {
-        name: "push_to_github"
+        name: "build_linux"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
         cipd_version: "refs/heads/main"
+        properties_j: "profile:\"postsubmit\""
+        properties_j: "test_arch:\"x86_64\""
+      }
+      caches {
+        name: "linux_builder_cache"
+        path: "builder"
       }
       service_account: "crosvm-luci-ci-builder@crosvm-infra.iam.gserviceaccount.com"
     }
     builders {
-      name: "update_chromeos_merges"
+      name: "push_to_github"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cpu:x86-64"
       dimensions: "os:Ubuntu"
       dimensions: "pool:luci.crosvm.ci"
       recipe {
-        name: "update_chromeos_merges"
+        name: "push_to_github"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
         cipd_version: "refs/heads/main"
       }
       service_account: "crosvm-luci-ci-builder@crosvm-infra.iam.gserviceaccount.com"
     }
     builders {
-      name: "windows"
+      name: "update_chromeos_merges"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cpu:x86-64"
-      dimensions: "os:Windows"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.crosvm.ci"
       recipe {
-        name: "build_windows"
+        name: "update_chromeos_merges"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
         cipd_version: "refs/heads/main"
       }
@@ -294,7 +315,7 @@ buckets {
       service_account: "crosvm-luci-try-builder@crosvm-infra.iam.gserviceaccount.com"
     }
     builders {
-      name: "linux_x86_64"
+      name: "linux_riscv64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cpu:x86-64"
       dimensions: "os:Ubuntu"
@@ -304,7 +325,7 @@ buckets {
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
         cipd_version: "refs/heads/main"
         properties_j: "profile:\"presubmit\""
-        properties_j: "test_arch:\"x86_64\""
+        properties_j: "test_arch:\"riscv64\""
       }
       caches {
         name: "linux_builder_cache"
@@ -313,15 +334,21 @@ buckets {
       service_account: "crosvm-luci-try-builder@crosvm-infra.iam.gserviceaccount.com"
     }
     builders {
-      name: "windows"
+      name: "linux_x86_64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cpu:x86-64"
-      dimensions: "os:Windows"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.crosvm.try"
       recipe {
-        name: "build_windows"
+        name: "build_linux"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/crosvm/crosvm"
         cipd_version: "refs/heads/main"
+        properties_j: "profile:\"presubmit\""
+        properties_j: "test_arch:\"x86_64\""
+      }
+      caches {
+        name: "linux_builder_cache"
+        path: "builder"
       }
       service_account: "crosvm-luci-try-builder@crosvm-infra.iam.gserviceaccount.com"
     }
diff --git a/infra/config/generated/luci-milo.cfg b/infra/config/generated/luci-milo.cfg
index e50cfdb19..c1d4442b8 100644
--- a/infra/config/generated/luci-milo.cfg
+++ b/infra/config/generated/luci-milo.cfg
@@ -27,12 +27,12 @@ consoles {
     category: "linux"
   }
   builders {
-    name: "buildbucket/luci.crosvm.ci/chromeos_hatch"
+    name: "buildbucket/luci.crosvm.ci/linux_riscv64"
     category: "linux"
   }
   builders {
-    name: "buildbucket/luci.crosvm.ci/windows"
-    category: "windows"
+    name: "buildbucket/luci.crosvm.ci/chromeos_hatch"
+    category: "linux"
   }
   builders {
     name: "buildbucket/luci.crosvm.ci/health_check"
@@ -59,7 +59,7 @@ consoles {
     name: "buildbucket/luci.crosvm.try/linux_mingw64"
   }
   builders {
-    name: "buildbucket/luci.crosvm.try/windows"
+    name: "buildbucket/luci.crosvm.try/linux_riscv64"
   }
   builders {
     name: "buildbucket/luci.crosvm.try/health_check"
@@ -81,5 +81,8 @@ consoles {
   builders {
     name: "buildbucket/luci.crosvm.ci/baguette_builder"
   }
+  builders {
+    name: "buildbucket/luci.crosvm.ci/baguette_uprev"
+  }
   builder_view_only: true
 }
diff --git a/infra/config/generated/luci-notify.cfg b/infra/config/generated/luci-notify.cfg
index 3be792ff7..c91f4912e 100644
--- a/infra/config/generated/luci-notify.cfg
+++ b/infra/config/generated/luci-notify.cfg
@@ -10,7 +10,6 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
@@ -23,7 +22,8 @@ notifiers {
   notifications {
     on_change: true
     email {
-      recipients: "denniskempin@google.com"
+      recipients: "crosvm-uprev@grotations.appspotmail.com"
+      recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
       recipients: "keiichiw@google.com"
     }
   }
@@ -36,7 +36,22 @@ notifiers {
   notifications {
     on_change: true
     email {
-      recipients: "denniskempin@google.com"
+      recipients: "crosvm-uprev@grotations.appspotmail.com"
+      recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
+      recipients: "keiichiw@google.com"
+    }
+  }
+  builders {
+    bucket: "ci"
+    name: "baguette_uprev"
+  }
+}
+notifiers {
+  notifications {
+    on_change: true
+    email {
+      recipients: "crosvm-uprev@grotations.appspotmail.com"
+      recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
       recipients: "keiichiw@google.com"
     }
   }
@@ -52,7 +67,6 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
@@ -67,7 +81,6 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
@@ -82,7 +95,6 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
@@ -97,7 +109,6 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
@@ -112,7 +123,6 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
@@ -127,12 +137,11 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
     }
   }
   builders {
     bucket: "ci"
-    name: "linux_x86_64"
+    name: "linux_riscv64"
     repository: "https://chromium.googlesource.com/crosvm/crosvm"
   }
 }
@@ -140,13 +149,13 @@ notifiers {
   notifications {
     on_change: true
     email {
-      recipients: "denniskempin@google.com"
-      recipients: "keiichiw@google.com"
+      recipients: "crosvm-uprev@grotations.appspotmail.com"
+      recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
     }
   }
   builders {
     bucket: "ci"
-    name: "push_to_github"
+    name: "linux_x86_64"
     repository: "https://chromium.googlesource.com/crosvm/crosvm"
   }
 }
@@ -154,13 +163,15 @@ notifiers {
   notifications {
     on_change: true
     email {
-      recipients: "denniskempin@google.com"
+      recipients: "crosvm-uprev@grotations.appspotmail.com"
+      recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
       recipients: "keiichiw@google.com"
     }
   }
   builders {
     bucket: "ci"
-    name: "update_chromeos_merges"
+    name: "push_to_github"
+    repository: "https://chromium.googlesource.com/crosvm/crosvm"
   }
 }
 notifiers {
@@ -169,12 +180,11 @@ notifiers {
     email {
       recipients: "crosvm-uprev@grotations.appspotmail.com"
       recipients: "crosvm-uprev-apac@grotations.appspotmail.com"
-      recipients: "denniskempin@google.com"
+      recipients: "keiichiw@google.com"
     }
   }
   builders {
     bucket: "ci"
-    name: "windows"
-    repository: "https://chromium.googlesource.com/crosvm/crosvm"
+    name: "update_chromeos_merges"
   }
 }
diff --git a/infra/config/generated/luci-scheduler.cfg b/infra/config/generated/luci-scheduler.cfg
index dc986cba7..9c8df5e59 100644
--- a/infra/config/generated/luci-scheduler.cfg
+++ b/infra/config/generated/luci-scheduler.cfg
@@ -17,7 +17,7 @@ job {
 job {
   id: "baguette_builder"
   realm: "ci"
-  schedule: "0,0 0 * * 3"
+  schedule: "0 0 * * *"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
@@ -25,6 +25,17 @@ job {
     builder: "baguette_builder"
   }
 }
+job {
+  id: "baguette_uprev"
+  realm: "ci"
+  schedule: "0 12 * * *"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "baguette_uprev"
+  }
+}
 job {
   id: "build_docs"
   realm: "ci"
@@ -86,44 +97,44 @@ job {
   }
 }
 job {
-  id: "linux_x86_64"
+  id: "linux_riscv64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "linux_x86_64"
+    builder: "linux_riscv64"
   }
 }
 job {
-  id: "push_to_github"
+  id: "linux_x86_64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "push_to_github"
+    builder: "linux_x86_64"
   }
 }
 job {
-  id: "update_chromeos_merges"
+  id: "push_to_github"
   realm: "ci"
-  schedule: "0,30 * * * *"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "update_chromeos_merges"
+    builder: "push_to_github"
   }
 }
 job {
-  id: "windows"
+  id: "update_chromeos_merges"
   realm: "ci"
+  schedule: "0,30 * * * *"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "windows"
+    builder: "update_chromeos_merges"
   }
 }
 trigger {
@@ -137,9 +148,9 @@ trigger {
   triggers: "linux_aarch64"
   triggers: "linux_armhf"
   triggers: "linux_mingw64"
+  triggers: "linux_riscv64"
   triggers: "linux_x86_64"
   triggers: "push_to_github"
-  triggers: "windows"
   gitiles {
     repo: "https://chromium.googlesource.com/crosvm/crosvm"
     refs: "regexp:refs/heads/main"
diff --git a/infra/config/generated/project.cfg b/infra/config/generated/project.cfg
index 347e20ea2..23c26175a 100644
--- a/infra/config/generated/project.cfg
+++ b/infra/config/generated/project.cfg
@@ -7,7 +7,7 @@
 name: "crosvm"
 access: "group:all"
 lucicfg {
-  version: "1.43.16"
+  version: "1.44.1"
   package_dir: ".."
   config_dir: "generated"
   entry_point: "main.star"
diff --git a/infra/config/main.star b/infra/config/main.star
index 1d64e910c..e74108690 100755
--- a/infra/config/main.star
+++ b/infra/config/main.star
@@ -149,14 +149,14 @@ luci.notifier(
     notify_emails = [
         "crosvm-uprev@grotations.appspotmail.com",
         "crosvm-uprev-apac@grotations.appspotmail.com",
-        "denniskempin@google.com",
     ],
 )
 luci.notifier(
     name = "infra-failures",
     on_status_change = True,
     notify_emails = [
-        "denniskempin@google.com",
+        "crosvm-uprev@grotations.appspotmail.com",
+        "crosvm-uprev-apac@grotations.appspotmail.com",
         "keiichiw@google.com",
     ],
 )
@@ -307,9 +307,7 @@ verify_linux_builder("x86_64")
 verify_linux_builder("aarch64")
 verify_linux_builder("armhf")
 verify_linux_builder("mingw64")
-
-# Disabled due to b/304875018
-# verify_linux_builder("riscv64")
+verify_linux_builder("riscv64")
 
 verify_builder(
     name = "chromeos_hatch",
@@ -324,17 +322,18 @@ verify_builder(
     presubmit = False,
 )
 
-verify_builder(
-    name = "windows",
-    dimensions = {
-        "os": "Windows",
-        "cpu": "x86-64",
-    },
-    executable = luci.recipe(
-        name = "build_windows",
-    ),
-    category = "windows",
-)
+# Disabled due to b/396467061
+#verify_builder(
+#    name = "windows",
+#    dimensions = {
+#        "os": "Windows",
+#        "cpu": "x86-64",
+#    },
+#    executable = luci.recipe(
+#        name = "build_windows",
+#    ),
+#    category = "windows",
+#)
 
 verify_builder(
     name = "health_check",
@@ -404,6 +403,19 @@ infra_builder(
     executable = luci.recipe(
         name = "build_baguette_image",
     ),
-    schedule = "0,0 0 * * 3",  # Run every Wednesday
-    postsubmit = False
+    schedule = "0 0 * * *",  # Run everyday during active devlopment
+    postsubmit = False,
+)
+
+infra_builder(
+    name = "baguette_uprev",
+    executable = luci.recipe(
+        name = "uprev_baguette_image",
+    ),
+    properties = {
+        "push": True,
+        "bot": True,
+    },
+    schedule = "0 12 * * *",  # Check for uprevs daily
+    postsubmit = False,
 )
diff --git a/infra/config/recipes.cfg b/infra/config/recipes.cfg
index d5c4d146d..38ccc6c2e 100644
--- a/infra/config/recipes.cfg
+++ b/infra/config/recipes.cfg
@@ -5,27 +5,25 @@
     "nontrivial": {
       "automatic_commit_dry_run": true,
       "extra_reviewer_emails": [
-        "denniskempin@google.com"
+        "zihanchen@google.com",
+        "drmasquatch@google.com"
       ],
       "set_autosubmit": true
     },
     "trivial": {
-      "automatic_commit": true,
-      "tbr_emails": [
-        "denniskempin@google.com"
-      ]
+      "automatic_commit": true
     }
   },
   "canonical_repo_url": "https://chromium.googlesource.com/crosvm/crosvm.git",
   "deps": {
     "depot_tools": {
       "branch": "refs/heads/main",
-      "revision": "f40ddcd8d51626fb7be3ab3c418b3f3be801623f",
+      "revision": "68f0a29a64d354aefcdb1f9eb2a636b21fe96d91",
       "url": "https://chromium.googlesource.com/chromium/tools/depot_tools.git"
     },
     "recipe_engine": {
       "branch": "refs/heads/main",
-      "revision": "b67985a8c735f0c61e1757be3cefd43b5d629696",
+      "revision": "e84c69f5be0b72ea7957140f6105a89cb0706dce",
       "url": "https://chromium.googlesource.com/infra/luci/recipes-py.git"
     }
   },
diff --git a/infra/recipe_modules/crosvm/examples/source_context.expected/prepare_source_for_try.json b/infra/recipe_modules/crosvm/examples/source_context.expected/prepare_source_for_try.json
index 405968915..9b32ee2c5 100644
--- a/infra/recipe_modules/crosvm/examples/source_context.expected/prepare_source_for_try.json
+++ b/infra/recipe_modules/crosvm/examples/source_context.expected/prepare_source_for_try.json
@@ -171,7 +171,6 @@
       "vpython3",
       "RECIPE_REPO[depot_tools]/gerrit_client.py",
       "changes",
-      "--verbose",
       "--host",
       "https://chromium-review.googlesource.com",
       "--json_file",
@@ -183,7 +182,8 @@
       "-o",
       "ALL_REVISIONS",
       "-o",
-      "DOWNLOAD_COMMANDS"
+      "DOWNLOAD_COMMANDS",
+      "--verbose"
     ],
     "cwd": "[CACHE]/builder",
     "env": {
diff --git a/infra/recipes/build_docs.py b/infra/recipes/build_docs.py
index e2b7f8400..2eb54d190 100644
--- a/infra/recipes/build_docs.py
+++ b/infra/recipes/build_docs.py
@@ -33,13 +33,6 @@ def RunSteps(api):
             ["./tools/cargo-doc", "--target-dir", "docs/target"],
         )
 
-        # Container generated files are root-owned, we need to make sure they will be readable by
-        # gsutil (which has to run outside the container to run with proper authentication).
-        api.crosvm.step_in_container(
-            "Make docs readable by gsutil",
-            ["chmod", "-R", "o+r", "docs/target"],
-        )
-
         api.gsutil(
             ["rsync", "-r", "-d", "./docs/target/html", BOOK_URL],
             name="Upload book",
diff --git a/infra/recipes/update_chromeos_merges.py b/infra/recipes/update_chromeos_merges.py
index cd27a8b0e..9a7ccec48 100644
--- a/infra/recipes/update_chromeos_merges.py
+++ b/infra/recipes/update_chromeos_merges.py
@@ -13,6 +13,15 @@ DEPS = [
 
 def RunSteps(api):
     with api.crosvm.source_context():
+        api.step(
+            "Stop existing dev containers",
+            [
+                "vpython3",
+                "./tools/dev_container",
+                "--verbose",
+                "--stop",
+            ],
+        )
         api.step(
             "Update Merges",
             [
diff --git a/infra/recipes/uprev_baguette_image.expected/Nothing to submit.json b/infra/recipes/uprev_baguette_image.expected/Nothing to submit.json
new file mode 100644
index 000000000..e4a31a06e
--- /dev/null
+++ b/infra/recipes/uprev_baguette_image.expected/Nothing to submit.json	
@@ -0,0 +1,134 @@
+[
+  {
+    "cmd": [
+      "python3",
+      "-u",
+      "RECIPE_MODULE[depot_tools::git]/resources/git_setup.py",
+      "--path",
+      "[CLEANUP]/tmp_tmp_1",
+      "--url",
+      "https://chromium.googlesource.com/chromiumos/platform2/"
+    ],
+    "name": "git setup"
+  },
+  {
+    "cmd": [
+      "git",
+      "fetch",
+      "origin",
+      "main",
+      "--progress",
+      "--depth",
+      "1"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "env": {
+      "PATH": "RECIPE_REPO[depot_tools]:<PATH>"
+    },
+    "infra_step": true,
+    "name": "git fetch"
+  },
+  {
+    "cmd": [
+      "git",
+      "checkout",
+      "-f",
+      "FETCH_HEAD"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git checkout"
+  },
+  {
+    "cmd": [
+      "git",
+      "rev-parse",
+      "HEAD"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "read revision",
+    "~followup_annotations": [
+      "@@@STEP_TEXT@<br/>checked out 'deadbeef'<br/>@@@"
+    ]
+  },
+  {
+    "cmd": [
+      "git",
+      "clean",
+      "-f",
+      "-d",
+      "-x"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git clean"
+  },
+  {
+    "cmd": [
+      "git",
+      "submodule",
+      "sync"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "submodule sync"
+  },
+  {
+    "cmd": [
+      "git",
+      "submodule",
+      "update",
+      "--init",
+      "--recursive"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "submodule update"
+  },
+  {
+    "cmd": [
+      "curl",
+      "-Lo",
+      ".git/hooks/commit-msg",
+      "https://chromium-review.googlesource.com/tools/hooks/commit-msg"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Install commit hook"
+  },
+  {
+    "cmd": [
+      "chmod",
+      "+x",
+      ".git/hooks/commit-msg"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Make commit hook executable"
+  },
+  {
+    "cmd": [
+      "bash",
+      "vm_tools/baguette_image/src/uprev-version-pin.sh"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Run uprev-image-version.sh"
+  },
+  {
+    "cmd": [
+      "git",
+      "diff",
+      "--exit-codes",
+      "-q",
+      "vm_tools/concierge/baguette_version.h"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git diff",
+    "~followup_annotations": [
+      "@@@STEP_TEXT@Nothing to submit@@@"
+    ]
+  },
+  {
+    "name": "$result"
+  }
+]
\ No newline at end of file
diff --git a/infra/recipes/uprev_baguette_image.expected/Submit bot uprev.json b/infra/recipes/uprev_baguette_image.expected/Submit bot uprev.json
new file mode 100644
index 000000000..75a301486
--- /dev/null
+++ b/infra/recipes/uprev_baguette_image.expected/Submit bot uprev.json	
@@ -0,0 +1,163 @@
+[
+  {
+    "cmd": [
+      "python3",
+      "-u",
+      "RECIPE_MODULE[depot_tools::git]/resources/git_setup.py",
+      "--path",
+      "[CLEANUP]/tmp_tmp_1",
+      "--url",
+      "https://chromium.googlesource.com/chromiumos/platform2/"
+    ],
+    "name": "git setup"
+  },
+  {
+    "cmd": [
+      "git",
+      "fetch",
+      "origin",
+      "main",
+      "--progress",
+      "--depth",
+      "1"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "env": {
+      "PATH": "RECIPE_REPO[depot_tools]:<PATH>"
+    },
+    "infra_step": true,
+    "name": "git fetch"
+  },
+  {
+    "cmd": [
+      "git",
+      "checkout",
+      "-f",
+      "FETCH_HEAD"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git checkout"
+  },
+  {
+    "cmd": [
+      "git",
+      "rev-parse",
+      "HEAD"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "read revision",
+    "~followup_annotations": [
+      "@@@STEP_TEXT@<br/>checked out 'deadbeef'<br/>@@@"
+    ]
+  },
+  {
+    "cmd": [
+      "git",
+      "clean",
+      "-f",
+      "-d",
+      "-x"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git clean"
+  },
+  {
+    "cmd": [
+      "git",
+      "submodule",
+      "sync"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "submodule sync"
+  },
+  {
+    "cmd": [
+      "git",
+      "submodule",
+      "update",
+      "--init",
+      "--recursive"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "submodule update"
+  },
+  {
+    "cmd": [
+      "curl",
+      "-Lo",
+      ".git/hooks/commit-msg",
+      "https://chromium-review.googlesource.com/tools/hooks/commit-msg"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Install commit hook"
+  },
+  {
+    "cmd": [
+      "chmod",
+      "+x",
+      ".git/hooks/commit-msg"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Make commit hook executable"
+  },
+  {
+    "cmd": [
+      "bash",
+      "vm_tools/baguette_image/src/uprev-version-pin.sh"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Run uprev-image-version.sh"
+  },
+  {
+    "cmd": [
+      "git",
+      "diff",
+      "--exit-codes",
+      "-q",
+      "vm_tools/concierge/baguette_version.h"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git diff"
+  },
+  {
+    "cmd": [
+      "git",
+      "add",
+      "vm_tools/concierge/baguette_version.h"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git add"
+  },
+  {
+    "cmd": [
+      "git",
+      "commit",
+      "-m",
+      "vm_tools: Uprev baguette_image version\n\nGenerated by https://cr-buildbucket.appspot.com/build/0."
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git commit"
+  },
+  {
+    "cmd": [
+      "git",
+      "push",
+      "origin",
+      "HEAD:refs/for/main%r=crosvm-uprev@google.com,l=Bot-Commit+1,l=Commit-Queue+2"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git push"
+  },
+  {
+    "name": "$result"
+  }
+]
\ No newline at end of file
diff --git a/infra/recipes/uprev_baguette_image.expected/Submit test uprev.json b/infra/recipes/uprev_baguette_image.expected/Submit test uprev.json
new file mode 100644
index 000000000..70dade6bb
--- /dev/null
+++ b/infra/recipes/uprev_baguette_image.expected/Submit test uprev.json	
@@ -0,0 +1,163 @@
+[
+  {
+    "cmd": [
+      "python3",
+      "-u",
+      "RECIPE_MODULE[depot_tools::git]/resources/git_setup.py",
+      "--path",
+      "[CLEANUP]/tmp_tmp_1",
+      "--url",
+      "https://chromium.googlesource.com/chromiumos/platform2/"
+    ],
+    "name": "git setup"
+  },
+  {
+    "cmd": [
+      "git",
+      "fetch",
+      "origin",
+      "main",
+      "--progress",
+      "--depth",
+      "1"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "env": {
+      "PATH": "RECIPE_REPO[depot_tools]:<PATH>"
+    },
+    "infra_step": true,
+    "name": "git fetch"
+  },
+  {
+    "cmd": [
+      "git",
+      "checkout",
+      "-f",
+      "FETCH_HEAD"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git checkout"
+  },
+  {
+    "cmd": [
+      "git",
+      "rev-parse",
+      "HEAD"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "read revision",
+    "~followup_annotations": [
+      "@@@STEP_TEXT@<br/>checked out 'deadbeef'<br/>@@@"
+    ]
+  },
+  {
+    "cmd": [
+      "git",
+      "clean",
+      "-f",
+      "-d",
+      "-x"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git clean"
+  },
+  {
+    "cmd": [
+      "git",
+      "submodule",
+      "sync"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "submodule sync"
+  },
+  {
+    "cmd": [
+      "git",
+      "submodule",
+      "update",
+      "--init",
+      "--recursive"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "submodule update"
+  },
+  {
+    "cmd": [
+      "curl",
+      "-Lo",
+      ".git/hooks/commit-msg",
+      "https://chromium-review.googlesource.com/tools/hooks/commit-msg"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Install commit hook"
+  },
+  {
+    "cmd": [
+      "chmod",
+      "+x",
+      ".git/hooks/commit-msg"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Make commit hook executable"
+  },
+  {
+    "cmd": [
+      "bash",
+      "vm_tools/baguette_image/src/uprev-version-pin.sh"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "name": "Run uprev-image-version.sh"
+  },
+  {
+    "cmd": [
+      "git",
+      "diff",
+      "--exit-codes",
+      "-q",
+      "vm_tools/concierge/baguette_version.h"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git diff"
+  },
+  {
+    "cmd": [
+      "git",
+      "add",
+      "vm_tools/concierge/baguette_version.h"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git add"
+  },
+  {
+    "cmd": [
+      "git",
+      "commit",
+      "-m",
+      "vm_tools: Uprev baguette_image version\n\nGenerated by https://cr-buildbucket.appspot.com/build/0."
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git commit"
+  },
+  {
+    "cmd": [
+      "git",
+      "push",
+      "origin",
+      "HEAD:refs/for/main%r=crosvm-uprev@google.com,l=Commit-Queue+1"
+    ],
+    "cwd": "[CLEANUP]/tmp_tmp_1",
+    "infra_step": true,
+    "name": "git push"
+  },
+  {
+    "name": "$result"
+  }
+]
\ No newline at end of file
diff --git a/infra/recipes/uprev_baguette_image.proto b/infra/recipes/uprev_baguette_image.proto
new file mode 100644
index 000000000..2c0ecbaff
--- /dev/null
+++ b/infra/recipes/uprev_baguette_image.proto
@@ -0,0 +1,14 @@
+// Copyright 2021 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+syntax = "proto3";
+
+package recipes.crosvm.uprev_baguette_image;
+
+message UprevBaguetteImageProperties {
+  // Set to true to enable pushing to gerrit
+  bool push = 1;
+  // Set to true if the recipe is allowed to set Bot-Commit+1
+  bool bot = 2;
+}
diff --git a/infra/recipes/uprev_baguette_image.py b/infra/recipes/uprev_baguette_image.py
new file mode 100644
index 000000000..5464cb4c1
--- /dev/null
+++ b/infra/recipes/uprev_baguette_image.py
@@ -0,0 +1,100 @@
+# -*- coding: utf-8 -*-
+# Copyright 2025 The ChromiumOS Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+"""Recipe for uploading uprevs of the baguette image."""
+
+import os
+import re
+import pathlib
+from typing import Generator
+
+from PB.recipes.crosvm.uprev_baguette_image import UprevBaguetteImageProperties
+from recipe_engine import post_process
+from recipe_engine.recipe_api import RecipeApi
+from recipe_engine.recipe_api import StepFailure
+from recipe_engine.recipe_test_api import RecipeTestApi
+from recipe_engine.recipe_test_api import TestData
+
+
+DEPS = [
+    "recipe_engine/buildbucket",
+    "recipe_engine/context",
+    "recipe_engine/path",
+    "recipe_engine/properties",
+    "recipe_engine/step",
+    "depot_tools/git",
+]
+
+PROPERTIES = UprevBaguetteImageProperties
+
+_PLATFORM2_REPO_URL = "https://chromium.googlesource.com/chromiumos/platform2/"
+_UPREV_SCRIPT_PATH = "vm_tools/baguette_image/src/uprev-version-pin.sh"
+_VERSION_FILE_PATH = "vm_tools/concierge/baguette_version.h"
+
+
+def RunSteps(api: RecipeApi, properties: UprevBaguetteImageProperties) -> None:
+    # Clone the repo in a temp dir
+    checkout = api.path.mkdtemp()
+    api.git.checkout(_PLATFORM2_REPO_URL, dir_path=checkout, depth=1)
+
+    with api.context(cwd=checkout):
+        # Ensure the commit hook is configured
+        api.step(
+            "Install commit hook",
+            [
+                "curl",
+                "-Lo",
+                ".git/hooks/commit-msg",
+                "https://chromium-review.googlesource.com/tools/hooks/commit-msg",
+            ],
+        )
+        api.step("Make commit hook executable", ["chmod", "+x", ".git/hooks/commit-msg"])
+
+        # Run the uprev script
+        api.step("Run uprev-image-version.sh", ["bash", _UPREV_SCRIPT_PATH])
+
+        # Check if the uprev made any changes to the version file
+        diff_result = api.git("diff", "--exit-codes", "-q", _VERSION_FILE_PATH, ok_ret="any")
+        if diff_result.retcode == 0:
+            diff_result.presentation.step_text = "Nothing to submit"
+            return
+
+        commit_lines = [
+            f"vm_tools: Uprev baguette_image version",
+            "",
+            f"Generated by {api.buildbucket.build_url()}.",
+        ]
+
+        # Create a commit with the new version file
+        api.git("add", _VERSION_FILE_PATH)
+        api.git("commit", "-m", "\n".join(commit_lines))
+
+        # Push the change to gerrit
+        if properties.push:
+            gerrit_params = ["r=crosvm-uprev@google.com"]
+            if properties.bot:
+                gerrit_params += ["l=Bot-Commit+1", "l=Commit-Queue+2"]
+            else:
+                gerrit_params += ["l=Commit-Queue+1"]
+            api.git("push", "origin", f"HEAD:refs/for/main%{','.join(gerrit_params)}")
+
+
+def GenTests(api: RecipeTestApi) -> Generator[TestData, None, None]:
+    yield api.test(
+        "Submit test uprev",
+        api.properties(push=True, bot=False),
+        api.step_data("git diff", retcode=1),
+    )
+    yield api.test(
+        "Submit bot uprev",
+        api.properties(push=True, bot=True),
+        api.step_data("git diff", retcode=1),
+    )
+
+    yield api.test(
+        "Nothing to submit",
+        api.properties(push=True),
+        api.step_data("git diff", retcode=0),
+    )
diff --git a/io_uring/Cargo.toml b/io_uring/Cargo.toml
index 06c2933bb..7d8456abf 100644
--- a/io_uring/Cargo.toml
+++ b/io_uring/Cargo.toml
@@ -5,11 +5,11 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-libc = "0.2.93"
-remain = "0.2"
-sync = { path = "../common/sync" } # provided by ebuild
-base = { path = "../base" } # provided by ebuild
-thiserror = "1"
+libc = { workspace = true }
+remain = { workspace = true }
+sync = { workspace = true }
+base = { workspace = true }
+thiserror = { workspace = true }
 
 [dev-dependencies]
 tempfile = "3"
diff --git a/io_uring/bindgen.sh b/io_uring/bindgen.sh
index dad82c175..002eae676 100755
--- a/io_uring/bindgen.sh
+++ b/io_uring/bindgen.sh
@@ -14,6 +14,6 @@ bindgen_generate \
     --allowlist-type='io_uring_.*' \
     --allowlist-var='IO_URING_.*' \
     --allowlist-var='IORING_.*' \
-    "${BINDGEN_LINUX}/include/uapi/linux/io_uring.h" \
+    "${BINDGEN_LINUX_X86_HEADERS}/include/linux/io_uring.h" \
     | replace_linux_int_types | rustfmt \
     > io_uring/src/bindings.rs
diff --git a/jail/Android.bp b/jail/Android.bp
index b725dbb14..c0958b98b 100644
--- a/jail/Android.bp
+++ b/jail/Android.bp
@@ -34,7 +34,6 @@ rust_test {
         "liblibtest_mimic",
         "liblog_rust",
         "libminijail_rust",
-        "libonce_cell",
         "libserde",
         "libserde_keyvalue",
         "libstatic_assertions",
@@ -57,7 +56,6 @@ rust_library {
         "liblibc",
         "liblog_rust",
         "libminijail_rust",
-        "libonce_cell",
         "libserde",
         "libserde_keyvalue",
         "libstatic_assertions",
diff --git a/jail/Cargo.toml b/jail/Cargo.toml
index f7f1e0072..97a6d2d22 100644
--- a/jail/Cargo.toml
+++ b/jail/Cargo.toml
@@ -15,13 +15,12 @@ harness = false
 seccomp_trace = []
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base" }
-libc = "0.2"
+anyhow = { workspace = true }
+base = { workspace = true }
+libc = { workspace = true }
 log = "0.4"
-once_cell = "1.7"
-serde = "1"
-serde_keyvalue = { path = "../serde_keyvalue", features = ["argh_derive"] }
+serde = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
 static_assertions = "1.1"
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
@@ -33,5 +32,5 @@ which = "4"
 rayon = "1.5.3"
 
 [dev-dependencies]
-cfg-if = "1"
+cfg-if = { workspace = true }
 libtest-mimic = "0.6"
diff --git a/jail/build.rs b/jail/build.rs
index ecc7bd034..a451f6a2d 100644
--- a/jail/build.rs
+++ b/jail/build.rs
@@ -104,14 +104,13 @@ fn main() {
     let compile_seccomp_policy = if let Ok(path) = which::which("compile_seccomp_policy") {
         // If `compile_seccomp_policy` exists in the path (e.g. ChromeOS builds), use it.
         path
-    } else {
         // Otherwise, use compile_seccomp_policy.py from the minijail submodule.
-        let minijail_dir = if let Ok(minijail_dir_env) = env::var("MINIJAIL_DIR") {
-            PathBuf::from(minijail_dir_env)
-        } else {
-            src_dir.join("../third_party/minijail")
-        };
-        minijail_dir.join("tools/compile_seccomp_policy.py")
+    } else if let Ok(minijail_dir_env) = env::var("MINIJAIL_DIR") {
+        PathBuf::from(minijail_dir_env).join("tools/compile_seccomp_policy.py")
+    } else if let Ok(compile_seccomp_policy_env) = env::var("COMPILE_SECCOMP_POLICY") {
+        PathBuf::from(compile_seccomp_policy_env)
+    } else {
+        src_dir.join("../third_party/minijail/tools/compile_seccomp_policy.py")
     };
 
     // check policies exist for target architecture
diff --git a/jail/seccomp/x86_64/common_device.policy b/jail/seccomp/x86_64/common_device.policy
index 3e75883e5..83af537dd 100644
--- a/jail/seccomp/x86_64/common_device.policy
+++ b/jail/seccomp/x86_64/common_device.policy
@@ -51,6 +51,9 @@ clock_nanosleep: 1
 pipe2: 1
 poll: 1
 ppoll: 1
+# ANDROID: Disabled because it isn't needed by any libc we support.
+# prctl: arg0 == PR_SET_VMA
+prlimit64: 1
 read: 1
 readlink: 1
 readlinkat: 1
diff --git a/jail/seccomp/x86_64/cras_audio_device.policy b/jail/seccomp/x86_64/cras_audio_device.policy
index 35749b32d..95f4c6dc3 100644
--- a/jail/seccomp/x86_64/cras_audio_device.policy
+++ b/jail/seccomp/x86_64/cras_audio_device.policy
@@ -6,7 +6,6 @@
 
 open: return ENOENT
 openat: return ENOENT
-prlimit64: 1
 setrlimit: 1
 sched_setscheduler: 1
 socketpair: arg0 == AF_UNIX
diff --git a/jail/seccomp/x86_64/jail_warden.policy b/jail/seccomp/x86_64/jail_warden.policy
index 512423cb9..741ca3896 100644
--- a/jail/seccomp/x86_64/jail_warden.policy
+++ b/jail/seccomp/x86_64/jail_warden.policy
@@ -43,7 +43,6 @@ prctl: arg0 == PR_SET_NO_NEW_PRIVS || \
        arg0 == PR_SET_SECCOMP || \
        arg0 == PR_CAPBSET_DROP || \
        arg0 == PR_SET_NAME
-prlimit64: 1
 setsid: 1
 setsockopt: 1
 socket: arg0 == AF_INET || arg0 == AF_UNIX
diff --git a/jail/seccomp/x86_64/null_audio_device.policy b/jail/seccomp/x86_64/null_audio_device.policy
index 1c46972b7..f5cff2d9a 100644
--- a/jail/seccomp/x86_64/null_audio_device.policy
+++ b/jail/seccomp/x86_64/null_audio_device.policy
@@ -6,7 +6,6 @@
 
 open: return ENOENT
 openat: return ENOENT
-prlimit64: 1
 setrlimit: 1
 sched_setscheduler: 1
 prctl: arg0 == PR_SET_NAME
diff --git a/jail/seccomp/x86_64/snd_aaudio_device.policy b/jail/seccomp/x86_64/snd_aaudio_device.policy
index 58252df40..70638870c 100644
--- a/jail/seccomp/x86_64/snd_aaudio_device.policy
+++ b/jail/seccomp/x86_64/snd_aaudio_device.policy
@@ -10,7 +10,6 @@ socket: arg0 == AF_UNIX
 socketpair: arg0 == AF_UNIX
 prctl: arg0 == PR_SET_NAME
 connect: 1
-prlimit64: 1
 setrlimit: 1
 sched_setscheduler: 1
 timerfd_create: 1
diff --git a/jail/seccomp/x86_64/snd_cras_device.policy b/jail/seccomp/x86_64/snd_cras_device.policy
index ef6032637..6b22513d2 100644
--- a/jail/seccomp/x86_64/snd_cras_device.policy
+++ b/jail/seccomp/x86_64/snd_cras_device.policy
@@ -10,7 +10,6 @@ socket: arg0 == AF_UNIX
 socketpair: arg0 == AF_UNIX
 prctl: arg0 == PR_SET_NAME
 connect: 1
-prlimit64: 1
 setrlimit: 1
 sched_setscheduler: 1
 timerfd_create: 1
diff --git a/jail/seccomp/x86_64/snd_null_device.policy b/jail/seccomp/x86_64/snd_null_device.policy
index 5ea1e68d8..3cf893637 100644
--- a/jail/seccomp/x86_64/snd_null_device.policy
+++ b/jail/seccomp/x86_64/snd_null_device.policy
@@ -9,7 +9,6 @@ socket: arg0 == AF_UNIX
 socketpair: arg0 == AF_UNIX
 prctl: arg0 == PR_SET_NAME
 connect: 1
-prlimit64: 1
 sched_setscheduler: 1
 timerfd_create: 1
 timerfd_settime: 1
diff --git a/jail/seccomp/x86_64/vios_audio_device.policy b/jail/seccomp/x86_64/vios_audio_device.policy
index 04c564fd7..402af0413 100644
--- a/jail/seccomp/x86_64/vios_audio_device.policy
+++ b/jail/seccomp/x86_64/vios_audio_device.policy
@@ -6,7 +6,6 @@
 
 open: return ENOENT
 openat: return ENOENT
-prlimit64: 1
 sched_setscheduler: 1
 setrlimit: 1
 prctl: arg0 == PR_SET_NAME
diff --git a/jail/src/helpers.rs b/jail/src/helpers.rs
index 159c9433a..0da2baa7c 100644
--- a/jail/src/helpers.rs
+++ b/jail/src/helpers.rs
@@ -7,6 +7,7 @@
 
 use std::path::Path;
 use std::str;
+use std::sync::LazyLock;
 
 use anyhow::bail;
 use anyhow::Context;
@@ -19,7 +20,6 @@ use base::geteuid;
 use base::warn;
 use libc::c_ulong;
 use minijail::Minijail;
-use once_cell::sync::Lazy;
 #[cfg(feature = "seccomp_trace")]
 use static_assertions::const_assert;
 #[cfg(feature = "seccomp_trace")]
@@ -31,11 +31,15 @@ use crate::config::JailConfig;
 
 // ANDROID: b/246968493
 #[cfg(not(feature = "seccomp_trace"))]
-static EMBEDDED_BPFS: Lazy<std::collections::HashMap<&str, Vec<u8>>> =
-    Lazy::new(|| std::collections::HashMap::<&str, Vec<u8>>::new());
-
-/// Most devices don't need to open many fds.
-pub const MAX_OPEN_FILES_DEFAULT: u64 = 1024;
+static EMBEDDED_BPFS: LazyLock<std::collections::HashMap<&str, Vec<u8>>> =
+    LazyLock::new(|| std::collections::HashMap::<&str, Vec<u8>>::new());
+
+/// Most devices don't need to open many fds. However, an implementation detail of minijail is that
+/// after applying this limit, it opens an additional file descriptor to scan the /proc/self/fd
+/// directory to choose which file descriptors to close in the child process. The open files limit
+/// therefore has to be higher than the number file descriptors that the parent thread holds open
+/// before the jail is started.
+pub const MAX_OPEN_FILES_DEFAULT: u64 = 4096;
 /// The max open files for gpu processes.
 const MAX_OPEN_FILES_FOR_GPU: u64 = 32768;
 /// The max open files for jail warden, matching FD_RAW_FAILURE.
diff --git a/kernel_cmdline/Cargo.toml b/kernel_cmdline/Cargo.toml
index 1dbdb1c7c..44d60c5e9 100644
--- a/kernel_cmdline/Cargo.toml
+++ b/kernel_cmdline/Cargo.toml
@@ -4,9 +4,9 @@ version = "0.1.0"
 edition = "2021"
 
 [dependencies]
-libc = "0.2"
-remain = "0.2"
-thiserror = "1"
+libc = { workspace = true }
+remain = { workspace = true }
+thiserror = { workspace = true }
 
 [lib]
 path = "src/kernel_cmdline.rs"
diff --git a/kernel_loader/Cargo.toml b/kernel_loader/Cargo.toml
index 9031b1e99..150d42c81 100644
--- a/kernel_loader/Cargo.toml
+++ b/kernel_loader/Cargo.toml
@@ -4,14 +4,14 @@ version = "0.1.0"
 edition = "2021"
 
 [dependencies]
-data_model = { path = "../common/data_model" }
-libc = "0.2"
-base = { path = "../base" }
+data_model = { workspace = true }
+libc = { workspace = true }
+base = { workspace = true }
 lz4_flex = "0.11"
-remain = "0.2"
-resources = { path = "../resources" }
-thiserror = "1"
-vm_memory = { path = "../vm_memory" }
+remain = { workspace = true }
+resources = { workspace = true }
+thiserror = { workspace = true }
+vm_memory = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [dev-dependencies]
diff --git a/kernel_loader/bindgen.sh b/kernel_loader/bindgen.sh
index de85e4f57..f710c4b3f 100755
--- a/kernel_loader/bindgen.sh
+++ b/kernel_loader/bindgen.sh
@@ -30,8 +30,8 @@ bindgen_generate \
     --with-derive-custom "elf64_hdr=FromBytes,Immutable,IntoBytes,KnownLayout" \
     --with-derive-custom "elf32_phdr=FromBytes,Immutable,IntoBytes,KnownLayout" \
     --with-derive-custom "elf64_phdr=FromBytes,Immutable,IntoBytes,KnownLayout" \
-    "${BINDGEN_LINUX}/include/uapi/linux/elf.h" \
+    "${BINDGEN_LINUX_X86_HEADERS}/include/linux/elf.h" \
     -- \
-    -isystem "${BINDGEN_LINUX}/include" \
+    -isystem "${BINDGEN_LINUX_X86_HEADERS}/include" \
     | replace_linux_int_types \
     > kernel_loader/src/elf.rs
diff --git a/kernel_loader/src/arm64.rs b/kernel_loader/src/arm64.rs
index 6b8632ff7..090f456e5 100644
--- a/kernel_loader/src/arm64.rs
+++ b/kernel_loader/src/arm64.rs
@@ -29,6 +29,7 @@ use zerocopy::Immutable;
 use zerocopy::IntoBytes;
 use zerocopy::KnownLayout;
 
+use crate::ElfClass;
 use crate::Error;
 use crate::LoadedKernel;
 use crate::Result;
@@ -114,6 +115,7 @@ where
         address_range: AddressRange::from_start_and_size(load_addr.offset(), range_size)
             .ok_or(Error::InvalidKernelSize)?,
         entry: load_addr,
+        class: ElfClass::ElfClass64,
     })
 }
 
@@ -168,6 +170,7 @@ fn load_arm64_kernel_from_reader<F: BufRead>(
         address_range: AddressRange::from_start_and_size(load_addr.offset(), range_size)
             .ok_or(Error::InvalidKernelSize)?,
         entry: load_addr,
+        class: ElfClass::ElfClass64,
     })
 }
 
diff --git a/kernel_loader/src/elf.rs b/kernel_loader/src/elf.rs
index 7170e7d89..6217f14e8 100644
--- a/kernel_loader/src/elf.rs
+++ b/kernel_loader/src/elf.rs
@@ -284,9 +284,6 @@ pub const NT_LOONGARCH_HW_WATCH: u32 = 2566;
 pub const NT_GNU_PROPERTY_TYPE_0: u32 = 5;
 pub const GNU_PROPERTY_AARCH64_FEATURE_1_AND: u32 = 3221225472;
 pub const GNU_PROPERTY_AARCH64_FEATURE_1_BTI: u32 = 1;
-pub const false_: _bindgen_ty_1 = 0;
-pub const true_: _bindgen_ty_1 = 1;
-pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
 pub type Elf32_Addr = u32;
 pub type Elf32_Half = u16;
 pub type Elf32_Off = u32;
diff --git a/kernel_loader/src/lib.rs b/kernel_loader/src/lib.rs
index 4abb96ef4..a0f79d6c2 100644
--- a/kernel_loader/src/lib.rs
+++ b/kernel_loader/src/lib.rs
@@ -91,64 +91,16 @@ pub struct LoadedKernel {
 
     /// Entry point address of the kernel.
     pub entry: GuestAddress,
-}
 
-/// Loads a kernel from a 32-bit ELF image into memory.
-///
-/// The ELF file will be loaded at the physical address specified by the `p_paddr` fields of its
-/// program headers.
-///
-/// # Arguments
-///
-/// * `guest_mem` - The guest memory region the kernel is written to.
-/// * `kernel_start` - The minimum guest address to allow when loading program headers.
-/// * `kernel_image` - Input vmlinux image.
-/// * `phys_offset` - An offset in bytes to add to each physical address (`p_paddr`).
-pub fn load_elf32<F>(
-    guest_mem: &GuestMemory,
-    kernel_start: GuestAddress,
-    kernel_image: &mut F,
-    phys_offset: u64,
-) -> Result<LoadedKernel>
-where
-    F: FileReadWriteAtVolatile,
-{
-    load_elf_for_class(
-        guest_mem,
-        kernel_start,
-        kernel_image,
-        phys_offset,
-        Some(elf::ELFCLASS32),
-    )
+    /// ELF class or equivalent for other image formats.
+    pub class: ElfClass,
 }
 
-/// Loads a kernel from a 64-bit ELF image into memory.
-///
-/// The ELF file will be loaded at the physical address specified by the `p_paddr` fields of its
-/// program headers.
-///
-/// # Arguments
-///
-/// * `guest_mem` - The guest memory region the kernel is written to.
-/// * `kernel_start` - The minimum guest address to allow when loading program headers.
-/// * `kernel_image` - Input vmlinux image.
-/// * `phys_offset` - An offset in bytes to add to each physical address (`p_paddr`).
-pub fn load_elf64<F>(
-    guest_mem: &GuestMemory,
-    kernel_start: GuestAddress,
-    kernel_image: &mut F,
-    phys_offset: u64,
-) -> Result<LoadedKernel>
-where
-    F: FileReadWriteAtVolatile,
-{
-    load_elf_for_class(
-        guest_mem,
-        kernel_start,
-        kernel_image,
-        phys_offset,
-        Some(elf::ELFCLASS64),
-    )
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
+/// ELF image class (32- or 64-bit ELF)
+pub enum ElfClass {
+    ElfClass32,
+    ElfClass64,
 }
 
 /// Loads a kernel from a 32-bit or 64-bit ELF image into memory.
@@ -171,20 +123,7 @@ pub fn load_elf<F>(
 where
     F: FileReadWriteAtVolatile,
 {
-    load_elf_for_class(guest_mem, kernel_start, kernel_image, phys_offset, None)
-}
-
-fn load_elf_for_class<F>(
-    guest_mem: &GuestMemory,
-    kernel_start: GuestAddress,
-    kernel_image: &mut F,
-    phys_offset: u64,
-    ei_class: Option<u32>,
-) -> Result<LoadedKernel>
-where
-    F: FileReadWriteAtVolatile,
-{
-    let elf = read_elf(kernel_image, ei_class)?;
+    let (elf, class) = read_elf(kernel_image)?;
     let mut start = None;
     let mut end = 0;
 
@@ -248,6 +187,7 @@ where
         address_range,
         size,
         entry: GuestAddress(entry),
+        class,
     })
 }
 
@@ -257,9 +197,9 @@ struct Elf64 {
 }
 
 /// Reads the headers of an ELF32 or ELF64 object file.  Returns ELF file and program headers,
-/// converted to ELF64 format.  If `required_ei_class` is Some and the file's ELF ei_class doesn't
-/// match, an Err is returned.
-fn read_elf<F>(file: &mut F, required_ei_class: Option<u32>) -> Result<Elf64>
+/// converted to ELF64 format as a single internal representation that can handle either 32- or
+/// 64-bit images, and the ELF class of the original image.
+fn read_elf<F>(file: &mut F) -> Result<(Elf64, ElfClass)>
 where
     F: FileReadWriteAtVolatile,
 {
@@ -284,14 +224,15 @@ where
     }
 
     let ei_class = ident[elf::EI_CLASS as usize] as u32;
-    if let Some(required_ei_class) = required_ei_class {
-        if ei_class != required_ei_class {
-            return Err(Error::InvalidElfClass);
-        }
-    }
     match ei_class {
-        elf::ELFCLASS32 => read_elf_by_type::<_, elf::Elf32_Ehdr, elf::Elf32_Phdr>(file),
-        elf::ELFCLASS64 => read_elf_by_type::<_, elf::Elf64_Ehdr, elf::Elf64_Phdr>(file),
+        elf::ELFCLASS32 => Ok((
+            read_elf_by_type::<_, elf::Elf32_Ehdr, elf::Elf32_Phdr>(file)?,
+            ElfClass::ElfClass32,
+        )),
+        elf::ELFCLASS64 => Ok((
+            read_elf_by_type::<_, elf::Elf64_Ehdr, elf::Elf64_Phdr>(file)?,
+            ElfClass::ElfClass64,
+        )),
         _ => Err(Error::InvalidElfClass),
     }
 }
@@ -418,10 +359,11 @@ mod test {
         let kernel_addr = GuestAddress(0x0);
         let mut image = make_elf32_bin();
         let kernel = load_elf(&gm, kernel_addr, &mut image, 0).unwrap();
-        assert_eq!(kernel.address_range.start, 0);
-        assert_eq!(kernel.address_range.end, 0xa_2037);
-        assert_eq!(kernel.size, 0xa_2038);
-        assert_eq!(kernel.entry, GuestAddress(0x3dc0));
+        assert_eq!(kernel.address_range.start, 0x20_0000);
+        assert_eq!(kernel.address_range.end, 0x20_002e);
+        assert_eq!(kernel.size, 0x2f);
+        assert_eq!(kernel.entry, GuestAddress(0x20_000e));
+        assert_eq!(kernel.class, ElfClass::ElfClass32);
     }
 
     #[test]
@@ -431,9 +373,10 @@ mod test {
         let mut image = make_elf64_bin();
         let kernel = load_elf(&gm, kernel_addr, &mut image, 0).expect("failed to load ELF");
         assert_eq!(kernel.address_range.start, 0x20_0000);
-        assert_eq!(kernel.address_range.end, 0x20_0034);
-        assert_eq!(kernel.size, 0x35);
+        assert_eq!(kernel.address_range.end, 0x20_002f);
+        assert_eq!(kernel.size, 0x30);
         assert_eq!(kernel.entry, GuestAddress(0x20_000e));
+        assert_eq!(kernel.class, ElfClass::ElfClass64);
     }
 
     #[test]
diff --git a/kernel_loader/src/multiboot.rs b/kernel_loader/src/multiboot.rs
index 5473ef8b2..69b449ac6 100644
--- a/kernel_loader/src/multiboot.rs
+++ b/kernel_loader/src/multiboot.rs
@@ -18,6 +18,7 @@ use resources::AddressRange;
 use vm_memory::GuestAddress;
 use vm_memory::GuestMemory;
 
+use crate::ElfClass;
 use crate::Error;
 use crate::LoadedKernel;
 use crate::Result;
@@ -352,5 +353,6 @@ where
         address_range,
         size,
         entry: multiboot_load.entry_addr,
+        class: ElfClass::ElfClass32,
     })
 }
diff --git a/kernel_loader/src/test_elf.S b/kernel_loader/src/test_elf.S
index 40a58c461..42eb47b43 100644
--- a/kernel_loader/src/test_elf.S
+++ b/kernel_loader/src/test_elf.S
@@ -3,8 +3,14 @@
 # found in the LICENSE file.
 
 # Build instructions:
-#  x86_64-linux-gnu-as test_elf.S -o test_elf.o
-#  x86_64-linux-gnu-ld test_elf.o -o test_elf.bin -T test_elf.ld
+#
+# For a 64-bit kernel:
+#  x86_64-linux-gnu-as test_elf.S -o test_elf64.o
+#  x86_64-linux-gnu-ld test_elf64.o -o test_elf64.bin -T test_elf.ld
+#
+# For a 32-bit kernel:
+#  i686-linux-gnu-as test_elf.S -o test_elf32.o
+#  i686-linux-gnu-ld test_elf32.o -o test_elf32.bin -T test_elf.ld
 
     .intel_syntax noprefix
 
@@ -16,8 +22,8 @@ hello_world:
     .text
     .globl _start
 _start:
-    lea rsi, [rip + hello_world]    # rsi -> message string
-    mov rcx, hello_size             # rcx = length of message
+    lea esi, [hello_world]          # esi -> message string
+    mov ecx, hello_size             # ecx = length of message
     mov dx, 0x3F8                   # dx = COM1 port
 
 .print_loop:
@@ -34,8 +40,7 @@ _start:
     # Load a byte of the message and send it to the serial port.
     lodsb                           # load message byte from RSI to AL
     out dx, al                      # send byte to serial port
-    dec rcx                         # rcx--
-    jnz .print_loop                 # repeat if rcx != 0
+    loop .print_loop                # repeat hello_size times
 
 .done:
     int3                            # cause vcpu to exit
diff --git a/kernel_loader/src/test_elf32.bin b/kernel_loader/src/test_elf32.bin
old mode 100644
new mode 100755
index 188ac9f59..5b9e6b296
Binary files a/kernel_loader/src/test_elf32.bin and b/kernel_loader/src/test_elf32.bin differ
diff --git a/kernel_loader/src/test_elf64.bin b/kernel_loader/src/test_elf64.bin
old mode 100644
new mode 100755
index 6ad687774..eb3ee0d2f
Binary files a/kernel_loader/src/test_elf64.bin and b/kernel_loader/src/test_elf64.bin differ
diff --git a/kvm/Cargo.toml b/kvm/Cargo.toml
index 23c23e064..f29cc54dd 100644
--- a/kvm/Cargo.toml
+++ b/kvm/Cargo.toml
@@ -5,11 +5,11 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-data_model = { path = "../common/data_model" }
-kvm_sys = { path = "../kvm_sys" }
-libc = "0.2"
-base = { path = "../base" }
+data_model = { workspace = true }
+kvm_sys = { workspace = true }
+libc = { workspace = true }
+base = { workspace = true }
 static_assertions = "1.1"
-sync = { path = "../common/sync" }
-vm_memory = { path = "../vm_memory" }
+sync = { workspace = true }
+vm_memory = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/kvm_sys/Cargo.toml b/kvm_sys/Cargo.toml
index ec9f770b3..8b0711cd2 100644
--- a/kvm_sys/Cargo.toml
+++ b/kvm_sys/Cargo.toml
@@ -5,7 +5,7 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-data_model = { path = "../common/data_model" }
-libc = "0.2"
-base = { path = "../base" }
+data_model = { workspace = true }
+libc = { workspace = true }
+base = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/kvm_sys/bindgen.sh b/kvm_sys/bindgen.sh
index dd5f19498..0076dd76a 100755
--- a/kvm_sys/bindgen.sh
+++ b/kvm_sys/bindgen.sh
@@ -20,11 +20,14 @@ use zerocopy::KnownLayout;
 // The original index (236) used in the ChromeOS v6.6 kernel was reused upstream for another
 // capability, so this may return incorrect information on some kernels.
 pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA_CROS: u32 = 236;
+pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
+pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 
 // TODO(qwandor): Update this once the pKVM patches are merged upstream with a stable capability ID.
 pub const KVM_CAP_ARM_PROTECTED_VM: u32 = 0xffbadab1;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FW_IPA: u32 = 0;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_INFO: u32 = 1;
+pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FFA: u32 = 2;
 pub const KVM_VM_TYPE_ARM_PROTECTED: u32 = 0x80000000;
 pub const KVM_X86_PKVM_PROTECTED_VM: u32 = 28;
 pub const KVM_CAP_X86_PROTECTED_VM: u32 = 0xffbadab2;
@@ -105,6 +108,7 @@ bindgen_generate \
     --blocklist-item='__BITS_PER_.*' \
     --blocklist-item='__FD_SETSIZE' \
     --blocklist-item='_?IOC.*' \
+    --with-derive-custom "kvm_regs=FromBytes,Immutable,IntoBytes,KnownLayout" \
     "${BINDGEN_LINUX_RISCV_HEADERS}/include/linux/kvm.h" \
     -- \
     -isystem "${BINDGEN_LINUX_RISCV_HEADERS}/include" \
diff --git a/kvm_sys/src/aarch64/bindings.rs b/kvm_sys/src/aarch64/bindings.rs
index 512d66246..9e3a067b2 100644
--- a/kvm_sys/src/aarch64/bindings.rs
+++ b/kvm_sys/src/aarch64/bindings.rs
@@ -18,11 +18,14 @@ use zerocopy::KnownLayout;
 // The original index (236) used in the ChromeOS v6.6 kernel was reused upstream for another
 // capability, so this may return incorrect information on some kernels.
 pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA_CROS: u32 = 236;
+pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
+pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 
 // TODO(qwandor): Update this once the pKVM patches are merged upstream with a stable capability ID.
 pub const KVM_CAP_ARM_PROTECTED_VM: u32 = 0xffbadab1;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FW_IPA: u32 = 0;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_INFO: u32 = 1;
+pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FFA: u32 = 2;
 pub const KVM_VM_TYPE_ARM_PROTECTED: u32 = 0x80000000;
 pub const KVM_X86_PKVM_PROTECTED_VM: u32 = 28;
 pub const KVM_CAP_X86_PROTECTED_VM: u32 = 0xffbadab2;
@@ -418,7 +421,6 @@ pub const KVM_API_VERSION: u32 = 12;
 pub const KVM_MEM_LOG_DIRTY_PAGES: u32 = 1;
 pub const KVM_MEM_READONLY: u32 = 2;
 pub const KVM_MEM_GUEST_MEMFD: u32 = 4;
-pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 pub const KVM_PIT_SPEAKER_DUMMY: u32 = 1;
 pub const KVM_EXIT_HYPERV_SYNIC: u32 = 1;
 pub const KVM_EXIT_HYPERV_HCALL: u32 = 2;
@@ -738,10 +740,6 @@ pub const KVM_CAP_VM_TYPES: u32 = 235;
 pub const KVM_CAP_PRE_FAULT_MEMORY: u32 = 236;
 pub const KVM_CAP_X86_APIC_BUS_CYCLES_NS: u32 = 237;
 pub const KVM_CAP_X86_GUEST_MODE: u32 = 238;
-pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
-pub const KVM_CAP_GET_CUR_CPUFREQ: u32 = 512;
-pub const KVM_CAP_UTIL_HINT: u32 = 513;
-pub const KVM_CAP_GET_CPUFREQ_TBL: u32 = 514;
 pub const KVM_IRQ_ROUTING_IRQCHIP: u32 = 1;
 pub const KVM_IRQ_ROUTING_MSI: u32 = 2;
 pub const KVM_IRQ_ROUTING_S390_ADAPTER: u32 = 3;
diff --git a/kvm_sys/src/riscv64/bindings.rs b/kvm_sys/src/riscv64/bindings.rs
index f062cf45c..4df3a38dd 100644
--- a/kvm_sys/src/riscv64/bindings.rs
+++ b/kvm_sys/src/riscv64/bindings.rs
@@ -18,11 +18,14 @@ use zerocopy::KnownLayout;
 // The original index (236) used in the ChromeOS v6.6 kernel was reused upstream for another
 // capability, so this may return incorrect information on some kernels.
 pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA_CROS: u32 = 236;
+pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
+pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 
 // TODO(qwandor): Update this once the pKVM patches are merged upstream with a stable capability ID.
 pub const KVM_CAP_ARM_PROTECTED_VM: u32 = 0xffbadab1;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FW_IPA: u32 = 0;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_INFO: u32 = 1;
+pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FFA: u32 = 2;
 pub const KVM_VM_TYPE_ARM_PROTECTED: u32 = 0x80000000;
 pub const KVM_X86_PKVM_PROTECTED_VM: u32 = 28;
 pub const KVM_CAP_X86_PROTECTED_VM: u32 = 0xffbadab2;
@@ -148,7 +151,6 @@ pub const KVM_API_VERSION: u32 = 12;
 pub const KVM_MEM_LOG_DIRTY_PAGES: u32 = 1;
 pub const KVM_MEM_READONLY: u32 = 2;
 pub const KVM_MEM_GUEST_MEMFD: u32 = 4;
-pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 pub const KVM_PIT_SPEAKER_DUMMY: u32 = 1;
 pub const KVM_EXIT_HYPERV_SYNIC: u32 = 1;
 pub const KVM_EXIT_HYPERV_HCALL: u32 = 2;
@@ -467,10 +469,6 @@ pub const KVM_CAP_VM_TYPES: u32 = 235;
 pub const KVM_CAP_PRE_FAULT_MEMORY: u32 = 236;
 pub const KVM_CAP_X86_APIC_BUS_CYCLES_NS: u32 = 237;
 pub const KVM_CAP_X86_GUEST_MODE: u32 = 238;
-pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
-pub const KVM_CAP_GET_CUR_CPUFREQ: u32 = 512;
-pub const KVM_CAP_UTIL_HINT: u32 = 513;
-pub const KVM_CAP_GET_CPUFREQ_TBL: u32 = 514;
 pub const KVM_IRQ_ROUTING_IRQCHIP: u32 = 1;
 pub const KVM_IRQ_ROUTING_MSI: u32 = 2;
 pub const KVM_IRQ_ROUTING_S390_ADAPTER: u32 = 3;
@@ -693,7 +691,7 @@ pub struct __riscv_v_regset_state {
     pub vreg: __IncompleteArrayField<::std::os::raw::c_char>,
 }
 #[repr(C)]
-#[derive(Debug, Default, Copy, Clone)]
+#[derive(Debug, Default, Copy, Clone, FromBytes, Immutable, IntoBytes, KnownLayout)]
 pub struct kvm_regs {}
 #[repr(C)]
 #[derive(Debug, Default, Copy, Clone)]
diff --git a/kvm_sys/src/x86/bindings.rs b/kvm_sys/src/x86/bindings.rs
index d87d3391a..78e785442 100644
--- a/kvm_sys/src/x86/bindings.rs
+++ b/kvm_sys/src/x86/bindings.rs
@@ -18,11 +18,14 @@ use zerocopy::KnownLayout;
 // The original index (236) used in the ChromeOS v6.6 kernel was reused upstream for another
 // capability, so this may return incorrect information on some kernels.
 pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA_CROS: u32 = 236;
+pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
+pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 
 // TODO(qwandor): Update this once the pKVM patches are merged upstream with a stable capability ID.
 pub const KVM_CAP_ARM_PROTECTED_VM: u32 = 0xffbadab1;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FW_IPA: u32 = 0;
 pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_INFO: u32 = 1;
+pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FFA: u32 = 2;
 pub const KVM_VM_TYPE_ARM_PROTECTED: u32 = 0x80000000;
 pub const KVM_X86_PKVM_PROTECTED_VM: u32 = 28;
 pub const KVM_CAP_X86_PROTECTED_VM: u32 = 0xffbadab2;
@@ -340,7 +343,6 @@ pub const KVM_API_VERSION: u32 = 12;
 pub const KVM_MEM_LOG_DIRTY_PAGES: u32 = 1;
 pub const KVM_MEM_READONLY: u32 = 2;
 pub const KVM_MEM_GUEST_MEMFD: u32 = 4;
-pub const KVM_MEM_NON_COHERENT_DMA: u32 = 8;
 pub const KVM_PIT_SPEAKER_DUMMY: u32 = 1;
 pub const KVM_EXIT_HYPERV_SYNIC: u32 = 1;
 pub const KVM_EXIT_HYPERV_HCALL: u32 = 2;
@@ -668,10 +670,6 @@ pub const KVM_CAP_VM_TYPES: u32 = 235;
 pub const KVM_CAP_PRE_FAULT_MEMORY: u32 = 236;
 pub const KVM_CAP_X86_APIC_BUS_CYCLES_NS: u32 = 237;
 pub const KVM_CAP_X86_GUEST_MODE: u32 = 238;
-pub const KVM_CAP_USER_CONFIGURE_NONCOHERENT_DMA: u32 = 239;
-pub const KVM_CAP_GET_CUR_CPUFREQ: u32 = 512;
-pub const KVM_CAP_UTIL_HINT: u32 = 513;
-pub const KVM_CAP_GET_CPUFREQ_TBL: u32 = 514;
 pub const KVM_IRQ_ROUTING_IRQCHIP: u32 = 1;
 pub const KVM_IRQ_ROUTING_MSI: u32 = 2;
 pub const KVM_IRQ_ROUTING_S390_ADAPTER: u32 = 3;
diff --git a/libcras_stub/Cargo.toml b/libcras_stub/Cargo.toml
index 80d0e5743..c7eef0945 100644
--- a/libcras_stub/Cargo.toml
+++ b/libcras_stub/Cargo.toml
@@ -8,5 +8,5 @@ edition = "2021"
 path = "src/libcras.rs"
 
 [dependencies]
-audio_streams = "*"
-serde = "1"
+audio_streams = { workspace = true }
+serde = { workspace = true }
diff --git a/linux_input_sys/Cargo.toml b/linux_input_sys/Cargo.toml
index a8c273f13..d18c8651f 100644
--- a/linux_input_sys/Cargo.toml
+++ b/linux_input_sys/Cargo.toml
@@ -5,7 +5,7 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-data_model = { path = "../common/data_model" }
-libc = "0.2"
-base = { path = "../base" }
+data_model = { workspace = true }
+libc = { workspace = true }
+base = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/media/ffmpeg/Cargo.toml b/media/ffmpeg/Cargo.toml
index 213d60a5f..be747eaf1 100644
--- a/media/ffmpeg/Cargo.toml
+++ b/media/ffmpeg/Cargo.toml
@@ -5,9 +5,9 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-libc = "0.2"
-thiserror = "1"
+anyhow = { workspace = true }
+libc = { workspace = true }
+thiserror = { workspace = true }
 
 [build-dependencies]
 bindgen = "0.63"
diff --git a/media/libvda/bindgen.sh b/media/libvda/bindgen.sh
index 701432d4f..2af281718 100755
--- a/media/libvda/bindgen.sh
+++ b/media/libvda/bindgen.sh
@@ -10,6 +10,8 @@ cd "$(dirname "${BASH_SOURCE[0]}")/../.."
 
 source tools/impl/bindgen-common.sh
 
+BINDGEN_PLATFORM2="${PWD}/../../platform2"
+
 bindgen_generate \
     --allowlist-type='video_.*' \
     "${BINDGEN_PLATFORM2}/arc/vm/libvda/libvda_common.h" \
diff --git a/metrics/Cargo.toml b/metrics/Cargo.toml
index 139bacea1..9cfce6d6e 100644
--- a/metrics/Cargo.toml
+++ b/metrics/Cargo.toml
@@ -9,12 +9,12 @@ collect = []
 experimental = []
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base" }
-cfg-if = "1"
-serde = { version = "1", features = ["derive"] }
-sync = { path = "../common/sync" }
-metrics_events = { path = "../metrics_events" }
+anyhow = { workspace = true }
+base = { workspace = true }
+cfg-if = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+sync = { workspace = true }
+metrics_events = { workspace = true }
 metrics_product = { path = "../vendor/generic/metrics", package = "metrics_generic" }
 
 [target.'cfg(windows)'.dependencies]
diff --git a/metrics_events/Cargo.toml b/metrics_events/Cargo.toml
index fddca78f0..f294a0d02 100644
--- a/metrics_events/Cargo.toml
+++ b/metrics_events/Cargo.toml
@@ -5,9 +5,9 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-cfg-if = "1"
-serde = { version = "1", features = ["derive"] }
+anyhow = { workspace = true }
+cfg-if = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
 metrics_events_product = { path = "../vendor/generic/metrics_events", package = "metrics_events_generic" }
 
 [target.'cfg(windows)'.dependencies]
diff --git a/net_sys/Cargo.toml b/net_sys/Cargo.toml
index 29cf2b5f6..138e925ae 100644
--- a/net_sys/Cargo.toml
+++ b/net_sys/Cargo.toml
@@ -5,5 +5,5 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-base = { path = "../base" }
-libc = "0.2"
+base = { workspace = true }
+libc = { workspace = true }
diff --git a/net_sys/bindgen.sh b/net_sys/bindgen.sh
index 9b3549eb4..1f5272950 100755
--- a/net_sys/bindgen.sh
+++ b/net_sys/bindgen.sh
@@ -48,12 +48,12 @@ bindgen_generate \
     --allowlist-var='IFF_MULTI_QUEUE' \
     --allowlist-var='IFF_TAP' \
     --allowlist-var='IFF_VNET_HDR' \
-    "${BINDGEN_LINUX}/include/uapi/linux/if_tun.h" \
+    "${BINDGEN_LINUX_X86_HEADERS}/include/linux/if_tun.h" \
     | replace_linux_int_types \
     > net_sys/src/if_tun.rs
 
 bindgen_generate \
     --allowlist-var='SIOC.*' \
-    "${BINDGEN_LINUX}/include/uapi/linux/sockios.h" \
+    "${BINDGEN_LINUX_X86_HEADERS}/include/linux/sockios.h" \
     | replace_linux_int_types \
     > net_sys/src/sockios.rs
diff --git a/net_util/Cargo.toml b/net_util/Cargo.toml
index 7b573e2a1..86988456d 100644
--- a/net_util/Cargo.toml
+++ b/net_util/Cargo.toml
@@ -12,29 +12,29 @@ slirp-debug = ["slirp"]
 slirp-ring-capture = ["slirp"]
 
 [dependencies]
-base = { path = "../base" }
-cfg-if = "1.0.0"
-cros_async = { path = "../cros_async" }
-libc = "0.2"
+base = { workspace = true }
+cfg-if = { workspace = true }
+cros_async = { workspace = true }
+libc = { workspace = true }
 pcap-file = { version = "1.1.0", optional = true }
-remain = "0.2"
-serde = { version = "1", features = [ "derive" ] }
+remain = { workspace = true }
+serde = { workspace = true, features = [ "derive" ] }
 smallvec = "1"
-thiserror = "1"
-virtio_sys = { path = "../virtio_sys" }
+thiserror = { workspace = true }
+virtio_sys = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-net_sys = { path = "../net_sys" }
+net_sys = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
-metrics = { path = "../metrics" }
+metrics = { workspace = true }
 winapi = { version = "0.3", features = ["everything", "std", "impl-default"] }
 libslirp-sys = { version = "4.2.1", optional = true }
 
 [build-dependencies]
-anyhow = "1"
-prebuilts = { path = "../prebuilts" }
+anyhow = { workspace = true }
+prebuilts = { workspace = true }
 
 [dev-dependencies]
-serde_json = "1"
+serde_json = { workspace = true }
diff --git a/net_util/src/slirp/sys/windows.rs b/net_util/src/slirp/sys/windows.rs
index 2c9457a2d..59724c71d 100644
--- a/net_util/src/slirp/sys/windows.rs
+++ b/net_util/src/slirp/sys/windows.rs
@@ -139,9 +139,9 @@ impl Slirp {
             slirp_capture_file.take(),
         ) {
             Err(Error::Slirp(SlirpError::BrokenPipe(e))) => {
-                warn!("exited slirp listening loop: {}", e)
+                warn!("exited slirp listening loop: {:?}", e)
             }
-            Err(e) => panic!("error while running slirp listening loop: {}", e),
+            Err(e) => panic!("error while running slirp listening loop: {:?}", e),
             _ => {}
         }
     }
diff --git a/power_monitor/Cargo.toml b/power_monitor/Cargo.toml
index f92a7fafd..1ddb9e098 100644
--- a/power_monitor/Cargo.toml
+++ b/power_monitor/Cargo.toml
@@ -8,12 +8,12 @@ edition = "2021"
 powerd = ["dbus", "system_api"]
 
 [dependencies]
-base = { path = "../base" }
-dbus = { version = "0.9", optional = true }
+base = { workspace = true }
+dbus = { version = "0.9.7", optional = true }
 protobuf = "3.2"
-remain = "0.2"
-system_api = { path = "../system_api", optional = true }
-thiserror = "1.0.20"
+remain = { workspace = true }
+system_api = { workspace = true, optional = true }
+thiserror = { workspace = true }
 
 [build-dependencies]
-proto_build_tools = { path = "../proto_build_tools" }
+proto_build_tools = { workspace = true }
diff --git a/power_monitor/src/lib.rs b/power_monitor/src/lib.rs
index 80f8e3869..7e65f1222 100644
--- a/power_monitor/src/lib.rs
+++ b/power_monitor/src/lib.rs
@@ -13,7 +13,7 @@ pub trait PowerMonitor: ReadNotifier {
     fn read_message(&mut self) -> std::result::Result<Option<PowerData>, Box<dyn Error>>;
 }
 
-pub trait PowerClient {
+pub trait PowerClient: Send {
     fn get_power_data(&mut self) -> std::result::Result<PowerData, Box<dyn Error>>;
 
     /// Returns timestamp that this client sends a DBus request.
diff --git a/prebuilts/Cargo.toml b/prebuilts/Cargo.toml
index f322ac80d..0e70ca8e2 100644
--- a/prebuilts/Cargo.toml
+++ b/prebuilts/Cargo.toml
@@ -5,6 +5,6 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-cfg-if = "1"
+anyhow = { workspace = true }
+cfg-if = { workspace = true }
 named-lock = "0.3"
diff --git a/protos/Cargo.toml b/protos/Cargo.toml
index 0ca7c1d9a..f5091c80d 100644
--- a/protos/Cargo.toml
+++ b/protos/Cargo.toml
@@ -10,8 +10,8 @@ plugin = ["kvm_sys"]
 registered_events = []
 
 [dependencies]
-kvm_sys = { path = "../kvm_sys", optional = true }
+kvm_sys = { workspace = true, optional = true }
 protobuf = "3.2"
 
 [build-dependencies]
-proto_build_tools = { path = "../proto_build_tools" }
+proto_build_tools = { workspace = true }
diff --git a/resources/Cargo.toml b/resources/Cargo.toml
index 58201fbc1..fd0421944 100644
--- a/resources/Cargo.toml
+++ b/resources/Cargo.toml
@@ -5,11 +5,11 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-libc = "0.2"
-base = { path = "../base" }
-serde = { version = "1", features = ["derive"] }
-remain = "0.2"
-thiserror = "1"
+libc = { workspace = true }
+base = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+remain = { workspace = true }
+thiserror = { workspace = true }
 
 [dev-dependencies]
-serde_json = "1"
+serde_json = { workspace = true }
diff --git a/riscv64/Android.bp b/riscv64/Android.bp
index 84dc583c3..7dfb18c01 100644
--- a/riscv64/Android.bp
+++ b/riscv64/Android.bp
@@ -32,8 +32,9 @@ rust_library {
         "libkernel_cmdline",
         "liblibc",
         "libminijail_rust",
-        "librand",
+        "librand-0.8",
         "libresources",
+        "libswap",
         "libsync_rust",
         "libthiserror",
         "libvm_control",
diff --git a/riscv64/Cargo.toml b/riscv64/Cargo.toml
index 4ee165431..a86509aeb 100644
--- a/riscv64/Cargo.toml
+++ b/riscv64/Cargo.toml
@@ -6,24 +6,26 @@ edition = "2021"
 
 [features]
 gdb = ["gdbstub", "gdbstub_arch", "arch/gdb"]
+swap = ["swap/enable"]
 
 [dependencies]
-arch = { path = "../arch" }
-cros_fdt = { path = "../cros_fdt" }
-devices = { path = "../devices" }
-gdbstub = { version = "0.7.0", optional = true }
-gdbstub_arch = { version = "0.3.0", optional = true }
-hypervisor = { path = "../hypervisor" }
-kernel_cmdline = { path = "../kernel_cmdline" }
-libc = "0.2"
-rand = "0.8"
-remain = "0.2"
-resources = { path = "../resources" }
-sync = { path = "../common/sync" }
-thiserror = "1"
-base = { path = "../base" }
-vm_control = { path = "../vm_control" }
-vm_memory = { path = "../vm_memory" }
+arch = { workspace = true }
+cros_fdt = { workspace = true }
+devices = { workspace = true }
+gdbstub = { workspace = true, optional = true }
+gdbstub_arch = { workspace = true, optional = true }
+hypervisor = { workspace = true }
+kernel_cmdline = { workspace = true }
+libc = { workspace = true }
+rand = { workspace = true }
+remain = { workspace = true }
+resources = { workspace = true }
+swap = { workspace = true }
+sync = { workspace = true }
+thiserror = { workspace = true }
+base = { workspace = true }
+vm_control = { workspace = true }
+vm_memory = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
 minijail = "*"
diff --git a/riscv64/src/fdt.rs b/riscv64/src/fdt.rs
index efc6d2822..8fdfe63c8 100644
--- a/riscv64/src/fdt.rs
+++ b/riscv64/src/fdt.rs
@@ -6,6 +6,7 @@
 use std::collections::BTreeMap;
 
 use arch::apply_device_tree_overlays;
+use arch::fdt::create_memory_node;
 use arch::DtbOverlay;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use arch::PlatformBusResources;
@@ -33,34 +34,6 @@ const PHANDLE_AIA_APLIC: u32 = 2;
 const PHANDLE_AIA_IMSIC: u32 = 3;
 const PHANDLE_CPU_INTC_BASE: u32 = 4;
 
-fn create_memory_node(fdt: &mut Fdt, guest_mem: &GuestMemory) -> Result<()> {
-    let mut mem_reg_prop = Vec::new();
-    let mut previous_memory_region_end = None;
-    let mut regions = guest_mem.guest_memory_regions();
-    regions.sort();
-    for region in regions {
-        // Merge with the previous region if possible.
-        if let Some(previous_end) = previous_memory_region_end {
-            if region.0 == previous_end {
-                *mem_reg_prop.last_mut().unwrap() += region.1 as u64;
-                previous_memory_region_end =
-                    Some(previous_end.checked_add(region.1 as u64).unwrap());
-                continue;
-            }
-            assert!(region.0 > previous_end, "Memory regions overlap");
-        }
-
-        mem_reg_prop.push(region.0.offset());
-        mem_reg_prop.push(region.1 as u64);
-        previous_memory_region_end = Some(region.0.checked_add(region.1 as u64).unwrap());
-    }
-
-    let memory_node = fdt.root_mut().subnode_mut("memory")?;
-    memory_node.set_prop("device_type", "memory")?;
-    memory_node.set_prop("reg", mem_reg_prop)?;
-    Ok(())
-}
-
 fn create_cpu_nodes(fdt: &mut Fdt, num_cpus: u32, timebase_frequency: u32) -> Result<()> {
     let cpus_node = fdt.root_mut().subnode_mut("cpus")?;
     cpus_node.set_prop("#address-cells", 0x1u32)?;
@@ -240,7 +213,6 @@ fn create_pci_nodes(
 
     const IRQ_TYPE_LEVEL_HIGH: u32 = 0x00000004;
     let mut interrupts: Vec<u32> = Vec::new();
-    let mut masks: Vec<u32> = Vec::new();
 
     for (address, irq_num, irq_pin) in pci_irqs.iter() {
         // PCI_DEVICE(3)
@@ -255,15 +227,15 @@ fn create_pci_nodes(
         interrupts.push(PHANDLE_AIA_APLIC);
         interrupts.push(*irq_num);
         interrupts.push(IRQ_TYPE_LEVEL_HIGH);
+    }
 
+    let mask: &[u32] = &[
         // PCI_DEVICE(3)
-        masks.push(0xf800); // bits 11..15 (device)
-        masks.push(0);
-        masks.push(0);
-
+        0xf800, // bits 11..15 (device)
+        0, 0, // mask off other unit address cells
         // INT#(1)
-        masks.push(0x7); // allow INTA#-INTD# (1 | 2 | 3 | 4)
-    }
+        0x7, // allow INTA#-INTD# (1 | 2 | 3 | 4)
+    ];
 
     let pci_node = fdt.root_mut().subnode_mut("pci")?;
     pci_node.set_prop("compatible", "pci-host-cam-generic")?;
@@ -275,7 +247,7 @@ fn create_pci_nodes(
     pci_node.set_prop("reg", &reg)?;
     pci_node.set_prop("#interrupt-cells", 1u32)?;
     pci_node.set_prop("interrupt-map", interrupts)?;
-    pci_node.set_prop("interrupt-map-mask", masks)?;
+    pci_node.set_prop("interrupt-map-mask", mask)?;
     pci_node.set_prop("msi-parent", PHANDLE_AIA_IMSIC)?;
     pci_node.set_prop("dma-coherent", ())?;
     Ok(())
diff --git a/rust-toolchain b/rust-toolchain
index 5d46f6a5e..98da93896 100644
--- a/rust-toolchain
+++ b/rust-toolchain
@@ -1,3 +1,3 @@
 [toolchain]
-channel = "1.77.2"
+channel = "1.81.0"
 components = [ "rustfmt", "clippy", "llvm-tools-preview" ]
diff --git a/rutabaga_gfx/Android.bp b/rutabaga_gfx/Android.bp
index 48a369225..21055c0e6 100644
--- a/rutabaga_gfx/Android.bp
+++ b/rutabaga_gfx/Android.bp
@@ -18,7 +18,7 @@ rust_library {
     host_supported: true,
     crate_name: "rutabaga_gfx",
     cargo_env_compat: true,
-    cargo_pkg_version: "0.1.3",
+    cargo_pkg_version: "0.1.6",
     crate_root: "src/lib.rs",
     edition: "2021",
     features: [
@@ -26,6 +26,7 @@ rust_library {
         "virgl_renderer",
     ],
     rustlibs: [
+        "libanyhow",
         "libcfg_if",
         "liblibc",
         "liblog_rust",
@@ -72,7 +73,7 @@ rust_test {
     host_supported: true,
     crate_name: "rutabaga_gfx",
     cargo_env_compat: true,
-    cargo_pkg_version: "0.1.3",
+    cargo_pkg_version: "0.1.6",
     crate_root: "src/lib.rs",
     test_suites: ["general-tests"],
     auto_gen_config: true,
@@ -85,6 +86,7 @@ rust_test {
         "virgl_renderer",
     ],
     rustlibs: [
+        "libanyhow",
         "libcfg_if",
         "liblibc",
         "liblog_rust",
@@ -96,11 +98,24 @@ rust_test {
         "libzerocopy",
     ],
     proc_macros: ["libremain"],
-    shared_libs: [
+    static_libs: [
         "libepoxy",
         "libgfxstream_backend",
         "libvirglrenderer",
     ],
+    shared_libs: [
+        "libc++",
+        "libbase",
+    ],
+    target: {
+        android: {
+            shared_libs: [
+                "libnativewindow",
+                "libcutils",
+                "liblog",
+            ],
+        },
+    },
 }
 
 // Manually written variant of librutabaga_gfx.
@@ -115,6 +130,7 @@ rust_library {
     srcs: ["src/lib.rs"],
     edition: "2021",
     rustlibs: [
+        "libanyhow",
         "libcfg_if",
         "liblibc",
         "liblog_rust",
diff --git a/rutabaga_gfx/Android.bp.extra b/rutabaga_gfx/Android.bp.extra
index b3b4ca9fa..ae5b25389 100644
--- a/rutabaga_gfx/Android.bp.extra
+++ b/rutabaga_gfx/Android.bp.extra
@@ -10,6 +10,7 @@ rust_library {
     srcs: ["src/lib.rs"],
     edition: "2021",
     rustlibs: [
+	"libanyhow",
         "libcfg_if",
         "liblibc",
         "liblog_rust",
diff --git a/rutabaga_gfx/Cargo.toml b/rutabaga_gfx/Cargo.toml
index 103bb8fd2..ac29c4db6 100644
--- a/rutabaga_gfx/Cargo.toml
+++ b/rutabaga_gfx/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "rutabaga_gfx"
-version = "0.1.3"
+version = "0.1.6"
 authors = ["The ChromiumOS Authors + Android Open Source Project"]
 edition = "2021"
 description = "Handling virtio-gpu protocols"
@@ -16,16 +16,16 @@ vulkano = ["dep:vulkano"]
 x = []
 
 [dependencies]
+anyhow = "1"
 cfg-if = "1.0.0"
-libc = "0.2.116"
+libc = "0.2.153"
+log = "0.4"
 remain = "0.2"
-serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 thiserror = "1.0.23"
+serde = { version = "1.0", features = ["derive"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
-log = "0.4"
-
 # To build latest Vulkano, change version to git = "https://github.com/vulkano-rs/vulkano.git"
 vulkano = { version = "0.33.0", optional = true }
 
@@ -37,7 +37,7 @@ winapi = {version = "0.3", features = ["winnt", "handleapi", "processthreadsapi"
 
 [build-dependencies]
 pkg-config = "0.3"
-anyhow = "1"
+anyhow = { workspace = true }
 
 [dev-dependencies]
 tempfile = "3"
diff --git a/rutabaga_gfx/build.rs b/rutabaga_gfx/build.rs
index 2c473cd12..3f197390f 100644
--- a/rutabaga_gfx/build.rs
+++ b/rutabaga_gfx/build.rs
@@ -244,7 +244,22 @@ fn virglrenderer() -> Result<()> {
 }
 
 fn gfxstream() -> Result<()> {
-    if let Ok(gfxstream_path) = env::var("GFXSTREAM_PATH") {
+    let mut gfxstream_path_env_override =
+        // We use the unrecommended PROFILE environment variable here, because the Windows
+        // downstream can set debug = true for the release profile to keep the symbol files.
+        if env::var("PROFILE").as_deref() == Ok("debug") {
+            env::var("GFXSTREAM_PATH_DEBUG")
+        } else {
+            env::var("GFXSTREAM_PATH_RELEASE")
+        }
+        .ok();
+    gfxstream_path_env_override = gfxstream_path_env_override.filter(|s| !s.is_empty());
+    if gfxstream_path_env_override.is_none() {
+        gfxstream_path_env_override = env::var("GFXSTREAM_PATH").ok();
+    }
+    gfxstream_path_env_override = gfxstream_path_env_override.filter(|s| !s.is_empty());
+
+    if let Some(gfxstream_path) = gfxstream_path_env_override {
         println!("cargo:rustc-link-lib=gfxstream_backend");
         println!("cargo:rustc-link-search={}", gfxstream_path);
         Ok(())
diff --git a/rutabaga_gfx/ffi/Cargo.toml b/rutabaga_gfx/ffi/Cargo.toml
index 8842efd25..ba603d59e 100644
--- a/rutabaga_gfx/ffi/Cargo.toml
+++ b/rutabaga_gfx/ffi/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "rutabaga_gfx_ffi"
-version = "0.1.3"
+version = "0.1.6"
 authors = ["The ChromiumOS Authors + Android Open Source Project"]
 edition = "2021"
 description = "Handling virtio-gpu protocols with C API"
@@ -11,10 +11,9 @@ name = "rutabaga_gfx_ffi"
 crate-type = ["cdylib", "staticlib"]
 
 [dependencies]
-rutabaga_gfx = { path = "../", version = "0.1.3"}
+rutabaga_gfx = { path = "../", version = "0.1.6"}
 libc = "0.2.93"
 log = "0.4"
-once_cell = "1.7"
 
 [features]
 minigbm = ["rutabaga_gfx/minigbm"]
diff --git a/rutabaga_gfx/ffi/build.rs b/rutabaga_gfx/ffi/build.rs
index 3a407c711..030ee69ba 100644
--- a/rutabaga_gfx/ffi/build.rs
+++ b/rutabaga_gfx/ffi/build.rs
@@ -26,7 +26,7 @@ libdir=${exec_prefix}/lib
 
 Name: rutabaga_gfx_ffi
 Description: C FFI bindings to Rutabaga VGI
-Version: 0.1.3
+Version: 0.1.6
 Cflags: -I${includedir}
 Libs: -L${libdir} -lrutabaga_gfx_ffi
 "###,
diff --git a/rutabaga_gfx/ffi/meson.build b/rutabaga_gfx/ffi/meson.build
index a384202e2..7cec65893 100644
--- a/rutabaga_gfx/ffi/meson.build
+++ b/rutabaga_gfx/ffi/meson.build
@@ -3,7 +3,7 @@
 # found in the LICENSE file.
 
 project('rutabaga_gfx_ffi', ['rust', 'c'],
-         version: '0.1.3')
+         version: '0.1.6')
 
 target_os = host_machine.system()
 
diff --git a/rutabaga_gfx/ffi/src/include/rutabaga_gfx_ffi.h b/rutabaga_gfx/ffi/src/include/rutabaga_gfx_ffi.h
index f5ab0007d..3bb1e2fd9 100644
--- a/rutabaga_gfx/ffi/src/include/rutabaga_gfx_ffi.h
+++ b/rutabaga_gfx/ffi/src/include/rutabaga_gfx_ffi.h
@@ -27,7 +27,7 @@ extern "C" {
  */
 #define RUTABAGA_VERSION_MAJOR 0
 #define RUTABAGA_VERSION_MINOR 1
-#define RUTABAGA_VERSION_PATCH 3
+#define RUTABAGA_VERSION_PATCH 6
 
 /**
  * Rutabaga capsets.
@@ -111,6 +111,8 @@ extern "C" {
 #define RUTABAGA_DEBUG_WARN 0x2
 #define RUTABAGA_DEBUG_INFO 0x3
 
+#ifdef RUTABAGA_GFX_FFI_UNSTABLE
+
 /**
  * Rutabaga resource import flags
  */
@@ -119,6 +121,8 @@ extern "C" {
 #define RUTABAGA_IMPORT_FLAG_RESOURCE_EXISTS (1 << 30)
 #define RUTABAGA_IMPORT_FLAG_PRESERVE_CONTENT (1 << 31)
 
+#endif
+
 struct rutabaga;
 
 struct rutabaga_create_blob {
@@ -141,6 +145,8 @@ struct rutabaga_create_3d {
     uint32_t flags;
 };
 
+#ifdef RUTABAGA_GFX_FFI_UNSTABLE
+
 struct rutabaga_import_data {
     uint32_t flags;
     struct {
@@ -154,6 +160,8 @@ struct rutabaga_import_data {
     } info_3d;
 };
 
+#endif
+
 struct rutabaga_transfer {
     uint32_t x;
     uint32_t y;
@@ -187,11 +195,10 @@ struct rutabaga_command {
     uint32_t cmd_size;
     uint8_t *cmd;
 
-    /**
-     * Unstable, don't use until version > 0.1.3
-     */
+#ifdef RUTABAGA_GFX_FFI_UNSTABLE
     uint32_t num_in_fences;
     uint64_t *fence_ids;
+#endif
 };
 
 /**
@@ -371,12 +378,13 @@ int32_t rutabaga_submit_command(struct rutabaga *ptr, struct rutabaga_command *c
 
 int32_t rutabaga_create_fence(struct rutabaga *ptr, const struct rutabaga_fence *fence);
 
+#ifdef RUTABAGA_GFX_FFI_UNSTABLE
+
 /**
  * Write a snapshot to `dir`. The directory is expected to already exist and to be empty.
  *
  * # Safety
  * - `dir` must be a null-terminated C-string.
- * - Unstable, don't use until version > 0.1.3
  */
 int32_t rutabaga_snapshot(struct rutabaga *ptr, const char *dir);
 
@@ -385,7 +393,6 @@ int32_t rutabaga_snapshot(struct rutabaga *ptr, const char *dir);
  *
  * # Safety
  * - `dir` must be a null-terminated C-string.
- * - Unstable, don't use until version > 0.1.3
  */
 int32_t rutabaga_restore(struct rutabaga *ptr, const char *dir);
 
@@ -393,6 +400,8 @@ int32_t rutabaga_resource_import(struct rutabaga *ptr, uint32_t resource_id,
                                  const struct rutabaga_handle *import_handle,
                                  const struct rutabaga_import_data *import_data);
 
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/rutabaga_gfx/ffi/src/lib.rs b/rutabaga_gfx/ffi/src/lib.rs
index b134c45c3..16b018666 100644
--- a/rutabaga_gfx/ffi/src/lib.rs
+++ b/rutabaga_gfx/ffi/src/lib.rs
@@ -10,7 +10,6 @@ use std::cell::RefCell;
 use std::convert::TryInto;
 use std::ffi::CStr;
 use std::ffi::CString;
-use std::fs::File;
 use std::io::IoSliceMut;
 use std::os::raw::c_char;
 use std::os::raw::c_void;
@@ -98,18 +97,6 @@ macro_rules! return_on_error {
     };
 }
 
-macro_rules! return_on_io_error {
-    ($result:expr) => {
-        match $result {
-            Ok(t) => t,
-            Err(e) => {
-                log_error(e.to_string());
-                return -e.raw_os_error().unwrap_or(EINVAL);
-            }
-        }
-    };
-}
-
 #[allow(non_camel_case_types)]
 type rutabaga = Rutabaga;
 
@@ -699,7 +686,7 @@ pub unsafe extern "C" fn rutabaga_snapshot(ptr: &mut rutabaga, dir: *const c_cha
         let result = c_str_slice.to_str();
         let directory = return_on_error!(result);
 
-        let result = ptr.snapshot(directory);
+        let result = ptr.snapshot(Path::new(directory));
         return_result(result)
     }))
     .unwrap_or(-ESRCH)
@@ -715,7 +702,7 @@ pub unsafe extern "C" fn rutabaga_restore(ptr: &mut rutabaga, dir: *const c_char
         let result = c_str_slice.to_str();
         let directory = return_on_error!(result);
 
-        let result = ptr.restore(directory);
+        let result = ptr.restore(Path::new(directory));
         return_result(result)
     }))
     .unwrap_or(-ESRCH)
diff --git a/rutabaga_gfx/kumquat/gpu_client/Android.bp b/rutabaga_gfx/kumquat/gpu_client/Android.bp
index 8911f567f..b6ae44d57 100644
--- a/rutabaga_gfx/kumquat/gpu_client/Android.bp
+++ b/rutabaga_gfx/kumquat/gpu_client/Android.bp
@@ -31,6 +31,7 @@ rust_ffi_shared {
     vendor_available: true,
     srcs: ["src/lib.rs"],
     rustlibs: [
+        "libanyhow",
         "librutabaga_gfx_gfxstream",
         "liblibc",
         "liblog_rust",
diff --git a/rutabaga_gfx/kumquat/gpu_client/Cargo.toml b/rutabaga_gfx/kumquat/gpu_client/Cargo.toml
index 56ff57bcf..ae8280261 100644
--- a/rutabaga_gfx/kumquat/gpu_client/Cargo.toml
+++ b/rutabaga_gfx/kumquat/gpu_client/Cargo.toml
@@ -11,7 +11,8 @@ name = "virtgpu_kumquat_ffi"
 crate-type = ["cdylib", "staticlib"]
 
 [dependencies]
-rutabaga_gfx = { path = "../../", version = "0.1.3"}
+anyhow = "1"
+rutabaga_gfx = { path = "../../", version = "0.1.6"}
 zerocopy = { version = "0.8.13", features = ["derive"] }
 libc = "0.2.93"
 log = "0.4"
@@ -21,6 +22,6 @@ lto = true
 incremental = false
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-nix = { version = "0.28", features = ["event", "feature", "fs", "mman", "socket", "uio", "ioctl"] }
+nix = { version = "0.29", features = ["event", "feature", "fs", "mman", "socket", "uio", "ioctl"] }
 
 [workspace]
diff --git a/rutabaga_gfx/kumquat/gpu_client/src/include/virtgpu_kumquat_ffi.h b/rutabaga_gfx/kumquat/gpu_client/src/include/virtgpu_kumquat_ffi.h
index 8946a4d8b..cae89e8c4 100644
--- a/rutabaga_gfx/kumquat/gpu_client/src/include/virtgpu_kumquat_ffi.h
+++ b/rutabaga_gfx/kumquat/gpu_client/src/include/virtgpu_kumquat_ffi.h
@@ -93,11 +93,19 @@ struct drm_kumquat_resource_create_3d {
     uint32_t stride;
 };
 
+struct drm_kumquat_vk_device_id {
+    uint8_t device_uuid[16];
+    uint8_t driver_uuid[16];
+};
+
+struct drm_kumquat_vk_info {
+    uint32_t memory_idx;
+    struct drm_kumquat_vk_device_id device_id;
+};
+
 struct drm_kumquat_resource_info {
     uint32_t bo_handle;
-    uint32_t res_handle;
-    uint32_t size;
-    uint32_t blob_mem;
+    struct drm_kumquat_vk_info vulkan_info;
 };
 
 struct drm_kumquat_3d_box {
@@ -264,6 +272,9 @@ int32_t virtgpu_kumquat_resource_export(struct virtgpu_kumquat *ptr,
 int32_t virtgpu_kumquat_resource_import(struct virtgpu_kumquat *ptr,
                                         struct drm_kumquat_resource_import *cmd);
 
+int32_t virtgpu_kumquat_resource_info(struct virtgpu_kumquat *ptr,
+                                      struct drm_kumquat_resource_info *cmd);
+
 int32_t virtgpu_kumquat_snapshot_save(struct virtgpu_kumquat *ptr);
 
 int32_t virtgpu_kumquat_snapshot_restore(struct virtgpu_kumquat *ptr);
diff --git a/rutabaga_gfx/kumquat/gpu_client/src/lib.rs b/rutabaga_gfx/kumquat/gpu_client/src/lib.rs
index e2d280dad..556808fcd 100644
--- a/rutabaga_gfx/kumquat/gpu_client/src/lib.rs
+++ b/rutabaga_gfx/kumquat/gpu_client/src/lib.rs
@@ -98,6 +98,9 @@ type drm_kumquat_resource_export = VirtGpuResourceExport;
 #[allow(non_camel_case_types)]
 type drm_kumquat_resource_import = VirtGpuResourceImport;
 
+#[allow(non_camel_case_types)]
+type drm_kumquat_resource_info = VirtGpuResourceInfo;
+
 #[no_mangle]
 pub unsafe extern "C" fn virtgpu_kumquat_init(
     ptr: &mut *mut virtgpu_kumquat,
@@ -149,7 +152,11 @@ pub unsafe extern "C" fn virtgpu_kumquat_get_caps(
     cmd: &drm_kumquat_get_caps,
 ) -> i32 {
     catch_unwind(AssertUnwindSafe(|| {
-        let caps_slice = from_raw_parts_mut(cmd.addr as *mut u8, cmd.size as usize);
+        let caps_slice = if cmd.size != 0 {
+            from_raw_parts_mut(cmd.addr as *mut u8, cmd.size as usize)
+        } else {
+            &mut []
+        };
         let result = ptr.lock().unwrap().get_caps(cmd.cap_set_id, caps_slice);
         return_result(result)
     }))
@@ -162,10 +169,14 @@ pub unsafe extern "C" fn virtgpu_kumquat_context_init(
     cmd: &drm_kumquat_context_init,
 ) -> i32 {
     catch_unwind(AssertUnwindSafe(|| {
-        let context_params: &[VirtGpuParam] = from_raw_parts(
-            cmd.ctx_set_params as *const VirtGpuParam,
-            cmd.num_params as usize,
-        );
+        let context_params: &[VirtGpuParam] = if cmd.num_params != 0 {
+            from_raw_parts(
+                cmd.ctx_set_params as *const VirtGpuParam,
+                cmd.num_params as usize,
+            )
+        } else {
+            &[]
+        };
 
         let mut capset_id: u64 = 0;
 
@@ -202,7 +213,11 @@ pub unsafe extern "C" fn virtgpu_kumquat_resource_create_blob(
     cmd: &mut drm_kumquat_resource_create_blob,
 ) -> i32 {
     catch_unwind(AssertUnwindSafe(|| {
-        let blob_cmd = from_raw_parts(cmd.cmd as *const u8, cmd.cmd_size as usize);
+        let blob_cmd = if cmd.cmd_size != 0 {
+            from_raw_parts(cmd.cmd as *const u8, cmd.cmd_size as usize)
+        } else {
+            &[]
+        };
         let result = ptr.lock().unwrap().resource_create_blob(cmd, blob_cmd);
         return_result(result)
     }))
@@ -278,8 +293,17 @@ pub unsafe extern "C" fn virtgpu_kumquat_execbuffer(
     cmd: &mut drm_kumquat_execbuffer,
 ) -> i32 {
     catch_unwind(AssertUnwindSafe(|| {
-        let bo_handles = from_raw_parts(cmd.bo_handles as *const u32, cmd.num_bo_handles as usize);
-        let cmd_buf = from_raw_parts(cmd.command as *const u8, cmd.size as usize);
+        let bo_handles = if cmd.num_bo_handles != 0 {
+            from_raw_parts(cmd.bo_handles as *const u32, cmd.num_bo_handles as usize)
+        } else {
+            &[]
+        };
+
+        let cmd_buf = if cmd.size != 0 {
+            from_raw_parts(cmd.command as *const u8, cmd.size as usize)
+        } else {
+            &[]
+        };
 
         // TODO
         let in_fences: &[u64] = &[0; 0];
@@ -356,6 +380,21 @@ pub unsafe extern "C" fn virtgpu_kumquat_resource_import(
     .unwrap_or(-ESRCH)
 }
 
+#[no_mangle]
+pub extern "C" fn virtgpu_kumquat_resource_info(
+    ptr: &mut virtgpu_kumquat,
+    cmd: &mut drm_kumquat_resource_info,
+) -> i32 {
+    catch_unwind(AssertUnwindSafe(|| {
+        let result = ptr.lock().unwrap().resource_info(cmd.bo_handle);
+
+        let info = return_on_error!(result);
+        (*cmd).vulkan_info = info;
+        NO_ERROR
+    }))
+    .unwrap_or(-ESRCH)
+}
+
 #[no_mangle]
 pub unsafe extern "C" fn virtgpu_kumquat_snapshot_save(ptr: &mut virtgpu_kumquat) -> i32 {
     catch_unwind(AssertUnwindSafe(|| {
diff --git a/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/defines.rs b/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/defines.rs
index bc50504e1..965bb10e8 100644
--- a/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/defines.rs
+++ b/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/defines.rs
@@ -4,6 +4,8 @@
 
 use std::os::raw::c_void;
 
+use rutabaga_gfx::VulkanInfo;
+
 pub const VIRTGPU_KUMQUAT_PARAM_3D_FEATURES: u64 = 1;
 pub const VIRTGPU_KUMQUAT_PARAM_CAPSET_QUERY_FIX: u64 = 2;
 #[allow(unused)]
@@ -174,3 +176,10 @@ pub struct VirtGpuResourceImport {
     pub res_handle: u32,
     pub size: u64,
 }
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+pub struct VirtGpuResourceInfo {
+    pub bo_handle: u32,
+    pub vulkan_info: VulkanInfo,
+}
diff --git a/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/virtgpu_kumquat.rs b/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/virtgpu_kumquat.rs
index 8ec7e915e..b62456d2a 100644
--- a/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/virtgpu_kumquat.rs
+++ b/rutabaga_gfx/kumquat/gpu_client/src/virtgpu/virtgpu_kumquat.rs
@@ -10,6 +10,7 @@ use std::slice::from_raw_parts_mut;
 use std::sync::Mutex;
 use std::sync::OnceLock;
 
+use anyhow::Context;
 use rutabaga_gfx::kumquat_support::kumquat_gpu_protocol::*;
 use rutabaga_gfx::kumquat_support::RutabagaEvent;
 use rutabaga_gfx::kumquat_support::RutabagaMemoryMapping;
@@ -21,6 +22,7 @@ use rutabaga_gfx::kumquat_support::RutabagaTubeType;
 use rutabaga_gfx::kumquat_support::RutabagaWriter;
 use rutabaga_gfx::RutabagaDescriptor;
 use rutabaga_gfx::RutabagaError;
+use rutabaga_gfx::RutabagaErrorKind;
 use rutabaga_gfx::RutabagaGralloc;
 use rutabaga_gfx::RutabagaGrallocBackendFlags;
 use rutabaga_gfx::RutabagaHandle;
@@ -130,7 +132,7 @@ impl VirtGpuKumquat {
         let mut protocols = stream.read()?;
         let num_capsets = match protocols.remove(0) {
             KumquatGpuProtocol::RespNumCapsets(num) => num,
-            _ => return Err(RutabagaError::Unsupported),
+            _ => return Err(RutabagaErrorKind::Unsupported.into()),
         };
 
         let mut capset_mask = 0;
@@ -145,7 +147,7 @@ impl VirtGpuKumquat {
             protocols = stream.read()?;
             let resp_capset_info = match protocols.remove(0) {
                 KumquatGpuProtocol::RespCapsetInfo(info) => info,
-                _ => return Err(RutabagaError::Unsupported),
+                _ => return Err(RutabagaErrorKind::Unsupported.into()),
             };
 
             let get_capset = kumquat_gpu_protocol_get_capset {
@@ -161,7 +163,7 @@ impl VirtGpuKumquat {
             protocols = stream.read()?;
             let capset = match protocols.remove(0) {
                 KumquatGpuProtocol::RespCapset(capset) => capset,
-                _ => return Err(RutabagaError::Unsupported),
+                _ => return Err(RutabagaErrorKind::Unsupported.into()),
             };
 
             capset_mask = 1u64 << resp_capset_info.capset_id | capset_mask;
@@ -190,7 +192,7 @@ impl VirtGpuKumquat {
             VIRTGPU_KUMQUAT_PARAM_SUPPORTED_CAPSET_IDS => self.capset_mask,
             VIRTGPU_KUMQUAT_PARAM_EXPLICIT_DEBUG_NAME => 0,
             VIRTGPU_KUMQUAT_PARAM_FENCE_PASSING => 1,
-            _ => return Err(RutabagaError::Unsupported),
+            _ => return Err(RutabagaErrorKind::Unsupported.into()),
         };
 
         Ok(())
@@ -200,7 +202,7 @@ impl VirtGpuKumquat {
         let caps = self
             .capsets
             .get(&capset_id)
-            .ok_or(RutabagaError::InvalidCapset)?;
+            .ok_or(RutabagaErrorKind::InvalidCapset)?;
         let length = min(slice.len(), caps.len());
         slice.copy_from_slice(&caps[0..length]);
         Ok(())
@@ -228,7 +230,7 @@ impl VirtGpuKumquat {
         let mut protocols = self.stream.read()?;
         self.context_id = match protocols.remove(0) {
             KumquatGpuProtocol::RespContextCreate(ctx_id) => ctx_id,
-            _ => return Err(RutabagaError::Unsupported),
+            _ => return Err(RutabagaErrorKind::Unsupported.into()),
         };
 
         Ok(self.context_id)
@@ -266,7 +268,7 @@ impl VirtGpuKumquat {
                 let size: usize = create_3d.size.try_into()?;
                 VirtGpuResource::new(resp.resource_id, size, handle, resp.vulkan_info)
             }
-            _ => return Err(RutabagaError::Unsupported),
+            _ => return Err(RutabagaErrorKind::Unsupported.into()),
         };
 
         create_3d.res_handle = resource.resource_id;
@@ -325,7 +327,7 @@ impl VirtGpuKumquat {
                 VirtGpuResource::new(resp.resource_id, size, handle, resp.vulkan_info)
             }
             _ => {
-                return Err(RutabagaError::Unsupported);
+                return Err(RutabagaErrorKind::Unsupported.into());
             }
         };
 
@@ -339,7 +341,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .remove(&bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let detach_resource = kumquat_gpu_protocol_ctx_resource {
             hdr: kumquat_gpu_protocol_ctrl_hdr {
@@ -360,7 +362,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .get_mut(&bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         if let Some(ref system_mapping) = resource.system_mapping {
             let rutabaga_mapping = system_mapping.as_rutabaga_mapping();
@@ -399,7 +401,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .get_mut(&bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         resource.system_mapping = None;
         resource.gpu_mapping = None;
@@ -410,7 +412,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .get_mut(&transfer.bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let event = RutabagaEvent::new()?;
         let emulated_fence: RutabagaHandle = event.into();
@@ -450,7 +452,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .get_mut(&transfer.bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let event = RutabagaEvent::new()?;
         let emulated_fence: RutabagaHandle = event.into();
@@ -541,20 +543,20 @@ impl VirtGpuKumquat {
             let fence = match protocols.remove(0) {
                 KumquatGpuProtocol::RespCmdSubmit3d(_fence_id, handle) => handle,
                 _ => {
-                    return Err(RutabagaError::Unsupported);
+                    return Err(RutabagaErrorKind::Unsupported.into());
                 }
             };
 
             for handle in bo_handles {
                 // We could support implicit sync with real fences, but the need does not exist.
                 if actual_fence {
-                    return Err(RutabagaError::Unsupported);
+                    return Err(RutabagaErrorKind::Unsupported.into());
                 }
 
                 let resource = self
                     .resources
                     .get_mut(handle)
-                    .ok_or(RutabagaError::InvalidResourceId)?;
+                    .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
                 resource.attached_fences.push(fence.try_clone()?);
             }
@@ -567,7 +569,8 @@ impl VirtGpuKumquat {
 
         if flags & VIRTGPU_KUMQUAT_EXECBUF_FENCE_FD_OUT != 0 {
             *raw_descriptor = fence_opt
-                .ok_or(RutabagaError::SpecViolation("no fence found"))?
+                .context("no fence found")
+                .context(RutabagaErrorKind::SpecViolation)?
                 .os_handle
                 .into_raw_descriptor();
         }
@@ -579,7 +582,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .get_mut(&bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let new_fences: Vec<RutabagaHandle> = std::mem::take(&mut resource.attached_fences);
         for fence in new_fences {
@@ -598,7 +601,7 @@ impl VirtGpuKumquat {
         let resource = self
             .resources
             .get_mut(&bo_handle)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         if flags & VIRTGPU_KUMQUAT_EMULATED_EXPORT != 0 {
             let descriptor: RutabagaDescriptor =
@@ -681,6 +684,15 @@ impl VirtGpuKumquat {
         Ok(())
     }
 
+    pub fn resource_info(&self, bo_handle: u32) -> RutabagaResult<VulkanInfo> {
+        let resource = self
+            .resources
+            .get(&bo_handle)
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
+
+        Ok(resource.vulkan_info)
+    }
+
     pub fn snapshot(&mut self) -> RutabagaResult<()> {
         let snapshot_save = kumquat_gpu_protocol_ctrl_hdr {
             type_: KUMQUAT_GPU_PROTOCOL_SNAPSHOT_SAVE,
@@ -693,7 +705,7 @@ impl VirtGpuKumquat {
         let mut protocols = self.stream.read()?;
         match protocols.remove(0) {
             KumquatGpuProtocol::RespOkSnapshot => Ok(()),
-            _ => Err(RutabagaError::Unsupported),
+            _ => Err(RutabagaErrorKind::Unsupported.into()),
         }
     }
 
@@ -709,7 +721,7 @@ impl VirtGpuKumquat {
         let mut protocols = self.stream.read()?;
         match protocols.remove(0) {
             KumquatGpuProtocol::RespOkSnapshot => Ok(()),
-            _ => Err(RutabagaError::Unsupported),
+            _ => Err(RutabagaErrorKind::Unsupported.into()),
         }
     }
 }
diff --git a/rutabaga_gfx/kumquat/server/Android.bp b/rutabaga_gfx/kumquat/server/Android.bp
index df22a1d3b..57532070c 100644
--- a/rutabaga_gfx/kumquat/server/Android.bp
+++ b/rutabaga_gfx/kumquat/server/Android.bp
@@ -24,6 +24,7 @@ rust_binary {
         "gfxstream",
     ],
     rustlibs: [
+        "libanyhow",
         "librutabaga_gfx_gfxstream",
         "liblibc",
         "liblog_rust",
diff --git a/rutabaga_gfx/kumquat/server/Cargo.toml b/rutabaga_gfx/kumquat/server/Cargo.toml
index 08131adff..95b3ca6c2 100644
--- a/rutabaga_gfx/kumquat/server/Cargo.toml
+++ b/rutabaga_gfx/kumquat/server/Cargo.toml
@@ -14,8 +14,9 @@ path = "src/main.rs"
 gfxstream = ["rutabaga_gfx/gfxstream"]
 
 [dependencies]
-rutabaga_gfx = { path = "../../", version = "0.1.3"}
-nix = { version = "0.28", features = ["event", "feature", "fs", "mman", "socket", "uio", "ioctl"] }
+anyhow = "1"
+rutabaga_gfx = { path = "../../", version = "0.1.6"}
+nix = { version = "0.29", features = ["event", "feature", "fs", "mman", "socket", "uio", "ioctl"] }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 log = "0.4"
 clap = { version = "4.1.8", features = ["derive"] }
diff --git a/rutabaga_gfx/kumquat/server/src/kumquat.rs b/rutabaga_gfx/kumquat/server/src/kumquat.rs
index 2355440ef..a04b30d1f 100644
--- a/rutabaga_gfx/kumquat/server/src/kumquat.rs
+++ b/rutabaga_gfx/kumquat/server/src/kumquat.rs
@@ -10,7 +10,7 @@ use rutabaga_gfx::kumquat_support::RutabagaListener;
 use rutabaga_gfx::kumquat_support::RutabagaWaitContext;
 use rutabaga_gfx::kumquat_support::RutabagaWaitTimeout;
 use rutabaga_gfx::RutabagaAsBorrowedDescriptor as AsBorrowedDescriptor;
-use rutabaga_gfx::RutabagaError;
+use rutabaga_gfx::RutabagaErrorKind;
 use rutabaga_gfx::RutabagaResult;
 
 use crate::kumquat_gpu::KumquatGpu;
@@ -69,7 +69,9 @@ impl Kumquat {
                     }
                 }
                 Entry::Vacant(_) => {
-                    return Err(RutabagaError::SpecViolation("no connection found"))
+                    return Err(anyhow::anyhow!("no connection found")
+                        .context(RutabagaErrorKind::SpecViolation)
+                        .into())
                 }
             }
         }
diff --git a/rutabaga_gfx/kumquat/server/src/kumquat_gpu/mod.rs b/rutabaga_gfx/kumquat/server/src/kumquat_gpu/mod.rs
index 40991eb80..06798a30f 100644
--- a/rutabaga_gfx/kumquat/server/src/kumquat_gpu/mod.rs
+++ b/rutabaga_gfx/kumquat/server/src/kumquat_gpu/mod.rs
@@ -11,6 +11,7 @@ use std::path::Path;
 use std::sync::Arc;
 use std::sync::Mutex;
 
+use anyhow::Context;
 use log::error;
 use rutabaga_gfx::calculate_capset_mask;
 use rutabaga_gfx::kumquat_support::kumquat_gpu_protocol::*;
@@ -27,6 +28,7 @@ use rutabaga_gfx::RutabagaBuilder;
 use rutabaga_gfx::RutabagaComponentType;
 use rutabaga_gfx::RutabagaDescriptor;
 use rutabaga_gfx::RutabagaError;
+use rutabaga_gfx::RutabagaErrorKind;
 use rutabaga_gfx::RutabagaFence;
 use rutabaga_gfx::RutabagaFenceHandler;
 use rutabaga_gfx::RutabagaHandle;
@@ -202,7 +204,7 @@ impl KumquatGpuConnection {
                     let mut resource = kumquat_gpu
                         .resources
                         .remove(&cmd.resource_id)
-                        .ok_or(RutabagaError::InvalidResourceId)?;
+                        .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
                     resource.attached_contexts.remove(&cmd.ctx_id);
                     if resource.attached_contexts.len() == 0 {
@@ -368,7 +370,8 @@ impl KumquatGpuConnection {
                         }
 
                         let fence_descriptor = fence_descriptor_opt
-                            .ok_or(RutabagaError::SpecViolation("No fence descriptor"))?;
+                            .context("No fence descriptor")
+                            .context(RutabagaErrorKind::SpecViolation)?;
 
                         let resp = kumquat_gpu_protocol_resp_cmd_submit_3d {
                             hdr: kumquat_gpu_protocol_ctrl_hdr {
@@ -460,7 +463,7 @@ impl KumquatGpuConnection {
                 }
                 _ => {
                     error!("Unsupported protocol {:?}", protocol);
-                    return Err(RutabagaError::Unsupported);
+                    return Err(RutabagaErrorKind::Unsupported.into());
                 }
             };
         }
diff --git a/rutabaga_gfx/patches/Android.bp.patch b/rutabaga_gfx/patches/Android.bp.patch
index 4a2b7af61..8a7d56679 100644
--- a/rutabaga_gfx/patches/Android.bp.patch
+++ b/rutabaga_gfx/patches/Android.bp.patch
@@ -1,5 +1,5 @@
 diff --git a/rutabaga_gfx/Android.bp b/rutabaga_gfx/Android.bp
-index 3358d5055..b6bc63efa 100644
+index c61b60a1a..48a369225 100644
 --- a/rutabaga_gfx/Android.bp
 +++ b/rutabaga_gfx/Android.bp
 @@ -23,7 +23,6 @@ rust_library {
@@ -10,16 +10,17 @@ index 3358d5055..b6bc63efa 100644
          "virgl_renderer",
      ],
      rustlibs: [
-@@ -37,11 +36,34 @@ rust_library {
+@@ -37,9 +36,34 @@ rust_library {
          "libzerocopy",
      ],
      proc_macros: ["libremain"],
--    shared_libs: [
+-    static_libs: ["libvirglrenderer"],
+-    shared_libs: ["libepoxy"],
 +    static_libs: [
-         "libepoxy",
++        "libepoxy",
 +        "libgfxstream_backend",
-         "libvirglrenderer",
-     ],
++        "libvirglrenderer",
++    ],
 +    shared_libs: [
 +        "libc++",
 +        "libbase",
@@ -44,9 +45,9 @@ index 3358d5055..b6bc63efa 100644
 +        },
 +    },
  }
- 
+
  rust_test {
-@@ -60,7 +82,6 @@ rust_test {
+@@ -58,7 +82,6 @@ rust_test {
      edition: "2021",
      features: [
          "gfxstream",
@@ -54,11 +55,30 @@ index 3358d5055..b6bc63efa 100644
          "virgl_renderer",
      ],
      rustlibs: [
-@@ -77,6 +98,7 @@ rust_test {
+@@ -73,8 +96,24 @@ rust_test {
+         "libzerocopy",
+     ],
      proc_macros: ["libremain"],
-     shared_libs: [
-         "libepoxy",
+-    static_libs: ["libvirglrenderer"],
+-    shared_libs: ["libepoxy"],
++    static_libs: [
++        "libepoxy",
 +        "libgfxstream_backend",
-         "libvirglrenderer",
-     ],
++        "libvirglrenderer",
++    ],
++    shared_libs: [
++        "libc++",
++        "libbase",
++    ],
++    target: {
++        android: {
++            shared_libs: [
++                "libnativewindow",
++                "libcutils",
++                "liblog",
++            ],
++        },
++    },
  }
+
+ // Manually written variant of librutabaga_gfx.
diff --git a/rutabaga_gfx/src/cross_domain/mod.rs b/rutabaga_gfx/src/cross_domain/mod.rs
index d5dbaec3e..a35bf6425 100644
--- a/rutabaga_gfx/src/cross_domain/mod.rs
+++ b/rutabaga_gfx/src/cross_domain/mod.rs
@@ -185,14 +185,14 @@ impl CrossDomainState {
     fn send_msg(&self, opaque_data: &[u8], descriptors: &[RawDescriptor]) -> RutabagaResult<usize> {
         match self.connection {
             Some(ref connection) => connection.send(opaque_data, descriptors),
-            None => Err(RutabagaError::InvalidCrossDomainChannel),
+            None => Err(RutabagaErrorKind::InvalidCrossDomainChannel.into()),
         }
     }
 
     fn receive_msg(&self, opaque_data: &mut [u8]) -> RutabagaResult<(usize, Vec<OwnedDescriptor>)> {
         match self.connection {
             Some(ref connection) => connection.receive(opaque_data),
-            None => Err(RutabagaError::InvalidCrossDomainChannel),
+            None => Err(RutabagaErrorKind::InvalidCrossDomainChannel.into()),
         }
     }
 
@@ -223,12 +223,12 @@ impl CrossDomainState {
 
         let resource = context_resources
             .get_mut(&ring_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let iovecs = resource
             .backing_iovecs
             .as_mut()
-            .ok_or(RutabagaError::InvalidIovec)?;
+            .ok_or(RutabagaErrorKind::InvalidIovec)?;
         let slice =
             // SAFETY:
             // Safe because we've verified the iovecs are attached and owned only by this context.
@@ -237,20 +237,20 @@ impl CrossDomainState {
         match ring_write {
             RingWrite::Write(cmd, opaque_data_opt) => {
                 if slice.len() < size_of::<T>() {
-                    return Err(RutabagaError::InvalidIovec);
+                    return Err(RutabagaErrorKind::InvalidIovec.into());
                 }
                 let (cmd_slice, opaque_data_slice) = slice.split_at_mut(size_of::<T>());
                 cmd_slice.copy_from_slice(cmd.as_bytes());
                 if let Some(opaque_data) = opaque_data_opt {
                     if opaque_data_slice.len() < opaque_data.len() {
-                        return Err(RutabagaError::InvalidIovec);
+                        return Err(RutabagaErrorKind::InvalidIovec.into());
                     }
                     opaque_data_slice[..opaque_data.len()].copy_from_slice(opaque_data);
                 }
             }
             RingWrite::WriteFromPipe(mut cmd_read, ref mut read_pipe, readable) => {
                 if slice.len() < size_of::<CrossDomainReadWrite>() {
-                    return Err(RutabagaError::InvalidIovec);
+                    return Err(RutabagaErrorKind::InvalidIovec.into());
                 }
 
                 let (cmd_slice, opaque_data_slice) =
@@ -352,7 +352,9 @@ impl CrossDomainWorker {
                                         )),
                                     )
                                 }
-                                _ => return Err(RutabagaError::InvalidCrossDomainItemType),
+                                _ => {
+                                    return Err(RutabagaErrorKind::InvalidCrossDomainItemType.into())
+                                }
                             };
                         }
 
@@ -392,7 +394,7 @@ impl CrossDomainWorker {
                     let item = items
                         .table
                         .get_mut(&pipe_id)
-                        .ok_or(RutabagaError::InvalidCrossDomainItemId)?;
+                        .ok_or(RutabagaErrorKind::InvalidCrossDomainItemId)?;
 
                     match item {
                         CrossDomainItem::WaylandReadPipe(ref mut readpipe) => {
@@ -408,7 +410,7 @@ impl CrossDomainWorker {
                                 self.wait_ctx.delete(readpipe.as_borrowed_descriptor())?;
                             }
                         }
-                        _ => return Err(RutabagaError::InvalidCrossDomainItemType),
+                        _ => return Err(RutabagaErrorKind::InvalidCrossDomainItemType.into()),
                     }
 
                     if event.hung_up && bytes_read == 0 {
@@ -450,13 +452,13 @@ impl CrossDomainWorker {
                     let item = items
                         .table
                         .get(&read_pipe_id)
-                        .ok_or(RutabagaError::InvalidCrossDomainItemId)?;
+                        .ok_or(RutabagaErrorKind::InvalidCrossDomainItemId)?;
 
                     match item {
                         CrossDomainItem::WaylandReadPipe(read_pipe) => self
                             .wait_ctx
                             .add(read_pipe_id as u64, read_pipe.as_borrowed_descriptor())?,
-                        _ => return Err(RutabagaError::InvalidCrossDomainItemType),
+                        _ => return Err(RutabagaErrorKind::InvalidCrossDomainItemType.into()),
                     }
                 }
                 CrossDomainJob::Finish => return Ok(()),
@@ -488,11 +490,11 @@ impl CrossDomainContext {
         let channels = self
             .channels
             .take()
-            .ok_or(RutabagaError::InvalidCrossDomainChannel)?;
+            .ok_or(RutabagaErrorKind::InvalidCrossDomainChannel)?;
         let base_channel = &channels
             .iter()
             .find(|channel| channel.channel_type == cmd_init.channel_type)
-            .ok_or(RutabagaError::InvalidCrossDomainChannel)?
+            .ok_or(RutabagaErrorKind::InvalidCrossDomainChannel)?
             .base_channel;
 
         Tube::new(base_channel.clone(), TubeType::Stream)
@@ -505,7 +507,7 @@ impl CrossDomainContext {
             .unwrap()
             .contains_key(&cmd_init.query_ring_id)
         {
-            return Err(RutabagaError::InvalidResourceId);
+            return Err(RutabagaErrorKind::InvalidResourceId.into());
         }
 
         let query_ring_id = cmd_init.query_ring_id;
@@ -520,7 +522,7 @@ impl CrossDomainContext {
                 .unwrap()
                 .contains_key(&cmd_init.channel_ring_id)
             {
-                return Err(RutabagaError::InvalidResourceId);
+                return Err(RutabagaErrorKind::InvalidResourceId.into());
             }
 
             let connection = self.get_connection(cmd_init)?;
@@ -616,7 +618,7 @@ impl CrossDomainContext {
             state.write_to_ring(RingWrite::Write(response, None), state.query_ring_id)?;
             Ok(())
         } else {
-            Err(RutabagaError::InvalidCrossDomainState)
+            Err(RutabagaErrorKind::InvalidCrossDomainState.into())
         }
     }
 
@@ -634,9 +636,9 @@ impl CrossDomainContext {
         let num_identifiers = cmd_send.num_identifiers.try_into()?;
 
         if num_identifiers > CROSS_DOMAIN_MAX_IDENTIFIERS {
-            return Err(RutabagaError::SpecViolation(
-                "max cross domain identifiers exceeded",
-            ));
+            return Err(anyhow::anyhow!("max cross domain identifiers exceeded")
+                .context(RutabagaErrorKind::SpecViolation)
+                .into());
         }
 
         let iter = cmd_send
@@ -652,18 +654,20 @@ impl CrossDomainContext {
 
                 let context_resource = context_resources
                     .get(identifier)
-                    .ok_or(RutabagaError::InvalidResourceId)?;
+                    .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
                 if let Some(ref handle) = context_resource.handle {
                     *descriptor = handle.os_handle.as_raw_descriptor();
                 } else {
-                    return Err(RutabagaError::InvalidRutabagaHandle);
+                    return Err(RutabagaErrorKind::InvalidRutabagaHandle.into());
                 }
             } else if *identifier_type == CROSS_DOMAIN_ID_TYPE_READ_PIPE {
                 // In practice, just 1 pipe pair per send is observed.  If we encounter
                 // more, this can be changed later.
                 if write_pipe_opt.is_some() {
-                    return Err(RutabagaError::SpecViolation("expected just one pipe pair"));
+                    return Err(anyhow::anyhow!("expected just one pipe pair")
+                        .context(RutabagaErrorKind::SpecViolation)
+                        .into());
                 }
 
                 let (read_pipe, write_pipe) = create_pipe()?;
@@ -680,7 +684,7 @@ impl CrossDomainContext {
                 // events changes, it's always possible to wait for the host
                 // response.
                 if read_pipe_id != *identifier {
-                    return Err(RutabagaError::InvalidCrossDomainItemId);
+                    return Err(RutabagaErrorKind::InvalidCrossDomainItemId.into());
                 }
 
                 // The write pipe needs to be dropped after the send_msg(..) call is complete, so
@@ -689,7 +693,7 @@ impl CrossDomainContext {
                 read_pipe_id_opt = Some(read_pipe_id);
             } else {
                 // Don't know how to handle anything else yet.
-                return Err(RutabagaError::InvalidCrossDomainItemType);
+                return Err(RutabagaErrorKind::InvalidCrossDomainItemType.into());
             }
         }
 
@@ -701,7 +705,7 @@ impl CrossDomainContext {
                 resample_evt.signal()?;
             }
         } else {
-            return Err(RutabagaError::InvalidCrossDomainState);
+            return Err(RutabagaErrorKind::InvalidCrossDomainState.into());
         }
 
         Ok(())
@@ -716,7 +720,7 @@ impl CrossDomainContext {
         let item = items
             .table
             .remove(&cmd_write.identifier)
-            .ok_or(RutabagaError::InvalidCrossDomainItemId)?;
+            .ok_or(RutabagaErrorKind::InvalidCrossDomainItemId)?;
 
         let len: usize = cmd_write.opaque_data_size.try_into()?;
         match item {
@@ -734,7 +738,7 @@ impl CrossDomainContext {
 
                 Ok(())
             }
-            _ => Err(RutabagaError::InvalidCrossDomainItemType),
+            _ => Err(RutabagaErrorKind::InvalidCrossDomainItemType.into()),
         }
     }
 }
@@ -786,12 +790,14 @@ impl RutabagaContext for CrossDomainContext {
             let item = items
                 .table
                 .get(&item_id)
-                .ok_or(RutabagaError::InvalidCrossDomainItemId)?;
+                .ok_or(RutabagaErrorKind::InvalidCrossDomainItemId)?;
 
             match item {
                 CrossDomainItem::ImageRequirements(reqs) => {
                     if reqs.size != resource_create_blob.size {
-                        return Err(RutabagaError::SpecViolation("blob size mismatch"));
+                        return Err(anyhow::anyhow!("blob size mismatch")
+                            .context(RutabagaErrorKind::SpecViolation)
+                            .into());
                     }
 
                     // Strictly speaking, it's against the virtio-gpu spec to allocate memory in the
@@ -832,7 +838,7 @@ impl RutabagaContext for CrossDomainContext {
                         mapping: None,
                     })
                 }
-                _ => Err(RutabagaError::InvalidCrossDomainItemType),
+                _ => Err(RutabagaErrorKind::InvalidCrossDomainItemType.into()),
             }
         } else {
             let item = self
@@ -841,7 +847,7 @@ impl RutabagaContext for CrossDomainContext {
                 .unwrap()
                 .table
                 .remove(&item_id)
-                .ok_or(RutabagaError::InvalidCrossDomainItemId)?;
+                .ok_or(RutabagaErrorKind::InvalidCrossDomainItemId)?;
 
             match item {
                 CrossDomainItem::WaylandKeymap(descriptor) => {
@@ -866,7 +872,7 @@ impl RutabagaContext for CrossDomainContext {
                         mapping: None,
                     })
                 }
-                _ => Err(RutabagaError::InvalidCrossDomainItemType),
+                _ => Err(RutabagaErrorKind::InvalidCrossDomainItemType.into()),
             }
         }
     }
@@ -879,7 +885,7 @@ impl RutabagaContext for CrossDomainContext {
     ) -> RutabagaResult<()> {
         while !commands.is_empty() {
             let (hdr, _) = CrossDomainHeader::read_from_prefix(commands)
-                .map_err(|_e| RutabagaError::InvalidCommandBuffer)?;
+                .map_err(|_| RutabagaErrorKind::InvalidCommandBuffer)?;
 
             match hdr.cmd {
                 CROSS_DOMAIN_CMD_INIT => {
@@ -896,7 +902,7 @@ impl RutabagaContext for CrossDomainContext {
                                     channel_type: cmd_init.channel_type,
                                 }
                             } else {
-                                return Err(RutabagaError::InvalidCommandBuffer);
+                                return Err(RutabagaErrorKind::InvalidCommandBuffer.into());
                             }
                         }
                     };
@@ -906,21 +912,21 @@ impl RutabagaContext for CrossDomainContext {
                 CROSS_DOMAIN_CMD_GET_IMAGE_REQUIREMENTS => {
                     let (cmd_get_reqs, _) =
                         CrossDomainGetImageRequirements::read_from_prefix(commands)
-                            .map_err(|_e| RutabagaError::InvalidCommandBuffer)?;
+                            .map_err(|_e| RutabagaErrorKind::InvalidCommandBuffer)?;
 
                     self.get_image_requirements(&cmd_get_reqs)?;
                 }
                 CROSS_DOMAIN_CMD_SEND => {
                     let opaque_data_offset = size_of::<CrossDomainSendReceive>();
                     let (cmd_send, _) = CrossDomainSendReceive::read_from_prefix(commands)
-                        .map_err(|_e| RutabagaError::InvalidCommandBuffer)?;
+                        .map_err(|_e| RutabagaErrorKind::InvalidCommandBuffer)?;
 
                     let opaque_data = commands
                         .get_mut(
                             opaque_data_offset
                                 ..opaque_data_offset + cmd_send.opaque_data_size as usize,
                         )
-                        .ok_or(RutabagaError::InvalidCommandSize(
+                        .ok_or(RutabagaErrorKind::InvalidCommandSize(
                             cmd_send.opaque_data_size as usize,
                         ))?;
 
@@ -932,25 +938,32 @@ impl RutabagaContext for CrossDomainContext {
                 CROSS_DOMAIN_CMD_WRITE => {
                     let opaque_data_offset = size_of::<CrossDomainReadWrite>();
                     let (cmd_write, _) = CrossDomainReadWrite::read_from_prefix(commands)
-                        .map_err(|_e| RutabagaError::InvalidCommandBuffer)?;
+                        .map_err(|_e| RutabagaErrorKind::InvalidCommandBuffer)?;
 
                     let opaque_data = commands
                         .get_mut(
                             opaque_data_offset
                                 ..opaque_data_offset + cmd_write.opaque_data_size as usize,
                         )
-                        .ok_or(RutabagaError::InvalidCommandSize(
-                            cmd_write.opaque_data_size as usize,
-                        ))?;
+                        .ok_or::<RutabagaError>(
+                            RutabagaErrorKind::InvalidCommandSize(
+                                cmd_write.opaque_data_size as usize,
+                            )
+                            .into(),
+                        )?;
 
                     self.write(&cmd_write, opaque_data)?;
                 }
-                _ => return Err(RutabagaError::SpecViolation("invalid cross domain command")),
+                _ => {
+                    return Err(anyhow::anyhow!("invalid cross domain command")
+                        .context(RutabagaErrorKind::SpecViolation)
+                        .into())
+                }
             }
 
             commands = commands
                 .get_mut(hdr.cmd_size as usize..)
-                .ok_or(RutabagaError::InvalidCommandSize(hdr.cmd_size as usize))?;
+                .ok_or(RutabagaErrorKind::InvalidCommandSize(hdr.cmd_size as usize))?;
         }
 
         Ok(())
@@ -994,7 +1007,11 @@ impl RutabagaContext for CrossDomainContext {
                     state.add_job(CrossDomainJob::HandleFence(fence));
                 }
             }
-            _ => return Err(RutabagaError::SpecViolation("unexpected ring type")),
+            _ => {
+                return Err(anyhow::anyhow!("unexpected ring type")
+                    .context(RutabagaErrorKind::SpecViolation)
+                    .into())
+            }
         }
 
         Ok(None)
@@ -1042,9 +1059,9 @@ impl RutabagaComponent for CrossDomain {
         if resource_create_blob.blob_mem != RUTABAGA_BLOB_MEM_GUEST
             && resource_create_blob.blob_flags != RUTABAGA_BLOB_FLAG_USE_MAPPABLE
         {
-            return Err(RutabagaError::SpecViolation(
-                "expected only guest memory blobs",
-            ));
+            return Err(anyhow::anyhow!("expected only guest memory blobs")
+                .context(RutabagaErrorKind::SpecViolation)
+                .into());
         }
 
         Ok(RutabagaResource {
diff --git a/rutabaga_gfx/src/gfxstream.rs b/rutabaga_gfx/src/gfxstream.rs
index f46541c2f..5e396a3b9 100644
--- a/rutabaga_gfx/src/gfxstream.rs
+++ b/rutabaga_gfx/src/gfxstream.rs
@@ -4,7 +4,7 @@
 
 //! gfxstream: Handles 3D virtio-gpu hypercalls using gfxstream.
 //!
-//! External code found at <https://android.googlesource.com/device/generic/vulkan-cereal/>.
+//! External code found at <https://android.googlesource.com/platform/hardware/google/gfxstream/>.
 
 #![cfg(feature = "gfxstream")]
 
@@ -22,6 +22,7 @@ use std::ptr::null;
 use std::ptr::null_mut;
 use std::sync::Arc;
 
+use anyhow::Context;
 use serde::Deserialize;
 use serde::Serialize;
 
@@ -274,7 +275,7 @@ impl GfxstreamContext {
 
     #[cfg(not(gfxstream_unstable))]
     fn export_fence(&self, _fence_id: u64) -> RutabagaResult<RutabagaHandle> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -286,7 +287,7 @@ impl RutabagaContext for GfxstreamContext {
         _shareable_fences: Vec<RutabagaHandle>,
     ) -> RutabagaResult<()> {
         if commands.len() % size_of::<u32>() != 0 {
-            return Err(RutabagaError::InvalidCommandSize(commands.len()));
+            return Err(RutabagaErrorKind::InvalidCommandSize(commands.len()).into());
         }
 
         // TODO(b/315870313): Add safety comment
@@ -356,7 +357,8 @@ impl RutabagaContext for GfxstreamContext {
 
         let mut buffer = std::io::Cursor::new(Vec::new());
         serde_json::to_writer(&mut buffer, &snapshot)
-            .map_err(|e| RutabagaError::IoError(e.into()))?;
+            .context(RutabagaErrorKind::IoError)
+            .map_err(RutabagaError::from)?;
         Ok(buffer.into_inner())
     }
 }
@@ -858,7 +860,7 @@ impl RutabagaComponent for Gfxstream {
         // Safe because the Stream renderer wraps and validates use of vkMapMemory.
         let ret = unsafe { stream_renderer_resource_map(resource_id, &mut map, &mut size) };
         if ret != 0 {
-            return Err(RutabagaError::MappingFailed(ret));
+            return Err(RutabagaErrorKind::MappingFailed(ret).into());
         }
         Ok(RutabagaMapping {
             ptr: map as u64,
@@ -943,8 +945,9 @@ impl RutabagaComponent for Gfxstream {
         snapshot: Vec<u8>,
         fence_handler: RutabagaFenceHandler,
     ) -> RutabagaResult<Box<dyn RutabagaContext>> {
-        let context_snapshot: GfxstreamContextSnapshot =
-            serde_json::from_reader(&snapshot[..]).map_err(|e| RutabagaError::IoError(e.into()))?;
+        let context_snapshot: GfxstreamContextSnapshot = serde_json::from_reader(&snapshot[..])
+            .context(RutabagaErrorKind::IoError)
+            .map_err(RutabagaError::from)?;
 
         Ok(Box::new(GfxstreamContext {
             ctx_id: context_snapshot.ctx_id,
diff --git a/rutabaga_gfx/src/ipc/rutabaga_stream.rs b/rutabaga_gfx/src/ipc/rutabaga_stream.rs
index 66fe87ea6..23a1cbb2a 100644
--- a/rutabaga_gfx/src/ipc/rutabaga_stream.rs
+++ b/rutabaga_gfx/src/ipc/rutabaga_stream.rs
@@ -18,7 +18,7 @@ use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
 use crate::rutabaga_os::Tube;
 use crate::rutabaga_os::DEFAULT_RAW_DESCRIPTOR;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaHandle;
 use crate::rutabaga_utils::RutabagaResult;
 use crate::rutabaga_utils::RUTABAGA_HANDLE_TYPE_SIGNAL_EVENT_FD;
@@ -120,7 +120,7 @@ impl RutabagaStream {
                 KUMQUAT_GPU_PROTOCOL_TRANSFER_TO_HOST_3D => {
                     let os_handle = descriptors
                         .pop_front()
-                        .ok_or(RutabagaError::InvalidResourceId)?;
+                        .ok_or(RutabagaErrorKind::InvalidResourceId)?;
                     let resp: kumquat_gpu_protocol_transfer_host_3d = reader.read_obj()?;
 
                     let handle = RutabagaHandle {
@@ -133,7 +133,7 @@ impl RutabagaStream {
                 KUMQUAT_GPU_PROTOCOL_TRANSFER_FROM_HOST_3D => {
                     let os_handle = descriptors
                         .pop_front()
-                        .ok_or(RutabagaError::InvalidResourceId)?;
+                        .ok_or(RutabagaErrorKind::InvalidResourceId)?;
                     let resp: kumquat_gpu_protocol_transfer_host_3d = reader.read_obj()?;
 
                     let handle = RutabagaHandle {
@@ -147,7 +147,7 @@ impl RutabagaStream {
                     let cmd: kumquat_gpu_protocol_cmd_submit = reader.read_obj()?;
                     if reader.available_bytes() < cmd.size.try_into()? {
                         // Large command buffers should handled via shared memory.
-                        return Err(RutabagaError::InvalidCommandBuffer);
+                        return Err(RutabagaErrorKind::InvalidCommandBuffer.into());
                     } else if reader.available_bytes() != 0 {
                         let num_in_fences = cmd.num_in_fences as usize;
                         let cmd_size = cmd.size as usize;
@@ -158,7 +158,7 @@ impl RutabagaStream {
                                 Ok(fence_id) => {
                                     fence_ids.push(fence_id);
                                 }
-                                Err(_) => return Err(RutabagaError::InvalidIovec),
+                                Err(_) => return Err(RutabagaErrorKind::InvalidIovec.into()),
                             }
                         }
                         reader.read_exact(&mut cmd_buf[..])?;
@@ -199,7 +199,7 @@ impl RutabagaStream {
                 KUMQUAT_GPU_PROTOCOL_RESP_RESOURCE_CREATE => {
                     let os_handle = descriptors
                         .pop_front()
-                        .ok_or(RutabagaError::InvalidResourceId)?;
+                        .ok_or(RutabagaErrorKind::InvalidResourceId)?;
                     let resp: kumquat_gpu_protocol_resp_resource_create = reader.read_obj()?;
 
                     let handle = RutabagaHandle {
@@ -212,7 +212,7 @@ impl RutabagaStream {
                 KUMQUAT_GPU_PROTOCOL_RESP_CMD_SUBMIT_3D => {
                     let os_handle = descriptors
                         .pop_front()
-                        .ok_or(RutabagaError::InvalidResourceId)?;
+                        .ok_or(RutabagaErrorKind::InvalidResourceId)?;
                     let resp: kumquat_gpu_protocol_resp_cmd_submit_3d = reader.read_obj()?;
 
                     let handle = RutabagaHandle {
@@ -227,7 +227,7 @@ impl RutabagaStream {
                     KumquatGpuProtocol::RespOkSnapshot
                 }
                 _ => {
-                    return Err(RutabagaError::Unsupported);
+                    return Err(RutabagaErrorKind::Unsupported.into());
                 }
             };
 
diff --git a/rutabaga_gfx/src/macros.rs b/rutabaga_gfx/src/macros.rs
index e813bd788..c80d1c5dc 100644
--- a/rutabaga_gfx/src/macros.rs
+++ b/rutabaga_gfx/src/macros.rs
@@ -10,10 +10,10 @@ macro_rules! checked_range {
         if $x <= $y {
             Ok(())
         } else {
-            Err(RutabagaError::CheckedRange {
+            Err($crate::RutabagaError::from($crate::RutabagaErrorKind::CheckedRange {
                 field1: (stringify!($x), $x as usize),
                 field2: (stringify!($y), $y as usize),
-            })
+            }))
         }
     };
     ($x:ident <= $y:ident) => {
@@ -24,11 +24,11 @@ macro_rules! checked_range {
 #[macro_export]
 macro_rules! checked_arithmetic {
     ($x:ident $op:ident $y:ident $op_name:expr) => {
-        $x.$op($y).ok_or_else(|| RutabagaError::CheckedArithmetic {
+        $x.$op($y).ok_or_else(|| $crate::RutabagaErrorKind::CheckedArithmetic {
             field1: (stringify!($x), $x as usize),
             field2: (stringify!($y), $y as usize),
             op: $op_name,
-        })
+        }).map_err($crate::RutabagaError::from)
     };
     ($x:ident + $y:ident) => {
         checked_arithmetic!($x checked_add $y "+")
diff --git a/rutabaga_gfx/src/renderer_utils.rs b/rutabaga_gfx/src/renderer_utils.rs
index 7a60db638..dfde4f08c 100644
--- a/rutabaga_gfx/src/renderer_utils.rs
+++ b/rutabaga_gfx/src/renderer_utils.rs
@@ -6,7 +6,7 @@
 
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_utils::RutabagaDebugHandler;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaFenceHandler;
 use crate::rutabaga_utils::RutabagaResult;
 
@@ -24,7 +24,7 @@ pub struct VirglBox {
 pub fn ret_to_res(ret: i32) -> RutabagaResult<()> {
     match ret {
         0 => Ok(()),
-        _ => Err(RutabagaError::ComponentError(ret)),
+        _ => Err(RutabagaErrorKind::ComponentError(ret).into()),
     }
 }
 
diff --git a/rutabaga_gfx/src/rutabaga_2d.rs b/rutabaga_gfx/src/rutabaga_2d.rs
index e1575d051..4098b8879 100644
--- a/rutabaga_gfx/src/rutabaga_2d.rs
+++ b/rutabaga_gfx/src/rutabaga_2d.rs
@@ -9,6 +9,8 @@ use std::cmp::min;
 use std::cmp::Ordering;
 use std::io::IoSliceMut;
 
+use anyhow::Context;
+
 use crate::rutabaga_core::Rutabaga2DInfo;
 use crate::rutabaga_core::RutabagaComponent;
 use crate::rutabaga_core::RutabagaResource;
@@ -106,7 +108,7 @@ fn transfer_2d(
             let src_end = offset_within_src + copyable_size;
             let src_subslice = src
                 .get(offset_within_src as usize..src_end as usize)
-                .ok_or(RutabagaError::InvalidIovec)?;
+                .ok_or(RutabagaErrorKind::InvalidIovec)?;
 
             let dst_line_vertical_offset = checked_arithmetic!(current_height * dst_stride)?;
             let dst_line_horizontal_offset =
@@ -118,7 +120,7 @@ fn transfer_2d(
             let dst_end_offset = dst_start_offset + copyable_size;
             let dst_subslice = dst
                 .get_mut(dst_start_offset as usize..dst_end_offset as usize)
-                .ok_or(RutabagaError::InvalidIovec)?;
+                .ok_or(RutabagaErrorKind::InvalidIovec)?;
 
             dst_subslice.copy_from_slice(src_subslice);
         } else if src_line_start_offset >= src_start_offset {
@@ -203,12 +205,12 @@ impl RutabagaComponent for Rutabaga2D {
         let mut info_2d = resource
             .info_2d
             .take()
-            .ok_or(RutabagaError::Invalid2DInfo)?;
+            .ok_or(RutabagaErrorKind::Invalid2DInfo)?;
 
         let iovecs = resource
             .backing_iovecs
             .take()
-            .ok_or(RutabagaError::InvalidIovec)?;
+            .ok_or(RutabagaErrorKind::InvalidIovec)?;
 
         // All offical virtio_gpu formats are 4 bytes per pixel.
         let resource_bpp = 4;
@@ -256,7 +258,7 @@ impl RutabagaComponent for Rutabaga2D {
         let mut info_2d = resource
             .info_2d
             .take()
-            .ok_or(RutabagaError::Invalid2DInfo)?;
+            .ok_or(RutabagaErrorKind::Invalid2DInfo)?;
 
         // All offical virtio_gpu formats are 4 bytes per pixel.
         let resource_bpp = 4;
@@ -264,9 +266,9 @@ impl RutabagaComponent for Rutabaga2D {
         let src_offset = 0;
         let dst_offset = 0;
 
-        let dst_slice = buf.ok_or(RutabagaError::SpecViolation(
-            "need a destination slice for transfer read",
-        ))?;
+        let dst_slice = buf
+            .context("need a destination slice for transfer read")
+            .context(RutabagaErrorKind::SpecViolation)?;
 
         transfer_2d(
             info_2d.width,
diff --git a/rutabaga_gfx/src/rutabaga_core.rs b/rutabaga_gfx/src/rutabaga_core.rs
index 6cd9e1321..152f32778 100644
--- a/rutabaga_gfx/src/rutabaga_core.rs
+++ b/rutabaga_gfx/src/rutabaga_core.rs
@@ -9,6 +9,7 @@ use std::io::IoSliceMut;
 use std::path::Path;
 use std::sync::Arc;
 
+use anyhow::Context;
 use serde::Deserialize;
 use serde::Serialize;
 
@@ -207,7 +208,7 @@ pub trait RutabagaComponent {
         _import_handle: RutabagaHandle,
         _import_data: RutabagaImportData,
     ) -> RutabagaResult<Option<RutabagaResource>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must attach `vecs` to the resource.
@@ -250,7 +251,7 @@ pub trait RutabagaComponent {
 
     /// Implementations must flush the given resource to the display.
     fn resource_flush(&self, _resource_id: &mut RutabagaResource) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must create a blob resource on success.  The memory parameters, size, and
@@ -263,24 +264,24 @@ pub trait RutabagaComponent {
         _iovec_opt: Option<Vec<RutabagaIovec>>,
         _handle_opt: Option<RutabagaHandle>,
     ) -> RutabagaResult<RutabagaResource> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must map the blob resource on success.  This is typically done by
     /// glMapBufferRange(...) or vkMapMemory.
     fn map(&self, _resource_id: u32) -> RutabagaResult<RutabagaMapping> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must unmap the blob resource on success.  This is typically done by
     /// glUnmapBuffer(...) or vkUnmapMemory.
     fn unmap(&self, _resource_id: u32) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must return a RutabagaHandle of the fence on success.
     fn export_fence(&self, _fence_id: u64) -> RutabagaResult<RutabagaHandle> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must create a context for submitting commands.  The command stream of the
@@ -293,7 +294,7 @@ pub trait RutabagaComponent {
         _context_name: Option<&str>,
         _fence_handler: RutabagaFenceHandler,
     ) -> RutabagaResult<Box<dyn RutabagaContext>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations should stop workers.
@@ -303,12 +304,12 @@ pub trait RutabagaComponent {
 
     /// Implementations must snapshot to the specified writer.
     fn snapshot(&self, _writer: RutabagaSnapshotWriter) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must restore from the specified reader.
     fn restore(&self, _reader: RutabagaSnapshotReader) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must restore the context from the given stream.
@@ -317,7 +318,7 @@ pub trait RutabagaComponent {
         _snapshot: Vec<u8>,
         _fence_handler: RutabagaFenceHandler,
     ) -> RutabagaResult<Box<dyn RutabagaContext>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations should resume workers.
@@ -334,7 +335,7 @@ pub trait RutabagaContext {
         _resource_create_blob: ResourceCreateBlob,
         _handle_opt: Option<RutabagaHandle>,
     ) -> RutabagaResult<RutabagaResource> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must handle the context-specific command stream.
@@ -360,7 +361,7 @@ pub trait RutabagaContext {
         &mut self,
         _fence: RutabagaFence,
     ) -> RutabagaResult<Option<RutabagaHandle>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Implementations must return the component type associated with the context.
@@ -368,7 +369,7 @@ pub trait RutabagaContext {
 
     /// Implementations must serialize the context.
     fn snapshot(&self) -> RutabagaResult<Vec<u8>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -448,7 +449,9 @@ pub fn calculate_capset_names(capset_mask: u64) -> Vec<String> {
 
 fn calculate_component(component_mask: u8) -> RutabagaResult<RutabagaComponentType> {
     if component_mask.count_ones() != 1 {
-        return Err(RutabagaError::SpecViolation("can't infer single component"));
+        return Err(anyhow::anyhow!("can't infer single component")
+            .context(RutabagaErrorKind::SpecViolation)
+            .into());
     }
 
     match component_mask.trailing_zeros() {
@@ -456,7 +459,7 @@ fn calculate_component(component_mask: u8) -> RutabagaResult<RutabagaComponentTy
         1 => Ok(RutabagaComponentType::VirglRenderer),
         2 => Ok(RutabagaComponentType::Gfxstream),
         3 => Ok(RutabagaComponentType::CrossDomain),
-        _ => Err(RutabagaError::InvalidComponent),
+        _ => Err(RutabagaErrorKind::InvalidComponent.into()),
     }
 }
 
@@ -492,7 +495,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         component.suspend()
     }
@@ -505,7 +508,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let component_snapshot_writer =
             snapshot_writer.add_namespace(self.default_component.as_str())?;
@@ -566,7 +569,7 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let component_snapshot_reader =
             snapshot_reader.get_namespace(self.default_component.as_str())?;
@@ -592,7 +595,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         component.resume()
     }
@@ -602,7 +605,7 @@ impl Rutabaga {
             .capset_info
             .iter()
             .find(|capset_info| capset_info.capset_id == capset_id)
-            .ok_or(RutabagaError::InvalidCapset)?
+            .ok_or(RutabagaErrorKind::InvalidCapset)?
             .component;
 
         Ok(component)
@@ -611,7 +614,7 @@ impl Rutabaga {
     fn capset_index_to_component_info(&self, index: u32) -> RutabagaResult<RutabagaCapsetInfo> {
         let idx = index as usize;
         if idx >= self.capset_info.len() {
-            return Err(RutabagaError::InvalidCapset);
+            return Err(RutabagaErrorKind::InvalidCapset.into());
         }
 
         Ok(self.capset_info[idx])
@@ -624,7 +627,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&capset_info.component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let (capset_version, capset_size) = component.get_capset_info(capset_info.capset_id);
         Ok((capset_info.capset_id, capset_version, capset_size))
@@ -643,7 +646,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&component_type)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         Ok(component.get_capset(capset_id, version))
     }
@@ -668,7 +671,7 @@ impl Rutabaga {
             let ctx = self
                 .contexts
                 .get_mut(&fence.ctx_id)
-                .ok_or(RutabagaError::InvalidContextId)?;
+                .ok_or(RutabagaErrorKind::InvalidContextId)?;
 
             #[allow(unused_variables)]
             let handle_opt = ctx.context_create_fence(fence)?;
@@ -682,7 +685,7 @@ impl Rutabaga {
             let component = self
                 .components
                 .get_mut(&self.default_component)
-                .ok_or(RutabagaError::InvalidComponent)?;
+                .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
             component.create_fence(fence)?;
         }
@@ -713,10 +716,10 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         if self.resources.contains_key(&resource_id) {
-            return Err(RutabagaError::InvalidResourceId);
+            return Err(RutabagaErrorKind::InvalidResourceId.into());
         }
 
         let resource = component.create_3d(resource_id, resource_create_3d)?;
@@ -735,7 +738,7 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         match component.import(resource_id, import_handle, import_data) {
             Ok(Some(resource)) => {
@@ -743,7 +746,7 @@ impl Rutabaga {
             }
             Ok(None) => {
                 if !self.resources.contains_key(&resource_id) {
-                    return Err(RutabagaError::InvalidResourceId);
+                    return Err(RutabagaErrorKind::InvalidResourceId.into());
                 }
             }
             Err(e) => return Err(e),
@@ -760,12 +763,12 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         component.attach_backing(resource_id, &mut vecs)?;
         resource.backing_iovecs = Some(vecs);
@@ -777,12 +780,12 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         component.detach_backing(resource_id);
         resource.backing_iovecs = None;
@@ -794,11 +797,11 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         self.resources
             .remove(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         component.unref_resource(resource_id);
         Ok(())
@@ -815,12 +818,12 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         component.transfer_write(ctx_id, resource, transfer)
     }
@@ -839,12 +842,12 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         component.transfer_read(ctx_id, resource, transfer, buf)
     }
@@ -853,12 +856,12 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::Unsupported)?;
+            .ok_or(RutabagaErrorKind::Unsupported)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         component.resource_flush(resource)
     }
@@ -875,13 +878,13 @@ impl Rutabaga {
         handle: Option<RutabagaHandle>,
     ) -> RutabagaResult<()> {
         if self.resources.contains_key(&resource_id) {
-            return Err(RutabagaError::InvalidResourceId);
+            return Err(RutabagaErrorKind::InvalidResourceId.into());
         }
 
         let component = self
             .components
             .get_mut(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         let mut context = None;
         // For the cross-domain context, we'll need to create the blob resource via a home-grown
@@ -891,7 +894,7 @@ impl Rutabaga {
             let ctx = self
                 .contexts
                 .get_mut(&ctx_id)
-                .ok_or(RutabagaError::InvalidContextId)?;
+                .ok_or(RutabagaErrorKind::InvalidContextId)?;
 
             if ctx.component_type() == RutabagaComponentType::CrossDomain {
                 context = Some(ctx);
@@ -914,7 +917,7 @@ impl Rutabaga {
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let component_type = calculate_component(resource.component_mask)?;
         if component_type == RutabagaComponentType::CrossDomain {
@@ -922,16 +925,17 @@ impl Rutabaga {
             match handle_opt {
                 Some(handle) => {
                     if handle.handle_type != RUTABAGA_HANDLE_TYPE_MEM_SHM {
-                        return Err(RutabagaError::SpecViolation(
-                            "expected a shared memory handle",
-                        ));
+                        return Err(anyhow::anyhow!("expected a shared memory handle")
+                            .context(RutabagaErrorKind::SpecViolation)
+                            .into());
                     }
 
                     let clone = handle.try_clone()?;
                     let resource_size: usize = resource.size.try_into()?;
                     let map_info = resource
                         .map_info
-                        .ok_or(RutabagaError::SpecViolation("no map info available"))?;
+                        .context("no map info available")
+                        .context(RutabagaErrorKind::SpecViolation)?;
 
                     // Creating the mapping closes the cloned descriptor.
                     let mapping = MemoryMapping::from_safe_descriptor(
@@ -945,14 +949,18 @@ impl Rutabaga {
 
                     return Ok(rutabaga_mapping);
                 }
-                None => return Err(RutabagaError::SpecViolation("expected a handle to map")),
+                None => {
+                    return Err(anyhow::anyhow!("expected a handle to map")
+                        .context(RutabagaErrorKind::SpecViolation)
+                        .into())
+                }
             }
         }
 
         let component = self
             .components
             .get(&component_type)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         component.map(resource_id)
     }
@@ -962,7 +970,7 @@ impl Rutabaga {
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         let component_type = calculate_component(resource.component_mask)?;
         if component_type == RutabagaComponentType::CrossDomain {
@@ -973,7 +981,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&component_type)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         component.unmap(resource_id)
     }
@@ -984,11 +992,13 @@ impl Rutabaga {
         let resource = self
             .resources
             .get(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         resource
             .map_info
-            .ok_or(RutabagaError::SpecViolation("no map info available"))
+            .context("no map info available")
+            .context(RutabagaErrorKind::SpecViolation)
+            .map_err(|e| e.into())
     }
 
     /// Returns the `vulkan_info` of the blob resource, which consists of the physical device
@@ -997,9 +1007,11 @@ impl Rutabaga {
         let resource = self
             .resources
             .get(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
-        resource.vulkan_info.ok_or(RutabagaError::InvalidVulkanInfo)
+        resource
+            .vulkan_info
+            .ok_or(RutabagaErrorKind::InvalidVulkanInfo.into())
     }
 
     /// Returns the 3D info associated with the resource, if any.
@@ -1007,11 +1019,13 @@ impl Rutabaga {
         let resource = self
             .resources
             .get(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         resource
             .info_3d
-            .ok_or(RutabagaError::SpecViolation("no 3d info available"))
+            .context("no 3d info available")
+            .context(RutabagaErrorKind::SpecViolation)
+            .map_err(|e| e.into())
     }
 
     /// Exports a blob resource.  See virtio-gpu spec for blob flag use flags.
@@ -1019,7 +1033,7 @@ impl Rutabaga {
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         // We can inspect blob flags only once guest minigbm is fully transitioned to blob.
         let share_mask = RUTABAGA_BLOB_FLAG_USE_SHAREABLE | RUTABAGA_BLOB_FLAG_USE_CROSS_DEVICE;
@@ -1035,11 +1049,11 @@ impl Rutabaga {
             }
             (Some(handle), false) => {
                 // Exactly one strong reference in this case.
-                let hnd =
-                    Arc::try_unwrap(handle).map_err(|_| RutabagaError::InvalidRutabagaHandle)?;
+                let hnd = Arc::try_unwrap(handle)
+                    .map_err(|_| RutabagaErrorKind::InvalidRutabagaHandle)?;
                 Ok(hnd)
             }
-            _ => Err(RutabagaError::InvalidRutabagaHandle),
+            _ => Err(RutabagaErrorKind::InvalidRutabagaHandle.into()),
         }
     }
 
@@ -1053,7 +1067,7 @@ impl Rutabaga {
         let component = self
             .components
             .get(&self.default_component)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         component.export_fence(fence_id)
     }
@@ -1076,10 +1090,10 @@ impl Rutabaga {
         let component = self
             .components
             .get_mut(&component_type)
-            .ok_or(RutabagaError::InvalidComponent)?;
+            .ok_or(RutabagaErrorKind::InvalidComponent)?;
 
         if self.contexts.contains_key(&ctx_id) {
-            return Err(RutabagaError::InvalidContextId);
+            return Err(RutabagaErrorKind::InvalidContextId.into());
         }
 
         let ctx = component.create_context(
@@ -1096,7 +1110,7 @@ impl Rutabaga {
     pub fn destroy_context(&mut self, ctx_id: u32) -> RutabagaResult<()> {
         self.contexts
             .remove(&ctx_id)
-            .ok_or(RutabagaError::InvalidContextId)?;
+            .ok_or(RutabagaErrorKind::InvalidContextId)?;
         Ok(())
     }
 
@@ -1105,12 +1119,12 @@ impl Rutabaga {
         let ctx = self
             .contexts
             .get_mut(&ctx_id)
-            .ok_or(RutabagaError::InvalidContextId)?;
+            .ok_or(RutabagaErrorKind::InvalidContextId)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         ctx.attach(resource);
         Ok(())
@@ -1121,12 +1135,12 @@ impl Rutabaga {
         let ctx = self
             .contexts
             .get_mut(&ctx_id)
-            .ok_or(RutabagaError::InvalidContextId)?;
+            .ok_or(RutabagaErrorKind::InvalidContextId)?;
 
         let resource = self
             .resources
             .get_mut(&resource_id)
-            .ok_or(RutabagaError::InvalidResourceId)?;
+            .ok_or(RutabagaErrorKind::InvalidResourceId)?;
 
         ctx.detach(resource);
         Ok(())
@@ -1142,7 +1156,7 @@ impl Rutabaga {
         let ctx = self
             .contexts
             .get_mut(&ctx_id)
-            .ok_or(RutabagaError::InvalidContextId)?;
+            .ok_or(RutabagaErrorKind::InvalidContextId)?;
 
         #[allow(unused_mut)]
         let mut shareable_fences: Vec<RutabagaHandle> = Vec::with_capacity(fence_ids.len());
@@ -1152,7 +1166,7 @@ impl Rutabaga {
             let handle = self
                 .shareable_fences
                 .get_mut(fence_id)
-                .ok_or(RutabagaError::InvalidRutabagaHandle)?;
+                .ok_or(RutabagaErrorKind::InvalidRutabagaHandle)?;
 
             let clone = handle.try_clone()?;
             shareable_fences.insert(i, clone);
@@ -1167,7 +1181,7 @@ impl Rutabaga {
         for fence_id in fence_ids {
             self.shareable_fences
                 .remove(fence_id)
-                .ok_or(RutabagaError::InvalidRutabagaHandle)?;
+                .ok_or(RutabagaErrorKind::InvalidRutabagaHandle)?;
         }
 
         Ok(())
@@ -1372,15 +1386,15 @@ impl RutabagaBuilder {
         // Make sure that disabled components are not used as default.
         #[cfg(not(feature = "virgl_renderer"))]
         if self.default_component == RutabagaComponentType::VirglRenderer {
-            return Err(RutabagaError::InvalidRutabagaBuild(
-                "virgl renderer feature not enabled",
-            ));
+            return Err(anyhow::anyhow!("virgl renderer feature not enabled")
+                .context(RutabagaErrorKind::InvalidRutabagaBuild)
+                .into());
         }
         #[cfg(not(feature = "gfxstream"))]
         if self.default_component == RutabagaComponentType::Gfxstream {
-            return Err(RutabagaError::InvalidRutabagaBuild(
-                "gfxstream feature not enabled",
-            ));
+            return Err(anyhow::anyhow!("gfxstream feature not enabled")
+                .context(RutabagaErrorKind::InvalidRutabagaBuild)
+                .into());
         }
 
         if self.default_component != RutabagaComponentType::Rutabaga2D {
diff --git a/rutabaga_gfx/src/rutabaga_gralloc/formats.rs b/rutabaga_gfx/src/rutabaga_gralloc/formats.rs
index 2422708f2..2a5421488 100644
--- a/rutabaga_gfx/src/rutabaga_gralloc/formats.rs
+++ b/rutabaga_gfx/src/rutabaga_gralloc/formats.rs
@@ -136,7 +136,7 @@ impl DrmFormat {
             DRM_FORMAT_ABGR16161616F => Ok(PACKED_8BPP),
             DRM_FORMAT_NV12 => Ok(BIPLANAR_YUV420),
             DRM_FORMAT_YVU420 => Ok(TRIPLANAR_YUV420),
-            _ => Err(RutabagaError::InvalidGrallocDrmFormat),
+            _ => Err(RutabagaErrorKind::InvalidGrallocDrmFormat.into()),
         }
     }
 
@@ -158,7 +158,7 @@ impl DrmFormat {
             DRM_FORMAT_ABGR16161616F => Ok(VulkanFormat::R16G16B16A16_SFLOAT),
             DRM_FORMAT_NV12 => Ok(VulkanFormat::G8_B8R8_2PLANE_420_UNORM),
             DRM_FORMAT_YVU420 => Ok(VulkanFormat::G8_B8_R8_3PLANE_420_UNORM),
-            _ => Err(RutabagaError::InvalidGrallocDrmFormat),
+            _ => Err(RutabagaErrorKind::InvalidGrallocDrmFormat.into()),
         }
     }
 
@@ -180,15 +180,15 @@ impl DrmFormat {
             DRM_FORMAT_NV12 => match plane {
                 0 => Ok(VulkanImageAspect::Plane0),
                 1 => Ok(VulkanImageAspect::Plane1),
-                _ => Err(RutabagaError::InvalidGrallocNumberOfPlanes),
+                _ => Err(RutabagaErrorKind::InvalidGrallocNumberOfPlanes.into()),
             },
             DRM_FORMAT_YVU420 => match plane {
                 0 => Ok(VulkanImageAspect::Plane0),
                 1 => Ok(VulkanImageAspect::Plane1),
                 2 => Ok(VulkanImageAspect::Plane2),
-                _ => Err(RutabagaError::InvalidGrallocNumberOfPlanes),
+                _ => Err(RutabagaErrorKind::InvalidGrallocNumberOfPlanes.into()),
             },
-            _ => Err(RutabagaError::InvalidGrallocDrmFormat),
+            _ => Err(RutabagaErrorKind::InvalidGrallocDrmFormat.into()),
         }
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_gralloc/gralloc.rs b/rutabaga_gfx/src/rutabaga_gralloc/gralloc.rs
index 1e4d85d59..66ad4a64b 100644
--- a/rutabaga_gfx/src/rutabaga_gralloc/gralloc.rs
+++ b/rutabaga_gfx/src/rutabaga_gralloc/gralloc.rs
@@ -234,7 +234,7 @@ pub trait Gralloc: Send {
         _vulkan_info: VulkanInfo,
         _size: u64,
     ) -> RutabagaResult<Box<dyn MappedRegion>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -350,7 +350,7 @@ impl RutabagaGralloc {
         let gralloc = self
             .grallocs
             .get_mut(&backend)
-            .ok_or(RutabagaError::InvalidGrallocBackend)?;
+            .ok_or(RutabagaErrorKind::InvalidGrallocBackend)?;
 
         let mut reqs = gralloc.get_image_memory_requirements(info)?;
         reqs.size = round_up_to_page_size(reqs.size)?;
@@ -367,7 +367,7 @@ impl RutabagaGralloc {
         let gralloc = self
             .grallocs
             .get_mut(&backend)
-            .ok_or(RutabagaError::InvalidGrallocBackend)?;
+            .ok_or(RutabagaErrorKind::InvalidGrallocBackend)?;
 
         gralloc.allocate_memory(reqs)
     }
@@ -383,7 +383,7 @@ impl RutabagaGralloc {
         let gralloc = self
             .grallocs
             .get_mut(&GrallocBackend::Vulkano)
-            .ok_or(RutabagaError::InvalidGrallocBackend)?;
+            .ok_or(RutabagaErrorKind::InvalidGrallocBackend)?;
 
         gralloc.import_and_map(handle, vulkan_info, size)
     }
diff --git a/rutabaga_gfx/src/rutabaga_gralloc/minigbm.rs b/rutabaga_gfx/src/rutabaga_gralloc/minigbm.rs
index 755a27e98..79e341a35 100644
--- a/rutabaga_gfx/src/rutabaga_gralloc/minigbm.rs
+++ b/rutabaga_gfx/src/rutabaga_gralloc/minigbm.rs
@@ -67,7 +67,7 @@ impl MinigbmDevice {
 
             gbm = minigbm_create_default_device(&mut fd);
             if gbm.is_null() {
-                return Err(RutabagaError::IoError(Error::last_os_error()));
+                return Err(Error::last_os_error().into());
             }
             descriptor = File::from_raw_fd(fd);
         }
@@ -107,7 +107,7 @@ impl Gralloc for MinigbmDevice {
             )
         };
         if bo.is_null() {
-            return Err(RutabagaError::IoError(Error::last_os_error()));
+            return Err(Error::last_os_error().into());
         }
 
         let mut reqs: ImageMemoryRequirements = Default::default();
@@ -135,7 +135,7 @@ impl Gralloc for MinigbmDevice {
         // via the TEST_ALLOC flag.  However, support has only been added in i915.  Until this
         // flag is supported everywhere, do the actual allocation here and stash it away.
         if self.last_buffer.is_some() {
-            return Err(RutabagaError::AlreadyInUse);
+            return Err(RutabagaErrorKind::AlreadyInUse.into());
         }
 
         self.last_buffer = Some(Arc::new(gbm_buffer));
@@ -151,7 +151,7 @@ impl Gralloc for MinigbmDevice {
                 || gbm_buffer.height() != reqs.info.height
                 || gbm_buffer.format() != reqs.info.drm_format
             {
-                return Err(RutabagaError::InvalidGrallocDimensions);
+                return Err(RutabagaErrorKind::InvalidGrallocDimensions.into());
             }
 
             let dmabuf = gbm_buffer.export()?.into();
@@ -174,7 +174,7 @@ impl Gralloc for MinigbmDevice {
         };
 
         if bo.is_null() {
-            return Err(RutabagaError::IoError(Error::last_os_error()));
+            return Err(Error::last_os_error().into());
         }
 
         let gbm_buffer = MinigbmBuffer {
@@ -270,7 +270,7 @@ impl MinigbmBuffer {
                 let dmabuf = unsafe { File::from_raw_descriptor(fd) };
                 Ok(dmabuf)
             }
-            ret => Err(RutabagaError::ComponentError(ret)),
+            ret => Err(RutabagaErrorKind::ComponentError(ret).into()),
         }
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc.rs b/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc.rs
index 779fa3ccf..0c24d510c 100644
--- a/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc.rs
+++ b/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc.rs
@@ -15,6 +15,7 @@ use std::collections::HashMap as Map;
 use std::convert::TryInto;
 use std::sync::Arc;
 
+use anyhow::Context;
 use log::warn;
 use vulkano::device::physical::PhysicalDeviceType;
 use vulkano::device::Device;
@@ -202,9 +203,9 @@ impl VulkanoGralloc {
         }
 
         if devices.is_empty() {
-            return Err(RutabagaError::SpecViolation(
-                "no matching VK devices available",
-            ));
+            return Err(anyhow::anyhow!("no matching VK devices available")
+                .context(RutabagaErrorKind::SpecViolation)
+                .into());
         }
 
         Ok(Box::new(VulkanoGralloc {
@@ -229,11 +230,11 @@ impl VulkanoGralloc {
         let device = if self.has_integrated_gpu {
             self.devices
                 .get(&PhysicalDeviceType::IntegratedGpu)
-                .ok_or(RutabagaError::InvalidGrallocGpuType)?
+                .ok_or(RutabagaErrorKind::InvalidGrallocGpuType)?
         } else {
             self.devices
                 .get(&PhysicalDeviceType::DiscreteGpu)
-                .ok_or(RutabagaError::InvalidGrallocGpuType)?
+                .ok_or(RutabagaErrorKind::InvalidGrallocGpuType)?
         };
 
         let usage = match info.flags.uses_rendering() {
@@ -243,12 +244,12 @@ impl VulkanoGralloc {
 
         // Reasonable bounds on image width.
         if info.width == 0 || info.width > 4096 {
-            return Err(RutabagaError::InvalidGrallocDimensions);
+            return Err(RutabagaErrorKind::InvalidGrallocDimensions.into());
         }
 
         // Reasonable bounds on image height.
         if info.height == 0 || info.height > 4096 {
-            return Err(RutabagaError::InvalidGrallocDimensions);
+            return Err(RutabagaErrorKind::InvalidGrallocDimensions.into());
         }
 
         let vulkan_format = info.drm_format.vulkan_format()?;
@@ -313,7 +314,7 @@ impl Gralloc for VulkanoGralloc {
         let device = self
             .devices
             .get(device_type)
-            .ok_or(RutabagaError::InvalidGrallocGpuType)?;
+            .ok_or(RutabagaErrorKind::InvalidGrallocGpuType)?;
 
         let planar_layout = info.drm_format.planar_layout()?;
 
@@ -390,9 +391,8 @@ impl Gralloc for VulkanoGralloc {
                 .chain(second_loop)
                 .filter(|&(i, _, _)| (memory_requirements.memory_type_bits & (1 << i)) != 0)
                 .find(|&(_, t, rq)| filter(t) == rq)
-                .ok_or(RutabagaError::SpecViolation(
-                    "unable to find required memory type",
-                ))?;
+                .context("unable to find required memory type")
+                .context(RutabagaErrorKind::SpecViolation)?;
             (found_type.0, found_type.1)
         };
 
@@ -427,16 +427,18 @@ impl Gralloc for VulkanoGralloc {
     fn allocate_memory(&mut self, reqs: ImageMemoryRequirements) -> RutabagaResult<RutabagaHandle> {
         let (raw_image, memory_requirements) = unsafe { self.create_image(reqs.info)? };
 
-        let vulkan_info = reqs.vulkan_info.ok_or(RutabagaError::InvalidVulkanInfo)?;
+        let vulkan_info = reqs
+            .vulkan_info
+            .ok_or(RutabagaErrorKind::InvalidVulkanInfo)?;
 
         let device = if self.has_integrated_gpu {
             self.devices
                 .get(&PhysicalDeviceType::IntegratedGpu)
-                .ok_or(RutabagaError::InvalidGrallocGpuType)?
+                .ok_or(RutabagaErrorKind::InvalidGrallocGpuType)?
         } else {
             self.devices
                 .get(&PhysicalDeviceType::DiscreteGpu)
-                .ok_or(RutabagaError::InvalidGrallocGpuType)?
+                .ok_or(RutabagaErrorKind::InvalidGrallocGpuType)?
         };
 
         if vulkan_info.memory_idx as usize
@@ -446,7 +448,7 @@ impl Gralloc for VulkanoGralloc {
                 .memory_types
                 .len()
         {
-            return Err(RutabagaError::InvalidVulkanInfo);
+            return Err(RutabagaErrorKind::InvalidVulkanInfo.into());
         }
 
         let (export_handle_type, export_handle_types, rutabaga_type) =
@@ -503,7 +505,7 @@ impl Gralloc for VulkanoGralloc {
         let device = self
             .device_by_id
             .get(&vulkan_info.device_id)
-            .ok_or(RutabagaError::InvalidVulkanInfo)?;
+            .ok_or(RutabagaErrorKind::InvalidVulkanInfo)?;
 
         let device_memory = unsafe {
             VulkanoGralloc::import_memory(
@@ -526,46 +528,60 @@ impl Gralloc for VulkanoGralloc {
     }
 }
 
-// Vulkano should really define an universal type that wraps all these errors, say
-// "VulkanoError(e)".
+// We should really use a universal error kind for all these errors, say
+// "VulkanoError".
 impl From<InstanceCreationError> for RutabagaError {
     fn from(e: InstanceCreationError) -> RutabagaError {
-        RutabagaError::VkInstanceCreationError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkInstanceCreationError)
+            .into()
     }
 }
 
 impl From<ImageError> for RutabagaError {
     fn from(e: ImageError) -> RutabagaError {
-        RutabagaError::VkImageCreationError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkImageCreationError)
+            .into()
     }
 }
 
 impl From<DeviceCreationError> for RutabagaError {
     fn from(e: DeviceCreationError) -> RutabagaError {
-        RutabagaError::VkDeviceCreationError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkDeviceCreationError)
+            .into()
     }
 }
 
 impl From<DeviceMemoryError> for RutabagaError {
     fn from(e: DeviceMemoryError) -> RutabagaError {
-        RutabagaError::VkDeviceMemoryError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkDeviceMemoryError)
+            .into()
     }
 }
 
 impl From<MemoryMapError> for RutabagaError {
     fn from(e: MemoryMapError) -> RutabagaError {
-        RutabagaError::VkMemoryMapError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkMemoryMapError)
+            .into()
     }
 }
 
 impl From<LoadingError> for RutabagaError {
     fn from(e: LoadingError) -> RutabagaError {
-        RutabagaError::VkLoadingError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkLoadingError)
+            .into()
     }
 }
 
 impl From<VulkanError> for RutabagaError {
     fn from(e: VulkanError) -> RutabagaError {
-        RutabagaError::VkError(e)
+        anyhow::Error::new(e)
+            .context(RutabagaErrorKind::VkError)
+            .into()
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/linux.rs b/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/linux.rs
index ec4645f84..f754da96f 100644
--- a/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/linux.rs
+++ b/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/linux.rs
@@ -17,7 +17,7 @@ use crate::rutabaga_os::FromRawDescriptor;
 use crate::rutabaga_os::IntoRawDescriptor;
 use crate::rutabaga_utils::RUTABAGA_HANDLE_TYPE_MEM_DMABUF;
 use crate::rutabaga_utils::RUTABAGA_HANDLE_TYPE_MEM_OPAQUE_FD;
-use crate::RutabagaError;
+use crate::RutabagaErrorKind;
 use crate::RutabagaHandle;
 use crate::RutabagaResult;
 
@@ -48,7 +48,7 @@ impl VulkanoGralloc {
             handle_type: match handle.handle_type {
                 RUTABAGA_HANDLE_TYPE_MEM_DMABUF => ExternalMemoryHandleType::DmaBuf,
                 RUTABAGA_HANDLE_TYPE_MEM_OPAQUE_FD => ExternalMemoryHandleType::OpaqueFd,
-                _ => return Err(RutabagaError::InvalidRutabagaHandle),
+                _ => return Err(RutabagaErrorKind::InvalidRutabagaHandle.into()),
             },
             // Safe because we own the handle.
             file: File::from_raw_descriptor(handle.os_handle.into_raw_descriptor()),
diff --git a/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/windows.rs b/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/windows.rs
index 54287c7e8..d783c20cf 100644
--- a/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/windows.rs
+++ b/rutabaga_gfx/src/rutabaga_gralloc/vulkano_gralloc/sys/windows.rs
@@ -14,7 +14,7 @@ use vulkano::memory::MemoryImportInfo;
 use crate::rutabaga_gralloc::vulkano_gralloc::VulkanoGralloc;
 use crate::rutabaga_os::AsRawDescriptor;
 use crate::rutabaga_utils::RUTABAGA_HANDLE_TYPE_MEM_OPAQUE_WIN32;
-use crate::RutabagaError;
+use crate::RutabagaErrorKind;
 use crate::RutabagaHandle;
 use crate::RutabagaResult;
 
@@ -43,7 +43,7 @@ impl VulkanoGralloc {
         let import_info = MemoryImportInfo::Win32 {
             handle_type: match handle.handle_type {
                 RUTABAGA_HANDLE_TYPE_MEM_OPAQUE_WIN32 => ExternalMemoryHandleType::OpaqueWin32,
-                _ => return Err(RutabagaError::InvalidRutabagaHandle),
+                _ => return Err(RutabagaErrorKind::InvalidRutabagaHandle.into()),
             },
             handle: handle.os_handle.as_raw_descriptor(),
         };
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/linux/event.rs b/rutabaga_gfx/src/rutabaga_os/sys/linux/event.rs
index 2b48e251f..d29ca01cd 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/linux/event.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/linux/event.rs
@@ -15,6 +15,7 @@ use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::AsRawDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaHandle;
 use crate::rutabaga_utils::RutabagaResult;
 use crate::rutabaga_utils::RUTABAGA_HANDLE_TYPE_SIGNAL_EVENT_FD;
@@ -51,7 +52,7 @@ impl TryFrom<RutabagaHandle> for Event {
     type Error = RutabagaError;
     fn try_from(handle: RutabagaHandle) -> Result<Self, Self::Error> {
         if handle.handle_type != RUTABAGA_HANDLE_TYPE_SIGNAL_EVENT_FD {
-            return Err(RutabagaError::InvalidRutabagaHandle);
+            return Err(RutabagaErrorKind::InvalidRutabagaHandle.into());
         }
 
         Ok(Event {
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs b/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs
index 6963f8f37..196b8e2b3 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs
@@ -13,7 +13,7 @@ use nix::sys::mman::MapFlags;
 use nix::sys::mman::ProtFlags;
 
 use crate::rutabaga_os::OwnedDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 use crate::rutabaga_utils::RUTABAGA_MAP_ACCESS_MASK;
 use crate::rutabaga_utils::RUTABAGA_MAP_ACCESS_READ;
@@ -50,7 +50,11 @@ impl MemoryMapping {
             RUTABAGA_MAP_ACCESS_READ => ProtFlags::PROT_READ,
             RUTABAGA_MAP_ACCESS_WRITE => ProtFlags::PROT_WRITE,
             RUTABAGA_MAP_ACCESS_RW => ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
-            _ => return Err(RutabagaError::SpecViolation("incorrect access flags")),
+            _ => {
+                return Err(anyhow::anyhow!("incorrect access flags")
+                    .context(RutabagaErrorKind::SpecViolation)
+                    .into())
+            }
         };
 
         if let Some(non_zero_size) = non_zero_opt {
@@ -68,7 +72,9 @@ impl MemoryMapping {
             };
             Ok(MemoryMapping { addr, size })
         } else {
-            Err(RutabagaError::SpecViolation("zero size mapping"))
+            Err(anyhow::anyhow!("zero size mapping")
+                .context(RutabagaErrorKind::SpecViolation)
+                .into())
         }
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/linux/shm.rs b/rutabaga_gfx/src/rutabaga_os/sys/linux/shm.rs
index 3eda262f4..cba91e037 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/linux/shm.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/linux/shm.rs
@@ -18,7 +18,7 @@ use nix::unistd::SysconfVar;
 use crate::rutabaga_os::descriptor::AsRawDescriptor;
 use crate::rutabaga_os::descriptor::IntoRawDescriptor;
 use crate::rutabaga_os::RawDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct SharedMemory {
@@ -74,6 +74,8 @@ pub fn round_up_to_page_size(v: u64) -> RutabagaResult<u64> {
         let aligned_size = (v + page_mask) & !page_mask;
         Ok(aligned_size)
     } else {
-        Err(RutabagaError::SpecViolation("no page size"))
+        Err(anyhow::anyhow!("no page size")
+            .context(RutabagaErrorKind::SpecViolation)
+            .into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/linux/tube.rs b/rutabaga_gfx/src/rutabaga_os/sys/linux/tube.rs
index 17e3f4dcc..3f1ecafbe 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/linux/tube.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/linux/tube.rs
@@ -35,7 +35,7 @@ use crate::rutabaga_os::FromRawDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
 use crate::rutabaga_os::TubeType;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 const MAX_IDENTIFIERS: usize = 28;
@@ -106,7 +106,7 @@ impl Tube {
                     })
                     .collect()
             }
-            Some(_) => return Err(RutabagaError::Unsupported),
+            Some(_) => return Err(RutabagaErrorKind::Unsupported.into()),
             None => Vec::new(),
         };
 
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/stub/event.rs b/rutabaga_gfx/src/rutabaga_os/sys/stub/event.rs
index 8c9b5d423..915e50cf3 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/stub/event.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/stub/event.rs
@@ -8,6 +8,7 @@ use std::convert::TryFrom;
 use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaHandle;
 use crate::rutabaga_utils::RutabagaResult;
 
@@ -15,26 +16,26 @@ pub struct Event(());
 
 impl Event {
     pub fn new() -> RutabagaResult<Event> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn signal(&mut self) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn wait(&self) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn try_clone(&self) -> RutabagaResult<Event> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
 impl TryFrom<RutabagaHandle> for Event {
     type Error = RutabagaError;
     fn try_from(_handle: RutabagaHandle) -> Result<Self, Self::Error> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/stub/memory_mapping.rs b/rutabaga_gfx/src/rutabaga_os/sys/stub/memory_mapping.rs
index 618e832a2..b589c272a 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/stub/memory_mapping.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/stub/memory_mapping.rs
@@ -7,7 +7,7 @@ use std::ptr::NonNull;
 use libc::c_void;
 
 use crate::rutabaga_os::OwnedDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 /// Wraps an anonymous shared memory mapping in the current process. Provides
@@ -24,6 +24,6 @@ impl MemoryMapping {
         _size: usize,
         _map_info: u32,
     ) -> RutabagaResult<MemoryMapping> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/stub/pipe.rs b/rutabaga_gfx/src/rutabaga_os/sys/stub/pipe.rs
index 5398fd056..595e460c1 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/stub/pipe.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/stub/pipe.rs
@@ -6,7 +6,7 @@ use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::AsRawDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct ReadPipeStub(());
@@ -16,12 +16,12 @@ pub type ReadPipe = ReadPipeStub;
 pub type WritePipe = WritePipeStub;
 
 pub fn create_pipe() -> RutabagaResult<(ReadPipe, WritePipe)> {
-    Err(RutabagaError::Unsupported)
+    Err(RutabagaErrorKind::Unsupported.into())
 }
 
 impl ReadPipe {
     pub fn read(&self, _data: &mut [u8]) -> RutabagaResult<usize> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -37,7 +37,7 @@ impl WritePipe {
     }
 
     pub fn write(&self, _data: &[u8]) -> RutabagaResult<usize> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/stub/shm.rs b/rutabaga_gfx/src/rutabaga_os/sys/stub/shm.rs
index 9c43d8e8f..552e52054 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/stub/shm.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/stub/shm.rs
@@ -7,7 +7,7 @@ use std::ffi::CStr;
 use crate::rutabaga_os::descriptor::AsRawDescriptor;
 use crate::rutabaga_os::descriptor::IntoRawDescriptor;
 use crate::rutabaga_os::RawDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct SharedMemory {
@@ -17,7 +17,7 @@ pub struct SharedMemory {
 impl SharedMemory {
     /// Creates a new shared memory file descriptor with zero size.
     pub fn new(_debug_name: &CStr, _size: u64) -> RutabagaResult<SharedMemory> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Gets the size in bytes of the shared memory.
@@ -43,5 +43,5 @@ impl IntoRawDescriptor for SharedMemory {
 
 /// Uses the system's page size in bytes to round the given value up to the nearest page boundary.
 pub fn round_up_to_page_size(_v: u64) -> RutabagaResult<u64> {
-    Err(RutabagaError::Unsupported)
+    Err(RutabagaErrorKind::Unsupported.into())
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/stub/tube.rs b/rutabaga_gfx/src/rutabaga_os/sys/stub/tube.rs
index fb1bc2f61..4121a82a5 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/stub/tube.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/stub/tube.rs
@@ -8,7 +8,7 @@ use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
 use crate::rutabaga_os::TubeType;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct Stub(());
@@ -17,7 +17,7 @@ pub type Listener = Stub;
 
 impl Tube {
     pub fn new<P: AsRef<Path>>(_path: P, _kind: TubeType) -> RutabagaResult<Tube> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn send(
@@ -25,14 +25,14 @@ impl Tube {
         _opaque_data: &[u8],
         _descriptors: &[RawDescriptor],
     ) -> RutabagaResult<usize> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn receive(
         &self,
         _opaque_data: &mut [u8],
     ) -> RutabagaResult<(usize, Vec<OwnedDescriptor>)> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -45,10 +45,10 @@ impl AsBorrowedDescriptor for Tube {
 impl Listener {
     /// Creates a new `Listener` bound to the given path.
     pub fn bind<P: AsRef<Path>>(_path: P) -> RutabagaResult<Listener> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn accept(&self) -> RutabagaResult<Tube> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/stub/wait_context.rs b/rutabaga_gfx/src/rutabaga_os/sys/stub/wait_context.rs
index 41f8c846e..0339b6dbc 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/stub/wait_context.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/stub/wait_context.rs
@@ -5,7 +5,7 @@
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::WaitEvent;
 use crate::rutabaga_os::WaitTimeout;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct Stub(());
@@ -13,7 +13,7 @@ pub type WaitContext = Stub;
 
 impl WaitContext {
     pub fn new() -> RutabagaResult<WaitContext> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn add(
@@ -21,14 +21,14 @@ impl WaitContext {
         _connection_id: u64,
         _descriptor: &OwnedDescriptor,
     ) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn wait(&mut self, _timeout: WaitTimeout) -> RutabagaResult<Vec<WaitEvent>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn delete(&mut self, _descriptor: &OwnedDescriptor) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/windows/event.rs b/rutabaga_gfx/src/rutabaga_os/sys/windows/event.rs
index 8c9b5d423..915e50cf3 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/windows/event.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/windows/event.rs
@@ -8,6 +8,7 @@ use std::convert::TryFrom;
 use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaHandle;
 use crate::rutabaga_utils::RutabagaResult;
 
@@ -15,26 +16,26 @@ pub struct Event(());
 
 impl Event {
     pub fn new() -> RutabagaResult<Event> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn signal(&mut self) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn wait(&self) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn try_clone(&self) -> RutabagaResult<Event> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
 impl TryFrom<RutabagaHandle> for Event {
     type Error = RutabagaError;
     fn try_from(_handle: RutabagaHandle) -> Result<Self, Self::Error> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/windows/memory_mapping.rs b/rutabaga_gfx/src/rutabaga_os/sys/windows/memory_mapping.rs
index 618e832a2..b589c272a 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/windows/memory_mapping.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/windows/memory_mapping.rs
@@ -7,7 +7,7 @@ use std::ptr::NonNull;
 use libc::c_void;
 
 use crate::rutabaga_os::OwnedDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 /// Wraps an anonymous shared memory mapping in the current process. Provides
@@ -24,6 +24,6 @@ impl MemoryMapping {
         _size: usize,
         _map_info: u32,
     ) -> RutabagaResult<MemoryMapping> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/windows/pipe.rs b/rutabaga_gfx/src/rutabaga_os/sys/windows/pipe.rs
index 5398fd056..595e460c1 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/windows/pipe.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/windows/pipe.rs
@@ -6,7 +6,7 @@ use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::AsRawDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct ReadPipeStub(());
@@ -16,12 +16,12 @@ pub type ReadPipe = ReadPipeStub;
 pub type WritePipe = WritePipeStub;
 
 pub fn create_pipe() -> RutabagaResult<(ReadPipe, WritePipe)> {
-    Err(RutabagaError::Unsupported)
+    Err(RutabagaErrorKind::Unsupported.into())
 }
 
 impl ReadPipe {
     pub fn read(&self, _data: &mut [u8]) -> RutabagaResult<usize> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -37,7 +37,7 @@ impl WritePipe {
     }
 
     pub fn write(&self, _data: &[u8]) -> RutabagaResult<usize> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/windows/shm.rs b/rutabaga_gfx/src/rutabaga_os/sys/windows/shm.rs
index 61322c9fb..9f1d52604 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/windows/shm.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/windows/shm.rs
@@ -8,7 +8,7 @@ use crate::rutabaga_os::descriptor::AsRawDescriptor;
 use crate::rutabaga_os::descriptor::IntoRawDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 /// A shared memory file descriptor and its size.
@@ -20,7 +20,7 @@ pub struct SharedMemory {
 impl SharedMemory {
     /// Creates a new shared memory file mapping with zero size.
     pub fn new(_debug_name: &CStr, _size: u64) -> RutabagaResult<Self> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     /// Gets the size in bytes of the shared memory.
@@ -48,5 +48,5 @@ impl IntoRawDescriptor for SharedMemory {
 }
 
 pub fn round_up_to_page_size(_v: u64) -> RutabagaResult<u64> {
-    Err(RutabagaError::Unsupported)
+    Err(RutabagaErrorKind::Unsupported.into())
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/windows/tube.rs b/rutabaga_gfx/src/rutabaga_os/sys/windows/tube.rs
index fb1bc2f61..4121a82a5 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/windows/tube.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/windows/tube.rs
@@ -8,7 +8,7 @@ use crate::rutabaga_os::AsBorrowedDescriptor;
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::RawDescriptor;
 use crate::rutabaga_os::TubeType;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct Stub(());
@@ -17,7 +17,7 @@ pub type Listener = Stub;
 
 impl Tube {
     pub fn new<P: AsRef<Path>>(_path: P, _kind: TubeType) -> RutabagaResult<Tube> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn send(
@@ -25,14 +25,14 @@ impl Tube {
         _opaque_data: &[u8],
         _descriptors: &[RawDescriptor],
     ) -> RutabagaResult<usize> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn receive(
         &self,
         _opaque_data: &mut [u8],
     ) -> RutabagaResult<(usize, Vec<OwnedDescriptor>)> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
 
@@ -45,10 +45,10 @@ impl AsBorrowedDescriptor for Tube {
 impl Listener {
     /// Creates a new `Listener` bound to the given path.
     pub fn bind<P: AsRef<Path>>(_path: P) -> RutabagaResult<Listener> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn accept(&self) -> RutabagaResult<Tube> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_os/sys/windows/wait_context.rs b/rutabaga_gfx/src/rutabaga_os/sys/windows/wait_context.rs
index 41f8c846e..0339b6dbc 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/windows/wait_context.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/windows/wait_context.rs
@@ -5,7 +5,7 @@
 use crate::rutabaga_os::OwnedDescriptor;
 use crate::rutabaga_os::WaitEvent;
 use crate::rutabaga_os::WaitTimeout;
-use crate::rutabaga_utils::RutabagaError;
+use crate::rutabaga_utils::RutabagaErrorKind;
 use crate::rutabaga_utils::RutabagaResult;
 
 pub struct Stub(());
@@ -13,7 +13,7 @@ pub type WaitContext = Stub;
 
 impl WaitContext {
     pub fn new() -> RutabagaResult<WaitContext> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn add(
@@ -21,14 +21,14 @@ impl WaitContext {
         _connection_id: u64,
         _descriptor: &OwnedDescriptor,
     ) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn wait(&mut self, _timeout: WaitTimeout) -> RutabagaResult<Vec<WaitEvent>> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     pub fn delete(&mut self, _descriptor: &OwnedDescriptor) -> RutabagaResult<()> {
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 }
diff --git a/rutabaga_gfx/src/rutabaga_utils.rs b/rutabaga_gfx/src/rutabaga_utils.rs
index f86d3bad4..4087539d9 100644
--- a/rutabaga_gfx/src/rutabaga_utils.rs
+++ b/rutabaga_gfx/src/rutabaga_utils.rs
@@ -20,20 +20,6 @@ use remain::sorted;
 use serde::Deserialize;
 use serde::Serialize;
 use thiserror::Error;
-#[cfg(feature = "vulkano")]
-use vulkano::device::DeviceCreationError;
-#[cfg(feature = "vulkano")]
-use vulkano::image::ImageError;
-#[cfg(feature = "vulkano")]
-use vulkano::instance::InstanceCreationError;
-#[cfg(feature = "vulkano")]
-use vulkano::memory::DeviceMemoryError;
-#[cfg(feature = "vulkano")]
-use vulkano::memory::MemoryMapError;
-#[cfg(feature = "vulkano")]
-use vulkano::LoadingError;
-#[cfg(feature = "vulkano")]
-use vulkano::VulkanError;
 use zerocopy::FromBytes;
 use zerocopy::Immutable;
 use zerocopy::IntoBytes;
@@ -235,10 +221,16 @@ pub const RUTABAGA_CAPSET_GFXSTREAM_MAGMA: u32 = 7;
 pub const RUTABAGA_CAPSET_GFXSTREAM_GLES: u32 = 8;
 pub const RUTABAGA_CAPSET_GFXSTREAM_COMPOSER: u32 = 9;
 
-/// An error generated while using this crate.
+/// A list specifying general categories of rutabaga_gfx error.
+///
+/// This list is intended to grow over time and it is not recommended to exhaustively match against
+/// it.
+///
+/// It is used with the [`RutabagaError`] type.
 #[sorted]
-#[derive(Error, Debug)]
-pub enum RutabagaError {
+#[non_exhaustive]
+#[derive(Error, Debug, Clone)]
+pub enum RutabagaErrorKind {
     /// Indicates `Rutabaga` was already initialized since only one Rutabaga instance per process
     /// is allowed.
     #[error("attempted to use a rutabaga asset already in use")]
@@ -259,6 +251,9 @@ pub enum RutabagaError {
     /// An internal Rutabaga component error was returned.
     #[error("rutabaga component failed with error {0}")]
     ComponentError(i32),
+    /// Internal error. The caller is not supposed to handle this error.
+    #[error("internal error")]
+    Internal,
     /// Invalid 2D info
     #[error("invalid 2D info")]
     Invalid2DInfo,
@@ -311,8 +306,8 @@ pub enum RutabagaError {
     #[error("invalid resource id")]
     InvalidResourceId,
     /// Indicates an error in the RutabagaBuilder.
-    #[error("invalid rutabaga build parameters: {0}")]
-    InvalidRutabagaBuild(&'static str),
+    #[error("invalid rutabaga build parameters")]
+    InvalidRutabagaBuild,
     /// An error with the RutabagaHandle
     #[error("invalid rutabaga handle")]
     InvalidRutabagaHandle,
@@ -320,8 +315,8 @@ pub enum RutabagaError {
     #[error("invalid vulkan info")]
     InvalidVulkanInfo,
     /// An input/output error occured.
-    #[error("an input/output error occur: {0}")]
-    IoError(IoError),
+    #[error("an input/output error occur")]
+    IoError,
     /// The mapping failed.
     #[error("The mapping failed with library error: {0}")]
     MappingFailed(i32),
@@ -329,81 +324,180 @@ pub enum RutabagaError {
     #[cfg(any(target_os = "android", target_os = "linux"))]
     #[error("The errno is {0}")]
     NixError(NixError),
-    #[error("Nul Error occured {0}")]
-    NulError(NulError),
+    #[error("Nul Error occured")]
+    NulError,
     /// An error with a snapshot.
-    #[error("a snapshot error occured: {0}")]
-    SnapshotError(String),
+    #[error("a snapshot error occured")]
+    SnapshotError,
     /// Violation of the Rutabaga spec occured.
-    #[error("violation of the rutabaga spec: {0}")]
-    SpecViolation(&'static str),
+    #[error("violation of the rutabaga spec")]
+    SpecViolation,
     /// An attempted integer conversion failed.
-    #[error("int conversion failed: {0}")]
-    TryFromIntError(TryFromIntError),
+    #[error("int conversion failed")]
+    TryFromIntError,
     /// The command is unsupported.
     #[error("the requested function is not implemented")]
     Unsupported,
     /// Utf8 error.
-    #[error("an utf8 error occured: {0}")]
-    Utf8Error(Utf8Error),
+    #[error("an utf8 error occured")]
+    Utf8Error,
     /// Device creation error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano device creation failure {0}")]
-    VkDeviceCreationError(DeviceCreationError),
+    #[error("vulkano device creation failure")]
+    VkDeviceCreationError,
     /// Device memory error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano device memory failure {0}")]
-    VkDeviceMemoryError(DeviceMemoryError),
+    #[error("vulkano device memory failure")]
+    VkDeviceMemoryError,
     /// General Vulkan error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano failure {0}")]
-    VkError(VulkanError),
+    #[error("vulkano failure")]
+    VkError,
     /// Image creation error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano image creation failure {0}")]
-    VkImageCreationError(ImageError),
+    #[error("vulkano image creation failure")]
+    VkImageCreationError,
     /// Instance creation error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano instance creation failure {0}")]
-    VkInstanceCreationError(InstanceCreationError),
+    #[error("vulkano instance creation failure")]
+    VkInstanceCreationError,
     /// Loading error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano loading failure {0}")]
-    VkLoadingError(LoadingError),
+    #[error("vulkano loading failure")]
+    VkLoadingError,
     /// Memory map error
     #[cfg(feature = "vulkano")]
-    #[error("vulkano memory map failure {0}")]
-    VkMemoryMapError(MemoryMapError),
+    #[error("vulkano memory map failure")]
+    VkMemoryMapError,
+}
+
+/// An error generated while using this crate.
+///
+/// Use [`RutabagaError::kind`] to distinguish between different errors.
+///
+/// # Examples
+///
+/// To create a [`RutabagaError`], create from an [`anyhow::Error`] or a
+/// [`RutabagaErrorKind`].
+///
+/// ```
+/// use rutabaga_gfx::RutabagaError;
+/// use rutabaga_gfx::RutabagaErrorKind;
+///
+/// let error: RutabagaError = anyhow::anyhow!("test error").into();
+/// assert!(matches!(error.kind(), &RutabagaErrorKind::Internal));
+///
+/// let error: RutabagaError = RutabagaErrorKind::AlreadyInUse.into();
+/// assert!(matches!(error.kind(), &RutabagaErrorKind::AlreadyInUse));
+/// ```
+///
+/// When creating from an [`anyhow::Error`], if an [`RutabagaErrorKind`] exists in the error chain,
+/// the created [`RutabagaError`] will respect that error kind, so feel free to use
+/// [`anyhow::Result`] and [`anyhow::Context::context`] in the code base, and only convert the
+/// result to [`RutabagaResult`] at the out most public interface.
+/// ```
+/// use anyhow::Context;
+/// use rutabaga_gfx::RutabagaResult;
+/// use rutabaga_gfx::RutabagaErrorKind;
+///
+/// let res = Err::<(), _>(anyhow::anyhow!("test error"))
+///     .context("context 1")
+///     .context(RutabagaErrorKind::InvalidComponent)
+///     .context("context 2");
+/// let res: RutabagaResult<()> = res.map_err(|e| e.into());
+/// let kind = res.err().map(|e| e.kind().clone());
+/// assert!(matches!(kind, Some(RutabagaErrorKind::InvalidComponent)));
+///
+/// let res = Err::<(), _>(anyhow::anyhow!("test error"))
+///     .context("context")
+///     .context(RutabagaErrorKind::InvalidComponent);
+/// let res: RutabagaResult<()> = res.map_err(|e| e.into());
+/// let kind = res.err().map(|e| e.kind().clone());
+/// assert!(matches!(kind, Some(RutabagaErrorKind::InvalidComponent)));
+///
+/// let res = Err::<(), _>(anyhow::anyhow!("test error"))
+///     .context(RutabagaErrorKind::InvalidComponent)
+///     .context("context");
+/// let res: RutabagaResult<()> = res.map_err(|e| e.into());
+/// let kind = res.err().map(|e| e.kind().clone());
+/// assert!(matches!(kind, Some(RutabagaErrorKind::InvalidComponent)));
+/// ```
+#[derive(thiserror::Error, Debug)]
+#[error("{kind}")]
+pub struct RutabagaError {
+    kind: RutabagaErrorKind,
+    #[source]
+    context: Option<anyhow::Error>,
+}
+
+impl RutabagaError {
+    pub fn kind(&self) -> &RutabagaErrorKind {
+        &self.kind
+    }
+}
+
+impl From<RutabagaErrorKind> for RutabagaError {
+    fn from(kind: RutabagaErrorKind) -> Self {
+        Self {
+            kind,
+            context: None,
+        }
+    }
+}
+
+impl From<anyhow::Error> for RutabagaError {
+    fn from(value: anyhow::Error) -> Self {
+        let kind = value
+            .downcast_ref::<RutabagaErrorKind>()
+            .unwrap_or(&RutabagaErrorKind::Internal)
+            .clone();
+        Self {
+            kind,
+            context: Some(value),
+        }
+    }
 }
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 impl From<NixError> for RutabagaError {
     fn from(e: NixError) -> RutabagaError {
-        RutabagaError::NixError(e)
+        RutabagaErrorKind::NixError(e).into()
     }
 }
 
 impl From<NulError> for RutabagaError {
     fn from(e: NulError) -> RutabagaError {
-        RutabagaError::NulError(e)
+        Self {
+            kind: RutabagaErrorKind::NulError,
+            context: Some(anyhow::Error::msg(e)),
+        }
     }
 }
 
 impl From<IoError> for RutabagaError {
     fn from(e: IoError) -> RutabagaError {
-        RutabagaError::IoError(e)
+        RutabagaError {
+            kind: RutabagaErrorKind::IoError,
+            context: Some(anyhow::Error::new(e)),
+        }
     }
 }
 
 impl From<TryFromIntError> for RutabagaError {
     fn from(e: TryFromIntError) -> RutabagaError {
-        RutabagaError::TryFromIntError(e)
+        Self {
+            kind: RutabagaErrorKind::TryFromIntError,
+            context: Some(anyhow::Error::new(e)),
+        }
     }
 }
 
 impl From<Utf8Error> for RutabagaError {
     fn from(e: Utf8Error) -> RutabagaError {
-        RutabagaError::Utf8Error(e)
+        Self {
+            kind: RutabagaErrorKind::Utf8Error,
+            context: Some(anyhow::Error::new(e)),
+        }
     }
 }
 
@@ -723,10 +817,10 @@ impl fmt::Debug for RutabagaHandle {
 impl RutabagaHandle {
     /// Clones an existing rutabaga handle, by using OS specific mechanisms.
     pub fn try_clone(&self) -> RutabagaResult<RutabagaHandle> {
-        let clone = self
-            .os_handle
-            .try_clone()
-            .map_err(|_| RutabagaError::InvalidRutabagaHandle)?;
+        let clone = self.os_handle.try_clone().map_err(|e| RutabagaError {
+            kind: RutabagaErrorKind::InvalidRutabagaHandle,
+            context: Some(anyhow::Error::new(e)),
+        })?;
         Ok(RutabagaHandle {
             os_handle: clone,
             handle_type: self.handle_type,
@@ -763,3 +857,77 @@ impl<S> fmt::Debug for RutabagaHandler<S> {
 pub type RutabagaFenceHandler = RutabagaHandler<RutabagaFence>;
 
 pub type RutabagaDebugHandler = RutabagaHandler<RutabagaDebug>;
+
+#[cfg(test)]
+mod tests {
+    use anyhow::Context;
+
+    use super::*;
+
+    #[test]
+    fn error_from_anyhow_should_keep_root_kind() {
+        let from_res = Err::<(), _>(RutabagaErrorKind::InvalidComponent)
+            .context("context 1")
+            .context("context 2");
+        let to_res: std::result::Result<_, RutabagaError> = from_res.map_err(|e| e.into());
+        let to_kind = to_res.err().map(|e| e.kind().clone());
+        assert!(
+            matches!(to_kind, Some(RutabagaErrorKind::InvalidComponent)),
+            "Expect the error kind to be RutabagaErrorKind::InvalidComponent, but is {:?}",
+            to_kind
+        );
+    }
+
+    #[test]
+    fn error_from_anyhow_should_keep_kind_added_in_context() {
+        let from_res = Err::<(), _>(anyhow::anyhow!("test error"))
+            .context("context 1")
+            .context(RutabagaErrorKind::InvalidComponent)
+            .context("context 2");
+        let to_res: std::result::Result<_, RutabagaError> = from_res.map_err(|e| e.into());
+        let to_kind = to_res.err().map(|e| e.kind().clone());
+        assert!(
+            matches!(to_kind, Some(RutabagaErrorKind::InvalidComponent)),
+            "Expect the error kind to be RutabagaErrorKind::InvalidComponent, but is {:?}",
+            to_kind
+        );
+    }
+
+    #[test]
+    fn error_from_anyhow_should_keep_top_most_kind() {
+        let from_res = Err::<(), _>(anyhow::anyhow!("test error"))
+            .context(RutabagaErrorKind::InvalidIovec)
+            .context(RutabagaErrorKind::InvalidComponent);
+        let to_res: std::result::Result<_, RutabagaError> = from_res.map_err(|e| e.into());
+        let to_kind = to_res.err().map(|e| e.kind().clone());
+        assert!(
+            matches!(to_kind, Some(RutabagaErrorKind::InvalidComponent)),
+            "Expect the error kind to be RutabagaErrorKind::InvalidComponent, but is {:?}",
+            to_kind
+        );
+    }
+
+    #[test]
+    fn error_from_kind_should_keep_kind() {
+        let from_res = Err::<(), _>(RutabagaErrorKind::InvalidComponent);
+        let to_res: std::result::Result<_, RutabagaError> = from_res.map_err(|e| e.into());
+        let to_kind = to_res.err().map(|e| e.kind().clone());
+        assert!(
+            matches!(to_kind, Some(RutabagaErrorKind::InvalidComponent)),
+            "Expect the error kind to be RutabagaErrorKind::InvalidComponent, but is {:?}",
+            to_kind
+        );
+    }
+
+    #[test]
+    fn error_from_arbitrary_anyhow_error_should_be_internal() {
+        let from_res = Err::<(), _>(anyhow::anyhow!("test error"));
+        let to_res: std::result::Result<_, RutabagaError> = from_res.map_err(|e| e.into());
+        let to_kind = to_res.err().map(|e| e.kind().clone());
+        assert!(
+            matches!(to_kind, Some(RutabagaErrorKind::Internal)),
+            "Expect the error kind to be RutabagaErrorKind::Internal, but is {:?}",
+            to_kind
+        );
+    }
+}
diff --git a/rutabaga_gfx/src/snapshot.rs b/rutabaga_gfx/src/snapshot.rs
index 582edf299..a6d499331 100644
--- a/rutabaga_gfx/src/snapshot.rs
+++ b/rutabaga_gfx/src/snapshot.rs
@@ -11,7 +11,10 @@ use std::io::BufWriter;
 use std::io::Write;
 use std::path::PathBuf;
 
+use anyhow::Context;
+
 use crate::RutabagaError;
+use crate::RutabagaErrorKind;
 use crate::RutabagaResult;
 
 pub struct RutabagaSnapshotWriter {
@@ -32,7 +35,9 @@ impl RutabagaSnapshotWriter {
     pub fn add_namespace(&self, name: &str) -> RutabagaResult<Self> {
         let directory = self.dir.join(name);
 
-        std::fs::create_dir(&directory).map_err(RutabagaError::IoError)?;
+        std::fs::create_dir(&directory)
+            .context(RutabagaErrorKind::IoError)
+            .map_err(RutabagaError::from)?;
 
         Ok(Self::from_existing(directory))
     }
@@ -43,16 +48,16 @@ impl RutabagaSnapshotWriter {
             .write(true)
             .create_new(true)
             .open(fragment_path)
-            .map_err(|e| {
-                RutabagaError::SnapshotError(format!("failed to add fragment {}: {}", name, e))
-            })?;
+            .with_context(|| format!("failed to add fragment {}", name))
+            .context(RutabagaErrorKind::SnapshotError)?;
         let mut fragment_writer = BufWriter::new(fragment_file);
-        serde_json::to_writer(&mut fragment_writer, t).map_err(|e| {
-            RutabagaError::SnapshotError(format!("failed to write fragment {}: {}", name, e))
-        })?;
-        fragment_writer.flush().map_err(|e| {
-            RutabagaError::SnapshotError(format!("failed to flush fragment {}: {}", name, e))
-        })?;
+        serde_json::to_writer(&mut fragment_writer, t)
+            .with_context(|| format!("failed to write fragment {}", name))
+            .context(RutabagaErrorKind::SnapshotError)?;
+        fragment_writer
+            .flush()
+            .with_context(|| format!("failed to flush fragment {}", name))
+            .context(RutabagaErrorKind::SnapshotError)?;
         Ok(())
     }
 }
@@ -66,10 +71,9 @@ impl RutabagaSnapshotReader {
         let directory = directory.into();
 
         if !directory.as_path().exists() {
-            return Err(RutabagaError::SnapshotError(format!(
-                "{} does not exist",
-                directory.display()
-            )));
+            return Err(anyhow::anyhow!("{} does not exist", directory.display())
+                .context(RutabagaErrorKind::SnapshotError)
+                .into());
         }
 
         Ok(Self { dir: directory })
@@ -86,12 +90,13 @@ impl RutabagaSnapshotReader {
 
     pub fn get_fragment<T: serde::de::DeserializeOwned>(&self, name: &str) -> RutabagaResult<T> {
         let fragment_path = self.dir.join(name);
-        let fragment_file = File::open(fragment_path).map_err(|e| {
-            RutabagaError::SnapshotError(format!("failed to get fragment {}: {}", name, e))
-        })?;
+        let fragment_file = File::open(fragment_path)
+            .with_context(|| format!("failed to get fragment {}", name))
+            .context(RutabagaErrorKind::SnapshotError)?;
         let mut fragment_reader = BufReader::new(fragment_file);
-        serde_json::from_reader(&mut fragment_reader).map_err(|e| {
-            RutabagaError::SnapshotError(format!("failed to read fragment {}: {}", name, e))
-        })
+        serde_json::from_reader(&mut fragment_reader)
+            .with_context(|| format!("failed to read fragment {}", name))
+            .context(RutabagaErrorKind::SnapshotError)
+            .map_err(|e| e.into())
     }
 }
diff --git a/rutabaga_gfx/src/virgl_renderer.rs b/rutabaga_gfx/src/virgl_renderer.rs
index 209fb3b07..164d97105 100644
--- a/rutabaga_gfx/src/virgl_renderer.rs
+++ b/rutabaga_gfx/src/virgl_renderer.rs
@@ -109,10 +109,10 @@ impl RutabagaContext for VirglRendererContext {
     ) -> RutabagaResult<()> {
         #[cfg(not(virgl_renderer_unstable))]
         if !fence_ids.is_empty() {
-            return Err(RutabagaError::Unsupported);
+            return Err(RutabagaErrorKind::Unsupported.into());
         }
         if commands.len() % size_of::<u32>() != 0 {
-            return Err(RutabagaError::InvalidCommandSize(commands.len()));
+            return Err(RutabagaErrorKind::InvalidCommandSize(commands.len()).into());
         }
         let dword_count = (commands.len() / size_of::<u32>()) as i32;
         #[cfg(not(virgl_renderer_unstable))]
@@ -354,7 +354,7 @@ impl VirglRenderer {
             .compare_exchange(false, true, Ordering::Acquire, Ordering::Acquire)
             .is_err()
         {
-            return Err(RutabagaError::AlreadyInUse);
+            return Err(RutabagaErrorKind::AlreadyInUse.into());
         }
 
         // TODO(b/315870313): Add safety comment
@@ -401,7 +401,7 @@ impl VirglRenderer {
     fn query(&self, resource_id: u32) -> RutabagaResult<Resource3DInfo> {
         let query = export_query(resource_id)?;
         if query.out_num_fds == 0 {
-            return Err(RutabagaError::Unsupported);
+            return Err(RutabagaErrorKind::Unsupported.into());
         }
 
         // virglrenderer unfortunately doesn't return the width or height, so map to zero.
@@ -435,7 +435,7 @@ impl VirglRenderer {
             VIRGL_RENDERER_BLOB_FD_TYPE_SHM => RUTABAGA_HANDLE_TYPE_MEM_SHM,
             VIRGL_RENDERER_BLOB_FD_TYPE_OPAQUE => RUTABAGA_HANDLE_TYPE_MEM_OPAQUE_FD,
             _ => {
-                return Err(RutabagaError::Unsupported);
+                return Err(RutabagaErrorKind::Unsupported.into());
             }
         };
 
@@ -745,7 +745,7 @@ impl RutabagaComponent for VirglRenderer {
         // Safe because virglrenderer wraps and validates use of GL/VK.
         let ret = unsafe { virgl_renderer_resource_map(resource_id, &mut map, &mut size) };
         if ret != 0 {
-            return Err(RutabagaError::MappingFailed(ret));
+            return Err(RutabagaErrorKind::MappingFailed(ret).into());
         }
 
         Ok(RutabagaMapping {
@@ -781,7 +781,7 @@ impl RutabagaComponent for VirglRenderer {
             })
         }
         #[cfg(not(virgl_renderer_unstable))]
-        Err(RutabagaError::Unsupported)
+        Err(RutabagaErrorKind::Unsupported.into())
     }
 
     #[allow(unused_variables)]
diff --git a/serde_keyvalue/Cargo.toml b/serde_keyvalue/Cargo.toml
index bddb40b56..86e4eeb94 100644
--- a/serde_keyvalue/Cargo.toml
+++ b/serde_keyvalue/Cargo.toml
@@ -8,13 +8,13 @@ edition = "2021"
 argh_derive = ["argh", "serde_keyvalue_derive"]
 
 [dependencies]
-argh = { version = "0.1.7", optional = true }
-serde_keyvalue_derive = { path = "serde_keyvalue_derive", optional = true } # provided by ebuild
-serde = "1"
-thiserror = { version = "1.0.20" }
-remain = "0.2"
+argh = { workspace = true, optional = true }
+serde_keyvalue_derive = { path = "serde_keyvalue_derive", optional = true }
+serde = { workspace = true }
+thiserror = { workspace = true }
+remain = { workspace = true }
 num-traits = "0.2"
 nom = { version = "7.1.0", features = ["alloc"] }
 
 [dev-dependencies]
-serde = { version = "1", features = ["derive"] }
+serde = { workspace = true, features = ["derive"] }
diff --git a/serde_keyvalue/serde_keyvalue_derive/Cargo.toml b/serde_keyvalue/serde_keyvalue_derive/Cargo.toml
index 7c0885d30..93639cc8e 100644
--- a/serde_keyvalue/serde_keyvalue_derive/Cargo.toml
+++ b/serde_keyvalue/serde_keyvalue_derive/Cargo.toml
@@ -7,7 +7,7 @@ edition = "2021"
 proc-macro = true
 
 [dependencies]
-argh = "0.1.7"
+argh = { workspace = true }
 proc-macro2 = "1.0"
 syn = "2"
 quote = "1.0"
diff --git a/snapshot/Android.bp b/snapshot/Android.bp
index 1a204463b..8f6ce7fc0 100644
--- a/snapshot/Android.bp
+++ b/snapshot/Android.bp
@@ -19,6 +19,7 @@ rust_library {
     rustlibs: [
         "libanyhow",
         "libbase_rust",
+        "libciborium",
         "libcrypto_generic",
         "libserde",
         "libserde_json",
diff --git a/snapshot/Cargo.toml b/snapshot/Cargo.toml
index cc1099fc0..25637f23b 100644
--- a/snapshot/Cargo.toml
+++ b/snapshot/Cargo.toml
@@ -7,8 +7,9 @@ edition = "2021"
 [features]
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base" }
-crypto = { path = "../vendor/generic/crypto", package = "crypto_generic" }
-serde = { version = "1", features = ["derive"] }
-serde_json = "1"
+anyhow = { workspace = true }
+base = { workspace = true }
+crypto = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+serde_json = { workspace = true }
+ciborium = { workspace = true }
diff --git a/snapshot/src/any_snapshot.rs b/snapshot/src/any_snapshot.rs
index fc17588c1..63362c2c8 100644
--- a/snapshot/src/any_snapshot.rs
+++ b/snapshot/src/any_snapshot.rs
@@ -14,15 +14,15 @@
 /// it will technically work, but the result might not match what you'd get if you directly
 /// serialized the original value. That should be OK as long as the serialization and
 /// deserialization paths make symmetric use of `AnySnapshot`.
-#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
-pub struct AnySnapshot(serde_json::Value);
+#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
+pub struct AnySnapshot(ciborium::Value);
 
 impl AnySnapshot {
     pub fn to_any(x: impl serde::Serialize) -> anyhow::Result<Self> {
-        Ok(AnySnapshot(serde_json::to_value(x)?))
+        Ok(AnySnapshot(ciborium::Value::serialized(&x)?))
     }
 
     pub fn from_any<T: serde::de::DeserializeOwned>(x: Self) -> anyhow::Result<T> {
-        Ok(serde_json::from_value(x.0)?)
+        Ok(x.0.deserialized()?)
     }
 }
diff --git a/snapshot/src/lib.rs b/snapshot/src/lib.rs
index c981f6db1..d4446ac8c 100644
--- a/snapshot/src/lib.rs
+++ b/snapshot/src/lib.rs
@@ -5,6 +5,7 @@
 use std::fmt::Debug;
 use std::fmt::Formatter;
 use std::fs::File;
+use std::io::BufReader;
 use std::io::Read;
 use std::io::Write;
 use std::path::Path;
@@ -117,7 +118,7 @@ impl SnapshotWriter {
     /// Creates a snapshot fragment from a serialized representation of `v`.
     pub fn write_fragment<T: serde::Serialize>(&self, name: &str, v: &T) -> Result<()> {
         let mut w = std::io::BufWriter::new(self.raw_fragment(name)?);
-        serde_json::to_writer(&mut w, v)?;
+        ciborium::into_writer(v, &mut w)?;
         w.flush()?;
         Ok(())
     }
@@ -199,8 +200,9 @@ impl SnapshotReader {
 
     /// Reads a fragment.
     pub fn read_fragment<T: serde::de::DeserializeOwned>(&self, name: &str) -> Result<T> {
-        serde_json::from_reader(std::io::BufReader::new(self.raw_fragment(name)?))
-            .with_context(|| format!("failed to parse json from snapshot fragment named {}", name))
+        Ok(ciborium::from_reader(BufReader::new(
+            self.raw_fragment(name)?,
+        ))?)
     }
 
     /// Reads the names of all fragments in this namespace.
diff --git a/src/crosvm/cmdline.rs b/src/crosvm/cmdline.rs
index 4cd9c7597..9599086bf 100644
--- a/src/crosvm/cmdline.rs
+++ b/src/crosvm/cmdline.rs
@@ -24,6 +24,8 @@ use std::sync::atomic::Ordering;
 
 use arch::CpuSet;
 use arch::FdtPosition;
+#[cfg(all(target_os = "android", target_arch = "aarch64"))]
+use arch::FfaConfig;
 #[cfg(target_arch = "x86_64")]
 use arch::MemoryRegionConfig;
 use arch::PciConfig;
@@ -42,7 +44,6 @@ use devices::virtio::scsi::ScsiOption;
 use devices::virtio::snd::parameters::Parameters as SndParameters;
 use devices::virtio::vhost::user::device;
 use devices::virtio::vsock::VsockConfig;
-use devices::virtio::DeviceType;
 #[cfg(feature = "gpu")]
 use devices::virtio::GpuDisplayParameters;
 #[cfg(feature = "gpu")]
@@ -93,7 +94,6 @@ use crate::crosvm::config::parse_mmio_address_range;
 use crate::crosvm::config::parse_pflash_parameters;
 use crate::crosvm::config::parse_serial_options;
 use crate::crosvm::config::parse_touch_device_option;
-use crate::crosvm::config::parse_vhost_user_fs_option;
 use crate::crosvm::config::BatteryConfig;
 use crate::crosvm::config::CpuOptions;
 use crate::crosvm::config::DtboOption;
@@ -104,8 +104,6 @@ use crate::crosvm::config::IrqChipKind;
 use crate::crosvm::config::MemOptions;
 use crate::crosvm::config::TouchDeviceOption;
 use crate::crosvm::config::VhostUserFrontendOption;
-use crate::crosvm::config::VhostUserFsOption;
-use crate::crosvm::config::VhostUserOption;
 #[cfg(feature = "plugin")]
 use crate::crosvm::plugin::parse_plugin_mount_option;
 #[cfg(feature = "plugin")]
@@ -1245,9 +1243,9 @@ pub struct RunCommand {
     ///       freq_domains=[[0,2],[1,3],[4-7,12]] - creates one freq_domain
     ///         for cores 0 and 2, another one for cores 1 and 3,
     ///         and one last for cores 4, 5, 6, 7 and 12.
-    ///     sve=[enabled=bool] - SVE Config. (aarch64 only)
+    ///     sve=[enable=bool] - SVE Config. (aarch64 only)
     ///         Examples:
-    ///         sve=[enabled=true] - Enables SVE on device. Will fail is SVE unsupported.
+    ///         sve=[enable=true] - Enables SVE on device. Will fail is SVE unsupported.
     ///         default value = false.
     pub cpus: Option<CpuOptions>,
 
@@ -1376,6 +1374,13 @@ pub struct RunCommand {
     /// On riscv64, defaults to `after-payload`.
     pub fdt_position: Option<FdtPosition>,
 
+    #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+    #[argh(option)]
+    #[serde(skip)] // TODO(b/255223604)
+    #[merge(strategy = overwrite_option)]
+    /// allow FF-A protocol for this vm. Currently only supported option is --guest-ffa=auto
+    pub ffa: Option<FfaConfig>,
+
     #[argh(
         option,
         arg_name = "addr=NUM,size=SIZE,path=PATH[,offset=NUM][,rw][,sync]"
@@ -1641,9 +1646,17 @@ pub struct RunCommand {
     #[argh(switch)]
     #[serde(skip)] // TODO(b/255223604)
     #[merge(strategy = overwrite_option)]
-    /// disable host swap on guest VM pages.
+    /// disable host swap on guest VM pages. use MADV_REMOVE to handle balloon. requires sandboxing
     pub lock_guest_memory: Option<bool>,
 
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    #[argh(switch)]
+    #[serde(skip)] // TODO(b/255223604)
+    #[merge(strategy = overwrite_option)]
+    /// disable host swap on guest VM pages. use MADV_DONTNEED_LOCKED to handle balloon. requires
+    /// 5.18+ kernel
+    pub lock_guest_memory_dontneed: Option<bool>,
+
     #[cfg(windows)]
     #[argh(option, arg_name = "PATH")]
     #[serde(skip)] // TODO(b/255223604)
@@ -1764,6 +1777,9 @@ pub struct RunCommand {
     ///                       Default: false.  [Optional]
     ///   pci-address     - preferred PCI address, e.g. "00:01.0"
     ///                       Default: automatic PCI address assignment. [Optional]
+    ///   mrg_rxbuf       - enable VIRTIO_NET_F_MRG_RXBUF feature.
+    ///                       If not set or set to false, it will disable this feature.
+    ///                       Default: false.  [Optional]
     ///
     /// Either one tap_name, one tap_fd or a triplet of host_ip,
     /// netmask and mac must be specified.
@@ -2232,6 +2248,8 @@ pub struct RunCommand {
     ///        Can only be given once. Will default to first serial
     ///        port if not provided.
     ///     pci-address - Preferred PCI address, e.g. "00:01.0".
+    ///     max-queue-sizes=[uint,uint] - Max size of each virtio
+    ///        queue. Only applicable when hardware=virtio-console.
     pub serial: Vec<SerialParameters>,
 
     #[cfg(windows)]
@@ -2584,12 +2602,6 @@ pub struct RunCommand {
     ///     pci-address=ADDR - Preferred PCI address, e.g. "00:01.0".
     pub vhost_user: Vec<VhostUserFrontendOption>,
 
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket for vhost-user block
-    pub vhost_user_blk: Vec<VhostUserOption>,
-
     #[argh(option)]
     #[serde(skip)]
     #[merge(strategy = overwrite_option)]
@@ -2597,64 +2609,6 @@ pub struct RunCommand {
     /// to no retries.
     pub vhost_user_connect_timeout_ms: Option<u64>,
 
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket for vhost-user console
-    pub vhost_user_console: Vec<VhostUserOption>,
-
-    #[argh(
-        option,
-        arg_name = "[socket=]SOCKET_PATH,tag=TAG[,max-queue-size=NUM]",
-        from_str_fn(parse_vhost_user_fs_option)
-    )]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket path for vhost-user fs, and tag for the shared dir
-    pub vhost_user_fs: Vec<VhostUserFsOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// paths to a vhost-user socket for gpu
-    pub vhost_user_gpu: Vec<VhostUserOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = overwrite_option)]
-    /// path to a socket for vhost-user mac80211_hwsim
-    pub vhost_user_mac80211_hwsim: Option<VhostUserOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket for vhost-user net
-    pub vhost_user_net: Vec<VhostUserOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket for vhost-user snd
-    pub vhost_user_snd: Vec<VhostUserOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket for vhost-user video decoder
-    pub vhost_user_video_decoder: Vec<VhostUserOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = append)]
-    /// path to a socket for vhost-user vsock
-    pub vhost_user_vsock: Vec<VhostUserOption>,
-
-    #[argh(option, arg_name = "SOCKET_PATH")]
-    #[serde(skip)] // Deprecated - use `vhost-user` instead.
-    #[merge(strategy = overwrite_option)]
-    /// path to a vhost-user socket for wayland
-    pub vhost_user_wl: Option<VhostUserOption>,
-
     #[cfg(any(target_os = "android", target_os = "linux"))]
     #[argh(option, arg_name = "SOCKET_PATH")]
     #[serde(skip)] // Deprecated - use `vsock` instead.
@@ -2746,6 +2700,8 @@ pub struct RunCommand {
     ///     cid=CID - CID to use for the device.
     ///     device=VHOST_DEVICE - path to the vhost-vsock device to
     ///         use (Linux only). Defaults to /dev/vhost-vsock.
+    ///     max-queue-sizes=[uint,uint,uint] - Max size of each
+    ///         virtio queue.
     pub vsock: Option<VsockConfig>,
 
     #[cfg(feature = "vtpm")]
@@ -2949,6 +2905,11 @@ impl TryFrom<RunCommand> for super::config::Config {
             cfg.swiotlb = cmd.swiotlb;
         }
 
+        #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+        {
+            cfg.ffa = cmd.ffa;
+        }
+
         cfg.hugepages = cmd.hugepages.unwrap_or_default();
 
         // `cfg.hypervisor` may have been set by the deprecated `--kvm-device` option above.
@@ -2960,6 +2921,7 @@ impl TryFrom<RunCommand> for super::config::Config {
         #[cfg(any(target_os = "android", target_os = "linux"))]
         {
             cfg.lock_guest_memory = cmd.lock_guest_memory.unwrap_or_default();
+            cfg.lock_guest_memory_dontneed = cmd.lock_guest_memory_dontneed.unwrap_or_default();
             cfg.boost_uclamp = cmd.boost_uclamp.unwrap_or_default();
         }
 
@@ -3520,6 +3482,7 @@ impl TryFrom<RunCommand> for super::config::Config {
                     vq_pairs: cmd.net_vq_pairs,
                     packed_queue: false,
                     pci_address: None,
+                    mrg_rxbuf: false,
                 });
             }
 
@@ -3534,6 +3497,7 @@ impl TryFrom<RunCommand> for super::config::Config {
                     vq_pairs: cmd.net_vq_pairs,
                     packed_queue: false,
                     pci_address: None,
+                    mrg_rxbuf: false,
                 });
             }
 
@@ -3551,13 +3515,6 @@ impl TryFrom<RunCommand> for super::config::Config {
                     None => return Err("`mac` missing from network config".to_string()),
                 };
 
-                if !cmd.vhost_user_net.is_empty() {
-                    return Err(
-                        "vhost-user-net cannot be used with any of --host-ip, --netmask or --mac"
-                            .to_string(),
-                    );
-                }
-
                 log::warn!(
                     "`--host-ip`, `--netmask`, and `--mac` are deprecated; please use \
                     `--net host-ip={host_ip},netmask={netmask},mac={mac}{vhost_net_msg}{vq_pairs_msg}`"
@@ -3573,6 +3530,7 @@ impl TryFrom<RunCommand> for super::config::Config {
                     vq_pairs: cmd.net_vq_pairs,
                     packed_queue: false,
                     pci_address: None,
+                    mrg_rxbuf: false,
                 });
             }
 
@@ -3585,6 +3543,9 @@ impl TryFrom<RunCommand> for super::config::Config {
                         net.vq_pairs = None;
                     }
                 }
+                if net.mrg_rxbuf && net.packed_queue {
+                    return Err("mrg_rxbuf and packed_queue together is unsupported".to_string());
+                }
             }
         }
 
@@ -3668,6 +3629,9 @@ impl TryFrom<RunCommand> for super::config::Config {
 
         #[cfg(feature = "gdb")]
         {
+            if cfg.suspended && cmd.gdb.is_some() {
+                return Err("suspended mode not supported with GDB".to_string());
+            }
             cfg.gdb = cmd.gdb;
         }
 
@@ -3712,41 +3676,6 @@ impl TryFrom<RunCommand> for super::config::Config {
 
         cfg.vhost_user_connect_timeout_ms = cmd.vhost_user_connect_timeout_ms;
 
-        // Convert an option from `VhostUserOption` to `VhostUserFrontendOption` with the given
-        // device type.
-        fn vu(
-            opt: impl IntoIterator<Item = VhostUserOption>,
-            type_: DeviceType,
-        ) -> impl Iterator<Item = VhostUserFrontendOption> {
-            opt.into_iter().map(move |o| {
-                log::warn!(
-                    "`--vhost-user-*` is deprecated; use `--vhost-user {},socket={}` instead",
-                    type_,
-                    o.socket.display(),
-                );
-                VhostUserFrontendOption {
-                    type_,
-                    socket: o.socket,
-                    max_queue_size: o.max_queue_size,
-                    pci_address: None,
-                }
-            })
-        }
-
-        cfg.vhost_user.extend(
-            vu(cmd.vhost_user_blk, DeviceType::Block)
-                .chain(vu(cmd.vhost_user_console, DeviceType::Console))
-                .chain(vu(cmd.vhost_user_gpu, DeviceType::Gpu))
-                .chain(vu(cmd.vhost_user_mac80211_hwsim, DeviceType::Mac80211HwSim))
-                .chain(vu(cmd.vhost_user_net, DeviceType::Net))
-                .chain(vu(cmd.vhost_user_snd, DeviceType::Sound))
-                .chain(vu(cmd.vhost_user_video_decoder, DeviceType::VideoDecoder))
-                .chain(vu(cmd.vhost_user_vsock, DeviceType::Vsock))
-                .chain(vu(cmd.vhost_user_wl, DeviceType::Wl)),
-        );
-
-        cfg.vhost_user_fs = cmd.vhost_user_fs;
-
         cfg.disable_virtio_intx = cmd.disable_virtio_intx.unwrap_or_default();
 
         cfg.dump_device_tree_blob = cmd.dump_device_tree_blob;
diff --git a/src/crosvm/config.rs b/src/crosvm/config.rs
index 5131ef06c..9e62f4f67 100644
--- a/src/crosvm/config.rs
+++ b/src/crosvm/config.rs
@@ -14,6 +14,8 @@ use std::time::Duration;
 use arch::set_default_serial_parameters;
 use arch::CpuSet;
 use arch::FdtPosition;
+#[cfg(all(target_os = "android", target_arch = "aarch64"))]
+use arch::FfaConfig;
 use arch::PciConfig;
 use arch::Pstore;
 #[cfg(target_arch = "x86_64")]
@@ -200,15 +202,6 @@ pub struct PmemOption {
     pub swap_interval: Option<Duration>,
 }
 
-#[derive(Serialize, Deserialize, FromKeyValues)]
-#[serde(deny_unknown_fields, rename_all = "kebab-case")]
-pub struct VhostUserOption {
-    pub socket: PathBuf,
-
-    /// Maximum number of entries per queue (default: 32768)
-    pub max_queue_size: Option<u16>,
-}
-
 #[derive(Serialize, Deserialize, FromKeyValues)]
 #[serde(deny_unknown_fields, rename_all = "kebab-case")]
 pub struct VhostUserFrontendOption {
@@ -226,57 +219,6 @@ pub struct VhostUserFrontendOption {
     pub pci_address: Option<PciAddress>,
 }
 
-#[derive(Serialize, Deserialize, FromKeyValues)]
-#[serde(deny_unknown_fields, rename_all = "kebab-case")]
-pub struct VhostUserFsOption {
-    #[serde(alias = "socket")]
-    pub socket_path: Option<PathBuf>,
-    /// File descriptor of connected socket
-    pub socket_fd: Option<u32>,
-    pub tag: Option<String>,
-
-    /// Maximum number of entries per queue (default: 32768)
-    pub max_queue_size: Option<u16>,
-}
-
-pub fn parse_vhost_user_fs_option(param: &str) -> Result<VhostUserFsOption, String> {
-    // Allow the previous `--vhost-user-fs /path/to/socket:fs-tag` format for compatibility.
-    // This will unfortunately prevent parsing of valid comma-separated FromKeyValues options that
-    // contain a ":" character (e.g. in a socket filename), but those were not supported in the old
-    // format either, so we can live with it until the deprecated format is removed.
-    // TODO(b/218223240): Remove support for the deprecated format (and use `FromKeyValues`
-    // directly instead of `from_str_fn`) once enough time has passed.
-    if param.contains(':') {
-        // (socket:tag)
-        let mut components = param.split(':');
-        let socket = PathBuf::from(
-            components
-                .next()
-                .ok_or("missing socket path for `vhost-user-fs`")?,
-        );
-        let tag = components
-            .next()
-            .ok_or("missing tag for `vhost-user-fs`")?
-            .to_owned();
-
-        log::warn!(
-            "`--vhost-user-fs` with colon-separated options is deprecated; \
-            please use `--vhost-user-fs {},tag={}` instead",
-            socket.display(),
-            tag,
-        );
-
-        Ok(VhostUserFsOption {
-            socket_path: Some(socket),
-            tag: Some(tag),
-            max_queue_size: None,
-            socket_fd: None,
-        })
-    } else {
-        from_key_values::<VhostUserFsOption>(param)
-    }
-}
-
 pub const DEFAULT_TOUCH_DEVICE_HEIGHT: u32 = 1024;
 pub const DEFAULT_TOUCH_DEVICE_WIDTH: u32 = 1280;
 
@@ -400,9 +342,9 @@ fn parse_hex_or_decimal(maybe_hex_string: &str) -> Result<u64, String> {
 }
 
 pub fn parse_mmio_address_range(s: &str) -> Result<Vec<AddressRange>, String> {
-    s.split(",")
+    s.split(',')
         .map(|s| {
-            let r: Vec<&str> = s.split("-").collect();
+            let r: Vec<&str> = s.split('-').collect();
             if r.len() != 2 {
                 return Err(invalid_value_err(s, "invalid range"));
             }
@@ -688,6 +630,8 @@ pub struct Config {
     #[cfg(windows)]
     pub exit_stats: bool,
     pub fdt_position: Option<FdtPosition>,
+    #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+    pub ffa: Option<FfaConfig>,
     pub file_backed_mappings_mmio: Vec<FileBackedMappingParameters>,
     pub file_backed_mappings_ram: Vec<FileBackedMappingParameters>,
     pub force_calibrated_tsc_leaf: bool,
@@ -724,6 +668,8 @@ pub struct Config {
     pub kernel_log_file: Option<String>,
     #[cfg(any(target_os = "android", target_os = "linux"))]
     pub lock_guest_memory: bool,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    pub lock_guest_memory_dontneed: bool,
     #[cfg(windows)]
     pub log_file: Option<String>,
     #[cfg(windows)]
@@ -827,7 +773,6 @@ pub struct Config {
     pub vhost_scmi_device: PathBuf,
     pub vhost_user: Vec<VhostUserFrontendOption>,
     pub vhost_user_connect_timeout_ms: Option<u64>,
-    pub vhost_user_fs: Vec<VhostUserFsOption>,
     #[cfg(feature = "video-decoder")]
     pub video_dec: Vec<VideoDeviceConfig>,
     #[cfg(feature = "video-encoder")]
@@ -921,6 +866,8 @@ impl Default for Config {
             #[cfg(windows)]
             exit_stats: false,
             fdt_position: None,
+            #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+            ffa: None,
             file_backed_mappings_mmio: Vec::new(),
             file_backed_mappings_ram: Vec::new(),
             force_calibrated_tsc_leaf: false,
@@ -965,6 +912,8 @@ impl Default for Config {
             kernel_log_file: None,
             #[cfg(any(target_os = "android", target_os = "linux"))]
             lock_guest_memory: false,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            lock_guest_memory_dontneed: false,
             #[cfg(windows)]
             log_file: None,
             #[cfg(windows)]
@@ -1060,7 +1009,6 @@ impl Default for Config {
             vhost_scmi_device: PathBuf::from(VHOST_SCMI_PATH),
             vhost_user: Vec::new(),
             vhost_user_connect_timeout_ms: None,
-            vhost_user_fs: Vec::new(),
             vsock: None,
             #[cfg(feature = "video-decoder")]
             video_dec: Vec::new(),
@@ -1269,6 +1217,14 @@ pub fn validate_config(cfg: &mut Config) -> std::result::Result<(), String> {
         return Err("'lock-guest-memory' and 'disable-sandbox' are mutually exclusive".to_string());
     }
 
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    if cfg.lock_guest_memory && cfg.lock_guest_memory_dontneed {
+        return Err(
+            "'lock-guest-memory' and 'lock-guest-memory-dontneed' are mutually exclusive"
+                .to_string(),
+        );
+    }
+
     // TODO(b/253386409): Vmm-swap only support sandboxed devices until vmm-swap use
     // `devices::Suspendable` to suspend devices.
     #[cfg(feature = "swap")]
@@ -1956,17 +1912,6 @@ mod tests {
         }
     }
 
-    #[test]
-    fn parse_vhost_user_option() {
-        let opt: VhostUserOption = from_key_values("/10mm").unwrap();
-        assert_eq!(opt.socket.to_str(), Some("/10mm"));
-        assert_eq!(opt.max_queue_size, None);
-
-        let opt: VhostUserOption = from_key_values("/10mm,max-queue-size=256").unwrap();
-        assert_eq!(opt.socket.to_str(), Some("/10mm"));
-        assert_eq!(opt.max_queue_size, Some(256));
-    }
-
     #[test]
     fn parse_vhost_user_option_all_device_types() {
         fn test_device_type(type_string: &str, type_: DeviceType) {
@@ -2009,133 +1954,6 @@ mod tests {
         test_device_type("pvclock", DeviceType::Pvclock);
     }
 
-    #[test]
-    fn parse_vhost_user_fs_deprecated() {
-        let cfg = TryInto::<Config>::try_into(
-            crate::crosvm::cmdline::RunCommand::from_args(
-                &[],
-                &["--vhost-user-fs", "my_socket:my_tag", "/dev/null"],
-            )
-            .unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(cfg.vhost_user_fs.len(), 1);
-        let fs = &cfg.vhost_user_fs[0];
-        let socket = fs.socket_path.as_ref().unwrap();
-        assert_eq!(socket.to_str(), Some("my_socket"));
-        assert_eq!(fs.tag, Some("my_tag".to_string()));
-        assert_eq!(fs.max_queue_size, None);
-        assert_eq!(fs.socket_fd, None);
-    }
-
-    #[test]
-    fn parse_vhost_user_fs() {
-        let cfg = TryInto::<Config>::try_into(
-            crate::crosvm::cmdline::RunCommand::from_args(
-                &[],
-                &["--vhost-user-fs", "my_socket,tag=my_tag", "/dev/null"],
-            )
-            .unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(cfg.vhost_user_fs.len(), 1);
-        let fs = &cfg.vhost_user_fs[0];
-        let socket = fs.socket_path.as_ref().unwrap();
-        assert_eq!(socket.to_str(), Some("my_socket"));
-        assert_eq!(fs.tag, Some("my_tag".to_string()));
-        assert_eq!(fs.max_queue_size, None);
-    }
-
-    #[test]
-    fn parse_vhost_user_fs_explict_socket() {
-        let cfg = TryInto::<Config>::try_into(
-            crate::crosvm::cmdline::RunCommand::from_args(
-                &[],
-                &[
-                    "--vhost-user-fs",
-                    "socket=my_socket,tag=my_tag",
-                    "/dev/null",
-                ],
-            )
-            .unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(cfg.vhost_user_fs.len(), 1);
-        let fs = &cfg.vhost_user_fs[0];
-        let socket = fs.socket_path.as_ref().unwrap();
-        assert_eq!(socket.to_str(), Some("my_socket"));
-        assert_eq!(fs.tag, Some("my_tag".to_string()));
-        assert_eq!(fs.max_queue_size, None);
-    }
-
-    #[test]
-    fn parse_vhost_user_fs_max_queue_size() {
-        let cfg = TryInto::<Config>::try_into(
-            crate::crosvm::cmdline::RunCommand::from_args(
-                &[],
-                &[
-                    "--vhost-user-fs",
-                    "my_socket,tag=my_tag,max-queue-size=256",
-                    "/dev/null",
-                ],
-            )
-            .unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(cfg.vhost_user_fs.len(), 1);
-        let fs = &cfg.vhost_user_fs[0];
-        let socket = fs.socket_path.as_ref().unwrap();
-        assert_eq!(socket.to_str(), Some("my_socket"));
-        assert_eq!(fs.tag, Some("my_tag".to_string()));
-        assert_eq!(fs.max_queue_size, Some(256));
-    }
-
-    #[test]
-    fn parse_vhost_user_fs_no_tag() {
-        let cfg = TryInto::<Config>::try_into(
-            crate::crosvm::cmdline::RunCommand::from_args(
-                &[],
-                &["--vhost-user-fs", "my_socket", "/dev/null"],
-            )
-            .unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(cfg.vhost_user_fs.len(), 1);
-        let fs = &cfg.vhost_user_fs[0];
-        let socket = fs.socket_path.as_ref().unwrap();
-        assert_eq!(socket.to_str(), Some("my_socket"));
-        assert_eq!(fs.tag, None);
-        assert_eq!(fs.max_queue_size, None);
-    }
-
-    #[test]
-    fn parse_vhost_user_fs_socket_fd() {
-        let cfg = TryInto::<Config>::try_into(
-            crate::crosvm::cmdline::RunCommand::from_args(
-                &[],
-                &[
-                    "--vhost-user-fs",
-                    "tag=my_tag,max-queue-size=256,socket-fd=1234",
-                    "/dev/null",
-                ],
-            )
-            .unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(cfg.vhost_user_fs.len(), 1);
-        let fs = &cfg.vhost_user_fs[0];
-        assert!(fs.socket_path.is_none());
-        assert_eq!(fs.tag, Some("my_tag".to_string()));
-        assert_eq!(fs.max_queue_size, Some(256));
-        assert_eq!(fs.socket_fd.unwrap(), 1234_u32);
-    }
-
     #[cfg(target_arch = "x86_64")]
     #[test]
     fn parse_smbios_uuid() {
diff --git a/src/crosvm/sys/linux.rs b/src/crosvm/sys/linux.rs
index 50e3b059d..577cee5b7 100644
--- a/src/crosvm/sys/linux.rs
+++ b/src/crosvm/sys/linux.rs
@@ -841,12 +841,6 @@ fn create_virtio_devices(
             )?);
         }
     }
-    for vhost_user_fs in &cfg.vhost_user_fs {
-        devs.push(create_vhost_user_fs_device(
-            cfg.protection_type,
-            vhost_user_fs,
-        )?);
-    }
 
     for shared_dir in &cfg.shared_dirs {
         let SharedDir {
@@ -1363,6 +1357,13 @@ fn setup_vm_components(cfg: &Config) -> Result<VmComponents> {
         (cfg.cpu_clusters.clone(), cfg.cpu_capacity.clone())
     };
 
+    #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
+    let cpu_ipc_ratio = if cfg.host_cpu_topology {
+        &cpu_capacity
+    } else {
+        &cfg.cpu_ipc_ratio
+    };
+
     #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
     let mut vcpu_domain_paths = BTreeMap::new();
     #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
@@ -1422,7 +1423,7 @@ fn setup_vm_components(cfg: &Config) -> Result<VmComponents> {
                     )
                 }),
                 host_max_freq,
-                |cpu_id| cfg.cpu_ipc_ratio.get(&cpu_id).copied().unwrap_or(1024),
+                |cpu_id| cpu_ipc_ratio.get(&cpu_id).copied().unwrap_or(1024),
             )?;
 
             if !cfg.cpu_freq_domains.is_empty() {
@@ -1504,6 +1505,8 @@ fn setup_vm_components(cfg: &Config) -> Result<VmComponents> {
             #[cfg(target_arch = "aarch64")]
             mte: cfg.mte,
             protection_type: cfg.protection_type,
+            #[cfg(all(target_os = "android", target_arch = "aarch64"))]
+            ffa: cfg.ffa.map(|g| g.auto).unwrap_or(false),
         },
         vm_image,
         android_fstab: cfg
@@ -1677,9 +1680,12 @@ fn create_guest_memory(
         mem_policy |= MemoryPolicy::USE_HUGEPAGES;
     }
 
-    if cfg.lock_guest_memory {
+    if cfg.lock_guest_memory || cfg.lock_guest_memory_dontneed {
         mem_policy |= MemoryPolicy::LOCK_GUEST_MEMORY;
     }
+    if cfg.lock_guest_memory_dontneed {
+        mem_policy |= MemoryPolicy::USE_DONTNEED_LOCKED;
+    }
     guest_mem.set_memory_policy(mem_policy);
 
     if cfg.unmap_guest_memory_on_fork {
@@ -1887,7 +1893,14 @@ fn run_gunyah(
         None
     };
 
-    let vm = GunyahVm::new(&gunyah, qcom_trusted_vm_id, qcom_trusted_vm_pas_id, guest_mem, components.hv_cfg).context("failed to create vm")?;
+    let vm = GunyahVm::new(
+        &gunyah,
+        qcom_trusted_vm_id,
+        qcom_trusted_vm_pas_id,
+        guest_mem,
+        components.hv_cfg,
+    )
+    .context("failed to create vm")?;
 
     // Check that the VM was actually created in protected mode as expected.
     if cfg.protection_type.isolates_memory() && !vm.check_capability(VmCap::Protected) {
@@ -1968,14 +1981,17 @@ pub fn run_config(cfg: Config) -> Result<ExitState> {
             any(target_arch = "arm", target_arch = "aarch64"),
             feature = "gunyah"
         ))]
-        HypervisorKind::Gunyah { device,
-                                 qcom_trusted_vm_id,
-                                 qcom_trusted_vm_pas_id
-                               } => run_gunyah(
-                                        device.as_deref(),
-                                        qcom_trusted_vm_id,
-                                        qcom_trusted_vm_pas_id,
-                                        cfg, components),
+        HypervisorKind::Gunyah {
+            device,
+            qcom_trusted_vm_id,
+            qcom_trusted_vm_pas_id,
+        } => run_gunyah(
+            device.as_deref(),
+            qcom_trusted_vm_id,
+            qcom_trusted_vm_pas_id,
+            cfg,
+            components,
+        ),
     }
 }
 
@@ -2276,7 +2292,9 @@ where
         .iter_mut()
         .filter_map(|(dev, _)| dev.as_pci_device_mut())
     {
-        device.generate_acpi(&mut components.acpi_sdts);
+        device
+            .generate_acpi(&mut components.acpi_sdts)
+            .with_context(|| format!("generate_acpi failed for {}", device.debug_label()))?;
     }
 
     // KVM_CREATE_VCPU uses apic id for x86 and uses cpu id for others.
@@ -2727,6 +2745,7 @@ fn handle_hotplug_net_add<V: VmArch, Vcpu: VcpuArch>(
         vq_pairs: None,
         packed_queue: false,
         pci_address: None,
+        mrg_rxbuf: false,
     };
     let ret = add_hotplug_net(
         linux,
@@ -3654,7 +3673,6 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
     let (device_ctrl_tube, device_ctrl_resp) = Tube::pair().context("failed to create tube")?;
     // Create devices thread, and restore if a restore file exists.
     linux.devices_thread = match create_devices_worker_thread(
-        linux.vm.get_memory().clone(),
         linux.io_bus.clone(),
         linux.mmio_bus.clone(),
         device_ctrl_resp,
@@ -4310,25 +4328,6 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
         }
     }
 
-    // Shut down the VM Memory handler thread.
-    if let Err(e) = vm_memory_handler_control.send(&VmMemoryHandlerRequest::Exit) {
-        error!(
-            "failed to request exit from VM Memory handler thread: {}",
-            e
-        );
-    }
-    if let Err(e) = vm_memory_handler_thread.join() {
-        error!("failed to exit VM Memory handler thread: {:?}", e);
-    }
-
-    // Shut down the IRQ handler thread.
-    if let Err(e) = irq_handler_control.send(&IrqHandlerRequest::Exit) {
-        error!("failed to request exit from IRQ handler thread: {}", e);
-    }
-    if let Err(e) = irq_handler_thread.join() {
-        error!("failed to exit irq handler thread: {:?}", e);
-    }
-
     // At this point, the only remaining `Arc` references to the `Bus` objects should be the ones
     // inside `linux`. If the checks below fail, then some other thread is probably still running
     // and needs to be explicitly stopped before dropping `linux` to ensure devices actually get
@@ -4352,6 +4351,28 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
     // control sockets are closed when this function exits.
     mem::drop(linux);
 
+    // Shut down the VM memory handler thread. This must happen after the potential device worker
+    // threads(including the vhost device request handler threads) exit, because device worker
+    // threads can issue VM memory requests. Those device worker threads are supposed to stop after
+    // the RunnableLinuxVm is dropped.
+    if let Err(e) = vm_memory_handler_control.send(&VmMemoryHandlerRequest::Exit) {
+        error!(
+            "failed to request exit from VM Memory handler thread: {}",
+            e
+        );
+    }
+    if let Err(e) = vm_memory_handler_thread.join() {
+        error!("failed to exit VM Memory handler thread: {:?}", e);
+    }
+
+    // Shut down the IRQ handler thread after the devices are dropped.
+    if let Err(e) = irq_handler_control.send(&IrqHandlerRequest::Exit) {
+        error!("failed to request exit from IRQ handler thread: {}", e);
+    }
+    if let Err(e) = irq_handler_thread.join() {
+        error!("failed to exit irq handler thread: {:?}", e);
+    }
+
     // Drop the hotplug manager to tell the warden process to exit before we try to join
     // the metrics thread.
     #[cfg(feature = "pci-hotplug")]
@@ -5043,13 +5064,11 @@ pub fn start_devices(opts: DevicesCommand) -> anyhow::Result<()> {
         return Ok(());
     }
 
-    let ex = Executor::new()?;
     if let Some(control_server_socket) = control_server_socket {
         // Start the control server in the parent process.
-        ex.spawn_blocking(move || {
+        std::thread::spawn(move || {
             start_vhost_user_control_server(control_server_socket, disk_host_tubes)
-        })
-        .detach();
+        });
     }
 
     // Now wait for all device processes to return.
diff --git a/src/crosvm/sys/linux/android.rs b/src/crosvm/sys/linux/android.rs
index 8b9310673..b940aaf96 100644
--- a/src/crosvm/sys/linux/android.rs
+++ b/src/crosvm/sys/linux/android.rs
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#![cfg(target_os = "android")]
-
 use std::ffi::CString;
 
 use anyhow::anyhow;
diff --git a/src/crosvm/sys/linux/config.rs b/src/crosvm/sys/linux/config.rs
index 172a55441..414cb81dd 100644
--- a/src/crosvm/sys/linux/config.rs
+++ b/src/crosvm/sys/linux/config.rs
@@ -653,7 +653,11 @@ mod tests {
     fn hypervisor_gunyah_device_with_qtvm_ids() {
         let config: Config = crate::crosvm::cmdline::RunCommand::from_args(
             &[],
-            &["--hypervisor", "gunyah[device=/not/default,qcom_trusted_vm_id=0,qcom_trusted_vm_pas_id=0]", "/dev/null"],
+            &[
+                "--hypervisor",
+                "gunyah[device=/not/default,qcom_trusted_vm_id=0,qcom_trusted_vm_pas_id=0]",
+                "/dev/null",
+            ],
         )
         .unwrap()
         .try_into()
diff --git a/src/crosvm/sys/linux/device_helpers.rs b/src/crosvm/sys/linux/device_helpers.rs
index 281160438..b9fcdbd44 100644
--- a/src/crosvm/sys/linux/device_helpers.rs
+++ b/src/crosvm/sys/linux/device_helpers.rs
@@ -5,12 +5,10 @@
 use std::collections::BTreeMap;
 use std::collections::BTreeSet;
 use std::convert::TryFrom;
-use std::fs;
 use std::fs::File;
 use std::fs::OpenOptions;
 use std::io::ErrorKind;
 use std::ops::RangeInclusive;
-use std::os::unix::fs::FileTypeExt;
 use std::os::unix::net::UnixStream;
 use std::path::Path;
 use std::path::PathBuf;
@@ -94,7 +92,6 @@ use vm_memory::GuestAddress;
 
 use crate::crosvm::config::PmemOption;
 use crate::crosvm::config::VhostUserFrontendOption;
-use crate::crosvm::config::VhostUserFsOption;
 use crate::crosvm::sys::config::PmemExt2Option;
 
 /// All the tube types collected and passed to `run_control`.
@@ -436,28 +433,6 @@ fn vhost_user_connection(
     }
 }
 
-fn is_socket(path: &PathBuf) -> bool {
-    match fs::metadata(path) {
-        Ok(metadata) => metadata.file_type().is_socket(),
-        Err(_) => false, // Assume not a socket if we can't get metadata
-    }
-}
-
-fn vhost_user_connection_from_socket_fd(
-    fd: u32,
-) -> Result<vmm_vhost::Connection<vmm_vhost::FrontendReq>> {
-    let path = PathBuf::from(format!("/proc/self/fd/{}", fd));
-    if !is_socket(&path) {
-        anyhow::bail!("path {} is not socket", path.display());
-    }
-
-    let safe_fd = safe_descriptor_from_cmdline_fd(&(fd as i32))?;
-
-    safe_fd
-        .try_into()
-        .context("failed to create vhost-user connection from fd")
-}
-
 pub fn create_vhost_user_frontend(
     protection_type: ProtectionType,
     opt: &VhostUserFrontendOption,
@@ -486,31 +461,6 @@ pub fn create_vhost_user_frontend(
     })
 }
 
-pub fn create_vhost_user_fs_device(
-    protection_type: ProtectionType,
-    option: &VhostUserFsOption,
-) -> DeviceResult {
-    let connection = match (&option.socket_path, option.socket_fd) {
-        (Some(socket), None) => vhost_user_connection(socket, None)?,
-        (None, Some(fd)) => vhost_user_connection_from_socket_fd(fd)?,
-        (Some(_), Some(_)) => bail!("Cannot specify both a UDS path and a file descriptor"),
-        (None, None) => bail!("Must specify either a socket or a file descriptor"),
-    };
-    let dev = VhostUserFrontend::new_fs(
-        virtio::base_features(protection_type),
-        connection,
-        option.max_queue_size,
-        option.tag.as_deref(),
-    )
-    .context("failed to set up vhost-user fs device")?;
-
-    Ok(VirtioDeviceStub {
-        dev: Box::new(dev),
-        // no sandbox here because virtqueue handling is exported to a different process.
-        jail: None,
-    })
-}
-
 pub fn create_rng_device(
     protection_type: ProtectionType,
     jail_config: Option<&JailConfig>,
@@ -913,6 +863,7 @@ impl VirtioDeviceBuilder for &NetParameters {
                     mac,
                     self.packed_queue,
                     self.pci_address,
+                    self.mrg_rxbuf,
                 )
                 .context("failed to set up virtio-vhost networking")?,
             ) as Box<dyn VirtioDevice>
@@ -925,6 +876,7 @@ impl VirtioDeviceBuilder for &NetParameters {
                     mac,
                     self.packed_queue,
                     self.pci_address,
+                    self.mrg_rxbuf,
                 )
                 .context("failed to set up virtio networking")?,
             ) as Box<dyn VirtioDevice>
@@ -953,7 +905,7 @@ impl VirtioDeviceBuilder for &NetParameters {
         let multi_vq = vq_pairs > 1 && self.vhost_net.is_none();
         let (tap, _mac) = create_tap_for_net_device(&self.mode, multi_vq)?;
 
-        let backend = NetBackend::new(tap)?;
+        let backend = NetBackend::new(tap, self.mrg_rxbuf)?;
 
         keep_rds.extend(backend.as_raw_descriptors());
 
@@ -1213,6 +1165,10 @@ impl VirtioDeviceBuilder for &VsockConfig {
         self,
         keep_rds: &mut Vec<RawDescriptor>,
     ) -> anyhow::Result<Box<dyn VhostUserDeviceBuilder>> {
+        if self.max_queue_sizes.is_some() {
+            bail!("vhost-user vsock doesn't support max-queue-sizes option");
+        }
+
         let vsock_device = VhostUserVsockDevice::new(self.cid, &self.vhost_device)?;
 
         keep_rds.push(vsock_device.as_raw_descriptor());
diff --git a/src/crosvm/sys/linux/vcpu.rs b/src/crosvm/sys/linux/vcpu.rs
index 20d730d55..70b6bc431 100644
--- a/src/crosvm/sys/linux/vcpu.rs
+++ b/src/crosvm/sys/linux/vcpu.rs
@@ -76,11 +76,13 @@ pub fn set_vcpu_thread_scheduling(
     boost_uclamp: bool,
 ) -> anyhow::Result<()> {
     if boost_uclamp {
-        let mut sched_attr = sched_attr::default();
-        sched_attr.sched_flags = SCHED_FLAG_KEEP_ALL as u64
-            | SCHED_FLAG_UTIL_CLAMP_MIN
-            | SCHED_FLAG_RESET_ON_FORK as u64;
-        sched_attr.sched_util_min = SCHED_SCALE_CAPACITY;
+        let mut sched_attr = sched_attr {
+            sched_flags: SCHED_FLAG_KEEP_ALL as u64
+                | SCHED_FLAG_UTIL_CLAMP_MIN
+                | SCHED_FLAG_RESET_ON_FORK as u64,
+            sched_util_min: SCHED_SCALE_CAPACITY,
+            ..Default::default()
+        };
 
         if let Err(e) = sched_setattr(0, &mut sched_attr, 0) {
             warn!("Failed to boost vcpu util: {}", e);
diff --git a/src/main.rs b/src/main.rs
index a8badbb28..1dcc901e0 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -9,6 +9,8 @@
 
 #[cfg(any(feature = "composite-disk", feature = "qcow"))]
 use std::fs::OpenOptions;
+#[cfg(feature = "composite-disk")]
+use std::io::Write;
 use std::path::Path;
 
 use anyhow::anyhow;
@@ -362,7 +364,7 @@ fn modify_virtio_net(cmd: cmdline::VirtioNetCommand) -> std::result::Result<(),
 fn parse_composite_partition_arg(
     partition_arg: &str,
 ) -> std::result::Result<(String, String, bool, Option<Uuid>), ()> {
-    let mut partition_fields = partition_arg.split(":");
+    let mut partition_fields = partition_arg.split(':');
 
     let label = partition_fields.next();
     let path = partition_fields.next();
@@ -401,6 +403,7 @@ fn parse_composite_partition_arg(
 
 #[cfg(feature = "composite-disk")]
 fn create_composite(cmd: cmdline::CreateCompositeCommand) -> std::result::Result<(), ()> {
+    use std::io::BufWriter;
     use std::path::PathBuf;
 
     let composite_image_path = &cmd.path;
@@ -426,7 +429,7 @@ fn create_composite(cmd: cmdline::CreateCompositeCommand) -> std::result::Result
             &zero_filler_path, e
         );
     })?;
-    let mut header_file = OpenOptions::new()
+    let header_file = OpenOptions::new()
         .create(true)
         .read(true)
         .write(true)
@@ -438,7 +441,8 @@ fn create_composite(cmd: cmdline::CreateCompositeCommand) -> std::result::Result
                 header_path, e
             );
         })?;
-    let mut footer_file = OpenOptions::new()
+    let mut header_buffer = BufWriter::new(header_file);
+    let footer_file = OpenOptions::new()
         .create(true)
         .read(true)
         .write(true)
@@ -450,6 +454,7 @@ fn create_composite(cmd: cmdline::CreateCompositeCommand) -> std::result::Result
                 footer_path, e
             );
         })?;
+    let mut footer_buffer = BufWriter::new(footer_file);
 
     let partitions = cmd
         .partitions
@@ -487,9 +492,9 @@ fn create_composite(cmd: cmdline::CreateCompositeCommand) -> std::result::Result
         &partitions,
         &PathBuf::from(zero_filler_path),
         &PathBuf::from(header_path),
-        &mut header_file,
+        &mut header_buffer,
         &PathBuf::from(footer_path),
-        &mut footer_file,
+        &mut footer_buffer,
         &mut composite_image_file,
     )
     .map_err(|e| {
@@ -498,6 +503,12 @@ fn create_composite(cmd: cmdline::CreateCompositeCommand) -> std::result::Result
             composite_image_path, e
         );
     })?;
+    header_buffer.flush().map_err(|e| {
+        error!("Failed to flush header buffer: {}", e);
+    })?;
+    footer_buffer.flush().map_err(|e| {
+        error!("Failed to flush footer buffer: {}", e);
+    })?;
 
     Ok(())
 }
@@ -725,7 +736,7 @@ fn prepare_argh_args<I: IntoIterator<Item = String>>(args_iter: I) -> Vec<String
             "-h" => args.push("--help".to_string()),
             arg if is_flag(arg) => {
                 // Split `--arg=val` into `--arg val`, since argh doesn't support the former.
-                if let Some((key, value)) = arg.split_once("=") {
+                if let Some((key, value)) = arg.split_once('=') {
                     args.push(key.to_string());
                     args.push(value.to_string());
                 } else {
@@ -753,8 +764,6 @@ fn shorten_usage(help: &str) -> String {
 }
 
 fn crosvm_main<I: IntoIterator<Item = String>>(args: I) -> Result<CommandStatus> {
-    let _library_watcher = sys::get_library_watcher();
-
     // The following panic hook will stop our crashpad hook on windows.
     // Only initialize when the crash-pad feature is off.
     #[cfg(not(feature = "crash-report"))]
diff --git a/src/sys.rs b/src/sys.rs
index ee8a9eef6..58b0f619b 100644
--- a/src/sys.rs
+++ b/src/sys.rs
@@ -21,7 +21,6 @@ cfg_if::cfg_if! {
 
 pub(crate) use platform::main::cleanup;
 pub(crate) use platform::main::error_to_exit_code;
-pub(crate) use platform::main::get_library_watcher;
 pub(crate) use platform::main::init_log;
 pub(crate) use platform::main::run_command;
 pub(crate) use platform::main::start_device;
diff --git a/src/sys/linux/main.rs b/src/sys/linux/main.rs
index 7ee177c8d..db555f5be 100644
--- a/src/sys/linux/main.rs
+++ b/src/sys/linux/main.rs
@@ -75,10 +75,6 @@ pub(crate) fn cleanup() {
     }
 }
 
-pub fn get_library_watcher() -> std::io::Result<()> {
-    Ok(())
-}
-
 pub(crate) fn run_command(command: Commands, _log_args: LogArgs) -> anyhow::Result<()> {
     match command {
         Commands::Devices(cmd) => start_devices(cmd).context("start_devices subcommand failed"),
diff --git a/src/sys/linux/panic_hook.rs b/src/sys/linux/panic_hook.rs
index 491eb487b..c64b9e051 100644
--- a/src/sys/linux/panic_hook.rs
+++ b/src/sys/linux/panic_hook.rs
@@ -7,7 +7,7 @@ use std::fs::File;
 use std::io::stderr;
 use std::io::Read;
 use std::panic;
-use std::panic::PanicInfo;
+use std::panic::PanicHookInfo;
 use std::process::abort;
 use std::string::String;
 
@@ -66,7 +66,10 @@ fn restore_stderr(stderr: File) -> bool {
 }
 
 // Sends as much information about the panic as possible to syslog.
-fn log_panic_info(default_panic: &(dyn Fn(&PanicInfo) + Sync + Send + 'static), info: &PanicInfo) {
+fn log_panic_info(
+    default_panic: &(dyn Fn(&PanicHookInfo) + Sync + Send + 'static),
+    info: &PanicHookInfo,
+) {
     // Grab a lock of stderr to prevent concurrent threads from trampling on our stderr capturing
     // procedure. The default_panic procedure likely uses stderr.lock as well, but the mutex inside
     // stderr is reentrant, so it will not dead-lock on this thread.
diff --git a/src/sys/windows.rs b/src/sys/windows.rs
index 61ec87678..df2196939 100644
--- a/src/sys/windows.rs
+++ b/src/sys/windows.rs
@@ -1379,7 +1379,6 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
 
     let (device_ctrl_tube, device_ctrl_resp) = Tube::pair().context("failed to create tube")?;
     guest_os.devices_thread = match create_devices_worker_thread(
-        guest_os.vm.get_memory().clone(),
         guest_os.io_bus.clone(),
         guest_os.mmio_bus.clone(),
         device_ctrl_resp,
@@ -1585,22 +1584,6 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
         }
     }
 
-    // Shut down the VM memory handler thread.
-    if let Err(e) = vm_memory_handler_control.send(&VmMemoryHandlerRequest::Exit) {
-        error!(
-            "failed to request exit from VM memory handler thread: {}",
-            e
-        );
-    }
-    if let Err(e) = vm_memory_handler_thread_join_handle.join() {
-        error!("failed to exit VM Memory handler thread: {:?}", e);
-    }
-
-    // Shut down the IRQ handler thread.
-    if let Err(e) = irq_handler_control.send(&IrqHandlerRequest::Exit) {
-        error!("failed to request exit from IRQ handler thread: {}", e);
-    }
-
     // Ensure any child threads have ended by sending the Exit vm event (possibly again) to ensure
     // their run loops are aborted.
     let _ = vm_evt_wrtube.send::<VmEventType>(&VmEventType::Exit);
@@ -1644,9 +1627,6 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
     cros_async::unblock_disarm();
     info!("blocking async pool has shut down.");
 
-    let _ = irq_join_handle.join();
-    info!("IrqWaitWorker has shut down.");
-
     #[cfg(feature = "stats")]
     if let Some(stats) = stats {
         println!("Statistics Collected:\n{}", stats.lock());
@@ -1662,8 +1642,31 @@ fn run_control<V: VmArch + 'static, Vcpu: VcpuArch + 'static>(
     // Explicitly drop the VM structure here to allow the devices to clean up before the
     // control tubes are closed when this function exits.
     mem::drop(guest_os);
+    info!("guest_os dropped");
+
+    // Shut down the VM memory handler thread. This must happen after the potential device worker
+    // threads(including the vhost device request handler threads) exit, because device worker
+    // threads can issue VM memory requests. Those device worker threads are supposed to stop after
+    // the RunnableLinuxVm is dropped.
+    if let Err(e) = vm_memory_handler_control.send(&VmMemoryHandlerRequest::Exit) {
+        error!(
+            "failed to request exit from VM memory handler thread: {}",
+            e
+        );
+    }
+    if let Err(e) = vm_memory_handler_thread_join_handle.join() {
+        error!("failed to exit VM Memory handler thread: {:?}", e);
+    }
+
+    // Shut down the IRQ handler thread after the devices are dropped.
+    if let Err(e) = irq_handler_control.send(&IrqHandlerRequest::Exit) {
+        error!("failed to request exit from IRQ handler thread: {}", e);
+    }
+
+    let _ = irq_join_handle.join();
+    info!("IrqWaitWorker has shut down.");
 
-    info!("guest_os dropped, run_control is done.");
+    info!("run_control is done.");
 
     res
 }
diff --git a/src/sys/windows/main.rs b/src/sys/windows/main.rs
index 7775b5eb3..2a297c5e6 100644
--- a/src/sys/windows/main.rs
+++ b/src/sys/windows/main.rs
@@ -27,8 +27,6 @@ use metrics::MetricEventType;
 use net_util::slirp::sys::windows::SlirpStartupConfig;
 use tube_transporter::TubeToken;
 use tube_transporter::TubeTransporterReader;
-use win_util::DllNotificationData;
-use win_util::DllWatcher;
 
 use crate::crosvm::cmdline::RunCommand;
 use crate::crosvm::sys::cmdline::Commands;
@@ -107,24 +105,6 @@ pub fn sandbox_lower_token() -> Result<()> {
     Ok(())
 }
 
-fn report_dll_loaded(dll_name: String) {
-    metrics::log_event(MetricEventType::DllLoaded(dll_name));
-}
-
-pub fn get_library_watcher(
-) -> std::io::Result<DllWatcher<impl FnMut(DllNotificationData), impl FnMut(DllNotificationData)>> {
-    let mut dlls: HashSet<OsString> = HashSet::new();
-    DllWatcher::new(
-        move |data| {
-            info!("DLL loaded: {:?}", data.base_dll_name);
-            if !dlls.insert(data.base_dll_name.clone()) && metrics::is_initialized() {
-                report_dll_loaded(data.base_dll_name.to_string_lossy().into_owned());
-            }
-        },
-        |data| info!("DLL unloaded: {:?}", data.base_dll_name),
-    )
-}
-
 pub(crate) fn start_device(command: DeviceSubcommand) -> Result<()> {
     Err(anyhow!("unknown device name: {:?}", command))
 }
diff --git a/swap/Android.bp b/swap/Android.bp
index a1f8e8260..f94f3bf87 100644
--- a/swap/Android.bp
+++ b/swap/Android.bp
@@ -30,7 +30,6 @@ rust_library {
         "liblibc",
         "libmetrics",
         "libnum_cpus",
-        "libonce_cell",
         "libserde",
         "libserde_json",
         "libsync_rust",
diff --git a/swap/Cargo.toml b/swap/Cargo.toml
index fb58e797d..3090ec319 100644
--- a/swap/Cargo.toml
+++ b/swap/Cargo.toml
@@ -17,23 +17,22 @@ trace_marker = ["cros_tracing/trace_marker"]
 enable = ["userfaultfd", "userfaultfd-sys"]
 
 [dependencies]
-anyhow = "1"
-base = { path = "../base" }
-cfg-if = "1"
-cros_tracing = { path = "../cros_tracing" }
+anyhow = { workspace = true }
+base = { workspace = true }
+cfg-if = { workspace = true }
+cros_tracing = { workspace = true }
 jail = { path = "../jail" }
-metrics = { path = "../metrics" }
+metrics = { workspace = true }
 num_cpus = "1"
-once_cell = "1.7"
-remain = "0.2"
-serde = { version = "1", features = ["derive"] }
-serde_json = "1"
-sync = { path = "../common/sync" }               # provided by ebuild
-thiserror = "1"
-vm_memory = { path = "../vm_memory" }
+remain = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+serde_json = { workspace = true }
+sync = { workspace = true }
+thiserror = { workspace = true }
+vm_memory = { workspace = true }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
-libc = "0.2"
+libc = { workspace = true }
 
 [target.'cfg(target_os="linux")'.dependencies]
 userfaultfd = { version = "0.8.1", optional = true }
diff --git a/swap/src/controller.rs b/swap/src/controller.rs
index cfaa6d74f..96eed3c05 100644
--- a/swap/src/controller.rs
+++ b/swap/src/controller.rs
@@ -13,6 +13,7 @@ use std::io::stdout;
 use std::ops::Range;
 use std::os::unix::fs::OpenOptionsExt;
 use std::path::Path;
+use std::sync::LazyLock;
 use std::thread::Scope;
 use std::thread::ScopedJoinHandle;
 use std::time::Duration;
@@ -42,7 +43,6 @@ use jail::fork::Child;
 use jail::JailConfig;
 use jail::SandboxConfig;
 use jail::MAX_OPEN_FILES_DEFAULT;
-use once_cell::sync::Lazy;
 use serde::Deserialize;
 use serde::Serialize;
 use sync::Mutex;
@@ -203,7 +203,7 @@ impl SwapController {
         keep_rds.extend(uffd_factory.as_raw_descriptors());
 
         // Load and cache transparent hugepage size from sysfs before jumping into sandbox.
-        Lazy::force(&THP_SIZE);
+        LazyLock::force(&THP_SIZE);
 
         let mut jail = if let Some(jail_config) = jail_config {
             let config = SandboxConfig::new(jail_config, "swap_monitor");
diff --git a/swap/src/pagesize.rs b/swap/src/pagesize.rs
index a6d38627f..e3a264d25 100644
--- a/swap/src/pagesize.rs
+++ b/swap/src/pagesize.rs
@@ -11,15 +11,15 @@
 
 use std::fs;
 use std::str;
+use std::sync::LazyLock;
 
 use anyhow::Context;
 use base::info;
 use base::pagesize;
-use once_cell::sync::Lazy;
 
 const TRANSPARENT_HUGEPAGE_SIZE_PATH: &str = "/sys/kernel/mm/transparent_hugepage/hpage_pmd_size";
 
-static PAGESIZE_SHIFT: Lazy<u8> = Lazy::new(|| {
+static PAGESIZE_SHIFT: LazyLock<u8> = LazyLock::new(|| {
     let pagesize_shift = pagesize().trailing_zeros();
     // pagesize() should be power of 2 in almost all cases. vmm-swap feature does not support
     // systems in which page size is not power of 2.
@@ -33,7 +33,7 @@ static PAGESIZE_SHIFT: Lazy<u8> = Lazy::new(|| {
 /// The transparent hugepage size loaded from /sys/kernel/mm/transparent_hugepage/hpage_pmd_size.
 ///
 /// If it fails to load the hugepage size, it fallbacks to use 2MB.
-pub static THP_SIZE: Lazy<usize> = Lazy::new(|| {
+pub static THP_SIZE: LazyLock<usize> = LazyLock::new(|| {
     match load_transparent_hugepage_size() {
         Ok(transparent_hugepage_size) => transparent_hugepage_size,
         Err(e) => {
diff --git a/swap/src/processes.rs b/swap/src/processes.rs
index b0fef61fc..8cd9a6469 100644
--- a/swap/src/processes.rs
+++ b/swap/src/processes.rs
@@ -102,7 +102,7 @@ fn load_descendants(current_pid: Pid, monitor_pid: Pid) -> Result<Vec<Pid>> {
         return Ok(Vec::new());
     }
     let pids: std::result::Result<Vec<i32>, ParseIntError> = children
-        .split(" ")
+        .split(' ')
         .map(i32::from_str)
         // except this monitor process
         .filter(|pid| match pid {
diff --git a/system_api/src/protos/spaced.rs b/system_api/src/protos/spaced.rs
index b19aeb714..0bb31ee94 100644
--- a/system_api/src/protos/spaced.rs
+++ b/system_api/src/protos/spaced.rs
@@ -1,4 +1,4 @@
-// This file is generated by rust-protobuf 3.6.0. Do not edit
+// This file is generated by rust-protobuf 3.7.2. Do not edit
 // .proto file is parsed by protoc 3.21.12
 // @generated
 
@@ -23,7 +23,7 @@
 
 /// Generated files are compatible only with the same version
 /// of protobuf runtime.
-const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_6_0;
+const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;
 
 // @@protoc_insertion_point(message:spaced.SetProjectIdReply)
 #[derive(PartialEq,Clone,Default,Debug)]
diff --git a/system_api/src/protos/vtpm_interface.rs b/system_api/src/protos/vtpm_interface.rs
index 3c9c7963b..c58e785bb 100644
--- a/system_api/src/protos/vtpm_interface.rs
+++ b/system_api/src/protos/vtpm_interface.rs
@@ -1,4 +1,4 @@
-// This file is generated by rust-protobuf 3.6.0. Do not edit
+// This file is generated by rust-protobuf 3.7.2. Do not edit
 // .proto file is parsed by protoc 3.21.12
 // @generated
 
@@ -23,7 +23,7 @@
 
 /// Generated files are compatible only with the same version
 /// of protobuf runtime.
-const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_6_0;
+const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;
 
 // @@protoc_insertion_point(message:vtpm.SendCommandRequest)
 #[derive(PartialEq,Clone,Default,Debug)]
diff --git a/tests/plugins.rs b/tests/plugins.rs
index 3a72d7293..5e448672a 100644
--- a/tests/plugins.rs
+++ b/tests/plugins.rs
@@ -14,18 +14,18 @@ use std::path::Path;
 use std::path::PathBuf;
 use std::process::Command;
 use std::process::Stdio;
+use std::sync::LazyLock;
 use std::thread::sleep;
 use std::time::Duration;
 
 use base::ioctl;
 use base::AsRawDescriptor;
 use net_util::TapTCommon;
-use once_cell::sync::Lazy;
 use rand::random;
 use tempfile::tempfile;
 
-static TAP_AVAILABLE: Lazy<bool> =
-    Lazy::new(|| net_util::sys::linux::Tap::new(true, false).is_ok());
+static TAP_AVAILABLE: LazyLock<bool> =
+    LazyLock::new(|| net_util::sys::linux::Tap::new(true, false).is_ok());
 
 struct RemovePath(PathBuf);
 impl Drop for RemovePath {
diff --git a/third_party/vmm_vhost/Cargo.toml b/third_party/vmm_vhost/Cargo.toml
index 50d69b22a..048436098 100644
--- a/third_party/vmm_vhost/Cargo.toml
+++ b/third_party/vmm_vhost/Cargo.toml
@@ -14,20 +14,20 @@ edition = "2021"
 default = []
 
 [dependencies]
-anyhow = "1"
-base = { path = "../../base" }
+anyhow = { workspace = true }
+base = { workspace = true }
 bitflags = "2.3"
-cfg-if = "1.0.0"
-enumn = "0.1.0"
-libc = ">=0.2.39"
-remain = "0.2"
-thiserror = { version = "1.0.20" }
+cfg-if = { workspace = true }
+enumn = { workspace = true }
+libc = { workspace = true }
+remain = { workspace = true }
+thiserror = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [target.'cfg(windows)'.dependencies]
-serde = { version = "1", features = [ "derive" ] }
-serde_json = "1"
-tube_transporter = { path = "../../tube_transporter" }
+serde = { workspace = true, features = [ "derive" ] }
+serde_json = { workspace = true }
+tube_transporter = { workspace = true }
 
 [dev-dependencies]
 tempfile = "3"
diff --git a/third_party/vmm_vhost/src/backend_client.rs b/third_party/vmm_vhost/src/backend_client.rs
index a44d01027..6f239cce0 100644
--- a/third_party/vmm_vhost/src/backend_client.rs
+++ b/third_party/vmm_vhost/src/backend_client.rs
@@ -10,7 +10,6 @@ use base::CloseNotifier;
 use base::Event;
 use base::RawDescriptor;
 use base::ReadNotifier;
-use base::INVALID_DESCRIPTOR;
 use zerocopy::FromBytes;
 use zerocopy::Immutable;
 use zerocopy::IntoBytes;
@@ -28,31 +27,19 @@ use crate::Result;
 /// Client for a vhost-user device. The API is a thin abstraction over the vhost-user protocol.
 pub struct BackendClient {
     connection: Connection<FrontendReq>,
-    // Cached virtio features from the backend.
-    virtio_features: u64,
-    // Cached acked virtio features from the driver.
-    acked_virtio_features: u64,
-    // Cached vhost-user protocol features.
-    acked_protocol_features: u64,
 }
 
 impl BackendClient {
     /// Create a new instance.
     pub fn new(connection: Connection<FrontendReq>) -> Self {
-        BackendClient {
-            connection,
-            virtio_features: 0,
-            acked_virtio_features: 0,
-            acked_protocol_features: 0,
-        }
+        BackendClient { connection }
     }
 
     /// Get a bitmask of supported virtio/vhost features.
     pub fn get_features(&mut self) -> Result<u64> {
         let hdr = self.send_request_header(FrontendReq::GET_FEATURES, None)?;
         let val = self.recv_reply::<VhostUserU64>(&hdr)?;
-        self.virtio_features = val.value;
-        Ok(self.virtio_features)
+        Ok(val.value)
     }
 
     /// Inform the vhost subsystem which features to enable.
@@ -60,7 +47,6 @@ impl BackendClient {
     pub fn set_features(&mut self, features: u64) -> Result<()> {
         let val = VhostUserU64::new(features);
         let hdr = self.send_request_with_body(FrontendReq::SET_FEATURES, &val, None)?;
-        self.acked_virtio_features = features & self.virtio_features;
         self.wait_for_ack(&hdr)
     }
 
@@ -81,20 +67,8 @@ impl BackendClient {
     /// Set the memory map regions on the backend so it can translate the vring
     /// addresses. In the ancillary data there is an array of file descriptors
     pub fn set_mem_table(&self, regions: &[VhostUserMemoryRegionInfo]) -> Result<()> {
-        if regions.is_empty() || regions.len() > MAX_ATTACHED_FD_ENTRIES {
-            return Err(VhostUserError::InvalidParam(
-                "set_mem_table: regions empty or exceed max allowed regions per req.",
-            ));
-        }
-
         let mut ctx = VhostUserMemoryContext::new();
         for region in regions.iter() {
-            if region.memory_size == 0 || region.mmap_handle == INVALID_DESCRIPTOR {
-                return Err(VhostUserError::InvalidParam(
-                    "set_mem_table: invalid memory region",
-                ));
-            }
-
             let reg = VhostUserMemoryRegion {
                 guest_phys_addr: region.guest_phys_addr,
                 memory_size: region.memory_size,
@@ -117,13 +91,6 @@ impl BackendClient {
     /// Set base address for page modification logging.
     pub fn set_log_base(&self, base: u64, fd: Option<RawDescriptor>) -> Result<()> {
         let val = VhostUserU64::new(base);
-
-        let should_have_fd =
-            self.acked_protocol_features & VhostUserProtocolFeatures::LOG_SHMFD.bits() != 0;
-        if should_have_fd != fd.is_some() {
-            return Err(VhostUserError::InvalidParam("set_log_base: FD is missing"));
-        }
-
         let _ = self.send_request_with_body(
             FrontendReq::SET_LOG_BASE,
             &val,
@@ -149,12 +116,6 @@ impl BackendClient {
 
     /// Set the addresses for a given vring.
     pub fn set_vring_addr(&self, queue_index: usize, config_data: &VringConfigData) -> Result<()> {
-        if config_data.flags & !(VhostUserVringAddrFlags::all().bits()) != 0 {
-            return Err(VhostUserError::InvalidParam(
-                "set_vring_addr: unsupported vring flags",
-            ));
-        }
-
         let val = VhostUserVringAddr::from_config_data(queue_index as u32, config_data);
         let hdr = self.send_request_with_body(FrontendReq::SET_VRING_ADDR, &val, None)?;
         self.wait_for_ack(&hdr)
@@ -229,9 +190,6 @@ impl BackendClient {
         migration_phase: VhostUserMigrationPhase,
         fd: &impl AsRawDescriptor,
     ) -> Result<Option<File>> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::DEVICE_STATE.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
         // Send request.
         let req = DeviceStateTransferParameters {
             transfer_direction: match transfer_direction {
@@ -264,9 +222,6 @@ impl BackendClient {
     /// After transferring the back-ends internal state during migration, check whether the
     /// back-end was able to successfully fully process the state.
     pub fn check_device_state(&self) -> Result<()> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::DEVICE_STATE.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
         let hdr = self.send_request_header(FrontendReq::CHECK_DEVICE_STATE, None)?;
         let reply = self.recv_reply::<VhostUserU64>(&hdr)?;
         if reply.value != 0 {
@@ -277,9 +232,6 @@ impl BackendClient {
 
     /// Get the protocol feature bitmask from the underlying vhost implementation.
     pub fn get_protocol_features(&self) -> Result<VhostUserProtocolFeatures> {
-        if self.virtio_features & 1 << VHOST_USER_F_PROTOCOL_FEATURES == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
         let hdr = self.send_request_header(FrontendReq::GET_PROTOCOL_FEATURES, None)?;
         let val = self.recv_reply::<VhostUserU64>(&hdr)?;
         Ok(VhostUserProtocolFeatures::from_bits_truncate(val.value))
@@ -287,33 +239,15 @@ impl BackendClient {
 
     /// Enable protocol features in the underlying vhost implementation.
     pub fn set_protocol_features(&mut self, features: VhostUserProtocolFeatures) -> Result<()> {
-        if self.virtio_features & 1 << VHOST_USER_F_PROTOCOL_FEATURES == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
-        if features.contains(VhostUserProtocolFeatures::SHARED_MEMORY_REGIONS)
-            && !features.contains(VhostUserProtocolFeatures::BACKEND_REQ)
-        {
-            return Err(VhostUserError::FeatureMismatch);
-        }
         let val = VhostUserU64::new(features.bits());
         let hdr = self.send_request_with_body(FrontendReq::SET_PROTOCOL_FEATURES, &val, None)?;
-        // Don't wait for ACK here because the protocol feature negotiation process hasn't been
-        // completed yet.
-        self.acked_protocol_features = features.bits();
         self.wait_for_ack(&hdr)
     }
 
     /// Query how many queues the backend supports.
     pub fn get_queue_num(&self) -> Result<u64> {
-        if !self.is_feature_mq_available() {
-            return Err(VhostUserError::InvalidOperation);
-        }
-
         let hdr = self.send_request_header(FrontendReq::GET_QUEUE_NUM, None)?;
         let val = self.recv_reply::<VhostUserU64>(&hdr)?;
-        if val.value > VHOST_USER_MAX_VRINGS {
-            return Err(VhostUserError::InvalidMessage);
-        }
         Ok(val.value)
     }
 
@@ -323,11 +257,6 @@ impl BackendClient {
     /// VHOST_USER_SET_VRING_ENABLE with parameter 1, or after it has been
     /// disabled by VHOST_USER_SET_VRING_ENABLE with parameter 0.
     pub fn set_vring_enable(&self, queue_index: usize, enable: bool) -> Result<()> {
-        // set_vring_enable() is supported only when PROTOCOL_FEATURES has been enabled.
-        if self.acked_virtio_features & 1 << VHOST_USER_F_PROTOCOL_FEATURES == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
-
         let val = VhostUserVringState::new(queue_index as u32, enable.into());
         let hdr = self.send_request_with_body(FrontendReq::SET_VRING_ENABLE, &val, None)?;
         self.wait_for_ack(&hdr)
@@ -342,16 +271,6 @@ impl BackendClient {
         buf: &[u8],
     ) -> Result<(VhostUserConfig, VhostUserConfigPayload)> {
         let body = VhostUserConfig::new(offset, size, flags);
-        if !body.is_valid() {
-            return Err(VhostUserError::InvalidParam(
-                "get_config: VhostUserConfig is invalid",
-            ));
-        }
-
-        // depends on VhostUserProtocolFeatures::CONFIG
-        if self.acked_protocol_features & VhostUserProtocolFeatures::CONFIG.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
 
         // vhost-user spec states that:
         // "Request payload: virtio device config space"
@@ -383,16 +302,6 @@ impl BackendClient {
                 .map_err(VhostUserError::InvalidCastToInt)?,
             flags,
         );
-        if !body.is_valid() {
-            return Err(VhostUserError::InvalidParam(
-                "set_config: VhostUserConfig is invalid",
-            ));
-        }
-
-        // depends on VhostUserProtocolFeatures::CONFIG
-        if self.acked_protocol_features & VhostUserProtocolFeatures::CONFIG.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
 
         let hdr = self.send_request_with_payload(FrontendReq::SET_CONFIG, &body, buf, None)?;
         self.wait_for_ack(&hdr)
@@ -400,9 +309,6 @@ impl BackendClient {
 
     /// Setup backend communication channel.
     pub fn set_backend_req_fd(&self, fd: &dyn AsRawDescriptor) -> Result<()> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::BACKEND_REQ.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
         let fds = [fd.as_raw_descriptor()];
         let hdr = self.send_request_header(FrontendReq::SET_BACKEND_REQ_FD, Some(&fds))?;
         self.wait_for_ack(&hdr)
@@ -413,10 +319,6 @@ impl BackendClient {
         &self,
         inflight: &VhostUserInflight,
     ) -> Result<(VhostUserInflight, File)> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::INFLIGHT_SHMFD.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
-
         let hdr = self.send_request_with_body(FrontendReq::GET_INFLIGHT_FD, inflight, None)?;
         let (inflight, files) = self.recv_reply_with_files::<VhostUserInflight>(&hdr)?;
 
@@ -428,20 +330,6 @@ impl BackendClient {
 
     /// Set shared buffer for inflight I/O tracking.
     pub fn set_inflight_fd(&self, inflight: &VhostUserInflight, fd: RawDescriptor) -> Result<()> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::INFLIGHT_SHMFD.bits() == 0 {
-            return Err(VhostUserError::InvalidOperation);
-        }
-
-        if inflight.mmap_size == 0
-            || inflight.num_queues == 0
-            || inflight.queue_size == 0
-            || fd == INVALID_DESCRIPTOR
-        {
-            return Err(VhostUserError::InvalidParam(
-                "set_inflight_fd: invalid fd or params",
-            ));
-        }
-
         let hdr =
             self.send_request_with_body(FrontendReq::SET_INFLIGHT_FD, inflight, Some(&[fd]))?;
         self.wait_for_ack(&hdr)
@@ -449,11 +337,6 @@ impl BackendClient {
 
     /// Query the maximum amount of memory slots supported by the backend.
     pub fn get_max_mem_slots(&self) -> Result<u64> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::CONFIGURE_MEM_SLOTS.bits() == 0
-        {
-            return Err(VhostUserError::InvalidOperation);
-        }
-
         let hdr = self.send_request_header(FrontendReq::GET_MAX_MEM_SLOTS, None)?;
         let val = self.recv_reply::<VhostUserU64>(&hdr)?;
 
@@ -462,17 +345,6 @@ impl BackendClient {
 
     /// Add a new guest memory mapping for vhost to use.
     pub fn add_mem_region(&self, region: &VhostUserMemoryRegionInfo) -> Result<()> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::CONFIGURE_MEM_SLOTS.bits() == 0
-        {
-            return Err(VhostUserError::InvalidOperation);
-        }
-
-        if region.memory_size == 0 || region.mmap_handle == INVALID_DESCRIPTOR {
-            return Err(VhostUserError::InvalidParam(
-                "add_mem_region: region empty or mmap handle invalid",
-            ));
-        }
-
         let body = VhostUserSingleMemoryRegion::new(
             region.guest_phys_addr,
             region.memory_size,
@@ -486,16 +358,6 @@ impl BackendClient {
 
     /// Remove a guest memory mapping from vhost.
     pub fn remove_mem_region(&self, region: &VhostUserMemoryRegionInfo) -> Result<()> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::CONFIGURE_MEM_SLOTS.bits() == 0
-        {
-            return Err(VhostUserError::InvalidOperation);
-        }
-        if region.memory_size == 0 {
-            return Err(VhostUserError::InvalidParam(
-                "remove_mem_region: cannot remove zero sized region",
-            ));
-        }
-
         let body = VhostUserSingleMemoryRegion::new(
             region.guest_phys_addr,
             region.memory_size,
@@ -557,13 +419,6 @@ impl BackendClient {
         payload: &[u8],
         fds: Option<&[RawDescriptor]>,
     ) -> VhostUserResult<VhostUserMsgHeader<FrontendReq>> {
-        if let Some(fd_arr) = fds {
-            if fd_arr.len() > MAX_ATTACHED_FD_ENTRIES {
-                return Err(VhostUserError::InvalidParam(
-                    "send_request_with_payload: too many FDs supplied with message",
-                ));
-            }
-        }
         let len = mem::size_of::<T>()
             .checked_add(payload.len())
             .ok_or(VhostUserError::OversizedMsg)?;
@@ -601,7 +456,7 @@ impl BackendClient {
             ));
         }
         let (reply, body, rfds) = self.connection.recv_message::<T>()?;
-        if !reply.is_reply_for(hdr) || !rfds.is_empty() || !body.is_valid() {
+        if !reply.is_valid() || !reply.is_reply_for(hdr) || !rfds.is_empty() || !body.is_valid() {
             return Err(VhostUserError::InvalidMessage);
         }
         Ok(body)
@@ -618,7 +473,7 @@ impl BackendClient {
         }
 
         let (reply, body, files) = self.connection.recv_message::<T>()?;
-        if !reply.is_reply_for(hdr) || !body.is_valid() {
+        if !reply.is_valid() || !reply.is_reply_for(hdr) || !body.is_valid() {
             return Err(VhostUserError::InvalidMessage);
         }
         Ok((body, files))
@@ -636,8 +491,14 @@ impl BackendClient {
             ));
         }
 
-        let (reply, body, buf, files) = self.connection.recv_message_with_payload::<T>()?;
-        if !reply.is_reply_for(hdr) || !files.is_empty() || !body.is_valid() {
+        let (reply, body, buf, files, more_files) =
+            self.connection.recv_message_with_payload::<T>()?;
+        if !reply.is_valid()
+            || !reply.is_reply_for(hdr)
+            || !files.is_empty()
+            || !more_files.is_empty()
+            || !body.is_valid()
+        {
             return Err(VhostUserError::InvalidMessage);
         }
 
@@ -645,14 +506,12 @@ impl BackendClient {
     }
 
     fn wait_for_ack(&self, hdr: &VhostUserMsgHeader<FrontendReq>) -> VhostUserResult<()> {
-        if self.acked_protocol_features & VhostUserProtocolFeatures::REPLY_ACK.bits() == 0
-            || !hdr.is_need_reply()
-        {
+        if !hdr.is_need_reply() {
             return Ok(());
         }
 
         let (reply, body, rfds) = self.connection.recv_message::<VhostUserU64>()?;
-        if !reply.is_reply_for(hdr) || !rfds.is_empty() || !body.is_valid() {
+        if !reply.is_valid() || !reply.is_reply_for(hdr) || !rfds.is_empty() || !body.is_valid() {
             return Err(VhostUserError::InvalidMessage);
         }
         if body.value != 0 {
@@ -661,10 +520,6 @@ impl BackendClient {
         Ok(())
     }
 
-    fn is_feature_mq_available(&self) -> bool {
-        self.acked_protocol_features & VhostUserProtocolFeatures::MQ.bits() != 0
-    }
-
     #[inline]
     fn new_request_header(
         &self,
@@ -714,7 +569,6 @@ impl VhostUserMemoryContext {
 #[cfg(test)]
 mod tests {
     use base::INVALID_DESCRIPTOR;
-    use tempfile::tempfile;
 
     use super::*;
 
@@ -792,10 +646,23 @@ mod tests {
         assert_eq!(hdr.get_code(), Ok(FrontendReq::SET_OWNER));
         assert!(rfds.is_empty());
 
-        assert!(backend_client.get_protocol_features().is_err());
-        assert!(backend_client
+        let pfeatures = VhostUserProtocolFeatures::all();
+        let hdr = VhostUserMsgHeader::new(FrontendReq::GET_PROTOCOL_FEATURES, 0x4, 8);
+        // Unknown feature bits should be ignored.
+        let msg = VhostUserU64::new(pfeatures.bits() | INVALID_PROTOCOL_FEATURE);
+        peer.send_message(&hdr, &msg, None).unwrap();
+        let features = backend_client.get_protocol_features().unwrap();
+        assert_eq!(features, pfeatures);
+        let (_hdr, rfds) = peer.recv_header().unwrap();
+        assert!(rfds.is_empty());
+
+        backend_client
             .set_protocol_features(VhostUserProtocolFeatures::all())
-            .is_err());
+            .unwrap();
+        let (_hdr, msg, rfds) = peer.recv_message::<VhostUserU64>().unwrap();
+        assert!(rfds.is_empty());
+        let val = msg.value;
+        assert_eq!(val, pfeatures.bits());
 
         let vfeatures = 0x15 | 1 << VHOST_USER_F_PROTOCOL_FEATURES;
         let hdr = VhostUserMsgHeader::new(FrontendReq::GET_FEATURES, 0x4, 8);
@@ -834,60 +701,9 @@ mod tests {
         assert!(backend_client.get_protocol_features().is_err());
     }
 
-    #[test]
-    fn test_backend_client_set_config_negative() {
-        let (mut backend_client, _peer) = create_pair();
-        let buf = vec![0x0; BUFFER_SIZE];
-
-        backend_client
-            .set_config(0x100, VhostUserConfigFlags::WRITABLE, &buf[0..4])
-            .unwrap_err();
-
-        backend_client.virtio_features = 0xffff_ffff;
-        backend_client.acked_virtio_features = 0xffff_ffff;
-        backend_client.acked_protocol_features = 0xffff_ffff;
-
-        backend_client
-            .set_config(0, VhostUserConfigFlags::WRITABLE, &buf[0..4])
-            .unwrap();
-        backend_client
-            .set_config(
-                VHOST_USER_CONFIG_SIZE,
-                VhostUserConfigFlags::WRITABLE,
-                &buf[0..4],
-            )
-            .unwrap_err();
-        backend_client
-            .set_config(0x1000, VhostUserConfigFlags::WRITABLE, &buf[0..4])
-            .unwrap_err();
-        backend_client
-            .set_config(
-                0x100,
-                VhostUserConfigFlags::from_bits_retain(0xffff_ffff),
-                &buf[0..4],
-            )
-            .unwrap_err();
-        backend_client
-            .set_config(VHOST_USER_CONFIG_SIZE, VhostUserConfigFlags::WRITABLE, &buf)
-            .unwrap_err();
-        backend_client
-            .set_config(VHOST_USER_CONFIG_SIZE, VhostUserConfigFlags::WRITABLE, &[])
-            .unwrap_err();
-    }
-
-    fn create_pair2() -> (BackendClient, Connection<FrontendReq>) {
-        let (mut backend_client, peer) = create_pair();
-
-        backend_client.virtio_features = 0xffff_ffff;
-        backend_client.acked_virtio_features = 0xffff_ffff;
-        backend_client.acked_protocol_features = 0xffff_ffff;
-
-        (backend_client, peer)
-    }
-
     #[test]
     fn test_backend_client_get_config_negative0() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let mut hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -909,7 +725,7 @@ mod tests {
 
     #[test]
     fn test_backend_client_get_config_negative1() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let mut hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -930,7 +746,7 @@ mod tests {
 
     #[test]
     fn test_backend_client_get_config_negative2() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -944,7 +760,7 @@ mod tests {
 
     #[test]
     fn test_backend_client_get_config_negative3() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -965,7 +781,7 @@ mod tests {
 
     #[test]
     fn test_backend_client_get_config_negative4() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -986,7 +802,7 @@ mod tests {
 
     #[test]
     fn test_backend_client_get_config_negative5() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -1007,7 +823,7 @@ mod tests {
 
     #[test]
     fn test_backend_client_get_config_negative6() {
-        let (backend_client, peer) = create_pair2();
+        let (backend_client, peer) = create_pair();
         let buf = vec![0x0; BUFFER_SIZE];
 
         let hdr = VhostUserMsgHeader::new(FrontendReq::GET_CONFIG, 0x4, 16);
@@ -1025,28 +841,4 @@ mod tests {
             .get_config(0x100, 4, VhostUserConfigFlags::WRITABLE, &buf[0..4])
             .is_err());
     }
-
-    #[test]
-    fn test_maset_set_mem_table_failure() {
-        let (backend_client, _peer) = create_pair2();
-
-        // set_mem_table() with 0 regions is invalid
-        backend_client.set_mem_table(&[]).unwrap_err();
-
-        // set_mem_table() with more than MAX_ATTACHED_FD_ENTRIES is invalid
-        let files: Vec<File> = (0..MAX_ATTACHED_FD_ENTRIES + 1)
-            .map(|_| tempfile().unwrap())
-            .collect();
-        let tables: Vec<VhostUserMemoryRegionInfo> = files
-            .iter()
-            .map(|f| VhostUserMemoryRegionInfo {
-                guest_phys_addr: 0,
-                memory_size: 0x100000,
-                userspace_addr: 0x800000,
-                mmap_offset: 0,
-                mmap_handle: f.as_raw_descriptor(),
-            })
-            .collect();
-        backend_client.set_mem_table(&tables).unwrap_err();
-    }
 }
diff --git a/third_party/vmm_vhost/src/backend_server.rs b/third_party/vmm_vhost/src/backend_server.rs
index b03debd1d..762522f7b 100644
--- a/third_party/vmm_vhost/src/backend_server.rs
+++ b/third_party/vmm_vhost/src/backend_server.rs
@@ -318,6 +318,10 @@ impl<S: Backend> BackendServer<S> {
             }
         };
 
+        if !hdr.is_valid() {
+            return Err(Error::InvalidMessage);
+        }
+
         self.check_attached_files(&hdr, &files)?;
 
         Ok((hdr, files))
@@ -350,8 +354,11 @@ impl<S: Backend> BackendServer<S> {
         hdr: VhostUserMsgHeader<FrontendReq>,
         files: Vec<File>,
     ) -> Result<()> {
-        let buf = self.connection.recv_body_bytes(&hdr)?;
+        let (buf, extra_files) = self.connection.recv_body_bytes(&hdr)?;
         let size = buf.len();
+        if !extra_files.is_empty() {
+            return Err(Error::InvalidMessage);
+        }
 
         // TODO: The error handling here is inconsistent. Sometimes we report the error to the
         // client and keep going, sometimes we report the error and then close the connection,
diff --git a/third_party/vmm_vhost/src/connection.rs b/third_party/vmm_vhost/src/connection.rs
index 354241fce..95adf283b 100644
--- a/third_party/vmm_vhost/src/connection.rs
+++ b/third_party/vmm_vhost/src/connection.rs
@@ -143,39 +143,29 @@ impl<R: Req> Connection<R> {
 
     /// Receive message header
     ///
-    /// Errors if the header is invalid.
-    ///
     /// Note, only the first MAX_ATTACHED_FD_ENTRIES file descriptors will be accepted and all
     /// other file descriptor will be discard silently.
     pub fn recv_header(&self) -> Result<(VhostUserMsgHeader<R>, Vec<File>)> {
         let mut hdr_raw = [0u32; 3];
         let files = self.recv_into_bufs_all(&mut [hdr_raw.as_mut_bytes()])?;
         let hdr = VhostUserMsgHeader::from_raw(hdr_raw);
-        if !hdr.is_valid() {
-            return Err(Error::InvalidMessage);
-        }
         Ok((hdr, files))
     }
 
     /// Receive the body following the header `hdr`.
-    pub fn recv_body_bytes(&self, hdr: &VhostUserMsgHeader<R>) -> Result<Vec<u8>> {
+    pub fn recv_body_bytes(&self, hdr: &VhostUserMsgHeader<R>) -> Result<(Vec<u8>, Vec<File>)> {
         // NOTE: `recv_into_bufs_all` is a noop when the buffer is empty, so `hdr.get_size() == 0`
         // works as expected.
         let mut body = vec![0; hdr.get_size().try_into().unwrap()];
         let files = self.recv_into_bufs_all(&mut [&mut body[..]])?;
-        if !files.is_empty() {
-            return Err(Error::InvalidMessage);
-        }
-        Ok(body)
+        Ok((body, files))
     }
 
     /// Receive a message header and body.
     ///
-    /// Errors if the header or body is invalid.
-    ///
     /// Note, only the first MAX_ATTACHED_FD_ENTRIES file descriptors will be
     /// accepted and all other file descriptor will be discard silently.
-    pub fn recv_message<T: IntoBytes + FromBytes + VhostUserMsgValidator>(
+    pub fn recv_message<T: IntoBytes + FromBytes>(
         &self,
     ) -> Result<(VhostUserMsgHeader<R>, T, Vec<File>)> {
         let mut hdr_raw = [0u32; 3];
@@ -184,9 +174,6 @@ impl<R: Req> Connection<R> {
         let files = self.recv_into_bufs_all(&mut slices)?;
 
         let hdr = VhostUserMsgHeader::from_raw(hdr_raw);
-        if !hdr.is_valid() || !body.is_valid() {
-            return Err(Error::InvalidMessage);
-        }
 
         Ok((hdr, body, files))
     }
@@ -194,13 +181,11 @@ impl<R: Req> Connection<R> {
     /// Receive a message header and body, where the body includes a variable length payload at the
     /// end.
     ///
-    /// Errors if the header or body is invalid.
-    ///
     /// Note, only the first MAX_ATTACHED_FD_ENTRIES file descriptors will be accepted and all
     /// other file descriptor will be discard silently.
-    pub fn recv_message_with_payload<T: IntoBytes + FromBytes + VhostUserMsgValidator>(
+    pub fn recv_message_with_payload<T: IntoBytes + FromBytes>(
         &self,
-    ) -> Result<(VhostUserMsgHeader<R>, T, Vec<u8>, Vec<File>)> {
+    ) -> Result<(VhostUserMsgHeader<R>, T, Vec<u8>, Vec<File>, Vec<File>)> {
         let (hdr, files) = self.recv_header()?;
 
         let mut body = T::new_zeroed();
@@ -208,11 +193,8 @@ impl<R: Req> Connection<R> {
         let mut buf: Vec<u8> = vec![0; payload_size];
         let mut slices = [body.as_mut_bytes(), buf.as_mut_bytes()];
         let more_files = self.recv_into_bufs_all(&mut slices)?;
-        if !body.is_valid() || !more_files.is_empty() {
-            return Err(Error::InvalidMessage);
-        }
 
-        Ok((hdr, body, buf, files))
+        Ok((hdr, body, buf, files, more_files))
     }
 }
 
diff --git a/third_party/vmm_vhost/src/frontend_client.rs b/third_party/vmm_vhost/src/frontend_client.rs
index 549addd0f..8d69652ac 100644
--- a/third_party/vmm_vhost/src/frontend_client.rs
+++ b/third_party/vmm_vhost/src/frontend_client.rs
@@ -23,9 +23,6 @@ pub struct FrontendClient {
 
     // Protocol feature VHOST_USER_PROTOCOL_F_REPLY_ACK has been negotiated.
     reply_ack_negotiated: bool,
-
-    // whether the connection has encountered any failure
-    error: Option<i32>,
 }
 
 impl FrontendClient {
@@ -34,7 +31,6 @@ impl FrontendClient {
         FrontendClient {
             sock: ep,
             reply_ack_negotiated: false,
-            error: None,
         }
     }
 
@@ -72,7 +68,7 @@ impl FrontendClient {
         }
 
         let (reply, body, rfds) = self.sock.recv_message::<VhostUserU64>()?;
-        if !reply.is_reply_for(hdr) || !rfds.is_empty() || !body.is_valid() {
+        if !reply.is_valid() || !reply.is_reply_for(hdr) || !rfds.is_empty() || !body.is_valid() {
             return Err(Error::InvalidMessage);
         }
         if body.value != 0 {
@@ -90,11 +86,6 @@ impl FrontendClient {
     pub fn set_reply_ack_flag(&mut self, enable: bool) {
         self.reply_ack_negotiated = enable;
     }
-
-    /// Mark connection as failed with specified error code.
-    pub fn set_failed(&mut self, error: i32) {
-        self.error = Some(error);
-    }
 }
 
 impl Frontend for FrontendClient {
@@ -135,18 +126,3 @@ impl Frontend for FrontendClient {
         self.send_message(BackendReq::EXTERNAL_MAP, req, None)
     }
 }
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_backend_req_set_failed() {
-        let (p1, _p2) = Connection::pair().unwrap();
-        let mut frontend_client = FrontendClient::new(p1);
-
-        assert!(frontend_client.error.is_none());
-        frontend_client.set_failed(libc::EAGAIN);
-        assert_eq!(frontend_client.error, Some(libc::EAGAIN));
-    }
-}
diff --git a/third_party/vmm_vhost/src/frontend_server.rs b/third_party/vmm_vhost/src/frontend_server.rs
index 57acaaa30..6555c2a83 100644
--- a/third_party/vmm_vhost/src/frontend_server.rs
+++ b/third_party/vmm_vhost/src/frontend_server.rs
@@ -5,6 +5,7 @@ use std::fs::File;
 use std::mem;
 
 use base::AsRawDescriptor;
+use zerocopy::FromBytes;
 
 use crate::message::*;
 use crate::BackendReq;
@@ -105,39 +106,44 @@ impl<S: Frontend> FrontendServer<S> {
         //   message header
         // . validate message body and optional payload
         let (hdr, files) = self.sub_sock.recv_header()?;
+        if !hdr.is_valid() || hdr.is_reply() {
+            return Err(Error::InvalidMessage);
+        }
         self.check_attached_files(&hdr, &files)?;
-        let buf = self.sub_sock.recv_body_bytes(&hdr)?;
-        let size = buf.len();
+        let (buf, extra_files) = self.sub_sock.recv_body_bytes(&hdr)?;
+        if !extra_files.is_empty() {
+            return Err(Error::InvalidMessage);
+        }
 
         let res = match hdr.get_code() {
             Ok(BackendReq::CONFIG_CHANGE_MSG) => {
-                self.check_msg_size(&hdr, size, 0)?;
+                self.check_msg_size(&hdr, 0)?;
                 self.frontend
                     .handle_config_change()
                     .map_err(Error::ReqHandlerError)
             }
             Ok(BackendReq::SHMEM_MAP) => {
-                let msg = self.extract_msg_body::<VhostUserShmemMapMsg>(&hdr, size, &buf)?;
+                let msg = self.extract_msg_body::<VhostUserShmemMapMsg>(&hdr, &buf)?;
                 // check_attached_files() has validated files
                 self.frontend
                     .shmem_map(&msg, &files[0])
                     .map_err(Error::ReqHandlerError)
             }
             Ok(BackendReq::SHMEM_UNMAP) => {
-                let msg = self.extract_msg_body::<VhostUserShmemUnmapMsg>(&hdr, size, &buf)?;
+                let msg = self.extract_msg_body::<VhostUserShmemUnmapMsg>(&hdr, &buf)?;
                 self.frontend
                     .shmem_unmap(&msg)
                     .map_err(Error::ReqHandlerError)
             }
             Ok(BackendReq::GPU_MAP) => {
-                let msg = self.extract_msg_body::<VhostUserGpuMapMsg>(&hdr, size, &buf)?;
+                let msg = self.extract_msg_body::<VhostUserGpuMapMsg>(&hdr, &buf)?;
                 // check_attached_files() has validated files
                 self.frontend
                     .gpu_map(&msg, &files[0])
                     .map_err(Error::ReqHandlerError)
             }
             Ok(BackendReq::EXTERNAL_MAP) => {
-                let msg = self.extract_msg_body::<VhostUserExternalMapMsg>(&hdr, size, &buf)?;
+                let msg = self.extract_msg_body::<VhostUserExternalMapMsg>(&hdr, &buf)?;
                 self.frontend
                     .external_map(&msg)
                     .map_err(Error::ReqHandlerError)
@@ -150,17 +156,8 @@ impl<S: Frontend> FrontendServer<S> {
         res
     }
 
-    fn check_msg_size(
-        &self,
-        hdr: &VhostUserMsgHeader<BackendReq>,
-        size: usize,
-        expected: usize,
-    ) -> Result<()> {
-        if hdr.get_size() as usize != expected
-            || hdr.is_reply()
-            || hdr.get_version() != 0x1
-            || size != expected
-        {
+    fn check_msg_size(&self, hdr: &VhostUserMsgHeader<BackendReq>, expected: usize) -> Result<()> {
+        if hdr.get_size() as usize != expected {
             return Err(Error::InvalidMessage);
         }
         Ok(())
@@ -184,15 +181,13 @@ impl<S: Frontend> FrontendServer<S> {
         }
     }
 
-    fn extract_msg_body<T: Sized + VhostUserMsgValidator>(
+    fn extract_msg_body<T: FromBytes + VhostUserMsgValidator>(
         &self,
         hdr: &VhostUserMsgHeader<BackendReq>,
-        size: usize,
         buf: &[u8],
     ) -> Result<T> {
-        self.check_msg_size(hdr, size, mem::size_of::<T>())?;
-        // SAFETY: above check ensures that buf is `T` sized.
-        let msg = unsafe { std::ptr::read_unaligned(buf.as_ptr() as *const T) };
+        self.check_msg_size(hdr, mem::size_of::<T>())?;
+        let msg = T::read_from_bytes(buf).map_err(|_| Error::InvalidMessage)?;
         if !msg.is_valid() {
             return Err(Error::InvalidMessage);
         }
diff --git a/third_party/vmm_vhost/src/lib.rs b/third_party/vmm_vhost/src/lib.rs
index 04dba7a5f..ef81d5ba5 100644
--- a/third_party/vmm_vhost/src/lib.rs
+++ b/third_party/vmm_vhost/src/lib.rs
@@ -73,18 +73,12 @@ pub enum Error {
     /// client exited properly.
     #[error("client exited properly")]
     ClientExit,
-    /// Failure to deserialize data.
-    #[error("failed to deserialize data")]
-    DeserializationFailed,
     /// client disconnected.
     /// If connection is closed properly, use `ClientExit` instead.
     #[error("client closed the connection")]
     Disconnect,
     #[error("Failed to enter suspended state")]
     EnterSuspendedState(anyhow::Error),
-    /// Virtio/protocol features mismatch.
-    #[error("virtio features mismatch")]
-    FeatureMismatch,
     /// Failure from the frontend side.
     #[error("frontend Internal error")]
     FrontendInternalError,
@@ -119,103 +113,22 @@ pub enum Error {
     },
     /// Error from request handler
     #[error("handler failed to handle request: {0}")]
-    ReqHandlerError(IOError),
+    ReqHandlerError(#[source] IOError),
     /// Failure to restore.
     #[error("Failed to restore")]
     RestoreError(anyhow::Error),
-    /// Failure to serialize data.
-    #[error("failed to serialize data")]
-    SerializationFailed,
-    /// Failure to run device specific sleep.
-    #[error("Failed to run device specific sleep: {0}")]
-    SleepError(anyhow::Error),
     /// Failure to snapshot.
     #[error("Failed to snapshot")]
     SnapshotError(anyhow::Error),
-    /// The socket is broken or has been closed.
-    #[error("socket is broken: {0}")]
-    SocketBroken(std::io::Error),
-    /// Can't connect to peer.
-    #[error("can't connect to peer: {0}")]
-    SocketConnect(std::io::Error),
     /// Generic socket errors.
     #[error("socket error: {0}")]
     SocketError(std::io::Error),
-    /// Fail to get socket from the fd
-    #[error("Failed get socket from the fd: {0}")]
-    SocketFromFdError(std::path::PathBuf),
     /// Should retry the socket operation again.
     #[error("temporary socket error: {0}")]
     SocketRetry(std::io::Error),
-    /// Failure to stop a queue.
-    #[error("failed to stop queue")]
-    StopQueueError(anyhow::Error),
     /// Error from tx/rx on a Tube.
     #[error("failed to read/write on Tube: {0}")]
     TubeError(base::TubeError),
-    /// Error from VFIO device.
-    #[error("error occurred in VFIO device: {0}")]
-    VfioDeviceError(anyhow::Error),
-    /// Error from invalid vring index.
-    #[error("Vring index not found: {0}")]
-    VringIndexNotFound(usize),
-    /// Failure to run device specific wake.
-    #[error("Failed to run device specific wake: {0}")]
-    WakeError(anyhow::Error),
-}
-
-impl From<base::TubeError> for Error {
-    fn from(err: base::TubeError) -> Self {
-        match err {
-            base::TubeError::Disconnected => Error::Disconnect,
-            err => Error::TubeError(err),
-        }
-    }
-}
-
-impl From<std::io::Error> for Error {
-    fn from(err: std::io::Error) -> Self {
-        Error::SocketError(err)
-    }
-}
-
-impl From<base::Error> for Error {
-    /// Convert raw socket errors into meaningful vhost-user errors.
-    ///
-    /// The base::Error is a simple wrapper over the raw errno, which doesn't means
-    /// much to the vhost-user connection manager. So convert it into meaningful errors to simplify
-    /// the connection manager logic.
-    ///
-    /// # Return:
-    /// * - Error::SocketRetry: temporary error caused by signals or short of resources.
-    /// * - Error::SocketBroken: the underline socket is broken.
-    /// * - Error::SocketError: other socket related errors.
-    #[allow(unreachable_patterns)] // EWOULDBLOCK equals to EGAIN on linux
-    fn from(err: base::Error) -> Self {
-        match err.errno() {
-            // Retry:
-            // * EAGAIN, EWOULDBLOCK: The socket is marked nonblocking and the requested operation
-            //   would block.
-            // * EINTR: A signal occurred before any data was transmitted
-            // * ENOBUFS: The  output  queue  for  a network interface was full.  This generally
-            //   indicates that the interface has stopped sending, but may be caused by transient
-            //   congestion.
-            // * ENOMEM: No memory available.
-            libc::EAGAIN | libc::EWOULDBLOCK | libc::EINTR | libc::ENOBUFS | libc::ENOMEM => {
-                Error::SocketRetry(err.into())
-            }
-            // Broken:
-            // * ECONNRESET: Connection reset by peer.
-            // * EPIPE: The local end has been shut down on a connection oriented socket. In this
-            //   case the process will also receive a SIGPIPE unless MSG_NOSIGNAL is set.
-            libc::ECONNRESET | libc::EPIPE => Error::SocketBroken(err.into()),
-            // Write permission is denied on the destination socket file, or search permission is
-            // denied for one of the directories the path prefix.
-            libc::EACCES => Error::SocketConnect(IOError::from_raw_os_error(libc::EACCES)),
-            // Catch all other errors
-            e => Error::SocketError(IOError::from_raw_os_error(e)),
-        }
-    }
 }
 
 /// Result of vhost-user operations
@@ -521,14 +434,4 @@ mod tests {
         );
         assert_eq!(format!("{}", Error::InvalidOperation), "invalid operation");
     }
-
-    #[test]
-    fn test_error_from_base_error() {
-        let e: Error = base::Error::new(libc::EAGAIN).into();
-        if let Error::SocketRetry(e1) = e {
-            assert_eq!(e1.raw_os_error().unwrap(), libc::EAGAIN);
-        } else {
-            panic!("invalid error code conversion!");
-        }
-    }
 }
diff --git a/third_party/vmm_vhost/src/sys/unix.rs b/third_party/vmm_vhost/src/sys/unix.rs
index 5ad7d3b81..279be07b9 100644
--- a/third_party/vmm_vhost/src/sys/unix.rs
+++ b/third_party/vmm_vhost/src/sys/unix.rs
@@ -213,7 +213,6 @@ impl SocketPlatformConnection {
     /// * - (number of bytes received, [received files]) on success
     /// * - Disconnect: the connection is closed.
     /// * - SocketRetry: temporary error caused by signals or short of resources.
-    /// * - SocketBroken: the underline socket is broken.
     /// * - SocketError: other socket related errors.
     pub fn recv_into_bufs(
         &self,
@@ -221,7 +220,17 @@ impl SocketPlatformConnection {
         allow_fd: bool,
     ) -> Result<(usize, Option<Vec<File>>)> {
         let max_fds = if allow_fd { MAX_ATTACHED_FD_ENTRIES } else { 0 };
-        let (bytes, fds) = self.sock.recv_vectored_with_fds(bufs, max_fds)?;
+        let (bytes, fds) = match self.sock.recv_vectored_with_fds(bufs, max_fds) {
+            Ok((bytes, fds)) => (bytes, fds),
+            Err(e) => {
+                return Err(match e.kind() {
+                    ErrorKind::WouldBlock | ErrorKind::Interrupted | ErrorKind::OutOfMemory => {
+                        Error::SocketRetry(e)
+                    }
+                    _ => Error::SocketError(e),
+                });
+            }
+        };
 
         // 0-bytes indicates that the connection is closed.
         if bytes == 0 {
@@ -264,7 +273,7 @@ impl<R: Req> TryFrom<UnixStream> for Connection<R> {
     fn try_from(sock: UnixStream) -> Result<Self> {
         Ok(Self(
             SocketPlatformConnection {
-                sock: sock.try_into()?,
+                sock: sock.try_into().map_err(Error::SocketError)?,
             },
             std::marker::PhantomData,
             std::marker::PhantomData,
@@ -275,7 +284,7 @@ impl<R: Req> TryFrom<UnixStream> for Connection<R> {
 impl<R: Req> Connection<R> {
     /// Create a pair of unnamed vhost-user connections connected to each other.
     pub fn pair() -> Result<(Self, Self)> {
-        let (client, server) = UnixStream::pair()?;
+        let (client, server) = UnixStream::pair().map_err(Error::SocketError)?;
         let client_connection = Connection::try_from(client)?;
         let server_connection = Connection::try_from(server)?;
         Ok((client_connection, server_connection))
@@ -302,7 +311,7 @@ impl<S: Frontend> FrontendServer<S> {
     ///
     /// [BackendClient::set_slave_request_fd()]: struct.BackendClient.html#method.set_slave_request_fd
     pub fn with_stream(backend: S) -> Result<(Self, SafeDescriptor)> {
-        let (tx, rx) = UnixStream::pair()?;
+        let (tx, rx) = UnixStream::pair().map_err(Error::SocketError)?;
         let rx_connection = Connection::try_from(rx)?;
         Ok((
             Self::new(backend, rx_connection)?,
@@ -319,18 +328,12 @@ pub(crate) mod tests {
     use super::*;
     use crate::backend_client::BackendClient;
     use crate::connection::Listener;
-    use crate::message::FrontendReq;
     use crate::Connection;
 
     pub(crate) fn temp_dir() -> TempDir {
         Builder::new().prefix("/tmp/vhost_test").tempdir().unwrap()
     }
 
-    fn connect(path: &Path) -> Result<Connection<FrontendReq>> {
-        let sock = UnixStream::connect(path).map_err(Error::SocketConnect)?;
-        Connection::try_from(sock)
-    }
-
     #[test]
     fn create_listener() {
         let dir = temp_dir();
@@ -361,13 +364,14 @@ pub(crate) mod tests {
         path.push("sock");
         let _ = SocketListener::new(&path, true).unwrap();
         let _ = SocketListener::new(&path, false).is_err();
-        assert!(connect(&path).is_err());
+        assert!(UnixStream::connect(&path).is_err());
 
         let mut listener = SocketListener::new(&path, true).unwrap();
         assert!(SocketListener::new(&path, false).is_err());
         listener.set_nonblocking(true).unwrap();
 
-        let backend_connection = connect(&path).unwrap();
+        let sock = UnixStream::connect(&path).unwrap();
+        let backend_connection = Connection::try_from(sock).unwrap();
         let _backend_client = BackendClient::new(backend_connection);
         let _server_connection = listener.accept().unwrap().unwrap();
     }
diff --git a/third_party/vmm_vhost/src/sys/windows.rs b/third_party/vmm_vhost/src/sys/windows.rs
index 464fb62a1..8af701591 100644
--- a/third_party/vmm_vhost/src/sys/windows.rs
+++ b/third_party/vmm_vhost/src/sys/windows.rs
@@ -56,6 +56,13 @@ impl From<Tube> for TubePlatformConnection {
     }
 }
 
+fn tube_err(e: base::TubeError) -> Error {
+    match e {
+        base::TubeError::Disconnected => Error::Disconnect,
+        e => Error::TubeError(e),
+    }
+}
+
 impl TubePlatformConnection {
     /// Sends a single message over the socket with optional attached file descriptors.
     ///
@@ -88,9 +95,9 @@ impl TubePlatformConnection {
 
         // We send the header and the body separately here. This is necessary on Windows. Otherwise
         // the recv side cannot read the header independently (the transport is message oriented).
-        self.tube.send(&hdr_msg)?;
+        self.tube.send(&hdr_msg).map_err(tube_err)?;
         if !body_msg.data.is_empty() {
-            self.tube.send(&body_msg)?;
+            self.tube.send(&body_msg).map_err(tube_err)?;
         }
 
         Ok(())
@@ -114,7 +121,7 @@ impl TubePlatformConnection {
     ) -> Result<(usize, Option<Vec<File>>)> {
         // TODO(b/221882601): implement "allow_rds"
 
-        let msg: Message = self.tube.recv()?;
+        let msg: Message = self.tube.recv().map_err(tube_err)?;
 
         let files = match msg.rds.len() {
             0 => None,
@@ -188,7 +195,7 @@ impl<R: Req> From<Tube> for Connection<R> {
 impl<R: Req> Connection<R> {
     /// Create a pair of unnamed vhost-user connections connected to each other.
     pub fn pair() -> Result<(Self, Self)> {
-        let (client, server) = Tube::pair()?;
+        let (client, server) = Tube::pair().map_err(Error::TubeError)?;
         Ok((Self::from(client), Self::from(server)))
     }
 
@@ -227,7 +234,7 @@ impl<S: Frontend> FrontendServer<S> {
     ///
     /// [BackendClient::set_slave_request_fd()]: struct.BackendClient.html#method.set_slave_request_fd
     pub fn with_tube(backend: S, backend_pid: u32) -> Result<(Self, SafeDescriptor)> {
-        let (tx, rx) = Tube::pair()?;
+        let (tx, rx) = Tube::pair().map_err(Error::TubeError)?;
         let rx_connection = Connection::from(rx);
         // SAFETY:
         // Safe because we expect the tube to be unpacked in the other process.
diff --git a/tools/contrib/cros_tracing_analyser/Cargo.lock b/tools/contrib/cros_tracing_analyser/Cargo.lock
index 2da10fe3f..2defc1365 100644
--- a/tools/contrib/cros_tracing_analyser/Cargo.lock
+++ b/tools/contrib/cros_tracing_analyser/Cargo.lock
@@ -117,7 +117,6 @@ dependencies = [
  "argh",
  "libtracecmd",
  "log",
- "once_cell",
  "serde",
  "serde_json",
 ]
diff --git a/tools/contrib/cros_tracing_analyser/Cargo.toml b/tools/contrib/cros_tracing_analyser/Cargo.toml
index 650a0d138..54a4b836f 100644
--- a/tools/contrib/cros_tracing_analyser/Cargo.toml
+++ b/tools/contrib/cros_tracing_analyser/Cargo.toml
@@ -10,7 +10,6 @@ anyhow = "1"
 argh = "0.1"
 libtracecmd = "0.2"
 log = "0.4"
-once_cell = "1.18.0"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 
diff --git a/tools/contrib/vcpu_blocker_analyzer/Cargo.lock b/tools/contrib/vcpu_blocker_analyzer/Cargo.lock
index 5fb553f45..b35171499 100644
--- a/tools/contrib/vcpu_blocker_analyzer/Cargo.lock
+++ b/tools/contrib/vcpu_blocker_analyzer/Cargo.lock
@@ -243,12 +243,6 @@ version = "2.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149"
 
-[[package]]
-name = "once_cell"
-version = "1.19.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"
-
 [[package]]
 name = "pin-project-lite"
 version = "0.2.13"
@@ -316,9 +310,9 @@ checksum = "e898588f33fdd5b9420719948f9f2a32c922a246964576f71ba7f24f80610fbc"
 
 [[package]]
 name = "rstest"
-version = "0.18.2"
+version = "0.19.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "97eeab2f3c0a199bc4be135c36c924b6590b88c377d416494288c14f2db30199"
+checksum = "9d5316d2a1479eeef1ea21e7f9ddc67c191d497abc8fc3ba2467857abbb68330"
 dependencies = [
  "futures",
  "futures-timer",
@@ -328,9 +322,9 @@ dependencies = [
 
 [[package]]
 name = "rstest_macros"
-version = "0.18.2"
+version = "0.19.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d428f8247852f894ee1be110b375111b586d4fa431f6c46e64ba5a0dcccbe605"
+checksum = "04a9df72cc1f67020b0d63ad9bfe4a323e459ea7eb68e03bd9824db49f9a4c25"
 dependencies = [
  "cfg-if",
  "glob",
@@ -451,7 +445,6 @@ dependencies = [
  "argh",
  "env_logger",
  "log",
- "once_cell",
  "regex",
  "rstest",
  "serde",
diff --git a/tools/contrib/vcpu_blocker_analyzer/Cargo.toml b/tools/contrib/vcpu_blocker_analyzer/Cargo.toml
index 8ad974ccc..7ae82446c 100644
--- a/tools/contrib/vcpu_blocker_analyzer/Cargo.toml
+++ b/tools/contrib/vcpu_blocker_analyzer/Cargo.toml
@@ -13,7 +13,6 @@ log = "0.4"
 regex = "1.3"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
-once_cell = "1"
 
 [dev-dependencies]
 rstest = "0.19"
diff --git a/tools/contrib/vcpu_blocker_analyzer/src/parse.rs b/tools/contrib/vcpu_blocker_analyzer/src/parse.rs
index 65826dc0b..36244ac93 100644
--- a/tools/contrib/vcpu_blocker_analyzer/src/parse.rs
+++ b/tools/contrib/vcpu_blocker_analyzer/src/parse.rs
@@ -2,10 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+use std::sync::OnceLock;
+
 use anyhow::anyhow;
 use anyhow::Context;
 use anyhow::Result;
-use once_cell::sync::OnceCell;
 use regex::Regex;
 
 use crate::ProcState;
@@ -29,7 +30,7 @@ impl PartialEq for Event {
     }
 }
 
-static EVENT_PATTERN: OnceCell<Regex> = OnceCell::new();
+static EVENT_PATTERN: OnceLock<Regex> = OnceLock::new();
 
 pub fn parse_event(line: &str) -> Option<Event> {
     let event_pattern = EVENT_PATTERN.get_or_init(|| {
@@ -50,7 +51,7 @@ pub fn parse_event(line: &str) -> Option<Event> {
     })
 }
 
-static VCPU_ID_PATTERN: OnceCell<Regex> = OnceCell::new();
+static VCPU_ID_PATTERN: OnceLock<Regex> = OnceLock::new();
 
 pub fn parse_vcpu_id(proc_name: &str) -> Result<usize> {
     let vcpu_id_pattern = VCPU_ID_PATTERN.get_or_init(|| Regex::new(r"crosvm_vcpu(\d+)").unwrap());
@@ -74,7 +75,7 @@ pub struct SchedWaking {
     pub waked_pid: i32,
 }
 
-static SCHED_WAKING_PATTERN: OnceCell<Regex> = OnceCell::new();
+static SCHED_WAKING_PATTERN: OnceLock<Regex> = OnceLock::new();
 
 pub fn parse_sched_waking(details: &str) -> Result<SchedWaking> {
     let sched_waking_pattern = SCHED_WAKING_PATTERN
@@ -100,7 +101,7 @@ pub struct SchedSwitch {
     pub new_pid: i32,
 }
 
-static SCHED_SWITCH_PATTERN: OnceCell<Regex> = OnceCell::new();
+static SCHED_SWITCH_PATTERN: OnceLock<Regex> = OnceLock::new();
 
 pub fn parse_sched_switch(details: &str) -> Result<SchedSwitch> {
     let sched_switch_pattern = SCHED_SWITCH_PATTERN.get_or_init(|| Regex::new(r"(?P<prev>.*):(?P<prev_pid>\d+) \[-?\d+\] (?P<state>\S+) ==> (?P<new>.*):(?P<new_pid>\d+) \[-?\d+\]").expect("failed to compile regex"));
@@ -136,7 +137,7 @@ pub fn parse_sched_switch(details: &str) -> Result<SchedSwitch> {
     })
 }
 
-static TASK_RENAME_PATTERN: OnceCell<Regex> = OnceCell::new();
+static TASK_RENAME_PATTERN: OnceLock<Regex> = OnceLock::new();
 
 pub fn parse_task_rename(details: &str) -> Result<String> {
     // Match a line like "newcomm=D-Bus Thread oom_score_adj="
diff --git a/tools/custom_checks b/tools/custom_checks
index 00630fec0..c60050528 100755
--- a/tools/custom_checks
+++ b/tools/custom_checks
@@ -44,7 +44,6 @@ def check_platform_independent(*files: str):
 CRLF_LINE_ENDING_FILES: List[str] = [
     "**.bat",
     "**.ps1",
-    "e2e_tests/tests/goldens/backcompat_test_simple_lspci_win.txt",
     "tools/windows/build_test",
 ]
 
diff --git a/tools/deps/install-x86_64-other b/tools/deps/install-x86_64-other
index 7279e36b9..3f1e07dbd 100755
--- a/tools/deps/install-x86_64-other
+++ b/tools/deps/install-x86_64-other
@@ -6,7 +6,8 @@ set -ex
 
 # mdformat is not available as a debian package. Install via pipx instead.
 pipx install mdformat
-pipx inject mdformat mdformat-gfm mdformat-footnote
+pipx inject mdformat mdformat-gfm mdformat-footnote \
+    || echo "b/295234319: ignoring failure may be errors if mdformat is not installed"
 pipx ensurepath
 
 # Install rustup if not available yet
diff --git a/tools/dev_container b/tools/dev_container
index 4636e6909..fd0e8807a 100755
--- a/tools/dev_container
+++ b/tools/dev_container
@@ -27,6 +27,7 @@
 import argparse
 from pathlib import Path
 import shutil
+import stat
 from impl.util import (
     add_common_args,
     confirm,
@@ -187,6 +188,39 @@ def ensure_container_is_alive(docker: cmd, docker_args: List[Optional[str]], cro
     return cid
 
 
+def access_needs_supplemental_group(file_path: str, write=True):
+    """
+    Checks if access to a given resource/file is granted through user's supplemental
+    group as opposed to ownership or world access.
+
+    Returns True if and only if access is permitted and is granted through membership
+    in a supplemental group. If access is permitted by other means or no access
+    granted returns False.
+
+    This function does not consider superuser case.
+    """
+    if not os.access(file_path, os.W_OK if write else os.R_OK, effective_ids=True):
+        return False
+
+    euid = os.geteuid()
+    egid = os.getegid()
+
+    stat_info = os.stat(file_path)
+
+    if euid == stat_info.st_uid:
+        return False  # Access granted to owner
+
+    desired_mode = stat.S_IWGRP if write else stat.S_IRGRP
+    if not (stat_info.st_mode & desired_mode):
+        return False  # Access is not through group ownership
+
+    if egid == stat_info.st_gid:
+        return False  # Access granted through the primary group
+
+    # Assume access is granted through supplemental group.
+    return True
+
+
 def validate_podman(podman: cmd):
     graph_driver_name = podman("info --format={{.Store.GraphDriverName}}").stdout()
     config_file_name = podman("info --format={{.Store.ConfigFile}}").stdout()
@@ -213,6 +247,13 @@ def validate_podman(podman: cmd):
                 usermod.fg()
                 podman("system migrate").fg()
 
+        if access_needs_supplemental_group("/dev/kvm"):
+            runtime = podman("info --format={{.Host.OCIRuntime.Name}}").stdout()
+            if runtime != "crun":
+                print("On this system access to /dev/kvm relies on supplemental groups.")
+                print("This functionality ('keep-groups') is only available with 'crun'.")
+                print("Please switch podman to use 'crun' runtime.")
+
 
 def main(argv: List[str]):
     parser = argparse.ArgumentParser()
diff --git a/tools/impl/bindgen-common.sh b/tools/impl/bindgen-common.sh
index 05a13a5e3..0cf43925d 100755
--- a/tools/impl/bindgen-common.sh
+++ b/tools/impl/bindgen-common.sh
@@ -4,9 +4,7 @@
 
 # Helper functions for bindgen scripts sourced by tools/bindgen-all-the-things.
 
-export BINDGEN_LINUX="${PWD}/../../third_party/kernel/v6.12"
-
-export BINDGEN_PLATFORM2="${PWD}/../../platform2"
+LINUX_VERSION="6.12.18"
 
 export BINDGEN_OPTS=(
     '--disable-header-comment'
@@ -50,6 +48,7 @@ bindgen_generate() {
 }
 
 bindgen_cleanup() {
+    rm -rf "${BINDGEN_TEMP}"
     rm -rf "${BINDGEN_LINUX_X86_HEADERS}" "${BINDGEN_LINUX_ARM64_HEADERS}" "${BINDGEN_LINUX_RISCV_HEADERS}"
 }
 
@@ -66,14 +65,18 @@ if [[ -z "${BINDGEN_LINUX_X86_HEADERS+x}" || ! -d "${BINDGEN_LINUX_X86_HEADERS}"
 
     echo -n "Installing Linux headers for x86, arm64, and riscv..."
     (
-        cd "${BINDGEN_LINUX}"
+        BINDGEN_LINUX_TARBALL="https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-${LINUX_VERSION}.tar.xz"
+        export BINDGEN_TEMP=$(mktemp -d)
+        cd "${BINDGEN_TEMP}"
+
+        # TODO: consider caching the downloaded file
+        curl "${BINDGEN_LINUX_TARBALL}" | tar xfJ -
+        cd "linux-${LINUX_VERSION}"
+
         nproc=$(nproc)
         make -s headers_install ARCH=x86 INSTALL_HDR_PATH="${BINDGEN_LINUX_X86_HEADERS}" -j "${nproc}"
         make -s headers_install ARCH=arm64 INSTALL_HDR_PATH="${BINDGEN_LINUX_ARM64_HEADERS}" -j "${nproc}"
         make -s headers_install ARCH=riscv INSTALL_HDR_PATH="${BINDGEN_LINUX_RISCV_HEADERS}" -j "${nproc}"
-        make -s mrproper ARCH=x86
-        make -s mrproper ARCH=arm64
-        make -s mrproper ARCH=riscv
     )
     echo " done."
 fi
diff --git a/tools/impl/catapult_converter/Cargo.toml b/tools/impl/catapult_converter/Cargo.toml
index aab66d355..968f03893 100644
--- a/tools/impl/catapult_converter/Cargo.toml
+++ b/tools/impl/catapult_converter/Cargo.toml
@@ -5,7 +5,7 @@ authors = ["The Chromium OS Authors"]
 edition = "2021"
 
 [dependencies]
-serde_json = "1"
-serde = { version = "1", features = ["derive"] }
+serde_json = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
 argh = "0.1"
 uuid = {version = "1", features = ["v4"]}
diff --git a/tools/impl/catapult_converter/src/main.rs b/tools/impl/catapult_converter/src/main.rs
index a2b515e77..e9dc5f7d9 100644
--- a/tools/impl/catapult_converter/src/main.rs
+++ b/tools/impl/catapult_converter/src/main.rs
@@ -339,7 +339,7 @@ fn main() {
         }
 
         output.push(HistogramSetElement::Histogram(Histogram::new(
-            name.replace(" ", "_").as_str(),
+            name.replace(' ', "_").as_str(),
             test_result.unit,
             diag_map,
             test_result.values,
diff --git a/tools/impl/dev_container/Dockerfile b/tools/impl/dev_container/Dockerfile
index 28841f3bb..c244eb1d8 100644
--- a/tools/impl/dev_container/Dockerfile
+++ b/tools/impl/dev_container/Dockerfile
@@ -40,10 +40,6 @@ ENV CARGO_TARGET_DIR=/scratch/cargo_target
 # Allow APT to cache packages between docker image builds
 RUN rm -f /etc/apt/apt.conf.d/docker-clean; echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache
 
-# Add foreign architectures for cross-compilation.
-RUN dpkg --add-architecture arm64 \
-    && dpkg --add-architecture armhf
-
 # Add wine64 to PATH, as debian removed alternative entry to wine64
 ENV PATH=/usr/lib/wine:$PATH
 
@@ -53,6 +49,7 @@ COPY --chmod=555 \
     tools/deps/install-aarch64-other \
     tools/deps/install-armhf-other \
     tools/deps/install-mingw64-other \
+    tools/deps/install-riscv64-other \
     rust-toolchain \
     /tools/deps/
 RUN cd /tools/deps \
@@ -60,6 +57,7 @@ RUN cd /tools/deps \
     && ./install-aarch64-other \
     && ./install-armhf-other \
     && ./install-mingw64-other \
+    && ./install-riscv64-other \
     # We only use the nightly toolchain for rustfmt, remove other parts to save space.
     && rustup component remove --toolchain nightly rust-std \
     && rustup component remove --toolchain nightly cargo
diff --git a/tools/impl/dev_container/Dockerfile.base b/tools/impl/dev_container/Dockerfile.base
index 25b1c453e..db7d4671e 100644
--- a/tools/impl/dev_container/Dockerfile.base
+++ b/tools/impl/dev_container/Dockerfile.base
@@ -12,14 +12,22 @@ FROM docker.io/debian:testing-slim
 
 # Add foreign architectures for cross-compilation.
 RUN dpkg --add-architecture arm64 \
-    && dpkg --add-architecture armhf
+    && dpkg --add-architecture armhf \
+    && dpkg --add-architecture riscv64
 
 # Use ./tools/deps/install-*-debs scripts to install debian packages
-COPY --chmod=555 tools/deps/install-x86_64-debs tools/deps/install-aarch64-debs tools/deps/install-armhf-debs tools/deps/install-mingw64-debs /tools/deps/
+COPY --chmod=555 \
+    tools/deps/install-x86_64-debs \
+    tools/deps/install-aarch64-debs \
+    tools/deps/install-armhf-debs \
+    tools/deps/install-mingw64-debs \
+    tools/deps/install-riscv64-debs \
+    /tools/deps/
 RUN cd /tools/deps \
     && apt-get update \
     && apt-get install --yes sudo curl \
     && ./install-x86_64-debs \
     && ./install-aarch64-debs \
     && ./install-armhf-debs \
-    && ./install-mingw64-debs
+    && ./install-mingw64-debs \
+    && ./install-riscv64-debs
diff --git a/tools/impl/dev_container/base_version b/tools/impl/dev_container/base_version
index 75d30fb53..9742708e6 100644
--- a/tools/impl/dev_container/base_version
+++ b/tools/impl/dev_container/base_version
@@ -1 +1 @@
-r0001
+r0002
diff --git a/tools/impl/dev_container/version b/tools/impl/dev_container/version
index 47e93c1fc..86292f4b9 100644
--- a/tools/impl/dev_container/version
+++ b/tools/impl/dev_container/version
@@ -1 +1 @@
-r0049
+r0051
diff --git a/tools/presubmit b/tools/presubmit
index 1e01029a0..8e52841e2 100755
--- a/tools/presubmit
+++ b/tools/presubmit
@@ -25,7 +25,7 @@ mdformat = cmd("mdformat")
 lucicfg = cmd("third_party/depot_tools/lucicfg")
 
 # All supported platforms as a type and a list.
-Platform = Literal["x86_64", "aarch64", "mingw64", "armhf"]
+Platform = Literal["x86_64", "aarch64", "mingw64", "armhf", "riscv64"]
 PLATFORMS: Tuple[Platform, ...] = typing.get_args(Platform)
 
 ClippyOnlyPlatform = Literal["android"]
diff --git a/tube_transporter/Cargo.toml b/tube_transporter/Cargo.toml
index 79cc20132..590db228f 100644
--- a/tube_transporter/Cargo.toml
+++ b/tube_transporter/Cargo.toml
@@ -6,11 +6,11 @@ edition = "2021"
 
 
 [dependencies]
-base = { path = "../base" }
-rand = "0.8"
-thiserror = "1.0.20"
-serde = { version = "1", features = [ "derive" ] }
-serde_json = "1"
+base = { workspace = true }
+rand = { workspace = true }
+thiserror = { workspace = true }
+serde = { workspace = true, features = [ "derive" ] }
+serde_json = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
 win_util = { path = "../win_util"}
diff --git a/usb_sys/Cargo.toml b/usb_sys/Cargo.toml
index af76b69cd..010fe2858 100644
--- a/usb_sys/Cargo.toml
+++ b/usb_sys/Cargo.toml
@@ -5,4 +5,4 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-base = { path = "../base" }
+base = { workspace = true }
diff --git a/usb_util/Cargo.toml b/usb_util/Cargo.toml
index c34644c2f..e6f535a17 100644
--- a/usb_util/Cargo.toml
+++ b/usb_util/Cargo.toml
@@ -6,11 +6,11 @@ edition = "2021"
 
 [dependencies]
 static_assertions = "1.1"
-data_model = { path = "../common/data_model" }
-libc = "0.2"
-remain = "0.2"
-thiserror = "1"
-base = { path = "../base" }
-usb_sys = { path = "../usb_sys" }
-sync = { path = "../common/sync" }
+data_model = { workspace = true }
+libc = { workspace = true }
+remain = { workspace = true }
+thiserror = { workspace = true }
+base = { workspace = true }
+usb_sys = { workspace = true }
+sync = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/vendor/generic/anti_tamper/Cargo.toml b/vendor/generic/anti_tamper/Cargo.toml
index 7c8e0091c..830f65e74 100644
--- a/vendor/generic/anti_tamper/Cargo.toml
+++ b/vendor/generic/anti_tamper/Cargo.toml
@@ -10,4 +10,4 @@ edition = "2021"
 anti-tamper = []
 
 [dependencies]
-base = { path = "../../../base" }
+base = { workspace = true }
diff --git a/vendor/generic/broker_ipc/Cargo.toml b/vendor/generic/broker_ipc/Cargo.toml
index 3a1eb4a9b..069113a14 100644
--- a/vendor/generic/broker_ipc/Cargo.toml
+++ b/vendor/generic/broker_ipc/Cargo.toml
@@ -9,6 +9,6 @@ process-invariants = []
 crash-report = ["crash_report"]
 
 [dependencies]
-anyhow = "1"
-crash_report = { path = "../crash_report", optional = true }
-serde = { version = "1", features = ["derive"] }
+anyhow = { workspace = true }
+crash_report = { workspace = true, optional = true }
+serde = { workspace = true, features = ["derive"] }
diff --git a/vendor/generic/broker_ipc/src/lib.rs b/vendor/generic/broker_ipc/src/lib.rs
index 03979dc32..3b57eefa9 100644
--- a/vendor/generic/broker_ipc/src/lib.rs
+++ b/vendor/generic/broker_ipc/src/lib.rs
@@ -27,8 +27,10 @@ pub fn init_child_crash_reporting(_attrs: &ProductAttributes) {
     // Do nothing. Crash reporting is implemented by a specific product.
 }
 
-pub fn product_child_setup(_attrs: &ProductAttributes) -> anyhow::Result<()> {
-    Ok(())
+pub struct ProductProcessState;
+
+pub fn product_child_setup(_attrs: &ProductAttributes) -> anyhow::Result<ProductProcessState> {
+    Ok(ProductProcessState)
 }
 
 #[cfg(feature = "process-invariants")]
diff --git a/vendor/generic/crash_report/Cargo.toml b/vendor/generic/crash_report/Cargo.toml
index 65b69e111..28555208a 100644
--- a/vendor/generic/crash_report/Cargo.toml
+++ b/vendor/generic/crash_report/Cargo.toml
@@ -9,9 +9,9 @@ crash-report = []
 perfetto-system-backend = []
 
 [dependencies]
-anyhow = "1"
-base = { path = "../../../base" }                # provided by ebuild
-serde = { version = "1", features = ["derive"] }
+anyhow = { workspace = true }
+base = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
 
 [target.'cfg(windows)'.dependencies]
 win_util = { path = "../../../win_util" }
diff --git a/vendor/generic/crash_report/src/lib.rs b/vendor/generic/crash_report/src/lib.rs
index 37c87788f..81481871c 100644
--- a/vendor/generic/crash_report/src/lib.rs
+++ b/vendor/generic/crash_report/src/lib.rs
@@ -47,7 +47,7 @@ pub mod product_type {
 }
 
 /// Attributes about a process that are required to set up annotations for crash reports.
-#[derive(Debug, Serialize, Deserialize, Clone)]
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
 pub struct CrashReportAttributes {
     pub product_type: String,
     pub pipe_name: Option<String>,
diff --git a/vendor/generic/crypto/Cargo.toml b/vendor/generic/crypto/Cargo.toml
index 5569cc6fd..eb5fff37e 100644
--- a/vendor/generic/crypto/Cargo.toml
+++ b/vendor/generic/crypto/Cargo.toml
@@ -8,10 +8,10 @@ edition = "2021"
 rustcrypto = []
 
 [dependencies]
-anyhow = "1"
-base = { path = "../../../base" }
-serde = { version = "1", features = ["derive"] }
-serde_json = "1"
+anyhow = { workspace = true }
+base = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+serde_json = { workspace = true }
 zeroize = "1.5.7"
 
 [dev-dependencies]
diff --git a/vendor/generic/metrics/Cargo.toml b/vendor/generic/metrics/Cargo.toml
index cdc9bbf17..203ef47c4 100644
--- a/vendor/generic/metrics/Cargo.toml
+++ b/vendor/generic/metrics/Cargo.toml
@@ -10,6 +10,6 @@ experimental = []
 collect = []
 
 [dependencies]
-anyhow = "1"
-base = { path = "../../../base" }
-metrics_events = { path = "../../../metrics_events" }
+anyhow = { workspace = true }
+base = { workspace = true }
+metrics_events = { workspace = true }
diff --git a/vendor/generic/metrics_events/Cargo.toml b/vendor/generic/metrics_events/Cargo.toml
index 19d3a5ba5..83013fc28 100644
--- a/vendor/generic/metrics_events/Cargo.toml
+++ b/vendor/generic/metrics_events/Cargo.toml
@@ -5,4 +5,4 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-serde = { version = "1", features = ["derive"] }
+serde = { workspace = true, features = ["derive"] }
diff --git a/vendor/generic/vm_control/Cargo.toml b/vendor/generic/vm_control/Cargo.toml
index 358408351..f66357148 100644
--- a/vendor/generic/vm_control/Cargo.toml
+++ b/vendor/generic/vm_control/Cargo.toml
@@ -6,4 +6,4 @@ edition = "2021"
 
 
 [dependencies]
-serde = { version = "1", features = ["derive"] }
+serde = { workspace = true, features = ["derive"] }
diff --git a/vfio_sys/Cargo.toml b/vfio_sys/Cargo.toml
index a187ba693..7d0403f6f 100644
--- a/vfio_sys/Cargo.toml
+++ b/vfio_sys/Cargo.toml
@@ -5,5 +5,5 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-base = { path = "../base" }
+base = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/vfio_sys/bindgen.sh b/vfio_sys/bindgen.sh
index adbc7c428..2cd2eea91 100755
--- a/vfio_sys/bindgen.sh
+++ b/vfio_sys/bindgen.sh
@@ -67,8 +67,6 @@ bindgen_generate \
     --allowlist-type='vfio_.*' \
     --with-derive-custom "vfio_info_cap_header=FromBytes,Immutable,IntoBytes,KnownLayout" \
     --with-derive-custom "vfio_iova_range=FromBytes,Immutable,IntoBytes,KnownLayout" \
-    "${BINDGEN_LINUX}/include/uapi/linux/vfio.h" \
-    -- \
-    -D__user= \
+    "${BINDGEN_LINUX_X86_HEADERS}/include/linux/vfio.h" \
     | replace_linux_int_types | fix_vfio_type \
     > vfio_sys/src/vfio.rs
diff --git a/vhost/Cargo.toml b/vhost/Cargo.toml
index 8c8360f60..27d60f240 100644
--- a/vhost/Cargo.toml
+++ b/vhost/Cargo.toml
@@ -6,10 +6,10 @@ edition = "2021"
 
 [dependencies]
 static_assertions = "1.1"
-libc = "0.2"
-net_util = { path = "../net_util" }
-base = { path = "../base" }
-remain = "0.2"
-thiserror = "1"
-virtio_sys = { path = "../virtio_sys" }
-vm_memory = { path = "../vm_memory" }
+libc = { workspace = true }
+net_util = { workspace = true }
+base = { workspace = true }
+remain = { workspace = true }
+thiserror = { workspace = true }
+virtio_sys = { workspace = true }
+vm_memory = { workspace = true }
diff --git a/virtio_sys/Cargo.toml b/virtio_sys/Cargo.toml
index 67dd93991..a0c9755dd 100644
--- a/virtio_sys/Cargo.toml
+++ b/virtio_sys/Cargo.toml
@@ -5,6 +5,6 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-base = { path = "../base" }
-data_model = { path = "../common/data_model" }
+base = { workspace = true }
+data_model = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
diff --git a/virtio_sys/bindgen.sh b/virtio_sys/bindgen.sh
index 37d88f91f..fb8ecdee4 100755
--- a/virtio_sys/bindgen.sh
+++ b/virtio_sys/bindgen.sh
@@ -57,6 +57,8 @@ VIRTIO_IDS_EXTRAS="
 //! from 63) are nonstandard and not defined by the virtio specification.
 
 // Added by virtio_sys/bindgen.sh - do not edit the generated file.
+pub const VIRTIO_ID_WL: u32 = 63;
+pub const VIRTIO_ID_TPM: u32 = 62;
 // TODO(b/236144983): Fix this id when an official virtio-id is assigned to this device.
 pub const VIRTIO_ID_PVCLOCK: u32 = 61;
 // TODO: Remove this once the ID is included in the Linux headers.
diff --git a/virtio_sys/src/virtio_ids.rs b/virtio_sys/src/virtio_ids.rs
index f77fea955..d47cd32c1 100644
--- a/virtio_sys/src/virtio_ids.rs
+++ b/virtio_sys/src/virtio_ids.rs
@@ -12,6 +12,8 @@
 //! from 63) are nonstandard and not defined by the virtio specification.
 
 // Added by virtio_sys/bindgen.sh - do not edit the generated file.
+pub const VIRTIO_ID_WL: u32 = 63;
+pub const VIRTIO_ID_TPM: u32 = 62;
 // TODO(b/236144983): Fix this id when an official virtio-id is assigned to this device.
 pub const VIRTIO_ID_PVCLOCK: u32 = 61;
 // TODO: Remove this once the ID is included in the Linux headers.
@@ -56,5 +58,3 @@ pub const VIRTIO_ID_PARAM_SERV: u32 = 38;
 pub const VIRTIO_ID_AUDIO_POLICY: u32 = 39;
 pub const VIRTIO_ID_BT: u32 = 40;
 pub const VIRTIO_ID_GPIO: u32 = 41;
-pub const VIRTIO_ID_WL: u32 = 63;
-pub const VIRTIO_ID_TPM: u32 = 62;
diff --git a/vm_control/Android.bp b/vm_control/Android.bp
index 9d4d04a49..b8ebe8d1e 100644
--- a/vm_control/Android.bp
+++ b/vm_control/Android.bp
@@ -40,7 +40,6 @@ rust_library {
         "liblibc",
         "libmetrics",
         "libmetrics_events",
-        "libonce_cell",
         "libresources",
         "librutabaga_gfx",
         "libserde",
@@ -90,7 +89,6 @@ rust_test {
         "liblibc",
         "libmetrics",
         "libmetrics_events",
-        "libonce_cell",
         "libresources",
         "librutabaga_gfx",
         "libserde",
diff --git a/vm_control/Cargo.toml b/vm_control/Cargo.toml
index 184e807a3..8c1932cbe 100644
--- a/vm_control/Cargo.toml
+++ b/vm_control/Cargo.toml
@@ -14,30 +14,29 @@ registered_events = ["balloon", "protos/registered_events"]
 swap = ["swap/enable"]
 
 [dependencies]
-anyhow = "1"
-balloon_control = { path = "../common/balloon_control" }
-base = { path = "../base" }
-cfg-if = "1"
-gdbstub = { version = "0.7.0", optional = true }
-gdbstub_arch = { version = "0.3.0", optional = true }
-hypervisor = { path = "../hypervisor" }
-libc = "0.2"
-metrics = { path = "../metrics" }
-metrics_events = { path = "../metrics_events" }
-once_cell = "1.7.2"
-protos = { path = "../protos", optional = true }
-remain = "0.2"
-resources = { path = "../resources" }
-rutabaga_gfx = { path = "../rutabaga_gfx" }
-serde = { version = "1", features = ["derive"] }
-serde_json = "1"
-serde_keyvalue = { path = "../serde_keyvalue", features = ["argh_derive"] }
+anyhow = { workspace = true }
+balloon_control = { workspace = true }
+base = { workspace = true }
+cfg-if = { workspace = true }
+gdbstub = { workspace = true, optional = true }
+gdbstub_arch = { workspace = true, optional = true }
+hypervisor = { workspace = true }
+libc = { workspace = true }
+metrics = { workspace = true }
+metrics_events = { workspace = true }
+protos = { workspace = true, optional = true }
+remain = { workspace = true }
+resources = { workspace = true }
+rutabaga_gfx = { workspace = true }
+serde = { workspace = true, features = ["derive"] }
+serde_json = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
 snapshot = { workspace = true }
-swap = { path = "../swap" }
-sync = { path = "../common/sync" }
-thiserror = "1"
+swap = { workspace = true }
+sync = { workspace = true }
+thiserror = { workspace = true }
 vm_control_product = { path = "../vendor/generic/vm_control", package = "vm_control_product" }
-vm_memory = { path = "../vm_memory" }
+vm_memory = { workspace = true }
 
 [target.'cfg(windows)'.dependencies]
 winapi = "0.3"
diff --git a/vm_control/src/api.rs b/vm_control/src/api.rs
index c31a9955e..5f04d724c 100644
--- a/vm_control/src/api.rs
+++ b/vm_control/src/api.rs
@@ -24,6 +24,7 @@ use crate::VmMemoryDestination;
 use crate::VmMemoryRegionId;
 use crate::VmMemoryRequest;
 use crate::VmMemoryResponse;
+use crate::VmMemoryResponseError;
 use crate::VmMemorySource;
 
 #[derive(Error, Debug)]
@@ -32,7 +33,7 @@ pub enum ApiClientError {
     #[error("API client tube recv failed: {0}")]
     Recv(TubeError),
     #[error("Request failed: {0}")]
-    RequestFailed(#[from] base::Error),
+    RequestFailed(#[source] anyhow::Error),
     #[error("API client tube send failed: {0}")]
     Send(TubeError),
     #[error("API client tube sending FDs failed: {0}")]
@@ -63,7 +64,9 @@ impl VmMemoryClient {
     fn request_unit(&self, request: &VmMemoryRequest) -> Result<()> {
         match self.request(request)? {
             VmMemoryResponse::Ok => Ok(()),
-            VmMemoryResponse::Err(e) => Err(ApiClientError::RequestFailed(e)),
+            VmMemoryResponse::Err(VmMemoryResponseError(e)) => {
+                Err(ApiClientError::RequestFailed(e))
+            }
             _other => Err(ApiClientError::UnexpectedResponse),
         }
     }
@@ -88,7 +91,9 @@ impl VmMemoryClient {
             cache,
         };
         match self.request(&request)? {
-            VmMemoryResponse::Err(e) => Err(ApiClientError::RequestFailed(e)),
+            VmMemoryResponse::Err(VmMemoryResponseError(e)) => {
+                Err(ApiClientError::RequestFailed(e))
+            }
             VmMemoryResponse::RegisterMemory { region_id, .. } => Ok(region_id),
             _other => Err(ApiClientError::UnexpectedResponse),
         }
@@ -121,7 +126,9 @@ impl VmMemoryClient {
 
         match self.tube.recv().map_err(ApiClientError::Recv)? {
             VmMemoryResponse::RegisterMemory { slot, .. } => Ok(slot),
-            VmMemoryResponse::Err(e) => Err(ApiClientError::RequestFailed(e)),
+            VmMemoryResponse::Err(VmMemoryResponseError(e)) => {
+                Err(ApiClientError::RequestFailed(e))
+            }
             _ => Err(ApiClientError::UnexpectedResponse),
         }
     }
diff --git a/vm_control/src/lib.rs b/vm_control/src/lib.rs
index 42e9f7238..851bb07e9 100644
--- a/vm_control/src/lib.rs
+++ b/vm_control/src/lib.rs
@@ -96,6 +96,7 @@ use rutabaga_gfx::RutabagaGralloc;
 use rutabaga_gfx::RutabagaHandle;
 use rutabaga_gfx::RutabagaMappedRegion;
 use rutabaga_gfx::VulkanInfo;
+use serde::de::Error;
 use serde::Deserialize;
 use serde::Serialize;
 use snapshot::SnapshotReader;
@@ -344,13 +345,8 @@ pub enum SnapshotCommand {
 pub enum DeviceControlCommand {
     SleepDevices,
     WakeDevices,
-    SnapshotDevices {
-        snapshot_writer: SnapshotWriter,
-        compress_memory: bool,
-    },
-    RestoreDevices {
-        snapshot_reader: SnapshotReader,
-    },
+    SnapshotDevices { snapshot_writer: SnapshotWriter },
+    RestoreDevices { snapshot_reader: SnapshotReader },
     GetDevicesState,
     Exit,
 }
@@ -459,11 +455,11 @@ impl Display for VmMemorySource {
 
 impl VmMemorySource {
     /// Map the resource and return its mapping and size in bytes.
-    pub fn map(
+    fn map(
         self,
         gralloc: &mut RutabagaGralloc,
         prot: Protection,
-    ) -> Result<(Box<dyn MappedRegion>, u64, Option<SafeDescriptor>)> {
+    ) -> anyhow::Result<(Box<dyn MappedRegion>, u64, Option<SafeDescriptor>)> {
         let (mem_region, size, descriptor) = match self {
             VmMemorySource::Descriptor {
                 descriptor,
@@ -490,27 +486,27 @@ impl VmMemorySource {
                     device_uuid,
                     driver_uuid,
                 };
-                let mapped_region = match gralloc.import_and_map(
-                    RutabagaHandle {
-                        os_handle: to_rutabaga_desciptor(descriptor),
-                        handle_type,
-                    },
-                    VulkanInfo {
-                        memory_idx,
-                        device_id,
-                    },
-                    size,
-                ) {
-                    Ok(mapped_region) => {
-                        let mapped_region: Box<dyn MappedRegion> =
-                            Box::new(RutabagaMemoryRegion::new(mapped_region));
-                        mapped_region
-                    }
-                    Err(e) => {
-                        error!("gralloc failed to import and map: {}", e);
-                        return Err(SysError::new(EINVAL));
-                    }
-                };
+                let mapped_region = gralloc
+                    .import_and_map(
+                        RutabagaHandle {
+                            os_handle: to_rutabaga_desciptor(descriptor),
+                            handle_type,
+                        },
+                        VulkanInfo {
+                            memory_idx,
+                            device_id,
+                        },
+                        size,
+                    )
+                    .with_context(|| {
+                        format!(
+                            "gralloc failed to import and map, handle type: {}, memory index {}, \
+                             size: {}",
+                            handle_type, memory_idx, size
+                        )
+                    })?;
+                let mapped_region: Box<dyn MappedRegion> =
+                    Box::new(RutabagaMemoryRegion::new(mapped_region));
                 (mapped_region, size, None)
             }
             VmMemorySource::ExternalMapping { ptr, size } => {
@@ -683,22 +679,25 @@ fn try_map_to_prepared_region(
             (Descriptor(shm.as_raw_descriptor()), 0, size)
         }
         _ => {
-            error!(
+            let error = anyhow::anyhow!(
                 "source {} is not compatible with fixed mapping into prepared memory region",
                 source
             );
-            return Some(VmMemoryResponse::Err(SysError::new(EINVAL)));
+            return Some(VmMemoryResponse::Err(error.into()));
         }
     };
-    if let Err(err) = vm.add_fd_mapping(
-        *slot,
-        *dest_offset as usize,
-        size,
-        &descriptor,
-        file_offset,
-        *prot,
-    ) {
-        return Some(VmMemoryResponse::Err(err));
+    if let Err(err) = vm
+        .add_fd_mapping(
+            *slot,
+            *dest_offset as usize,
+            size,
+            &descriptor,
+            file_offset,
+            *prot,
+        )
+        .context("failed to add fd mapping when trying to map to prepared region")
+    {
+        return Some(VmMemoryResponse::Err(err.into()));
     }
 
     let guest_address = GuestAddress(guest_address.0 + dest_offset);
@@ -753,12 +752,14 @@ impl VmMemoryRequest {
                     return VmMemoryResponse::Ok;
                 }
 
-                match sys::prepare_shared_memory_region(vm, sys_allocator, alloc, cache) {
+                match sys::prepare_shared_memory_region(vm, sys_allocator, alloc, cache)
+                    .context("failed to prepare shared memory region")
+                {
                     Ok(region) => {
                         region_state.mapped_regions.insert(alloc, region);
                         VmMemoryResponse::Ok
                     }
-                    Err(e) => VmMemoryResponse::Err(e),
+                    Err(e) => VmMemoryResponse::Err(e.into()),
                 }
             }
             RegisterMemory {
@@ -775,25 +776,32 @@ impl VmMemoryRequest {
 
                 // Correct on Windows because callers of this IPC guarantee descriptor is a mapping
                 // handle.
-                let (mapped_region, size, descriptor) = match source.map(gralloc, prot) {
-                    Ok((region, size, descriptor)) => (region, size, descriptor),
-                    Err(e) => return VmMemoryResponse::Err(e),
-                };
+                let (mapped_region, size, descriptor) =
+                    match source.map(gralloc, prot).context("gralloc mapping") {
+                        Ok((region, size, descriptor)) => (region, size, descriptor),
+                        Err(e) => return VmMemoryResponse::Err(e.into()),
+                    };
 
-                let guest_addr = match dest.allocate(sys_allocator, size) {
+                let guest_addr = match dest
+                    .allocate(sys_allocator, size)
+                    .context("VM memory destination allocation fails")
+                {
                     Ok(addr) => addr,
-                    Err(e) => return VmMemoryResponse::Err(e),
+                    Err(e) => return VmMemoryResponse::Err(e.into()),
                 };
 
-                let slot = match vm.add_memory_region(
-                    guest_addr,
-                    mapped_region,
-                    prot == Protection::read(),
-                    false,
-                    cache,
-                ) {
+                let slot = match vm
+                    .add_memory_region(
+                        guest_addr,
+                        mapped_region,
+                        prot == Protection::read(),
+                        false,
+                        cache,
+                    )
+                    .context("failed to add memory region when registering memory")
+                {
                     Ok(slot) => slot,
-                    Err(e) => return VmMemoryResponse::Err(e),
+                    Err(e) => return VmMemoryResponse::Err(e.into()),
                 };
 
                 let region_id = VmMemoryRegionId(guest_addr);
@@ -809,10 +817,15 @@ impl VmMemoryRequest {
                     match virtio_iommu_request(&iommu_client.tube.lock(), &request) {
                         Ok(VirtioIOMMUResponse::VfioResponse(VirtioIOMMUVfioResult::Ok)) => (),
                         resp => {
-                            error!("Unexpected message response: {:?}", resp);
-                            // Ignore the result because there is nothing we can do with a failure.
-                            let _ = vm.remove_memory_region(slot);
-                            return VmMemoryResponse::Err(SysError::new(EINVAL));
+                            let error = anyhow::anyhow!(
+                                "Unexpected virtio-iommu message response when registering memory: \
+                                 {:?}", resp);
+                            if let Err(e) = vm.remove_memory_region(slot) {
+                                // There is nothing we can do here, so we just log a warning
+                                // message.
+                                warn!("failed to remove memory region: {:?}", e);
+                            }
+                            return VmMemoryResponse::Err(error.into());
                         }
                     };
 
@@ -836,12 +849,10 @@ impl VmMemoryRequest {
                     let mem = match MemoryMappingBuilder::new(shm.size() as usize)
                         .from_shared_memory(&shm)
                         .build()
+                        .context("failed to build MemoryMapping from shared memory")
                     {
                         Ok(mem) => mem,
-                        Err(e) => {
-                            error!("Failed to build MemoryMapping from shared memory: {:#}", e);
-                            return Err(VmMemoryResponse::Err(SysError::new(EINVAL)));
-                        }
+                        Err(e) => return Err(VmMemoryResponse::Err(e.into())),
                     };
                     let mut mmap_arena = MemoryMappingArena::from(mem);
 
@@ -851,15 +862,12 @@ impl VmMemoryRequest {
                     let mut read = 0;
                     while read < num_file_mappings {
                         let len = std::cmp::min(num_file_mappings - read, base::unix::SCM_MAX_FD);
-                        let mps: Vec<VmMemoryFileMapping> = match tube.recv_with_max_fds(len) {
+                        let mps: Vec<VmMemoryFileMapping> = match tube
+                            .recv_with_max_fds(len)
+                            .with_context(|| format!("get {num_file_mappings} FDs to be mapped"))
+                        {
                             Ok(m) => m,
-                            Err(e) => {
-                                error!(
-                                    "Failed to get {num_file_mappings} FDs to be mapped: {:#}",
-                                    e
-                                );
-                                return Err(VmMemoryResponse::Err(SysError::new(EINVAL)));
-                            }
+                            Err(e) => return Err(VmMemoryResponse::Err(e.into())),
                         };
                         file_mappings.extend(mps.into_iter());
                         read += len;
@@ -872,45 +880,56 @@ impl VmMemoryRequest {
                         file_offset,
                     } in file_mappings
                     {
-                        if let Err(e) = mmap_arena.add_fd_mapping(
-                            mem_offset,
-                            length,
-                            &file,
-                            file_offset,
-                            Protection::read(),
-                        ) {
-                            error!("Failed to add fd mapping: {:#}", e);
-                            return Err(VmMemoryResponse::Err(SysError::new(EINVAL)));
+                        if let Err(e) = mmap_arena
+                            .add_fd_mapping(
+                                mem_offset,
+                                length,
+                                &file,
+                                file_offset,
+                                Protection::read(),
+                            )
+                            .context(
+                                "failed to add fd mapping when handling mmap and register memory",
+                            )
+                        {
+                            return Err(VmMemoryResponse::Err(e.into()));
                         }
                     }
                     Ok(mmap_arena)
                 };
-                let mmap_arena = match call_with_extended_max_files(callback) {
+                let mmap_arena = match call_with_extended_max_files(callback)
+                    .context("failed to set max count of file descriptors")
+                {
                     Ok(Ok(m)) => m,
                     Ok(Err(e)) => {
                         return e;
                     }
                     Err(e) => {
-                        error!("Failed to set max count of file descriptors: {e}");
-                        return VmMemoryResponse::Err(e);
+                        error!("{e:?}");
+                        return VmMemoryResponse::Err(e.into());
                     }
                 };
 
                 let size = shm.size();
-                let guest_addr = match dest.allocate(sys_allocator, size) {
+                let guest_addr = match dest.allocate(sys_allocator, size).context(
+                    "VM memory destination allocation fails when handling mmap and register memory",
+                ) {
                     Ok(addr) => addr,
-                    Err(e) => return VmMemoryResponse::Err(e),
+                    Err(e) => return VmMemoryResponse::Err(e.into()),
                 };
 
-                let slot = match vm.add_memory_region(
-                    guest_addr,
-                    Box::new(mmap_arena),
-                    true,
-                    false,
-                    MemCacheType::CacheCoherent,
-                ) {
+                let slot = match vm
+                    .add_memory_region(
+                        guest_addr,
+                        Box::new(mmap_arena),
+                        true,
+                        false,
+                        MemCacheType::CacheCoherent,
+                    )
+                    .context("failed to add memory region when handling mmap and register memory")
+                {
                     Ok(slot) => slot,
-                    Err(e) => return VmMemoryResponse::Err(e),
+                    Err(e) => return VmMemoryResponse::Err(e.into()),
                 };
 
                 let region_id = VmMemoryRegionId(guest_addr);
@@ -924,7 +943,9 @@ impl VmMemoryRequest {
             UnregisterMemory(id) => match region_state.registered_memory.remove(&id) {
                 Some(RegisteredMemory::DynamicMapping { slot }) => match vm
                     .remove_memory_region(slot)
-                {
+                    .context(
+                        "failed to remove memory region when unregistering dynamic mapping memory",
+                    ) {
                     Ok(_) => {
                         if let Some(iommu_client) = iommu_client {
                             if iommu_client.registered_memory.remove(&id) {
@@ -937,8 +958,12 @@ impl VmMemoryRequest {
                                         VirtioIOMMUVfioResult::Ok,
                                     )) => VmMemoryResponse::Ok,
                                     resp => {
-                                        error!("Unexpected message response: {:?}", resp);
-                                        VmMemoryResponse::Err(SysError::new(EINVAL))
+                                        let error = anyhow::anyhow!(
+                                            "Unexpected virtio-iommu message response when \
+                                             unregistering memory: {:?}",
+                                            resp
+                                        );
+                                        VmMemoryResponse::Err(error.into())
                                     }
                                 }
                             } else {
@@ -948,26 +973,38 @@ impl VmMemoryRequest {
                             VmMemoryResponse::Ok
                         }
                     }
-                    Err(e) => VmMemoryResponse::Err(e),
+                    Err(e) => VmMemoryResponse::Err(e.into()),
                 },
                 Some(RegisteredMemory::FixedMapping { slot, offset, size }) => {
-                    match vm.remove_mapping(slot, offset, size) {
+                    match vm.remove_mapping(slot, offset, size).context(
+                        "failed to remove memory mapping when unregistering fixed mapping memory",
+                    ) {
                         Ok(()) => VmMemoryResponse::Ok,
-                        Err(e) => VmMemoryResponse::Err(e),
+                        Err(e) => VmMemoryResponse::Err(e.into()),
                     }
                 }
-                None => VmMemoryResponse::Err(SysError::new(EINVAL)),
+                None => {
+                    let error =
+                        anyhow::anyhow!("can't find the memory region when unregistering memory");
+                    VmMemoryResponse::Err(error.into())
+                }
             },
             DynamicallyFreeMemoryRanges { ranges } => {
                 let mut r = VmMemoryResponse::Ok;
                 for (guest_address, size) in ranges {
-                    match vm.handle_balloon_event(BalloonEvent::Inflate(MemRegion {
-                        guest_address,
-                        size,
-                    })) {
+                    match vm
+                        .handle_balloon_event(BalloonEvent::Inflate(MemRegion {
+                            guest_address,
+                            size,
+                        }))
+                        .context(
+                            "failed to handle the inflate balloon event when freeing memory ranges \
+                             dynamically",
+                        ) {
                         Ok(_) => {}
                         Err(e) => {
-                            r = VmMemoryResponse::Err(e);
+                            error!("{:?}", e);
+                            r = VmMemoryResponse::Err(e.into());
                             break;
                         }
                     }
@@ -977,13 +1014,19 @@ impl VmMemoryRequest {
             DynamicallyReclaimMemoryRanges { ranges } => {
                 let mut r = VmMemoryResponse::Ok;
                 for (guest_address, size) in ranges {
-                    match vm.handle_balloon_event(BalloonEvent::Deflate(MemRegion {
-                        guest_address,
-                        size,
-                    })) {
+                    match vm
+                        .handle_balloon_event(BalloonEvent::Deflate(MemRegion {
+                            guest_address,
+                            size,
+                        }))
+                        .context(
+                            "failed to handle the deflate balloon event when reclaiming memory \
+                             ranges dynamically",
+                        ) {
                         Ok(_) => {}
                         Err(e) => {
-                            r = VmMemoryResponse::Err(e);
+                            error!("{:?}", e);
+                            r = VmMemoryResponse::Err(e.into());
                             break;
                         }
                     }
@@ -991,9 +1034,12 @@ impl VmMemoryRequest {
                 r
             }
             BalloonTargetReached { size } => {
-                match vm.handle_balloon_event(BalloonEvent::BalloonTargetReached(size)) {
+                match vm
+                    .handle_balloon_event(BalloonEvent::BalloonTargetReached(size))
+                    .context("failed to handle the target reached balloon event")
+                {
                     Ok(_) => VmMemoryResponse::Ok,
-                    Err(e) => VmMemoryResponse::Err(e),
+                    Err(e) => VmMemoryResponse::Err(e.into()),
                 }
             }
             IoEventRaw(request) => {
@@ -1003,16 +1049,18 @@ impl VmMemoryRequest {
                         IoEventAddress::Mmio(request.addr),
                         request.datamatch,
                     )
+                    .context("failed to register IO event")
                 } else {
                     vm.unregister_ioevent(
                         &request.event,
                         IoEventAddress::Mmio(request.addr),
                         request.datamatch,
                     )
+                    .context("failed to unregister IO event")
                 };
                 match res {
                     Ok(_) => VmMemoryResponse::Ok,
-                    Err(e) => VmMemoryResponse::Err(e),
+                    Err(e) => VmMemoryResponse::Err(e.into()),
                 }
             }
         }
@@ -1032,7 +1080,74 @@ pub enum VmMemoryResponse {
         slot: u32,
     },
     Ok,
-    Err(SysError),
+    Err(VmMemoryResponseError),
+}
+
+impl<T> From<Result<T>> for VmMemoryResponse {
+    fn from(r: Result<T>) -> Self {
+        match r {
+            Ok(_) => VmMemoryResponse::Ok,
+            Err(e) => VmMemoryResponse::Err(anyhow::Error::new(e).into()),
+        }
+    }
+}
+
+#[derive(Debug, thiserror::Error)]
+#[error("Vm memory response error: {0}")]
+pub struct VmMemoryResponseError(#[from] pub anyhow::Error);
+
+impl TryFrom<FlatVmMemoryResponseError> for VmMemoryResponseError {
+    type Error = anyhow::Error;
+    fn try_from(value: FlatVmMemoryResponseError) -> StdResult<Self, Self::Error> {
+        let inner = value
+            .0
+            .into_iter()
+            .fold(
+                None,
+                |error: Option<anyhow::Error>, current_context| match error {
+                    Some(error) => Some(error.context(current_context)),
+                    None => Some(anyhow::Error::msg(current_context)),
+                },
+            )
+            .context("should carry at least one error")?;
+        Ok(Self(inner))
+    }
+}
+
+impl Serialize for VmMemoryResponseError {
+    fn serialize<S>(&self, serializer: S) -> StdResult<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        let flat: FlatVmMemoryResponseError = self.into();
+        flat.serialize(serializer)
+    }
+}
+
+impl<'de> Deserialize<'de> for VmMemoryResponseError {
+    fn deserialize<D>(deserializer: D) -> StdResult<Self, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        let flat = FlatVmMemoryResponseError::deserialize(deserializer)?;
+        flat.try_into()
+            .map_err(|e: anyhow::Error| D::Error::custom(e.to_string()))
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+struct FlatVmMemoryResponseError(Vec<String>);
+
+impl From<&VmMemoryResponseError> for FlatVmMemoryResponseError {
+    fn from(value: &VmMemoryResponseError) -> Self {
+        let contexts = value
+            .0
+            .chain()
+            .map(ToString::to_string)
+            .rev()
+            .collect::<Vec<_>>();
+        Self(contexts)
+    }
 }
 
 #[derive(Serialize, Deserialize, Debug)]
@@ -2285,18 +2400,18 @@ fn do_snapshot(
     let _vcpu_guard = VcpuSuspendGuard::new(&kick_vcpus, vcpu_size)?;
     let _device_guard = DeviceSleepGuard::new(device_control_tube)?;
 
-    // We want to flush all pending IRQs to the LAPICs. There are two cases:
+    // We want to flush all pending IRQs to the interrupt controller. There are two cases:
     //
-    // MSIs: these are directly delivered to the LAPIC. We must verify the handler
-    // thread cycles once to deliver these interrupts.
+    // MSIs: these are directly delivered to the interrupt controller.
+    // We must verify the handler thread cycles once to deliver these interrupts.
     //
     // Legacy interrupts: in the case of a split IRQ chip, these interrupts may
     // flow through the userspace IOAPIC. If the hypervisor does not support
     // irqfds (e.g. WHPX), a single iteration will only flush the IRQ to the
     // IOAPIC. The underlying MSI will be asserted at this point, but if the
     // IRQ handler doesn't run another iteration, it won't be delivered to the
-    // LAPIC. This is why we cycle the handler thread twice (doing so ensures we
-    // process the underlying MSI).
+    // interrupt controller. This is why we cycle the handler thread twice (doing so
+    // ensures we process the underlying MSI).
     //
     // We can handle both of these cases by iterating until there are no tokens
     // serviced on the requested iteration. Note that in the legacy case, this
@@ -2305,29 +2420,34 @@ fn do_snapshot(
     // Note: within CrosVM, *all* interrupts are eventually converted into the
     // same mechanicism that MSIs use. This is why we say "underlying" MSI for
     // a legacy IRQ.
-    let mut flush_attempts = 0;
-    loop {
-        irq_handler_control
-            .send(&IrqHandlerRequest::WakeAndNotifyIteration)
-            .context("failed to send flush command to IRQ handler thread")?;
-        let resp = irq_handler_control
-            .recv()
-            .context("failed to recv flush response from IRQ handler thread")?;
-        match resp {
-            IrqHandlerResponse::HandlerIterationComplete(tokens_serviced) => {
-                if tokens_serviced == 0 {
-                    break;
+    {
+        let mut flush_attempts = 0;
+        loop {
+            irq_handler_control
+                .send(&IrqHandlerRequest::WakeAndNotifyIteration)
+                .context("failed to send flush command to IRQ handler thread")?;
+            let resp = irq_handler_control
+                .recv()
+                .context("failed to recv flush response from IRQ handler thread")?;
+            match resp {
+                IrqHandlerResponse::HandlerIterationComplete(tokens_serviced) => {
+                    if tokens_serviced == 0 {
+                        break;
+                    }
                 }
+                _ => bail!("received unexpected reply from IRQ handler: {:?}", resp),
+            }
+            flush_attempts += 1;
+            if flush_attempts > EXPECTED_MAX_IRQ_FLUSH_ITERATIONS {
+                warn!(
+                    "flushing IRQs for snapshot may be stalled after iteration {}, expected <= {}
+                      iterations",
+                    flush_attempts, EXPECTED_MAX_IRQ_FLUSH_ITERATIONS
+                );
             }
-            _ => bail!("received unexpected reply from IRQ handler: {:?}", resp),
-        }
-        flush_attempts += 1;
-        if flush_attempts > EXPECTED_MAX_IRQ_FLUSH_ITERATIONS {
-            warn!("flushing IRQs for snapshot may be stalled after iteration {}, expected <= {} iterations", flush_attempts, EXPECTED_MAX_IRQ_FLUSH_ITERATIONS);
         }
+        info!("flushed IRQs in {} iterations", flush_attempts);
     }
-    info!("flushed IRQs in {} iterations", flush_attempts);
-
     let snapshot_writer = SnapshotWriter::new(snapshot_path, encrypt)?;
 
     // Snapshot hypervisor's paravirtualized clock.
@@ -2357,13 +2477,42 @@ fn do_snapshot(
         .context("Failed to write irqchip state")?;
     info!("Snapshotted irqchip.");
 
+    // Snapshot memory
+    {
+        let mem_snap_start = Instant::now();
+        // Use 64MB chunks when writing the memory snapshot (if encryption is used).
+        const MEMORY_SNAP_ENCRYPTED_CHUNK_SIZE_BYTES: usize = 1024 * 1024 * 64;
+        // SAFETY:
+        // VM & devices are stopped.
+        let guest_memory_metadata = unsafe {
+            vm.get_memory()
+                .snapshot(
+                    &mut snapshot_writer.raw_fragment_with_chunk_size(
+                        "mem",
+                        MEMORY_SNAP_ENCRYPTED_CHUNK_SIZE_BYTES,
+                    )?,
+                    compress_memory,
+                )
+                .context("failed to snapshot memory")?
+        };
+        snapshot_writer.write_fragment("mem_metadata", &guest_memory_metadata)?;
+
+        let mem_snap_duration_ms = mem_snap_start.elapsed().as_millis();
+        info!(
+            "snapshot: memory snapshotted {}MB in {}ms",
+            vm.get_memory().memory_size() / 1024 / 1024,
+            mem_snap_duration_ms
+        );
+        metrics::log_metric_with_details(
+            metrics::MetricEventType::SnapshotSaveMemoryLatency,
+            mem_snap_duration_ms as i64,
+            &metrics_events::RecordDetails {},
+        );
+    }
     // Snapshot devices
     info!("Devices snapshotting...");
     device_control_tube
-        .send(&DeviceControlCommand::SnapshotDevices {
-            snapshot_writer,
-            compress_memory,
-        })
+        .send(&DeviceControlCommand::SnapshotDevices { snapshot_writer })
         .context("send command to devices control socket")?;
     let resp: VmResponse = device_control_tube
         .recv()
@@ -2450,10 +2599,36 @@ pub fn do_restore(
             .context("Failed to restore vcpu")?;
     }
 
+    // Restore Memory
+    {
+        let mem_restore_start = Instant::now();
+        let guest_memory_metadata = snapshot_reader.read_fragment("mem_metadata")?;
+        // SAFETY:
+        // VM & devices are stopped.
+        unsafe {
+            vm.get_memory().restore(
+                guest_memory_metadata,
+                &mut snapshot_reader.raw_fragment("mem")?,
+            )?
+        };
+        let mem_restore_duration_ms = mem_restore_start.elapsed().as_millis();
+        info!(
+            "snapshot: memory restored {}MB in {}ms",
+            vm.get_memory().memory_size() / 1024 / 1024,
+            mem_restore_duration_ms
+        );
+        metrics::log_metric_with_details(
+            metrics::MetricEventType::SnapshotRestoreMemoryLatency,
+            mem_restore_duration_ms as i64,
+            &metrics_events::RecordDetails {},
+        );
+    }
     // Restore devices
     device_control_tube
-        .send(&DeviceControlCommand::RestoreDevices { snapshot_reader })
-        .context("send command to devices control socket")?;
+        .send(&DeviceControlCommand::RestoreDevices {
+            snapshot_reader: snapshot_reader.clone(),
+        })
+        .context("send restore devices command to devices control socket")?;
     let resp: VmResponse = device_control_tube
         .recv()
         .context("receive from devices control socket")?;
@@ -2461,17 +2636,20 @@ pub fn do_restore(
         bail!("unexpected RestoreDevices response: {resp}");
     }
 
-    irq_handler_control
-        .send(&IrqHandlerRequest::RefreshIrqEventTokens)
-        .context("failed to send refresh irq event token command to IRQ handler thread")?;
-    let resp: IrqHandlerResponse = irq_handler_control
-        .recv()
-        .context("failed to recv refresh response from IRQ handler thread")?;
-    if !matches!(resp, IrqHandlerResponse::IrqEventTokenRefreshComplete) {
-        bail!(
-            "received unexpected reply from IRQ handler thread: {:?}",
-            resp
-        );
+    // refresh the IRQ tokens.
+    {
+        irq_handler_control
+            .send(&IrqHandlerRequest::RefreshIrqEventTokens)
+            .context("failed to send refresh irq event token command to IRQ handler thread")?;
+        let resp: IrqHandlerResponse = irq_handler_control
+            .recv()
+            .context("failed to recv refresh response from IRQ handler thread")?;
+        if !matches!(resp, IrqHandlerResponse::IrqEventTokenRefreshComplete) {
+            bail!(
+                "received unexpected reply from IRQ handler thread: {:?}",
+                resp
+            );
+        }
     }
 
     let restore_duration_ms = restore_start.elapsed().as_millis();
@@ -2480,6 +2658,7 @@ pub fn do_restore(
         restore_duration_ms,
         vm.get_memory().memory_size(),
     );
+
     metrics::log_metric_with_details(
         metrics::MetricEventType::SnapshotRestoreOverallLatency,
         restore_duration_ms as i64,
@@ -2736,3 +2915,35 @@ pub fn virtio_iommu_request(
     };
     Ok(response)
 }
+
+#[cfg(test)]
+mod tests {
+    use anyhow::anyhow;
+
+    use super::*;
+
+    #[test]
+    fn vm_memory_response_error_should_serialize_and_deserialize_correctly() {
+        let source_error: VmMemoryResponseError = anyhow!("root cause")
+            .context("context 1")
+            .context("context 2")
+            .into();
+        let serialized_bytes =
+            serde_json::to_vec(&source_error).expect("should serialize to json successfully");
+        let target_error = serde_json::from_slice::<VmMemoryResponseError>(&serialized_bytes)
+            .expect("should deserialize from json successfully");
+        assert_eq!(
+            format!("{:?}", source_error.0),
+            format!("{:?}", target_error.0)
+        );
+    }
+
+    #[test]
+    fn vm_memory_response_error_deserialization_should_handle_malformat_correctly() {
+        let flat_source = FlatVmMemoryResponseError(vec![]);
+        let serialized_bytes =
+            serde_json::to_vec(&flat_source).expect("should serialize to json successfully");
+        serde_json::from_slice::<VmMemoryResponseError>(&serialized_bytes)
+            .expect_err("deserialize with 0 error messages should fail");
+    }
+}
diff --git a/vm_control/src/sys/linux.rs b/vm_control/src/sys/linux.rs
index 7eb97ba0d..676a18d4a 100644
--- a/vm_control/src/sys/linux.rs
+++ b/vm_control/src/sys/linux.rs
@@ -6,6 +6,7 @@
 pub(crate) mod gpu;
 
 use std::path::Path;
+use std::sync::LazyLock;
 use std::time::Duration;
 
 use base::error;
@@ -23,7 +24,6 @@ use hypervisor::MemSlot;
 use hypervisor::Vm;
 use libc::EINVAL;
 use libc::ERANGE;
-use once_cell::sync::Lazy;
 use resources::Alloc;
 use resources::SystemAllocator;
 use serde::Deserialize;
@@ -222,7 +222,7 @@ pub fn prepare_shared_memory_region(
     }
 }
 
-static SHOULD_PREPARE_MEMORY_REGION: Lazy<bool> = Lazy::new(|| {
+static SHOULD_PREPARE_MEMORY_REGION: LazyLock<bool> = LazyLock::new(|| {
     if cfg!(target_arch = "x86_64") {
         // The legacy x86 MMU allocates an rmap and a page tracking array
         // that take 2.5MiB per 1GiB of user memory region address space,
diff --git a/vm_memory/Cargo.toml b/vm_memory/Cargo.toml
index 5e1f9be5d..a5aea99a7 100644
--- a/vm_memory/Cargo.toml
+++ b/vm_memory/Cargo.toml
@@ -6,20 +6,20 @@ edition = "2021"
 include = ["src/**/*", "Cargo.toml"]
 
 [dependencies]
-anyhow = "1"
-cfg-if = "1.0.0"
-cros_async = { path = "../cros_async" }
-data_model = { path = "../common/data_model" }
-libc = "0.2"
+anyhow = { workspace = true }
+cfg-if = { workspace = true }
+cros_async = { workspace = true }
+data_model = { workspace = true }
+libc = { workspace = true }
 lz4_flex = "0.11"
-base = { path = "../base" }
+base = { workspace = true }
 bitflags = "2.2.1"
-remain = "0.2"
-serde = { version = "1", features = [ "derive" ] }
-serde_json = "1"
-serde_keyvalue = { path = "../serde_keyvalue", features = ["argh_derive"] }
+remain = { workspace = true }
+serde = { workspace = true, features = [ "derive" ] }
+serde_json = { workspace = true }
+serde_keyvalue = { workspace = true, features = ["argh_derive"] }
 snapshot = { workspace = true }
-thiserror = "1"
+thiserror = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [dev-dependencies]
diff --git a/vm_memory/bindgen.sh b/vm_memory/bindgen.sh
index e3208bca1..e6723f532 100755
--- a/vm_memory/bindgen.sh
+++ b/vm_memory/bindgen.sh
@@ -13,6 +13,6 @@ source tools/impl/bindgen-common.sh
 bindgen_generate \
     --allowlist-type='udmabuf_.*' \
     --allowlist-var="UDMABUF_.*" \
-    "${BINDGEN_LINUX}/include/uapi/linux/udmabuf.h" \
+    "${BINDGEN_LINUX_X86_HEADERS}/include/linux/udmabuf.h" \
     | replace_linux_int_types | rustfmt \
     > vm_memory/src/udmabuf_bindings.rs
diff --git a/vm_memory/src/guest_memory.rs b/vm_memory/src/guest_memory.rs
index f469b925a..fdf785547 100644
--- a/vm_memory/src/guest_memory.rs
+++ b/vm_memory/src/guest_memory.rs
@@ -73,6 +73,8 @@ pub enum Error {
     MemoryRegionOverlap,
     #[error("memory region size {0} is too large")]
     MemoryRegionTooLarge(u128),
+    #[error("punch hole failed {0}")]
+    PunchHole(#[source] base::Error),
     #[error("incomplete read of {completed} instead of {expected} bytes")]
     ShortRead { expected: usize, completed: usize },
     #[error("incomplete write of {completed} instead of {expected} bytes")]
@@ -276,6 +278,7 @@ impl MemoryRegion {
 pub struct GuestMemory {
     regions: Arc<[MemoryRegion]>,
     locked: bool,
+    use_dontneed_locked: bool,
 }
 
 impl AsRawDescriptors for GuestMemory {
@@ -384,6 +387,7 @@ impl GuestMemory {
         Ok(GuestMemory {
             regions: Arc::from(regions),
             locked: false,
+            use_dontneed_locked: false,
         })
     }
 
@@ -425,6 +429,7 @@ impl GuestMemory {
         Ok(GuestMemory {
             regions: Arc::from(regions),
             locked: false,
+            use_dontneed_locked: false,
         })
     }
 
@@ -433,6 +438,11 @@ impl GuestMemory {
         self.locked
     }
 
+    // Whether `MemoryPolicy::USE_DONTNEED_LOCKED` was set.
+    pub fn use_dontneed_locked(&self) -> bool {
+        self.use_dontneed_locked
+    }
+
     /// Returns the end address of memory.
     ///
     /// # Examples
@@ -454,14 +464,6 @@ impl GuestMemory {
             .map_or(GuestAddress(0), MemoryRegion::end)
     }
 
-    /// Returns the guest addresses and sizes of the memory regions.
-    pub fn guest_memory_regions(&self) -> Vec<(GuestAddress, usize)> {
-        self.regions
-            .iter()
-            .map(|region| (region.guest_base, region.mapping.size()))
-            .collect()
-    }
-
     /// Returns the total size of memory in bytes.
     pub fn memory_size(&self) -> u64 {
         self.regions
diff --git a/vm_memory/src/guest_memory/sys/linux.rs b/vm_memory/src/guest_memory/sys/linux.rs
index 3845c94cc..6c6f661d3 100644
--- a/vm_memory/src/guest_memory/sys/linux.rs
+++ b/vm_memory/src/guest_memory/sys/linux.rs
@@ -23,6 +23,7 @@ bitflags! {
     pub struct MemoryPolicy: u32 {
         const USE_HUGEPAGES = 1;
         const LOCK_GUEST_MEMORY = (1 << 1);
+        const USE_DONTNEED_LOCKED = (1 << 2);
     }
 }
 
@@ -50,6 +51,34 @@ impl GuestMemory {
             .map_err(|e| Error::MemoryAccess(addr, e))
     }
 
+    /// Madvise away the address range in the host that is associated with the given guest range.
+    ///
+    /// This feature is only available on Unix, where a MemoryMapping can remove a mapped range.
+    ///
+    /// Requires a 5.18+ kernel.
+    pub fn dontneed_locked_range(&self, addr: GuestAddress, count: u64) -> Result<()> {
+        let (mapping, offset, _) = self.find_region(addr)?;
+        mapping
+            .dontneed_locked_range(offset, count as usize)
+            .map_err(|e| Error::MemoryAccess(addr, e))
+    }
+
+    /// Punch a hole in the backing file that is associated with the given guest range.
+    pub fn punch_hole_range(&self, addr: GuestAddress, count: u64) -> Result<()> {
+        let region = self
+            .regions
+            .iter()
+            .find(|region| region.contains(addr))
+            .ok_or(Error::InvalidGuestAddress(addr))?;
+        base::sys::linux::fallocate(
+            &region.shared_obj,
+            base::sys::linux::FallocateMode::PunchHole,
+            region.obj_offset + addr.offset_from(region.guest_base),
+            count,
+        )
+        .map_err(Error::PunchHole)
+    }
+
     /// Handles guest memory policy hints/advices.
     pub fn set_memory_policy(&mut self, mem_policy: MemoryPolicy) {
         if mem_policy.is_empty() {
@@ -79,6 +108,10 @@ impl GuestMemory {
                     println!("Failed to lock memory for mapping {}", err);
                 }
             }
+
+            if mem_policy.contains(MemoryPolicy::USE_DONTNEED_LOCKED) {
+                self.use_dontneed_locked = true;
+            }
         }
     }
 
diff --git a/win_audio/Cargo.toml b/win_audio/Cargo.toml
index 291520235..8bee5b77d 100644
--- a/win_audio/Cargo.toml
+++ b/win_audio/Cargo.toml
@@ -6,20 +6,19 @@ edition = "2021"
 
 [target.'cfg(windows)'.dependencies]
 async-trait = "0.1.36"
-audio_streams = { path = "../common/audio_streams"}
-audio_util = { path = "../audio_util" }
-base = { path = "../base" }
-cros_async = { path = "../cros_async" }
-libc = "0.2"
+audio_streams = { workspace = true }
+audio_util = { workspace = true }
+base = { workspace = true }
+cros_async = { workspace = true }
+libc = { workspace = true }
 win_util = { path = "../win_util" }
 winapi = "0.3"
 wio = "0.2"
-sync = { path = "../common/sync" }
-thiserror = "1"
-metrics = { path = "../metrics"}
-once_cell = "1.7.2"
+sync = { workspace = true }
+thiserror = { workspace = true }
+metrics = { workspace = true }
 
 [build-dependencies]
-anyhow = "1"
-prebuilts = { path = "../prebuilts" }
+anyhow = { workspace = true }
+prebuilts = { workspace = true }
 
diff --git a/win_util/Cargo.toml b/win_util/Cargo.toml
index 55452749e..d33b83ac5 100644
--- a/win_util/Cargo.toml
+++ b/win_util/Cargo.toml
@@ -5,11 +5,13 @@ authors = ["The ChromiumOS Authors"]
 edition = "2021"
 
 [dependencies]
-anyhow = "1"
-enumn = "0.1.0"
-libc = "0.2"
-once_cell = "1.7"
-serde = { version = "1", features = [ "derive" ] }
+anyhow = { workspace = true }
+enumn = { workspace = true }
+libc = { workspace = true }
+# Note most crates in this project use re-exported log macros from base, but
+# as this crate is a base dependency, we use log directly
+log = "0.4"
+serde = { workspace = true, features = [ "derive" ] }
 zeroize = "1.5.7"
 
 [target.'cfg(windows)'.dependencies]
diff --git a/win_util/src/dll_notification.rs b/win_util/src/dll_notification.rs
deleted file mode 100644
index 40677bbda..000000000
--- a/win_util/src/dll_notification.rs
+++ /dev/null
@@ -1,451 +0,0 @@
-// Copyright 2022 The ChromiumOS Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-use std::ffi::c_void;
-use std::ffi::OsString;
-use std::io;
-use std::ptr;
-
-use winapi::shared::minwindef::ULONG;
-use winapi::um::winnt::PVOID;
-
-use super::unicode_string_to_os_string;
-
-// Required for Windows API FFI bindings, as the names of the FFI structs and
-// functions get called out by the linter.
-#[allow(non_upper_case_globals)]
-#[allow(non_camel_case_types)]
-#[allow(non_snake_case)]
-#[allow(dead_code)]
-mod dll_notification_sys {
-    use std::io;
-
-    use winapi::shared::minwindef::ULONG;
-    use winapi::shared::ntdef::NTSTATUS;
-    use winapi::shared::ntdef::PCUNICODE_STRING;
-    use winapi::shared::ntstatus::STATUS_SUCCESS;
-    use winapi::um::libloaderapi::GetModuleHandleA;
-    use winapi::um::libloaderapi::GetProcAddress;
-    use winapi::um::winnt::CHAR;
-    use winapi::um::winnt::PVOID;
-
-    #[repr(C)]
-    pub union _LDR_DLL_NOTIFICATION_DATA {
-        pub Loaded: LDR_DLL_LOADED_NOTIFICATION_DATA,
-        pub Unloaded: LDR_DLL_UNLOADED_NOTIFICATION_DATA,
-    }
-    pub type LDR_DLL_NOTIFICATION_DATA = _LDR_DLL_NOTIFICATION_DATA;
-    pub type PLDR_DLL_NOTIFICATION_DATA = *mut LDR_DLL_NOTIFICATION_DATA;
-
-    #[repr(C)]
-    #[derive(Debug, Copy, Clone)]
-    pub struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
-        pub Flags: ULONG,                  // Reserved.
-        pub FullDllName: PCUNICODE_STRING, // The full path name of the DLL module.
-        pub BaseDllName: PCUNICODE_STRING, // The base file name of the DLL module.
-        pub DllBase: PVOID,                // A pointer to the base address for the DLL in memory.
-        pub SizeOfImage: ULONG,            // The size of the DLL image, in bytes.
-    }
-    pub type LDR_DLL_LOADED_NOTIFICATION_DATA = _LDR_DLL_LOADED_NOTIFICATION_DATA;
-    pub type PLDR_DLL_LOADED_NOTIFICATION_DATA = *mut LDR_DLL_LOADED_NOTIFICATION_DATA;
-
-    #[repr(C)]
-    #[derive(Debug, Copy, Clone)]
-    pub struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
-        pub Flags: ULONG,                  // Reserved.
-        pub FullDllName: PCUNICODE_STRING, // The full path name of the DLL module.
-        pub BaseDllName: PCUNICODE_STRING, // The base file name of the DLL module.
-        pub DllBase: PVOID,                // A pointer to the base address for the DLL in memory.
-        pub SizeOfImage: ULONG,            // The size of the DLL image, in bytes.
-    }
-    pub type LDR_DLL_UNLOADED_NOTIFICATION_DATA = _LDR_DLL_UNLOADED_NOTIFICATION_DATA;
-    pub type PLDR_DLL_UNLOADED_NOTIFICATION_DATA = *mut LDR_DLL_UNLOADED_NOTIFICATION_DATA;
-
-    pub const LDR_DLL_NOTIFICATION_REASON_LOADED: ULONG = 1;
-    pub const LDR_DLL_NOTIFICATION_REASON_UNLOADED: ULONG = 2;
-
-    const NTDLL: &[u8] = b"ntdll\0";
-    const LDR_REGISTER_DLL_NOTIFICATION: &[u8] = b"LdrRegisterDllNotification\0";
-    const LDR_UNREGISTER_DLL_NOTIFICATION: &[u8] = b"LdrUnregisterDllNotification\0";
-
-    pub type LdrDllNotification = unsafe extern "C" fn(
-        NotificationReason: ULONG,
-        NotificationData: PLDR_DLL_NOTIFICATION_DATA,
-        Context: PVOID,
-    );
-
-    pub type FnLdrRegisterDllNotification =
-        unsafe extern "C" fn(ULONG, LdrDllNotification, PVOID, *mut PVOID) -> NTSTATUS;
-    pub type FnLdrUnregisterDllNotification = unsafe extern "C" fn(PVOID) -> NTSTATUS;
-
-    extern "C" {
-        pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
-    }
-
-    /// Wrapper for the NTDLL `LdrRegisterDllNotification` function. Dynamically
-    /// gets the address of the function and invokes the function with the given
-    /// arguments.
-    ///
-    /// # Safety
-    /// Unsafe as this function does not verify its arguments; the caller is
-    /// expected to verify the safety as if invoking the underlying C function.
-    pub unsafe fn LdrRegisterDllNotification(
-        Flags: ULONG,
-        NotificationFunction: LdrDllNotification,
-        Context: PVOID,
-        Cookie: *mut PVOID,
-    ) -> io::Result<()> {
-        let proc_addr = GetProcAddress(
-            /* hModule= */
-            GetModuleHandleA(/* lpModuleName= */ NTDLL.as_ptr() as *const CHAR),
-            /* lpProcName= */
-            LDR_REGISTER_DLL_NOTIFICATION.as_ptr() as *const CHAR,
-        );
-        if proc_addr.is_null() {
-            return Err(std::io::Error::last_os_error());
-        }
-        let ldr_register_dll_notification: FnLdrRegisterDllNotification =
-            std::mem::transmute(proc_addr);
-        let ret = ldr_register_dll_notification(Flags, NotificationFunction, Context, Cookie);
-        if ret != STATUS_SUCCESS {
-            return Err(io::Error::from_raw_os_error(
-                RtlNtStatusToDosError(/* Status= */ ret) as i32,
-            ));
-        };
-        Ok(())
-    }
-
-    /// Wrapper for the NTDLL `LdrUnregisterDllNotification` function. Dynamically
-    /// gets the address of the function and invokes the function with the given
-    /// arguments.
-    ///
-    /// # Safety
-    /// Unsafe as this function does not verify its arguments; the caller is
-    /// expected to verify the safety as if invoking the underlying C function.
-    pub unsafe fn LdrUnregisterDllNotification(Cookie: PVOID) -> io::Result<()> {
-        let proc_addr = GetProcAddress(
-            /* hModule= */
-            GetModuleHandleA(/* lpModuleName= */ NTDLL.as_ptr() as *const CHAR),
-            /* lpProcName= */
-            LDR_UNREGISTER_DLL_NOTIFICATION.as_ptr() as *const CHAR,
-        );
-        if proc_addr.is_null() {
-            return Err(std::io::Error::last_os_error());
-        }
-        let ldr_unregister_dll_notification: FnLdrUnregisterDllNotification =
-            std::mem::transmute(proc_addr);
-        let ret = ldr_unregister_dll_notification(Cookie);
-        if ret != STATUS_SUCCESS {
-            return Err(io::Error::from_raw_os_error(
-                RtlNtStatusToDosError(/* Status= */ ret) as i32,
-            ));
-        };
-        Ok(())
-    }
-}
-
-use dll_notification_sys::*;
-
-#[derive(Debug)]
-pub struct DllNotificationData {
-    pub full_dll_name: OsString,
-    pub base_dll_name: OsString,
-}
-
-/// Callback context wrapper for DLL load notification functions.
-///
-/// This struct provides a wrapper for invoking a function-like type any time a
-/// DLL is loaded in the current process. This is done in a type-safe way,
-/// provided that users of this struct observe some safety invariants.
-///
-/// # Safety
-/// The struct instance must not be used once it has been registered as a
-/// notification target. The callback function assumes that it has a mutable
-/// reference to the struct instance. Only once the callback is unregistered is
-/// it safe to re-use the struct instance.
-struct CallbackContext<F1, F2>
-where
-    F1: FnMut(DllNotificationData),
-    F2: FnMut(DllNotificationData),
-{
-    loaded_callback: F1,
-    unloaded_callback: F2,
-}
-
-impl<F1, F2> CallbackContext<F1, F2>
-where
-    F1: FnMut(DllNotificationData),
-    F2: FnMut(DllNotificationData),
-{
-    /// Create a new `CallbackContext` with the two callback functions. Takes
-    /// two callbacks, a `loaded_callback` which is called when a DLL is
-    /// loaded, and `unloaded_callback` which is called when a DLL is unloaded.
-    pub fn new(loaded_callback: F1, unloaded_callback: F2) -> Self {
-        CallbackContext {
-            loaded_callback,
-            unloaded_callback,
-        }
-    }
-
-    /// Provides a notification function that can be passed to the
-    /// `LdrRegisterDllNotification` function.
-    pub fn get_notification_function(&self) -> LdrDllNotification {
-        Self::notification_function
-    }
-
-    /// A notification function with C linkage. This function assumes that it
-    /// has exclusive access to the instance of the struct passed through the
-    /// `context` parameter.
-    extern "C" fn notification_function(
-        notification_reason: ULONG,
-        notification_data: PLDR_DLL_NOTIFICATION_DATA,
-        context: PVOID,
-    ) {
-        let callback_context =
-            // SAFETY: The DLLWatcher guarantees that the CallbackContext instance is not null and
-            // that we have exclusive access to it.
-            unsafe { (context as *mut Self).as_mut() }.expect("context was null");
-
-        assert!(!notification_data.is_null());
-
-        match notification_reason {
-            LDR_DLL_NOTIFICATION_REASON_LOADED => {
-                // SAFETY: We know that the LDR_DLL_NOTIFICATION_DATA union contains the
-                // LDR_DLL_LOADED_NOTIFICATION_DATA because we got
-                // LDR_DLL_NOTIFICATION_REASON_LOADED as the notification reason.
-                let loaded = unsafe { &mut (*notification_data).Loaded };
-
-                assert!(!loaded.BaseDllName.is_null());
-
-                // SAFETY: We assert that the pointer is not null and expect that the OS has
-                // provided a valid UNICODE_STRING struct.
-                let base_dll_name = unsafe { unicode_string_to_os_string(&*loaded.BaseDllName) };
-
-                assert!(!loaded.FullDllName.is_null());
-
-                // SAFETY: We assert that the pointer is not null and expect that the OS has
-                // provided a valid UNICODE_STRING struct.
-                let full_dll_name = unsafe { unicode_string_to_os_string(&*loaded.FullDllName) };
-
-                (callback_context.loaded_callback)(DllNotificationData {
-                    base_dll_name,
-                    full_dll_name,
-                });
-            }
-            LDR_DLL_NOTIFICATION_REASON_UNLOADED => {
-                // SAFETY: We know that the LDR_DLL_NOTIFICATION_DATA union contains the
-                // LDR_DLL_UNLOADED_NOTIFICATION_DATA because we got
-                // LDR_DLL_NOTIFICATION_REASON_UNLOADED as the notification reason.
-                let unloaded = unsafe { &mut (*notification_data).Unloaded };
-
-                assert!(!unloaded.BaseDllName.is_null());
-
-                // SAFETY: We assert that the pointer is not null and expect that the OS has
-                // provided a valid UNICODE_STRING struct.
-                let base_dll_name = unsafe { unicode_string_to_os_string(&*unloaded.BaseDllName) };
-
-                assert!(!unloaded.FullDllName.is_null());
-
-                // SAFETY: We assert that the pointer is not null and expect that the OS has
-                // provided a valid UNICODE_STRING struct.
-                let full_dll_name = unsafe { unicode_string_to_os_string(&*unloaded.FullDllName) };
-
-                (callback_context.unloaded_callback)(DllNotificationData {
-                    base_dll_name,
-                    full_dll_name,
-                })
-            }
-            n => panic!("invalid value \"{}\" for dll notification reason", n),
-        }
-    }
-}
-
-/// DLL watcher for monitoring DLL loads/unloads.
-///
-/// Provides a method to invoke a function-like type any time a DLL
-/// is loaded or unloaded in the current process.
-pub struct DllWatcher<F1, F2>
-where
-    F1: FnMut(DllNotificationData),
-    F2: FnMut(DllNotificationData),
-{
-    context: Box<CallbackContext<F1, F2>>,
-    cookie: Option<ptr::NonNull<c_void>>,
-}
-
-impl<F1, F2> DllWatcher<F1, F2>
-where
-    F1: FnMut(DllNotificationData),
-    F2: FnMut(DllNotificationData),
-{
-    /// Create a new `DllWatcher` with the two callback functions. Takes two
-    /// callbacks, a `loaded_callback` which is called when a DLL is loaded,
-    /// and `unloaded_callback` which is called when a DLL is unloaded.
-    pub fn new(loaded_callback: F1, unloaded_callback: F2) -> io::Result<Self> {
-        let mut watcher = Self {
-            context: Box::new(CallbackContext::new(loaded_callback, unloaded_callback)),
-            cookie: None,
-        };
-        let mut cookie: PVOID = ptr::null_mut();
-        // SAFETY: We guarantee that the notification function that we register will have exclusive
-        // access to the context.
-        unsafe {
-            LdrRegisterDllNotification(
-                /* Flags= */ 0,
-                /* NotificationFunction= */ watcher.context.get_notification_function(),
-                /* Context= */
-                &mut *watcher.context as *mut CallbackContext<F1, F2> as PVOID,
-                /* Cookie= */ &mut cookie as *mut PVOID,
-            )?
-        };
-        watcher.cookie = ptr::NonNull::new(cookie);
-        Ok(watcher)
-    }
-
-    fn unregister_dll_notification(&mut self) -> io::Result<()> {
-        if let Some(c) = self.cookie.take() {
-            // SAFETY: We guarantee that `Cookie` was previously initialized.
-            unsafe {
-                LdrUnregisterDllNotification(/* Cookie= */ c.as_ptr() as PVOID)?
-            }
-        }
-
-        Ok(())
-    }
-}
-
-impl<F1, F2> Drop for DllWatcher<F1, F2>
-where
-    F1: FnMut(DllNotificationData),
-    F2: FnMut(DllNotificationData),
-{
-    fn drop(&mut self) {
-        self.unregister_dll_notification()
-            .expect("error unregistering dll notification");
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use std::collections::HashSet;
-    use std::ffi::CString;
-    use std::io;
-
-    use winapi::shared::minwindef::FALSE;
-    use winapi::shared::minwindef::TRUE;
-    use winapi::um::handleapi::CloseHandle;
-    use winapi::um::libloaderapi::FreeLibrary;
-    use winapi::um::libloaderapi::LoadLibraryA;
-    use winapi::um::synchapi::CreateEventA;
-    use winapi::um::synchapi::SetEvent;
-    use winapi::um::synchapi::WaitForSingleObject;
-    use winapi::um::winbase::WAIT_OBJECT_0;
-
-    use super::*;
-
-    // Arbitrarily chosen DLLs for load/unload test. Chosen because they're
-    // hopefully esoteric enough that they're probably not already loaded in
-    // the process so we can test load/unload notifications.
-    //
-    // Using a single DLL can lead to flakiness; since the tests are run in the
-    // same process, it can be hard to rely on the OS to clean up the DLL loaded
-    // by one test before the other test runs. Using a different DLL makes the
-    // tests more independent.
-    const TEST_DLL_NAME_1: &str = "Imagehlp.dll";
-    const TEST_DLL_NAME_2: &str = "dbghelp.dll";
-
-    #[test]
-    fn load_dll() {
-        let test_dll_name = CString::new(TEST_DLL_NAME_1).expect("failed to create CString");
-        let mut loaded_dlls: HashSet<OsString> = HashSet::new();
-        let h_module = {
-            let _watcher = DllWatcher::new(
-                |data| {
-                    loaded_dlls.insert(data.base_dll_name);
-                },
-                |_data| (),
-            )
-            .expect("failed to create DllWatcher");
-            // SAFETY: We pass a valid C string in to the function.
-            unsafe { LoadLibraryA(test_dll_name.as_ptr()) }
-        };
-        assert!(
-            !h_module.is_null(),
-            "failed to load {}: {}",
-            TEST_DLL_NAME_1,
-            io::Error::last_os_error()
-        );
-        assert!(
-            !loaded_dlls.is_empty(),
-            "no DLL loads recorded by DLL watcher"
-        );
-        assert!(
-            loaded_dlls.contains::<OsString>(&(TEST_DLL_NAME_1.to_owned().into())),
-            "{} load wasn't recorded by DLL watcher",
-            TEST_DLL_NAME_1
-        );
-        // SAFETY: We initialized h_module with a LoadLibraryA call.
-        let success = unsafe { FreeLibrary(h_module) } > 0;
-        assert!(
-            success,
-            "failed to free {}: {}",
-            TEST_DLL_NAME_1,
-            io::Error::last_os_error(),
-        )
-    }
-
-    #[test]
-    fn unload_dll() {
-        let mut unloaded_dlls: HashSet<OsString> = HashSet::new();
-        let event =
-            // SAFETY: No pointers are passed. The handle may leak if the test fails.
-            unsafe { CreateEventA(std::ptr::null_mut(), TRUE, FALSE, std::ptr::null_mut()) };
-        assert!(
-            !event.is_null(),
-            "failed to create event; event was NULL: {}",
-            io::Error::last_os_error()
-        );
-        {
-            let test_dll_name = CString::new(TEST_DLL_NAME_2).expect("failed to create CString");
-            let _watcher = DllWatcher::new(
-                |_data| (),
-                |data| {
-                    unloaded_dlls.insert(data.base_dll_name);
-                    // SAFETY: We assert that the event is valid above.
-                    unsafe { SetEvent(event) };
-                },
-            )
-            .expect("failed to create DllWatcher");
-            // SAFETY: We pass a valid C string in to the function.
-            let h_module = unsafe { LoadLibraryA(test_dll_name.as_ptr()) };
-            assert!(
-                !h_module.is_null(),
-                "failed to load {}: {}",
-                TEST_DLL_NAME_2,
-                io::Error::last_os_error()
-            );
-            // SAFETY: We initialized h_module with a LoadLibraryA call.
-            let success = unsafe { FreeLibrary(h_module) } > 0;
-            assert!(
-                success,
-                "failed to free {}: {}",
-                TEST_DLL_NAME_2,
-                io::Error::last_os_error(),
-            )
-        };
-        // SAFETY: We assert that the event is valid above.
-        assert_eq!(unsafe { WaitForSingleObject(event, 5000) }, WAIT_OBJECT_0);
-        assert!(
-            !unloaded_dlls.is_empty(),
-            "no DLL unloads recorded by DLL watcher"
-        );
-        assert!(
-            unloaded_dlls.contains::<OsString>(&(TEST_DLL_NAME_2.to_owned().into())),
-            "{} unload wasn't recorded by DLL watcher",
-            TEST_DLL_NAME_2
-        );
-        // SAFETY: We assert that the event is valid above.
-        unsafe { CloseHandle(event) };
-    }
-}
diff --git a/win_util/src/lib.rs b/win_util/src/lib.rs
index 3b530f6bf..ef1be3f1b 100644
--- a/win_util/src/lib.rs
+++ b/win_util/src/lib.rs
@@ -17,9 +17,6 @@ mod large_integer;
 pub use crate::large_integer::*;
 
 mod security_attributes;
-pub use crate::security_attributes::*;
-
-mod dll_notification;
 use std::ffi::CString;
 use std::ffi::OsStr;
 use std::ffi::OsString;
@@ -31,6 +28,8 @@ use std::os::windows::io::RawHandle;
 use std::ptr;
 use std::slice;
 
+pub use crate::security_attributes::*;
+
 mod keyboard;
 pub use keyboard::*;
 use libc::c_ulong;
@@ -56,8 +55,6 @@ use winapi::um::winnt::HRESULT;
 use winapi::um::winnt::PROCESS_DUP_HANDLE;
 use winapi::um::winnt::WCHAR;
 
-pub use crate::dll_notification::*;
-
 pub mod dpapi;
 
 #[macro_export]
diff --git a/win_util/src/security_attributes.rs b/win_util/src/security_attributes.rs
index 0138c0291..fe94e0925 100644
--- a/win_util/src/security_attributes.rs
+++ b/win_util/src/security_attributes.rs
@@ -12,8 +12,8 @@ use std::io;
 use std::mem::size_of;
 use std::os::windows::io::RawHandle;
 use std::ptr;
+use std::sync::OnceLock;
 
-use once_cell::sync::OnceCell;
 use winapi::shared::minwindef::FALSE;
 use winapi::shared::minwindef::HLOCAL;
 use winapi::shared::minwindef::LPDWORD;
@@ -496,8 +496,8 @@ impl SelfRelativeSecurityDescriptor {
 
     /// Gets a copy of a singleton `SelfRelativeSecurityDescriptor`.
     pub fn get_singleton() -> SelfRelativeSecurityDescriptor {
-        static DEFAULT_SECURITY_DESCRIPTOR: OnceCell<SelfRelativeSecurityDescriptor> =
-            OnceCell::new();
+        static DEFAULT_SECURITY_DESCRIPTOR: OnceLock<SelfRelativeSecurityDescriptor> =
+            OnceLock::new();
         DEFAULT_SECURITY_DESCRIPTOR
             .get_or_init(|| {
                 SelfRelativeSecurityDescriptor::new().expect("Failed to create security descriptor")
diff --git a/x86_64/Android.bp b/x86_64/Android.bp
index 726e93e60..72546e253 100644
--- a/x86_64/Android.bp
+++ b/x86_64/Android.bp
@@ -41,8 +41,7 @@ rust_library {
         "libkernel_loader",
         "liblibc",
         "libminijail_rust",
-        "libonce_cell",
-        "librand",
+        "librand-0.8",
         "libresources",
         "libswap",
         "libsync_rust",
@@ -100,8 +99,7 @@ rust_test {
         "libkernel_loader",
         "liblibc",
         "libminijail_rust",
-        "libonce_cell",
-        "librand",
+        "librand-0.8",
         "libresources",
         "libswap",
         "libsync_rust",
diff --git a/x86_64/Cargo.toml b/x86_64/Cargo.toml
index efadf0fe2..7e5df310a 100644
--- a/x86_64/Cargo.toml
+++ b/x86_64/Cargo.toml
@@ -10,30 +10,29 @@ seccomp_trace = []
 swap = ["swap/enable"]
 
 [dependencies]
-acpi_tables = {path = "../acpi_tables" }
-arch = { path = "../arch" }
-anyhow = "1"
-cfg-if = "1.0.0"
+acpi_tables = { workspace = true }
+arch = { workspace = true }
+anyhow = { workspace = true }
+cfg-if = { workspace = true }
 chrono = { version = "0.4.34", default-features = false }
-cros_fdt = { path = "../cros_fdt" }
-devices = { path = "../devices" }
-gdbstub_arch = { version = "0.3.0", optional = true }
-hypervisor = { path = "../hypervisor" }
+cros_fdt = { workspace = true }
+devices = { workspace = true }
+gdbstub_arch = { workspace = true, optional = true }
+hypervisor = { workspace = true }
 jail = { path = "../jail" }
-kernel_cmdline = { path = "../kernel_cmdline" }
-kernel_loader = { path = "../kernel_loader" }
-libc = "0.2"
-once_cell = "1.7.2"
-rand = "0.8"
-remain = "0.2"
-resources = { path = "../resources" }
-sync = { path = "../common/sync" }
-thiserror = "1"
+kernel_cmdline = { workspace = true }
+kernel_loader = { workspace = true }
+libc = { workspace = true }
+rand = { workspace = true }
+remain = { workspace = true }
+resources = { workspace = true }
+sync = { workspace = true }
+thiserror = { workspace = true }
 uuid = { version = "1", features = ["v4"] }
-base = { path = "../base" }
-swap = { path = "../swap" }
-vm_control = { path = "../vm_control" }
-vm_memory = { path = "../vm_memory" }
+base = { workspace = true }
+swap = { workspace = true }
+vm_control = { workspace = true }
+vm_memory = { workspace = true }
 zerocopy = { version = "0.8.13", features = ["derive"] }
 
 [target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
diff --git a/x86_64/src/fdt.rs b/x86_64/src/fdt.rs
index bef74033a..57b517349 100644
--- a/x86_64/src/fdt.rs
+++ b/x86_64/src/fdt.rs
@@ -11,12 +11,16 @@ use std::path::PathBuf;
 
 use arch::android::create_android_fdt;
 use arch::apply_device_tree_overlays;
+use arch::fdt::create_memory_node;
+use arch::fdt::create_reserved_memory_node;
+use arch::fdt::reserved_memory_regions_from_guest_mem;
 use arch::DtbOverlay;
 use base::open_file_or_duplicate;
 use cros_fdt::Error;
 use cros_fdt::Fdt;
 use resources::AddressRange;
 use vm_memory::GuestAddress;
+use vm_memory::GuestMemory;
 
 fn create_config_node(fdt: &mut Fdt, kernel_region: AddressRange) -> cros_fdt::Result<()> {
     let addr: u32 = kernel_region
@@ -58,6 +62,7 @@ fn create_chosen_node(
 ///
 /// * `android_fstab` - the File object for the android fstab
 pub fn create_fdt(
+    guest_mem: &GuestMemory,
     android_fstab: Option<File>,
     dump_device_tree_blob: Option<PathBuf>,
     device_tree_overlays: Vec<DtbOverlay>,
@@ -65,13 +70,21 @@ pub fn create_fdt(
     initrd: Option<(GuestAddress, usize)>,
 ) -> Result<Vec<u8>, Error> {
     let mut fdt = Fdt::new(&[]);
+    let reserved_memory_regions = reserved_memory_regions_from_guest_mem(guest_mem);
+
     // The whole thing is put into one giant node with some top level properties
+    let root_node = fdt.root_mut();
+    root_node.set_prop("#address-cells", 0x2u32)?;
+    root_node.set_prop("#size-cells", 0x2u32)?;
+
     if let Some(android_fstab) = android_fstab {
         create_android_fdt(&mut fdt, android_fstab)?;
     }
 
     create_config_node(&mut fdt, kernel_region)?;
     create_chosen_node(&mut fdt, initrd)?;
+    create_memory_node(&mut fdt, guest_mem)?;
+    create_reserved_memory_node(&mut fdt, &reserved_memory_regions)?;
 
     // Done writing base FDT, now apply DT overlays
     apply_device_tree_overlays(
diff --git a/x86_64/src/lib.rs b/x86_64/src/lib.rs
index 225f77006..e06963840 100644
--- a/x86_64/src/lib.rs
+++ b/x86_64/src/lib.rs
@@ -125,7 +125,7 @@ use jail::read_jail_addr;
 use jail::FakeMinijailStub as Minijail;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use minijail::Minijail;
-use mptable::MPTABLE_START;
+use mptable::MPTABLE_RANGE;
 use multiboot_spec::MultibootInfo;
 use multiboot_spec::MultibootMmapEntry;
 use multiboot_spec::MULTIBOOT_BOOTLOADER_MAGIC;
@@ -389,7 +389,7 @@ pub const KERNEL_START_OFFSET: u64 = 0x20_0000;
 const CMDLINE_OFFSET: u64 = 0x2_0000;
 const CMDLINE_MAX_SIZE: u64 = 0x800; // including terminating zero
 const SETUP_DATA_START: u64 = CMDLINE_OFFSET + CMDLINE_MAX_SIZE;
-const SETUP_DATA_END: u64 = MPTABLE_START;
+const SETUP_DATA_END: u64 = MPTABLE_RANGE.start;
 const X86_64_SERIAL_1_3_IRQ: u32 = 4;
 const X86_64_SERIAL_2_4_IRQ: u32 = 3;
 // X86_64_SCI_IRQ is used to fill the ACPI FACP table.
@@ -744,6 +744,29 @@ fn write_setup_data(
     Ok(setup_data_list_head)
 }
 
+/// Find the first `setup_data_hdr` with the given type in guest memory and return its address.
+fn find_setup_data(
+    mem: &GuestMemory,
+    setup_data_start: GuestAddress,
+    setup_data_end: GuestAddress,
+    type_: SetupDataType,
+) -> Option<GuestAddress> {
+    let mut setup_data_addr = setup_data_start.align(8)?;
+    while setup_data_addr < setup_data_end {
+        let hdr: setup_data_hdr = mem.read_obj_from_addr(setup_data_addr).ok()?;
+        if hdr.type_ == type_ as u32 {
+            return Some(setup_data_addr);
+        }
+
+        if hdr.next == 0 {
+            return None;
+        }
+
+        setup_data_addr = GuestAddress(hdr.next);
+    }
+    None
+}
+
 /// Generate a SETUP_RNG_SEED SetupData with random seed data.
 fn setup_data_rng_seed() -> SetupData {
     let mut data = vec![0u8; 256];
@@ -1212,7 +1235,6 @@ impl arch::LinuxArch for X8664arch {
         }
 
         if mptable {
-            // Note that this puts the mptable at 0x9FC00 in guest physical memory.
             mptable::setup_mptable(&mem, vcpu_count as u8, &pci_irqs)
                 .map_err(Error::SetupMptable)?;
         }
@@ -1280,7 +1302,7 @@ impl arch::LinuxArch for X8664arch {
                 // The default values for `Regs` and `Sregs` already set up the reset vector.
             }
             VmImage::Kernel(ref mut kernel_image) => {
-                let (params, kernel_region, kernel_entry, cpu_mode, kernel_type) =
+                let (params, kernel_region, kernel_entry, mut cpu_mode, kernel_type) =
                     Self::load_kernel(&mem, kernel_image)?;
 
                 info!("Loaded {} kernel", kernel_type);
@@ -1344,6 +1366,19 @@ impl arch::LinuxArch for X8664arch {
                 }
 
                 if protection_type.runs_firmware() {
+                    // Pass DTB address to pVM firmware. This is redundant with the DTB entry in the
+                    // `setup_data` list, but it allows the pVM firmware to know the location of the
+                    // DTB without having the `setup_data` region mapped yet.
+                    if let Some(fdt_setup_data_addr) = find_setup_data(
+                        &mem,
+                        GuestAddress(SETUP_DATA_START),
+                        GuestAddress(SETUP_DATA_END),
+                        SetupDataType::Dtb,
+                    ) {
+                        vcpu_init[0].regs.rdx =
+                            fdt_setup_data_addr.offset() + size_of::<setup_data_hdr>() as u64;
+                    }
+
                     // Pass pVM payload entry address to pVM firmware.
                     // NOTE: this is only for development purposes. An actual pvmfw
                     // implementation should not use this value and should instead receive
@@ -1351,6 +1386,10 @@ impl arch::LinuxArch for X8664arch {
                     // /config/kernel-address and /config/kernel-size and determine the offset
                     // of the entry point on its own, not trust crosvm to provide it.
                     vcpu_init[0].regs.rdi = kernel_entry.offset();
+
+                    // The pVM firmware itself always starts in 64-bit long mode, regardless of
+                    // the type of payload.
+                    cpu_mode = CpuMode::LongMode;
                 }
 
                 match cpu_mode {
@@ -1749,7 +1788,7 @@ impl X8664arch {
             ));
         }
 
-        match kernel_loader::load_elf64(mem, kernel_start, kernel_image, 0) {
+        match kernel_loader::load_elf(mem, kernel_start, kernel_image, 0) {
             Ok(loaded_kernel) => {
                 // ELF kernels don't contain a `boot_params` structure, so synthesize a default one.
                 let boot_params = boot_params {
@@ -1763,7 +1802,10 @@ impl X8664arch {
                     boot_params,
                     loaded_kernel.address_range,
                     loaded_kernel.entry,
-                    CpuMode::LongMode,
+                    match loaded_kernel.class {
+                        kernel_loader::ElfClass::ElfClass32 => CpuMode::FlatProtectedMode,
+                        kernel_loader::ElfClass::ElfClass64 => CpuMode::LongMode,
+                    },
                     KernelType::Elf,
                 ))
             }
@@ -1853,6 +1895,7 @@ impl X8664arch {
             || protection_type.runs_firmware()
         {
             let device_tree_blob = fdt::create_fdt(
+                mem,
                 android_fstab,
                 dump_device_tree_blob,
                 device_tree_overlays,
diff --git a/x86_64/src/mptable.rs b/x86_64/src/mptable.rs
index e09f3d91d..87faa7c83 100644
--- a/x86_64/src/mptable.rs
+++ b/x86_64/src/mptable.rs
@@ -9,6 +9,7 @@ use std::result;
 use devices::PciAddress;
 use devices::PciInterruptPin;
 use remain::sorted;
+use resources::AddressRange;
 use thiserror::Error;
 use vm_memory::GuestAddress;
 use vm_memory::GuestMemory;
@@ -28,6 +29,9 @@ pub enum Error {
     /// There was too little guest memory to store the entire MP table.
     #[error("There was too little guest memory to store the MP table")]
     NotEnoughMemory,
+    /// More than the maximum number of supported CPUs.
+    #[error("{0} is more than the maximum number of supported CPUs")]
+    TooManyCpus(u8),
     /// Failure to write MP bus entry.
     #[error("Failure to write MP bus entry")]
     WriteMpcBus,
@@ -69,7 +73,12 @@ const APIC_VERSION: u8 = 0x14;
 const CPU_STEPPING: u32 = 0x600;
 const CPU_FEATURE_APIC: u32 = 0x200;
 const CPU_FEATURE_FPU: u32 = 0x001;
-pub const MPTABLE_START: u64 = 0x400 * 639; // Last 1k of Linux's 640k base RAM.
+/// Place the MP Floating Pointer Structure in the last kilobyte of base memory (639K-640K).
+const MP_FLOATING_POINTER_ADDR: u64 = 0x400 * 640 - size_of::<mpf_intel>() as u64;
+/// Reserve the last 6K of low memory (below 640K) just before the MP Floating Pointer Structure for
+/// the rest of the MP Table.
+pub const MPTABLE_RANGE: AddressRange =
+    AddressRange::from_start_and_end(0x400 * 634, MP_FLOATING_POINTER_ADDR - 1);
 
 fn compute_checksum(v: &[u8]) -> u8 {
     let mut checksum: u8 = 0;
@@ -85,8 +94,7 @@ fn mpf_intel_compute_checksum(v: &mpf_intel) -> u8 {
 }
 
 fn compute_mp_size(num_cpus: u8) -> usize {
-    mem::size_of::<mpf_intel>()
-        + mem::size_of::<mpc_table>()
+    mem::size_of::<mpc_table>()
         + mem::size_of::<mpc_cpu>() * (num_cpus as usize)
         + mem::size_of::<mpc_ioapic>()
         + mem::size_of::<mpc_bus>() * 2
@@ -101,8 +109,23 @@ pub fn setup_mptable(
     num_cpus: u8,
     pci_irqs: &[(PciAddress, u32, PciInterruptPin)],
 ) -> Result<()> {
+    // Write the MP Floating Pointer structure pointing at `MPTABLE_RANGE`. This structure must be
+    // in one of a few pre-defined memory areas so the OS can find it; we choose to place it in the
+    // last kilobyte of low system memory (639K-640K).
+    let mut mpf_intel = mpf_intel::default();
+    mpf_intel.signature = SMP_MAGIC_IDENT;
+    mpf_intel.length = 1;
+    mpf_intel.specification = 4;
+    mpf_intel.physptr = MPTABLE_RANGE
+        .start
+        .try_into()
+        .map_err(|_| Error::AddressOverflow)?;
+    mpf_intel.checksum = mpf_intel_compute_checksum(&mpf_intel);
+    mem.write_obj_at_addr(mpf_intel, GuestAddress(MP_FLOATING_POINTER_ADDR))
+        .map_err(|_| Error::WriteMpfIntel)?;
+
     // Used to keep track of the next base pointer into the MP table.
-    let mut base_mp = GuestAddress(MPTABLE_START);
+    let mut base_mp = GuestAddress(MPTABLE_RANGE.start);
 
     // Calculate ISA bus number in the system, report at least one PCI bus.
     let isa_bus_id = match pci_irqs.iter().max_by_key(|v| v.0.bus) {
@@ -114,7 +137,7 @@ pub fn setup_mptable(
     // The checked_add here ensures the all of the following base_mp.unchecked_add's will be without
     // overflow.
     if let Some(end_mp) = base_mp.checked_add(mp_size as u64 - 1) {
-        if !mem.address_in_range(end_mp) {
+        if !mem.address_in_range(end_mp) || !MPTABLE_RANGE.contains(end_mp.0) {
             return Err(Error::NotEnoughMemory);
         }
     } else {
@@ -125,26 +148,15 @@ pub fn setup_mptable(
         .map_err(|_| Error::Clear)?
         .write_bytes(0);
 
-    {
-        let size = mem::size_of::<mpf_intel>();
-        let mut mpf_intel = mpf_intel::default();
-        mpf_intel.signature = SMP_MAGIC_IDENT;
-        mpf_intel.length = 1;
-        mpf_intel.specification = 4;
-        mpf_intel.physptr = (base_mp.offset() + mem::size_of::<mpf_intel>() as u64) as u32;
-        mpf_intel.checksum = mpf_intel_compute_checksum(&mpf_intel);
-        mem.write_obj_at_addr(mpf_intel, base_mp)
-            .map_err(|_| Error::WriteMpfIntel)?;
-        base_mp = base_mp.unchecked_add(size as u64);
-    }
-
     // We set the location of the mpc_table here but we can't fill it out until we have the length
     // of the entire table later.
     let table_base = base_mp;
     base_mp = base_mp.unchecked_add(mem::size_of::<mpc_table>() as u64);
 
     let mut checksum: u8 = 0;
-    let ioapicid: u8 = num_cpus + 1;
+    let ioapicid: u8 = num_cpus
+        .checked_add(1)
+        .ok_or(Error::TooManyCpus(num_cpus))?;
 
     for cpu_id in 0..num_cpus {
         let size = mem::size_of::<mpc_cpu>();
@@ -356,14 +368,10 @@ pub fn setup_mptable(
 
 #[cfg(test)]
 mod tests {
-    use base::pagesize;
-
     use super::*;
 
-    fn compute_page_aligned_mp_size(num_cpus: u8) -> u64 {
-        let mp_size = compute_mp_size(num_cpus);
-        let pg_size = pagesize();
-        (mp_size + pg_size - (mp_size % pg_size)) as u64
+    fn test_guest_mem() -> GuestMemory {
+        GuestMemory::new(&[(GuestAddress(0), 640 * 1024)]).unwrap()
     }
 
     fn table_entry_size(type_: u8) -> usize {
@@ -380,11 +388,7 @@ mod tests {
     #[test]
     fn bounds_check() {
         let num_cpus = 4;
-        let mem = GuestMemory::new(&[(
-            GuestAddress(MPTABLE_START),
-            compute_page_aligned_mp_size(num_cpus),
-        )])
-        .unwrap();
+        let mem = test_guest_mem();
 
         setup_mptable(&mem, num_cpus, &[]).unwrap();
     }
@@ -392,7 +396,7 @@ mod tests {
     #[test]
     fn bounds_check_fails() {
         let num_cpus = 255;
-        let mem = GuestMemory::new(&[(GuestAddress(MPTABLE_START), 0x1000)]).unwrap();
+        let mem = test_guest_mem();
 
         assert!(setup_mptable(&mem, num_cpus, &[]).is_err());
     }
@@ -400,15 +404,13 @@ mod tests {
     #[test]
     fn mpf_intel_checksum() {
         let num_cpus = 1;
-        let mem = GuestMemory::new(&[(
-            GuestAddress(MPTABLE_START),
-            compute_page_aligned_mp_size(num_cpus),
-        )])
-        .unwrap();
+        let mem = test_guest_mem();
 
         setup_mptable(&mem, num_cpus, &[]).unwrap();
 
-        let mpf_intel = mem.read_obj_from_addr(GuestAddress(MPTABLE_START)).unwrap();
+        let mpf_intel = mem
+            .read_obj_from_addr(GuestAddress(MP_FLOATING_POINTER_ADDR))
+            .unwrap();
 
         assert_eq!(mpf_intel_compute_checksum(&mpf_intel), mpf_intel.checksum);
     }
@@ -416,15 +418,13 @@ mod tests {
     #[test]
     fn mpc_table_checksum() {
         let num_cpus = 4;
-        let mem = GuestMemory::new(&[(
-            GuestAddress(MPTABLE_START),
-            compute_page_aligned_mp_size(num_cpus),
-        )])
-        .unwrap();
+        let mem = test_guest_mem();
 
         setup_mptable(&mem, num_cpus, &[]).unwrap();
 
-        let mpf_intel: mpf_intel = mem.read_obj_from_addr(GuestAddress(MPTABLE_START)).unwrap();
+        let mpf_intel: mpf_intel = mem
+            .read_obj_from_addr(GuestAddress(MP_FLOATING_POINTER_ADDR))
+            .unwrap();
         let mpc_offset = GuestAddress(mpf_intel.physptr as u64);
         let mpc_table: mpc_table = mem.read_obj_from_addr(mpc_offset).unwrap();
 
@@ -441,16 +441,14 @@ mod tests {
     #[test]
     fn cpu_entry_count() {
         const MAX_CPUS: u8 = 0xff;
-        let mem = GuestMemory::new(&[(
-            GuestAddress(MPTABLE_START),
-            compute_page_aligned_mp_size(MAX_CPUS),
-        )])
-        .unwrap();
+        let mem = test_guest_mem();
 
         for i in 0..MAX_CPUS {
             setup_mptable(&mem, i, &[]).unwrap();
 
-            let mpf_intel: mpf_intel = mem.read_obj_from_addr(GuestAddress(MPTABLE_START)).unwrap();
+            let mpf_intel: mpf_intel = mem
+                .read_obj_from_addr(GuestAddress(MP_FLOATING_POINTER_ADDR))
+                .unwrap();
             let mpc_offset = GuestAddress(mpf_intel.physptr as u64);
             let mpc_table: mpc_table = mem.read_obj_from_addr(mpc_offset).unwrap();
             let mpc_end = mpc_offset.checked_add(mpc_table.length as u64).unwrap();
```

